<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

    
      <link rel="icon" href="/favicon.png" />
    

    <title>
        
          计网 CyC2018 之网络层 - aha&#39;s book
        
    </title>

    <!-- Spectre.css framework -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-exp.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-icons.min.css">

    <!-- theme css & js -->
    
<link rel="stylesheet" href="/css/book.css">

    
<script src="/js/book.js"></script>


    <!-- tocbot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
    
    <!-- katex -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">

    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/zooming/2.1.1/zooming.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    const zooming = new Zooming()
    zooming.listen('.book-content img')
})
</script>

<meta name="generator" content="Hexo 6.3.0"></head>
    <style>
      body {
        background-color: #FFFFFF;
        /* color: #000000; */
        transition: background-color 0.3s ease, color 0.3s ease;
      }

      /* Floating Button Styles */
      .floating-button {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 999;
        background-color: #000000;
        color: #ffffff;
        padding: 12px;
        border-radius: 50%;
        cursor: pointer;
        border: 2px solid #000000;
      }

      .floating-button:hover {
        background-color: #FFFFFF;
      }

      /* Dropdown Menu Styles */
      .dropdown-menu {
        position: fixed;
        bottom: 60px;
        right: 10px;
        display: none;
        min-width: 60px;
        padding: 2px;
        background-color: #fff;
        /* box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); */
        z-index: 1000;
      }

      .floating-button.active+.dropdown-menu {
        display: block;
      }

      .dropdown-item {
        display: block;
        padding: 8px 16px;
        cursor: pointer;
      }

      .dropdown-item:hover {
        background-color: #f5f5f5;
      }
    </style>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body>
  <div class="book-container">
    <div class="book-sidebar">
      <div class="book-brand">
  <a href="/">
    <img src="/favicon.png">
    <span>AHA&#39;S BOOK</span>
  </a>
</div>
        <div id="menu" class="book-menu hide">
  <h2 id="基础知识"> 基础知识 </h2>
<ul>
<li><a href="/posts/231010144856.html"> 模运算 </a></li>
<li><a href="/posts/231014105311.html"> 异或运算 </a></li>
<li><a href="/posts/231210181853.html"> 计算机中的寄存器 </a></li>
<li><a href="/posts/231213183051.html"> 正则表达式基础 </a></li>
</ul>
<h2 id="C 语言">C 语言 </h2>
<ul>
<li><a href="/posts/230916171929.html">main 函数参数 </a></li>
<li><a href="/posts/231214192113.html"> 关键字与专有名词 </a></li>
<li><a href="/posts/240103180653.html"> 输出打印函数 </a></li>
<li><a href="/posts/230922143003.html"> 多维数组 </a></li>
<li><a href="/posts/230913200729.html">const 关键字 </a></li>
<li><a href="/posts/230918174223.html">typedef 类型基础 </a></li>
<li><a href="/posts/230920172849.html">typedef 类型实践 </a></li>
<li><a href="/posts/240224193217.html"> 二级指针 </a></li>
<li><a href="/posts/240307195203.html"> 代码 TOP-K 问题 </a></li>
<li><a href="/posts/230922172626.html">uthash 哈希表基础 </a></li>
<li><a href="/posts/230918114841.html"> 大小端知识 </a></li>
</ul>
<h2 id="Golang 语言">Golang 语言 </h2>
<ul>
<li><a href="/posts/230907162612.html"> 变量与常量 </a></li>
<li><a href="/posts/230909120145.html"> 函数 &amp; 包 &amp; 判断 &amp; 循环 </a></li>
<li><a href="/posts/230912152800.html"> 数组与切片 </a></li>
<li><a href="/posts/230913161326.html"> 可变参数函数与 Map 集合 </a></li>
<li><a href="/posts/230915155105.html"> 字符串和指针 </a></li>
</ul>
<h2 id="数据结构"> 数据结构 </h2>
<ul>
<li><a href="/posts/231007174854.html"> 链表（数组实现）</a></li>
<li><a href="/posts/231008213450.html"> 链表（链式实现）</a></li>
<li><a href="/posts/231016161508.html"> 堆栈（数组实现）</a></li>
<li><a href="/posts/231016184406.html"> 堆栈（链表实现）</a></li>
<li><a href="/posts/231127185207.html"> 单调栈 </a></li>
<li><a href="/posts/231017105123.html"> 队列（链表实现）</a></li>
<li><a href="/posts/231017154121.html"> 双端队列（链表实现）</a></li>
<li><a href="/posts/231018102559.html"> 堆基础与堆结构（数组实现）</a></li>
<li><a href="/posts/231019102311.html"> 优先队列（堆实现）</a></li>
<li><a href="/posts/230905224335.html"> 二叉树的遍历 </a></li>
<li><a href="/posts/231020174358.html"> 二叉搜索树 </a></li>
<li><a href="/posts/230916094606.html"> 拓扑排序 </a></li>
<li><a href="/posts/230925185057.html">Trie 字典树 </a></li>
<li><a href="/posts/231023164532.html"> 并查集（数组实现）</a></li>
<li><a href="/posts/240702200642.html">Linux 数据结构之队列 </a></li>
</ul>
<h2 id="数据结构算法"> 数据结构算法 </h2>
<ul>
<li><a href="/posts/231218181635.html"> 归并排序 </a></li>
<li><a href="/posts/231108163339.html"> 快速排序 </a></li>
<li><a href="/posts/231107171607.html"> 堆排序 </a></li>
<li><a href="/posts/231124181658.html"> 二分查找 </a></li>
<li><a href="/posts/231227190828.html"> 哈希表实现 </a></li>
<li><a href="/posts/240313193201.html"> 字符串哈希函数 </a></li>
<li><a href="/posts/231116150205.html">Floyd 多源最短路径 </a></li>
<li><a href="/posts/231117095232.html">Dijkstra 单源最短路径（原理部分）</a></li>
<li><a href="/posts/231121152713.html">Dijkstra 单源最短路径（实现部分）</a></li>
</ul>
<h2 id="数据库"> 数据库 </h2>
<ul>
<li><a href="/posts/250605180332.html">MySQL 基础 </a></li>
</ul>
<h2 id="计算机网络"> 计算机网络 </h2>
<ul>
<li><a href="/posts/231011192359.html">OSI 参考模型 </a></li>
<li><a href="/posts/240329202000.html"> 计网 CyC2018 之概述 </a></li>
<li><a href="/posts/240329202004.html"> 计网 CyC2018 之链路层 </a></li>
<li><a href="/posts/240329202003.html"> 计网 CyC2018 之网络层 </a></li>
<li><a href="/posts/240329202002.html"> 计网 CyC2018 之传输层 </a></li>
<li><a href="/posts/240329202001.html"> 计网 CyC2018 之应用层 </a></li>
<li><a href="/posts/240306203742.html">ACL 访问控制列表 </a></li>
<li><a href="/posts/240130190208.html"> 路由表、转发表与快速转发工作原理 </a></li>
<li><a href="/posts/231221200716.html">VXLAN 网络虚拟化技术 </a></li>
<li><a href="/posts/240903191243.html">TCP/IP checksum 计算 </a></li>
<li><a href="/posts/240911185603.html"> 抓包分析 TCP 三次握手与四次挥手过程 </a></li>
</ul>
<h2 id="操作系统"> 操作系统 </h2>
<ul>
<li><a href="/posts/230921190726.html"> 概述 </a></li>
<li><a href="/posts/230924172528.html"> 中断 &amp; 异常 &amp; 系统调用 </a></li>
<li><a href="/posts/231017195157.html"> 内存分层体系与地址空间生成 </a></li>
<li><a href="/posts/231108195351.html"> 连续内存分配 </a></li>
<li><a href="/posts/231111172507.html"> 非连续内存分配之分段与分页 </a></li>
<li><a href="/posts/231119170537.html"> 非连续内存分配之页表 </a></li>
<li><a href="/posts/231123184526.html"> 内存管理之覆盖技术与交换技术 </a></li>
<li><a href="/posts/231127193658.html"> 内存管理之虚存技术 </a></li>
<li><a href="/posts/231129182631.html"> 局部页面置换算法 </a></li>
<li><a href="/posts/231207184239.html"> 全局页面置换算法 </a></li>
<li><a href="/posts/231207204958.html"> 进程描述 </a></li>
<li><a href="/posts/231210211306.html"> 进程状态 </a></li>
<li><a href="/posts/231215213932.html"> 线程 </a></li>
<li><a href="/posts/231218220813.html"> 进程控制 </a></li>
<li><a href="/posts/231228193143.html"> 调度 </a></li>
<li><a href="/posts/240104202828.html"> 同步与互斥 </a></li>
<li><a href="/posts/240113115605.html"> 信号量与管程 </a></li>
<li><a href="/posts/240205182643.html"> 经典同步问题 </a></li>
<li><a href="/posts/240310162231.html"> 死锁 </a></li>
</ul>
<h2 id="系统与网络编程"> 系统与网络编程 </h2>
<ul>
<li><a href="/posts/230911151334.html">pthread 库 </a></li>
<li><a href="/posts/230921094127.html"> 锁与原子操作 </a></li>
<li><a href="/posts/240319195609.html"> 读者写者问题 </a></li>
<li><a href="/posts/240527200241.html"> 网络编程卷一阅读随笔 </a></li>
<li><a href="/posts/240414190410.html"> 进程间通信 IPC 机制 </a></li>
<li><a href="/posts/240424200123.html"> 多进程相关练习 </a></li>
<li><a href="/posts/240516221527.html">I/O 模式与 I/O 多路复用 </a></li>
<li><a href="/posts/240626192803.html">Linux 内核 kfifo 环形队列 </a></li>
<li><a href="/posts/241009203126.html">Linux 内核等待队列 </a></li>
<li><a href="/posts/240627210637.html">DPDK 无锁环形队列 </a></li>
<li><a href="/posts/240919200410.html"> 解密内存屏障 </a></li>
<li><a href="/posts/240927202500.html"> 内核线程的创建 </a></li>
<li><a href="/posts/241015195205.html">Linux 网络数据包接收过程 </a></li>
<li><a href="/posts/2410232111015.html"> 源码解读 epoll 实现原理 </a></li>
<li><a href="/posts/241106182619.html">Linux 文件系统 </a></li>
<li><a href="/posts/250619154429.html">Libevent 高性能 IO 事件驱动库 </a></li>
<li><a href="/posts/251119185833.html">Linux UDP 传输性能优化 </a></li>
<li><a href="/posts/251202101130.html">Linux 零拷贝技术 </a></li>
<li><a href="/posts/251124150921.html">QUIC 协议 </a></li>
</ul>
<h2 id="工具与命令"> 工具与命令 </h2>
<ul>
<li><a href="/posts/240207180410.html">GCC 编译过程分解 </a></li>
<li><a href="/posts/240312184132.html">GDB 调试入门 </a></li>
<li><a href="/posts/240512184921.html">Makefile 学习 </a></li>
<li><a href="/posts/250629214430.html">CMake 学习 </a></li>
<li><a href="/posts/240417193754.html">Linux 命令之文件权限 </a></li>
</ul>
<h2 id="开源项目"> 开源项目 </h2>
<ul>
<li><a href="/posts/240303201855.html"> 线程池原理与实现 </a></li>
<li><a href="/posts/240507194549.html">HTTP 服务器实现 </a></li>
<li><a href="/posts/240904203605.html"> 聊天服务器实现 </a></li>
<li><a href="/posts/241119182636.html">Linux 文件系统 </a></li>
</ul>
<h2 id="Docker">Docker</h2>
<ul>
<li><a href="/posts/230909171809.html">Docker 学习笔记 </a></li>
</ul>
<h1 id="LeetCode 刷题">LeetCode 刷题 </h1>
<h2 id="链表相关"> 链表相关 </h2>
<ul>
<li><a href="/posts/231025143947.html">160 相交链表 </a></li>
<li><a href="/posts/231025185947.html">206 反转链表 </a></li>
<li><a href="/posts/231026101239.html">21 合并两个有序链表 </a></li>
<li><a href="/posts/231026184514.html">83 删除排序链表中的重复元素 </a></li>
<li><a href="/posts/231027150243.html">19 删除链表的倒数第 N 个节点 </a></li>
<li><a href="/posts/231031120718.html">2 两数相加 </a></li>
<li><a href="/posts/231031163133.html">445 两数相加 II</a></li>
<li><a href="/posts/231101094219.html">234 回文链表 </a></li>
<li><a href="/posts/231101135228.html">725 分隔链表 </a></li>
<li><a href="/posts/231102120708.html">328 奇偶链表 </a></li>
<li><a href="/posts/231102165703.html">142 环形链表 II</a></li>
</ul>
<h2 id="设计"> 设计 </h2>
<ul>
<li><a href="/posts/231201184542.html">146 LRU 缓存 </a></li>
</ul>
<h2 id="贪心算法"> 贪心算法 </h2>
<ul>
<li><a href="/posts/231107094652.html">1029 两地调度 </a></li>
<li><a href="/posts/231109150855.html">435 无重叠区间 </a></li>
</ul>
<h2 id="哈希表"> 哈希表 </h2>
<ul>
<li><a href="/posts/231123181539.html">1410 实体解析器 </a></li>
</ul>
<h2 id="树的遍历"> 树的遍历 </h2>
<ul>
<li><a href="/posts/231103121209.html">117 填充每个节点的下一个右侧节点指针 II</a></li>
</ul>
<h2 id="深度优先搜索（递归）"> 深度优先搜索（递归）</h2>
<ul>
<li><a href="/posts/231206201243.html">2477 达到首都的最少油耗 </a></li>
</ul>
<h2 id="图或路径问题"> 图或路径问题 </h2>
<ul>
<li><a href="/posts/231211184652.html">1631 最小体力消耗路径 </a></li>
</ul>
<h2 id="其它"> 其它 </h2>
<ul>
<li><a href="/posts/230101120000.html"> 备忘录 </a></li>
</ul>

</div>


<script src="/js/book-menu.js"></script>

    </div>
    <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
  <div class="sidebar-toggle-inner"></div>
</div>

<script>
function add_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.add('show')  
}

function remove_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.remove('show')
}

function sidebar_toggle() {
    let sidebar_toggle = document.querySelector('.sidebar-toggle')
    let sidebar = document.querySelector('.book-sidebar')
    let content = document.querySelector('.off-canvas-content')
    if (sidebar_toggle.classList.contains('extend')) { // show
        sidebar_toggle.classList.remove('extend')
        sidebar.classList.remove('hide')
        content.classList.remove('extend')
    }
    else { // hide
        sidebar_toggle.classList.add('extend')
        sidebar.classList.add('hide')
        content.classList.add('extend')
    }
}
</script>

      <div class="off-canvas-content">
        <div class="columns">
          <div class="column col-10 col-lg-12">
            <div class="book-navbar">
              <!-- For Responsive Layout -->

<header class="navbar">
  <section class="navbar-section">
    <a onclick="open_sidebar()">
      <i class="icon icon-menu"></i>
    </a>
  </section>
</header>

            </div>
            <div class="book-content">
              <div class="book-post">
  <h1 id="计算机网络 - 网络层">计算机网络 - 网络层</h1>
<!-- GFM-TOC -->
<ul>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%BD%91%E7%BB%9C%E5%B1%82">计算机网络 - 网络层</a>
<ul>
<li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li>
<li><a href="#IP-%20%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F">IP 数据报格式</a></li>
<li><a href="#IP-%20%E5%9C%B0%E5%9D%80%E7%BC%96%E5%9D%80%E6%96%B9%E5%BC%8F">IP 地址编址方式</a>
<ul>
<li><a href="#1-%20%E5%88%86%E7%B1%BB">1. 分类</a></li>
<li><a href="#2-%20%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86">2. 子网划分</a></li>
<li><a href="#3-%20%E6%97%A0%E5%88%86%E7%B1%BB">3. 无分类</a></li>
</ul>
</li>
<li><a href="#%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE%20-ARP">地址解析协议 ARP</a></li>
<li><a href="#%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE%20-ICMP">网际控制报文协议 ICMP</a>
<ul>
<li><a href="#1-Ping">1. Ping</a></li>
<li><a href="#2-Traceroute">2. Traceroute</a></li>
</ul>
</li>
<li><a href="#%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91%20-VPN">虚拟专用网 VPN</a></li>
<li><a href="#%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%20-NAT">网络地址转换 NAT</a></li>
<li><a href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84">路由器的结构</a></li>
<li><a href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B">路由器分组转发流程</a></li>
<li><a href="#%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%86%E7%B1%BB">路由协议的分类</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE">动态路由选择协议</a>
<ul>
<li><a href="#1-%20%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE%20-RIP">1. 内部网关协议 RIP</a></li>
<li><a href="#2-%20%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE%20-OSPF">2. 内部网关协议 OSPF</a></li>
<li><a href="#3-%20%E5%A4%96%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE%20-BGP">3. 外部网关协议 BGP</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- GFM-TOC -->
<h2 id="概述">概述</h2>
<p>因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。<u>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的 </u> 数据报服务。</p>
<p>使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8d779ab7-ffcc-47c6-90ec-ede8260b2368.png" width="800"/> </div><br>
<p>与 IP 协议配套使用的还有三个协议：</p>
<ul>
<li>地址解析协议 ARP（Address Resolution Protocol）</li>
<li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li>
<li>网际组管理协议 IGMP（Internet Group Management Protocol）</li>
</ul>
<h2 id="IP- 数据报格式">IP 数据报格式</h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/85c05fb1-5546-4c50-9221-21f231cdc8c5.jpg" width="700"/> </div><br>
<ul>
<li><strong>版本</strong>：有 4（IPv4）和 6（IPv6）两个值；</li>
<li><strong>首部长度</strong>：占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li>
<li><strong>区分服务</strong>：用来获得更好的服务，可以理解为赋予报文不同优先级的一个字段，一般情况下不使用。</li>
<li><strong>总长度</strong>：包括首部长度和数据部分长度。</li>
<li><strong>生存时间 TTL</strong>：它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 减为 0 时就丢弃数据报。</li>
<li><strong>协议</strong>：指出携带的数据应该上交给哪个协议进行处理，例如 <u>ICMP</u>、TCP、UDP 等。</li>
<li><strong>首部检验和 </strong>：因为数据报<u> 每经过一个路由器，都要重新计算检验和 </u>，因此检验和计算<u> 不包含数据部分</u>，以减少计算的工作量。</li>
<li><strong>唯一标识 ID</strong>：不同数据报具有不同的唯一标识。在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li>
<li><strong>片偏移</strong>：和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</li>
<li><strong>分片标志位 Flags</strong>：包括不分片（DF）和更多片（MF）标志位。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/23ba890e-e11c-45e2-a20c-64d217f83430.png" width="700"/> </div><br>
<blockquote>
<p>IP 数据报发生分片后，不同分片的首部中，唯一标识字段相同、片偏移字段不同、首部校验和不同；DF 标志位通常是相同的，而 MF 标志位则用于指示是否还有后续片。</p>
</blockquote>
<h2 id="IP- 地址编址方式">IP 地址编址方式</h2>
<p>IP 地址的编址方式经历了三个历史阶段：分类、子网划分、无分类。</p>
<h3 id="1- 分类">1. 分类</h3>
<p>由两部分组成，<strong>网络号（Network ID）和主机号（Host ID）</strong>，其中 <u> 不同分类具有不同的网络号长度，并且是固定的</u>。</p>
<p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cbf50eb8-22b4-4528-a2e7-d187143d57f7.png" width="500"/> </div><br>
<h3 id="2- 子网划分">2. 子网划分</h3>
<p>通过 <u> 在主机号字段中拿一部分作为子网号</u>，把两级 IP 地址划分为三级 IP 地址。</p>
<p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p>
<p><strong>要使用子网，必须配置子网掩码</strong>。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p>
<blockquote>
<p>注意，外部网络看不到子网的存在。</p>
</blockquote>
<h3 id="3- 无分类">3. 无分类</h3>
<p>无分类编址（Classless Inter-Domain Routing, CIDR）消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，<u>使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化</u>。</p>
<p>IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}</p>
<p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀（子网掩码长度为 20）。</p>
<p>CIDR 的地址掩码可以继续称为子网掩码，网络前缀的长度等于子网掩码的首位连续为 1 的长度。</p>
<p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为 <strong> 路由聚合</strong>，也称为构成超网。</p>
<p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当 <u> 采用最长前缀匹配原则 </u> 来确定应该匹配哪一个。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[RTA]display ip routing-table                                                   </span><br><span class="line">                                                                                </span><br><span class="line">Destinations : 4 Routes : 4                                                     </span><br><span class="line">                                                                                </span><br><span class="line">Destination/Mask   Proto   Pre Cost        NextHop         Interface            </span><br><span class="line">0.0.0.0/32         Direct  0   0           127.0.0.1       InLoop0              </span><br><span class="line">10.20.1.0/24       Direct  0   0           10.20.1.11      GE0/0/0              </span><br><span class="line">10.20.1.11/32      Direct  0   0           127.0.0.1       InLoop0              </span><br><span class="line">10.20.1.255/32     Direct  0   0           10.20.1.11      GE0/0/0              </span><br><span class="line">[RTA]</span><br></pre></td></tr></table></figure>
<h2 id="地址解析协议 -ARP">地址解析协议 ARP</h2>
<p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此 <u> 在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变</u>。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/66192382-558b-4b05-a35d-ac4a2b1a9811.jpg" width="700"/> </div><br>
<p><strong>ARP 协议用于将 IP 地址映射到对应的 MAC 地址</strong>。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b9d79a5a-e7af-499b-b989-f10483e71b8b.jpg" width="500"/> </div><br>
<blockquote>
<p>ICMP 和 IGMP 属于网络层，但是作为 IP 数据报的数据部分存在。因此图中画在了 IP 之外。</p>
</blockquote>
<p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;RTA&gt;display arp                                                                </span><br><span class="line">   Type: S-Static    D-Dynamic    O-Openflow   R-Rule   I-Invalid               </span><br><span class="line">IP address      MAC address    VLAN/VSI name Interface/Link ID        Aging Type</span><br><span class="line">30.0.0.2        0000-00a1-231e --            GE0/1                    11    D   </span><br><span class="line">10.20.1.30      912b-b058-7eba --            GE0/0                    15    D   </span><br><span class="line">10.20.1.31      9010-bae2-7046 --            GE0/0                    15    D   </span><br><span class="line">&lt;RTA&gt;                                                                           </span><br></pre></td></tr></table></figure>
<p>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时 <mark> 主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址</mark>，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8006a450-6c2f-498c-a928-c927f758b1d0.png" width="700"/> </div><br>
<h2 id="网际控制报文协议 -ICMP">网际控制报文协议 ICMP</h2>
<p>ICMP 用于在 IP 网络中传送控制信息和错误消息，它 <u> 通常用于网络设备之间进行通信，以诊断网络问题和报告错误</u>。</p>
<p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。<u>ICMP 封装在 IP 数据报中</u>（作为数据部分），但是不属于高层协议，而是一种在 IP 层之上的协议。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e3124763-f75e-46c3-ba82-341e6c98d862.jpg" width="500"/> </div><br>
<p>ICMP 报文分为差错报告报文和询问报文，通常是 <u> 由网络设备生成并发送</u>。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/aa29cc88-7256-4399-8c7f-3cf4a6489559.png" width="600"/> </div><br>
<h3 id="1-Ping">1. Ping</h3>
<p>Ping 是 ICMP 的一个重要应用，主要 <u> 用来测试两台主机之间的连通性</u>。</p>
<p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p>
<h3 id="2-Traceroute">2. Traceroute</h3>
<p>Traceroute 是 ICMP 的另一个应用，<u>用来跟踪一个分组从源点到终点的路径</u>。</p>
<p>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p>
<ul>
<li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并 <u> 向源主机发送一个 ICMP 时间超过差错报告报文</u>；</li>
<li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并 <u> 向源主机发送一个 ICMP 时间超过差错报告报文</u>；</li>
<li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，目的主机要 <u> 向源主机发送 ICMP 终点不可达差错报告报文</u>。</li>
<li><strong>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间</strong>。</li>
</ul>
<h2 id="虚拟专用网 -VPN">虚拟专用网 VPN</h2>
<p>由于 IP 地址的紧缺，一个 <u> 机构能申请到的 IP 地址数往往 <strong> 远小于 </strong> 本机构所拥有的主机数</u>。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p>
<p>有三个专用地址块：</p>
<ul>
<li>10.0.0.0 ~ 10.255.255.255</li>
<li>172.16.0.0 ~ 172.31.255.255</li>
<li>192.168.0.0 ~ 192.168.255.255</li>
</ul>
<p>VPN <u>使用公用的互联网作为 </u> 本机构各专用网之间的 <u> 通信载体</u>。“专用”指机构内的主机只与本机构内的其它主机通信；“虚拟”指好像是、而实际上并不是，它有经过公用的互联网。</p>
<p>下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。IP 数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1556770b-8c01-4681-af10-46f1df69202c.jpg" width="800"/> </div><br>
<h2 id="网络地址转换 -NAT">网络地址转换 NAT</h2>
<p>专用网内部的主机使用本地 IP 地址，但又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。</p>
<p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，<u>现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址 </u>。使用端口号的 NAT 也叫做<strong> 网络地址与端口转换 NAPT</strong>。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2719067e-b299-4639-9065-bed6729dbf0b.png" width=""/> </div><br>
<h2 id="路由器的结构">路由器的结构</h2>
<p>路由器从功能上可以划分为：<strong>路由选择和分组转发</strong>。路由选择是指路由器根据网络中各设备之间的通信需求，选择最佳的传输路径进行数据转发；而分组转发则是指路由器将收到的数据包按照特定的规则进行处理和转发。</p>
<p>分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c3369072-c740-43b0-b276-202bd1d3960d.jpg" width="600"/> </div><br>
<blockquote>
<p>交换结构是指路由器内部用于处理和转发数据包的组件，通常包括转发表、邻接表、缓存等。</p>
</blockquote>
<h2 id="路由器分组转发流程">路由器分组转发流程</h2>
<p>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N：</p>
<ol>
<li>若 N 就是与此路由器 <u> 直接相连 </u> 的某个网络地址，则进行直接交付；</li>
<li>若路由表中有 <u> 目的地址 </u> 为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li>
<li>若路由表中有到达 <u> 网络地址 </u> 为 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li>
<li>若路由表中有一个 <u> 默认路由</u>，则把数据报传送给路由表中所指明的默认路由器；</li>
<li>报告转发分组出错。</li>
</ol>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1ab49e39-012b-4383-8284-26570987e3c4.jpg" width="800"/> </div><br>
<h2 id="路由协议的分类">路由协议的分类</h2>
<p>路由分类：</p>
<ul>
<li><strong>直连路由 </strong>：路由器直连接口所在的网络，当<u> 接口物理和协议状态都 UP 时 </u> 自动学习到路由表。</li>
<li><strong>静态路由 </strong>：根据数据访问需要<u> 手工 </u> 在每台设备上进行添加和维护的路由。</li>
<li><strong>动态路由协议</strong>：路由器自动进行路由信息的更新和同步，并且当网络拓扑变更时，能够自动收敛。</li>
</ul>
<p>不同路由协议的优先级，值越低优先级越高（不同厂商的优先级定义可能不同）：</p>
<img src="../images/computer-network/router-preference.png" alt="路由协议优先级" width="50%" height="50%">
<h2 id="动态路由选择协议">动态路由选择协议</h2>
<p>动态路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p>
<p>互联网可以划分为许多较小的自治系统（Autonomous System, AS），一个 AS 可以使用一种不同于其他 AS 的路由选择协议。</p>
<p>可以把 <strong> 动态路由选择协议 </strong> 划分为两大类：</p>
<ul>
<li>自洽系统 <strong> 内</strong>网关间交换路由的内部网关协议（Interior Gateway Protocol, IGP），包括：RIP、OSPF、IS-IS；</li>
<li>自治系统 <strong> 间</strong>交换路由的外部网关协议（External Gateway Protocol, EGP），包括：BGP（Border Gateway Protocol）。</li>
</ul>
<table>
<thead>
<tr>
<th><div style="width: 80px">项目</div></th>
<th><div style="width: 80px">RIP</div></th>
<th>OSPF</th>
<th>IS-IS</th>
</tr>
</thead>
<tbody>
<tr>
<td>协议类型</td>
<td>IP 层协议</td>
<td>IP 层协议</td>
<td>链路层协议</td>
</tr>
<tr>
<td>适用范围</td>
<td>适用于规模较小的网络中</td>
<td>适用于规模适用的网络中</td>
<td>适用于规模较大的网络中</td>
</tr>
<tr>
<td>路由算法</td>
<td>采用距离矢量算法</td>
<td>采用 SPF（Shortest Path First，最短路径优先）算法。通告 LSA（Link State Advertisement，链路状态通告）描述网络拓扑，根据网络拓扑生成一颗 SPT（Shortest Path Tree，最短路径树），计算出到网络中所有目的地的最短路径，并进行路由信息的交换</td>
<td>采用 SPF（Shortest Path First，最短路径优先）算法。根据网络拓扑生成一颗 SPT（Shortest Path Tree，最短路径树），计算出到网络中所有目的地的最短路径</td>
</tr>
<tr>
<td>收敛速度</td>
<td>收敛速度慢</td>
<td>收敛速度快</td>
<td>收敛速度快</td>
</tr>
<tr>
<td>扩展性</td>
<td>不能扩展</td>
<td>通过划分区域增强 OSPF 网络的可扩展性</td>
<td>通过 Level 路由器增强 IS-IS 网络的可扩展性</td>
</tr>
</tbody>
</table>
<p>按协议类型分类：</p>
<ul>
<li>距离矢量协议：RIP、BGP</li>
<li>链路状态协议：OSPF、IS-IS</li>
</ul>
<h3 id="1- 内部网关协议 -RIP">1. 内部网关协议 RIP</h3>
<p>RIP (Routing Information Protocol) 是一种 <u> 基于距离矢量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达</u>。</p>
<p><strong>原理：RIP 按固定的时间间隔仅和直接相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址</strong>。</p>
<p>使用距离矢量路由协议的路由器，并不了解网络的拓扑结构，该路由器只知道：</p>
<ol>
<li>自身与目的网络之间的距离（跳数）；</li>
<li>应该使用哪个出接口转发数据包。</li>
</ol>
<img src="../images/computer-network/RIP-1.png" alt="RIP 转发数据示意图" width="60%" height="60%">
<p>初始的直连路由，经过两次路由交换之后收敛完成，各个路由器的路由表：</p>
<img src="../images/computer-network/RIP-2-merged.png" alt="RIP 路由交换过程" width="100%" height="100%">
<blockquote>
<p>为什么后续交换没有表项更新了呢？</p>
<p>以路由器 C 中的路由 <code>10.0.1.0, G0/0/0, 2</code> 为例，它通过路由器 B 的 <code>G0/0/1</code> 扩散到路由器 B，假设会“形成”一个表项 <code>10.0.1.0, G0/0/1, 2+1</code>，但该路由器有一个更优的表项 <code>10.0.1.0, G0/0/0, 1 &lt; (2+1)</code> 可以到达目的网段，所以交换不会更新表项。</p>
</blockquote>
<p><strong>距离矢量算法大致步骤</strong>：</p>
<p>对地址为 X 的路由器的多个相邻路由器发来的 RIP 报文，先修改报文中的所有 entry ，把下一跳字段中的地址改为 X，并把所有的距离字段加 1。对修改后的 RIP 报文中的每一个 entry ，进行以下步骤：</p>
<ol>
<li>若路由器 X 的原路由表中没有目的网络 N，则把该 entry 添加到该路由表中；</li>
<li>否则：若下一跳路由器地址就是 X，则把收到的 entry 替换掉原来路由表中的 entry ；否则：若收到的 entry 中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2: 5, Y，新表项为 Net2: 4, X，则更新）；否则什么也不做。</li>
</ol>
<p>若 3 分钟（即 6 次 RIP 消息广播的时间）还没有收到相邻路由器的更新路由表，则路由器 X 把该相邻路由器标为不可达（将距离置为 16）。</p>
<p><strong>伪代码（仅供参考）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">for each neighboring routers of X:</span><br><span class="line">    if RIP message received from neighboring router:</span><br><span class="line">        modify nexthop address to X&#x27;s gateway, and increment distance by 1</span><br><span class="line"></span><br><span class="line">        for each entry in modified RIP message:</span><br><span class="line">            if destination network N not in routing table:</span><br><span class="line">                add entry to routing table</span><br><span class="line">            else:</span><br><span class="line">                if nexthop address in received entry is X:</span><br><span class="line">                    replace existing entry in routing table with received entry</span><br><span class="line">                else:</span><br><span class="line">                    if received distance d is less than existing distance in routing table:</span><br><span class="line">                        update entry in routing table with received entry</span><br><span class="line">                    else:</span><br><span class="line">                        do nothing</span><br><span class="line">    else:</span><br><span class="line">        if no update received from neighboring router for 180s:</span><br><span class="line">            mark neighboring router as unreachable by setting distance to 16</span><br></pre></td></tr></table></figure>
<p><strong>RIP 的特点</strong>：</p>
<ul>
<li>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</li>
<li>RIP 以跳数作为度量值，虽然简单，但是不够科学。例如，被 RIP 优选的跳数少的路径可能是链路带宽低的路径，反而跳数多的路径是链路带宽高的路径。</li>
</ul>
<p><strong>路由环路的产生</strong>：</p>
<p>路由环路，就是数据包不断在这个网络传输，始终到达不了目的地，导致掉线或者网络瘫痪。</p>
<p>图中，路由器 C 与 <code>10.0.4.0/24</code> 网段的设备物理断开后，路由器 C 上对应的表项会被删除。</p>
<img src="../images/computer-network/RIP-3-merged.png" alt="路由环路产生过程" width="100%" height="100%">
<p>后续，在第一次 RIP 路由交换时，路由器 B 上的表项 <code>10.0.4.0, 1</code> 会通过路由器 C 的 <code>G0/0/0</code> 通告给路由器 C，并添加该表项 <code>10.0.4.0, G0/0/0, 1+1</code>。</p>
<p>在第二次 RIP 路由交换时，路由器 C 会再次把该表项通过路由器 B 的 <code>G0/0/1</code> 通告给路由器 B。<strong>原先路由器 B 上到达该目的网段的表项为 <code>10.0.4.0, G0/0/1, 1</code>，但这次路由器 C 通告的表项表明：到达目的网段 <code>10.0.4.0</code> 需要通过你的 <code>G0/0/1</code> 接口，其跳数是 <code>2+1</code>，故路由器 B 会更新该表项为  <code>10.0.4.0, G0/0/1, 3</code></strong>。</p>
<p>在再下一次 RIP 路由交换时，路由器 A 同理，会更新为  <code>10.0.4.0, G0/0/1, 3+1</code>。后续不断地交换，跳数越来越大…</p>
<p>路由环路的产生，会导致数据包不断在这个网络传输，始终到达不了目的地。例如，路由器 B 下挂的设备想要给 <code>10.0.4.0/24</code> 网段的设备通信时，数据包会从 <code>G0/0/1</code> 发送给路由器 C，路由器 C 又会从 <code>G0/0/0</code> 发回给 路由器 B，路由器 B 又会从 <code>G0/0/1</code> 发送给路由器 C，如此循环…</p>
<p><strong>距离矢量路由选择协议的防环机制</strong>：</p>
<ul>
<li><strong>定义最大度量以防止计数至无穷大</strong>：如 RIP 规定跳数达到 16 为不可达，数据包将被丢弃</li>
<li><strong>水平分割</strong>：路由器从一个接口收到的路由更新，不会再从同一个接口通告出去</li>
<li><strong>路由中毒</strong>：当本设备的某一路由表项不可达时，会立即向所有邻居发出通告（邻居再通告给邻居的邻居），以 16 跳数的方式表明该路由不可达</li>
<li><strong>毒性逆转</strong>：路由器从一个接口收到的路由更新，会以 16 跳从该接口更新出去（再次返回给那个邻居后，发现不是最优的路径，不会触发更新表项）</li>
<li>抑制计时器</li>
<li>触发更新</li>
</ul>
<img src="../images/computer-network/RIP-4-merged.png" alt="距离矢量路由选择协议的防环机制" width="80%" height="80%">
<blockquote>
<p>水平分割与毒性逆转不会同时存在。</p>
</blockquote>
<h3 id="2- 内部网关协议 -OSPF">2. 内部网关协议 OSPF</h3>
<p>开放最短路径优先（Open Shortest Path First, OSPF），是为了克服 RIP 的缺点而开发出来的。</p>
<p>这里的开放一词意味着：OSPF 不受某一家厂商控制，而是公开发表的，它使用了 Dijkstra 提出的 <a href="/posts/231117095232.html"> 最短路径算法 SPF</a>。</p>
<p>OSPF 具有以下特点：</p>
<ul>
<li>向本自治系统中的所有路由器发送信息，这种方法是洪泛法。</li>
<li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li>
<li>只有当链路状态发生变化时，路由器才会发送信息。</li>
</ul>
<p>所有路由器都具有全网的拓扑结构图，并且是一致的。相较于 RIP，OSPF 的更新过程收敛的很快。</p>
<blockquote>
<p>洪泛法（Flooding）是一种简单且基础的路由算法，常用于网络通信中。在洪泛法中，当一个路由器接收到一个数据包时，它会将该数据包发送到所有与其相邻的路由器（除了接收该数据包的路由器）。接收到数据包的路由器会继续将该数据包向外传输，直到数据包到达目的地。</p>
</blockquote>
<h3 id="3- 外部网关协议 -BGP">3. 外部网关协议 BGP</h3>
<p>AS 之间的路由选择很困难，主要是由于：</p>
<ul>
<li>互联网规模很大；</li>
<li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li>
<li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</li>
</ul>
<p>边界网关协议（Border Gateway Protocol, BGP）只能寻找一条比较好的路由，而不是最佳路由。</p>
<p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9cd0ae20-4fb5-4017-a000-f7d3a0eb3529.png" width="600"/> </div><br>
<blockquote>
<ol>
<li>本文修改自：<a target="_blank" rel="noopener" href="https://github.com/CyC2018/CS-Notes">https://github.com/CyC2018/CS-Notes</a></li>
<li>RIP 参考：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1SK411T7EC/">https://www.bilibili.com/video/BV1SK411T7EC/</a></li>
</ol>
</blockquote>

</div>


  <div class="book-comments">
    




  </div>



<script src="/js/book-post.js"></script>


            </div>
          </div>
          <div class="column col-2 hide-lg">
            <div class="book-post-info">
  
    <div class="book-post-meta">

  <div class="author">

    <!-- Author image -->
    <div class="author-img">
      
        <figure
          class="avatar avatar-lg"
          data-initial="A"
          style="background-color: #3b4351;">
        </figure>
      
    </div>

    <!-- Author title -->
    <div class="author-title">
      <div>aha</div>
      <div>2024-03-29</div>
    </div>
  </div>

  
    <div class="divider"></div>

    <div class="link">
      <a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>

      <a class="tag-none-link" href="/tags/CyC2018/" rel="tag">#CyC2018</a>
    </div>
    
  

  <div class="divider"></div>
</div>
  

  <div class="book-tocbot">
</div>
<div class="book-tocbot-menu">
  <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
  <a onclick="go_top()">Back to top</a>
  <a onclick="go_bottom()">Go to bottom</a>
  <a onclick="toggleSearch()">Search in blogs</a> <!-- 添加搜索文字的点击事件 -->
</div>

<div id="search-overlay" class="search-overlay" style="display: none;"> <!-- 初始状态为隐藏 -->
  <div class="search-box">
    <input type="text" id="search-input" placeholder="Search in all blogs...">
    <button onclick="closeSearch()">Close</button> <!-- 添加关闭按钮 -->
    <div id="search-results" class="search-results"></div>
  </div>
</div>

<script>
  function performSearch(query) {
    if (!query.trim()) {
      return;
    }

    fetch('/search.xml')
      .then(response => response.text())
      .then(data => {
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(data, "text/xml");
        const entries = xmlDoc.getElementsByTagName('entry');
        let results = '';

        for (let i = 0; i < entries.length; i++) {
          const title = entries[i].getElementsByTagName('title')[0].textContent;
          const content = entries[i].getElementsByTagName('content')[0].textContent;
          const url = entries[i].getElementsByTagName('url')[0].textContent;

          let count = (title.match(new RegExp(query, "gi")) || []).length; // 统计查询词出现的次数
          count += (content.match(new RegExp(query, "gi")) || []).length;

          if (count > 0) { // title.includes(query) || content.includes(query)
            results += `
              <div class="search-result-item">
                <a href="${url}">${title}</a> (${count})
              </div>`;
          }
        }

        const searchResultsElement = document.getElementById('search-results');
        searchResultsElement.innerHTML = results;
        searchResultsElement.classList.add('active');
      });
  }

  function toggleSearch() {
    const searchOverlay = document.getElementById('search-overlay');
    searchOverlay.style.display = searchOverlay.style.display === 'none' ? 'flex' : 'none';
  }

  function closeSearch() {
    document.getElementById('search-overlay').style.display = 'none';
  }

  document.getElementById('search-input').addEventListener('input', function() {
    const query = this.value;
    performSearch(query);
  });
</script>

<style>
  .search-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }

  .search-box {
    background: white;
    padding: 20px;
    border-radius: 5px;
    text-align: center;
    width: 80%;
    max-width: 500px;
  }

  .search-results {
    margin-top: 10px;
    max-height: 300px;
    overflow-y: auto;
    background: white;
    padding: 10px;
    border-radius: 5px;
    width: 100%;
  }

  .search-result-item {
    margin: 10px 0;
  }

  .search-result-item a {
    color: blue; /* 设置链接颜色为蓝色 */
    text-decoration: none;
  }

  .search-result-item a:hover {
    text-decoration: underline;
  }
</style>


<script src="/js/book-toc.js"></script>


</div>
          </div>
        </div>
      </div>

      <a class="off-canvas-overlay" onclick="hide_canvas()"></a>

      <button class="floating-button" onclick="toggleDropdownMenu()"></button>

      <div class="dropdown-menu">
        <div class="dropdown-item" onclick="changeBackgroundColor('#FFFFFF', '#000000')">银河白</div>
        <div class="dropdown-item" onclick="changeBackgroundColor('#C7EDCC', '#000000')">豆沙绿</div>
        <div class="dropdown-item" onclick="changeBackgroundColor('#FAF9DE', '#000000')">杏仁黄</div>
        <div class="dropdown-item" onclick="changeBackgroundColor('#E3EDCD', '#000000')">青草绿</div>
        <div class="dropdown-item" onclick="changeBackgroundColor('#FFF2E2', '#000000')">秋叶褐</div>
      </div>
  </div>

  <script>
    function toggleDropdownMenu() {
      document.querySelector('.floating-button').classList.toggle('active');
    }

    document.addEventListener('DOMContentLoaded', function () {
      var storedBackgroundColor = localStorage.getItem('blogBackgroundColor');
      var storedColor = localStorage.getItem('blogColor');

      if (storedBackgroundColor && storedColor) {
        document.body.style.backgroundColor = storedBackgroundColor;
        document.body.style.color = storedColor;
      }
    });

    function changeBackgroundColor(backgroundColor, color) {
      document.body.style.backgroundColor = backgroundColor;
      document.body.style.color = color;

      localStorage.setItem('blogBackgroundColor', backgroundColor);
      localStorage.setItem('blogColor', color);

      document.querySelector('.floating-button').classList.remove('active');
    }
  </script>
</body>

</html>


<script src="/js/book.js"></script>
