<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

    
      <link rel="icon" href="/favicon.png" />
    

    <title>
        
          Linux IO 模式与 IO 多路复用 - aha&#39;s book
        
    </title>

    <!-- Spectre.css framework -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-exp.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-icons.min.css">

    <!-- theme css & js -->
    
<link rel="stylesheet" href="/css/book.css">

    
<script src="/js/book.js"></script>


    <!-- tocbot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
    
    <!-- katex -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">

    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/zooming/2.1.1/zooming.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    const zooming = new Zooming()
    zooming.listen('.book-content img')
})
</script>

<meta name="generator" content="Hexo 6.3.0"></head>
    <style>
      body {
        background-color: #FFFFFF;
        /* color: #000000; */
        transition: background-color 0.3s ease, color 0.3s ease;
      }

      /* Floating Button Styles */
      .floating-button {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 999;
        background-color: #000000;
        color: #ffffff;
        padding: 12px;
        border-radius: 50%;
        cursor: pointer;
        border: 2px solid #000000;
      }

      .floating-button:hover {
        background-color: #FFFFFF;
      }

      /* Dropdown Menu Styles */
      .dropdown-menu {
        position: fixed;
        bottom: 60px;
        right: 10px;
        display: none;
        min-width: 60px;
        padding: 2px;
        background-color: #fff;
        /* box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); */
        z-index: 1000;
      }

      .floating-button.active+.dropdown-menu {
        display: block;
      }

      .dropdown-item {
        display: block;
        padding: 8px 16px;
        cursor: pointer;
      }

      .dropdown-item:hover {
        background-color: #f5f5f5;
      }
    </style>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body>
  <div class="book-container">
    <div class="book-sidebar">
      <div class="book-brand">
  <a href="/">
    <img src="/favicon.png">
    <span>AHA&#39;S BOOK</span>
  </a>
</div>
        <div id="menu" class="book-menu hide">
  <h2 id="基础知识"> 基础知识 </h2>
<ul>
<li><a href="/posts/231010144856.html"> 模运算 </a></li>
<li><a href="/posts/231014105311.html"> 异或运算 </a></li>
<li><a href="/posts/231210181853.html"> 计算机中的寄存器 </a></li>
<li><a href="/posts/231213183051.html"> 正则表达式基础 </a></li>
</ul>
<h2 id="C 语言">C 语言 </h2>
<ul>
<li><a href="/posts/230916171929.html">main 函数参数 </a></li>
<li><a href="/posts/231214192113.html"> 关键字与专有名词 </a></li>
<li><a href="/posts/240103180653.html"> 输出打印函数 </a></li>
<li><a href="/posts/230922143003.html"> 多维数组 </a></li>
<li><a href="/posts/230913200729.html">const 关键字 </a></li>
<li><a href="/posts/230918174223.html">typedef 类型基础 </a></li>
<li><a href="/posts/230920172849.html">typedef 类型实践 </a></li>
<li><a href="/posts/240224193217.html"> 二级指针 </a></li>
<li><a href="/posts/240307195203.html"> 代码 TOP-K 问题 </a></li>
<li><a href="/posts/230922172626.html">uthash 哈希表基础 </a></li>
<li><a href="/posts/230918114841.html"> 大小端知识 </a></li>
</ul>
<h2 id="Golang 语言">Golang 语言 </h2>
<ul>
<li><a href="/posts/230907162612.html"> 变量与常量 </a></li>
<li><a href="/posts/230909120145.html"> 函数 &amp; 包 &amp; 判断 &amp; 循环 </a></li>
<li><a href="/posts/230912152800.html"> 数组与切片 </a></li>
<li><a href="/posts/230913161326.html"> 可变参数函数与 Map 集合 </a></li>
<li><a href="/posts/230915155105.html"> 字符串和指针 </a></li>
</ul>
<h2 id="数据结构"> 数据结构 </h2>
<ul>
<li><a href="/posts/231007174854.html"> 链表（数组实现）</a></li>
<li><a href="/posts/231008213450.html"> 链表（链式实现）</a></li>
<li><a href="/posts/231016161508.html"> 堆栈（数组实现）</a></li>
<li><a href="/posts/231016184406.html"> 堆栈（链表实现）</a></li>
<li><a href="/posts/231127185207.html"> 单调栈 </a></li>
<li><a href="/posts/231017105123.html"> 队列（链表实现）</a></li>
<li><a href="/posts/231017154121.html"> 双端队列（链表实现）</a></li>
<li><a href="/posts/231018102559.html"> 堆基础与堆结构（数组实现）</a></li>
<li><a href="/posts/231019102311.html"> 优先队列（堆实现）</a></li>
<li><a href="/posts/230905224335.html"> 二叉树的遍历 </a></li>
<li><a href="/posts/231020174358.html"> 二叉搜索树 </a></li>
<li><a href="/posts/230916094606.html"> 拓扑排序 </a></li>
<li><a href="/posts/230925185057.html">Trie 字典树 </a></li>
<li><a href="/posts/231023164532.html"> 并查集（数组实现）</a></li>
<li><a href="/posts/240702200642.html">Linux 数据结构之队列 </a></li>
</ul>
<h2 id="数据结构算法"> 数据结构算法 </h2>
<ul>
<li><a href="/posts/231218181635.html"> 归并排序 </a></li>
<li><a href="/posts/231108163339.html"> 快速排序 </a></li>
<li><a href="/posts/231107171607.html"> 堆排序 </a></li>
<li><a href="/posts/231124181658.html"> 二分查找 </a></li>
<li><a href="/posts/231227190828.html"> 哈希表实现 </a></li>
<li><a href="/posts/240313193201.html"> 字符串哈希函数 </a></li>
<li><a href="/posts/231116150205.html">Floyd 多源最短路径 </a></li>
<li><a href="/posts/231117095232.html">Dijkstra 单源最短路径（原理部分）</a></li>
<li><a href="/posts/231121152713.html">Dijkstra 单源最短路径（实现部分）</a></li>
</ul>
<h2 id="数据库"> 数据库 </h2>
<ul>
<li><a href="/posts/250605180332.html">MySQL 基础 </a></li>
</ul>
<h2 id="计算机网络"> 计算机网络 </h2>
<ul>
<li><a href="/posts/231011192359.html">OSI 参考模型 </a></li>
<li><a href="/posts/240329202000.html"> 计网 CyC2018 之概述 </a></li>
<li><a href="/posts/240329202004.html"> 计网 CyC2018 之链路层 </a></li>
<li><a href="/posts/240329202003.html"> 计网 CyC2018 之网络层 </a></li>
<li><a href="/posts/240329202002.html"> 计网 CyC2018 之传输层 </a></li>
<li><a href="/posts/240329202001.html"> 计网 CyC2018 之应用层 </a></li>
<li><a href="/posts/240306203742.html">ACL 访问控制列表 </a></li>
<li><a href="/posts/240130190208.html"> 路由表、转发表与快速转发工作原理 </a></li>
<li><a href="/posts/231221200716.html">VXLAN 网络虚拟化技术 </a></li>
<li><a href="/posts/240903191243.html">TCP/IP checksum 计算 </a></li>
<li><a href="/posts/240911185603.html"> 抓包分析 TCP 三次握手与四次挥手过程 </a></li>
</ul>
<h2 id="操作系统"> 操作系统 </h2>
<ul>
<li><a href="/posts/230921190726.html"> 概述 </a></li>
<li><a href="/posts/230924172528.html"> 中断 &amp; 异常 &amp; 系统调用 </a></li>
<li><a href="/posts/231017195157.html"> 内存分层体系与地址空间生成 </a></li>
<li><a href="/posts/231108195351.html"> 连续内存分配 </a></li>
<li><a href="/posts/231111172507.html"> 非连续内存分配之分段与分页 </a></li>
<li><a href="/posts/231119170537.html"> 非连续内存分配之页表 </a></li>
<li><a href="/posts/231123184526.html"> 内存管理之覆盖技术与交换技术 </a></li>
<li><a href="/posts/231127193658.html"> 内存管理之虚存技术 </a></li>
<li><a href="/posts/231129182631.html"> 局部页面置换算法 </a></li>
<li><a href="/posts/231207184239.html"> 全局页面置换算法 </a></li>
<li><a href="/posts/231207204958.html"> 进程描述 </a></li>
<li><a href="/posts/231210211306.html"> 进程状态 </a></li>
<li><a href="/posts/231215213932.html"> 线程 </a></li>
<li><a href="/posts/231218220813.html"> 进程控制 </a></li>
<li><a href="/posts/231228193143.html"> 调度 </a></li>
<li><a href="/posts/240104202828.html"> 同步与互斥 </a></li>
<li><a href="/posts/240113115605.html"> 信号量与管程 </a></li>
<li><a href="/posts/240205182643.html"> 经典同步问题 </a></li>
<li><a href="/posts/240310162231.html"> 死锁 </a></li>
</ul>
<h2 id="系统与网络编程"> 系统与网络编程 </h2>
<ul>
<li><a href="/posts/230911151334.html">pthread 库 </a></li>
<li><a href="/posts/230921094127.html"> 锁与原子操作 </a></li>
<li><a href="/posts/240319195609.html"> 读者写者问题 </a></li>
<li><a href="/posts/240527200241.html"> 网络编程卷一阅读随笔 </a></li>
<li><a href="/posts/240414190410.html"> 进程间通信 IPC 机制 </a></li>
<li><a href="/posts/240424200123.html"> 多进程相关练习 </a></li>
<li><a href="/posts/240516221527.html">I/O 模式与 I/O 多路复用 </a></li>
<li><a href="/posts/240626192803.html">Linux 内核 kfifo 环形队列 </a></li>
<li><a href="/posts/241009203126.html">Linux 内核等待队列 </a></li>
<li><a href="/posts/240627210637.html">DPDK 无锁环形队列 </a></li>
<li><a href="/posts/240919200410.html"> 解密内存屏障 </a></li>
<li><a href="/posts/240927202500.html"> 内核线程的创建 </a></li>
<li><a href="/posts/241015195205.html">Linux 网络数据包接收过程 </a></li>
<li><a href="/posts/2410232111015.html"> 源码解读 epoll 实现原理 </a></li>
<li><a href="/posts/241106182619.html">Linux 文件系统 </a></li>
<li><a href="/posts/250619154429.html">Libevent 高性能 IO 事件驱动库 </a></li>
<li><a href="/posts/251119185833.html">Linux UDP 传输性能优化 </a></li>
<li><a href="/posts/251202101130.html">Linux 零拷贝技术 </a></li>
<li><a href="/posts/251124150921.html">QUIC 协议 </a></li>
</ul>
<h2 id="工具与命令"> 工具与命令 </h2>
<ul>
<li><a href="/posts/240207180410.html">GCC 编译过程分解 </a></li>
<li><a href="/posts/240312184132.html">GDB 调试入门 </a></li>
<li><a href="/posts/240512184921.html">Makefile 学习 </a></li>
<li><a href="/posts/250629214430.html">CMake 学习 </a></li>
<li><a href="/posts/240417193754.html">Linux 命令之文件权限 </a></li>
</ul>
<h2 id="开源项目"> 开源项目 </h2>
<ul>
<li><a href="/posts/240303201855.html"> 线程池原理与实现 </a></li>
<li><a href="/posts/240507194549.html">HTTP 服务器实现 </a></li>
<li><a href="/posts/240904203605.html"> 聊天服务器实现 </a></li>
<li><a href="/posts/241119182636.html">Linux 文件系统 </a></li>
</ul>
<h2 id="Docker">Docker</h2>
<ul>
<li><a href="/posts/230909171809.html">Docker 学习笔记 </a></li>
</ul>
<h1 id="LeetCode 刷题">LeetCode 刷题 </h1>
<h2 id="链表相关"> 链表相关 </h2>
<ul>
<li><a href="/posts/231025143947.html">160 相交链表 </a></li>
<li><a href="/posts/231025185947.html">206 反转链表 </a></li>
<li><a href="/posts/231026101239.html">21 合并两个有序链表 </a></li>
<li><a href="/posts/231026184514.html">83 删除排序链表中的重复元素 </a></li>
<li><a href="/posts/231027150243.html">19 删除链表的倒数第 N 个节点 </a></li>
<li><a href="/posts/231031120718.html">2 两数相加 </a></li>
<li><a href="/posts/231031163133.html">445 两数相加 II</a></li>
<li><a href="/posts/231101094219.html">234 回文链表 </a></li>
<li><a href="/posts/231101135228.html">725 分隔链表 </a></li>
<li><a href="/posts/231102120708.html">328 奇偶链表 </a></li>
<li><a href="/posts/231102165703.html">142 环形链表 II</a></li>
</ul>
<h2 id="设计"> 设计 </h2>
<ul>
<li><a href="/posts/231201184542.html">146 LRU 缓存 </a></li>
</ul>
<h2 id="贪心算法"> 贪心算法 </h2>
<ul>
<li><a href="/posts/231107094652.html">1029 两地调度 </a></li>
<li><a href="/posts/231109150855.html">435 无重叠区间 </a></li>
</ul>
<h2 id="哈希表"> 哈希表 </h2>
<ul>
<li><a href="/posts/231123181539.html">1410 实体解析器 </a></li>
</ul>
<h2 id="树的遍历"> 树的遍历 </h2>
<ul>
<li><a href="/posts/231103121209.html">117 填充每个节点的下一个右侧节点指针 II</a></li>
</ul>
<h2 id="深度优先搜索（递归）"> 深度优先搜索（递归）</h2>
<ul>
<li><a href="/posts/231206201243.html">2477 达到首都的最少油耗 </a></li>
</ul>
<h2 id="图或路径问题"> 图或路径问题 </h2>
<ul>
<li><a href="/posts/231211184652.html">1631 最小体力消耗路径 </a></li>
</ul>
<h2 id="其它"> 其它 </h2>
<ul>
<li><a href="/posts/230101120000.html"> 备忘录 </a></li>
</ul>

</div>


<script src="/js/book-menu.js"></script>

    </div>
    <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
  <div class="sidebar-toggle-inner"></div>
</div>

<script>
function add_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.add('show')  
}

function remove_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.remove('show')
}

function sidebar_toggle() {
    let sidebar_toggle = document.querySelector('.sidebar-toggle')
    let sidebar = document.querySelector('.book-sidebar')
    let content = document.querySelector('.off-canvas-content')
    if (sidebar_toggle.classList.contains('extend')) { // show
        sidebar_toggle.classList.remove('extend')
        sidebar.classList.remove('hide')
        content.classList.remove('extend')
    }
    else { // hide
        sidebar_toggle.classList.add('extend')
        sidebar.classList.add('hide')
        content.classList.add('extend')
    }
}
</script>

      <div class="off-canvas-content">
        <div class="columns">
          <div class="column col-10 col-lg-12">
            <div class="book-navbar">
              <!-- For Responsive Layout -->

<header class="navbar">
  <section class="navbar-section">
    <a onclick="open_sidebar()">
      <i class="icon icon-menu"></i>
    </a>
  </section>
</header>

            </div>
            <div class="book-content">
              <div class="book-post">
  <p>同步 I/O 和异步 I/O、阻塞 I/O 和非阻塞 I/O 分别是什么？到底有什么区别？不同的人在不同的上下文下给出的答案是不同的。所以先限定一下本文的上下文：本文讨论的背景是 Linux 环境下的 Network I/O。</p>
<span id="more"></span>
<blockquote>
<p>注：本文是对众多博客的学习和总结，可能存在理解错误。请带着怀疑的眼光，同时如果有错误希望能指出。</p>
</blockquote>
<h1 id="概念说明">概念说明</h1>
<p>在进行解释之前，首先要说明几个概念：</p>
<ul>
<li>用户空间和内核空间</li>
<li>进程切换</li>
<li>进程的阻塞</li>
<li>文件描述符</li>
<li>缓存 I/O</li>
</ul>
<h2 id="用户空间与内核空间">用户空间与内核空间</h2>
<p>现在操作系统都是采用虚拟存储器，那么对 32 位操作系统而言，它的寻址空间（虚拟存储空间）为 4G（2 的 32 次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。</p>
<p>为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对 Linux 操作系统而言，将最高的 1G 字节（从虚拟地址 0xC0000000 到 0xFFFFFFFF），供内核使用，称为内核空间；而将较低的 3G 字节（从虚拟地址 0x00000000 到 0xBFFFFFFF），供各个进程使用，称为用户空间。</p>
<h2 id="进程切换">进程切换</h2>
<p>为了控制进程的执行，内核必须有能力挂起正在 CPU 上运行的进程，并恢复以前挂起的某个进程的执行，这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p>
<p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p>
<ol>
<li>保存 CPU 上下文，包括程序计数器和其他寄存器。</li>
<li>更新 PCB 信息。</li>
<li>把进程的 PCB 移入相应的队列，如就绪队列、在某事件阻塞的等待队列。</li>
<li>选择另一个进程执行，并更新其 PCB。</li>
<li>更新内存管理的数据结构。</li>
<li>恢复 CPU 上下文。</li>
</ol>
<blockquote>
<p>注：总而言之就是 <strong> 很耗资源</strong>。</p>
</blockquote>
<h2 id="进程的阻塞">进程的阻塞</h2>
<p>正在执行的进程，由于期待的某些事件未发生，例如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作可做时，会 <strong> 主动执行 </strong> 阻塞原语（Block），使自己由运行状态变为阻塞状态。可见，进程的阻塞是 <strong> 进程自身的一种主动行为</strong>。也因此，只有处于运行态的进程（获得 CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用 CPU 资源的。</p>
<h2 id="文件描述符">文件描述符</h2>
<p>文件描述符（File descriptor, fd）是计算机科学中的一个术语，是一个 <strong> 用于表述指向文件的引用 </strong> 的抽象化概念。</p>
<p>文件描述符在形式上是一个非负整数。<strong>实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表</strong>。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p>
<p>在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是，文件描述符这一概念往往只适用于 UNIX、Linux 这样的操作系统。</p>
<h2 id="缓存 -I-O">缓存 I/O</h2>
<p>缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（page cache）中。也就是说，<strong>数据会先被拷贝到内核的缓冲区中，然后才会从内核的缓冲区拷贝到应用程序的地址空间</strong>。</p>
<p><strong>缓存 I/O 的缺点 </strong>：数据在传输过程中需要在应用程序地址空间和内核之间<strong> 进行多次数据拷贝操作</strong>，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p>
<h1 id="I-O 模式">I/O 模式</h1>
<p>刚才说了，对于一次 I/O 访问（以 read 为例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个 read 操作发生时，它会经历两个阶段：</p>
<ol>
<li><strong>等待数据准备好（Waiting for the data to be ready）</strong></li>
<li><strong>将数据从内核拷贝到进程中（Copying the data from the kernel to the process）</strong></li>
</ol>
<p>正式因为这两个阶段，Linux 系统产生了以下五种网络模式的方案：</p>
<ul>
<li>阻塞 I/O（blocking I/O）</li>
<li>非阻塞 I/O（nonblocking I/O）</li>
<li>I/O 多路复用（ I/O multiplexing）</li>
<li>信号驱动 I/O（ signal driven I/O）</li>
<li>异步 I/O（asynchronous I/O）</li>
</ul>
<blockquote>
<p>注：由于 signal driven I/O 在实际中并不常用，所以我这只提及剩下的四种 I/O 模式。</p>
</blockquote>
<h2 id="阻塞 -I-O">阻塞 I/O</h2>
<p>在 Linux 中，<strong>默认情况下所有的 socket 都是 blocking</strong>，一个典型的读操作流程大概是这样：</p>
<p><img src="https://notes.shichao.io/unp/figure_6.1.png" alt="阻塞 I/O（blocking I/O）模式"></p>
<p>当用户进程调用了 <code>recvfrom</code> 这个系统调用，kernel 就开始了 I/O 的第一个阶段：准备数据（对于网络 I/O 来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的 UDP 包。这个时候 kernel 就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。</p>
<p>而 <strong> 在用户进程这边，整个进程会被阻塞（当然，这是进程自己选择的阻塞）</strong>。当 kernel 等到数据准备好了，它就会将数据从 kernel 中拷贝到用户内存，然后 kernel 返回结果，用户进程才解除 block 的状态，重新运行起来。</p>
<p>所以，blocking I/O 的特点就是在 I/O 执行的两个阶段都被 block 了。</p>
<h2 id="非阻塞 -I-O">非阻塞 I/O</h2>
<p>在 Linux 下，可以通过设置 socket 使其变为 non-blocking。当对一个 non-blocking socket 执行读操作时，流程是这个样子：</p>
<p><img src="https://notes.shichao.io/unp/figure_6.2.png" alt="非阻塞 I/O（nonblocking I/O）模式"></p>
<p>当用户进程发出 read 操作时，如果 kernel 中的数据还没有准备好，那么它并不会 block 用户进程，而是立刻返回一个 error。从用户进程角度讲，它发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个 error 时，它就知道数据还没有准备好，于是它 <strong> 可以再次发送 read 操作</strong>。一旦 kernel 中的数据准备好了，并且又再次收到了用户进程的 system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
<p>所以，nonblocking I/O 的特点是用户进程需要 <strong> 不断地主动询问</strong> kernel 数据好了没有。</p>
<h2 id="I-O- 多路复用">I/O 多路复用</h2>
<p>I/O multiplexing 就是我们说的 <code>select</code>, <code>poll</code>, <code>epoll</code> 系统调用，有些地方也称这种 I/O 方式为 event driven I/O。它们的 <strong> 好处就在于单个 process 就可以同时处理（监听）多个网络连接的 I/O</strong>。它的基本原理就是通过 <code>select</code>，<code>poll</code>，<code>epoll</code> 系统调用，会不断地轮询所负责的所有 socket，当某个 socket 有数据到达了，就通知用户进程。</p>
<p><img src="https://notes.shichao.io/unp/figure_6.3.png" alt="I/O 多路复用（ I/O multiplexing）模式"></p>
<p>当用户进程调用了 <code>select</code>，那么整个进程会被 block，同时 kernel 会“监视” <code>select</code> 负责的所有 socket，当任何一个 socket 中的数据准备好了，<code>select</code> 就会返回。这个时候用户进程再调用 read 操作，可以直接将数据从 kernel 拷贝到用户进程。</p>
<p>所以，I/O 多路复用的特点是通过一种机制让一个进程能同时等待多个 fd，而这些 fd（socket fd）只要任意一个进入读就绪状态，<code>select</code> 系统调用就可以返回。</p>
<p>这个图和 blocking I/O 的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个 system call (<code>select</code> 和 <code>recvfrom</code>)，而 blocking I/O 只调用了一个 system call (<code>recvfrom</code>)。但是，<strong>用 <code>select</code> 的优势在于它可以同时处理多个 connection</strong>。</p>
<p>所以，<strong>如果处理的连接数不是很高的话，使用 <code>select</code> 或 <code>epoll</code> 的 web server 不一定比使用 multi-threading + blocking I/O 的 web server 性能更好，可能延迟还更大。<code>select</code> 或 <code>epoll</code> 的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接</strong>。</p>
<p><strong>在 I/O multiplexing Model 中，通常会将每个 socket 设置为 non-blocking 模式。这意味着当调用 socket 相关的 I/O 操作时，如果数据尚未准备好，该操作将立即返回而不会阻塞进程。然而，整个用户进程在等待事件发生时仍然会被阻塞</strong>。区别在于，这种阻塞是由于系统调用 select（或者其他 I/O 多路复用的系统调用，如 poll、epoll）而不是由于单个 socket I/O 操作导致的。因此，用户进程的阻塞状态是由 I/O 多路复用机制控制的，而不是由单个 socket I/O 操作控制的。</p>
<h2 id="异步 -I-O">异步 I/O</h2>
<p>Linux 的 asynchronous I/O 其实用得很少。先看一下它的流程：</p>
<p><img src="https://notes.shichao.io/unp/figure_6.5.png" alt="异步 I/O（asynchronous I/O）模式"></p>
<p>用户进程发起 read 操作之后，立刻就可以开始去做其它的事。而另一方面，从 kernel 的角度，当它收到一个 asynchronous read 之后，首先它会立刻返回，所以不会对用户进程产生任何 block。然后，kernel 会等待数据准备完成，然后将数据拷贝到用户内存。当这一切都完成之后，kernel 会给用户进程发送一个 signal，告诉它 read 操作完成了。</p>
<h2 id="总结">总结</h2>
<p><strong>blocking 和 non-blocking 的区别</strong></p>
<p>调用 blocking I/O 会一直 block 住对应的进程直到操作完成，而 non-blocking I/O 在 kernel 还准备数据的情况下会立刻返回。</p>
<p><strong>synchronous I/O 和 asynchronous I/O 的区别</strong></p>
<p>在说明 synchronous I/O 和 asynchronous I/O 的区别之前，需要先给出两者的定义。POSIX 的定义是这样子的：</p>
<ul>
<li>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes.</li>
<li>An asynchronous I/O operation does not cause the requesting process to be blocked.</li>
</ul>
<p>两者的区别就在于 synchronous I/O 做 I/O 操作的时候会将 process 阻塞。按照这个定义，之前所述的 blocking I/O/, non-blocking I/O, /I/O multiplexing 都属于 synchronous I/O。</p>
<p>有人会说，non-blocking I/O 并没有被 block 啊。这里有个非常 “狡猾” 的地方，定义中所指的 “I/O operation” 是指真实的 I/O 操作，就是例子中的 recvfrom 这个 system call。non-blocking I/O 在执行 recvfrom 这个 system call 的时候，如果 kernel 的数据没有准备好，这时候不会 block 进程。但是，当 kernel 中数据准备好的时候，recvfrom 会将数据从 kernel 拷贝到用户内存中，这个时候进程是被 block 了，在这段时间内，进程是被 block 的。</p>
<p>而 asynchronous I/O 则不一样，当进程发起 I/O 操作之后，就直接返回再也不理睬了，直到 kernel 发送一个信号，告诉进程说 I/O 完成。在这整个过程中，进程完全没有被 block。</p>
<p>各个 I/O Model 的比较如图所示：</p>
<p><img src="https://notes.shichao.io/unp/figure_6.6.png" alt="五种 I/O 模式比较"></p>
<p>通过上图，可以发现 non-blocking I/O 和 asynchronous I/O 的区别还是很明显的。在 non-blocking I/O 中，虽然进程大部分时间都不会被 block，但是它仍然要求进程去主动的 check，并且当数据准备完成以后，也需要进程主动的再次调用 recvfrom 来将数据拷贝到用户内存。而 asynchronous I/O 则完全不同。它就像是用户进程将整个 I/O 操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查 I/O 操作的状态，也不需要主动的去拷贝数据。</p>
<h1 id="I-O- 多路复用 -v2">I/O 多路复用</h1>
<h2 id="多路复用概念">多路复用概念</h2>
<p>I/O 多路复用就是通过一种机制，<strong>一个进程 </strong> 就可以 <strong> 监视 </strong> 多个 fd，一旦某个 fd 就绪（通常是读就绪 / 写就绪），便可通知进程进行相应的 I/O 操作。这 <strong> 避免了每个 I/O 操作都阻塞在一个线程上</strong>，从而提高了资源利用率和系统的并发处理能力。</p>
<p><code>select</code>, <code>poll</code>, <code>epoll</code> 都是实现 I/O 多路复用的机制，但本质上都是同步 I/O，因为它们都需要在 <strong> 读写事件就绪后自己负责进行读写，也就是说这个读写数据的过程是阻塞的</strong>（参考 <a href="#I-O-%20%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">I/O 多路复用</a> 小节的配图）。</p>
<blockquote>
<p>异步 I/O 则无需自己负责进行读写，它会负责把数据从内核拷贝到用户空间。</p>
</blockquote>
<h2 id="select">select</h2>
<p>系统调用定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 替换宏定义，化简后的结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> fds_bits[<span class="number">32</span>]; <span class="comment">// 32 位系统上 32*(4*8bits)=1024bits</span></span><br><span class="line">&#125; fd_set;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds,</span></span><br><span class="line"><span class="params">          fd_set *_Nullable <span class="keyword">restrict</span> readfds,</span></span><br><span class="line"><span class="params">          fd_set *_Nullable <span class="keyword">restrict</span> writefds,</span></span><br><span class="line"><span class="params">          fd_set *_Nullable <span class="keyword">restrict</span> exceptfds,</span></span><br><span class="line"><span class="params">          <span class="keyword">struct</span> timeval *_Nullable <span class="keyword">restrict</span> timeout)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">    <span class="title function_">select</span><span class="params">()</span> allows a program to monitor multiple file descriptors,     &lt;- 最多 1024 个 fd</span><br><span class="line">    waiting until one or more of the file descriptors become &quot;ready&quot;    &lt;- 至少一个 fd 就绪后，便可返回</span><br><span class="line">    <span class="keyword">for</span> some class of I/O <span class="title function_">operation</span> <span class="params">(e.g., input possible)</span>.  A file</span><br><span class="line">    descriptor is considered &quot;ready&quot; <span class="keyword">if</span> it is possible to perform a     &lt;- 就绪即有数据可读写（无阻塞）</span><br><span class="line">    corresponding I/O <span class="title function_">operation</span> <span class="params">(e.g., read(<span class="number">2</span>), or a sufficiently</span></span><br><span class="line"><span class="params">    small write(<span class="number">2</span>))</span> without blocking.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">    On success, <span class="title function_">select</span><span class="params">()</span> and <span class="title function_">pselect</span><span class="params">()</span> <span class="keyword">return</span> the number of file        &lt;- 三类集合的就绪数量和</span><br><span class="line">    descriptors contained in the three returned descriptor <span class="title function_">sets</span> <span class="params">(that</span></span><br><span class="line"><span class="params">    is, the total number of bits that are <span class="built_in">set</span> in readfds, writefds,</span></span><br><span class="line"><span class="params">    exceptfds)</span>.  The <span class="keyword">return</span> value may be zero <span class="keyword">if</span> the timeout expired</span><br><span class="line">    before any file descriptors became ready.</span><br><span class="line"></span><br><span class="line">    On error, -1 is returned, and errno is <span class="built_in">set</span> to indicate the error;</span><br><span class="line">    the file descriptor sets are unmodified, and timeout becomes</span><br><span class="line">    undefined.</span><br></pre></td></tr></table></figure>
<p><code>select</code> 函数监视的 fd 分 3 类，分别是 writefds、readfds 和 exceptfds。调用后 <code>select</code> 函数会阻塞，直到有 fd 就绪（有数据可读、可写或者有 except）或者超时（timeout 指定等待时间，如果立即返回设为 NULL 即可），函数返回。当 <code>select</code> 函数返回后，可以通过遍历各类 fdset，来找到就绪的 fd。</p>
<blockquote>
<p>select 使用“参数 - 值”传递的方式，即参数分别是 writefds、readfds 和 exceptfds，它们各自对应着一个位图（bitmap）值。这些位图表示了要监视的 fd 集合的状态，值为 1 表示就绪。</p>
</blockquote>
<p>与 <code>select</code> 系统调用相关的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空（从集合中删除所有 fd），它应该作为初始化 fd 集的第一步使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 fd 添加到集合中，向集合中添加已经存在的 fd 是一个空操作，并不会产生错误</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从集合中移除 fd，移除一个不存在于集合中的 fd 是一个空操作，并不会产生错误</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 fd 是否仍然存在于集合中（是否有活动：I/O 操作准备就绪），如果存在于集合中，则返回非零值，否则返回零</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>来自 man 手册的示例代码</strong>：该代码监控标准输入（0），并设置超时时间为 5 秒。在超时时间到达前，若监控到标准输入有输入数据，则 <code>select</code> 返回值 1，表示有一个 fd 就绪，随之按返回结果提示不同的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    fd_set rfds;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Watch stdin (fd 0) to see when it has input. */</span></span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;rfds);</span><br><span class="line">    FD_SET(<span class="number">0</span>, &amp;rfds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait up to five seconds. */</span></span><br><span class="line">    tv.tv_sec = <span class="number">5</span>;</span><br><span class="line">    tv.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    retval = select(<span class="number">1</span>, &amp;rfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);  <span class="comment">// 阻塞等待就绪事件发生</span></span><br><span class="line">    <span class="comment">/* 现在不再依赖于 tv 的值，当在超时时间内监控到标准输入有输入数据时，即可返回 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (retval == <span class="number">-1</span>)</span><br><span class="line">        perror(<span class="string">&quot;select()&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Data is available now.\n&quot;</span>);</span><br><span class="line">        <span class="comment">/* FD_ISSET(0, &amp;rfds) will be true. */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No data within five seconds.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>select 优点：<code>select</code> 目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。</p>
<p>select 缺点：</p>
<ol>
<li><strong><code>select</code> 的一个缺点在于其只能监视最多 FD_SETSIZE (1024) 个 fd 数量</strong>（对于许多现代应用程序来说这是一个不合理的下限），并且此限制将不会改变（用户可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低）。所有现代应用程序都应该使用 <code>poll</code> 或 <code>epoll</code>，它们不受此限制。</li>
<li><strong>fd_set rfds 不可重用</strong>：每次调用 <code>select</code> 之前或新的 fd 进来，需要重新 FD_ZERO 并 FD_SET。</li>
<li><strong>用户态和内核态拷贝产生开销</strong>：用户需要监听事件时，<code>select</code> 会将 writefds、readfds 和 exceptfds 集合都拷贝到内核态；以及有就绪事件时，再次将整个集合（而非就绪的那几个事件）拷贝回用户态。</li>
<li><strong>需要 O(n) 时间复杂度的轮询</strong>，来获取集合中就绪的 fd（即使只有一个就绪）。</li>
</ol>
<h2 id="poll">poll</h2>
<p>系统调用定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">    <span class="title function_">poll</span><span class="params">()</span> performs a similar task to <span class="title function_">select</span><span class="params">(<span class="number">2</span>)</span>: it waits <span class="keyword">for</span> one of</span><br><span class="line">    a <span class="built_in">set</span> of file descriptors to become &quot;ready&quot; to perform I/O.  The</span><br><span class="line">    Linux-specific <span class="title function_">epoll</span><span class="params">(<span class="number">7</span>)</span> API performs a similar task, but offers</span><br><span class="line">    features beyond those found in <span class="title function_">poll</span><span class="params">()</span>.</span><br></pre></td></tr></table></figure>
<p>不同于 <code>select</code> 使用三个位图（bitmap）来表示三个 fdset 的方式，<code>poll</code> 使用一个 pollfd 结构体指针 fds 实现，nfds 为 fds 数组的长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="type">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">    <span class="type">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">    <span class="comment">/* The bits that may be set/returned in events and revents are defined in &lt;poll.h&gt;: POLLIN, POLLOUT, POLLHUP, et.al. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>pollfd 结构包含了要监视的 events 和发生的 revents，不再使用 <code>select</code> “参数 - 值” 传递的方式。同时 pollfd 并没有最大数量限制（但是数量过大后性能也会下降）。和 <code>select</code> 函数一样，<code>poll</code> 返回后，需要轮询 pollfd 来获取就绪的 fd。</p>
<p>从上面看，<code>select</code> 和 <code>poll</code> 都需要在返回后，<strong>通过遍历 fd 来获取已经就绪的 socket</strong>。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的 fd 数量的增长，其效率也会线性下降。</p>
<h2 id="epoll">epoll</h2>
<p>epoll 全称 eventpoll，是 linux 2.6 内核实现 IO 多路复用的一种实现，是之前的 <code>select</code> 和 <code>poll</code> 的增强版本。相对于 <code>select</code> 和 <code>poll</code> 来说，epoll 更加灵活、没有 fd 限制。</p>
<p><strong>epoll 使用一个 epfd 句柄管理多个 fd，将用户关心的 fd 的事件存放到内核的一个事件表（内核数据结构 struct eventpoll）中，这样只需要一次从内核空间到用户空间的拷贝（且仅需拷贝就绪的那几个事件）</strong>。</p>
<p>epoll 操作过程需要三个接口，分别如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;  <span class="comment">// 创建一个 epoll 的句柄 epfd</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>epoll_create 接口</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">    <span class="title function_">epoll_create</span><span class="params">()</span> creates a new <span class="title function_">epoll</span><span class="params">(<span class="number">7</span>)</span> instance.  Since Linux        &lt;- epoll 实例</span><br><span class="line">    2.6.8, the size argument is ignored, but must be greater than       &lt;- size 无用但要大于 0</span><br><span class="line">    zero; see HISTORY.</span><br><span class="line"></span><br><span class="line">    epoll_create() returns a file descriptor referring to the new       &lt;- 返回 epoll fd 句柄</span><br><span class="line">    epoll instance.  This file descriptor is used <span class="keyword">for</span> all the</span><br><span class="line">    subsequent calls to the epoll interface.  When no longer</span><br><span class="line">    required, the file descriptor returned by epoll_create() should     &lt;- 不再需要时要 close(epfd)</span><br><span class="line">    be closed by using close(<span class="number">2</span>).  When all file descriptors referring</span><br><span class="line">    to an epoll instance have been closed, the kernel destroys the      &lt;- 关闭后，内核销毁 epfd 实例，释放相关的 fd 资源</span><br><span class="line">    instance and releases the associated resources <span class="keyword">for</span> reuse.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">    On success, these system calls <span class="keyword">return</span> a file descriptor (a</span><br><span class="line">    nonnegative integer).  On error, <span class="number">-1</span> is returned, and errno is <span class="built_in">set</span></span><br><span class="line">    to indicate the error.</span><br></pre></td></tr></table></figure>
<p>创建一个 epoll 的句柄，<s>size 用来告诉内核这个监听的数目一共有多大，这个参数不同于 <code>select</code> 中的第一个参数（给出最大监听的 fd 值再加一），这里参数 size 并不是限制了 epoll 所能监听的 fd 最大个数，只是对内核初始分配内部数据结构的一个建议。</s> 自 Linux 2.6.8 后，size 参数被忽略，但应设置一个大于 0 的值。</p>
<blockquote>
<p>当创建好 epoll 句柄后，它就会占用一个 fd 值。在 Linux 下，如果查看 /proc/process-id/fd/，是能够看到这个 fd 的，所以在使用完 epoll 后，必须调用 <code>close()</code> 关闭，否则可能导致 fd 被耗尽。</p>
</blockquote>
<p><strong>epoll_ctl 接口</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br></pre></td></tr></table></figure>
<p>函数是对 epoll 句柄 epfd 执行 op 操作，即添加、修改或删除 epoll 句柄上的事件。</p>
<ul>
<li>epfd：epoll 句柄，是 epoll_create() 的返回值。</li>
<li>op：操作类型，用三个宏来表示，可以是 EPOLL_CTL_ADD, EPOLL_CTL_MOD, EPOLL_CTL_DEL。</li>
<li>fd：需要进行上述 op 操作的目标 fd。</li>
<li>event：指向 epoll_event 结构指针，用户进程告诉内核需要监听什么事件（即 event-&gt;events 成员指定的宏的组合事件）。</li>
</ul>
<p>epoll_event 结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>      events;  <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="type">epoll_data_t</span>  data;    <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>     *ptr;</span><br><span class="line">    <span class="type">int</span>       fd;</span><br><span class="line">    <span class="type">uint32_t</span>  u32;</span><br><span class="line">    <span class="type">uint64_t</span>  u64;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span>  <span class="title">epoll_data_t</span>;</span></span><br></pre></td></tr></table></figure>
<p>成员 events 可以是以下几个宏的集合，通过 OR 运算组合而成：</p>
<table>
<thead>
<tr>
<th>events 标志</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>EPOLLIN</td>
<td>对应的 fd 可以读（包括对端 SOCKET 正常关闭）</td>
</tr>
<tr>
<td>EPOLLOUT</td>
<td>对应的 fd 可以写</td>
</tr>
<tr>
<td>EPOLLPRI</td>
<td>对应的 fd 有紧急的数据可读</td>
</tr>
<tr>
<td>EPOLLERR</td>
<td>对应的 fd 发生错误</td>
</tr>
<tr>
<td>EPOLLHUP</td>
<td>对应的 fd 被挂起</td>
</tr>
<tr>
<td>EPOLLET</td>
<td>将 EPOLL 设置为边缘触发（Edge Triggered）模式，相对于水平触发（Level Triggered）</td>
</tr>
<tr>
<td>EPOLLONESHOT</td>
<td>只监听一次事件，当监听完该事件后，如果需要继续监听，需将该 socket fd 重新加入到 EPOLL 队列</td>
</tr>
</tbody>
</table>
<p><strong>epoll_wait 接口</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>
<p>等待 epfd 上的 I/O 事件的发生，最多返回 maxevents 个事件。成功时返回就绪事件的数量（即 events 数组中有效条目的数量），失败时返回 -1 并设置 errno 错误码。</p>
<ul>
<li>events：用户空间中用于从内核接收就绪事件的数组指针。</li>
<li>maxevents：可以返回的最大事件数。events 数组的大小应该至少是 maxevents。</li>
<li>timeout：超时时间，单位是毫秒，-1 表示一直阻塞直到有事件发生，0 表示立即返回（即使没有事件），大于 0 表示等待指定毫秒数后返回。</li>
</ul>
<h2 id="epoll 优点">epoll 优点</h2>
<p>在 <code>select</code> 和 <code>poll</code> 中，进程只有在调用一定的方法后，内核才对所有监视的 fd 进行扫描，而 <code>epoll</code> 事先通过 <code>epoll_ctl()</code> 来注册一个 fd。一旦基于某个 fd 就绪时，内核会采用类似 callback 的回调机制，迅速激活这个 fd，当进程调用 <code>epoll_wait()</code> 时便得到通知。<strong>epoll 的魅力就在于它去掉了遍历 fd 的步骤，而是通过监听回调的机制</strong>。</p>
<p><strong>监视的 fd 数量不受限制</strong></p>
<ul>
<li>epoll 所支持的 fd 上限是最大可以打开文件的数目，这个数字一般远大于 2048。举个例子，在 1GB 内存的机器上大约是 10 万左右，具体数目可以通过命令 <code>cat /proc/sys/fs/file-max</code> 来查看。这个数目通常与系统内存的大小有很大关系。</li>
<li><code>select</code> 的最大缺点是进程打开的 fd 数量是有限制的，对于连接数量较大的服务器来说，这种限制根本无法满足需求。虽然也可以选择多进程的解决方案（如 Apache 的实现方式），但尽管在 Linux 上创建进程的代价相对较小，但仍旧不可忽视，加上进程间数据同步远不如线程间同步高效，因此也不是一种完美的方案。</li>
</ul>
<p><strong>I/O 效率不会随着监视 fd 的数量增长而下降</strong></p>
<ul>
<li>epoll 不同于 <code>select</code> 和 <code>poll</code> 的轮询方式，而是通过每个 fd 定义的回调函数来实现的。只有就绪的 fd 才会执行回调函数。</li>
<li>如果没有大量的 idle-connection（空闲连接）或者 dead-connection（失效连接），epoll 的效率并不会比 <code>select</code> 或 <code>poll</code> 高很多，但是当遇到大量的 idle-connection 时，就会发现 epoll 的效率大大高于 <code>select</code> 或 <code>poll</code>。</li>
</ul>
<p>epoll 通过其独特的回调机制和对大数量 fd 的支持，显著提高了高并发场景下 I/O 操作的效率，是现代高性能网络服务器的首选 I/O 多路复用机制。</p>
<h2 id="示例代码">示例代码</h2>
<p>示例一：这个程序使用 <code>epoll</code> 实现了一个简单的事件驱动服务器，可以处理多个客户端的连接和数据读写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS (10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BUF (1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT (8080)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> epoll_fd;                              <span class="comment">// epoll create 分配的句柄</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span>                     <span class="comment">// 内核需要监听的事件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">my_events</span>[<span class="title">MAX_EVENTS</span>];</span>  <span class="comment">// 用于从内核得到就绪事件的集合</span></span><br><span class="line">    <span class="type">int</span> ready_nfds;                            <span class="comment">// epoll wait 返回的就绪事件的数量</span></span><br><span class="line">    <span class="type">int</span> sockfd, client_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>, <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> addrlen;</span><br><span class="line">    <span class="type">char</span> buffer[MAX_BUF];  <span class="comment">// 用于存储从客户端读取的数据</span></span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建服务器 socket</span></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置服务器地址结构</span></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    server_addr.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定 socket 到指定的端口，并监听客户端请求</span></span><br><span class="line">    retval = bind(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    retval = listen(sockfd, MAX_EVENTS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 epoll 实例</span></span><br><span class="line">    epoll_fd = epoll_create(MAX_EVENTS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化用于存储就绪事件的集合</span></span><br><span class="line">    <span class="built_in">memset</span>(my_events, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event) * MAX_EVENTS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加服务器 socket 到 epoll 实例，监听客户端连接事件</span></span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    ev.data.fd = sockfd;</span><br><span class="line">    retval = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, sockfd, &amp;ev);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Listening on port %d...\n&quot;</span>, PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ready_nfds = epoll_wait(epoll_fd, my_events, MAX_EVENTS, <span class="number">-1</span>);  <span class="comment">// 阻塞等待就绪事件发生</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有就绪事件，区分处理新的连接和已连接客户端的数据读写</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ready_nfds; i++) &#123;</span><br><span class="line">            <span class="comment">// 处理新的连接：客户端首次连接时添加到 epoll 事件中进行监听</span></span><br><span class="line">            <span class="keyword">if</span> (my_events[i].data.fd == sockfd) &#123;</span><br><span class="line">                addrlen = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">                client_fd = accept(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;addrlen);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将新连接的 socket 添加到 epoll 实例</span></span><br><span class="line">                ev.events = EPOLLIN;</span><br><span class="line">                ev.data.fd = client_fd;</span><br><span class="line">                retval = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, client_fd, &amp;ev);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Accepted connection from %s:%d\n&quot;</span>, inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 处理客户端 socket 的可读事件</span></span><br><span class="line">                <span class="built_in">memset</span>(buffer, <span class="number">0</span>, MAX_BUF);</span><br><span class="line">                client_fd = my_events[i].data.fd;</span><br><span class="line">                <span class="type">ssize_t</span> n = read(client_fd, buffer, MAX_BUF);</span><br><span class="line">                <span class="keyword">if</span> (n == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    close(client_fd);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Client disconnected, fd %d\n&quot;</span>, client_fd);</span><br><span class="line">                    close(client_fd);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Read from fd %d: %s&quot;</span>, client_fd, buffer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line">    close(epoll_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 Chrome 和 Postman 分别访问该服务器，可以看到：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./ioepoll</span></span><br><span class="line">Listening on port 8080...</span><br><span class="line">Accepted connection from x.x.x.x:56613</span><br><span class="line">Accepted connection from x.x.x.x:56614</span><br><span class="line">Read from fd 5: GET / HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:8080</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line"></span><br><span class="line">Accepted connection from x.x.x.x:56617</span><br><span class="line">Read from fd 7: GET /df1231213232 HTTP/1.1</span><br><span class="line">User-Agent: PostmanRuntime/7.37.3</span><br><span class="line">Accept: */*</span><br><span class="line">Postman-Token: 1d9c80eb-1f7b-46fc-a0aa-96439f0971c0</span><br><span class="line">Host: 127.0.0.1:8080</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">Client disconnected, fd 7</span><br><span class="line">Client disconnected, fd 5</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>示例二：这个程序使用 <code>epoll</code> 实现了一个简单的事件驱动模型，通过 <strong> 回调函数 </strong> 处理标准输入（stdin）的可读事件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS (10)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*event_callback)</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="comment">/* 一般回调函数定义，可供所有事件使用这一结构体，</span></span><br><span class="line"><span class="comment">       在实际使用时，可按需求强制类型转换成不同的函数指针 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> callback;</span><br><span class="line">    <span class="type">void</span>* arg;</span><br><span class="line">&#125; <span class="type">event_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_callback</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">ssize_t</span> n = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EOF on fd %d\n&quot;</span>, fd);  <span class="comment">// End of file</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Read from fd %d: %s&quot;</span>, fd, buf);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> epoll_fd;                              <span class="comment">// epoll create 分配的句柄</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span>                     <span class="comment">// 内核需要监听的事件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">my_events</span>[<span class="title">MAX_EVENTS</span>];</span>  <span class="comment">// 用于从内核得到就绪事件的集合</span></span><br><span class="line">    <span class="type">event_data_t</span>* event_data = <span class="literal">NULL</span>;           <span class="comment">// 事件的具体数据：包含 fd、回调函数、参数</span></span><br><span class="line">    <span class="type">int</span> ready_nfds;                            <span class="comment">// epoll wait 返回的就绪事件的数量</span></span><br><span class="line">    <span class="type">int</span> stdin_fd = STDIN_FILENO;               <span class="comment">// 标准输入 fd</span></span><br><span class="line">    event_callback fn_callback = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化用于存储就绪事件的集合</span></span><br><span class="line">    <span class="built_in">memset</span>(my_events, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event) * MAX_EVENTS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 epoll 实例，返回其句柄</span></span><br><span class="line">    epoll_fd = epoll_create(MAX_EVENTS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate memory for event data ⭐</span></span><br><span class="line">    event_data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">event_data_t</span>));</span><br><span class="line">    event_data-&gt;fd = stdin_fd;</span><br><span class="line">    event_data-&gt;callback = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span>)read_callback;</span><br><span class="line">    event_data-&gt;arg = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将标准输入 fd 注册到 epoll 实例中，并监听可读事件</span></span><br><span class="line">    ev.events = EPOLLIN;              <span class="comment">// 监听可读事件</span></span><br><span class="line">    ev.data.ptr = (<span class="type">void</span>*)event_data;  <span class="comment">// 用于传递具体的事件数据 ⭐</span></span><br><span class="line"></span><br><span class="line">    retval = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, stdin_fd, &amp;ev)  <span class="comment">// 将 stdin 添加到 epoll 实例中</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Listening for input on stdin...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ready_nfds = epoll_wait(epoll_fd, my_events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有就绪事件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ready_nfds; i++) &#123;</span><br><span class="line">            <span class="comment">// 监听到可读事件</span></span><br><span class="line">            <span class="keyword">if</span> (my_events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">                event_data = (<span class="type">event_data_t</span>*)my_events[i].data.ptr;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> != event_data) &#123;</span><br><span class="line">                    <span class="comment">// 获取回调函数，执行相应的事件处理函数</span></span><br><span class="line">                    fn_callback = (event_callback)event_data-&gt;callback;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="literal">NULL</span> != fn_callback) &#123;</span><br><span class="line">                        fn_callback(event_data-&gt;fd, event_data-&gt;arg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(event_data);</span><br><span class="line">    close(epoll_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述程序，在终端输入一些数据，可以看到：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./ioepoll2</span></span><br><span class="line">Listening for input on stdin...</span><br><span class="line">nihao</span><br><span class="line">Read from fd 0: nihao</span><br><span class="line">hello</span><br><span class="line">Read from fd 0: hello</span><br><span class="line">hi</span><br><span class="line">Read from fd 0: hi</span><br><span class="line">hello world!</span><br><span class="line">Read from fd 0: hello world!</span><br><span class="line">-=()&amp;*&amp;@&amp;@%&amp;!</span><br><span class="line">Read from fd 0: -=()&amp;*&amp;@&amp;@%&amp;!</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="epoll 工作模式">epoll 工作模式</h2>
<p>epoll 对 fd 的操作有两种模式：LT (level trigger) 和 ET (edge trigger)。LT 模式与 ET 模式的区别如下：</p>
<ul>
<li>LT 模式（默认模式）：当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序 <strong> 可以不立即处理该事件 </strong>。下次调用 epoll_wait 时，<strong> 会再次响应 </strong> 应用程序并通知此事件。</li>
<li>ET 模式：当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序 <strong> 必须立即处理该事件 </strong>。如果不处理，下次调用 epoll_wait 时，<strong> 不会再次响应 </strong> 应用程序并通知此事件（除非该描述符上有新的事件发生）。</li>
</ul>
<blockquote>
<p>意思就是对于就绪事件，LT 可以不着急处理，下次 epoll_wait 返回时，还有这个就绪事件；而 ET 不处理，下次 epoll_wait 返回时，不会再有这个事件（除非有新的事件发生，再次就绪）。</p>
</blockquote>
<h3 id="LT 模式">LT 模式</h3>
<p>LT 是缺省的工作方式，并且 <strong> 同时支持 block 和 non-block socket</strong>。在这种做法中，内核告诉你一个 fd 是否就绪了，然后你可以对这个就绪的 fd 进行 I/O 操作。<strong>如果你不作任何操作，内核还是会继续通知你的</strong>。</p>
<h3 id="ET 模式">ET 模式</h3>
<p>ET 是高速工作方式，<strong>只支持 non-block socket</strong>。在这种模式下，当描述符从未就绪变为就绪时，内核通过 epoll 告诉你。然后，它会假设你知道 fd 已经就绪，并且不会再为那个 fd 发送更多的就绪通知，直到你做了某些操作导致那个 fd 不再为就绪状态了。但是请注意，如果一直不对这个 fd 作 I/O 操作（从而导致它再次变成未就绪），内核不会发送更多的通知（only once）。</p>
<p><strong>ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高</strong>。当 epoll 工作在 ET 模式时，必须使用 non-block socket，以避免在一个 fd 上进行阻塞的读或写操作时，导致无法及时处理其他 fd 上的任务，从而造成任务饥饿。</p>
<h3 id="不同模式执行差异">不同模式执行差异</h3>
<p>假如有这样一个例子：</p>
<ol>
<li>我们已经把一个用来从管道中读取数据的文件句柄（RFD）添加到 epoll 描述符；</li>
<li>这个时候从管道的另一端被写入了 2KB 的数据；</li>
<li>调用 epoll_wait()，并且它会返回 RFD，说明它已经准备好读取操作；</li>
<li>然后我们读取了 1KB 的数据；</li>
<li>调用 epoll_wait() …</li>
</ol>
<p>对于 LT 模式：在第 5 步调用 epoll_wait() 之后，仍然能收到通知。</p>
<p>对于 ET 模式：如果我们在第 1 步将 RFD 添加到 epoll 描述符的时候使用了 EPOLLET 标志，那么在第 5 步调用 epoll_wait() 之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候，ET 工作模式才会汇报事件。因此在第 5 步的时候，调用者可能会放弃等待仍存在于文件输入缓冲区内的剩余数据。</p>
<p>当使用 epoll 的 ET 模型来工作时，当产生了一个 EPOLLIN 事件后，读数据的时候需要考虑的是当 recv() 返回的大小如果等于请求的大小，那么很有可能是缓冲区还有数据未读完，也意味着该次事件还没有处理完，所以还需要再次读取：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (rs) &#123;</span><br><span class="line">    buflen = recv(events[i].data.fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (buflen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 由于是非阻塞的模式，所以当 errno 为 EAGAIN 时，表示当前缓冲区已无数据可读</span></span><br><span class="line">        <span class="comment">// 在这里就当作是该次事件已处理完</span></span><br><span class="line">        <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buflen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里表示对端的 socket 已正常关闭</span></span><br><span class="line">        rs = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buflen == <span class="keyword">sizeof</span>(buf)) &#123;</span><br><span class="line">        rs = <span class="number">1</span>;  <span class="comment">// 很有可能是缓冲区还有数据未读完，需要再次尝试读取</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rs = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EAGAIN 错误码在 Linux 中的含义：</p>
<p>在 Linux 开发中，我们经常会遇到各种错误码（通过设置 <code>errno</code>），其中 EAGAIN 是一个比较常见的错误码，通常出现在进行非阻塞操作时。字面上，EAGAIN 的含义是“再试一次”。这个错误通常出现在应用程序进行非阻塞（non-blocking）操作时，如对文件、socket 或 FIFO 进行操作。</p>
<p>例如，当以 <code>O_NONBLOCK</code> 标志打开文件、socket 或 FIFO 时，如果连续执行 <code>read</code> 操作但没有数据可读，此时程序不会阻塞等待数据准备就绪，而是会返回一个错误码 EAGAIN，提示应用程序当前没有数据可读，请稍后再试。另一个例子是，当某些系统调用（如 <code>fork</code>）由于资源不足（如虚拟内存）而执行失败时，也会返回 EAGAIN，提示调用程序稍后重试，也许下一次调用会成功。</p>
<p>通过这些例子可以看出，EAGAIN 错误码通常用于指示当前操作无法立即完成，程序需要稍后重试。</p>
<blockquote>
<p>参考资料</p>
<ol>
<li>本文转载并修改自：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000003063859">https://segmentfault.com/a/1190000003063859</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1qJ411w7du/">https://www.bilibili.com/video/BV1qJ411w7du/</a></li>
<li><a target="_blank" rel="noopener" href="https://notes.shichao.io/unp/ch6/">https://notes.shichao.io/unp/ch6/</a></li>
</ol>
</blockquote>

</div>


  <div class="book-comments">
    




  </div>



<script src="/js/book-post.js"></script>


            </div>
          </div>
          <div class="column col-2 hide-lg">
            <div class="book-post-info">
  
    <div class="book-post-meta">

  <div class="author">

    <!-- Author image -->
    <div class="author-img">
      
        <figure
          class="avatar avatar-lg"
          data-initial="A"
          style="background-color: #3b4351;">
        </figure>
      
    </div>

    <!-- Author title -->
    <div class="author-title">
      <div>aha</div>
      <div>2024-05-16</div>
    </div>
  </div>

  
    <div class="divider"></div>

    <div class="link">
      <a class="category-link" href="/categories/Linux/">Linux</a> <a class="category-link" href="/categories/Linux/IO%E6%A8%A1%E5%BC%8F/">IO模式</a>

      <a class="tag-none-link" href="/tags/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" rel="tag">#IO多路复用</a> <a class="tag-none-link" href="/tags/IO%E6%A8%A1%E5%BC%8F/" rel="tag">#IO模式</a>
    </div>
    
  

  <div class="divider"></div>
</div>
  

  <div class="book-tocbot">
</div>
<div class="book-tocbot-menu">
  <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
  <a onclick="go_top()">Back to top</a>
  <a onclick="go_bottom()">Go to bottom</a>
  <a onclick="toggleSearch()">Search in blogs</a> <!-- 添加搜索文字的点击事件 -->
</div>

<div id="search-overlay" class="search-overlay" style="display: none;"> <!-- 初始状态为隐藏 -->
  <div class="search-box">
    <input type="text" id="search-input" placeholder="Search in all blogs...">
    <button onclick="closeSearch()">Close</button> <!-- 添加关闭按钮 -->
    <div id="search-results" class="search-results"></div>
  </div>
</div>

<script>
  function performSearch(query) {
    if (!query.trim()) {
      return;
    }

    fetch('/search.xml')
      .then(response => response.text())
      .then(data => {
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(data, "text/xml");
        const entries = xmlDoc.getElementsByTagName('entry');
        let results = '';

        for (let i = 0; i < entries.length; i++) {
          const title = entries[i].getElementsByTagName('title')[0].textContent;
          const content = entries[i].getElementsByTagName('content')[0].textContent;
          const url = entries[i].getElementsByTagName('url')[0].textContent;

          let count = (title.match(new RegExp(query, "gi")) || []).length; // 统计查询词出现的次数
          count += (content.match(new RegExp(query, "gi")) || []).length;

          if (count > 0) { // title.includes(query) || content.includes(query)
            results += `
              <div class="search-result-item">
                <a href="${url}">${title}</a> (${count})
              </div>`;
          }
        }

        const searchResultsElement = document.getElementById('search-results');
        searchResultsElement.innerHTML = results;
        searchResultsElement.classList.add('active');
      });
  }

  function toggleSearch() {
    const searchOverlay = document.getElementById('search-overlay');
    searchOverlay.style.display = searchOverlay.style.display === 'none' ? 'flex' : 'none';
  }

  function closeSearch() {
    document.getElementById('search-overlay').style.display = 'none';
  }

  document.getElementById('search-input').addEventListener('input', function() {
    const query = this.value;
    performSearch(query);
  });
</script>

<style>
  .search-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }

  .search-box {
    background: white;
    padding: 20px;
    border-radius: 5px;
    text-align: center;
    width: 80%;
    max-width: 500px;
  }

  .search-results {
    margin-top: 10px;
    max-height: 300px;
    overflow-y: auto;
    background: white;
    padding: 10px;
    border-radius: 5px;
    width: 100%;
  }

  .search-result-item {
    margin: 10px 0;
  }

  .search-result-item a {
    color: blue; /* 设置链接颜色为蓝色 */
    text-decoration: none;
  }

  .search-result-item a:hover {
    text-decoration: underline;
  }
</style>


<script src="/js/book-toc.js"></script>


</div>
          </div>
        </div>
      </div>

      <a class="off-canvas-overlay" onclick="hide_canvas()"></a>

      <button class="floating-button" onclick="toggleDropdownMenu()"></button>

      <div class="dropdown-menu">
        <div class="dropdown-item" onclick="changeBackgroundColor('#FFFFFF', '#000000')">银河白</div>
        <div class="dropdown-item" onclick="changeBackgroundColor('#C7EDCC', '#000000')">豆沙绿</div>
        <div class="dropdown-item" onclick="changeBackgroundColor('#FAF9DE', '#000000')">杏仁黄</div>
        <div class="dropdown-item" onclick="changeBackgroundColor('#E3EDCD', '#000000')">青草绿</div>
        <div class="dropdown-item" onclick="changeBackgroundColor('#FFF2E2', '#000000')">秋叶褐</div>
      </div>
  </div>

  <script>
    function toggleDropdownMenu() {
      document.querySelector('.floating-button').classList.toggle('active');
    }

    document.addEventListener('DOMContentLoaded', function () {
      var storedBackgroundColor = localStorage.getItem('blogBackgroundColor');
      var storedColor = localStorage.getItem('blogColor');

      if (storedBackgroundColor && storedColor) {
        document.body.style.backgroundColor = storedBackgroundColor;
        document.body.style.color = storedColor;
      }
    });

    function changeBackgroundColor(backgroundColor, color) {
      document.body.style.backgroundColor = backgroundColor;
      document.body.style.color = color;

      localStorage.setItem('blogBackgroundColor', backgroundColor);
      localStorage.setItem('blogColor', color);

      document.querySelector('.floating-button').classList.remove('active');
    }
  </script>
</body>

</html>


<script src="/js/book.js"></script>
