<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

    
      <link rel="icon" href="/favicon.png" />
    

    <title>
        
          多线程编程之 pthread 库 - aha&#39;s book
        
    </title>

    <!-- Spectre.css framework -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-exp.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-icons.min.css">

    <!-- theme css & js -->
    
<link rel="stylesheet" href="/css/book.css">

    
<script src="/js/book.js"></script>


    <!-- tocbot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
    
    <!-- katex -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">

    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/zooming/2.1.1/zooming.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    const zooming = new Zooming()
    zooming.listen('.book-content img')
})
</script>

<meta name="generator" content="Hexo 6.3.0"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body>

<div class="book-container">
  <div class="book-sidebar">
    <div class="book-brand">
  <a href="/">
    <img src="/favicon.png">
    <span>AHA&#39;S BOOK</span>
  </a>
</div>
    <div id="menu" class="book-menu hide">
  <h2 id="基础知识"> 基础知识 </h2>
<ul>
<li><a href="/posts/231010144856.html"> 模运算 </a></li>
<li><a href="/posts/231014105311.html"> 异或运算 </a></li>
<li><a href="/posts/231210181853.html"> 计算机中的寄存器 </a></li>
<li><a href="/posts/231213183051.html"> 正则表达式基础 </a></li>
</ul>
<h2 id="C 语言">C 语言 </h2>
<ul>
<li><a href="/posts/230916171929.html">main 函数参数 </a></li>
<li><a href="/posts/231214192113.html"> 关键字与专有名词 </a></li>
<li><a href="/posts/240103180653.html"> 输出打印函数 </a></li>
<li><a href="/posts/230922143003.html"> 多维数组 </a></li>
<li><a href="/posts/230913200729.html">const 关键字 </a></li>
<li><a href="/posts/230918174223.html">typedef 类型基础 </a></li>
<li><a href="/posts/230920172849.html">typedef 类型实践 </a></li>
<li><a href="/posts/240224193217.html"> 二级指针 </a></li>
<li><a href="/posts/240307195203.html"> 代码 TOP-K 问题 </a></li>
<li><a href="/posts/230922172626.html">uthash 哈希表基础 </a></li>
<li><a href="/posts/230918114841.html"> 大小端知识 </a></li>
</ul>
<h2 id="Golang 语言">Golang 语言 </h2>
<ul>
<li><a href="/posts/230907162612.html"> 变量与常量 </a></li>
<li><a href="/posts/230909120145.html"> 函数 &amp; 包 &amp; 判断 &amp; 循环 </a></li>
<li><a href="/posts/230912152800.html"> 数组与切片 </a></li>
<li><a href="/posts/230913161326.html"> 可变参数函数与 Map 集合 </a></li>
<li><a href="/posts/230915155105.html"> 字符串和指针 </a></li>
</ul>
<h2 id="数据结构"> 数据结构 </h2>
<ul>
<li><a href="/posts/231007174854.html"> 链表（数组实现）</a></li>
<li><a href="/posts/231008213450.html"> 链表（链式实现）</a></li>
<li><a href="/posts/231016161508.html"> 堆栈（数组实现）</a></li>
<li><a href="/posts/231016184406.html"> 堆栈（链表实现）</a></li>
<li><a href="/posts/231127185207.html"> 单调栈 </a></li>
<li><a href="/posts/231017105123.html"> 队列（链表实现）</a></li>
<li><a href="/posts/231017154121.html"> 双端队列（链表实现）</a></li>
<li><a href="/posts/231018102559.html"> 堆基础与堆结构（数组实现）</a></li>
<li><a href="/posts/231019102311.html"> 优先队列（堆实现）</a></li>
<li><a href="/posts/230905224335.html"> 二叉树的遍历 </a></li>
<li><a href="/posts/231020174358.html"> 二叉搜索树 </a></li>
<li><a href="/posts/230916094606.html"> 拓扑排序 </a></li>
<li><a href="/posts/230925185057.html">Trie 字典树 </a></li>
<li><a href="/posts/231023164532.html"> 并查集（数组实现）</a></li>
</ul>
<h2 id="数据结构算法"> 数据结构算法 </h2>
<ul>
<li><a href="/posts/231218181635.html"> 归并排序 </a></li>
<li><a href="/posts/231108163339.html"> 快速排序 </a></li>
<li><a href="/posts/231107171607.html"> 堆排序 </a></li>
<li><a href="/posts/231124181658.html"> 二分查找 </a></li>
<li><a href="/posts/231227190828.html"> 哈希表实现 </a></li>
<li><a href="/posts/240313193201.html"> 字符串哈希函数 </a></li>
<li><a href="/posts/231116150205.html">Floyd 多源最短路径 </a></li>
<li><a href="/posts/231117095232.html">Dijkstra 单源最短路径（原理部分）</a></li>
<li><a href="/posts/231121152713.html">Dijkstra 单源最短路径（实现部分）</a></li>
</ul>
<h2 id="计算机网络"> 计算机网络 </h2>
<ul>
<li><a href="/posts/231011192359.html">OSI 参考模型 </a></li>
<li><a href="/posts/240306203742.html">ACL 访问控制列表 </a></li>
<li><a href="/posts/240130190208.html"> 路由表、转发表与快速转发工作原理 </a></li>
<li><a href="/posts/231221200716.html">VXLAN 网络虚拟化技术 </a></li>
</ul>
<h2 id="操作系统"> 操作系统 </h2>
<ul>
<li><a href="/posts/230921190726.html"> 概述 </a></li>
<li><a href="/posts/230924172528.html"> 启动 &amp; 中断 &amp; 异常 &amp; 系统调用 </a></li>
<li><a href="/posts/231017195157.html"> 内存分层体系与地址空间生成 </a></li>
<li><a href="/posts/231108195351.html"> 连续内存分配 </a></li>
<li><a href="/posts/231111172507.html"> 非连续内存分配之分段与分页 </a></li>
<li><a href="/posts/231119170537.html"> 非连续内存分配之页表 </a></li>
<li><a href="/posts/231123184526.html"> 内存管理之覆盖技术与交换技术 </a></li>
<li><a href="/posts/231127193658.html"> 内存管理之虚存技术 </a></li>
<li><a href="/posts/231129182631.html"> 局部页面置换算法 </a></li>
<li><a href="/posts/231207184239.html"> 全局页面置换算法 </a></li>
<li><a href="/posts/231207204958.html"> 进程描述 </a></li>
<li><a href="/posts/231210211306.html"> 进程状态 </a></li>
<li><a href="/posts/231215213932.html"> 线程 </a></li>
<li><a href="/posts/231218220813.html"> 进程控制 </a></li>
<li><a href="/posts/231228193143.html"> 调度 </a></li>
<li><a href="/posts/240104202828.html"> 同步与互斥 </a></li>
<li><a href="/posts/240113115605.html"> 信号量与管程 </a></li>
<li><a href="/posts/240205182643.html"> 经典同步问题 </a></li>
</ul>
<h2 id="多线程编程"> 多线程编程 </h2>
<ul>
<li><a href="/posts/230911151334.html">pthread 库 </a></li>
<li><a href="/posts/230921094127.html"> 锁与原子操作 </a></li>
<li><a href="/posts/240319195609.html"> 读者写者问题 </a></li>
</ul>
<h2 id="工具"> 工具 </h2>
<ul>
<li><a href="/posts/240207180410.html">GCC 编译过程分解 </a></li>
<li><a href="/posts/240312184132.html">GDB 调试入门 </a></li>
</ul>
<h2 id="Docker">Docker</h2>
<ul>
<li><a href="/posts/230909171809.html">Docker 学习笔记 </a></li>
</ul>
<h1 id="LeetCode 刷题">LeetCode 刷题 </h1>
<h2 id="链表相关"> 链表相关 </h2>
<ul>
<li><a href="/posts/231025143947.html">160 相交链表 </a></li>
<li><a href="/posts/231025185947.html">206 反转链表 </a></li>
<li><a href="/posts/231026101239.html">21 合并两个有序链表 </a></li>
<li><a href="/posts/231026184514.html">83 删除排序链表中的重复元素 </a></li>
<li><a href="/posts/231027150243.html">19 删除链表的倒数第 N 个节点 </a></li>
<li><a href="/posts/231031120718.html">2 两数相加 </a></li>
<li><a href="/posts/231031163133.html">445 两数相加 II</a></li>
<li><a href="/posts/231101094219.html">234 回文链表 </a></li>
<li><a href="/posts/231101135228.html">725 分隔链表 </a></li>
<li><a href="/posts/231102120708.html">328 奇偶链表 </a></li>
<li><a href="/posts/231102165703.html">142 环形链表 II</a></li>
</ul>
<h2 id="设计"> 设计 </h2>
<ul>
<li><a href="/posts/231201184542.html">146 LRU 缓存 </a></li>
</ul>
<h2 id="贪心算法"> 贪心算法 </h2>
<ul>
<li><a href="/posts/231107094652.html">1029 两地调度 </a></li>
<li><a href="/posts/231109150855.html">435 无重叠区间 </a></li>
</ul>
<h2 id="哈希表"> 哈希表 </h2>
<ul>
<li><a href="/posts/231123181539.html">1410 实体解析器 </a></li>
</ul>
<h2 id="树的遍历"> 树的遍历 </h2>
<ul>
<li><a href="/posts/231103121209.html">117 填充每个节点的下一个右侧节点指针 II</a></li>
</ul>
<h2 id="深度优先搜索（递归）"> 深度优先搜索（递归）</h2>
<ul>
<li><a href="/posts/231206201243.html">2477 达到首都的最少油耗 </a></li>
</ul>
<h2 id="图或路径问题"> 图或路径问题 </h2>
<ul>
<li><a href="/posts/231211184652.html">1631 最小体力消耗路径 </a></li>
</ul>
<h1 id="项目"> 项目 </h1>
<h2 id="开源项目"> 开源项目 </h2>
<ul>
<li><a href="/posts/240303201855.html"> 线程池原理与实现 </a></li>
</ul>
<h2 id="非开源项目"> 非开源项目 </h2>
<ul>
<li><a href="/posts/231202180319.html"> 确定性网络 CSQF</a></li>
</ul>

</div>


<script src="/js/book-menu.js"></script>

  </div>

  <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
  <div class="sidebar-toggle-inner"></div>
</div>

<script>
function add_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.add('show')  
}

function remove_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.remove('show')
}

function sidebar_toggle() {
    let sidebar_toggle = document.querySelector('.sidebar-toggle')
    let sidebar = document.querySelector('.book-sidebar')
    let content = document.querySelector('.off-canvas-content')
    if (sidebar_toggle.classList.contains('extend')) { // show
        sidebar_toggle.classList.remove('extend')
        sidebar.classList.remove('hide')
        content.classList.remove('extend')
    }
    else { // hide
        sidebar_toggle.classList.add('extend')
        sidebar.classList.add('hide')
        content.classList.add('extend')
    }
}
</script>

  <div class="off-canvas-content">
    <div class="columns">
      <div class="column col-10 col-lg-12">
        <div class="book-navbar">
          <!-- For Responsive Layout -->

<header class="navbar">
  <section class="navbar-section">
    <a onclick="open_sidebar()">
      <i class="icon icon-menu"></i>
    </a>
  </section>
</header>

        </div>
        <div class="book-content">
          <div class="book-post">
  <h1 id="进程与线程">进程与线程</h1>
<p><strong>进程</strong>：是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单元，是应用程序运行的载体。进程一般由程序、数据集合和进程控制块三部分组成：</p>
<ul>
<li>
<p>程序：描述进程的功能，控制进程的指令集（写论文的目的和手段）</p>
</li>
<li>
<p>数据集：程序在执行时所需要的数据和工作区（写论文的材料）</p>
</li>
<li>
<p>进程控制块：跟踪每个进程的状态，操作系统会为进程保留进程列表（写作者）</p>
</li>
</ul>
<p><strong>线程 </strong>：线程是程序执行中的一个单一的<strong> 顺序控制流程</strong>，是程序执行流的最小单元，是处理器调度和分派的基本单位。</p>
<ul>
<li>
<p>一个进程至少有一个线程，一个进程也可以有多个线程。（一个父亲可以有一个、多个孩子）</p>
</li>
<li>
<p>各个线程之间共享程序的内存空间，即所在进程的内存空间。（多个孩子共享一个家庭空间）</p>
</li>
<li>
<p>一个标准的线程由线程 ID、当前指令指针 PC、寄存器和堆栈组成。（每个孩子有其自身的成长轨迹）</p>
</li>
</ul>
<span id="more"></span>
<p><strong>进程与线程的区别</strong>：</p>
<ul>
<li>
<p>线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位。</p>
</li>
<li>
<p>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线。</p>
</li>
<li>
<p>进程之间相互独立，但 <strong> 同一进程下的各个线程之间共享程序的内存空间 </strong>（代码段、数据集、堆等）以及一些<strong> 进程级的资源</strong>（如打开文件和信号等），某进程内的线程在其他进程中不可见。</p>
</li>
<li>
<p><strong>线程上下文切换比进程上下文切换要快得多</strong>。</p>
</li>
</ul>
<h1 id="上下文切换">上下文切换</h1>
<h2 id="时间片">时间片</h2>
<p>多任务系统往往需要同时执行多道作业。作业数往往大于机器的 CPU 数，然而一颗 CPU 同时只能执行一项任务，如何让用户感觉这些任务正在同时进行呢? 操作系统的设计者巧妙地利用了 <strong> 时间片轮转的方式</strong>。</p>
<p><strong>时间片是 CPU 分配给各个任务（线程）的时间</strong>。</p>
<blockquote>
<p>思考：单核 CPU 为何也支持多线程呢？</p>
<p>虽然单核 CPU 只有一个物理处理单元，但它可以 <strong> 通过时间分片的方式支持多线程</strong>。在单核 CPU 中，操作系统通过时间片轮转算法将 CPU 时间划分为多个时间片段，每个时间片段分配给一个线程执行。当一个线程的时间片用完后，操作系统会暂停该线程的执行，并切换到下一个线程继续执行。这种切换是非常快速的，以至于我们感觉多个线程在同时执行。</p>
<p>需要注意的是，在单核 CPU 上并发执行的多线程是通过时间片轮转调度实现的，在任意给定的时间点上 <strong> 只能有一个 </strong> 线程在执行。而在多核 CPU 上，可以实现真正的并行执行，每个核心可以同时执行一个线程，从而提高并发性能。</p>
</blockquote>
<h2 id="上下文切换 -v2">上下文切换</h2>
<p><strong>线程上下文 </strong>：是指某一时间点 CPU <strong> 寄存器和程序计数器的内容</strong>，CPU 通过时间片分配算法来循环执行任务（线程），因为时间片非常短，所以 CPU 通过不停地切换线程执行。</p>
<p>换言之，单 CPU 这么频繁，多核 CPU 一定程度上可以减少上下文切换。</p>
<p><strong>上下文切换 </strong>：CPU 切换前把当前任务的状态保存下来（以便下次切换回这个任务时可以再次加载这个任务的状态），然后加载下一任务的状态并执行。<strong> 任务的状态保存及再加载</strong>，这段过程就叫做上下文切换。</p>
<h2 id="多线程编程">多线程编程</h2>
<ul>
<li>
<p>多进程模式：启动多个进程，每个进程虽然只有一个线程，但是多个进程可以一块执行多个任务。</p>
</li>
<li>
<p><strong>多线程模式</strong>：启动一个进程，在一个进程内启动多个线程，多个线程一起执行多个任务。</p>
</li>
<li>
<p>多进程 + 多线程模式：启动多个进程，每个进程再启动多个线程，这样同时执行的任务就更多了。</p>
</li>
</ul>
<p>其实创建线程之后，线程并不是始终保持一个状态的，其状态大概如下：</p>
<ol>
<li>New 创建</li>
<li>Runnable 就绪，等待调度</li>
<li>Running 运行</li>
<li>Blocked 阻塞，阻塞可能在 Wait / Locked / Sleeping 阶段</li>
<li>Dead 消亡</li>
</ol>
<p>线程有着不同的状态，也有不同的类型。大致可分为：</p>
<ul>
<li>
<p>主线程：主线程是程序启动时自动创建的线程，它负责执行程序的主要逻辑。主线程通常负责处理用户交互、调度其他线程的创建和管理等任务。</p>
</li>
<li>
<p>子线程：子线程是由主线程创建的额外线程，用于执行并发任务。子线程可以并行地执行任务，从而提高程序的效率和响应性。</p>
</li>
<li>
<p>守护线程（后台线程）：守护线程是一种特殊类型的线程，它在后台运行，<strong>不会阻止程序的退出</strong>。当所有的非守护线程都退出时，守护线程也会自动结束。守护线程通常用于执行一些后台任务，如日志记录、定时任务等。</p>
</li>
<li>
<p>前台线程：前台线程是与守护线程相对的概念，它是指 <strong> 会阻止程序退出的线程</strong>。当所有的前台线程都退出时，程序才会结束。</p>
</li>
</ul>
<h1 id="pthread 多线程">pthread 多线程</h1>
<p>POSIX 线程（Pthreads）是一套标准的线程 API，用于多线程编程。该库定义了一组 C 语言函数，允许程序员创建和管理多个线程，并提供同步和互斥机制，以确保线程之间的正确协调。</p>
<p>Pthreads 库是 POSIX 标准的一部分，其全称是“Portable Operating System Interface”，旨在为 Unix-like 操作系统（如 Linux、FreeBSD、Mac OS X 等）提供一致的接口。由于该标准的广泛接受和实现，因此 Pthreads 库现在在许多不同的平台上都可用。</p>
<p>Pthreads 库的一个优点是它允许程序员创建轻量级线程（LWT），这些线程比进程更轻量级，因此在创建和销毁它们时所需的开销较小。此外，由于它是标准的 POSIX 接口，因此 Pthreads 库可在不同的操作系统上重用，从而提高了代码的可移植性。</p>
<p>Pthread 库需要头文件：<code>pthread.h</code></p>
<p>gcc 编译链接参数：<code>lpthread</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc ./demo.c -o demo -lpthread</span><br></pre></td></tr></table></figure>
<h2 id="创建线程相关">创建线程相关</h2>
<h3 id="pthread-create">pthread_create</h3>
<p><code>pthread_create</code>是一个用于创建线程的函数，它的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pthread_t 类型的原型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="type">pthread_t</span>;</span><br></pre></td></tr></table></figure>
<p>该函数接收四个参数，分别是：</p>
<ol>
<li>
<p><code>thread</code>：一个指向线程标识符的指针，由函数创建并返回。</p>
</li>
<li>
<p><code>attr</code>：一个指向线程属性的指针，用于设置线程的属性。如果不需要设置属性，传入 <code>NULL</code> 即可。</p>
</li>
<li>
<p><code>start_routine</code>：线程执行的函数指针，该函数接受一个 <code>void *</code> 类型的参数，并返回一个 <code>void *</code> 类型的值。</p>
</li>
<li>
<p><code>arg</code>：传递给线程执行函数的参数，如果有多个参数，可以传递一个指向参数结构体的指针。</p>
</li>
</ol>
<p>当调用 <code>pthread_create</code> 函数时，它会创建一个新的线程，并将其标识符存储在 <code>thread</code> 指针中。新线程的执行将从 <code>start_routine</code> 函数开始，<code>arg</code>参数将作为 <code>start_routine</code> 的参数传递给它。</p>
<p>创建线程时，可以选择使用默认线程属性，也可以使用 <code>pthread_attr_t</code> 结构体来设置一些属性，例如线程的调度策略、栈大小、优先级等等。如果不需要设置属性，可以将 <code>attr</code> 参数设置为<code>NULL</code>。</p>
<p><code>pthread_create</code>函数成功时返回 0，否则返回一个错误码。如果返回非零错误码，可以使用 <code>perror</code> 函数或 <code>strerror</code> 函数打印出错误信息。</p>
<h3 id="pthread-self">pthread_self</h3>
<p><code>pthread_self</code>函数返回调用线程的线程 ID，即等于线程创建中返回给 <code>*thread</code> 的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="pthread-equal">pthread_equal</h3>
<p><code>pthread_equal</code>函数通过线程 ID 比较线程是否相等，如果两个线程相等，返回非 0 值，如果不相等，返回 0：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="pthread-detach">pthread_detach</h3>
<p><code>pthread_detach</code> 函数用于将指定的线程分离出去，所谓分离出去就是指 <strong> 主线程不再需要 </strong> 通过 <code>pthread_join</code> 方式，等待该线程的结束并回收其线程控制块（TCB）资源，<strong>被分离的线程结束后由操作系统负责其资源的回收</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure>
<p>其中，<code>thread</code> 参数是要分离的线程的标识符，返回值为 0 表示成功，非 0 值表示出错。</p>
<blockquote>
<p>需要注意的是，如果一个线程被分离了，就不能再对它调用 <code>pthread_join</code> 函数，否则会出错。因此，在调用 <code>pthread_detach</code> 函数之前，必须确保不会再调用 <code>pthread_join</code> 函数。</p>
</blockquote>
<p>一般来说，主线程是要负责创建出来的子线程的资源回收工作的：</p>
<ul>
<li>
<p>如果主线程先于子线程退出，并且子线程没有设置为分离状态，那么子线程结束后其资源是无法得到回收的，会造成资源浪费和系统臃肿。</p>
</li>
<li>
<p>如果主线程先于子线程退出，但是子线程是分离状态，那么子线程退出的时候操作系统会自动回收其资源。</p>
</li>
</ul>
<p>分离线程并不是分离了之后，就跟主线程没有一点关系了。<strong>主线程退出了，分离线程还是一样退出</strong>，只是分离线程的资源是由系统回收的。</p>
<h2 id="终止线程相关">终止线程相关</h2>
<p>终止线程的三种方式：</p>
<ol>
<li>
<p>线程从启动例程（线程创建接口中的函数指针<code>start_routine</code>）返回，返回值就是线程的退出码；</p>
</li>
<li>
<p>线程可以被同一进程中的其他线程取消（通过<code>pthread_cancel()</code>）；</p>
</li>
<li>
<p>线程自身调用 <code>pthread_ exit()</code> 函数终止。</p>
</li>
</ol>
<h3 id="pthread-cancel">pthread_cancel</h3>
<p><code>pthread_cancel</code> 函数是一个用于取消 POSIX 线程的函数。该函数向目标线程发送一个取消请求，如果该线程允许取消，则会在处理该请求时终止该线程的执行。</p>
<blockquote>
<p>线程可以设置为允许取消（默认情况下）或者禁止取消。如果线程允许取消，它将在收到取消请求后 <strong> 尽快取消</strong>，并执行一些清理工作；如果线程禁止取消，它将继续运行，直到完成其任务或者显式地调用 <code>pthread_exit</code> 函数。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure>
<p><code>pthread_cancel</code> 函数有以下两种用法：</p>
<ol>
<li>
<p><code>int pthread_cancel(pthread_t thread);</code> 此用法向线程 ID 为 <code>thread</code> 的线程发送取消请求。如果请求成功发送，则返回 0。如果线程 ID 无效或请求无法发送，则返回一个非零错误码。</p>
</li>
<li>
<p><code>void pthread_testcancel(void);</code> 此用法可以在线程执行期间调用，用于测试是否有取消请求已经发送给该线程。如果是，则在线程执行期间发生取消动作，该线程的执行将立即停止。</p>
</li>
</ol>
<p>需要注意的是，<code>pthread_cancel</code> 函数并不保证能够成功地取消目标线程的执行。当目标线程正在执行某些不可取消的操作（例如某些系统调用）时，取消请求可能会被暂时挂起，直到目标线程离开这些操作为止。另外，使用 <code>pthread_cancel</code> 函数需要注意线程同步问题，避免出现死锁等问题。</p>
<p>总的来说，<code>pthread_cancel</code> 函数可以用于线程的优雅终止，但是需要谨慎使用，避免出现意外的问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread is running...\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 在循环中调用 pthread_testcancel 函数检查是否有取消请求</span></span><br><span class="line">        pthread_testcancel();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread_id;</span><br><span class="line">    <span class="comment">// 创建一个线程并启动它</span></span><br><span class="line">    pthread_create(&amp;thread_id, <span class="literal">NULL</span>, &amp;thread_func, <span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 在主线程中调用 pthread_cancel 函数向子线程发送取消请求</span></span><br><span class="line">    pthread_cancel(thread_id);</span><br><span class="line">    <span class="comment">// 等待子线程结束</span></span><br><span class="line">    pthread_join(thread_id, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread has been canceled.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@fw:~/ccodes# ./demo</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread has been canceled.</span><br><span class="line">root@fw:~/ccodes#</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，首先创建了一个子线程并启动它，在子线程的循环中不断输出信息，同时在循环中调用 <code>pthread_testcancel</code> 函数检查是否有取消请求。在主线程中等待 5 秒钟后，调用 <code>pthread_cancel</code> 函数向子线程发送取消请求，然后等待子线程结束并输出一条信息表示子线程已经被成功取消。</p>
<p><strong>调用与不调用 <code>pthread_testcancel()</code> 的区别</strong>：</p>
<ol>
<li>调用 <code>pthread_testcancel</code> 函数可以让线程在循环或其他 <em> 可取消的操作中 </em> 主动检查是否有取消请求，并在检测到取消请求时 <em> 及时终止 </em> 线程的执行。这样可以增加线程的可靠性，<strong>确保线程在可以取消的时候及时响应取消请求</strong>。</li>
<li>如果不调用 <code>pthread_testcancel</code> 函数，线程可能会在某些不可取消的操作中被阻塞（例如在 <code>sleep</code> 等待时），无法及时响应取消请求，导致取消请求被暂时挂起。</li>
</ol>
<p>因此，为了保证线程及时响应取消请求，<strong>通常建议 </strong> 在线程的循环或其他可取消的操作中调用 <code>pthread_testcancel</code> 函数，以便让线程在合适的时机进行取消。但是需要注意的是，在使用 <code>pthread_testcancel</code> 函数时，必须确保线程的同步操作是线程安全的，否则可能会导致程序出现不可预期的错误。</p>
<p>当然，在某些情况下，如果线程不会进入可取消状态或在处理临界区时不能被取消，那么调用 <code>pthread_testcancel</code> 函数可能会导致线程被错误地取消。在这种情况下，可以通过设置线程的取消状态为 <code>PTHREAD_CANCEL_DISABLE</code> 来禁用取消操作，以避免意外的取消。</p>
<p>总之，调用 <code>pthread_testcancel</code> 函数可以让线程更加及时地、可靠地响应取消请求，从而增加程序的安全性和稳定性，但需要注意线程同步的问题，以避免出现错误。</p>
<h3 id="pthread-exit">pthread_exit</h3>
<p><code>pthread_exit()</code>是一个线程终止函数，它允许一个线程在它的 <strong> 任意位置退出</strong>。该函数接受一个参数，表示线程的返回值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure>
<p>调用 <code>pthread_exit()</code> 函数会立即终止当前线程的执行，并将传递的参数作为线程的返回值。如果该线程被其他线程等待，那么该返回值可以被其他线程获取。</p>
<blockquote>
<p>注意：指针 <code>retval</code> 指向的内容不能为函数中局部变量，因为一旦线程函数终止，它们将不再存在。</p>
</blockquote>
<p><code>pthread_exit()</code>函数通常在以下情况下使用：</p>
<ol>
<li>
<p>在线程执行完任务后，主动结束自己的执行。</p>
</li>
<li>
<p>当线程执行出现错误时，使用该函数退出线程。</p>
</li>
<li>
<p>在主线程中调用 <code>pthread_exit()</code> 函数来结束整个程序的执行。</p>
</li>
</ol>
<blockquote>
<p>注意：如果在主线程中调用了<code>pthread_exit(NULL)</code>，则主线程退出，而不是退出进程。因此，如果子线程存在，会继续执行。</p>
<p>需要注意的是，当一个线程调用 <code>pthread_exit()</code> 函数后，该线程会 <strong> 立即终止，不会再执行任何其他操作 </strong>。因此，如果线程需要进行一些清理工作，比如释放内存、关闭文件等，就需要在调用<code>pthread_exit()</code> 函数之前完成这些操作。</p>
</blockquote>
<h2 id="等待线程结束">等待线程结束</h2>
<h3 id="pthread-join">pthread_join</h3>
<p><code>pthread_join</code>函数用于 <strong> 等待一个指定线程结束，并回收其占用的资源</strong>。它的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>thread</code>：要等待的线程标识符，即线程创建时传递给 <code>pthread_t *</code> 类型的值。</li>
<li><code>retval</code>：用于存储线程的返回值的指针，该参数是一个指向指针的指针。这是因为 <strong> 线程的返回值类型是不确定的，可能是一个整型、浮点型或者指针等类型</strong>。</li>
</ol>
<p>函数返回时，线程的返回值的指针将会被存储在二级指针 <code>retval</code> 所指向的内存空间中。</p>
<blockquote>
<p>需要注意的是，如果不需要获取线程的返回值，可以将其设置为 <code>NULL</code>。另外，如果线程没有返回值，或者<strong> 在线程函数中没有显式地调用 <code>pthread_exit</code> 函数退出线程 </strong>，那么<code>retval</code> 参数将被忽略。</p>
</blockquote>
<p><strong>该函数会阻塞当前线程，直到指定的线程 <code>thread</code> 结束执行 </strong>。具体来说，当我们调用<code>pthread_join</code> 函数时：</p>
<ul>
<li>如果指定的线程 <code>thread</code> 还在运行中，当前线程就会被阻塞，等待该线程结束；</li>
<li>如果线程 <code>thread</code> 已经结束了，那么 <code>pthread_join</code> 函数会立即返回，并将线程的返回值存储在 <code>retval</code> 中。</li>
</ul>
<p>此外，<code>pthread_join</code>函数会自动回收线程占用的资源，避免了资源泄露的问题。</p>
<p>以下是一个简单的示例代码，用于演示如何使用 <code>pthread_join</code> 函数等待线程结束并获取其返回值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *num = (<span class="type">int</span> *)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread is running, parameter is %d\n&quot;</span>, *num);</span><br><span class="line">    <span class="type">int</span> *res = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 线程退出的返回值不能是局部变量，这是 malloc 的原因</span></span><br><span class="line">    *res = (*num) * (*num);</span><br><span class="line">    pthread_exit((<span class="type">void</span> *)res);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="type">int</span> param = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *res;</span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, thread_func, (<span class="type">void</span> *)&amp;param);</span><br><span class="line">    pthread_join(thread, (<span class="type">void</span> **)&amp;res);  <span class="comment">// 通过二级指针 (&amp;res) 在函数内改变指向的地址 (res) 下的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread returned: %d\n&quot;</span>, *res);</span><br><span class="line">    <span class="built_in">free</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread is running, parameter is 10</span></span><br><span class="line"><span class="comment">// Thread returned: 100</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果在线程函数中不调用 <code>pthread_exit</code> 函数退出线程，而是直接返回，那么该线程的返回值将是一个未定义的值，可能会导致程序出现不可预料的错误。因此，<strong>在需要线程返回值时，一定要在线程函数中调用 <code>pthread_exit</code> 函数退出线程</strong>。</p>
<h1 id="多线程示例">多线程示例</h1>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">my_thread_func</span><span class="params">(<span class="type">void</span>* ptr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> val = *(<span class="type">int</span>*)ptr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread #%lu running, param val = %d, iter &quot;</span>, pthread_self(), val);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%dth &quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> threadId[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span>* ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        *ptr = i;  <span class="comment">// 注意一</span></span><br><span class="line">        pthread_create(&amp;threadId[i], <span class="literal">NULL</span>, my_thread_func, (<span class="type">void</span>*)(ptr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        pthread_join(threadId[i], (<span class="type">void</span>**)(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread end\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于注意一的解释：在 <code>main</code> 函数中循环创建 5 个线程时，每个线程的 <code>my_thread_func</code> 函数都被传递了指向 <code>i</code> 的指针，而 <code>i</code> 是一个 <em> 自动变量 </em>，其生命周期仅在循环内部。<strong> 由于线程的创建和调度是异步的</strong>，因此当线程实际运行时，<code>i</code> 可能已经被更新成另一个值，这会导致线程使用了错误的数据。</p>
<p>正确做法：使用 <code>malloc</code> 申请临时变量来保存自动变量 <code>i</code> 的值，每个线程函数都被传递了一个指向分配的临时变量的指针，该变量保存了正确的 <code>i</code> 值。在线程函数中，使用 <code>*(int *)pointer</code> 获取 <code>i</code> 的值，并在使用完后释放该临时变量的内存空间。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread #140021109618240 running, param val = 0, iter 0th 1th 2th 3th</span><br><span class="line">thread #140021101225536 running, param val = 1, iter 0th 1th 2th 3th</span><br><span class="line">thread #140020958615104 running, param val = 2, iter thread #140021092832832 running, param val = 3, iter 0th 1th 2th 3th</span><br><span class="line">0th 1th 2th 3th</span><br><span class="line">thread #140021084440128 running, param val = 4, iter 0th 1th 2th 3th</span><br><span class="line">main thread end</span><br></pre></td></tr></table></figure>
<p>由于线程之间是异步执行的，<strong>无法保证互斥执行（线程的临界资源要么不执行、要么全部执行）</strong>。如上面打印中，线程 15104 还没来得及迭代，就被线程 32832 抢占了 CPU 执行权。因此，如果需要保证互斥执行，可以使用互斥锁来实现。</p>
<h1 id="多线程互斥访问示例">多线程互斥访问示例</h1>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">my_thread_func</span><span class="params">(<span class="type">void</span>* ptr)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="type">int</span> val = *(<span class="type">int</span>*)ptr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread #%lu running, param val = %d, iter &quot;</span>, pthread_self(), val);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%dth &quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> threadId[<span class="number">5</span>];</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span>* ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        *ptr = i;  <span class="comment">// 注意一</span></span><br><span class="line">        pthread_create(&amp;threadId[i], <span class="literal">NULL</span>, my_thread_func, (<span class="type">void</span>*)(ptr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        pthread_join(threadId[i], (<span class="type">void</span>**)(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread end\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在修改后的代码中，我们使用 <code>pthread_mutex_t</code> 类型定义了一个互斥锁，并在 <code>main</code> 函数中初始化了它。在 <code>my_thread_func</code> 函数中，我们在循环前加锁（某一个线程获取了锁），循环结束后解锁（该线程释放了锁，此时其它线程可以获取锁了），以保证线程的互斥访问（先获取锁的线程，会执行完锁之间的内容，不再会出现上面未加锁的示例中，执行到一半，便去执行其它线程的内容）。最后在 <code>main</code> 函数结束前销毁互斥锁。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread #140354695198272 running, param val = 0, iter 0th 1th 2th 3th</span><br><span class="line">thread #140354678412864 running, param val = 2, iter 0th 1th 2th 3th</span><br><span class="line">thread #140354686805568 running, param val = 1, iter 0th 1th 2th 3th</span><br><span class="line">thread #140354661627456 running, param val = 4, iter 0th 1th 2th 3th</span><br><span class="line">thread #140354670020160 running, param val = 3, iter 0th 1th 2th 3th</span><br><span class="line">main thread end</span><br></pre></td></tr></table></figure>

</div>


  <div class="book-comments">
    




  </div>



<script src="/js/book-post.js"></script>

        </div>
      </div>
      <div class="column col-2 hide-lg">
        <div class="book-post-info">
  
    <div class="book-post-meta">

  <div class="author">

    <!-- Author image -->
    <div class="author-img">
      
        <figure
          class="avatar avatar-lg"
          data-initial="A"
          style="background-color: #3b4351;">
        </figure>
      
    </div>

    <!-- Author title -->
    <div class="author-title">
      <div>aha</div>
      <div>2023-09-11</div>
    </div>
  </div>

  
    <div class="divider"></div>

    <div class="link">
      <a class="category-link" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/">多线程编程</a>

      <a class="tag-none-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">#多线程</a> <a class="tag-none-link" href="/tags/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" rel="tag">#进程与线程</a>
    </div>
    
  

  <div class="divider"></div>
</div>
  

  <div class="book-tocbot">
</div>
<div class="book-tocbot-menu">
  <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
  <a onclick="go_top()">Back to top</a>
  <a onclick="go_bottom()">Go to bottom</a>
</div>


<script src="/js/book-toc.js"></script>

</div>
      </div>
    </div>
  </div>
  
  <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>

</body>
</html>


<script src="/js/book.js"></script>
