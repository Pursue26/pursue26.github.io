<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"pursue26.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"fold":{"enable":true,"height":300},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如MySQL。 线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者（worker）分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的">
<meta property="og:type" content="article">
<meta property="og:title" content="项目之线程池原理与实现">
<meta property="og:url" content="https://pursue26.github.io/posts/240303201855.html">
<meta property="og:site_name" content="aha&#39;s blog">
<meta property="og:description" content="线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如MySQL。 线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者（worker）分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pursue26.github.io/images/projects/c-thread-pool/thread-pool-1.png">
<meta property="og:image" content="https://pursue26.github.io/images/projects/c-thread-pool/blocking-queue.png">
<meta property="og:image" content="https://pursue26.github.io/images/projects/c-thread-pool/thread-pool-struct.png">
<meta property="og:image" content="https://pursue26.github.io/images/projects/c-thread-pool/thread-pool-bsem-method.png">
<meta property="og:image" content="https://pursue26.github.io/images/projects/c-thread-pool/thread-pool-thpool-method.png">
<meta property="og:image" content="https://pursue26.github.io/images/projects/c-thread-pool/thread-pool-thread-method.png">
<meta property="og:image" content="https://pursue26.github.io/images/projects/c-thread-pool/thread-pool-queue-method.png">
<meta property="article:published_time" content="2024-03-03T12:18:55.000Z">
<meta property="article:modified_time" content="2024-03-03T10:59:27.572Z">
<meta property="article:author" content="aha">
<meta property="article:tag" content="多线程">
<meta property="article:tag" content="线程池">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pursue26.github.io/images/projects/c-thread-pool/thread-pool-1.png">


<link rel="canonical" href="https://pursue26.github.io/posts/240303201855.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://pursue26.github.io/posts/240303201855.html","path":"posts/240303201855.html","title":"项目之线程池原理与实现"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>项目之线程池原理与实现 | aha's blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">aha's blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-dailyblog"><a href="/random.html" rel="section"><i class="fa fa-file fa-fw"></i>每日博客</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.</span> <span class="nav-text">为什么选择线程池 </span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">2.</span> <span class="nav-text">线程池的好处 </span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">线程池解决的问题 </span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C"><span class="nav-number">4.</span> <span class="nav-text">线程池如何工作 </span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-Thread-Pool"><span class="nav-number">5.</span> <span class="nav-text">C-Thread-Pool</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AC%E5%85%B1%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.1.</span> <span class="nav-text">公共接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="nav-number">5.2.</span> <span class="nav-text">接口使用实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%84%E7%BB%87%E5%85%B3%E7%B3%BB"><span class="nav-number">5.3.</span> <span class="nav-text">数据结构组织关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.4.</span> <span class="nav-text">二进制信号量接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.5.</span> <span class="nav-text">线程池接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">5.5.1.</span> <span class="nav-text">线程池初始化 </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1"><span class="nav-number">5.5.2.</span> <span class="nav-text">线程池添加任务 </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AD%89%E5%BE%85"><span class="nav-number">5.5.3.</span> <span class="nav-text">线程池等待 </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%94%80%E6%AF%81"><span class="nav-number">5.5.4.</span> <span class="nav-text">线程池销毁 </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9A%82%E5%81%9C%E4%B8%8E%E6%81%A2%E5%A4%8D"><span class="nav-number">5.5.5.</span> <span class="nav-text">线程池暂停与恢复</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.6.</span> <span class="nav-text">线程接口 </span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">5.6.1.</span> <span class="nav-text">线程初始化 </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%20worker"><span class="nav-number">5.6.2.</span> <span class="nav-text">线程 worker</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.7.</span> <span class="nav-text">队列接口 </span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">aha</p>
  <div class="site-description" itemprop="description">经历一个过程然后成为更好的自己</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">88</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">115</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://pursue26.github.io/posts/240303201855.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aha">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aha's blog">
      <meta itemprop="description" content="经历一个过程然后成为更好的自己">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="项目之线程池原理与实现 | aha's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          项目之线程池原理与实现
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
  
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-03-03 20:18:55 / 修改时间：18:59:27" itemprop="dateCreated datePublished" datetime="2024-03-03T20:18:55+08:00">2024-03-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">项目</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%A1%B9%E7%9B%AE/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">多线程</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>17 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p><strong>线程池（Thread Pool）</strong>是一种基于 <strong> 池化思想 </strong> 管理线程的工具，经常出现在多线程服务器中，如 MySQL。</p>
<p>线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。<strong>线程池维护多个线程，等待监督管理者（worker）分配可并发执行的任务</strong>。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。</p>
<span id="more"></span>

<h1 id="为什么选择线程池"><a href="# 为什么选择线程池" class="headerlink" title="为什么选择线程池"></a>为什么选择线程池 </h1><p> 创建线程可能是非常昂贵的。通常每个线程都会执行几乎相同的任务，包括创建线程、执行任务和销毁线程等。线程本身相当 heavy —— 创建或销毁线程会占用很多本来想要执行的任务时间。因此，<strong>重用线程是一个很好的选择</strong>。</p>
<p>线程池的另一个好处是它可以防止系统过载（overloaded），它允许 <strong> 限制线程数量、任务排队，并仅在线程可用时运行任务</strong>。</p>
<blockquote>
<p>线程池维持固定数量的线程，并等待执行特定任务。该线程池可以设计为根据您需要完成的工作量进行扩展，但我更喜欢 <strong> 指定固定数量的线程 </strong>。为了确定这个数量，通常可以考虑<strong> 使用系统上的核心 / 处理器数量加一</strong>。</p>
</blockquote>
<h1 id="线程池的好处"><a href="# 线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处 </h1><p> 使用线程池可以带来一系列好处：</p>
<ul>
<li>降低资源消耗（系统资源）：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。</li>
<li>提高线程的可管理性（系统资源）：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</li>
<li>提高响应速度（任务响应）：任务到达时，无需等待线程创建即可立即执行。</li>
</ul>
<h1 id="线程池解决的问题"><a href="# 线程池解决的问题" class="headerlink" title="线程池解决的问题"></a>线程池解决的问题 </h1><p> 线程池解决的核心问题就是资源管理问题。<strong>在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入</strong>。这种不确定性将带来以下若干问题：</p>
<ul>
<li>频繁申请 / 销毁资源和调度资源：将带来额外的消耗，可能会非常巨大。</li>
<li>对资源无限申请缺少抑制手段：易引发系统资源耗尽的风险。</li>
<li>系统无法合理管理内部的资源分布：会降低系统的稳定性。</li>
</ul>
<h1 id="线程池如何工作"><a href="# 线程池如何工作" class="headerlink" title="线程池如何工作"></a><a target="_blank" rel="noopener" href="https://jenkov.com/tutorials/java-concurrency/thread-pools.html#how-a-thread-pool-works">线程池如何工作 </a></h1><p> 可以将任务传递到线程池，而不是为每个任务启动一个新线程来并发地执行。一旦池中有任何空闲线程（idle threads），任务就会分配给其中一个空闲线程并执行。在内部，任务被插入到阻塞队列（Blocking Queue）中，池中的线程将从该队列中出队。当一个新任务被插入队列时，其中一个空闲线程将成功地将其出队并执行它。池中的其余空闲线程将被阻塞，等待任务出队。</p>
<img src="../images/projects/c-thread-pool/thread-pool-1.png" alt="线程池如何工作" width="100%" height="100%">

<p>何为阻塞队列（Blocking Queue）？</p>
<img src="../images/projects/c-thread-pool/blocking-queue.png" alt="阻塞队列" width="100%" height="100%">

<h1 id="C-Thread-Pool"><a href="#C-Thread-Pool" class="headerlink" title="C-Thread-Pool"></a>C-Thread-Pool</h1><p>后续内容是对基于 C 语言实现的线程池的开源项目 <a target="_blank" rel="noopener" href="https://github.com/Pithikos/C-Thread-Pool">C-Thread-Pool</a> 的学习。</p>
<h2 id="公共接口"><a href="# 公共接口" class="headerlink" title="公共接口"></a>公共接口</h2><table>
<thead>
<tr>
<th>Function example</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>thpool_init(4)</code></td>
<td>Will return a new threadpool with <code>4</code> threads.</td>
</tr>
<tr>
<td><code>thpool_add_work(thpool,func_p,arg_p)</code></td>
<td>Will add new work to the pool. Work is simply a function. You can pass a single argument to the function if you wish. If not, <code>NULL</code> should be passed.</td>
</tr>
<tr>
<td><code>thpool_wait(thpool)</code></td>
<td>Will wait for all jobs (both in queue and currently running) to finish.</td>
</tr>
<tr>
<td><code>thpool_destroy(thpool)</code></td>
<td>This will destroy the threadpool. If jobs are currently being executed, then it will wait for them to finish.</td>
</tr>
<tr>
<td><code>thpool_pause(thpool)</code></td>
<td>All threads in the threadpool will pause no matter if they are idle or executing work.</td>
</tr>
<tr>
<td><code>thpool_resume(thpool)</code></td>
<td>If the threadpool is paused, then all threads will resume from where they were.</td>
</tr>
<tr>
<td><code>thpool_num_threads_working(thpool)</code></td>
<td>Will return the number of currently working threads.</td>
</tr>
</tbody></table>
<h2 id="接口使用实例"><a href="# 接口使用实例" class="headerlink" title="接口使用实例"></a>接口使用实例</h2><p>We create a pool of 4 threads and then add 40 tasks to the pool (20 task1 functions and 20 task2 functions). task1 and task2 simply print which thread is running them.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">task1</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Task1, Thread #%u working on %d\n&quot;</span>, (<span class="type">int</span>)pthread_self(), (<span class="type">int</span>)(<span class="type">uintptr_t</span>)arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">task2</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Task2, Thread #%u working on %d\n&quot;</span>, (<span class="type">int</span>)pthread_self(), (<span class="type">int</span>)(<span class="type">uintptr_t</span>)arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Making threadpool with 4 threads&quot;</span>);</span><br><span class="line">    threadpool thpool = thpool_init(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Adding 40 tasks to threadpool&quot;</span>);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">        thpool_add_work(thpool, (<span class="type">void</span> (*)(<span class="type">void</span>*))(i % <span class="number">2</span> ? task1 : task2), (<span class="type">void</span>*)(<span class="type">uintptr_t</span>)i);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    thpool_wait(thpool);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Killing threadpool&quot;</span>);</span><br><span class="line">    thpool_destroy(thpool);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As soon as we add the tasks to the pool, the threads will run them. It can happen that you see a single thread running all the tasks (highly unlikely). It is up the OS to decide which thread will run what. So it is not an error of the thread pool but rather a decision of the OS.</p>
<h2 id="数据结构组织关系"><a href="# 数据结构组织关系" class="headerlink" title="数据结构组织关系"></a>数据结构组织关系</h2><img src="../images/projects/c-thread-pool/thread-pool-struct.png" alt="线程池数据结构组织关系" width="100%" height="100%">

<p><a target="_blank" rel="noopener" href="https://github.com/Pithikos/C-Thread-Pool">C-Thread-Pool</a> 实现的线程池包括如下数据结构：</p>
<ul>
<li>线程池数据结构：包括申请创建的每个线程的地址、任务队列等；</li>
<li>线程数据结构：包括创建的线程、线程所属的线程池等；</li>
<li>任务队列数据结构：包括一个是否存在任务的信号量；</li>
<li>任务数据结构；</li>
<li>信号量数据结构。</li>
</ul>
<h2 id="二进制信号量接口"><a href="# 二进制信号量接口" class="headerlink" title="二进制信号量接口"></a>二进制信号量接口</h2><img src="../images/projects/c-thread-pool/thread-pool-bsem-method.png" alt="线程池的二进制信号量接口" width="100%" height="100%">

<h2 id="线程池接口"><a href="# 线程池接口" class="headerlink" title="线程池接口"></a>线程池接口</h2><img src="../images/projects/c-thread-pool/thread-pool-thpool-method.png" alt="线程池的线程池接口" width="100%" height="100%">

<h3 id="线程池初始化"><a href="# 线程池初始化" class="headerlink" title="线程池初始化"></a>线程池初始化 </h3><p> 流程图左一：<code>struct thpool_* thpool_init(int num_threads)</code></p>
<ol>
<li>分配线程池内存空间</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">thpool_</span> &#123;</span></span><br><span class="line">    thread** threads;                  <span class="comment">// 指向一组线程（指针数组）</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> num_threads_alive;    <span class="comment">// 当前活跃的线程数量</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> num_threads_working;  <span class="comment">// 当前工作中的线程数量</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> thcount_lock;      <span class="comment">// used for thread count etc</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> threads_all_idle;   <span class="comment">// signal to thpool_wait</span></span><br><span class="line">    jobqueue jobqueue;                 <span class="comment">// 作业队列</span></span><br><span class="line">&#125; thpool_;</span><br><span class="line"></span><br><span class="line">thpool_* thpool_p = (<span class="keyword">struct</span> thpool_*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> thpool_));</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>初始化任务队列</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobqueue_init(&amp;thpool_p-&gt;jobqueue);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建线程池中的二级指针 <code>thpool_p-&gt;threads</code>，它指向一个 <code>struct thread *</code> 类型指针的 <strong> 指针数组</strong>。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thpool_p-&gt;threads = (<span class="keyword">struct</span> thread**)<span class="built_in">malloc</span>(num_threads * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> thread*));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>后续将在 <code>thread_init()</code> 函数中，为每个指向 <code>struct thread *</code> 的指针分配一段内存空间。正因为是在 <strong> 其它函数内部 </strong> 为这里申请的二级指针指向的指针数组中的每个指针分配一段内存空间，所以在 <code>thread_init()</code> 函数中使用了二级指针。<a href="https://pursue26.github.io/posts/240224193217.html#%E4%BE%8B%E5%AD%90%E4%BA%8C">看这里，为什么用二级指针</a></p>
</blockquote>
<ol start="4">
<li>初始化一组线程</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_threads; i++) &#123;</span><br><span class="line">    thread_init(thpool_p, &amp;thpool_p-&gt;threads[i], i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程池添加任务"><a href="# 线程池添加任务" class="headerlink" title="线程池添加任务"></a>线程池添加任务 </h3><p> 流程图左二：<code>int thpool_add_work(thpool_* thpool_p, void (*function_p)(void*), void* arg_p)</code></p>
<ol>
<li>为添加的任务分配一块内存空间</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">job</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job</span>* <span class="title">next</span>;</span>             <span class="comment">// 指向下一个 job</span></span><br><span class="line">    <span class="type">void</span> (*function)(<span class="type">void</span>* arg);  <span class="comment">// 调用的 job 的函数，作为线程入口函数</span></span><br><span class="line">    <span class="type">void</span>* arg;                    <span class="comment">// 调用的 job 的函数的参数，作为线程入口函数的参数</span></span><br><span class="line">&#125; job;</span><br><span class="line"></span><br><span class="line">job* newjob = (<span class="keyword">struct</span> job*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> job));</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>根据入参初始化函数指针和函数参数</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newjob-&gt;function = function_p;</span><br><span class="line">newjob-&gt;arg = arg_p;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>将任务添加到指定的队列中</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobqueue_push(&amp;thpool_p-&gt;jobqueue, newjob);</span><br></pre></td></tr></table></figure>

<p>关注点：</p>
<ol>
<li><p>对于任务队列中 <strong> 没有任务时的处理 </strong>：<br> 不是采用轮询的方式，而是使用条件变量 <code>has_jobs-&gt;cond</code>，在入队 / 出队任务后，若仍有任务在队列中，则唤醒条件变量。</p>
</li>
<li><p>对于 <strong> 函数指针类型转换的处理 </strong>：<br> 自定义的函数原型可以与 api 的原型不一致。例如：这里 api 的函数指针原型为<code>void (*)(void*)</code>，而「接口使用实例」中的 task1 和 task2 的函数原型为<code>void* (*)(void*)</code>。</p>
</li>
</ol>
<h3 id="线程池等待"><a href="# 线程池等待" class="headerlink" title="线程池等待"></a>线程池等待 </h3><p> 流程图左三：<code>void thpool_wait(thpool_* thpool_p)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;thpool_p-&gt;thcount_lock);</span><br><span class="line"><span class="keyword">while</span> (thpool_p-&gt;jobqueue.len || thpool_p-&gt;num_threads_working) &#123;</span><br><span class="line">    pthread_cond_wait(&amp;thpool_p-&gt;threads_all_idle, &amp;thpool_p-&gt;thcount_lock);</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;thpool_p-&gt;thcount_lock);</span><br></pre></td></tr></table></figure>

<p>这个函数的工作原理是：</p>
<ol>
<li>获取锁，避免多个线程同时访问共享资源（这里是指 <code>thpool_</code> 结构中的计数变量）；</li>
<li>当任务队列中有任务或有正在处理任务的工作线程时，继续等待：<ul>
<li>这个线程会等待在条件变量 <code>threads_all_idle</code> 上，同时释放 <code>thcount_lock</code> 互斥锁（以让其它线程有机会拿到锁），并阻塞在这个条件变量上。这样其它线程可以在条件满足时唤醒等待在 <code>threads_all_idle</code> 条件变量上的这个线程。</li>
<li>如果这个线程被其它线程唤醒后，这个线程会重新尝试获取 <code>thcount_lock</code> 互斥锁。一旦获取到互斥锁后，它会再次检查 while 条件，若条件成立，说明还有任务或工作线程。那么，这个线程会继续等待在条件变量上，等待被通知唤醒。</li>
</ul>
</li>
<li>直到所有任务都已经执行完毕且所有线程都是空闲的，释放锁。</li>
</ol>
<p>关注点：</p>
<ol>
<li>这个函数有何作用？用在哪里？<br>用在销毁线程池之前，<strong>安全地执行完 </strong> 所有正在执行、尚未执行的任务。</li>
</ol>
<h3 id="线程池销毁"><a href="# 线程池销毁" class="headerlink" title="线程池销毁"></a>线程池销毁 </h3><p> 流程图右一：<code>void thpool_destroy(thpool_* thpool_p)</code></p>
<ol>
<li>复位全局活跃标志</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threads_keepalive = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>复位的目的是，通过这个标志结束每个活跃线程的轮询（详见 <code>thread_do</code> 函数），并等待被唤醒后退出。</p>
<ol start="2">
<li>通过条件变量 <code>bsem_p-&gt;cond</code> 的唤醒，线程退出</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Give one second to kill idle threads */</span></span><br><span class="line"><span class="type">double</span> TIMEOUT = <span class="number">1.0</span>;</span><br><span class="line"><span class="type">time_t</span> start, end;</span><br><span class="line"><span class="type">double</span> tpassed = <span class="number">0.0</span>;</span><br><span class="line">time(&amp;start);</span><br><span class="line"><span class="keyword">while</span> (tpassed &lt; TIMEOUT &amp;&amp; thpool_p-&gt;num_threads_alive) &#123;</span><br><span class="line">    bsem_post_all(thpool_p-&gt;jobqueue.has_jobs);</span><br><span class="line">    time(&amp;end);</span><br><span class="line">    tpassed = difftime(end, start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Poll remaining threads */</span></span><br><span class="line"><span class="keyword">while</span> (thpool_p-&gt;num_threads_alive) &#123;</span><br><span class="line">    bsem_post_all(thpool_p-&gt;jobqueue.has_jobs);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里被唤醒后，<code>thread_do</code> 函数中的 <code>bsem_wait</code> 将被唤醒，随之跳出轮询并线程退出。</p>
<ol start="3">
<li>销毁任务队列</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobqueue_destroy(&amp;thpool_p-&gt;jobqueue);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>其余堆上内存的释放</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; threads_total; n++) &#123;</span><br><span class="line">    thread_destroy(thpool_p-&gt;threads[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(thpool_p-&gt;threads);</span><br><span class="line"><span class="built_in">free</span>(thpool_p);</span><br></pre></td></tr></table></figure>

<p>关注点：</p>
<ol>
<li>对于 <strong> 线程释放的处理 </strong>：<br> 可以定义一个条件变量来唤醒所有线程，通过复位 <code>threads_keepalive</code> 标志，使得在 <code>thread_do</code> 中被唤醒的线程，跳过任务执行（if）和轮询（while），达到优雅地退出。</li>
<li>对于 <strong> 唤醒线程的处理方式 </strong>：<br> 超时时间内不断地、快速地唤醒所有活跃线程 + 固定时间轮询唤醒剩余活跃线程。为什么先后执行这两种方式，<strong>直接执行第二种方式不行吗</strong>？</li>
</ol>
<h3 id="线程池暂停与恢复"><a href="# 线程池暂停与恢复" class="headerlink" title="线程池暂停与恢复"></a>线程池暂停与恢复</h3><ol>
<li>注册信号并绑定线程暂停函数，实现在收到信号时暂停线程</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in function thread_do()</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">sigemptyset(&amp;act.sa_mask);</span><br><span class="line">act.sa_flags = SA_ONSTACK;</span><br><span class="line">act.sa_handler = thread_hold;</span><br><span class="line"><span class="keyword">if</span> (sigaction(SIGUSR1, &amp;act, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">    err(<span class="string">&quot;thread_do(): cannot handle SIGUSR1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">thread_hold</span><span class="params">(<span class="type">int</span> sig_id)</span> &#123;</span><br><span class="line">    (<span class="type">void</span>)sig_id;</span><br><span class="line">    threads_on_hold = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (threads_on_hold) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>流程图右二（上），暂停：<code>void thpool_pause(thpool_* thpool_p)</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; thpool_p-&gt;num_threads_alive; n++) &#123;</span><br><span class="line">    pthread_kill(thpool_p-&gt;threads[n]-&gt;pthread, SIGUSR1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数原型：<code>int pthread_kill(pthread_t thread, int sig)</code></p>
<p>函数描述：<code>pthread_kill()</code>函数向与调用者在同一进程中的线程 <code>thread</code> 发送信号 <code>sig</code>。该信号会<strong> 异步地 </strong> 被发送到 <code>thread</code> 线程中。发送成功返回 0，不成功返回非 0。</p>
<p>对「异步地」的理解：<code>pthread_kill()</code>函数向目标线程发送信号时，<strong>不会阻塞调用线程的执行 </strong>。换句话说，调用<code>pthread_kill()</code> 函数发送信号是一个异步操作，<strong>它会立即返回，而不会等待目标线程处理完信号后再继续执行</strong>。这意味着调用线程可以继续执行自己的任务，而不必等待目标线程对接收到的信号做出响应。</p>
<ol start="3">
<li>流程图右二（下），恢复：<code>void thpool_resume(thpool_* thpool_p)</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">void</span>)thpool_p;</span><br><span class="line">threads_on_hold = <span class="number">0</span>;  <span class="comment">// change its value here or thread_hold_on()</span></span><br></pre></td></tr></table></figure>

<p>关注点：</p>
<ol>
<li>线程池暂停与恢复函数是 <strong> 如何控制线程状态的 </strong>？<br> 每个线程会注册一个信号，并绑定线程暂停函数。当线程池发出暂停时，每一个线程都将会收到一个暂停信号，这将触发执行 <code>thread_hold</code> 函数，进入循环睡眠，实现线程的暂停；当线程池发出恢复时，将 <code>threads_on_hold</code> 复位，<code>thread_hold</code> 函数将退出循环睡眠，线程继续执行。</li>
</ol>
<h2 id="线程接口"><a href="# 线程接口" class="headerlink" title="线程接口"></a>线程接口 </h2><p> 所有的线程接口都被 <code>static</code> 关键字修饰。</p>
<img src="../images/projects/c-thread-pool/thread-pool-thread-method.png" alt="线程池的线程接口" width="100%" height="100%">

<h3 id="线程初始化"><a href="# 线程初始化" class="headerlink" title="线程初始化"></a>线程初始化 </h3><p> 流程图左一：<code>static int thread_init(thpool_* thpool_p, struct thread** thread_p, int id)</code></p>
<ol>
<li>为线程池中的线程分配内存空间</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*thread_p = (<span class="keyword">struct</span> thread*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> thread));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么用二级指针作为入参？参考「线程池初始化 -3」小节。</p>
</blockquote>
<ol start="2">
<li>指定线程所属的线程池</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*thread_p)-&gt;thpool_p = thpool_p;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这一步有何作用？通过线程找到对应的线程池，多个线程可以互斥地改变对应线程池的共享计数资源（发生在<code>thread_do</code>）。</p>
</blockquote>
<ol start="3">
<li>创建线程，并指定 start_routine 函数指针</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建实际线程，并开始执行 thread_do 函数（Worker 函数，其内部执行 Job 函数）</span></span><br><span class="line"><span class="comment"> * int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment"> * (void* (*)(void*))是一个强制类型转换，将 thread_do 函数类型强转为 start_routine 的 void *(*) (void *)类型</span></span><br><span class="line"><span class="comment"> * pthread_detach 函数用于将指定的线程分离出去，主线程不再需要通过 pthread_join 方式回收资源，被分离的线程结束后由 OS 回收资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">pthread_create(&amp;((*thread_p)-&gt;pthread), <span class="literal">NULL</span>, (<span class="type">void</span>* (*)(<span class="type">void</span>*))thread_do, (*thread_p));</span><br><span class="line">pthread_detach((*thread_p)-&gt;pthread);</span><br></pre></td></tr></table></figure>

<h3 id="线程 worker"><a href="# 线程 worker" class="headerlink" title="线程 worker"></a>线程 worker</h3><p>这是核心代码，Worker 作为一个无休止的循环，唯一的被中断是调用 <code>thpool_destroy()</code> 或程序退出。它作为一个 Worker，在内部执行不断入队的 Job。</p>
<ol>
<li>获取线程所属的线程池</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thpool_* thpool_p = thread_p-&gt;thpool_p;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>互斥地更新活跃线程数量</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;thpool_p-&gt;thcount_lock);</span><br><span class="line">thpool_p-&gt;num_threads_alive += <span class="number">1</span>;</span><br><span class="line">pthread_mutex_unlock(&amp;thpool_p-&gt;thcount_lock);</span><br></pre></td></tr></table></figure>

<p>在「线程初始化」中，每创建一个线程示例，都会执行对应的启动例程，即<code>thread_do</code>，这个线程运行起来，共享计数量加一。</p>
<ol start="3">
<li>进入轮询（poll），等待条件变量的唤醒通知</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (threads_keepalive) &#123;</span><br><span class="line">    bsem_wait(thpool_p-&gt;jobqueue.has_jobs);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>有任务被唤醒，执行 Job 任务</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (threads_keepalive) &#123;</span><br><span class="line">    job* job_p = jobqueue_pull(&amp;thpool_p-&gt;jobqueue);</span><br><span class="line">    job_p-&gt;function(job_p-&gt;arg);</span><br><span class="line">    <span class="built_in">free</span>(job_p);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>无任务被唤醒，即是被 <code>thpool_destroy()</code> 唤醒，if 不成立，while 不成立，退出轮询，活跃线程退出。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;thpool_p-&gt;thcount_lock);</span><br><span class="line">thpool_p-&gt;num_threads_alive--;</span><br><span class="line">pthread_mutex_unlock(&amp;thpool_p-&gt;thcount_lock);</span><br></pre></td></tr></table></figure>

<h2 id="队列接口"><a href="# 队列接口" class="headerlink" title="队列接口"></a>队列接口 </h2><p> 任务队列主要是为线程服务的。当有新任务到来时，<code>thpool_add_work</code> 调用 push 函数将新任务插入队尾；当线程检测到任务队列有任务时，及时将任务从队列中 pull 并执行它。</p>
<img src="../images/projects/c-thread-pool/thread-pool-queue-method.png" alt="线程池的任务队列接口" width="100%" height="100%">

<p>具体接口在这里就不再介绍了，直接看流程吧，挺详细的。核心就在 push&amp;pull 操作后，若队列中仍有剩余任务，则会通知唤醒等待在条件变量上的线程，从而使得线程可以执行队列中的任务；当队列为空时，不再通知唤醒线程，线程便会阻塞在条件变量上。</p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://nachtimwald.com/2019/04/12/thread-pool-in-c/">https://nachtimwald.com/2019/04/12/thread-pool-in-c/</a></li>
<li><a target="_blank" rel="noopener" href="https://smartyue076.github.io/2023/06/10/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/">https://smartyue076.github.io/2023/06/10/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1849765">https://cloud.tencent.com/developer/article/1849765</a></li>
</ol>
</blockquote>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag"># 多线程</a>
              <a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="tag"># 线程池</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/240224193217.html" rel="prev" title="C 语言之一、二级指针">
                  <i class="fa fa-angle-left"></i> C 语言之一、二级指针
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/240306203742.html" rel="next" title="计网之 ACL 访问控制列表">
                  计网之 ACL 访问控制列表 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">aha</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">405k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">12:16</span>
  </span>
</div>
<div class="busuanzi-count">
</div>
  <div class="powered-by">
    <!--由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动 -->
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script src="https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#3F3F3F',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
