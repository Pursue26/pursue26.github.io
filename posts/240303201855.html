<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

    
      <link rel="icon" href="/favicon.png" />
    

    <title>
        
          项目之线程池原理与实现 - aha&#39;s book
        
    </title>

    <!-- Spectre.css framework -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-exp.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-icons.min.css">

    <!-- theme css & js -->
    
<link rel="stylesheet" href="/css/book.css">

    
<script src="/js/book.js"></script>


    <!-- tocbot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
    
    <!-- katex -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">

    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/zooming/2.1.1/zooming.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    const zooming = new Zooming()
    zooming.listen('.book-content img')
})
</script>

<meta name="generator" content="Hexo 6.3.0"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body>

<div class="book-container">
  <div class="book-sidebar">
    <div class="book-brand">
  <a href="/">
    <img src="/favicon.png">
    <span>AHA&#39;S BOOK</span>
  </a>
</div>
    <div id="menu" class="book-menu hide">
  <h2 id="基础知识"> 基础知识 </h2>
<ul>
<li><a href="/posts/231010144856.html"> 模运算 </a></li>
<li><a href="/posts/231014105311.html"> 异或运算 </a></li>
<li><a href="/posts/231210181853.html"> 计算机中的寄存器 </a></li>
<li><a href="/posts/231213183051.html"> 正则表达式基础 </a></li>
</ul>
<h2 id="C 语言">C 语言 </h2>
<ul>
<li><a href="/posts/230916171929.html">main 函数参数 </a></li>
<li><a href="/posts/231214192113.html"> 关键字与专有名词 </a></li>
<li><a href="/posts/240103180653.html"> 输出打印函数 </a></li>
<li><a href="/posts/230922143003.html"> 多维数组 </a></li>
<li><a href="/posts/230913200729.html">const 关键字 </a></li>
<li><a href="/posts/230918174223.html">typedef 类型基础 </a></li>
<li><a href="/posts/230920172849.html">typedef 类型实践 </a></li>
<li><a href="/posts/240224193217.html"> 二级指针 </a></li>
<li><a href="/posts/240307195203.html"> 代码 TOP-K 问题 </a></li>
<li><a href="/posts/230922172626.html">uthash 哈希表基础 </a></li>
<li><a href="/posts/230918114841.html"> 大小端知识 </a></li>
</ul>
<h2 id="Golang 语言">Golang 语言 </h2>
<ul>
<li><a href="/posts/230907162612.html"> 变量与常量 </a></li>
<li><a href="/posts/230909120145.html"> 函数 &amp; 包 &amp; 判断 &amp; 循环 </a></li>
<li><a href="/posts/230912152800.html"> 数组与切片 </a></li>
<li><a href="/posts/230913161326.html"> 可变参数函数与 Map 集合 </a></li>
<li><a href="/posts/230915155105.html"> 字符串和指针 </a></li>
</ul>
<h2 id="数据结构"> 数据结构 </h2>
<ul>
<li><a href="/posts/231007174854.html"> 链表（数组实现）</a></li>
<li><a href="/posts/231008213450.html"> 链表（链式实现）</a></li>
<li><a href="/posts/231016161508.html"> 堆栈（数组实现）</a></li>
<li><a href="/posts/231016184406.html"> 堆栈（链表实现）</a></li>
<li><a href="/posts/231127185207.html"> 单调栈 </a></li>
<li><a href="/posts/231017105123.html"> 队列（链表实现）</a></li>
<li><a href="/posts/231017154121.html"> 双端队列（链表实现）</a></li>
<li><a href="/posts/231018102559.html"> 堆基础与堆结构（数组实现）</a></li>
<li><a href="/posts/231019102311.html"> 优先队列（堆实现）</a></li>
<li><a href="/posts/230905224335.html"> 二叉树的遍历 </a></li>
<li><a href="/posts/231020174358.html"> 二叉搜索树 </a></li>
<li><a href="/posts/230916094606.html"> 拓扑排序 </a></li>
<li><a href="/posts/230925185057.html">Trie 字典树 </a></li>
<li><a href="/posts/231023164532.html"> 并查集（数组实现）</a></li>
</ul>
<h2 id="数据结构算法"> 数据结构算法 </h2>
<ul>
<li><a href="/posts/231218181635.html"> 归并排序 </a></li>
<li><a href="/posts/231108163339.html"> 快速排序 </a></li>
<li><a href="/posts/231107171607.html"> 堆排序 </a></li>
<li><a href="/posts/231124181658.html"> 二分查找 </a></li>
<li><a href="/posts/231227190828.html"> 哈希表实现 </a></li>
<li><a href="/posts/240313193201.html"> 字符串哈希函数 </a></li>
<li><a href="/posts/231116150205.html">Floyd 多源最短路径 </a></li>
<li><a href="/posts/231117095232.html">Dijkstra 单源最短路径（原理部分）</a></li>
<li><a href="/posts/231121152713.html">Dijkstra 单源最短路径（实现部分）</a></li>
</ul>
<h2 id="计算机网络"> 计算机网络 </h2>
<ul>
<li><a href="/posts/231011192359.html">OSI 参考模型 </a></li>
<li><a href="/posts/240306203742.html">ACL 访问控制列表 </a></li>
<li><a href="/posts/240130190208.html"> 路由表、转发表与快速转发工作原理 </a></li>
<li><a href="/posts/231221200716.html">VXLAN 网络虚拟化技术 </a></li>
</ul>
<h2 id="操作系统"> 操作系统 </h2>
<ul>
<li><a href="/posts/230921190726.html"> 概述 </a></li>
<li><a href="/posts/230924172528.html"> 启动 &amp; 中断 &amp; 异常 &amp; 系统调用 </a></li>
<li><a href="/posts/231017195157.html"> 内存分层体系与地址空间生成 </a></li>
<li><a href="/posts/231108195351.html"> 连续内存分配 </a></li>
<li><a href="/posts/231111172507.html"> 非连续内存分配之分段与分页 </a></li>
<li><a href="/posts/231119170537.html"> 非连续内存分配之页表 </a></li>
<li><a href="/posts/231123184526.html"> 内存管理之覆盖技术与交换技术 </a></li>
<li><a href="/posts/231127193658.html"> 内存管理之虚存技术 </a></li>
<li><a href="/posts/231129182631.html"> 局部页面置换算法 </a></li>
<li><a href="/posts/231207184239.html"> 全局页面置换算法 </a></li>
<li><a href="/posts/231207204958.html"> 进程描述 </a></li>
<li><a href="/posts/231210211306.html"> 进程状态 </a></li>
<li><a href="/posts/231215213932.html"> 线程 </a></li>
<li><a href="/posts/231218220813.html"> 进程控制 </a></li>
<li><a href="/posts/231228193143.html"> 调度 </a></li>
<li><a href="/posts/240104202828.html"> 同步与互斥 </a></li>
<li><a href="/posts/240113115605.html"> 信号量与管程 </a></li>
<li><a href="/posts/240205182643.html"> 经典同步问题 </a></li>
</ul>
<h2 id="多线程编程"> 多线程编程 </h2>
<ul>
<li><a href="/posts/230911151334.html">pthread 库 </a></li>
<li><a href="/posts/230921094127.html"> 锁与原子操作 </a></li>
<li><a href="/posts/240319195609.html"> 读者写者问题 </a></li>
</ul>
<h2 id="工具"> 工具 </h2>
<ul>
<li><a href="/posts/240207180410.html">GCC 编译过程分解 </a></li>
<li><a href="/posts/240312184132.html">GDB 调试入门 </a></li>
</ul>
<h2 id="Docker">Docker</h2>
<ul>
<li><a href="/posts/230909171809.html">Docker 学习笔记 </a></li>
</ul>
<h1 id="LeetCode 刷题">LeetCode 刷题 </h1>
<h2 id="链表相关"> 链表相关 </h2>
<ul>
<li><a href="/posts/231025143947.html">160 相交链表 </a></li>
<li><a href="/posts/231025185947.html">206 反转链表 </a></li>
<li><a href="/posts/231026101239.html">21 合并两个有序链表 </a></li>
<li><a href="/posts/231026184514.html">83 删除排序链表中的重复元素 </a></li>
<li><a href="/posts/231027150243.html">19 删除链表的倒数第 N 个节点 </a></li>
<li><a href="/posts/231031120718.html">2 两数相加 </a></li>
<li><a href="/posts/231031163133.html">445 两数相加 II</a></li>
<li><a href="/posts/231101094219.html">234 回文链表 </a></li>
<li><a href="/posts/231101135228.html">725 分隔链表 </a></li>
<li><a href="/posts/231102120708.html">328 奇偶链表 </a></li>
<li><a href="/posts/231102165703.html">142 环形链表 II</a></li>
</ul>
<h2 id="设计"> 设计 </h2>
<ul>
<li><a href="/posts/231201184542.html">146 LRU 缓存 </a></li>
</ul>
<h2 id="贪心算法"> 贪心算法 </h2>
<ul>
<li><a href="/posts/231107094652.html">1029 两地调度 </a></li>
<li><a href="/posts/231109150855.html">435 无重叠区间 </a></li>
</ul>
<h2 id="哈希表"> 哈希表 </h2>
<ul>
<li><a href="/posts/231123181539.html">1410 实体解析器 </a></li>
</ul>
<h2 id="树的遍历"> 树的遍历 </h2>
<ul>
<li><a href="/posts/231103121209.html">117 填充每个节点的下一个右侧节点指针 II</a></li>
</ul>
<h2 id="深度优先搜索（递归）"> 深度优先搜索（递归）</h2>
<ul>
<li><a href="/posts/231206201243.html">2477 达到首都的最少油耗 </a></li>
</ul>
<h2 id="图或路径问题"> 图或路径问题 </h2>
<ul>
<li><a href="/posts/231211184652.html">1631 最小体力消耗路径 </a></li>
</ul>
<h1 id="项目"> 项目 </h1>
<h2 id="开源项目"> 开源项目 </h2>
<ul>
<li><a href="/posts/240303201855.html"> 线程池原理与实现 </a></li>
</ul>
<h2 id="非开源项目"> 非开源项目 </h2>
<ul>
<li><a href="/posts/231202180319.html"> 确定性网络 CSQF</a></li>
</ul>

</div>


<script src="/js/book-menu.js"></script>

  </div>

  <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
  <div class="sidebar-toggle-inner"></div>
</div>

<script>
function add_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.add('show')  
}

function remove_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.remove('show')
}

function sidebar_toggle() {
    let sidebar_toggle = document.querySelector('.sidebar-toggle')
    let sidebar = document.querySelector('.book-sidebar')
    let content = document.querySelector('.off-canvas-content')
    if (sidebar_toggle.classList.contains('extend')) { // show
        sidebar_toggle.classList.remove('extend')
        sidebar.classList.remove('hide')
        content.classList.remove('extend')
    }
    else { // hide
        sidebar_toggle.classList.add('extend')
        sidebar.classList.add('hide')
        content.classList.add('extend')
    }
}
</script>

  <div class="off-canvas-content">
    <div class="columns">
      <div class="column col-10 col-lg-12">
        <div class="book-navbar">
          <!-- For Responsive Layout -->

<header class="navbar">
  <section class="navbar-section">
    <a onclick="open_sidebar()">
      <i class="icon icon-menu"></i>
    </a>
  </section>
</header>

        </div>
        <div class="book-content">
          <div class="book-post">
  <p><strong>线程池（Thread Pool）<strong>是一种基于 </strong> 池化思想 </strong> 管理线程的工具，经常出现在多线程服务器中，如 MySQL。</p>
<p>线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。<strong>线程池维护多个线程，等待监督管理者（worker）分配可并发执行的任务</strong>。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。</p>
<span id="more"></span>
<h1 id="为什么选择线程池">为什么选择线程池</h1>
<p>创建线程可能是非常昂贵的。通常每个线程都会执行几乎相同的任务，包括创建线程、执行任务和销毁线程等。线程本身相当 heavy —— 创建或销毁线程会占用很多本来想要执行的任务时间。因此，<strong>重用线程是一个很好的选择</strong>。</p>
<p>线程池的另一个好处是它可以防止系统过载（overloaded），它允许 <strong> 限制线程数量、任务排队，并仅在线程可用时运行任务</strong>。</p>
<blockquote>
<p>线程池维持固定数量的线程，并等待执行特定任务。该线程池可以设计为根据您需要完成的工作量进行扩展，但我更喜欢 <strong> 指定固定数量的线程 </strong>。为了确定这个数量，通常可以考虑<strong> 使用系统上的核心 / 处理器数量加一</strong>。</p>
</blockquote>
<h1 id="线程池的好处">线程池的好处</h1>
<p>使用线程池可以带来一系列好处：</p>
<ul>
<li>降低资源消耗（系统资源）：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。</li>
<li>提高线程的可管理性（系统资源）：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</li>
<li>提高响应速度（任务响应）：任务到达时，无需等待线程创建即可立即执行。</li>
</ul>
<h1 id="线程池解决的问题">线程池解决的问题</h1>
<p>线程池解决的核心问题就是资源管理问题。<strong>在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入</strong>。这种不确定性将带来以下若干问题：</p>
<ul>
<li>频繁申请 / 销毁资源和调度资源：将带来额外的消耗，可能会非常巨大。</li>
<li>对资源无限申请缺少抑制手段：易引发系统资源耗尽的风险。</li>
<li>系统无法合理管理内部的资源分布：会降低系统的稳定性。</li>
</ul>
<h1 id="线程池如何工作"><a target="_blank" rel="noopener" href="https://jenkov.com/tutorials/java-concurrency/thread-pools.html#how-a-thread-pool-works">线程池如何工作</a></h1>
<p>可以将任务传递到线程池，而不是为每个任务启动一个新线程来并发地执行。一旦池中有任何空闲线程（idle threads），任务就会分配给其中一个空闲线程并执行。在内部，任务被插入到阻塞队列（Blocking Queue）中，池中的线程将从该队列中出队。当一个新任务被插入队列时，其中一个空闲线程将成功地将其出队并执行它。池中的其余空闲线程将被阻塞，等待任务出队。</p>
<img src="../images/projects/c-thread-pool/thread-pool-1.png" alt="线程池如何工作" width="100%" height="100%">
<p>何为阻塞队列（Blocking Queue）？</p>
<img src="../images/projects/c-thread-pool/blocking-queue.png" alt="阻塞队列" width="100%" height="100%">
<h1 id="C-Thread-Pool">C-Thread-Pool</h1>
<p>后续内容是对基于 C 语言实现的线程池的开源项目 <a target="_blank" rel="noopener" href="https://github.com/Pithikos/C-Thread-Pool">C-Thread-Pool</a> 的学习。</p>
<h2 id="公共接口">公共接口</h2>
<table>
<thead>
<tr>
<th>Function example</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>thpool_init(4)</code></td>
<td>Will return a new threadpool with <code>4</code> threads.</td>
</tr>
<tr>
<td><code>thpool_add_work(thpool,func_p,arg_p)</code></td>
<td>Will add new work to the pool. Work is simply a function. You can pass a single argument to the function if you wish. If not, <code>NULL</code> should be passed.</td>
</tr>
<tr>
<td><code>thpool_wait(thpool)</code></td>
<td>Will wait for all jobs (both in queue and currently running) to finish.</td>
</tr>
<tr>
<td><code>thpool_destroy(thpool)</code></td>
<td>This will destroy the threadpool. If jobs are currently being executed, then it will wait for them to finish.</td>
</tr>
<tr>
<td><code>thpool_pause(thpool)</code></td>
<td>All threads in the threadpool will pause no matter if they are idle or executing work.</td>
</tr>
<tr>
<td><code>thpool_resume(thpool)</code></td>
<td>If the threadpool is paused, then all threads will resume from where they were.</td>
</tr>
<tr>
<td><code>thpool_num_threads_working(thpool)</code></td>
<td>Will return the number of currently working threads.</td>
</tr>
</tbody>
</table>
<h2 id="接口使用实例">接口使用实例</h2>
<p>We create a pool of 4 threads and then add 40 tasks to the pool (20 task1 functions and 20 task2 functions). task1 and task2 simply print which thread is running them.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">task1</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Task1, Thread #%u working on %d\n&quot;</span>, (<span class="type">int</span>)pthread_self(), (<span class="type">int</span>)(<span class="type">uintptr_t</span>)arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">task2</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Task2, Thread #%u working on %d\n&quot;</span>, (<span class="type">int</span>)pthread_self(), (<span class="type">int</span>)(<span class="type">uintptr_t</span>)arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Making threadpool with 4 threads&quot;</span>);</span><br><span class="line">    threadpool thpool = thpool_init(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Adding 40 tasks to threadpool&quot;</span>);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">        thpool_add_work(thpool, (<span class="type">void</span> (*)(<span class="type">void</span>*))(i % <span class="number">2</span> ? task1 : task2), (<span class="type">void</span>*)(<span class="type">uintptr_t</span>)i);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    thpool_wait(thpool);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Killing threadpool&quot;</span>);</span><br><span class="line">    thpool_destroy(thpool);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>As soon as we add the tasks to the pool, the threads will run them. It can happen that you see a single thread running all the tasks (highly unlikely). It is up the OS to decide which thread will run what. So it is not an error of the thread pool but rather a decision of the OS.</p>
<h2 id="数据结构组织关系">数据结构组织关系</h2>
<img src="../images/projects/c-thread-pool/thread-pool-struct.png" alt="线程池数据结构组织关系" width="100%" height="100%">
<p><a target="_blank" rel="noopener" href="https://github.com/Pithikos/C-Thread-Pool">C-Thread-Pool</a> 实现的线程池包括如下数据结构：</p>
<ul>
<li>线程池数据结构：包括申请创建的每个线程的地址、任务队列等；</li>
<li>线程数据结构：包括创建的线程、线程所属的线程池等；</li>
<li>任务队列数据结构：包括一个是否存在任务的信号量；</li>
<li>任务数据结构；</li>
<li>信号量数据结构。</li>
</ul>
<h2 id="二进制信号量接口">二进制信号量接口</h2>
<img src="../images/projects/c-thread-pool/thread-pool-bsem-method.png" alt="线程池的二进制信号量接口" width="100%" height="100%">
<h2 id="线程池接口">线程池接口</h2>
<img src="../images/projects/c-thread-pool/thread-pool-thpool-method.png" alt="线程池的线程池接口" width="100%" height="100%">
<h3 id="线程池初始化">线程池初始化</h3>
<p>流程图左一：<code>struct thpool_* thpool_init(int num_threads)</code></p>
<ol>
<li>分配线程池内存空间</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">thpool_</span> &#123;</span></span><br><span class="line">    thread** threads;                  <span class="comment">// 指向一组线程（指针数组）</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> num_threads_alive;    <span class="comment">// 当前活跃的线程数量</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> num_threads_working;  <span class="comment">// 当前工作中的线程数量</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> thcount_lock;      <span class="comment">// used for thread count etc</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> threads_all_idle;   <span class="comment">// signal to thpool_wait</span></span><br><span class="line">    jobqueue jobqueue;                 <span class="comment">// 作业队列</span></span><br><span class="line">&#125; thpool_;</span><br><span class="line"></span><br><span class="line">thpool_* thpool_p = (<span class="keyword">struct</span> thpool_*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> thpool_));</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>初始化任务队列</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobqueue_init(&amp;thpool_p-&gt;jobqueue);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>创建线程池中的二级指针 <code>thpool_p-&gt;threads</code>，它指向一个 <code>struct thread *</code> 类型指针的 <strong> 指针数组</strong>。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thpool_p-&gt;threads = (<span class="keyword">struct</span> thread**)<span class="built_in">malloc</span>(num_threads * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> thread*));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>后续将在 <code>thread_init()</code> 函数中，为每个指向 <code>struct thread *</code> 的指针分配一段内存空间。正因为是在 <strong> 其它函数内部 </strong> 为这里申请的二级指针指向的指针数组中的每个指针分配一段内存空间，所以在 <code>thread_init()</code> 函数中使用了二级指针。<a href="https://pursue26.github.io/posts/240224193217.html#%E4%BE%8B%E5%AD%90%E4%BA%8C">看这里，为什么用二级指针</a></p>
</blockquote>
<ol start="4">
<li>初始化一组线程</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_threads; i++) &#123;</span><br><span class="line">    thread_init(thpool_p, &amp;thpool_p-&gt;threads[i], i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程池添加任务">线程池添加任务</h3>
<p>流程图左二：<code>int thpool_add_work(thpool_* thpool_p, void (*function_p)(void*), void* arg_p)</code></p>
<ol>
<li>为添加的任务分配一块内存空间</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">job</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job</span>* <span class="title">next</span>;</span>             <span class="comment">// 指向下一个 job</span></span><br><span class="line">    <span class="type">void</span> (*function)(<span class="type">void</span>* arg);  <span class="comment">// 调用的 job 的函数，作为线程入口函数</span></span><br><span class="line">    <span class="type">void</span>* arg;                    <span class="comment">// 调用的 job 的函数的参数，作为线程入口函数的参数</span></span><br><span class="line">&#125; job;</span><br><span class="line"></span><br><span class="line">job* newjob = (<span class="keyword">struct</span> job*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> job));</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>根据入参初始化函数指针和函数参数</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newjob-&gt;function = function_p;</span><br><span class="line">newjob-&gt;arg = arg_p;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>将任务添加到指定的队列中</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobqueue_push(&amp;thpool_p-&gt;jobqueue, newjob);</span><br></pre></td></tr></table></figure>
<p>关注点：</p>
<ol>
<li>
<p>对于任务队列中 <strong> 没有任务时的处理</strong>：<br>
不是采用轮询的方式，而是使用条件变量 <code>has_jobs-&gt;cond</code>，在入队 / 出队任务后，若仍有任务在队列中，则唤醒条件变量。</p>
</li>
<li>
<p>对于 <strong> 函数指针类型转换的处理</strong>：<br>
自定义的函数原型可以与 api 的原型不一致。例如：这里 api 的函数指针原型为<code>void (*)(void*)</code>，而「接口使用实例」中的 task1 和 task2 的函数原型为<code>void* (*)(void*)</code>。</p>
</li>
</ol>
<h3 id="线程池等待">线程池等待</h3>
<p>流程图左三：<code>void thpool_wait(thpool_* thpool_p)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;thpool_p-&gt;thcount_lock);</span><br><span class="line"><span class="keyword">while</span> (thpool_p-&gt;jobqueue.len || thpool_p-&gt;num_threads_working) &#123;</span><br><span class="line">    pthread_cond_wait(&amp;thpool_p-&gt;threads_all_idle, &amp;thpool_p-&gt;thcount_lock);</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;thpool_p-&gt;thcount_lock);</span><br></pre></td></tr></table></figure>
<p>这个函数的工作原理是：</p>
<ol>
<li>获取锁，避免多个线程同时访问共享资源（这里是指 <code>thpool_</code> 结构中的计数变量）；</li>
<li>当任务队列中有任务或有正在处理任务的工作线程时，继续等待：
<ul>
<li>这个线程会等待在条件变量 <code>threads_all_idle</code> 上，同时释放 <code>thcount_lock</code> 互斥锁（以让其它线程有机会拿到锁），并阻塞在这个条件变量上。这样其它线程可以在条件满足时唤醒等待在 <code>threads_all_idle</code> 条件变量上的这个线程。</li>
<li>如果这个线程被其它线程唤醒后，这个线程会重新尝试获取 <code>thcount_lock</code> 互斥锁。一旦获取到互斥锁后，它会再次检查 while 条件，若条件成立，说明还有任务或工作线程。那么，这个线程会继续等待在条件变量上，等待被通知唤醒。</li>
</ul>
</li>
<li>直到所有任务都已经执行完毕且所有线程都是空闲的，释放锁。</li>
</ol>
<p>关注点：</p>
<ol>
<li>这个函数有何作用？用在哪里？<br>
用在销毁线程池之前，<strong>安全地执行完 </strong> 所有正在执行、尚未执行的任务。</li>
</ol>
<h3 id="线程池销毁">线程池销毁</h3>
<p>流程图右一：<code>void thpool_destroy(thpool_* thpool_p)</code></p>
<ol>
<li>复位全局活跃标志</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threads_keepalive = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>复位的目的是，通过这个标志结束每个活跃线程的轮询（详见 <code>thread_do</code> 函数），并等待被唤醒后退出。</p>
<ol start="2">
<li>通过条件变量 <code>bsem_p-&gt;cond</code> 的唤醒，线程退出</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Give one second to kill idle threads */</span></span><br><span class="line"><span class="type">double</span> TIMEOUT = <span class="number">1.0</span>;</span><br><span class="line"><span class="type">time_t</span> start, end;</span><br><span class="line"><span class="type">double</span> tpassed = <span class="number">0.0</span>;</span><br><span class="line">time(&amp;start);</span><br><span class="line"><span class="keyword">while</span> (tpassed &lt; TIMEOUT &amp;&amp; thpool_p-&gt;num_threads_alive) &#123;</span><br><span class="line">    bsem_post_all(thpool_p-&gt;jobqueue.has_jobs);</span><br><span class="line">    time(&amp;end);</span><br><span class="line">    tpassed = difftime(end, start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Poll remaining threads */</span></span><br><span class="line"><span class="keyword">while</span> (thpool_p-&gt;num_threads_alive) &#123;</span><br><span class="line">    bsem_post_all(thpool_p-&gt;jobqueue.has_jobs);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里被唤醒后，<code>thread_do</code> 函数中的 <code>bsem_wait</code> 将被唤醒，随之跳出轮询并线程退出。</p>
<ol start="3">
<li>销毁任务队列</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobqueue_destroy(&amp;thpool_p-&gt;jobqueue);</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>其余堆上内存的释放</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; threads_total; n++) &#123;</span><br><span class="line">    thread_destroy(thpool_p-&gt;threads[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(thpool_p-&gt;threads);</span><br><span class="line"><span class="built_in">free</span>(thpool_p);</span><br></pre></td></tr></table></figure>
<p>关注点：</p>
<ol>
<li>对于 <strong> 线程释放的处理</strong>：<br>
可以定义一个条件变量来唤醒所有线程，通过复位 <code>threads_keepalive</code> 标志，使得在 <code>thread_do</code> 中被唤醒的线程，跳过任务执行（if）和轮询（while），达到优雅地退出。</li>
<li>对于 <strong> 唤醒线程的处理方式</strong>：<br>
超时时间内不断地、快速地唤醒所有活跃线程 + 固定时间轮询唤醒剩余活跃线程。为什么先后执行这两种方式，<strong>直接执行第二种方式不行吗</strong>？</li>
</ol>
<h3 id="线程池暂停与恢复">线程池暂停与恢复</h3>
<ol>
<li>注册信号并绑定线程暂停函数，实现在收到信号时暂停线程</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in function thread_do()</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">sigemptyset(&amp;act.sa_mask);</span><br><span class="line">act.sa_flags = SA_ONSTACK;</span><br><span class="line">act.sa_handler = thread_hold;</span><br><span class="line"><span class="keyword">if</span> (sigaction(SIGUSR1, &amp;act, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">    err(<span class="string">&quot;thread_do(): cannot handle SIGUSR1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">thread_hold</span><span class="params">(<span class="type">int</span> sig_id)</span> &#123;</span><br><span class="line">    (<span class="type">void</span>)sig_id;</span><br><span class="line">    threads_on_hold = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (threads_on_hold) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>流程图右二（上），暂停：<code>void thpool_pause(thpool_* thpool_p)</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; thpool_p-&gt;num_threads_alive; n++) &#123;</span><br><span class="line">    pthread_kill(thpool_p-&gt;threads[n]-&gt;pthread, SIGUSR1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数原型：<code>int pthread_kill(pthread_t thread, int sig)</code></p>
<p>函数描述：<code>pthread_kill()</code>函数向与调用者在同一进程中的线程 <code>thread</code> 发送信号 <code>sig</code>。该信号会<strong> 异步地 </strong> 被发送到 <code>thread</code> 线程中。发送成功返回 0，不成功返回非 0。</p>
<p>对「异步地」的理解：<code>pthread_kill()</code>函数向目标线程发送信号时，<strong>不会阻塞调用线程的执行 </strong>。换句话说，调用<code>pthread_kill()</code> 函数发送信号是一个异步操作，<strong>它会立即返回，而不会等待目标线程处理完信号后再继续执行</strong>。这意味着调用线程可以继续执行自己的任务，而不必等待目标线程对接收到的信号做出响应。</p>
<ol start="3">
<li>流程图右二（下），恢复：<code>void thpool_resume(thpool_* thpool_p)</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">void</span>)thpool_p;</span><br><span class="line">threads_on_hold = <span class="number">0</span>;  <span class="comment">// change its value here or thread_hold_on()</span></span><br></pre></td></tr></table></figure>
<p>关注点：</p>
<ol>
<li>线程池暂停与恢复函数是 <strong> 如何控制线程状态的</strong>？<br>
每个线程会注册一个信号，并绑定线程暂停函数。当线程池发出暂停时，每一个线程都将会收到一个暂停信号，这将触发执行 <code>thread_hold</code> 函数，进入循环睡眠，实现线程的暂停；当线程池发出恢复时，将 <code>threads_on_hold</code> 复位，<code>thread_hold</code> 函数将退出循环睡眠，线程继续执行。</li>
</ol>
<h2 id="线程接口">线程接口</h2>
<p>所有的线程接口都被 <code>static</code> 关键字修饰。</p>
<img src="../images/projects/c-thread-pool/thread-pool-thread-method.png" alt="线程池的线程接口" width="100%" height="100%">
<h3 id="线程初始化">线程初始化</h3>
<p>流程图左一：<code>static int thread_init(thpool_* thpool_p, struct thread** thread_p, int id)</code></p>
<ol>
<li>为线程池中的线程分配内存空间</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*thread_p = (<span class="keyword">struct</span> thread*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> thread));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么用二级指针作为入参？参考「线程池初始化 -3」小节。</p>
</blockquote>
<ol start="2">
<li>指定线程所属的线程池</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*thread_p)-&gt;thpool_p = thpool_p;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这一步有何作用？通过线程找到对应的线程池，多个线程可以互斥地改变对应线程池的共享计数资源（发生在<code>thread_do</code>）。</p>
</blockquote>
<ol start="3">
<li>创建线程，并指定 start_routine 函数指针</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建实际线程，并开始执行 thread_do 函数（Worker 函数，其内部执行 Job 函数）</span></span><br><span class="line"><span class="comment"> * int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment"> * (void* (*)(void*))是一个强制类型转换，将 thread_do 函数类型强转为 start_routine 的 void *(*) (void *)类型</span></span><br><span class="line"><span class="comment"> * pthread_detach 函数用于将指定的线程分离出去，主线程不再需要通过 pthread_join 方式回收资源，被分离的线程结束后由 OS 回收资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">pthread_create(&amp;((*thread_p)-&gt;pthread), <span class="literal">NULL</span>, (<span class="type">void</span>* (*)(<span class="type">void</span>*))thread_do, (*thread_p));</span><br><span class="line">pthread_detach((*thread_p)-&gt;pthread);</span><br></pre></td></tr></table></figure>
<h3 id="线程 worker">线程 worker</h3>
<p>这是核心代码，Worker 作为一个无休止的循环，唯一的被中断是调用 <code>thpool_destroy()</code> 或程序退出。它作为一个 Worker，在内部执行不断入队的 Job。</p>
<ol>
<li>获取线程所属的线程池</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thpool_* thpool_p = thread_p-&gt;thpool_p;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>互斥地更新活跃线程数量</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;thpool_p-&gt;thcount_lock);</span><br><span class="line">thpool_p-&gt;num_threads_alive += <span class="number">1</span>;</span><br><span class="line">pthread_mutex_unlock(&amp;thpool_p-&gt;thcount_lock);</span><br></pre></td></tr></table></figure>
<p>在「线程初始化」中，每创建一个线程示例，都会执行对应的启动例程，即<code>thread_do</code>，这个线程运行起来，共享计数量加一。</p>
<ol start="3">
<li>进入轮询（poll），等待条件变量的唤醒通知</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (threads_keepalive) &#123;</span><br><span class="line">    bsem_wait(thpool_p-&gt;jobqueue.has_jobs);</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>有任务被唤醒，执行 Job 任务</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (threads_keepalive) &#123;</span><br><span class="line">    job* job_p = jobqueue_pull(&amp;thpool_p-&gt;jobqueue);</span><br><span class="line">    job_p-&gt;function(job_p-&gt;arg);</span><br><span class="line">    <span class="built_in">free</span>(job_p);</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>无任务被唤醒，即是被 <code>thpool_destroy()</code> 唤醒，if 不成立，while 不成立，退出轮询，活跃线程退出。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;thpool_p-&gt;thcount_lock);</span><br><span class="line">thpool_p-&gt;num_threads_alive--;</span><br><span class="line">pthread_mutex_unlock(&amp;thpool_p-&gt;thcount_lock);</span><br></pre></td></tr></table></figure>
<h2 id="队列接口">队列接口</h2>
<p>任务队列主要是为线程服务的。当有新任务到来时，<code>thpool_add_work</code> 调用 push 函数将新任务插入队尾；当线程检测到任务队列有任务时，及时将任务从队列中 pull 并执行它。</p>
<img src="../images/projects/c-thread-pool/thread-pool-queue-method.png" alt="线程池的任务队列接口" width="100%" height="100%">
<p>具体接口在这里就不再介绍了，直接看流程吧，挺详细的。核心就在 push&amp;pull 操作后，若队列中仍有剩余任务，则会通知唤醒等待在条件变量上的线程，从而使得线程可以执行队列中的任务；当队列为空时，不再通知唤醒线程，线程便会阻塞在条件变量上。</p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://nachtimwald.com/2019/04/12/thread-pool-in-c/">https://nachtimwald.com/2019/04/12/thread-pool-in-c/</a></li>
<li><a target="_blank" rel="noopener" href="https://smartyue076.github.io/2023/06/10/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/">https://smartyue076.github.io/2023/06/10/ 线程池原理与实现 /</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1849765">https://cloud.tencent.com/developer/article/1849765</a></li>
</ol>
</blockquote>

</div>


  <div class="book-comments">
    




  </div>



<script src="/js/book-post.js"></script>

        </div>
      </div>
      <div class="column col-2 hide-lg">
        <div class="book-post-info">
  
    <div class="book-post-meta">

  <div class="author">

    <!-- Author image -->
    <div class="author-img">
      
        <figure
          class="avatar avatar-lg"
          data-initial="A"
          style="background-color: #3b4351;">
        </figure>
      
    </div>

    <!-- Author title -->
    <div class="author-title">
      <div>aha</div>
      <div>2024-03-03</div>
    </div>
  </div>

  
    <div class="divider"></div>

    <div class="link">
      <a class="category-link" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a> <a class="category-link" href="/categories/%E9%A1%B9%E7%9B%AE/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>

      <a class="tag-none-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">#多线程</a> <a class="tag-none-link" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="tag">#线程池</a>
    </div>
    
  

  <div class="divider"></div>
</div>
  

  <div class="book-tocbot">
</div>
<div class="book-tocbot-menu">
  <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
  <a onclick="go_top()">Back to top</a>
  <a onclick="go_bottom()">Go to bottom</a>
</div>


<script src="/js/book-toc.js"></script>

</div>
      </div>
    </div>
  </div>
  
  <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>

</body>
</html>


<script src="/js/book.js"></script>
