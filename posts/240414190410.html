<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

    
      <link rel="icon" href="/favicon.png" />
    

    <title>
        
          Linux 进程间通信机制 - aha&#39;s book
        
    </title>

    <!-- Spectre.css framework -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-exp.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-icons.min.css">

    <!-- theme css & js -->
    
<link rel="stylesheet" href="/css/book.css">

    
<script src="/js/book.js"></script>


    <!-- tocbot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
    
    <!-- katex -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">

    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/zooming/2.1.1/zooming.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    const zooming = new Zooming()
    zooming.listen('.book-content img')
})
</script>

<meta name="generator" content="Hexo 6.3.0"></head>
    <style>
      body {
        background-color: #FFFFFF;
        /* color: #000000; */
        transition: background-color 0.3s ease, color 0.3s ease;
      }

      /* Floating Button Styles */
      .floating-button {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 999;
        background-color: #000000;
        color: #ffffff;
        padding: 12px;
        border-radius: 50%;
        cursor: pointer;
        border: 2px solid #000000;
      }

      .floating-button:hover {
        background-color: #FFFFFF;
      }

      /* Dropdown Menu Styles */
      .dropdown-menu {
        position: fixed;
        bottom: 60px;
        right: 10px;
        display: none;
        min-width: 60px;
        padding: 2px;
        background-color: #fff;
        /* box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); */
        z-index: 1000;
      }

      .floating-button.active+.dropdown-menu {
        display: block;
      }

      .dropdown-item {
        display: block;
        padding: 8px 16px;
        cursor: pointer;
      }

      .dropdown-item:hover {
        background-color: #f5f5f5;
      }
    </style>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body>
  <div class="book-container">
    <div class="book-sidebar">
      <div class="book-brand">
  <a href="/">
    <img src="/favicon.png">
    <span>AHA&#39;S BOOK</span>
  </a>
</div>
        <div id="menu" class="book-menu hide">
  <h2 id="基础知识"> 基础知识 </h2>
<ul>
<li><a href="/posts/231010144856.html"> 模运算 </a></li>
<li><a href="/posts/231014105311.html"> 异或运算 </a></li>
<li><a href="/posts/231210181853.html"> 计算机中的寄存器 </a></li>
<li><a href="/posts/231213183051.html"> 正则表达式基础 </a></li>
</ul>
<h2 id="C 语言">C 语言 </h2>
<ul>
<li><a href="/posts/230916171929.html">main 函数参数 </a></li>
<li><a href="/posts/231214192113.html"> 关键字与专有名词 </a></li>
<li><a href="/posts/240103180653.html"> 输出打印函数 </a></li>
<li><a href="/posts/230922143003.html"> 多维数组 </a></li>
<li><a href="/posts/230913200729.html">const 关键字 </a></li>
<li><a href="/posts/230918174223.html">typedef 类型基础 </a></li>
<li><a href="/posts/230920172849.html">typedef 类型实践 </a></li>
<li><a href="/posts/240224193217.html"> 二级指针 </a></li>
<li><a href="/posts/240307195203.html"> 代码 TOP-K 问题 </a></li>
<li><a href="/posts/230922172626.html">uthash 哈希表基础 </a></li>
<li><a href="/posts/230918114841.html"> 大小端知识 </a></li>
</ul>
<h2 id="Golang 语言">Golang 语言 </h2>
<ul>
<li><a href="/posts/230907162612.html"> 变量与常量 </a></li>
<li><a href="/posts/230909120145.html"> 函数 &amp; 包 &amp; 判断 &amp; 循环 </a></li>
<li><a href="/posts/230912152800.html"> 数组与切片 </a></li>
<li><a href="/posts/230913161326.html"> 可变参数函数与 Map 集合 </a></li>
<li><a href="/posts/230915155105.html"> 字符串和指针 </a></li>
</ul>
<h2 id="数据结构"> 数据结构 </h2>
<ul>
<li><a href="/posts/231007174854.html"> 链表（数组实现）</a></li>
<li><a href="/posts/231008213450.html"> 链表（链式实现）</a></li>
<li><a href="/posts/231016161508.html"> 堆栈（数组实现）</a></li>
<li><a href="/posts/231016184406.html"> 堆栈（链表实现）</a></li>
<li><a href="/posts/231127185207.html"> 单调栈 </a></li>
<li><a href="/posts/231017105123.html"> 队列（链表实现）</a></li>
<li><a href="/posts/231017154121.html"> 双端队列（链表实现）</a></li>
<li><a href="/posts/231018102559.html"> 堆基础与堆结构（数组实现）</a></li>
<li><a href="/posts/231019102311.html"> 优先队列（堆实现）</a></li>
<li><a href="/posts/230905224335.html"> 二叉树的遍历 </a></li>
<li><a href="/posts/231020174358.html"> 二叉搜索树 </a></li>
<li><a href="/posts/230916094606.html"> 拓扑排序 </a></li>
<li><a href="/posts/230925185057.html">Trie 字典树 </a></li>
<li><a href="/posts/231023164532.html"> 并查集（数组实现）</a></li>
<li><a href="/posts/240702200642.html">Linux 数据结构之队列 </a></li>
</ul>
<h2 id="数据结构算法"> 数据结构算法 </h2>
<ul>
<li><a href="/posts/231218181635.html"> 归并排序 </a></li>
<li><a href="/posts/231108163339.html"> 快速排序 </a></li>
<li><a href="/posts/231107171607.html"> 堆排序 </a></li>
<li><a href="/posts/231124181658.html"> 二分查找 </a></li>
<li><a href="/posts/231227190828.html"> 哈希表实现 </a></li>
<li><a href="/posts/240313193201.html"> 字符串哈希函数 </a></li>
<li><a href="/posts/231116150205.html">Floyd 多源最短路径 </a></li>
<li><a href="/posts/231117095232.html">Dijkstra 单源最短路径（原理部分）</a></li>
<li><a href="/posts/231121152713.html">Dijkstra 单源最短路径（实现部分）</a></li>
</ul>
<h2 id="数据库"> 数据库 </h2>
<ul>
<li><a href="/posts/250605180332.html">MySQL 基础 </a></li>
</ul>
<h2 id="计算机网络"> 计算机网络 </h2>
<ul>
<li><a href="/posts/231011192359.html">OSI 参考模型 </a></li>
<li><a href="/posts/240329202000.html"> 计网 CyC2018 之概述 </a></li>
<li><a href="/posts/240329202004.html"> 计网 CyC2018 之链路层 </a></li>
<li><a href="/posts/240329202003.html"> 计网 CyC2018 之网络层 </a></li>
<li><a href="/posts/240329202002.html"> 计网 CyC2018 之传输层 </a></li>
<li><a href="/posts/240329202001.html"> 计网 CyC2018 之应用层 </a></li>
<li><a href="/posts/240306203742.html">ACL 访问控制列表 </a></li>
<li><a href="/posts/240130190208.html"> 路由表、转发表与快速转发工作原理 </a></li>
<li><a href="/posts/231221200716.html">VXLAN 网络虚拟化技术 </a></li>
<li><a href="/posts/240903191243.html">TCP/IP checksum 计算 </a></li>
<li><a href="/posts/240911185603.html"> 抓包分析 TCP 三次握手与四次挥手过程 </a></li>
</ul>
<h2 id="操作系统"> 操作系统 </h2>
<ul>
<li><a href="/posts/230921190726.html"> 概述 </a></li>
<li><a href="/posts/230924172528.html"> 中断 &amp; 异常 &amp; 系统调用 </a></li>
<li><a href="/posts/231017195157.html"> 内存分层体系与地址空间生成 </a></li>
<li><a href="/posts/231108195351.html"> 连续内存分配 </a></li>
<li><a href="/posts/231111172507.html"> 非连续内存分配之分段与分页 </a></li>
<li><a href="/posts/231119170537.html"> 非连续内存分配之页表 </a></li>
<li><a href="/posts/231123184526.html"> 内存管理之覆盖技术与交换技术 </a></li>
<li><a href="/posts/231127193658.html"> 内存管理之虚存技术 </a></li>
<li><a href="/posts/231129182631.html"> 局部页面置换算法 </a></li>
<li><a href="/posts/231207184239.html"> 全局页面置换算法 </a></li>
<li><a href="/posts/231207204958.html"> 进程描述 </a></li>
<li><a href="/posts/231210211306.html"> 进程状态 </a></li>
<li><a href="/posts/231215213932.html"> 线程 </a></li>
<li><a href="/posts/231218220813.html"> 进程控制 </a></li>
<li><a href="/posts/231228193143.html"> 调度 </a></li>
<li><a href="/posts/240104202828.html"> 同步与互斥 </a></li>
<li><a href="/posts/240113115605.html"> 信号量与管程 </a></li>
<li><a href="/posts/240205182643.html"> 经典同步问题 </a></li>
<li><a href="/posts/240310162231.html"> 死锁 </a></li>
</ul>
<h2 id="系统与网络编程"> 系统与网络编程 </h2>
<ul>
<li><a href="/posts/230911151334.html">pthread 库 </a></li>
<li><a href="/posts/230921094127.html"> 锁与原子操作 </a></li>
<li><a href="/posts/240319195609.html"> 读者写者问题 </a></li>
<li><a href="/posts/240527200241.html"> 网络编程卷一阅读随笔 </a></li>
<li><a href="/posts/240414190410.html"> 进程间通信 IPC 机制 </a></li>
<li><a href="/posts/240424200123.html"> 多进程相关练习 </a></li>
<li><a href="/posts/240516221527.html">I/O 模式与 I/O 多路复用 </a></li>
<li><a href="/posts/240626192803.html">Linux 内核 kfifo 环形队列 </a></li>
<li><a href="/posts/241009203126.html">Linux 内核等待队列 </a></li>
<li><a href="/posts/240627210637.html">DPDK 无锁环形队列 </a></li>
<li><a href="/posts/240919200410.html"> 解密内存屏障 </a></li>
<li><a href="/posts/240927202500.html"> 内核线程的创建 </a></li>
<li><a href="/posts/241015195205.html">Linux 网络数据包接收过程 </a></li>
<li><a href="/posts/2410232111015.html"> 源码解读 epoll 实现原理 </a></li>
<li><a href="/posts/241106182619.html">Linux 文件系统 </a></li>
<li><a href="/posts/250619154429.html">Libevent 高性能 IO 事件驱动库 </a></li>
</ul>
<h2 id="工具与命令"> 工具与命令 </h2>
<ul>
<li><a href="/posts/240207180410.html">GCC 编译过程分解 </a></li>
<li><a href="/posts/240312184132.html">GDB 调试入门 </a></li>
<li><a href="/posts/240512184921.html">Makefile 学习 </a></li>
<li><a href="/posts/250629214430.html">CMake 学习 </a></li>
<li><a href="/posts/240417193754.html">Linux 命令之文件权限 </a></li>
</ul>
<h2 id="开源项目"> 开源项目 </h2>
<ul>
<li><a href="/posts/240303201855.html"> 线程池原理与实现 </a></li>
<li><a href="/posts/240507194549.html">HTTP 服务器实现 </a></li>
<li><a href="/posts/240904203605.html"> 聊天服务器实现 </a></li>
<li><a href="/posts/241119182636.html">Linux 文件系统 </a></li>
</ul>
<h2 id="Docker">Docker</h2>
<ul>
<li><a href="/posts/230909171809.html">Docker 学习笔记 </a></li>
</ul>
<h1 id="LeetCode 刷题">LeetCode 刷题 </h1>
<h2 id="链表相关"> 链表相关 </h2>
<ul>
<li><a href="/posts/231025143947.html">160 相交链表 </a></li>
<li><a href="/posts/231025185947.html">206 反转链表 </a></li>
<li><a href="/posts/231026101239.html">21 合并两个有序链表 </a></li>
<li><a href="/posts/231026184514.html">83 删除排序链表中的重复元素 </a></li>
<li><a href="/posts/231027150243.html">19 删除链表的倒数第 N 个节点 </a></li>
<li><a href="/posts/231031120718.html">2 两数相加 </a></li>
<li><a href="/posts/231031163133.html">445 两数相加 II</a></li>
<li><a href="/posts/231101094219.html">234 回文链表 </a></li>
<li><a href="/posts/231101135228.html">725 分隔链表 </a></li>
<li><a href="/posts/231102120708.html">328 奇偶链表 </a></li>
<li><a href="/posts/231102165703.html">142 环形链表 II</a></li>
</ul>
<h2 id="设计"> 设计 </h2>
<ul>
<li><a href="/posts/231201184542.html">146 LRU 缓存 </a></li>
</ul>
<h2 id="贪心算法"> 贪心算法 </h2>
<ul>
<li><a href="/posts/231107094652.html">1029 两地调度 </a></li>
<li><a href="/posts/231109150855.html">435 无重叠区间 </a></li>
</ul>
<h2 id="哈希表"> 哈希表 </h2>
<ul>
<li><a href="/posts/231123181539.html">1410 实体解析器 </a></li>
</ul>
<h2 id="树的遍历"> 树的遍历 </h2>
<ul>
<li><a href="/posts/231103121209.html">117 填充每个节点的下一个右侧节点指针 II</a></li>
</ul>
<h2 id="深度优先搜索（递归）"> 深度优先搜索（递归）</h2>
<ul>
<li><a href="/posts/231206201243.html">2477 达到首都的最少油耗 </a></li>
</ul>
<h2 id="图或路径问题"> 图或路径问题 </h2>
<ul>
<li><a href="/posts/231211184652.html">1631 最小体力消耗路径 </a></li>
</ul>
<h2 id="其它"> 其它 </h2>
<ul>
<li><a href="/posts/230101120000.html"> 备忘录 </a></li>
</ul>

</div>


<script src="/js/book-menu.js"></script>

    </div>
    <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
  <div class="sidebar-toggle-inner"></div>
</div>

<script>
function add_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.add('show')  
}

function remove_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.remove('show')
}

function sidebar_toggle() {
    let sidebar_toggle = document.querySelector('.sidebar-toggle')
    let sidebar = document.querySelector('.book-sidebar')
    let content = document.querySelector('.off-canvas-content')
    if (sidebar_toggle.classList.contains('extend')) { // show
        sidebar_toggle.classList.remove('extend')
        sidebar.classList.remove('hide')
        content.classList.remove('extend')
    }
    else { // hide
        sidebar_toggle.classList.add('extend')
        sidebar.classList.add('hide')
        content.classList.add('extend')
    }
}
</script>

      <div class="off-canvas-content">
        <div class="columns">
          <div class="column col-10 col-lg-12">
            <div class="book-navbar">
              <!-- For Responsive Layout -->

<header class="navbar">
  <section class="navbar-section">
    <a onclick="open_sidebar()">
      <i class="icon icon-menu"></i>
    </a>
  </section>
</header>

            </div>
            <div class="book-content">
              <div class="book-post">
  <p>进程间通信（Inter-Process Communication，IPC）是操作系统中的一个重要概念，<strong>它允许不同进程之间进行数据交换、共享资源和相互协作</strong>。在多任务操作系统中，进程通常是相互独立的，彼此隔离且不能直接访问对方的内存。因此，为了实现进程间的交互，需要使用 IPC 机制。同时，本文章也记录了各种 IPC 通信机制中的常见系统调用 API 的功能描述。</p>
<span id="more"></span>
<h1 id="进程间通信方式">进程间通信方式</h1>
<ul>
<li>
<p><strong>共享文件（Shared file）</strong>：共享文件允许 <strong> 多个进程访问同一个文件</strong>，并在这个文件上进行读取和写入操作。</p>
</li>
<li>
<p><strong>共享内存（Shared memory (with semaphores)）</strong>：共享内存允许 <strong> 多个进程访问同一块内存区域 </strong>，这样它们就可以直接读取或写入数据，而无需进行复制。共享内存通常是<strong> 最快的 IPC 方法之一</strong>，因为它避免了数据的复制操作。</p>
</li>
<li>
<p><strong>信号量（Semaphores）</strong>：信号量是一种用于控制对共享资源的访问的同步机制。它可以用来解决竞态条件（Race Condition）和临界区（Critical Section）问题，确保多个进程之间的互斥和同步。</p>
</li>
<li>
<p><strong>管道（Pipe (named and unnamed)）</strong>：管道是一种 <strong> 单向通信机制</strong>，用于在相关进程之间传输数据。它通常用于具有亲缘关系（父子进程）的进程之间的通信。管道有匿名管道和命名管道两种类型。</p>
</li>
<li>
<p><strong>消息队列（Message queues）</strong>：消息队列是一种进程间通信的方式，其中的 <strong> 消息被放置在一个队列中</strong>，并且可以由多个接收者进行读取。消息队列通常是通过消息队列标识符来进行引用的。</p>
</li>
<li>
<p><strong>套接字（Socket）</strong>：套接字是一种在网络上进行进程间通信的通用方法。它允许 <strong> 不同计算机上的进程进行通信</strong>，可以用于实现客户端 - 服务器模型等应用。</p>
</li>
</ul>
<blockquote>
<p>如果需要高效的数据传输，共享内存可能是一个不错的选择；如果需要在不同机器上的进程进行通信，套接字则是一个更合适的选择。</p>
</blockquote>
<h1 id="核心概念">核心概念</h1>
<p>进程是正在执行的程序，每个进程都有自己的地址空间，其中包括允许进程访问的内存位置。</p>
<p>进程内的线程共享各种资源，特别是地址空间。因此，进程内的线程可以通过共享内存直接通信。但是，不同的进程，默认情况下，不共享内存。</p>
<p>启动进程然后进行通信的方法有很多种，主要有两种方法：</p>
<ul>
<li>使用终端来启动一个进程，使用不同的终端来启动另一个进程。</li>
<li>在一个进程（父进程）内调用系统函数 <code>fork</code> 以生成另一进程（子进程）。</li>
</ul>
<h1 id="Shared-Storage">Shared Storage</h1>
<h2 id="Shared-File">Shared File</h2>
<p>共享文件可能是最基本的 IPC 机制。考虑相对简单的情况，其中一个进程（生产者）创建并写入文件，而另一个进程（消费者）从同一个文件中读取。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">         writes  +-----------+  reads </span><br><span class="line">producer--------&gt;| disk file |&lt;-------consumer </span><br><span class="line">                 +-----------+ </span><br></pre></td></tr></table></figure>
<p>使用此 IPC 机制的明显挑战是 <strong> 可能会出现竞态条件</strong>：生产者和消费者可能会同时访问文件，从而导致结果不确定。为了避免竞态条件，必须以防止写入操作与任何其他操作（无论是读取还是写入）之间发生冲突的方式锁定文件。</p>
<ul>
<li>生产者应该在写入文件之前获得文件的独占锁。独占锁最多只能由一个进程持有，这排除了竞态条件，因为在释放锁之前没有其他进程可以访问该文件。</li>
<li>在读取文件之前，消费者应该至少获得文件的共享锁。多个读取者可以同时持有共享锁，但是当单个读取者持有共享锁时，任何写入者都无法访问文件。</li>
</ul>
<p>标准 I/O 库包含一个 <strong> 名为 <code>fcntl</code> 的实用函数，可用于检查和操作文件上的独占锁和共享锁</strong>。该函数通过文件描述符进行工作，文件描述符是一个非负整数值，在进程内标识一个文件（不同进程中的不同文件描述符可能标识同一个物理文件）。</p>
<p>对于文件锁定，Linux 提供了库函数 <code>flock</code>，它是 <code>fcntl</code> 的 thin wrapper。第一个示例使用 <code>fcntl</code> 函数探索 API 细节。</p>
<h3 id="producer">producer</h3>
<p>Example 1. the producer program <em>producer.c</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FileName <span class="string">&quot;data.txt&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DataString <span class="string">&quot;Now is the winter of our discontent\nMade glorious summer by this sun of York\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">report_and_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span> &#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>); <span class="comment">/* EXIT_FAILURE */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">lock</span>;</span></span><br><span class="line">    lock.l_type = F_WRLCK;    <span class="comment">/* read/write (exclusive versus shared) lock */</span></span><br><span class="line">    lock.l_whence = SEEK_SET; <span class="comment">/* base for seek offsets */</span></span><br><span class="line">    lock.l_start = <span class="number">0</span>;         <span class="comment">/* 1st byte in file */</span></span><br><span class="line">    lock.l_len = <span class="number">0</span>;           <span class="comment">/* 0 here means &#x27;until EOF&#x27; */</span></span><br><span class="line">    lock.l_pid = getpid();    <span class="comment">/* process id */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd; <span class="comment">/* file descriptor to identify a file within a process */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(FileName, O_RDWR | O_CREAT, <span class="number">0666</span>)) &lt; <span class="number">0</span>) <span class="comment">/* -1 signals an error */</span></span><br><span class="line">        report_and_exit(<span class="string">&quot;open failed...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fcntl(fd, F_SETLK, &amp;lock) &lt; <span class="number">0</span>) <span class="comment">/** F_SETLK doesn&#x27;t block, F_SETLKW does **/</span></span><br><span class="line">        report_and_exit(<span class="string">&quot;fcntl failed to get lock...&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        write(fd, DataString, <span class="built_in">strlen</span>(DataString)); <span class="comment">/* populate data file */</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Process %d has written to data file...\n&quot;</span>, lock.l_pid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now release the lock explicitly. */</span></span><br><span class="line">    lock.l_type = F_UNLCK;</span><br><span class="line">    <span class="keyword">if</span> (fcntl(fd, F_SETLK, &amp;lock) &lt; <span class="number">0</span>)</span><br><span class="line">        report_and_exit(<span class="string">&quot;explicit unlocking failed...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(fd); <span class="comment">/* close the file: would unlock if needed */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">/* terminating the process would unlock as well */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述生产者程序的主要步骤可以总结如下：</p>
<p>1）程序声明了一个 <code>struct flock</code> 类型的变量，它代表一个锁，并初始化了该结构的五个字段，<code>F_WRLCK</code> 使锁成为独占（读写）锁而不是共享（只读）锁。该变量主要作用是锁定整个文件，但也可以通过 <code>l_start</code> 和 <code>l_len</code> 来锁定指定的字节。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vim /usr/include/x86_64-linux-gnu/bits/fcntl.h +35</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flock</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">   <span class="type">short</span> <span class="type">int</span> l_type;   <span class="comment">/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.  */</span></span><br><span class="line">   <span class="type">short</span> <span class="type">int</span> l_whence; <span class="comment">/* How to interpret l_start: SEEK_SET, SEEK_CUR, SEEK_END.  */</span></span><br><span class="line">   <span class="type">__off_t</span> l_start;    <span class="comment">/* Offset where the lock begins.  */</span></span><br><span class="line">   <span class="type">__off_t</span> l_len;      <span class="comment">/* Size of the locked area; zero means until EOF.  */</span></span><br><span class="line">   <span class="type">__pid_t</span> l_pid;      <span class="comment">/* Process holding the lock.  */</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>2）第一次调用 <code>fcntl(fd, F_SETLK, &amp;lock)</code> 尝试以独占方式锁定文件。第二个参数 <code>F_SETLK</code> 表示对 <code>fcntl</code> 的调用不会阻塞：函数立即返回，要么授予锁，要么指示失败。如果改用标志 <code>F_SETLKW</code>（末尾的 W 表示 wait ），则对 <code>fcntl</code> 的调用将阻塞，直到可以获取锁为止。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span> )</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   <span class="title function_">fcntl</span><span class="params">()</span> performs one of the operations described below on the </span><br><span class="line">   open file descriptor fd.  The operation is determined by cmd.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>3）写入文件后，生产者将文件锁结构的 <code>l_type</code> 字段更改为解锁值 <code>F_UNLCK</code>，并调用 <code>fcntl</code> 执行解锁操作。</p>
<h3 id="consumer">consumer</h3>
<p>Example 2. the consumer program <em>consumer</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FileName <span class="string">&quot;data.txt&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">report_and_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span> &#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>); <span class="comment">/* EXIT_FAILURE */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">lock</span>;</span></span><br><span class="line">    lock.l_type = F_WRLCK;    <span class="comment">/* read/write (exclusive) lock */</span></span><br><span class="line">    lock.l_whence = SEEK_SET; <span class="comment">/* base for seek offsets */</span></span><br><span class="line">    lock.l_start = <span class="number">0</span>;         <span class="comment">/* 1st byte in file */</span></span><br><span class="line">    lock.l_len = <span class="number">0</span>;           <span class="comment">/* 0 here means &#x27;until EOF&#x27; */</span></span><br><span class="line">    lock.l_pid = getpid();    <span class="comment">/* process id */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd; <span class="comment">/* file descriptor to identify a file within a process */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(FileName, O_RDONLY)) &lt; <span class="number">0</span>) <span class="comment">/* -1 signals an error */</span></span><br><span class="line">        report_and_exit(<span class="string">&quot;open to read failed...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the file is write-locked, we can&#x27;t continue. */</span></span><br><span class="line">    fcntl(fd, F_GETLK, &amp;lock); <span class="comment">/* sets lock.l_type to F_UNLCK if no write lock */</span></span><br><span class="line">    <span class="keyword">if</span> (lock.l_type != F_UNLCK)</span><br><span class="line">        report_and_exit(<span class="string">&quot;file is still write locked...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    lock.l_type = F_RDLCK; <span class="comment">/* prevents any writing during the reading */</span></span><br><span class="line">    <span class="keyword">if</span> (fcntl(fd, F_SETLK, &amp;lock) &lt; <span class="number">0</span>)</span><br><span class="line">        report_and_exit(<span class="string">&quot;can&#x27;t get a read-only lock...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Read the bytes (they happen to be ASCII codes) one at a time. */</span></span><br><span class="line">    <span class="type">int</span> c;                           <span class="comment">/* buffer for read bytes */</span></span><br><span class="line">    <span class="keyword">while</span> (read(fd, &amp;c, <span class="number">1</span>) &gt; <span class="number">0</span>)      <span class="comment">/* 0 signals EOF */</span></span><br><span class="line">        write(STDOUT_FILENO, &amp;c, <span class="number">1</span>); <span class="comment">/* write one byte to the standard output */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Release the lock explicitly. */</span></span><br><span class="line">    lock.l_type = F_UNLCK;</span><br><span class="line">    <span class="keyword">if</span> (fcntl(fd, F_SETLK, &amp;lock) &lt; <span class="number">0</span>)</span><br><span class="line">        report_and_exit(<span class="string">&quot;explicit unlocking failed...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者程序首先检查文件是否被独占锁定，然后才尝试获得共享锁。<code>fcntl</code> 调用中指定的 <code>F_GETLK</code> 操作检查锁，在本例中，是上面第一个语句中以 <code>F_WRLCK</code> 形式给出的独占锁。如果指定的锁不存在，则 <code>fcntl</code> 调用会自动将锁类型字段更改为 <code>F_UNLCK</code> 以指示这一事实。如果文件被独占锁定，则消费者终止（该程序的更强大版本可能会让消费者稍微休息一下，然后重试几次）。</p>
<p>如果文件当前未锁定，则消费者尝试获取共享（只读）锁 <code>F_RDLCK</code>。获得共享锁后，消费者程序从文件中一次读取一个字节，将字节打印到标准输出，释放锁，关闭文件，然后终止。</p>
<blockquote>
<p>为了缩短程序，尝试获取共享（只读）锁后，可以删除对 <code>fcntl</code> 的 <code>F_GETLK</code> 调用，因为如果其他某个进程已持有互斥（读写）锁，则 <code>F_RDLCK</code> 赋值操作不会成功。</p>
</blockquote>
<h3 id="特点">特点</h3>
<p>共享文件的内容可能是大量的、任意字节（例如数字化电影），这使得文件共享成为一种非常灵活的 IPC 机制。<strong>缺点是文件访问无论是读还是写都比较慢</strong>。下一个示例通过共享内存（而不是共享文件）展现了 IPC 的优势，并相应提高了性能。</p>
<h2 id="Shared-memory">Shared memory</h2>
<p>默认情况下，<strong>为共享内存提供的 POSIX API 将共享内存实现为内存映射文件：对于共享内存段，系统维护一个具有相应内容的后备文件（backing file）</strong>。POSIX 下的共享内存可以在没有后备文件的情况下进行配置，但这可能会影响可移植性。</p>
<p>下面的示例使用带有支持后备文件的 POSIX API，它 <strong> 结合了内存访问（速度）和文件存储（持久性）的优点</strong>。</p>
<p>共享内存示例有两个程序，名为 <em>memwriter</em> 和 <em>memreader</em>，并 <strong> 使用信号量来协调（同步）它们对共享内存的访问</strong>——因为无论是在多进程还是多线程中，基于内存的竞态条件的风险也是如此。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file shmem.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ByteSize 512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BackingFile <span class="string">&quot;/shMemEx&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AccessPerms 0644</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SemaphoreName <span class="string">&quot;mysemaphore&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MemContents <span class="string">&quot;This is the way the world ends...\n&quot;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="memwriter">memwriter</h3>
<p>Example 3. source code for the memwriter process <em>memwriter.c</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Compilation: gcc -o memwriter memwriter.c -lrt -lpthread **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shmem.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">report_and_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span> &#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = shm_open(BackingFile,      <span class="comment">/* name from smem.h */</span></span><br><span class="line">                      O_RDWR | O_CREAT, <span class="comment">/* read/write, create if needed */</span></span><br><span class="line">                      AccessPerms);     <span class="comment">/* access permissions (0644) */</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        report_and_exit(<span class="string">&quot;Can&#x27;t open shared mem segment...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ftruncate(fd, ByteSize); <span class="comment">/* get the bytes */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">caddr_t</span> memptr = mmap(<span class="literal">NULL</span>,                   <span class="comment">/* let system pick where to put segment */</span></span><br><span class="line">                          ByteSize,               <span class="comment">/* how many bytes */</span></span><br><span class="line">                          PROT_READ | PROT_WRITE, <span class="comment">/* access protections */</span></span><br><span class="line">                          MAP_SHARED,             <span class="comment">/* mapping visible to other processes */</span></span><br><span class="line">                          fd,                     <span class="comment">/* file descriptor */</span></span><br><span class="line">                          <span class="number">0</span>);                     <span class="comment">/* offset: start at 1st byte */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">caddr_t</span>)<span class="number">-1</span> == memptr)</span><br><span class="line">        report_and_exit(<span class="string">&quot;Can&#x27;t get segment...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;shared mem address: %p [0..%d]\n&quot;</span>, memptr, ByteSize - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;backing file:       /dev/shm%s\n&quot;</span>, BackingFile);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* semahore code to lock the shared mem */</span></span><br><span class="line">    <span class="type">sem_t</span>* semptr = sem_open(SemaphoreName, <span class="comment">/* name */</span></span><br><span class="line">                             O_CREAT,       <span class="comment">/* create the semaphore */</span></span><br><span class="line">                             AccessPerms,   <span class="comment">/* protection perms */</span></span><br><span class="line">                             <span class="number">0</span>);            <span class="comment">/* initial value */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">void</span>*)<span class="number">-1</span> == semptr)</span><br><span class="line">        report_and_exit(<span class="string">&quot;sem_open&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(memptr, MemContents); <span class="comment">/* copy some ASCII bytes to the segment */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* increment the semaphore so that memreader can read */</span></span><br><span class="line">    <span class="keyword">if</span> (sem_post(semptr) &lt; <span class="number">0</span>)</span><br><span class="line">        report_and_exit(<span class="string">&quot;sem_post&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">12</span>); <span class="comment">/* give reader a chance */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* clean up */</span></span><br><span class="line">    munmap(memptr, ByteSize); <span class="comment">/* unmap the storage */</span></span><br><span class="line">    close(fd);</span><br><span class="line">    sem_close(semptr);</span><br><span class="line">    shm_unlink(BackingFile); <span class="comment">/* unlink from the backing file */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二进制信号量是一种特殊情况，只需要两个值：0 和 1，充当互斥锁。共享内存示例使用信号量作为互斥体。当信号量的值为 0 时，只有 memwriter 可以访问共享内存。写入后，该进程会增加信号量的值，从而允许 memreader 读取共享内存。</p>
<p>以下概述了 memwriter 和 memreader 程序如何通过共享内存进行通信：</p>
<p>1）如上所示，memwriter 程序调用 <code>shm_open</code> 函数来获取系统与共享内存协调的 backing file 的文件描述符。<strong>此时，还没有分配任何内存</strong>。随后调用名称具有误导性的函数 <code>ftruncate</code> 分配 <code>ByteSize</code> 字节。</p>
<ul>
<li>memwriter 和 memreader 程序 <strong> 仅访问共享内存，而不访问后备文件。系统负责同步共享内存和后备文件</strong>。</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">int</span> <span class="title function_">shm_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflag, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line">   <span class="type">int</span> <span class="title function_">shm_unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   <span class="title function_">shm_open</span><span class="params">()</span> creates and opens a new, or opens an existing, POSIX</span><br><span class="line">   shared memory object.  A POSIX shared memory object is in effect</span><br><span class="line">   a handle which can be used by unrelated processes to <span class="title function_">mmap</span><span class="params">(<span class="number">2</span>)</span> the</span><br><span class="line">   same region of shared memory.  The <span class="title function_">shm_unlink</span><span class="params">()</span> function performs</span><br><span class="line">   the converse operation, removing an object previously created by</span><br><span class="line">   <span class="title function_">shm_open</span><span class="params">()</span>.</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">ftruncate</span><span class="params">(<span class="type">int</span> fildes, <span class="type">off_t</span> length)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   If fildes is not a valid file descriptor open <span class="keyword">for</span> writing, the</span><br><span class="line">   <span class="title function_">ftruncate</span><span class="params">()</span> function shall fail.</span><br><span class="line"></span><br><span class="line">   If fildes refers to a regular file, the <span class="title function_">ftruncate</span><span class="params">()</span> function</span><br><span class="line">   shall cause the size of the file to be truncated to length.  If</span><br><span class="line">   the size of the file previously exceeded length, the extra data</span><br><span class="line">   shall no longer be available to reads on the file. If the file</span><br><span class="line">   previously was smaller than this size, <span class="title function_">ftruncate</span><span class="params">()</span> shall increase</span><br><span class="line">   the size of the file. If the file size is increased, the extended</span><br><span class="line">   area shall appear as <span class="keyword">if</span> it were zero-filled. The value of the</span><br><span class="line">   seek pointer shall not be modified by a call to <span class="title function_">ftruncate</span><span class="params">()</span>.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>2）然后 memwriter <strong>调用 <code>mmap</code> 函数，获取指向共享内存的指针</strong>。指针类型 <code>caddr_t</code> 以 c 开头，代表 calloc，这是一个将动态分配的存储初始化为零（initializes dynamically allocated storage to zeroes）的系统函数。</p>
<ul>
<li><code>mmap</code> 的第一个参数是 NULL，这意味着系统决定在虚拟地址空间中分配内存的位置。</li>
<li><code>MAP_SHARED</code> 标志指示分配的内存可在进程之间共享，最后一个参数（在本例中为零）意味着共享内存的偏移量应该是第一个字节。</li>
<li>size 参数指定要分配的字节数，protection 参数指示共享内存可以写入和读取。</li>
<li>函数执行成功后，系统在 <code>/dev/shm</code> 目录下创建并维护后备文件 <code>/shMemEx</code></li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> addr[.length], <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">           <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line">   <span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> addr[.length], <span class="type">size_t</span> length)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   <span class="title function_">mmap</span><span class="params">()</span> creates a new mapping in the virtual address space of the</span><br><span class="line">   calling process.  The starting address <span class="keyword">for</span> the new mapping is</span><br><span class="line">   specified in addr.  The length argument specifies the length of</span><br><span class="line">   the <span class="title function_">mapping</span> <span class="params">(which must be greater than <span class="number">0</span>)</span>.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>3）此时，memwriter 已准备好写入，但它首先创建一个信号量以确保对共享内存的独占访问。如果对 <code>sem_open</code> 的调用成功，然后就可以处理写操作了。</p>
<ul>
<li>在 memwriter 和 memreader 进程中，通过 <strong> 调用 sem_open 时使用相同的名称标识，可以访问同一个信号量</strong>。</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">sem_t</span> *<span class="title function_">sem_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflag)</span>;</span><br><span class="line">   <span class="type">sem_t</span> *<span class="title function_">sem_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflag,</span></span><br><span class="line"><span class="params">                   <span class="type">mode_t</span> mode, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   <span class="title function_">sem_open</span><span class="params">()</span> creates a new POSIX semaphore or opens an existing</span><br><span class="line">   semaphore.  The semaphore is identified by name.</span><br><span class="line"></span><br><span class="line">   The oflag argument specifies flags that control the operation of</span><br><span class="line">   the call.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>4）写入后，memwriter 通过 <code>sem_post()</code> 将信号量值增加到 1。增加信号量会释放互斥锁，并使 memreader 能够执行其读取操作。</p>
<p>5）最后，memwriter 进程还从 memwriter 地址空间取消共享内存的映射，这会阻止 memwriter 进一步访问共享内存；以及其它关闭操作。</p>
<ul>
<li>如果省略 <code>shm_unlink</code> 语句，则后备文件在程序终止后仍然存在。</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   The <span class="title function_">munmap</span><span class="params">()</span> function shall remove any mappings <span class="keyword">for</span> those entire</span><br><span class="line">   pages containing any part of the address space of the process</span><br><span class="line">   starting at addr and continuing <span class="keyword">for</span> len bytes. Further references</span><br><span class="line">   to these pages shall result in the generation of a SIGSEGV signal</span><br><span class="line">   to the process.  If there are no mappings in the specified</span><br><span class="line">   address range, then <span class="title function_">munmap</span><span class="params">()</span> has no effect.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在 memwriter 和 memreader 程序中，主要感兴趣的共享内存函数是 <code>shm_open</code> 和 <code>mmap</code>：如果成功，第一个调用将返回后备文件的文件描述符，第二个调用将使用该文件描述符来获取指向共享内存的指针部分。</p>
<h3 id="memreader">memreader</h3>
<p>Example 4. source code for the memreader process <em>memreader</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Compilation: gcc -o memreader memreader.c -lrt -lpthread **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shmem.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">report_and_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span> &#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = shm_open(BackingFile, O_RDWR, AccessPerms); <span class="comment">/* empty to begin */</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        report_and_exit(<span class="string">&quot;Can&#x27;t get file descriptor...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get a pointer to memory */</span></span><br><span class="line">    <span class="type">caddr_t</span> memptr = mmap(<span class="literal">NULL</span>,                   <span class="comment">/* let system pick where to put segment */</span></span><br><span class="line">                          ByteSize,               <span class="comment">/* how many bytes */</span></span><br><span class="line">                          PROT_READ | PROT_WRITE, <span class="comment">/* access protections */</span></span><br><span class="line">                          MAP_SHARED,             <span class="comment">/* mapping visible to other processes */</span></span><br><span class="line">                          fd,                     <span class="comment">/* file descriptor */</span></span><br><span class="line">                          <span class="number">0</span>);                     <span class="comment">/* offset: start at 1st byte */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">caddr_t</span>)<span class="number">-1</span> == memptr)</span><br><span class="line">        report_and_exit(<span class="string">&quot;Can&#x27;t access segment...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create a semaphore for mutual exclusion */</span></span><br><span class="line">    <span class="type">sem_t</span>* semptr = sem_open(SemaphoreName, <span class="comment">/* name */</span></span><br><span class="line">                             O_CREAT,       <span class="comment">/* create the semaphore */</span></span><br><span class="line">                             AccessPerms,   <span class="comment">/* protection perms */</span></span><br><span class="line">                             <span class="number">0</span>);            <span class="comment">/* initial value */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">void</span>*)<span class="number">-1</span> == semptr)</span><br><span class="line">        report_and_exit(<span class="string">&quot;sem_open&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* use semaphore as a mutex (lock) by waiting for writer to increment it */</span></span><br><span class="line">    <span class="keyword">if</span> (!sem_wait(semptr)) &#123; <span class="comment">/* wait until semaphore != 0 */</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(MemContents); i++)</span><br><span class="line">            write(STDOUT_FILENO, memptr + i, <span class="number">1</span>); <span class="comment">/* one byte at a time */</span></span><br><span class="line">        sem_post(semptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* cleanup */</span></span><br><span class="line">    munmap(memptr, ByteSize);</span><br><span class="line">    close(fd);</span><br><span class="line">    sem_close(semptr);</span><br><span class="line">    unlink(BackingFile);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与 memwriter 一样，memreader 在调用 <code>sem_open</code> 时 <strong> 通过其名称来访问信号量</strong>。但是 memreader 然后进入等待状态，直到 memwriter 递增信号量。一旦等待结束，memreader 就会从共享内存中读取 ASCII 字节，随后进行清理并终止。</p>
<blockquote>
<p>共享内存 API 包含显式同步共享内存段和后备文件的操作 <code>msync(NULL, ByteSize, MS_SYNC)</code>。示例中省略了这些操作，以减少混乱并将重点放在内存共享和信号量代码上。</p>
</blockquote>
<h3 id="输出">输出</h3>
<p>先执行 memwriter 进程，然后执行 memreader 进程，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">% ./memwriter</span><br><span class="line">shared mem address: 0x7f924123f000 [0..511]</span><br><span class="line">backing file:       /dev/shm/shMemEx</span><br><span class="line">(...sleep 12s, then to end...)</span><br><span class="line">% </span><br><span class="line"></span><br><span class="line">% ./memreader</span><br><span class="line">This is the way the world ends...</span><br><span class="line">% </span><br></pre></td></tr></table></figure>
<h3 id="特点 -v2">特点</h3>
<p>共享文件和共享内存示例展示了进程如何通过共享存储进行通信，一种情况是文件，另一种情况是内存段。这两种方法的 API 都相对简单。这些方法有共同的缺点吗？现代应用程序经常处理流数据，实际上是处理大量数据流。<strong>共享文件和共享内存方法都不太适合海量数据流</strong>。Channels of one type or another are better suited. Next part thus introduces pipes and message queues.</p>
<h1 id="Pipes">Pipes</h1>
<p>本节转向管道，管道（pipes）是连接进程进行通信的通道（channels）。一个 channel 有一个用于写入字节的写端（write-end），以及一个用于以 FIFO 顺序读取这些字节的读端（read-end）。在典型使用中，一个进程向 channel 写入数据，而另一个进程从同一 channel 读取数据。</p>
<p>管道有两种类型：命名（named）的和匿名（unnamed）的，<strong>可以在命令行交互式地使用，也可以在程序内部使用</strong>。</p>
<p>一般来说，基于 channel 的 IPC 是并发安全（concurrent-safe）的。</p>
<h2 id="Unnamed-pipes">Unnamed pipes</h2>
<h3 id="在交互式命令行">在交互式命令行</h3>
<p>让我们从一个命令行示例开始，该示例展示了匿名管道的工作原理。在所有现代系统中，<strong>竖线 <code>|</code> 表示命令行中的匿名管道</strong>。假设 % 是命令行提示符，并考虑以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">sleep</span> 5 | <span class="built_in">echo</span> <span class="string">&quot;Hello, world!&quot;</span> <span class="comment">## writer to the left of |, reader to the right</span></span><br></pre></td></tr></table></figure>
<p><code>sleep</code> 和 <code>echo</code> 实用程序作为单独的进程执行，并且匿名管道允许它们进行通信——该示例是人为设计的（没有发生通信）。问候语 <em>Hello, world!</em> 出现在屏幕上；然后，大约五秒钟后，命令行提示符返回，表明 <code>sleep</code> 和 <code>echo</code> 进程都已退出。这是怎么回事？</p>
<p><strong>在命令行的 <code>|</code> 语法中，左侧的进程（<code>sleep</code>）是写者，右侧的进程（<code>echo</code>）是读者。默认情况下，读者会阻塞，直到能从通道读取字节，而写者在写入字节后，通过发送流结束标记来完成（即使写者提前终止，流结束标记也会发送给读者）。匿名管道将持续存在，直到写者和读者都终止</strong>。</p>
<blockquote>
<p>刚刚不是说“默认情况下，读者会阻塞，直到能从通道读取字节”吗？那为什么是立即打印呢？</p>
<p><code>sleep</code> 进程不会向通道写入任何字节，但会在大约五秒后终止，这会向通道发送流结束标记。同时，<code>echo</code> 进程立即将问候语写入标准输出（屏幕），因为该进程不会从通道读取任何字节，因此无需等待。</p>
</blockquote>
<p>两个需要通信的例子，写者写入字节、读者从管道中读取字节：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">sleep</span> 5 &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;Data printed after waiting&quot;</span> &amp;&amp; <span class="built_in">sleep</span> 3 | <span class="built_in">echo</span> <span class="string">&quot;hello world!&quot;</span> | <span class="built_in">cat</span></span><br><span class="line">Data printed after waiting (5s-th)</span><br><span class="line">hello world! (5s-th)</span><br><span class="line">% (8s-th)</span><br><span class="line"></span><br><span class="line">% <span class="built_in">cat</span> test.txt</span><br><span class="line">this</span><br><span class="line">is</span><br><span class="line">the</span><br><span class="line">way</span><br><span class="line">the</span><br><span class="line">world</span><br><span class="line">ends</span><br><span class="line">% <span class="built_in">cat</span> test.txt | <span class="built_in">sort</span> | <span class="built_in">uniq</span></span><br><span class="line">ends</span><br><span class="line">is</span><br><span class="line">the</span><br><span class="line">this</span><br><span class="line">way</span><br><span class="line">world</span><br><span class="line">%</span><br></pre></td></tr></table></figure>
<h3 id="在程序内部">在程序内部</h3>
<p>Example 1. a <em>pipeUN.c</em> with two processes communicating through an unnamed pipe.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span> <span class="comment">/* wait */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>   <span class="comment">/* exit functions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>   <span class="comment">/* read, write, pipe, _exit */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ReadEnd  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WriteEnd 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">report_and_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span> &#123;</span><br><span class="line">  perror(msg);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">-1</span>);    <span class="comment">/** failure **/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> pipeFDs[<span class="number">2</span>]; <span class="comment">/* two file descriptors */</span></span><br><span class="line">  <span class="type">char</span> buf;       <span class="comment">/* 1-byte buffer */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* msg = <span class="string">&quot;Nature&#x27;s first green is gold\n&quot;</span>; <span class="comment">/* bytes to write */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pipe(pipeFDs) &lt; <span class="number">0</span>) report_and_exit(<span class="string">&quot;pipeFD&quot;</span>);</span><br><span class="line">  <span class="type">pid_t</span> cpid = fork();                                <span class="comment">/* fork a child process */</span></span><br><span class="line">  <span class="keyword">if</span> (cpid &lt; <span class="number">0</span>) report_and_exit(<span class="string">&quot;fork&quot;</span>);              <span class="comment">/* check for failure */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> == cpid) &#123;    <span class="comment">/*** child ***/</span>                 <span class="comment">/* child process */</span></span><br><span class="line">    close(pipeFDs[WriteEnd]);                         <span class="comment">/* child reads, doesn&#x27;t write */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (read(pipeFDs[ReadEnd], &amp;buf, <span class="number">1</span>) &gt; <span class="number">0</span>)       <span class="comment">/* read until end of byte stream */</span></span><br><span class="line">      write(STDOUT_FILENO, &amp;buf, <span class="keyword">sizeof</span>(buf));        <span class="comment">/* echo to the standard output */</span></span><br><span class="line"></span><br><span class="line">    close(pipeFDs[ReadEnd]);                          <span class="comment">/* close the ReadEnd: all done */</span></span><br><span class="line">    _exit(<span class="number">0</span>);                                         <span class="comment">/* exit and notify parent at once  */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;              <span class="comment">/*** parent ***/</span></span><br><span class="line">    close(pipeFDs[ReadEnd]);                          <span class="comment">/* parent writes, doesn&#x27;t read */</span></span><br><span class="line"></span><br><span class="line">    write(pipeFDs[WriteEnd], msg, <span class="built_in">strlen</span>(msg));       <span class="comment">/* write the bytes to the pipe */</span></span><br><span class="line">    close(pipeFDs[WriteEnd]);                         <span class="comment">/* done writing: generate eof */</span></span><br><span class="line"></span><br><span class="line">    wait(<span class="literal">NULL</span>);                                       <span class="comment">/* wait for child to exit */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);                                          <span class="comment">/* exit normally */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的 <em>pipeUN.c</em> 程序使用系统函数 <code>fork</code> 来创建进程。尽管程序只有一个源文件，但在（成功）执行期间会发生多处理。</p>
<p>以下是库函数 <code>fork</code> 工作原理的快速回顾：</p>
<p>在父进程中调用的 <code>fork</code> 函数，返回值为整数类型的 <code>pid_t</code> 变量。<strong>如果 <code>fork</code> 调用成功，它就会生成（创建）一个新的子进程，向父进程返回一个值，但向子进程返回一个不同的值。父进程和子进程都执行调用 <code>fork</code> 之后的相同代码，但大概率（人为设计）走向不同的条件分支（通过 <code>fork</code> 成功时的返回值来分流）</strong>。</p>
<ul>
<li>调用 <code>fork</code> 失败时，向父进程返回 -1。</li>
<li><strong>调用 <code>fork</code> 成功时，子进程返回 0、父进程返回子进程的 PID</strong>。</li>
</ul>
<p>如何在程序中使用匿名管道？</p>
<p>使用系统调用 <code>pipe</code> 来创建管道，数组参数用于返回：写入字节的写端（write-end）的文件描述符，以及一个用于以 FIFO 顺序读取这些字节的读端（read-end）的文件描述符。数组索引 0 对应读端文件描述符。索引 1 对应写端文件描述符。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   <span class="title function_">pipe</span><span class="params">()</span> creates a pipe, a unidirectional data channel that can be</span><br><span class="line">   used <span class="keyword">for</span> interprocess communication.  The <span class="built_in">array</span> pipefd is used to</span><br><span class="line">   <span class="keyword">return</span> two file descriptors referring to the ends of the pipe.</span><br><span class="line">   pipefd[0] refers to the read end of the pipe.  pipefd[1] refers</span><br><span class="line">   to the write end of the pipe.  Data written to the write end of</span><br><span class="line">   the pipe is buffered by the kernel until it is read from the read</span><br><span class="line">   end of the pipe.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在这个例子中，父进程负责将数据写入匿名管道，子进程负责从匿名管道读取数据。所以，在各自进程的分支处理中，先把不使用的另一个文件描述符关闭了。</p>
<p><strong>需要注意的细节</strong>：</p>
<p>1）父进程中对 <code>wait(NULL)</code> 函数调用的作用？</p>
<p>虽然，子进程在很大程度上独立于其父进程、子进程可以执行与父进程无关的任意代码。但是，如果子进程终止，系统会通过信号通知父进程。</p>
<p><strong>如果父进程先于子进程终止怎么办？在这种情况下，除非采取预防措施，否则子进程将成为并保持为僵尸进程，并在进程表中残留一个条目</strong>。</p>
<p>预防措施有两大类。<strong>一种预防措施是让父进程通知系统，让其知道：父进程（自己）对子进程的终止没有兴趣</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGCHLD, SIG_IGN); <span class="comment">/* in parent: ignore notification */</span></span><br></pre></td></tr></table></figure>
<p><strong>第二种方法是让父进程执行等待操作，等待任何一个子进程的终止，从而确保父进程的寿命比子进程的寿命长</strong>。</p>
<p><strong>wait() 系统调用</strong></p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *_Nullable wstatus)</span>;</span><br><span class="line">   <span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *_Nullable wstatus, <span class="type">int</span> options)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   All of these system calls are used to wait <span class="keyword">for</span> state changes in a</span><br><span class="line">   child of the calling process, and obtain information about the</span><br><span class="line">   child whose state has changed.  A state change is considered to</span><br><span class="line">   be: the child terminated; the child was stopped by a signal; or</span><br><span class="line">   the child was resumed by a signal.  In the <span class="keyword">case</span> of a terminated</span><br><span class="line">   child, performing a wait allows the system to release the</span><br><span class="line">   resources associated with the child; <span class="keyword">if</span> a wait is not performed,</span><br><span class="line">   then the terminated child remains in a <span class="string">&quot;zombie&quot;</span> state (see NOTES</span><br><span class="line">   below).</span><br></pre></td></tr></table></figure>
</blockquote>
<p>系统调用 <code>wait()</code> 用于调用进程的子进程的状态改变时，获取它的状态：子进程终止、子进程通过信号被暂停、子进程通过信号被恢复。“子进程终止” 状态下，允许系统释放分配给子进程的资源，以防止子进程成为僵尸进程。</p>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> wstatus;</span><br><span class="line"><span class="type">pid_t</span> wc = wait(&amp;wstatus);  <span class="comment">// wait code</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;parent process (PID: %d), wc: %d, wstatus: %d, wait if normal exited: %s\n&quot;</span>, \</span><br><span class="line">        getpid(), wc, wstatus, WIFEXITED(wstatus) ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br></pre></td></tr></table></figure>
<p><em>pipeUN.c</em> 程序还采取了另一种预防措施。当父进程完成等待时，父进程将通过调用常规退出函数来终止。<strong>相比之下，子进程通过调用 <code>_exit</code> 变体来终止，这会快速跟踪终止通知。实际上，子进程会告诉系统：「尽快」通知父进程，自己已经终止</strong>。</p>
<p>2）如果多个进程同时向管道中写入，会不会出现并发（交错）写入？</p>
<p>POSIX 标准确保只要写入不超过 <code>PIPE_BUF</code> 字节（4096 bytes on Linux），写入就不会交错。正如本节一开始说的：基于 channel 的 IPC 是并发安全的。</p>
<h2 id="Named-pipes">Named pipes</h2>
<p>匿名管道没有后备文件：系统维护一个内存缓冲区（in-memory buffer），用于将字节从写者传输到读者。一旦写者和读者终止，缓冲区就会被回收，匿名管道就会消失。相比之下，命名管道有一个后备文件和一个独特的 API。</p>
<p>管道的基本特性是先进先出（FIFO），写入管道的数据会按照顺序被读取。<strong>当写者进程往管道中写入数据时，如果没有读者进程在等待读取数据，写者进程可能会被阻塞，直到有读者进程读取了数据。相反，如果读者进程试图从空管道中读取数据，读者进程也会被阻塞，直到有写者进程向管道中写入数据</strong>。</p>
<h3 id="在交互式命令行 -v2">在交互式命令行</h3>
<p>让我们看另一个命令行示例来了解命名管道的要点。打开两个终端，两者的工作目录应该相同。</p>
<p>终端 1：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">mkfifo</span> tester <span class="comment">## creates a backing file with FIFO named pipes</span></span><br><span class="line">% <span class="built_in">cat</span> tester <span class="comment">## type the pipe&#x27;s contents to stdout</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一开始，终端中不应出现任何内容，因为尚未将任何内容写入命名管道。</p>
<p>终端 2：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">cat</span> &gt; tester <span class="comment">## redirect keyboard input to the pipe</span></span><br><span class="line">hello, world! <span class="comment">## then hit Return key</span></span><br><span class="line"><span class="built_in">bye</span>, <span class="built_in">bye</span> <span class="comment">## ditto</span></span><br><span class="line">&lt;Control-C&gt; <span class="comment">## terminate session with a Control-C</span></span><br></pre></td></tr></table></figure>
<p>在这个终端中输入的任何内容都会在另一个终端中得到回显。输入 Ctrl+C 后，两个终端都会返回常规命令行提示符：管道已关闭。</p>
<p>使用 <code>unlink tester</code> 可以删除并清理已创建的命名管道的文件。</p>
<h3 id="在程序内部 -v2">在程序内部</h3>
<p>Linux 有一个名为 <code>mkfifo</code> 的库函数，它在程序中创建一个命名管道。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   <span class="title function_">mkfifo</span><span class="params">()</span> makes a FIFO special file with name pathname.  mode</span><br><span class="line">   specifies the FIFO&#x27;s permissions.  It is modified by the</span><br><span class="line">   process&#x27;s umask in the usual way: the permissions of the created</span><br><span class="line">   file <span class="title function_">are</span> <span class="params">(mode &amp; ~umask)</span>.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>下面的示例给出两个进程：一个写入数据到命名管道的进程，一个从该管道读取数据并进行业务处理的进程。</p>
<p>Example 2. the fifoWriter program <em>fifoWriter.c</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxLoops 12000 <span class="comment">/* outer loop */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ChunkSize 16   <span class="comment">/* how many written at a time */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IntsPerChunk 4 <span class="comment">/* four 4-byte ints per chunk */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxZs 250      <span class="comment">/* max microseconds to sleep */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pipeName = <span class="string">&quot;./fifoChannel&quot;</span>;</span><br><span class="line">    mkfifo(pipeName, <span class="number">0666</span>);                      <span class="comment">/* read/write for user/group/others */</span></span><br><span class="line">    <span class="type">int</span> fd = open(pipeName, O_CREAT | O_WRONLY); <span class="comment">/* open as write-only */</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/** error **/</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FIFO named pipe has created and opend\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MaxLoops; i++) &#123; <span class="comment">/* write MaxWrites times */</span></span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ChunkSize; j++) &#123; <span class="comment">/* each time, write ChunkSize bytes */</span></span><br><span class="line">            <span class="type">int</span> k;</span><br><span class="line">            <span class="type">int</span> chunk[IntsPerChunk];</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; IntsPerChunk; k++) &#123;</span><br><span class="line">                chunk[k] = rand();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;debug, verify if the writer process is blocked\n&quot;</span>);</span><br><span class="line">            write(fd, chunk, <span class="keyword">sizeof</span>(chunk));</span><br><span class="line">        &#125;</span><br><span class="line">        usleep((rand() % MaxZs) + <span class="number">1</span>); <span class="comment">/* pause a bit for realism */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);        <span class="comment">/* close pipe: generates an end-of-file */</span></span><br><span class="line">    unlink(pipeName); <span class="comment">/* unlink from the implementing file */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%i ints sent to the pipe.\n&quot;</span>, MaxLoops * ChunkSize * IntsPerChunk);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>mkfifo</code> 创建了一个指定名称的后备文件，并指定了文件权限。然后使用熟悉的 <code>open</code> 函数调用打开命名管道，该函数返回一个文件描述符。同时，为了更加真实，<em>fifoWriter.c</em> 不会一次写入所有数据，而是写入一个块，休眠随机微秒数。最后，关闭命名管道后，<em>fifoWriter.c</em> 还会取消文件链接。</p>
<blockquote>
<p>当仅运行了这个进程后，你会发现不会有任何信息被打印到屏幕上，这是因为：如果没有读者进程在等待读取数据，写者进程可能会被阻塞，直到有读者进程读取了数据。</p>
</blockquote>
<p>Example 3. the fifoReader program <em>fifoReader.c</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* not pretty, but gets the job done efficiently */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">is_prime</span><span class="params">(<span class="type">unsigned</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == (n % <span class="number">2</span>) || <span class="number">0</span> == (n % <span class="number">3</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">5</span>; (i * i) &lt;= n; i += <span class="number">6</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == (n % i) || <span class="number">0</span> == (n % (i + <span class="number">2</span>)))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/* found a prime! */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* file = <span class="string">&quot;./fifoChannel&quot;</span>;</span><br><span class="line">    <span class="type">int</span> fd = open(file, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* no point in continuing */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count = <span class="number">0</span>, total = <span class="number">0</span>, primes_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> next;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">ssize_t</span> count = read(fd, &amp;next, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == count) &#123;</span><br><span class="line">            <span class="keyword">break</span>;                         <span class="comment">/* end of stream */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="keyword">sizeof</span>(<span class="type">int</span>)) &#123; <span class="comment">/* read a 4-byte int value */</span></span><br><span class="line">            total++;</span><br><span class="line">            <span class="keyword">if</span> (is_prime(next)) &#123;</span><br><span class="line">                primes_count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);    <span class="comment">/* close pipe from read end */</span></span><br><span class="line">    unlink(file); <span class="comment">/* unlink from the underlying file */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received ints: %u, primes: %u\n&quot;</span>, total, primes_count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 <em>fifoWriter.c</em> 创建命名管道，所以 <em>fifoReader.c</em> 仅需要以只读方式打开后备文件，来访问管道即可。</p>
<p><code>read</code> 调用返回 0 表示结束流（end-of-stream）。在这种情况下，<em>fifoReader.c</em> 会跳出循环，关闭命名管道，并在终止之前取消链接后备文件。</p>
<h3 id="输出 -v2">输出</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">% ./fifoWriter</span><br><span class="line">FIFO named pipe has created and opend  <span class="comment"># run ./fifoReader and print it out</span></span><br><span class="line">debug, verify <span class="keyword">if</span> the writer process is blocked</span><br><span class="line">768000 ints sent to the pipe.</span><br><span class="line"></span><br><span class="line">% ./fifoReader</span><br><span class="line">Received ints: 768000, primes: 37682</span><br></pre></td></tr></table></figure>
<h3 id="特点 -v3">特点</h3>
<p>命名管道是一种高度可靠且高效的 IPC 机制，因此被广泛使用。</p>
<h1 id="Message-queue">Message queue</h1>
<p>管道具有严格的 FIFO 行为：写入的第一个字节是读取的第一个字节，写入的第二个字节是读取的第二个字节，依此类推。<strong>消息队列可以以相同的方式运行，但足够灵活，可以不按 FIFO 顺序检索字节块（byte chunks）</strong>。</p>
<p>顾名思义，消息队列是一个消息序列，每个消息都有两部分：</p>
<ul>
<li>负载（payload），它是一个字节数组；</li>
<li>类型（type），以无符号长整型形式给出；通过类型对消息进行分类，以便灵活检索（<em>通过类型达到不按 FIFO 顺序检索字节块的效果</em>）。</li>
</ul>
<p>考虑以下消息队列，其中每条消息都标有整数类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">          +-+    +-+    +-+    +-+</span><br><span class="line">sender---&gt;|3|---&gt;|2|---&gt;|2|---&gt;|1|---&gt;receiver </span><br><span class="line">          +-+    +-+    +-+    +-+</span><br></pre></td></tr></table></figure>
<p>如果采用严格的 FIFO 行为，则消息将以 1-2-2-3 的顺序接收。然而，消息队列允许其他检索顺序。例如，接收方可以按 3-2-1-2 的顺序检索消息。</p>
<p>Example 4. The header file <em>queue.h</em>, use it in <em>sender.c</em> and <em>receiver.c</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ProjectId 123</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PathName <span class="string">&quot;queue.h&quot;</span> <span class="comment">/* any existing, accessible file would do */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MsgLen 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MsgCount 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> type;                <span class="comment">/* must be of type long */</span></span><br><span class="line">    <span class="type">char</span> payload[MsgLen + <span class="number">1</span>]; <span class="comment">/* bytes in the message */</span></span><br><span class="line">&#125; queuedMessage;</span><br></pre></td></tr></table></figure>
<p><code>ProjectId</code> 可以是任何正整数值，<code>PathName</code> 必须是现有的、可访问的文件。这两个参数用于使用 <code>ftok</code> 函数调用生成 System V IPC key。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">key_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span>;</span><br><span class="line">DESCRIPTION</span><br><span class="line">   The <span class="title function_">ftok</span><span class="params">()</span> function uses the identity of the file named by the</span><br><span class="line">   given <span class="title function_">pathname</span> <span class="params">(which must refer to an existing, accessible file)</span></span><br><span class="line">   and the least significant 8 bits of <span class="title function_">proj_id</span> <span class="params">(which must be</span></span><br><span class="line"><span class="params">   nonzero)</span> to generate a <span class="type">key_t</span> type System V IPC key, suitable <span class="keyword">for</span></span><br><span class="line">   use with <span class="title function_">msgget</span><span class="params">(<span class="number">2</span>)</span>, <span class="title function_">semget</span><span class="params">(<span class="number">2</span>)</span>, or <span class="title function_">shmget</span><span class="params">(<span class="number">2</span>)</span>.</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="sender">sender</h2>
<p>Example 5. the message sender program <em>sender.c</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;queue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">report_and_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span> &#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>); <span class="comment">/* EXIT_FAILURE */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(PathName, ProjectId);</span><br><span class="line">    <span class="keyword">if</span> (key &lt; <span class="number">0</span>)</span><br><span class="line">        report_and_exit(<span class="string">&quot;couldn&#x27;t get key...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> qid = msgget(key, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (qid &lt; <span class="number">0</span>)</span><br><span class="line">        report_and_exit(<span class="string">&quot;couldn&#x27;t get queue id...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* payloads[] = &#123;<span class="string">&quot;msg1&quot;</span>, <span class="string">&quot;msg2&quot;</span>, <span class="string">&quot;msg3&quot;</span>, <span class="string">&quot;msg4&quot;</span>, <span class="string">&quot;msg5&quot;</span>, <span class="string">&quot;msg6&quot;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> types[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>&#125;; <span class="comment">/* each must be &gt; 0 */</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MsgCount; i++) &#123;</span><br><span class="line">        <span class="comment">/* build the message */</span></span><br><span class="line">        queuedMessage msg;</span><br><span class="line">        msg.type = types[i];</span><br><span class="line">        <span class="built_in">strcpy</span>(msg.payload, payloads[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* send the message */</span></span><br><span class="line">        msgsnd(qid, &amp;msg, MsgLen + <span class="number">1</span>, IPC_NOWAIT); <span class="comment">/* don&#x27;t block */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s sent as type %i\n&quot;</span>, msg.payload, (<span class="type">int</span>)msg.type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>msgget()</code> 系统调用</strong>：</p>
<ul>
<li>描述：<code>msgget()</code> 系统调用返回与 key 参数值 <strong> 关联的</strong> System V 消息队列标识符。</li>
<li>返回值：成功时，返回消息队列标识符（非负整数）。失败时，返回 -1，并设置 errno 来指示错误。</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   The <span class="title function_">msgget</span><span class="params">()</span> system call returns the System V message <span class="built_in">queue</span></span><br><span class="line">   identifier associated with the value of the key argument.  It may</span><br><span class="line">   be used either to obtain the identifier of a previously created</span><br><span class="line">   message <span class="title function_">queue</span> <span class="params">(when msgflg is zero and key does not have the</span></span><br><span class="line"><span class="params">   value IPC_PRIVATE)</span>, or to create a new <span class="built_in">set</span>.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在 <code>msgget</code> 系统调用中，<code>0666 | IPC_CREAT</code> 表示：</p>
<ul>
<li><code>0666</code>：八进制权限位，指定了消息队列的权限，表示该消息队列将被所有用户读写访问。</li>
<li><code>IPC_CREAT</code>：这是一个标志位，指示如果消息队列不存在，则创建一个新的消息队列。<strong>如果消息队列已经存在，它将被忽略</strong>。</li>
</ul>
<p><strong><code>msgsnd()</code> 系统调用</strong>：</p>
<ul>
<li>描述：<code>msgsnd()</code> 函数应将消息发送到与 msqid 指定的消息队列标识符 <strong> 关联的 </strong> 队列。</li>
<li>返回值：成功完成后，将返回 0；否则，不发送任何消息，返回 -1，并设置 errno 来指示错误。</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   The <span class="title function_">msgsnd</span><span class="params">()</span> function shall send a message to the <span class="built_in">queue</span></span><br><span class="line">   associated with the message <span class="built_in">queue</span> identifier specified by msqid.</span><br><span class="line"></span><br><span class="line">   The application shall ensure that the argument msgp points to a</span><br><span class="line">   user-defined buffer that contains first a field of type <span class="type">long</span></span><br><span class="line">   specifying the type of the message, and then a data portion that</span><br><span class="line">   holds the data bytes of the message. The structure below is an</span><br><span class="line">   example of what this user-defined buffer might look like:</span><br><span class="line"></span><br><span class="line">       <span class="keyword">struct</span> mymsg &#123;</span><br><span class="line">           <span class="type">long</span>   mtype;       <span class="comment">/* Message type. */</span></span><br><span class="line">           <span class="type">char</span>   mtext[<span class="number">1</span>];    <span class="comment">/* Message text. */</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   The structure member mtype is a non-zero positive type <span class="type">long</span> that</span><br><span class="line">   can be used by the receiving process <span class="keyword">for</span> message selection.</span><br><span class="line"></span><br><span class="line">   The structure member mtext is any text of length msgsz bytes. The</span><br><span class="line">   argument msgsz can range from <span class="number">0</span> to a system-imposed maximum.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在本例中，发送方按照 1-1-2-2-3-3 的顺序发送消息，但接收方随后按照 3-1-2-1-3-2 的顺序检索消息，这表明 <strong> 消息队列没有绑定严格的 FIFO 行为</strong>。</p>
<h2 id="receiver">receiver</h2>
<p>Example 6. the message receiver program <em>receiver.c</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;queue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">report_and_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span> &#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>); <span class="comment">/* EXIT_FAILURE */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(PathName, ProjectId); <span class="comment">/* key to identify the queue */</span></span><br><span class="line">    <span class="keyword">if</span> (key &lt; <span class="number">0</span>)</span><br><span class="line">        report_and_exit(<span class="string">&quot;key not gotten...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> qid = msgget(key, <span class="number">0666</span> | IPC_CREAT); <span class="comment">/* access but not create if created already */</span></span><br><span class="line">    <span class="keyword">if</span> (qid &lt; <span class="number">0</span>)</span><br><span class="line">        report_and_exit(<span class="string">&quot;no access to queue...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> types[] = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>&#125;; <span class="comment">/* different than in sender */</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MsgCount; i++) &#123;</span><br><span class="line">        queuedMessage msg; <span class="comment">/* defined in queue.h */</span></span><br><span class="line">        <span class="keyword">if</span> (msgrcv(qid, &amp;msg, MsgLen + <span class="number">1</span>, types[i], MSG_NOERROR | IPC_NOWAIT) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;msgrcv trouble...&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s received as type %i\n&quot;</span>, msg.payload, (<span class="type">int</span>)msg.type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** remove the queue **/</span></span><br><span class="line">    <span class="keyword">if</span> (msgctl(qid, IPC_RMID, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) <span class="comment">/* NULL = &#x27;no flags&#x27; */</span></span><br><span class="line">        report_and_exit(<span class="string">&quot;trouble removing queue...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 <em>sender.c</em> 已经创建了消息队列，所以在 <em>receiver.c</em> 的 <code>msgget</code> 系统调用中，<code>IPC_CREAT</code> 标志位将被忽略。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">ssize_t</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp,</span></span><br><span class="line"><span class="params">       <span class="type">int</span> msgflg)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   The <span class="title function_">msgrcv</span><span class="params">()</span> function shall read a message from the <span class="built_in">queue</span></span><br><span class="line">   associated with the message <span class="built_in">queue</span> identifier specified by msqid</span><br><span class="line">   and place it in the user-defined buffer pointed to by msgp.</span><br><span class="line"></span><br><span class="line">   The received message shall be truncated to msgsz bytes <span class="keyword">if</span> it is</span><br><span class="line">   larger than msgsz <span class="title function_">and</span> <span class="params">(msgflg &amp; MSG_NOERROR)</span> is non-zero.  The</span><br><span class="line">   truncated part of the message shall be lost and no indication of</span><br><span class="line">   the truncation shall be given to the calling process.</span><br><span class="line">RETURN VALUE</span><br><span class="line">   Upon successful completion, <span class="title function_">msgrcv</span><span class="params">()</span> shall <span class="keyword">return</span> a value equal</span><br><span class="line">   to the number of bytes actually placed into the buffer mtext.</span><br><span class="line">   Otherwise, no message shall be received, <span class="title function_">msgrcv</span><span class="params">()</span> shall <span class="keyword">return</span></span><br><span class="line">   -1, and errno shall be <span class="built_in">set</span> to indicate the error.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意：<strong>当接收进程通过调用 <code>msgctl</code> 显式删除队列后，队列才会消失</strong>；否则，队列仍然存在（即使写入队列进程已经退出）。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">int</span> <span class="title function_">msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   <span class="title function_">msgctl</span><span class="params">()</span> performs the control operation specified by cmd on the</span><br><span class="line">   System V message <span class="built_in">queue</span> with identifier msqid.</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="输出 -v3">输出</h2>
<p>上述代码的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">% ./sender</span><br><span class="line">msg1 sent as type 1</span><br><span class="line">msg2 sent as type 1</span><br><span class="line">msg3 sent as type 2</span><br><span class="line">msg4 sent as type 2</span><br><span class="line">msg5 sent as type 3</span><br><span class="line">msg6 sent as type 3</span><br><span class="line">%</span><br><span class="line"></span><br><span class="line">% ./receiver</span><br><span class="line">msg5 received as type 3</span><br><span class="line">msg1 received as type 1</span><br><span class="line">msg3 received as type 2</span><br><span class="line">msg2 received as type 1</span><br><span class="line">msg6 received as type 3</span><br><span class="line">msg4 received as type 2</span><br><span class="line">%</span><br></pre></td></tr></table></figure>
<p>如果将 <em>receiver.c</em> 代码中的 <code>msgctl</code> 函数调用注释掉，再把 for 循环改成 <code>i &lt; MsgCount/2</code>，则接收方有以下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">% ./receiver</span><br><span class="line">msg5 received as type 3</span><br><span class="line">msg1 received as type 1</span><br><span class="line">msg3 received as type 2</span><br><span class="line">% ./receiver</span><br><span class="line">msg6 received as type 3 # 没接收完，且没显示删除消息队列 -&gt; 还能继续接收</span><br><span class="line">msg2 received as type 1</span><br><span class="line">msg4 received as type 2</span><br><span class="line">% ./receiver</span><br><span class="line">msgrcv trouble... # 消息队列中没有消息了（如果这一步前再执行一次./sender，则这一步还能继续接收到消息）</span><br><span class="line"> received as type 0</span><br><span class="line">msgrcv trouble...</span><br><span class="line"> received as type 0</span><br><span class="line">msgrcv trouble...</span><br><span class="line"> received as type 0</span><br><span class="line">%</span><br></pre></td></tr></table></figure>
<h2 id="特点 -v4">特点</h2>
<p>管道和消息队列的 API 本质上是单向的：一个进程写入，另一个进程读取。虽然也有双向管道的实现，但作者 Marty Kalin 认为 IPC 机制越简单越好。作者认为消息队列仍然是 IPC 工具箱中有用的工具，尽管它们的流行度下降了。</p>
<h1 id="Sockets">Sockets</h1>
<p>正如 pipes 有两种类型（命名和匿名）一样，socket 也是如此。</p>
<ul>
<li>IPC sockets（又名 Unix domain sockets）可以为 <strong> 同一物理设备（主机）上的进程 </strong> 启用基于通道的通信。</li>
<li>Network sockets 可以在 <strong> 不同主机上运行的进程 </strong> 启用基于通道的通信，从而发挥网络作用。</li>
</ul>
<p><strong>Network sockets 需要底层协议的支持</strong>，例如 tcp (transmission control protocol) or the lower-level udp (user datagram protocol)。相比之下，IPC sockets 依赖本地系统内核来支持通信；实际上，<strong>IPC sockets 使用本地文件作为 socket address 进行通信</strong>。尽管存在这些实现差异，但 IPC sockets 和 Network sockets 的 APIs 在本质上是相同的。</p>
<p>配置为流的套接字是双向的（bidirectional），并且控制遵循 client/server 模式：客户端通过尝试连接到服务器来发起对话，服务器尝试接受连接。如果一切正常，来自客户端的请求和来自服务器的响应可以流经通道，直到两端关闭，从而中断连接。</p>
<p>Example 0. The header file <em>sock.h</em>, use it in <em>server.c</em> and <em>client.c</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PortNumber 9876</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxConnects 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BuffSize 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ConversationLen 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Host <span class="string">&quot;127.0.0.1&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>下面的示例涵盖了 Network sockets，但服务器和客户端程序可以在同一台计算机上运行——服务器使用网络地址 localhost (127.0.0.1)，即本地主机地址。</p>
<h2 id="server">server</h2>
<p>Example 1. The socket server <em>server.c</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">report</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> <span class="built_in">terminate</span>)</span> &#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">terminate</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>); <span class="comment">/* failure */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET,     <span class="comment">/* network versus AF_LOCAL */</span></span><br><span class="line">                    SOCK_STREAM, <span class="comment">/* reliable, bidirectional: TCP */</span></span><br><span class="line">                    <span class="number">0</span>);          <span class="comment">/* system picks underlying protocol */</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        report(<span class="string">&quot;socket&quot;</span>, <span class="number">1</span>); <span class="comment">/* terminate */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* bind the server&#x27;s local address in memory */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;saddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(saddr));          <span class="comment">/* clear the bytes */</span></span><br><span class="line">    saddr.sin_family = AF_INET;                <span class="comment">/* versus AF_LOCAL */</span></span><br><span class="line">    saddr.sin_addr.s_addr = htonl(INADDR_ANY); <span class="comment">/* host-to-network endian */</span></span><br><span class="line">    saddr.sin_port = htons(PortNumber);        <span class="comment">/* for listening */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(fd, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="keyword">sizeof</span>(saddr)) &lt; <span class="number">0</span>)</span><br><span class="line">        report(<span class="string">&quot;bind&quot;</span>, <span class="number">1</span>); <span class="comment">/* terminate */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* listen to the socket */</span></span><br><span class="line">    <span class="keyword">if</span> (listen(fd, MaxConnects) &lt; <span class="number">0</span>) <span class="comment">/* listen for clients, up to MaxConnects */</span></span><br><span class="line">        report(<span class="string">&quot;listen&quot;</span>, <span class="number">1</span>);         <span class="comment">/* terminate */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Listening on port %i for clients...\n&quot;</span>, PortNumber);</span><br><span class="line">    <span class="comment">/* a server traditionally listens indefinitely */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">caddr</span>;</span> <span class="comment">/* client address */</span></span><br><span class="line">        <span class="type">int</span> len = <span class="keyword">sizeof</span>(caddr);  <span class="comment">/* address length could change */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> client_fd = accept(fd, (<span class="keyword">struct</span> sockaddr*)&amp;caddr, &amp;len); <span class="comment">/* accept blocks */</span></span><br><span class="line">        <span class="keyword">if</span> (client_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            report(<span class="string">&quot;accept&quot;</span>, <span class="number">0</span>); <span class="comment">/* don&#x27;t terminated, though there&#x27;s a problem */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* read from client */</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ConversationLen; i++) &#123;</span><br><span class="line">            <span class="type">char</span> buffer[BuffSize + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">memset</span>(buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">            <span class="type">int</span> count = read(client_fd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(buffer);</span><br><span class="line">                write(client_fd, buffer, <span class="keyword">sizeof</span>(buffer)); <span class="comment">/* echo as confirmation */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close(client_fd); <span class="comment">/* break connection */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的服务器程序执行经典的四步，<strong>为客户端请求做好准备，然后接受各个请求</strong>。每个步骤（也是调用顺序）：</p>
<ol>
<li><code>socket()</code>：获取套接字连接的文件描述符；</li>
<li><code>bind()</code>：将套接字绑定到服务器主机上的某个地址；</li>
<li><code>listen()</code>：监听客户端的请求；</li>
<li><code>accept()</code>：接受特定客户端的请求。</li>
</ol>
<p><strong>socket() 系统调用</strong>：</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   <span class="title function_">socket</span><span class="params">()</span> creates an endpoint <span class="keyword">for</span> communication and returns a file</span><br><span class="line">   descriptor that refers to that endpoint.  The file descriptor</span><br><span class="line">   returned by a successful call will be the lowest-numbered file</span><br><span class="line">   descriptor not currently open <span class="keyword">for</span> the process.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">   On success, a file descriptor <span class="keyword">for</span> the new socket is returned.  On</span><br><span class="line">   error, -1 is returned, and errno is <span class="built_in">set</span> to indicate the error.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>第一个参数指定网络套接字 <code>AF_INET</code> 而不是 IPC 套接字 <code>AF_LOCAL</code>。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AF_UNIX/AF_LOCAL    Local communication</span><br><span class="line">AF_INET             IPv4 Internet protocols</span><br></pre></td></tr></table></figure>
</blockquote>
<p>第二个参数有多个选项，但 <code>SOCK_STREAM</code> 和 <code>SOCK_DGRAM</code>（数据报）可能是最常用的。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SOCK_STREAM</span><br><span class="line">   Provides sequenced, reliable, two-way, connection-based</span><br><span class="line">   byte streams.  An out-of-band data transmission mechanism</span><br><span class="line">   may be supported.</span><br><span class="line"></span><br><span class="line">SOCK_DGRAM</span><br><span class="line">   Supports datagrams (connectionless, unreliable messages of</span><br><span class="line">   a fixed maximum length).</span><br></pre></td></tr></table></figure>
</blockquote>
<p>第三个参数指定协议。对于这里使用的基于流的套接字——参数 0 代表 TCP。</p>
<p>返回值：因为成功调用套接字会返回熟悉的文件描述符，所以 <strong> 套接字的写入和读取语法与本地文件等相同</strong>。</p>
<p><strong>bind() 系统调用</strong>：</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   When a socket is created with <span class="title function_">socket</span><span class="params">(<span class="number">2</span>)</span>, it exists in a name</span><br><span class="line">   <span class="title function_">space</span> <span class="params">(address family)</span> but has no address assigned to it.  <span class="title function_">bind</span><span class="params">()</span></span><br><span class="line">   assigns the address specified by addr to the socket referred to</span><br><span class="line">   by the file descriptor sockfd.  addrlen specifies the size, in</span><br><span class="line">   bytes, of the address structure pointed to by addr.</span><br><span class="line">   Traditionally, this operation is called “assigning a name to a</span><br><span class="line">   socket”.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">   On success, zero is returned.  On error, -1 is returned, and</span><br><span class="line">   errno is <span class="built_in">set</span> to indicate the error.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>功能：<code>bind()</code> 系统调用将 sockfd 套接字 <strong> 绑定到分配的内存地址 addr 上</strong>。</p>
<p><strong>动态分配一个端口号</strong>：</p>
<p>对于网络套接字，如果套接字地址结构中的端口号（如 sin_port of struct sockaddr_in）被指定为 0，则在 <code>bind()</code> 系统调用时，OS 会自动为套接字分配一个可用的临时端口号（如果 OS 定义的临时端口范围内的所有端口号丢已经被其他套接字使用，则会发生“EADDRINUSE 地址使用错误”）。</p>
<p><strong>动态分配端口后，如何获取这个端口值</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 getsockname 系统调用，获取 fd 绑定到的当前地址（位于 addr 指向的缓冲区中）</span></span><br><span class="line">getsockname(fd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, &amp;<span class="keyword">sizeof</span>(saddr));</span><br><span class="line">port = ntohs(saddr.sin_port); <span class="comment">// 从当前地址中取出指定（或动态分配）的端口号</span></span><br></pre></td></tr></table></figure>
<p><code>getsockname()</code> 系统调用：</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">int</span> <span class="title function_">getsockname</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *<span class="keyword">restrict</span> addr,</span></span><br><span class="line"><span class="params">                   <span class="type">socklen_t</span> *<span class="keyword">restrict</span> addrlen)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   <span class="title function_">getsockname</span><span class="params">()</span> returns the current address to which the socket</span><br><span class="line">   sockfd is bound, in the buffer pointed to by addr.  The addrlen</span><br><span class="line">   argument should be initialized to indicate the amount of <span class="title function_">space</span></span><br><span class="line">   <span class="params">(in bytes)</span> pointed to by addr.  On <span class="keyword">return</span> it contains the actual</span><br><span class="line">   size of the socket address.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">   On success, zero is returned.  On error, -1 is returned, and</span><br><span class="line">   errno is <span class="built_in">set</span> to indicate the error.</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>在 <em>server.c</em> 中，<code>bind()</code> 的第二个参数为什么要强转成 <code>struct sockaddr</code> 类型呢</strong>？</p>
<p><code>addr</code> 是一个指向 <code>sockaddr</code> 结构体的指针，用于指定要绑定到 <strong> 套接字的地址信息。这个结构体的具体类型取决于套接字的地址族</strong>（Address Family），通常是 <code>sockaddr_in</code> 结构体（用于 IPv4 地址族）或 <code>sockaddr_un</code> 结构体（用于 UNIX 本地通信域）。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Describes a socket address</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">   <span class="type">sa_family_t</span>     sa_family;      <span class="comment">/* Address family */</span></span><br><span class="line">   <span class="type">char</span>            sa_data[];      <span class="comment">/* Socket address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Internet domain sockets</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">   <span class="type">sa_family_t</span>     sin_family;     <span class="comment">/* AF_INET for Internet domain sockets */</span></span><br><span class="line">   <span class="type">in_port_t</span>       sin_port;       <span class="comment">/* Port number */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>  <span class="title">sin_addr</span>;</span>       <span class="comment">/* IPv4 address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">   <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UNIX domain sockets</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">   <span class="type">sa_family_t</span>     sun_family;     <span class="comment">/* AF_LOCAL(AF_UNIX) for UNIX domain sockets */</span></span><br><span class="line">   <span class="type">char</span>            sun_path[];     <span class="comment">/* Socket pathname */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>listen() 系统调用</strong>：</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   <span class="title function_">listen</span><span class="params">()</span> marks the socket referred to by sockfd as a passive</span><br><span class="line">   socket, that is, as a socket that will be used to accept incoming</span><br><span class="line">   connection requests using <span class="title function_">accept</span><span class="params">(<span class="number">2</span>)</span>.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>作用：<code>listen()</code> 函数是用于使套接字处于监听状态，以便接受来自客户端的连接请求。当调用 <code>listen()</code> 函数时，套接字会由主动套接字（active socket）变为被动套接字（passive socket），从而使其 <strong> 处于监听状态 </strong>。在这个状态下，套接字将开始接受连接请求，但并<strong> 不立即处理这些连接请求 </strong>，而是将它们<strong> 放入内核中的连接队列中等待处理</strong>。</p>
<p>第二个参数 backlog 指定了 OS 在内核中维护的连接队列的最大长度。这个参数决定了同时等待被服务器接受的连接请求的数量。</p>
<p><strong>accept() 系统调用</strong>：</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *_Nullable <span class="keyword">restrict</span> addr,</span></span><br><span class="line"><span class="params">               <span class="type">socklen_t</span> *_Nullable <span class="keyword">restrict</span> addrlen)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   The <span class="title function_">accept</span><span class="params">()</span> system call is used with connection-based socket</span><br><span class="line">   <span class="title function_">types</span> <span class="params">(SOCK_STREAM, SOCK_SEQPACKET)</span>.  It extracts the first</span><br><span class="line">   connection request on the <span class="built_in">queue</span> of pending connections <span class="keyword">for</span> the</span><br><span class="line">   listening socket, sockfd, creates a new connected socket, and</span><br><span class="line">   returns a new file descriptor referring to that socket.  The</span><br><span class="line">   newly created socket is not in the listening state.  The original</span><br><span class="line">   socket sockfd is unaffected by this call.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">   On success, these system calls <span class="keyword">return</span> a file descriptor <span class="keyword">for</span> the</span><br><span class="line">   accepted <span class="title function_">socket</span> <span class="params">(a nonnegative integer)</span>.  On error, -1 is</span><br><span class="line">   returned, errno is <span class="built_in">set</span> to indicate the error, and addrlen is left</span><br><span class="line">   unchanged.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>作用：<code>accept()</code> 函数用于在服务器端接受客户端连接请求。</p>
<ul>
<li>该调用默认为阻塞等待：服务器不执行任何操作，直到客户端尝试连接然后继续。</li>
<li>调用成功时，<strong>返回一个新的套接字文件描述符（a read/write socket）</strong>，用于与客户端进行通信：<strong>服务器使用 read/write socket 读取来自客户端的请求并写回响应</strong>。</li>
</ul>
<p>参数 <code>sockfd</code> 仅用于接受客户端连接。</p>
<p>参数 <code>addr</code> 和 <code>addrlen</code> 用于获取客户端的地址信息。</p>
<ul>
<li>在函数调用之前，需要将一个足够大的 <code>sockaddr</code> 结构体传递给 <code>addr</code> 参数，并将其长度传递给 <code>addrlen</code> 参数。<strong>当 <code>accept()</code> 函数返回时，<code>addr</code> 指向的结构体将被填充为客户端的地址信息，而 <code>addrlen</code> 则会被更新为 <code>addr</code> 结构体的实际长度</strong>。</li>
</ul>
<h2 id="client">client</h2>
<p>Example 2. The socket client <em>client.c</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* books[] = &#123;<span class="string">&quot;War and Peace&quot;</span>, <span class="string">&quot;Pride and Prejudice&quot;</span>, <span class="string">&quot;The Sound and the Fury&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">report</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> <span class="built_in">terminate</span>)</span> &#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">terminate</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>); <span class="comment">/* failure */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/* fd for the socket */</span></span><br><span class="line">    <span class="type">int</span> sockfd = socket(AF_INET,     <span class="comment">/* versus AF_LOCAL */</span></span><br><span class="line">                        SOCK_STREAM, <span class="comment">/* reliable, bidirectional */</span></span><br><span class="line">                        <span class="number">0</span>);          <span class="comment">/* system picks protocol (TCP) */</span></span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>)</span><br><span class="line">        report(<span class="string">&quot;socket&quot;</span>, <span class="number">1</span>); <span class="comment">/* terminate */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* connect to the server: configure server&#x27;s address 1st */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;saddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = inet_addr(Host);</span><br><span class="line">    saddr.sin_port = htons(PortNumber); <span class="comment">/* port number in big-endian */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connect(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="keyword">sizeof</span>(saddr)) &lt; <span class="number">0</span>)</span><br><span class="line">        report(<span class="string">&quot;connect&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write some stuff and read the echoes. */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Connect to server, about to write some stuff...&quot;</span>);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ConversationLen; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (write(sockfd, books[i], <span class="built_in">strlen</span>(books[i])) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* get confirmation echoed from server and print */</span></span><br><span class="line">            <span class="type">char</span> buffer[BuffSize + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">memset</span>(buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">            <span class="keyword">if</span> (read(sockfd, buffer, <span class="keyword">sizeof</span>(buffer)) &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">puts</span>(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Client done, about to exit...&quot;</span>);</span><br><span class="line">    close(sockfd); <span class="comment">/* close the connection */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端程序的代码与服务器的类似。两者之间的主要区别在于客户端既不 listens 也不 accepts，而是 connects。</p>
<p><code>connect()</code> 调用可能会因多种原因而失败，例如：</p>
<ul>
<li>客户端的服务器地址错误。</li>
<li>已经有太多客户端连接到服务器。</li>
</ul>
<p>在这个示例中，如果连接操作成功，客户端将写入请求，然后在 for 循环中读取服务器发回来的回显响应。会话结束后，服务器和客户端都 close the read/write socket（那个 <code>accept()</code> 调用返回的新的套接字文件描述符），尽管任何一方的关闭操作都足以关闭连接。此后客户端退出，但如前所述，服务器仍保持开放状态。</p>
<p><strong>connect() 系统调用</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">    The <span class="title function_">connect</span><span class="params">()</span> system call connects the socket referred to by the</span><br><span class="line">    file descriptor sockfd to the address specified by addr.  The</span><br><span class="line">    addrlen argument specifies the size of addr.  The format of the</span><br><span class="line">    address in addr is determined by the address space of the socket</span><br><span class="line">    sockfd; see <span class="title function_">socket</span><span class="params">(<span class="number">2</span>)</span> <span class="keyword">for</span> further details.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">    If the connection or binding succeeds, zero is returned.  On</span><br><span class="line">    error, -1 is returned, and errno is <span class="built_in">set</span> to indicate the error.</span><br></pre></td></tr></table></figure>
<p>作用：<code>connect()</code> 函数是一个阻塞函数，在连接建立完成之前会阻塞程序的执行。其作用是将客户端的套接字连接到指定的服务器地址和端口上。在调用 <code>connect()</code> 函数之前，客户端需要先创建一个套接字，并调用 <code>bind()</code> 函数绑定到本地地址（如果需要的话），然后才能调用 <code>connect()</code> 函数与服务器建立连接。</p>
<p><strong>inet_addr() 辅助函数</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">    The <span class="title function_">inet_addr</span><span class="params">()</span> function shall convert the <span class="built_in">string</span> pointed to by</span><br><span class="line">    cp, in the standard IPv4 dotted decimal notation, to an integer</span><br><span class="line">    value suitable <span class="keyword">for</span> use as an Internet address.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">    Upon successful completion, <span class="title function_">inet_addr</span><span class="params">()</span> shall <span class="keyword">return</span> the Internet</span><br><span class="line">    address. Otherwise, it shall <span class="title function_">return</span> <span class="params">(<span class="type">in_addr_t</span>)</span><span class="params">(<span class="number">-1</span>)</span>.</span><br></pre></td></tr></table></figure>
<p>作用：<code>inet_addr()</code> 将字符串格式的点分十进制 IPv4 地址，转换为网络地址格式。</p>
<h2 id="输出 -v4">输出</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">% ./server</span><br><span class="line">Listening on port 9876 <span class="keyword">for</span> clients...</span><br><span class="line">War and Peace</span><br><span class="line">Pride and Prejudice</span><br><span class="line">The Sound and the Fury <span class="comment"># while(1) -&gt; 一直监听</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">% ./client</span><br><span class="line">Connect to server, about to write some stuff...</span><br><span class="line">War and Peace</span><br><span class="line">Pride and Prejudice</span><br><span class="line">The Sound and the Fury</span><br><span class="line">Client <span class="keyword">done</span>, about to <span class="built_in">exit</span>...</span><br><span class="line">%</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>套接字示例将请求消息回显给客户端，暗示了服务器和客户端之间 <strong> 进行任意丰富对话的可能性</strong>。也许这就是套接字的主要吸引力。在现代系统中，客户端应用程序（例如数据库客户端）通过套接字与服务器进行通信是很常见的。如前所述，本地 IPC sockets 和 Network sockets 仅在一些实现细节上有所不同；一般来说，IPC sockets 的开销较低，性能较好。两者的通信 API 本质上是相同的。</p>
<h1 id="Signals">Signals</h1>
<p><strong>信号（signal）中断正在执行的程序并与其通信 </strong>：信号是一种用于通知进程发生了某种事件的机制。<u> 当其它进程接收到信号时，OS 会中断进程的正常执行，然后根据接收到的信号执行相应的操作</u>。</p>
<p>除了由 OS 发出信号外，一个进程也可以向另一个进程发送信号，从而使信号成为一种 IPC 机制。大多数信号可以被忽略（阻止）或 <strong> 处理（通过指定的代码）</strong>。</p>
<p>在 UNIX 系统可以通过 kill -l 来查看支持的信号列表，以下是部分信号的功能：</p>
<table>
<thead>
<tr>
<th>信号名</th>
<th>POSIX 标准编号</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGKILL</td>
<td>9</td>
<td>强制终止进程，无法被捕获或忽略</td>
</tr>
<tr>
<td>SIGUSR1</td>
<td>10</td>
<td>用户自定义信号 1</td>
</tr>
<tr>
<td>SIGUSR2</td>
<td>12</td>
<td>用户自定义信号 2</td>
</tr>
<tr>
<td>SIGCHLD</td>
<td>17</td>
<td>子进程状态发生改变</td>
</tr>
<tr>
<td>SIGTERM</td>
<td>15</td>
<td>请求终止进程，通常是正常终止</td>
</tr>
</tbody>
</table>
<blockquote>
<p>用户交互中可能会产生（arise）信号。例如，用户从命令行按下 Ctrl+C 来终止从命令行启动的程序；Ctrl+C 生成 SIGTERM (15) 信号。与 SIGKILL (9) 不同，用于终止的 SIGTERM (15) 可以被阻止或处理。</p>
</blockquote>
<p><strong>kill() 系统调用</strong>：</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   The <span class="title function_">kill</span><span class="params">()</span> system call can be used to send any signal to any</span><br><span class="line">   process group or process.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果函数 <code>kill</code> 的第一个参数大于 0，则该参数被视为目标进程的 PID；如果参数为 0，则该参数标识信号发送者所属的进程组。</p>
<h2 id="shutdown">shutdown</h2>
<p>Example 3. the graceful shutdown of a multi-processing system <em>shutdown.c</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">graceful</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\tChild confirming received signal: %i\n&quot;</span>, signum);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\tChild about to terminate gracefully...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\tChild terminating now...&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>); <span class="comment">/* fast-track notification of parent */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_handler</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">current</span>;</span></span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;current.sa_mask); <span class="comment">/* clear the signal set */</span></span><br><span class="line">    current.sa_flags = <span class="number">0</span>;          <span class="comment">/* enables setting sa_handler, not sa_action */</span></span><br><span class="line">    current.sa_handler = graceful; <span class="comment">/* specify a handler */</span></span><br><span class="line"></span><br><span class="line">    sigaction(SIGTERM, &amp;current, <span class="literal">NULL</span>); <span class="comment">/* register the handler */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">child_code</span><span class="params">()</span> &#123;</span><br><span class="line">    set_handler();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="comment">/** loop until interrupted **/</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\tChild just woke up, but going back to sleep.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">parent_code</span><span class="params">(<span class="type">pid_t</span> cpid)</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Parent sleeping for a time...&quot;</span>);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Try to terminate child. */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == kill(cpid, SIGTERM)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;kill&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    wait(<span class="literal">NULL</span>); <span class="comment">/** wait for child to terminate **/</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;My child terminated, about to exit myself...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> cpid = fork();</span><br><span class="line">    <span class="keyword">if</span> (cpid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == cpid) &#123;</span><br><span class="line">        child_code();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent_code(cpid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，来自父进程的 SIGTERM 信号（通过 <code>kill()</code> 系统调用），导致子进程优雅地执行信号处理 callback 函数。父进程等待子进程正常终止后，自身也正常终止。</p>
<p>对于信号处理，该示例使用 <code>sigaction</code> 函数（POSIX 推荐的），而不是 <code>signal</code> 信号函数（它存在可移植性问题）。</p>
<p><strong>struct sigaction 数据结构</strong>：</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">   <span class="type">void</span>     (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">   <span class="type">void</span>     (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line">   <span class="type">sigset_t</span> sa_mask;</span><br><span class="line">   <span class="type">int</span>      sa_flags;</span><br><span class="line">   <span class="type">void</span>     (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><code>sa_flags</code>：整数值，包含了一些标志位，用于控制信号处理的行为。</li>
<li><code>sa_mask</code>：信号集，用于在执行信号处理函数期间阻止其他特定信号的发送。</li>
<li><code>sa_handler</code>：函数指针，指向一个简单的信号处理函数，接收一个信号编号。当 <code>sa_flags</code> 没有设置 <code>SA_SIGINFO</code> 标志时使用。</li>
<li><code>sa_sigaction</code>：函数指针，指向一个更复杂的信号处理函数。当 <code>sa_flags</code> 设置了 <code>SA_SIGINFO</code> 标志时使用。</li>
</ul>
<p><strong>sigaction() 系统调用</strong>：</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   The <span class="title function_">sigaction</span><span class="params">()</span> system call is used to change the action taken by</span><br><span class="line">   a process on receipt of a specific signal.</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><code>signum</code>：指定了要捕获的信号的编号。比如，<code>SIGTERM</code> 代表终止信号等。</li>
<li><code>act</code>：一个指向 <code>struct sigaction</code> 结构的指针，该结构定义了新的信号处理程序和一些信号处理的选项。如果想要忽略信号，可以将 <code>act</code> 设置为 <code>NULL</code>。</li>
<li><code>oldact</code>：用于存储以前关联的信号处理程序信息，以供后续使用。如果不需要此信息，也可以将其设置为 <code>NULL</code>。</li>
</ul>
<h2 id="输出 -v5">输出</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">% ./shutdown</span><br><span class="line">Parent sleeping <span class="keyword">for</span> a time...</span><br><span class="line">        Child just woke up, but going back to <span class="built_in">sleep</span>.</span><br><span class="line">        Child just woke up, but going back to <span class="built_in">sleep</span>.</span><br><span class="line">        Child just woke up, but going back to <span class="built_in">sleep</span>.</span><br><span class="line">        Child just woke up, but going back to <span class="built_in">sleep</span>.</span><br><span class="line">        Child confirming received signal: 15</span><br><span class="line">        Child about to terminate gracefully...</span><br><span class="line">        Child terminating now...</span><br><span class="line">My child terminated, about to <span class="built_in">exit</span> myself...</span><br><span class="line">% </span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://opensource.com/sites/default/files/gated-content/inter-process_communication_in_linux.pdf">A guide to inter-process communication in Linux</a></li>
</ol>
</blockquote>

</div>


  <div class="book-comments">
    




  </div>



<script src="/js/book-post.js"></script>


            </div>
          </div>
          <div class="column col-2 hide-lg">
            <div class="book-post-info">
  
    <div class="book-post-meta">

  <div class="author">

    <!-- Author image -->
    <div class="author-img">
      
        <figure
          class="avatar avatar-lg"
          data-initial="A"
          style="background-color: #3b4351;">
        </figure>
      
    </div>

    <!-- Author title -->
    <div class="author-title">
      <div>aha</div>
      <div>2024-04-14</div>
    </div>
  </div>

  
    <div class="divider"></div>

    <div class="link">
      <a class="category-link" href="/categories/Linux/">Linux</a> <a class="category-link" href="/categories/Linux/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/">多进程编程</a>

      <a class="tag-none-link" href="/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/" rel="tag">#多进程编程</a> <a class="tag-none-link" href="/tags/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" rel="tag">#进程间通信</a>
    </div>
    
  

  <div class="divider"></div>
</div>
  

  <div class="book-tocbot">
</div>
<div class="book-tocbot-menu">
  <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
  <a onclick="go_top()">Back to top</a>
  <a onclick="go_bottom()">Go to bottom</a>
  <a onclick="toggleSearch()">Search in blogs</a> <!-- 添加搜索文字的点击事件 -->
</div>

<div id="search-overlay" class="search-overlay" style="display: none;"> <!-- 初始状态为隐藏 -->
  <div class="search-box">
    <input type="text" id="search-input" placeholder="Search in all blogs...">
    <button onclick="closeSearch()">Close</button> <!-- 添加关闭按钮 -->
    <div id="search-results" class="search-results"></div>
  </div>
</div>

<script>
  function performSearch(query) {
    if (!query.trim()) {
      return;
    }

    fetch('/search.xml')
      .then(response => response.text())
      .then(data => {
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(data, "text/xml");
        const entries = xmlDoc.getElementsByTagName('entry');
        let results = '';

        for (let i = 0; i < entries.length; i++) {
          const title = entries[i].getElementsByTagName('title')[0].textContent;
          const content = entries[i].getElementsByTagName('content')[0].textContent;
          const url = entries[i].getElementsByTagName('url')[0].textContent;

          let count = (title.match(new RegExp(query, "gi")) || []).length; // 统计查询词出现的次数
          count += (content.match(new RegExp(query, "gi")) || []).length;

          if (count > 0) { // title.includes(query) || content.includes(query)
            results += `
              <div class="search-result-item">
                <a href="${url}">${title}</a> (${count})
              </div>`;
          }
        }

        const searchResultsElement = document.getElementById('search-results');
        searchResultsElement.innerHTML = results;
        searchResultsElement.classList.add('active');
      });
  }

  function toggleSearch() {
    const searchOverlay = document.getElementById('search-overlay');
    searchOverlay.style.display = searchOverlay.style.display === 'none' ? 'flex' : 'none';
  }

  function closeSearch() {
    document.getElementById('search-overlay').style.display = 'none';
  }

  document.getElementById('search-input').addEventListener('input', function() {
    const query = this.value;
    performSearch(query);
  });
</script>

<style>
  .search-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }

  .search-box {
    background: white;
    padding: 20px;
    border-radius: 5px;
    text-align: center;
    width: 80%;
    max-width: 500px;
  }

  .search-results {
    margin-top: 10px;
    max-height: 300px;
    overflow-y: auto;
    background: white;
    padding: 10px;
    border-radius: 5px;
    width: 100%;
  }

  .search-result-item {
    margin: 10px 0;
  }

  .search-result-item a {
    color: blue; /* 设置链接颜色为蓝色 */
    text-decoration: none;
  }

  .search-result-item a:hover {
    text-decoration: underline;
  }
</style>


<script src="/js/book-toc.js"></script>


</div>
          </div>
        </div>
      </div>

      <a class="off-canvas-overlay" onclick="hide_canvas()"></a>

      <button class="floating-button" onclick="toggleDropdownMenu()"></button>

      <div class="dropdown-menu">
        <div class="dropdown-item" onclick="changeBackgroundColor('#FFFFFF', '#000000')">银河白</div>
        <div class="dropdown-item" onclick="changeBackgroundColor('#C7EDCC', '#000000')">豆沙绿</div>
        <div class="dropdown-item" onclick="changeBackgroundColor('#FAF9DE', '#000000')">杏仁黄</div>
        <div class="dropdown-item" onclick="changeBackgroundColor('#E3EDCD', '#000000')">青草绿</div>
        <div class="dropdown-item" onclick="changeBackgroundColor('#FFF2E2', '#000000')">秋叶褐</div>
      </div>
  </div>

  <script>
    function toggleDropdownMenu() {
      document.querySelector('.floating-button').classList.toggle('active');
    }

    document.addEventListener('DOMContentLoaded', function () {
      var storedBackgroundColor = localStorage.getItem('blogBackgroundColor');
      var storedColor = localStorage.getItem('blogColor');

      if (storedBackgroundColor && storedColor) {
        document.body.style.backgroundColor = storedBackgroundColor;
        document.body.style.color = storedColor;
      }
    });

    function changeBackgroundColor(backgroundColor, color) {
      document.body.style.backgroundColor = backgroundColor;
      document.body.style.color = color;

      localStorage.setItem('blogBackgroundColor', backgroundColor);
      localStorage.setItem('blogColor', color);

      document.querySelector('.floating-button').classList.remove('active');
    }
  </script>
</body>

</html>


<script src="/js/book.js"></script>
