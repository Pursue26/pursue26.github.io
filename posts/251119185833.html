<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

    
      <link rel="icon" href="/favicon.png" />
    

    <title>
        
          Linux UDP 传输性能优化 - aha&#39;s book
        
    </title>

    <!-- Spectre.css framework -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-exp.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-icons.min.css">

    <!-- theme css & js -->
    
<link rel="stylesheet" href="/css/book.css">

    
<script src="/js/book.js"></script>


    <!-- tocbot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
    
    <!-- katex -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">

    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/zooming/2.1.1/zooming.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    const zooming = new Zooming()
    zooming.listen('.book-content img')
})
</script>

<meta name="generator" content="Hexo 6.3.0"></head>
    <style>
      body {
        background-color: #FFFFFF;
        /* color: #000000; */
        transition: background-color 0.3s ease, color 0.3s ease;
      }

      /* Floating Button Styles */
      .floating-button {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 999;
        background-color: #000000;
        color: #ffffff;
        padding: 12px;
        border-radius: 50%;
        cursor: pointer;
        border: 2px solid #000000;
      }

      .floating-button:hover {
        background-color: #FFFFFF;
      }

      /* Dropdown Menu Styles */
      .dropdown-menu {
        position: fixed;
        bottom: 60px;
        right: 10px;
        display: none;
        min-width: 60px;
        padding: 2px;
        background-color: #fff;
        /* box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); */
        z-index: 1000;
      }

      .floating-button.active+.dropdown-menu {
        display: block;
      }

      .dropdown-item {
        display: block;
        padding: 8px 16px;
        cursor: pointer;
      }

      .dropdown-item:hover {
        background-color: #f5f5f5;
      }
    </style>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body>
  <div class="book-container">
    <div class="book-sidebar">
      <div class="book-brand">
  <a href="/">
    <img src="/favicon.png">
    <span>AHA&#39;S BOOK</span>
  </a>
</div>
        <div id="menu" class="book-menu hide">
  <h2 id="基础知识"> 基础知识 </h2>
<ul>
<li><a href="/posts/231010144856.html"> 模运算 </a></li>
<li><a href="/posts/231014105311.html"> 异或运算 </a></li>
<li><a href="/posts/231210181853.html"> 计算机中的寄存器 </a></li>
<li><a href="/posts/231213183051.html"> 正则表达式基础 </a></li>
</ul>
<h2 id="C 语言">C 语言 </h2>
<ul>
<li><a href="/posts/230916171929.html">main 函数参数 </a></li>
<li><a href="/posts/231214192113.html"> 关键字与专有名词 </a></li>
<li><a href="/posts/240103180653.html"> 输出打印函数 </a></li>
<li><a href="/posts/230922143003.html"> 多维数组 </a></li>
<li><a href="/posts/230913200729.html">const 关键字 </a></li>
<li><a href="/posts/230918174223.html">typedef 类型基础 </a></li>
<li><a href="/posts/230920172849.html">typedef 类型实践 </a></li>
<li><a href="/posts/240224193217.html"> 二级指针 </a></li>
<li><a href="/posts/240307195203.html"> 代码 TOP-K 问题 </a></li>
<li><a href="/posts/230922172626.html">uthash 哈希表基础 </a></li>
<li><a href="/posts/230918114841.html"> 大小端知识 </a></li>
</ul>
<h2 id="Golang 语言">Golang 语言 </h2>
<ul>
<li><a href="/posts/230907162612.html"> 变量与常量 </a></li>
<li><a href="/posts/230909120145.html"> 函数 &amp; 包 &amp; 判断 &amp; 循环 </a></li>
<li><a href="/posts/230912152800.html"> 数组与切片 </a></li>
<li><a href="/posts/230913161326.html"> 可变参数函数与 Map 集合 </a></li>
<li><a href="/posts/230915155105.html"> 字符串和指针 </a></li>
</ul>
<h2 id="数据结构"> 数据结构 </h2>
<ul>
<li><a href="/posts/231007174854.html"> 链表（数组实现）</a></li>
<li><a href="/posts/231008213450.html"> 链表（链式实现）</a></li>
<li><a href="/posts/231016161508.html"> 堆栈（数组实现）</a></li>
<li><a href="/posts/231016184406.html"> 堆栈（链表实现）</a></li>
<li><a href="/posts/231127185207.html"> 单调栈 </a></li>
<li><a href="/posts/231017105123.html"> 队列（链表实现）</a></li>
<li><a href="/posts/231017154121.html"> 双端队列（链表实现）</a></li>
<li><a href="/posts/231018102559.html"> 堆基础与堆结构（数组实现）</a></li>
<li><a href="/posts/231019102311.html"> 优先队列（堆实现）</a></li>
<li><a href="/posts/230905224335.html"> 二叉树的遍历 </a></li>
<li><a href="/posts/231020174358.html"> 二叉搜索树 </a></li>
<li><a href="/posts/230916094606.html"> 拓扑排序 </a></li>
<li><a href="/posts/230925185057.html">Trie 字典树 </a></li>
<li><a href="/posts/231023164532.html"> 并查集（数组实现）</a></li>
<li><a href="/posts/240702200642.html">Linux 数据结构之队列 </a></li>
</ul>
<h2 id="数据结构算法"> 数据结构算法 </h2>
<ul>
<li><a href="/posts/231218181635.html"> 归并排序 </a></li>
<li><a href="/posts/231108163339.html"> 快速排序 </a></li>
<li><a href="/posts/231107171607.html"> 堆排序 </a></li>
<li><a href="/posts/231124181658.html"> 二分查找 </a></li>
<li><a href="/posts/231227190828.html"> 哈希表实现 </a></li>
<li><a href="/posts/240313193201.html"> 字符串哈希函数 </a></li>
<li><a href="/posts/231116150205.html">Floyd 多源最短路径 </a></li>
<li><a href="/posts/231117095232.html">Dijkstra 单源最短路径（原理部分）</a></li>
<li><a href="/posts/231121152713.html">Dijkstra 单源最短路径（实现部分）</a></li>
</ul>
<h2 id="数据库"> 数据库 </h2>
<ul>
<li><a href="/posts/250605180332.html">MySQL 基础 </a></li>
</ul>
<h2 id="计算机网络"> 计算机网络 </h2>
<ul>
<li><a href="/posts/231011192359.html">OSI 参考模型 </a></li>
<li><a href="/posts/240329202000.html"> 计网 CyC2018 之概述 </a></li>
<li><a href="/posts/240329202004.html"> 计网 CyC2018 之链路层 </a></li>
<li><a href="/posts/240329202003.html"> 计网 CyC2018 之网络层 </a></li>
<li><a href="/posts/240329202002.html"> 计网 CyC2018 之传输层 </a></li>
<li><a href="/posts/240329202001.html"> 计网 CyC2018 之应用层 </a></li>
<li><a href="/posts/240306203742.html">ACL 访问控制列表 </a></li>
<li><a href="/posts/240130190208.html"> 路由表、转发表与快速转发工作原理 </a></li>
<li><a href="/posts/231221200716.html">VXLAN 网络虚拟化技术 </a></li>
<li><a href="/posts/240903191243.html">TCP/IP checksum 计算 </a></li>
<li><a href="/posts/240911185603.html"> 抓包分析 TCP 三次握手与四次挥手过程 </a></li>
</ul>
<h2 id="操作系统"> 操作系统 </h2>
<ul>
<li><a href="/posts/230921190726.html"> 概述 </a></li>
<li><a href="/posts/230924172528.html"> 中断 &amp; 异常 &amp; 系统调用 </a></li>
<li><a href="/posts/231017195157.html"> 内存分层体系与地址空间生成 </a></li>
<li><a href="/posts/231108195351.html"> 连续内存分配 </a></li>
<li><a href="/posts/231111172507.html"> 非连续内存分配之分段与分页 </a></li>
<li><a href="/posts/231119170537.html"> 非连续内存分配之页表 </a></li>
<li><a href="/posts/231123184526.html"> 内存管理之覆盖技术与交换技术 </a></li>
<li><a href="/posts/231127193658.html"> 内存管理之虚存技术 </a></li>
<li><a href="/posts/231129182631.html"> 局部页面置换算法 </a></li>
<li><a href="/posts/231207184239.html"> 全局页面置换算法 </a></li>
<li><a href="/posts/231207204958.html"> 进程描述 </a></li>
<li><a href="/posts/231210211306.html"> 进程状态 </a></li>
<li><a href="/posts/231215213932.html"> 线程 </a></li>
<li><a href="/posts/231218220813.html"> 进程控制 </a></li>
<li><a href="/posts/231228193143.html"> 调度 </a></li>
<li><a href="/posts/240104202828.html"> 同步与互斥 </a></li>
<li><a href="/posts/240113115605.html"> 信号量与管程 </a></li>
<li><a href="/posts/240205182643.html"> 经典同步问题 </a></li>
<li><a href="/posts/240310162231.html"> 死锁 </a></li>
</ul>
<h2 id="系统与网络编程"> 系统与网络编程 </h2>
<ul>
<li><a href="/posts/230911151334.html">pthread 库 </a></li>
<li><a href="/posts/230921094127.html"> 锁与原子操作 </a></li>
<li><a href="/posts/240319195609.html"> 读者写者问题 </a></li>
<li><a href="/posts/240527200241.html"> 网络编程卷一阅读随笔 </a></li>
<li><a href="/posts/240414190410.html"> 进程间通信 IPC 机制 </a></li>
<li><a href="/posts/240424200123.html"> 多进程相关练习 </a></li>
<li><a href="/posts/240516221527.html">I/O 模式与 I/O 多路复用 </a></li>
<li><a href="/posts/240626192803.html">Linux 内核 kfifo 环形队列 </a></li>
<li><a href="/posts/241009203126.html">Linux 内核等待队列 </a></li>
<li><a href="/posts/240627210637.html">DPDK 无锁环形队列 </a></li>
<li><a href="/posts/240919200410.html"> 解密内存屏障 </a></li>
<li><a href="/posts/240927202500.html"> 内核线程的创建 </a></li>
<li><a href="/posts/241015195205.html">Linux 网络数据包接收过程 </a></li>
<li><a href="/posts/2410232111015.html"> 源码解读 epoll 实现原理 </a></li>
<li><a href="/posts/241106182619.html">Linux 文件系统 </a></li>
<li><a href="/posts/250619154429.html">Libevent 高性能 IO 事件驱动库 </a></li>
<li><a href="/posts/251119185833.html">Linux UDP 传输性能优化 </a></li>
<li><a href="/posts/251202101130.html">Linux 零拷贝技术 </a></li>
<li><a href="/posts/251124150921.html">QUIC 协议 </a></li>
</ul>
<h2 id="工具与命令"> 工具与命令 </h2>
<ul>
<li><a href="/posts/240207180410.html">GCC 编译过程分解 </a></li>
<li><a href="/posts/240312184132.html">GDB 调试入门 </a></li>
<li><a href="/posts/240512184921.html">Makefile 学习 </a></li>
<li><a href="/posts/250629214430.html">CMake 学习 </a></li>
<li><a href="/posts/240417193754.html">Linux 命令之文件权限 </a></li>
</ul>
<h2 id="开源项目"> 开源项目 </h2>
<ul>
<li><a href="/posts/240303201855.html"> 线程池原理与实现 </a></li>
<li><a href="/posts/240507194549.html">HTTP 服务器实现 </a></li>
<li><a href="/posts/240904203605.html"> 聊天服务器实现 </a></li>
<li><a href="/posts/241119182636.html">Linux 文件系统 </a></li>
</ul>
<h2 id="Docker">Docker</h2>
<ul>
<li><a href="/posts/230909171809.html">Docker 学习笔记 </a></li>
</ul>
<h1 id="LeetCode 刷题">LeetCode 刷题 </h1>
<h2 id="链表相关"> 链表相关 </h2>
<ul>
<li><a href="/posts/231025143947.html">160 相交链表 </a></li>
<li><a href="/posts/231025185947.html">206 反转链表 </a></li>
<li><a href="/posts/231026101239.html">21 合并两个有序链表 </a></li>
<li><a href="/posts/231026184514.html">83 删除排序链表中的重复元素 </a></li>
<li><a href="/posts/231027150243.html">19 删除链表的倒数第 N 个节点 </a></li>
<li><a href="/posts/231031120718.html">2 两数相加 </a></li>
<li><a href="/posts/231031163133.html">445 两数相加 II</a></li>
<li><a href="/posts/231101094219.html">234 回文链表 </a></li>
<li><a href="/posts/231101135228.html">725 分隔链表 </a></li>
<li><a href="/posts/231102120708.html">328 奇偶链表 </a></li>
<li><a href="/posts/231102165703.html">142 环形链表 II</a></li>
</ul>
<h2 id="设计"> 设计 </h2>
<ul>
<li><a href="/posts/231201184542.html">146 LRU 缓存 </a></li>
</ul>
<h2 id="贪心算法"> 贪心算法 </h2>
<ul>
<li><a href="/posts/231107094652.html">1029 两地调度 </a></li>
<li><a href="/posts/231109150855.html">435 无重叠区间 </a></li>
</ul>
<h2 id="哈希表"> 哈希表 </h2>
<ul>
<li><a href="/posts/231123181539.html">1410 实体解析器 </a></li>
</ul>
<h2 id="树的遍历"> 树的遍历 </h2>
<ul>
<li><a href="/posts/231103121209.html">117 填充每个节点的下一个右侧节点指针 II</a></li>
</ul>
<h2 id="深度优先搜索（递归）"> 深度优先搜索（递归）</h2>
<ul>
<li><a href="/posts/231206201243.html">2477 达到首都的最少油耗 </a></li>
</ul>
<h2 id="图或路径问题"> 图或路径问题 </h2>
<ul>
<li><a href="/posts/231211184652.html">1631 最小体力消耗路径 </a></li>
</ul>
<h2 id="其它"> 其它 </h2>
<ul>
<li><a href="/posts/230101120000.html"> 备忘录 </a></li>
</ul>

</div>


<script src="/js/book-menu.js"></script>

    </div>
    <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
  <div class="sidebar-toggle-inner"></div>
</div>

<script>
function add_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.add('show')  
}

function remove_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.remove('show')
}

function sidebar_toggle() {
    let sidebar_toggle = document.querySelector('.sidebar-toggle')
    let sidebar = document.querySelector('.book-sidebar')
    let content = document.querySelector('.off-canvas-content')
    if (sidebar_toggle.classList.contains('extend')) { // show
        sidebar_toggle.classList.remove('extend')
        sidebar.classList.remove('hide')
        content.classList.remove('extend')
    }
    else { // hide
        sidebar_toggle.classList.add('extend')
        sidebar.classList.add('hide')
        content.classList.add('extend')
    }
}
</script>

      <div class="off-canvas-content">
        <div class="columns">
          <div class="column col-10 col-lg-12">
            <div class="book-navbar">
              <!-- For Responsive Layout -->

<header class="navbar">
  <section class="navbar-section">
    <a onclick="open_sidebar()">
      <i class="icon icon-menu"></i>
    </a>
  </section>
</header>

            </div>
            <div class="book-content">
              <div class="book-post">
  <span id="more"></span>
<h1 id="UDP 性能提升（理论部分）">UDP 性能提升（理论部分）</h1>
<p>While a lot of work has gone into optimizing TCP implementations as much as possible over the years, <strong>including building offloading capabilities in both software (like in operating systems) and hardware (like in network interfaces)</strong>, UDP has not received quite as much attention as TCP, which puts QUIC at a disadvantage. In this post we will look at a few tricks that help mitigate(减轻) this disadvantage for UDP, and by association QUIC.</p>
<p>尽管多年来人们投入大量精力优化 TCP 实现——<strong>包括在软件（如操作系统）和硬件（如网络接口）中构建卸载能力</strong>，但 UDP 获得的关注度远不及 TCP，这使得 QUIC 处于不利地位。本文将探讨几种有助于减轻 UDP 及其关联协议 QUIC 的这种劣势的技术方案。</p>
<h2 id="sendmsg">sendmsg</h2>
<p>Currently the code that implements QUIC in NGINX uses the <code>sendmsg()</code> system call to send a single UDP packet at a time.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>
<img src="../images/udp-accelerating/sendmsg.png" alt="sendmsg" width="80%" height="80%">
<p>The <code>struct msghdr</code> carries a <code>struct iovec</code> which can in turn(依次) carry multiple buffers. However, all of the buffers within a single iovec will be merged together into a single UDP datagram during transmission. The kernel will then take care of encapsulating the buffer in a UDP packet and sending it over the wire.</p>
<p><code>struct msghdr</code> 结构体携带的 <code>struct iovec</code> 能够承载多个缓冲区。然而，在传输过程中，<strong>单个 iovec 内的所有缓冲区会被合并成一个独立的 UDP 数据报</strong>。内核随后会负责将该缓冲区封装到 UDP 数据包中并通过网络发送。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Structure describing messages sent by `sendmsg&#x27; and received by `recvmsg&#x27;.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">void</span> *msg_name;		<span class="comment">/* Address to send to/receive from.  */</span></span><br><span class="line">    <span class="type">socklen_t</span> msg_namelen;	<span class="comment">/* Length of address data.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">msg_iov</span>;</span>	<span class="comment">/* Vector of data to send/receive into.  */</span></span><br><span class="line">    <span class="type">size_t</span> msg_iovlen;		<span class="comment">/* Number of elements in the vector.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *msg_control;		<span class="comment">/* Ancillary data (eg BSD filedesc passing). */</span></span><br><span class="line">    <span class="type">size_t</span> msg_controllen;	<span class="comment">/* Ancillary data buffer length.</span></span><br><span class="line"><span class="comment">				   !! The type should be socklen_t but the</span></span><br><span class="line"><span class="comment">				   definition of the kernel is incompatible</span></span><br><span class="line"><span class="comment">				   with this.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> msg_flags;		<span class="comment">/* Flags on received message.  */</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Structure for scatter/gather I/O.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">void</span> *iov_base;	<span class="comment">/* Pointer to data.  */</span></span><br><span class="line">    <span class="type">size_t</span> iov_len;	<span class="comment">/* Length of data.  */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="sendmmsg">sendmmsg</h2>
<p>Due to the fact that <code>sendmsg()</code> only sends a single UDP packet at a time, it needs to be invoked quite a lot in order to transmit all of the QUIC packets required to deliver the requested resources.</p>
<p>由于 <code>sendmsg()</code> 每次只能发送一个 UDP 数据包，因此需要频繁调用该函数才能传输交付所请求资源所需的所有 QUIC 数据包。</p>
<p>Each of those system calls causes an expensive context switch between the application and the kernel, thus impacting throughput.</p>
<p>每一次系统调用都会导致应用程序与内核之间发生昂贵的上下文切换，从而对吞吐量造成影响。</p>
<p>But while <code>sendmsg()</code> only transmits a single UDP packet at a time for each invocation, its close cousin(近亲 / 衍生) <code>sendmmsg()</code> (note the additional “m” in the name) is able to <strong>batch multiple packets</strong> per system call:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sendmmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> mmsghdr *msgvec, <span class="type">unsigned</span> <span class="type">int</span> vlen, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>
<p>Multiple <code>struct mmsghdr</code> structures can be passed to the kernel as an array, each in turn(依次) carrying a single <code>struct msghdr</code> with its own <code>struct iovec</code>, with each element in the <code>msgvec</code> array representing a single UDP datagram.</p>
<p>可以将多个 <code>struct mmsghdr</code> 结构体以数组形式传递给内核，其中每个结构体依次承载一个包含独立 <code>struct iovec</code> 的 <code>struct msghdr</code>，而 <code>msgvec</code> 数组中的每个元素都代表一个独立的 UDP 数据报。</p>
<img src="../images/udp-accelerating/sendmmsg.png" alt="sendmmsg" width="80%" height="80%">
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* For `recvmmsg&#x27; and `sendmmsg&#x27;.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmsghdr</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg_hdr</span>;</span>	<span class="comment">/* Actual message header.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> msg_len;	<span class="comment">/* Number of received or sent bytes for the entry.  */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>系统调用示例（可见 <code>.msg_len</code> 是内核返回给应用的参数）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ret = sendmmsg(sockfd, msgs, num_packets, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计发送的字节数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sendmmsg sent %d out of %d packets\n&quot;</span>, ret, num_packets);</span><br><span class="line"><span class="type">size_t</span> total_sent = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line">    total_sent += msgs[i].msg_len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Total bytes sent via sendmmsg: %zu\n&quot;</span>, total_sent);</span><br></pre></td></tr></table></figure>
<h2 id="UDP-segmentation-offload">UDP segmentation offload</h2>
<h3 id="原理">原理</h3>
<p>With <code>sendmsg()</code> as well as <code>sendmmsg()</code>, the application is responsible for separating each QUIC packet into its own buffer in order for the kernel to be able to transmit it. While the implementation in NGINX uses static buffers to implement this, so there is no overhead in allocating them, all of these buffers need to be traversed by the kernel during transmission, which can add significant overhead.</p>
<p>无论是使用 <code>sendmsg()</code> 还是 <code>sendmmsg()</code>，应用程序都需要将每个 QUIC 数据包分离到独立的缓冲区中，以便内核进行传输。虽然 NGINX 的实现使用静态缓冲区来完成这一操作（因此不存在分配开销），但在传输过程中内核需要遍历所有这些缓冲区，这会带来显著的开销。</p>
<p>Linux supports a feature, <strong>Generic Segmentation Offload (GSO)</strong>, which allows the application to pass a single “super buffer” to the kernel, which will then take care of segmenting it into smaller packets. The kernel will try to postpone(推迟) the segmentation as much as possible to reduce the overhead of traversing outgoing buffers (some NICs even support hardware segmentation). Originally GSO was only supported for TCP, but support for UDP GSO was recently added as well, in Linux 4.18.</p>
<p><strong>Linux 支持一项名为通用分段卸载（GSO）的功能，该功能允许应用程序向内核传递一个“超级缓冲区”，由内核负责将其分割成更小的数据包。内核会尽可能推迟分段操作，以减少遍历发送缓冲区带来的开销</strong>（某些网卡甚至支持硬件分段）。最初 GSO 仅支持 TCP，但在 Linux 4.18 中也新增了对 UDP GSO 的支持。</p>
<p>This feature can be controlled using the <code>UDP_SEGMENT</code> socket option:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SOL_UDP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOL_UDP (17)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UDP_SEGMENT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UDP_SEGMENT (103)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UDP_GRO</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UDP_GRO (104)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UDP_MAX_SEGMENTS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UDP_MAX_SEGMENTS (1 &lt;&lt; 6UL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>       use_gso = <span class="number">-1</span>;</span><br><span class="line"><span class="type">socklen_t</span> opt_len = <span class="keyword">sizeof</span>(use_gso);</span><br><span class="line"><span class="keyword">if</span> (getsockopt(sockfd, SOL_UDP, UDP_SEGMENT, &amp;use_gso, &amp;opt_len) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;GSO not supported by system, strerror: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">int</span> gso_size = (<span class="number">1500</span> - <span class="number">20</span> - <span class="number">8</span>);  <span class="comment">// MTU - IP Header - UDP Header</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sockfd, SOL_UDP, UDP_SEGMENT, &amp;gso_size, <span class="keyword">sizeof</span>(gso_size)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;setsockopt: UDP GSO enabled with size %d failed, strerror: %s\n&quot;</span>, gso_size, strerror(errno));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;UDP GSO supported: UDP GSO enabled with size %d\n&quot;</span>, gso_size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>As well as via ancillary(辅助的) data, to control segmentation for each <code>sendmsg()</code> call:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> *<span class="title">cm</span> =</span> CMSG_FIRSTHDR(&amp;msg);</span><br><span class="line">cm-&gt;cmsg_level = SOL_UDP;</span><br><span class="line">cm-&gt;cmsg_type = UDP_SEGMENT;</span><br><span class="line">cm-&gt;cmsg_len = CMSG_LEN(<span class="keyword">sizeof</span>(<span class="type">uint16_t</span>));</span><br><span class="line">*((<span class="type">uint16_t</span> *) CMSG_DATA(cm)) = gso_size;</span><br></pre></td></tr></table></figure>
<p>Where <code>gso_size</code> is the size of each segment that form the “super buffer” passed to the kernel from the application. Once configured, the application can provide one contiguous(连续的) large buffer containing a number of packets of <code>gso_size</code> length (as well as a final smaller packet), that will then be segmented by the kernel (or the NIC if hardware segmentation offloading is supported and enabled).</p>
<p>其中，<strong><code>gso_size</code> 表示构成从应用程序传递给内核的“超级缓冲区”的每个分段的大小。一旦配置完成，应用程序就可以提供一个连续的大型缓冲区，其中包含多个长度为 <code>gso_size</code> 的数据包（以及最后一个较小尺寸的数据包）</strong>，这些数据包将由内核（或在支持并启用硬件分段卸载功能时由网卡）进行分段处理。</p>
<img src="../images/udp-accelerating/sendmsg-gso.png" alt="sendmsg-gso" width="80%" height="80%">
<p><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/80a0c2e511a97e11d82e0ec11564e2c3fe624b0d/include/linux/udp.h#L94">Up to 64 segments</a> can be batched with the <code>UDP_SEGMENT</code> option.</p>
<p>And indeed the number of syscalls also went down significantly, compared to plain(普通的) <code>sendmsg()</code>.</p>
<p>GSO can also be combined with <code>sendmmsg()</code> to deliver an even bigger improvement. The idea being that each <code>struct msghdr</code> can be segmented in the kernel by setting the <code>UDP_SEGMENT</code> option using ancillary data, allowing an application to pass multiple “super buffers”, each carrying up to 64 segments, to the kernel in a single system call.</p>
<p>GSO 还可以与 <code>sendmmsg()</code> 结合使用，从而实现更显著的性能提升。其核心思想是：通过使用辅助数据设置 <code>UDP_SEGMENT</code> 选项，每个 <code>struct msghdr</code> 都可以在内核中进行分段，这使得应用程序能够在单次系统调用中向内核传递多个“超级缓冲区”，而每个缓冲区最多可包含 64 个数据段。</p>
<img src="../images/udp-accelerating/all-chart.png" alt="all-chart" width="80%" height="80%">
<h3 id="sendmsg-GSO 实践代码">sendmsg+GSO 实践代码</h3>
<p>本段代码，抽象于我最近编写的基于 Alibaba XQUIC 封装的 BSD TCP Socket API。</p>
<p>对于多个独立的 QUIC 包组成的 <code>msg_iov</code> 数组（也并非一块连续的超级缓冲区），如果大多数包满足具有相同的长度（不一定是 setsockopt 设置的 <code>gso_size</code>，但一定比它小且长度固定），少数包是其它长度。这种场景下，在尝试发送一个 <code>msg_iov</code> 数组下的多个包时，<strong>需要“分段”发送，即遇到长度变化时就要调用一次 <code>sendmsg</code>，将之前的所有长度一致的包使用 GSO 发送出去</strong>，再继续发送后续的包。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendmsg_with_gso</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> iovec *msg_iov, <span class="type">unsigned</span> <span class="type">int</span> vlen,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="keyword">struct</span> sockaddr *peer_addr, <span class="type">socklen_t</span> peer_addrlen, <span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ssize_t</span>        res;</span><br><span class="line">    <span class="type">ssize_t</span>        sent_batch = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>   start = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 一次调用 sendmsg 时，发送的多个小包组成的大包，长度不能超过系统限制，否则报错 Message too loog</span></span><br><span class="line">    <span class="comment">// 且一次 sendmsg 调用，不能超过 UDP_SEGMENT 个分段</span></span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> max_sendmsg_once = fmin(UDP_MAX_SEGMENTS, (<span class="number">65536</span> / PKT_MAX_MSS));</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    msg.msg_name = (<span class="type">void</span> *)peer_addr;</span><br><span class="line">    msg.msg_namelen = peer_addrlen;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> control[CMSG_SPACE(<span class="keyword">sizeof</span>(<span class="type">uint16_t</span>))];</span><br><span class="line">    <span class="built_in">memset</span>(control, <span class="number">0</span>, <span class="keyword">sizeof</span>(control));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt;= vlen; i++) &#123;</span><br><span class="line">        <span class="comment">// 连续相同的长度则继续后探，也控制每次 sendmsg 的 UDP datagram 数量</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; vlen &amp;&amp; msg_iov[i].iov_len == msg_iov[start].iov_len &amp;&amp; i - start &lt; max_sendmsg_once) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span>        batch_len = i - start;</span><br><span class="line">        <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">batch_iov</span> =</span> &amp;msg_iov[start];</span><br><span class="line">        <span class="type">size_t</span>              segment_size = msg_iov[start].iov_len;</span><br><span class="line"></span><br><span class="line">        msg.msg_iov = (<span class="keyword">struct</span> iovec *)batch_iov;</span><br><span class="line">        msg.msg_iovlen = batch_len;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只有批量数据才使用 GSO</span></span><br><span class="line">        <span class="keyword">if</span> (batch_len &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            msg.msg_control = control;</span><br><span class="line">            msg.msg_controllen = <span class="keyword">sizeof</span>(control);</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> *<span class="title">cm</span> =</span> CMSG_FIRSTHDR(&amp;msg);</span><br><span class="line">            cm-&gt;cmsg_level = SOL_UDP;</span><br><span class="line">            cm-&gt;cmsg_type = UDP_SEGMENT;</span><br><span class="line">            cm-&gt;cmsg_len = CMSG_LEN(<span class="keyword">sizeof</span>(<span class="type">uint16_t</span>));</span><br><span class="line">            *((<span class="type">uint16_t</span> *)CMSG_DATA(cm)) = segment_size;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            msg.msg_control = <span class="literal">NULL</span>;</span><br><span class="line">            msg.msg_controllen = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = sendmsg(fd, &amp;msg, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 错误处理...</span></span><br><span class="line"></span><br><span class="line">        sent_batch += batch_len;</span><br><span class="line">        start = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sent_batch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="大包、小包与 GSO">大包、小包与 GSO</h2>
<p>在业务发送 UDP 数据包时，为了避免 IP 层对包进行分片，一般会将待发送的 UDP 数据包的大小控制在 <code>MTU - sizeof(udp header) - sizeof(ip header)</code> 以下。这里之所以要避免 IP 层分片，主要是额外的 IP 层分片与重组有时候会导致不少问题：</p>
<ul>
<li>比如，同属于同一个上层数据包的多个 IP 分片在发送时，任一分片的丢失都将导致整个上层数据包的重传。</li>
<li>再比如，接收端设备为了完成 IP 重组不得不分配额外的内存等资源来存放管理当前已经收到的 IP 分片，如果发送端发送大量的 IP 分片，那么将会导致接收端用于暂存分片包的缓冲区被打满。</li>
<li>更糟糕的是，如果发送端的一个数据包对应的分片数目过多，那么接收端可能会一直无法完成一次完整的分片重组。举个极端例子：假设接收端 R 最多可以缓存 4 个 IP 分片包，现在有发送端 S 发送了 1 个 8000 字节长度的 UDP 数据包，在 MTU 为 1500 的情况下，这个 UDP 数据包将拆分为 6 个分片。很显然这时 R 将一直无法完成数据包的重组导致数据发送一直失败。</li>
</ul>
<p><strong>UDP GSO，简单来说就是内核在接受到应用程序发来的一堆待发送的应用数据 D 之后，会按照应用程序之前告诉内核的配置，将接收到的 D 拆分为若干块，之后为每一块加上 UDP header 封装成一个 UDP 数据包发送出去</strong>。以 <code>gsosize</code> 来表示上层应用告诉内核的每块最大大小。</p>
<p>我们以 QUIC 协议为例，当上层应用希望发送 2k 字节内容时，在不使用 GSO 的情况下，QUIC 实现一般会将内容拆分存放到 2 个 QUIC packet 中，之后对应着 2 个 UDP 数据包发送出去，对应到伪代码如下。很显然这涉及到两次 sendto 系统调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将待 1k 应用数据拼接成 QUIC packet 之后调用 sendto 发送</span></span><br><span class="line">sendto(fd, <span class="string">&quot;quic short packet header + frame header + [0, 1k) app data&quot;</span>);</span><br><span class="line"><span class="comment">// 继续发送后续 1k 应用数据</span></span><br><span class="line">sendto(fd, <span class="string">&quot;quic short packet header + frame header + [1k, 2k) app data&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>在使用 GSO 之后，应用需要首先通过 <code>SOL_UDP + UDP_SEGMENT</code> 告诉内核 <code>gsosize</code> 取值，之后应用按照 <code>gsosize</code> 完成数据的组装：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分片 1, 总长度要限制为 gsosize，否则 part1 就不是一个完整的 QUIC 包了</span></span><br><span class="line">part1 = <span class="string">&quot;quic short packet header + frame header + app data&quot;</span></span><br><span class="line"><span class="comment">// 分片 2, 存放着剩下的应用数据, 其大小可小于 gsosize.</span></span><br><span class="line">part2 = <span class="string">&quot;quic short packet header + frame header + app data&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后将分片 1, 2 拼接成一个大缓冲区, 然后一次 sendto 调用完成数据发送.</span></span><br><span class="line"><span class="comment">// 除最后一个分片的所有分片的大小要固定为 gsosize.</span></span><br><span class="line">sendto(fd, part1 + part2); <span class="comment">// part1 + part2 为一块连续的超级缓冲区</span></span><br><span class="line"><span class="comment">// 这里内核内部会按照 gsosize 再次将数据拆分为 &#x27; 分片 1&#x27;, &#x27; 分片 2&#x27;, 然后分为两个 UDP 数据包发送.</span></span><br></pre></td></tr></table></figure>
<p>所以，也可以看到 GSO 对于接收端来说是透明的。毕竟 GSO 后发送的每一个 UDP 数据包都是一个完整的、单独的数据包。</p>
<h2 id="UDP-GRO">UDP GRO</h2>
<p>UDP GRO，最开始我一直没有搞懂 UDP GRO，单纯地从字面上看 GRO 是说内核会尽量在协议的最底层将收到的多个数据包拼接在一起之后向上传递，也即上层看到的只是一个数据包。对于 TCP 中的 GRO，这里内核在拼接数据包时会遵循 TCP 的语义，比如内核在收到了三个 TCP 数据包，TCP 序号分别为 33, 34, 35, 那么此时内核会将三个 TCP 数据包拼接成一个之后向上层协议传递，这时还是可以理解的。但是对于 UDP 而言，<strong>大部分使用 UDP 作为传输协议的应用都依赖着 udp packet 边界的性质</strong>，比如 QUIC short packet 中，packet header 中并没有长度字段，完全是使用了 udp header 中的长度字段来隐式地指定了 short packet 的大小。那这时 GRO 将多个 UDP 数据包拼接成一个之后，上层应用还咋用这个边界信息来区分？</p>
<p>这个真的是 google 上找了半天，现实中问了一圈大佬都没搞清楚，直到最后快要弃疗的时候看到了内核关于 GRO/GSO 的单测 case 才大概了解了 UDP GRO 是如何拼接成，很简单就是 <strong> 仅当 UDP 数据包具有相同大小时，才会被拼接成一个大的 UDP 数据包，同时内核还会告诉上层应用原始 UDP 数据包的长度信息</strong>。这样上层应用在需要的时候也可以根据这个信息来确定 udp packet 边界。如 <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/torvalds/linux/master/tools/testing/selftests/net/udpgso_bench_rx.c">udpgso_bench_rx.c</a> 所示，当使用了 UDP GRO 之后，应用程序的收包姿势如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">recv_msg</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *buf, <span class="type">int</span> len, <span class="type">int</span> *gso_size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> control[CMSG_SPACE(<span class="keyword">sizeof</span>(<span class="type">uint16_t</span>))] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> *<span class="title">cmsg</span>;</span></span><br><span class="line">	<span class="type">uint16_t</span> *gsosizeptr;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	iov.iov_base = buf;</span><br><span class="line">	iov.iov_len = len;</span><br><span class="line"></span><br><span class="line">	msg.msg_iov = &amp;iov;</span><br><span class="line">	msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	msg.msg_control = control;</span><br><span class="line">	msg.msg_controllen = <span class="keyword">sizeof</span>(control);</span><br><span class="line"></span><br><span class="line">	*gso_size = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 假如，发送端发送的是 1200, 1200, 1100, 1200, 1200, 1200 的六个包</span></span><br><span class="line">	<span class="comment">// 那么，接收端需要调用 3 次 recv_msg 接口，才能将发送端的六个包完整的接收到</span></span><br><span class="line">	<span class="comment">// 第一次，接收一个长度为 2400 的数据块存到 buf 中，*gso_size 的值为 1200，函数返回后用户根据 gso_size 来切分包</span></span><br><span class="line">	<span class="comment">// 第二次，接收一个长度为 1100 的数据块存到 buf 中，*gso_size 的值为 1100，函数返回后用户根据 gso_size 来切分包</span></span><br><span class="line">	<span class="comment">// 第三次，接收一个长度为 3600 的数据块存到 buf 中，*gso_size 的值为 1200，函数返回后用户根据 gso_size 来切分包</span></span><br><span class="line">	ret = recvmsg(fd, &amp;msg, MSG_TRUNC | MSG_DONTWAIT);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (cmsg = CMSG_FIRSTHDR(&amp;msg); cmsg != <span class="literal">NULL</span>;</span><br><span class="line">		     cmsg = CMSG_NXTHDR(&amp;msg, cmsg)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (cmsg-&gt;cmsg_level == SOL_UDP &amp;&amp; cmsg-&gt;cmsg_type == UDP_GRO) &#123;</span><br><span class="line">				gsosizeptr = (<span class="type">uint16_t</span> *) CMSG_DATA(cmsg);</span><br><span class="line">				*gso_size = *gsosizeptr;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 <code>recv_msg()</code> 返回后，<code>[buf, len)</code> 中存放的 <strong> 可能是一个或多个</strong> UDP 数据包拼接之后的内容，此时 <code>*gso_size</code> 存放着每个原始 UDP 数据包的大小。对于应用来说，它可以以 <code>*gso_size</code> 来切分 buf，然后处理每一个数据包，即中间位置的数据对应的原始 UDP 数据包大小总是为 <code>*gso_size</code>, 最后剩下的数据对应 UDP 数据包大小可能会小于 <code>*gsosize</code>。</p>
<h1 id="UDP 性能提升（实践部分）">UDP 性能提升（实践部分）</h1>
<h2 id="开启 - 禁用 -socket-level- 的 -GSO">开启 &amp; 禁用 socket-level 的 GSO</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GSO_SIZE (1500 - 20 - 8) <span class="comment">// 最大 GSO 分段大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 启用 UDP GSO</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">enable_udp_gso</span><span class="params">(<span class="type">int</span> sockfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> gso_size = GSO_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sockfd, SOL_UDP, UDP_SEGMENT, &amp;gso_size, <span class="keyword">sizeof</span>(gso_size)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt UDP_SEGMENT failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;UDP GSO enabled with segment size: %d\n&quot;</span>, gso_size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁用 UDP GSO</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">disable_udp_gso</span><span class="params">(<span class="type">int</span> sockfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> gso_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sockfd, SOL_UDP, UDP_SEGMENT, &amp;gso_size, <span class="keyword">sizeof</span>(gso_size)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt UDP_SEGMENT disable failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;UDP GSO disabled\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="不同系统调用发送相同字节数据（客户端侧）">不同系统调用发送相同字节数据（客户端侧）</h2>
<p>每个接口均发送 <code>num_packets</code> 个 <code>packet_size</code> 字节的数据，共计发送 <code>packet_size * num_packets</code> 字节，但是使用不同的系统调用和调优策略。</p>
<h3 id="sendto- 发送多个小包">sendto(发送多个小包)</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">send_sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr_in *dest_addr,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> packet_size, <span class="type">int</span> num_packets)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> total_size = packet_size * num_packets;</span><br><span class="line">    <span class="type">size_t</span> total_sent_size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>  *send_buffer = <span class="built_in">malloc</span>(packet_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!send_buffer) &#123;</span><br><span class="line">        perror(<span class="string">&quot;malloc failed for send buffer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(send_buffer, <span class="string">&#x27;X&#x27;</span>, packet_size);</span><br><span class="line">    send_buffer[packet_size - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sending %d packets using sendto, total buffer: %zu bytes\n&quot;</span>, </span><br><span class="line">        num_packets, total_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_packets; i++) &#123;</span><br><span class="line">        <span class="type">int</span> written = <span class="built_in">snprintf</span>(send_buffer, packet_size, </span><br><span class="line">            <span class="string">&quot;Send packet %d at timestamp: %ld, total packets: %d&quot;</span>,</span><br><span class="line">            i, time(<span class="literal">NULL</span>), num_packets);</span><br><span class="line">        send_buffer[written] = <span class="string">&#x27;X&#x27;</span>; <span class="comment">// 去掉结束符，方便 recvfrom 能打印整个缓冲区</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ssize_t</span> sent = sendto(sockfd, send_buffer, packet_size, <span class="number">0</span>,</span><br><span class="line">            (<span class="keyword">struct</span> sockaddr *)dest_addr, <span class="keyword">sizeof</span>(*dest_addr));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;sendto without GSO failed&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            total_sent_size += sent;</span><br><span class="line">            <span class="comment">// printf(&quot;Send sent %zd bytes, expected %u bytes\n&quot;, sent, packet_size);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Approximately %zd packets sent without GSO, total sent %lu bytes\n&quot;</span>,</span><br><span class="line">        total_sent_size / packet_size, total_sent_size);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(send_buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sendto-GSO- 发送一个大包">sendto+GSO(发送一个大包)</h3>
<p>前置条件：先调用 <code>enable_udp_gso(sockfd)</code> 接口开启指定 sockfd 的 GSO。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">send_gso_batch</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr_in *dest_addr,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> packet_size, <span class="type">int</span> num_packets)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 计算总缓冲区大小</span></span><br><span class="line">    <span class="type">size_t</span> total_size = packet_size * num_packets;</span><br><span class="line">    <span class="type">char</span>  *gso_buffer = <span class="built_in">malloc</span>(total_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!gso_buffer) &#123;</span><br><span class="line">        perror(<span class="string">&quot;malloc failed for GSO buffer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(gso_buffer, <span class="string">&#x27;X&#x27;</span>, total_size);</span><br><span class="line">    gso_buffer[total_size - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备数据，初始化每个小包的前 N 个字节</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_packets; i++) &#123;</span><br><span class="line">        <span class="type">char</span> *packet_start = gso_buffer + (i * packet_size);</span><br><span class="line">        <span class="type">int</span>   written = <span class="built_in">snprintf</span>(packet_start, packet_size,</span><br><span class="line">              <span class="string">&quot;GSO Batch packet %d at timestamp: %ld, total packets: %d&quot;</span>,</span><br><span class="line">              i, time(<span class="literal">NULL</span>), num_packets);</span><br><span class="line">        packet_start[written] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sending %d packets using UDP GSO, total buffer: %zu bytes\n&quot;</span>,</span><br><span class="line">        num_packets, total_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 GSO 一次性发送整个连续的超级缓冲区</span></span><br><span class="line">    <span class="type">ssize_t</span> sent = sendto(sockfd, gso_buffer, total_size, <span class="number">0</span>,</span><br><span class="line">        (<span class="keyword">struct</span> sockaddr *)dest_addr, <span class="keyword">sizeof</span>(*dest_addr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sendto with GSO failed&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;GSO sent %zd bytes, expected %zu bytes\n&quot;</span>, sent, total_size);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Approximately %zd packets sent via GSO\n&quot;</span>, sent / packet_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(gso_buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sendmsg-GSO-Scatter-Gather 发送多个小包">sendmsg+GSO(Scatter-Gather 发送多个小包)</h3>
<p>前置条件：如果启用 <code>is_segment</code>，需要先调用 <code>enable_udp_gso(sockfd)</code> 接口开启指定 sockfd 的 GSO。</p>
<p>该接口实现的是：通过一次 <code>sendmsg</code> 系统调用，发送一个 <code>struct msghdr</code>。该结构体中包含一个 <code>struct iovec *</code> 数组（其长度为 <code>num_packets</code>），该数组的每个元素中，又包含一个 UDP datagram（长度为 <code>packet_size</code>）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">send_gso_batch_sendmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr_in *dest_addr,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> packet_size, <span class="type">int</span> num_packets, <span class="type">int</span> is_segment)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一次性分配所有内存：packet_buffers 数组 + iovec 数组 + 所有数据包缓冲区</span></span><br><span class="line">    <span class="type">size_t</span> total_buffer_size = (<span class="type">size_t</span>)packet_size * num_packets;</span><br><span class="line">    <span class="type">char</span>  *memory_block = <span class="built_in">malloc</span>(num_packets * <span class="keyword">sizeof</span>(<span class="type">char</span> *) + num_packets * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iovec) + total_buffer_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!memory_block) &#123;</span><br><span class="line">        perror(<span class="string">&quot;malloc failed for memory block&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(memory_block, <span class="string">&#x27;X&#x27;</span>, total_buffer_size);</span><br><span class="line">    memory_block[total_buffer_size - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置指针位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">msg_iov</span> =</span> (<span class="keyword">struct</span> iovec *)(memory_block + num_packets * <span class="keyword">sizeof</span>(<span class="type">char</span> *));</span><br><span class="line">    <span class="type">char</span>         *data_buffer = (<span class="type">char</span> *)(memory_block + num_packets * <span class="keyword">sizeof</span>(<span class="type">char</span> *) + num_packets * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iovec));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数据包和 iovec</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_packets; i++) &#123;</span><br><span class="line">        <span class="type">char</span> *packet_start = data_buffer + (i * packet_size);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> written = <span class="built_in">snprintf</span>(packet_start, packet_size,</span><br><span class="line">            <span class="string">&quot;Optimized Merged Batch packet %d at timestamp: %ld, total packets: %d&quot;</span>,</span><br><span class="line">            i, time(<span class="literal">NULL</span>), num_packets);</span><br><span class="line">        packet_start[written] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        msg_iov[i].iov_base = packet_start;</span><br><span class="line">        msg_iov[i].iov_len = packet_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 msghdr</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    msg.msg_name = (<span class="type">void</span> *)dest_addr;</span><br><span class="line">    msg.msg_namelen = <span class="keyword">sizeof</span>(*dest_addr);</span><br><span class="line">    msg.msg_iov = msg_iov;</span><br><span class="line">    msg.msg_iovlen = num_packets;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_segment) &#123;</span><br><span class="line">        <span class="comment">// 分配控制消息缓冲区</span></span><br><span class="line">        <span class="type">char</span> control[CMSG_SPACE(<span class="keyword">sizeof</span>(<span class="type">uint16_t</span>))];</span><br><span class="line">        msg.msg_control = control;</span><br><span class="line">        msg.msg_controllen = <span class="keyword">sizeof</span>(control);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 UDP_SEGMENT 控制消息</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> *<span class="title">cm</span> =</span> CMSG_FIRSTHDR(&amp;msg);</span><br><span class="line">        cm-&gt;cmsg_level = SOL_UDP;</span><br><span class="line">        cm-&gt;cmsg_type = UDP_SEGMENT;</span><br><span class="line">        cm-&gt;cmsg_len = CMSG_LEN(<span class="keyword">sizeof</span>(<span class="type">uint16_t</span>));</span><br><span class="line">        *((<span class="type">uint16_t</span> *)CMSG_DATA(cm)) = packet_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sending %d optimized merged packets, total size: %zu bytes\n&quot;</span>,</span><br><span class="line">        num_packets, total_buffer_size);</span><br><span class="line"></span><br><span class="line">    <span class="type">ssize_t</span> sent = sendmsg(sockfd, &amp;msg, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sendmsg with optimized merged packets failed&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Optimized merged batch sent %zd total bytes\n&quot;</span>, sent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(memory_block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sendmsg-GSO- 发送一个大包">sendmsg+GSO(发送一个大包)</h3>
<p>前置条件：如果启用 <code>is_segment</code>，需要先调用 <code>enable_udp_gso(sockfd)</code> 接口开启指定 sockfd 的 GSO。</p>
<p>该接口实现的是：通过一次 <code>sendmsg</code> 系统调用，发送一个 <code>struct msghdr</code>。该结构体中包含一个 <code>struct iovec *</code> 数组（其长度为 1），该数组又包含一个长度为 <code>packet_size * num_packets</code> 的 <strong> 连续的超级缓冲区，并由内核或更底层的 NIC 负责对超大包的分段卸载处理</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">send_gso_batch_improved</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr_in *dest_addr,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> packet_size, <span class="type">int</span> num_packets)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 计算总缓冲区大小</span></span><br><span class="line">    <span class="type">size_t</span> total_size = packet_size * num_packets;</span><br><span class="line">    <span class="type">char</span>  *gso_buffer = <span class="built_in">malloc</span>(total_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!gso_buffer) &#123;</span><br><span class="line">        perror(<span class="string">&quot;malloc failed for GSO buffer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(gso_buffer, <span class="string">&#x27;X&#x27;</span>, total_size);</span><br><span class="line">    gso_buffer[total_size - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备批量数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_packets; i++) &#123;</span><br><span class="line">        <span class="type">char</span> *packet_start = gso_buffer + (i * packet_size);</span><br><span class="line">        <span class="type">int</span>   written = <span class="built_in">snprintf</span>(packet_start, packet_size,</span><br><span class="line">              <span class="string">&quot;GSO Batch packet %d at timestamp: %ld, total packets: %d&quot;</span>,</span><br><span class="line">              i, time(<span class="literal">NULL</span>), num_packets);</span><br><span class="line">        packet_start[written] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sending %d packets using UDP GSO, total buffer: %zu bytes\n&quot;</span>,</span><br><span class="line">        num_packets, total_size);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> =</span> &#123;</span><br><span class="line">        .iov_base = gso_buffer,</span><br><span class="line">        .iov_len = total_size</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span> =</span> &#123;</span><br><span class="line">        .msg_name = dest_addr,</span><br><span class="line">        .msg_namelen = <span class="keyword">sizeof</span>(*dest_addr),</span><br><span class="line">        .msg_iov = &amp;iov,</span><br><span class="line">        .msg_iovlen = <span class="number">1</span>,</span><br><span class="line">        .msg_control = <span class="literal">NULL</span>, <span class="comment">// 使用 socket-level GSO 可以不加控制信息</span></span><br><span class="line">        .msg_controllen = <span class="number">0</span>,</span><br><span class="line">        .msg_flags = <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// disable_udp_gso 时加控制信息</span></span><br><span class="line">    <span class="type">char</span> control[CMSG_SPACE(<span class="keyword">sizeof</span>(<span class="type">uint16_t</span>))] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    msg.msg_control = control;</span><br><span class="line">    msg.msg_controllen = <span class="keyword">sizeof</span>(control);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> *<span class="title">cm</span> =</span> CMSG_FIRSTHDR(&amp;msg);</span><br><span class="line">    cm-&gt;cmsg_level = SOL_UDP;</span><br><span class="line">    cm-&gt;cmsg_type = UDP_SEGMENT;</span><br><span class="line">    cm-&gt;cmsg_len = CMSG_LEN(<span class="keyword">sizeof</span>(<span class="type">uint16_t</span>));</span><br><span class="line">    *((<span class="type">uint16_t</span> *)CMSG_DATA(cm)) = GSO_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="type">ssize_t</span> sent = sendmsg(sockfd, &amp;msg, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sendmsg with GSO failed&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;GSO sent %zd bytes, expected %zu bytes, Approximately %zd packets sent via GSO\n&quot;</span>, </span><br><span class="line">            sent, total_size, sent / packet_size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sent != total_size) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Warn: Sent %zd bytes less than expected (packet fragmentation may occur)\n&quot;</span>,</span><br><span class="line">                total_size - sent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(gso_buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sendmmsg-W-O-GSO- 批量发送小包">sendmmsg+W/O GSO(批量发送小包)</h3>
<p>前置条件：无（不需要启用 GSO）。</p>
<p>该接口实现的是：批量发送小包。通过一次 <code>sendmmsg</code> 系统调用，发送一个 <code>struct mmsghdr</code> 数组（其长度为 <code>num_packets</code>）。该结构体数组的每一个元素的成员 <code>struct msghdr</code> 中，又包含一个 <code>struct iovec *</code> 数组（其长度为 1），该数组又包含一个长度为 <code>packet_size</code> 的小包缓冲区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">send_mmsg_batch</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr_in *dest_addr,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> packet_size, <span class="type">int</span> num_packets)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mmsghdr</span> <span class="title">msgs</span>[<span class="title">num_packets</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>   <span class="title">iovecs</span>[<span class="title">num_packets</span>];</span></span><br><span class="line">    <span class="type">char</span>          *buffers[num_packets];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备每个消息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_packets; i++) &#123;</span><br><span class="line">        buffers[i] = <span class="built_in">malloc</span>(packet_size);</span><br><span class="line">        <span class="keyword">if</span> (!buffers[i]) &#123;</span><br><span class="line">            perror(<span class="string">&quot;malloc failed for mmsg buffer&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="built_in">free</span>(buffers[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(buffers[i], <span class="string">&#x27;X&#x27;</span>, packet_size);</span><br><span class="line">        buffers[i][packet_size - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> written = <span class="built_in">snprintf</span>(buffers[i], packet_size,</span><br><span class="line">            <span class="string">&quot;sendmmsg packet %d at timestamp: %ld&quot;</span>,</span><br><span class="line">            i, time(<span class="literal">NULL</span>));</span><br><span class="line">        buffers[i][written] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        iovecs[i].iov_base = buffers[i];</span><br><span class="line">        iovecs[i].iov_len = packet_size; <span class="comment">// 使用完整的数据包大小</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;msgs[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(msgs[i]));</span><br><span class="line">        msgs[i].msg_hdr.msg_name = dest_addr;</span><br><span class="line">        msgs[i].msg_hdr.msg_namelen = <span class="keyword">sizeof</span>(*dest_addr);</span><br><span class="line">        msgs[i].msg_hdr.msg_iov = &amp;iovecs[i];</span><br><span class="line">        msgs[i].msg_hdr.msg_iovlen = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sending %d packets using sendmmsg\n&quot;</span>, num_packets);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = sendmmsg(sockfd, msgs, num_packets, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sendmmsg failed&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sendmmsg sent %d out of %d packets\n&quot;</span>, ret, num_packets);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计发送的字节数</span></span><br><span class="line">        <span class="type">size_t</span> total_sent = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line">            total_sent += msgs[i].msg_len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Total bytes sent via sendmmsg: %zu\n&quot;</span>, total_sent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_packets; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(buffers[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sendmmsg-GSO- 批量发送小包">sendmmsg+GSO(批量发送小包)</h3>
<p>前置条件：先调用 <code>enable_udp_gso(sockfd)</code> 接口开启指定 sockfd 的 GSO。</p>
<p>该接口实现的是：批量发送小包。通过一次 <code>sendmmsg</code> 系统调用，发送一个 <code>struct mmsghdr</code> 数组（其长度为 <code>num_packets</code>）。该结构体数组的每一个元素的成员 <code>struct msghdr</code> 中，又包含一个 <code>struct iovec *</code> 数组（其长度为 1），该数组又包含一个长度为 <code>packet_size</code> 的小包缓冲区。与 <code>send_mmsg_batch</code> 的区别是，该接口加了 GSO 控制信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">send_mmsg_gso_batch</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr_in *dest_addr,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> packet_size, <span class="type">int</span> num_packets)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mmsghdr</span> <span class="title">msgs</span>[<span class="title">num_packets</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>   <span class="title">iovecs</span>[<span class="title">num_packets</span>];</span></span><br><span class="line">    <span class="type">char</span>          *buffers[num_packets];</span><br><span class="line">    <span class="type">char</span>          *control_buffers[num_packets]; <span class="comment">// 为每个消息分配控制缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备每个消息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_packets; i++) &#123;</span><br><span class="line">        buffers[i] = <span class="built_in">malloc</span>(packet_size);</span><br><span class="line">        <span class="keyword">if</span> (!buffers[i]) &#123;</span><br><span class="line">            perror(<span class="string">&quot;malloc failed for mmsg_gso buffer&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="built_in">free</span>(buffers[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(buffers[i], <span class="string">&#x27;X&#x27;</span>, packet_size);</span><br><span class="line">        buffers[i][packet_size - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> written = <span class="built_in">snprintf</span>(buffers[i], packet_size,</span><br><span class="line">            <span class="string">&quot;sendmmsg+GSO packet %d at timestamp: %ld&quot;</span>,</span><br><span class="line">            i, time(<span class="literal">NULL</span>));</span><br><span class="line">        buffers[i][written] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        iovecs[i].iov_base = buffers[i];</span><br><span class="line">        iovecs[i].iov_len = packet_size; <span class="comment">// 使用完整的数据包大小</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为控制消息分配空间</span></span><br><span class="line">        control_buffers[i] = <span class="built_in">malloc</span>(CMSG_SPACE(<span class="keyword">sizeof</span>(<span class="type">uint16_t</span>)));</span><br><span class="line">        <span class="keyword">if</span> (!control_buffers[i]) &#123;</span><br><span class="line">            perror(<span class="string">&quot;malloc failed for control buffer&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="built_in">free</span>(buffers[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="built_in">free</span>(control_buffers[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;msgs[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(msgs[i]));</span><br><span class="line">        msgs[i].msg_hdr.msg_name = dest_addr;</span><br><span class="line">        msgs[i].msg_hdr.msg_namelen = <span class="keyword">sizeof</span>(*dest_addr);</span><br><span class="line">        msgs[i].msg_hdr.msg_iov = &amp;iovecs[i];</span><br><span class="line">        msgs[i].msg_hdr.msg_iovlen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 GSO 控制信息</span></span><br><span class="line">        msgs[i].msg_hdr.msg_control = control_buffers[i];</span><br><span class="line">        msgs[i].msg_hdr.msg_controllen = CMSG_SPACE(<span class="keyword">sizeof</span>(<span class="type">uint16_t</span>));</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> *<span class="title">cmsg</span> =</span> CMSG_FIRSTHDR(&amp;msgs[i].msg_hdr);</span><br><span class="line">        cmsg-&gt;cmsg_level = SOL_UDP;</span><br><span class="line">        cmsg-&gt;cmsg_type = UDP_SEGMENT;</span><br><span class="line">        cmsg-&gt;cmsg_len = CMSG_LEN(<span class="keyword">sizeof</span>(<span class="type">uint16_t</span>));</span><br><span class="line">        *((<span class="type">uint16_t</span> *)CMSG_DATA(cmsg)) = GSO_SIZE; <span class="comment">// 设置 GSO 分段大小</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：msg_controllen 必须精确设置为控制消息的总长度</span></span><br><span class="line">        msgs[i].msg_hdr.msg_controllen = cmsg-&gt;cmsg_len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sending %d packets using sendmmsg + UDP GSO\n&quot;</span>, num_packets);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = sendmmsg(sockfd, msgs, num_packets, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sendmmsg with GSO failed&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sendmmsg+GSO sent %d out of %d packets\n&quot;</span>, ret, num_packets);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计发送的字节数</span></span><br><span class="line">        <span class="type">size_t</span> total_sent = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line">            total_sent += msgs[i].msg_len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Total bytes sent via sendmmsg+GSO: %zu\n&quot;</span>, total_sent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_packets; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(buffers[i]);</span><br><span class="line">        <span class="built_in">free</span>(control_buffers[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不同接口的性能对比测试">不同接口的性能对比测试</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 性能测试函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">performance_test</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr_in *dest_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>                iterations = <span class="number">10000</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>                packets_per_batch = <span class="number">32</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>                packet_size = <span class="number">1216</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> total_bits = <span class="number">8ULL</span> * iterations * packets_per_batch * packet_size;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n=== Performance Test ===\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Iterations: %d, Packets per batch: %d, Packet size: %d, GSO_SIZE: %d\n&quot;</span>,</span><br><span class="line">        iterations, packets_per_batch, packet_size, GSO_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 sendto</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n1. Testing sendto without GSO...\n&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start</span>, <span class="title">end</span>;</span></span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;start);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">        send_sendto(sockfd, dest_addr, packet_size, packets_per_batch);</span><br><span class="line">    &#125;</span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;end);</span><br><span class="line">    <span class="type">double</span> sendto_time = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / <span class="number">1e9</span>;</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 sendmmsg</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n2. Testing sendmmsg...\n&quot;</span>);</span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;start);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">        send_mmsg_batch(sockfd, dest_addr, packet_size, packets_per_batch);</span><br><span class="line">    &#125;</span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;end);</span><br><span class="line">    <span class="type">double</span> mmsg_time = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / <span class="number">1e9</span>;</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 UDP GSO + sendto 发大包</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n3. Testing UDP GSO (merge sendto)...\n&quot;</span>);</span><br><span class="line">    enable_udp_gso(sockfd); <span class="comment">// 启用 GSO</span></span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;start);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">        send_gso_batch(sockfd, dest_addr, packet_size, packets_per_batch);</span><br><span class="line">    &#125;</span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;end);</span><br><span class="line">    <span class="type">double</span> gso_time = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / <span class="number">1e9</span>;</span><br><span class="line">    disable_udp_gso(sockfd); <span class="comment">// 禁用 GSO</span></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 UDP GSO + scatter-gather sendmsg without segment</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n3. Testing UDP GSO (scatter-gather sendmsg without segment)...\n&quot;</span>);</span><br><span class="line">    enable_udp_gso(sockfd); <span class="comment">// 启用 GSO</span></span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;start);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">        send_gso_batch_sendmsg(sockfd, dest_addr, packet_size, packets_per_batch, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;end);</span><br><span class="line">    <span class="type">double</span> gso_sendmsg_time0 = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / <span class="number">1e9</span>;</span><br><span class="line">    disable_udp_gso(sockfd); <span class="comment">// 禁用 GSO</span></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 UDP GSO + scatter-gather sendmsg with segment</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n3. Testing UDP GSO (scatter-gather sendmsg with segment)...\n&quot;</span>);</span><br><span class="line">    enable_udp_gso(sockfd); <span class="comment">// 启用 GSO</span></span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;start);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">        send_gso_batch_sendmsg(sockfd, dest_addr, packet_size, packets_per_batch, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;end);</span><br><span class="line">    <span class="type">double</span> gso_sendmsg_time1 = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / <span class="number">1e9</span>;</span><br><span class="line">    disable_udp_gso(sockfd); <span class="comment">// 禁用 GSO</span></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 UDP GSO + sendmsg 发大包</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n4. Testing UDP GSO (merge sendmsg)...\n&quot;</span>);</span><br><span class="line">    <span class="comment">// enable_udp_gso(sockfd); // 启用 GSO</span></span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;start);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">        send_gso_batch_improved(sockfd, dest_addr, packet_size, packets_per_batch);</span><br><span class="line">    &#125;</span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;end);</span><br><span class="line">    <span class="type">double</span> gso_improved_time = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / <span class="number">1e9</span>;</span><br><span class="line">    <span class="comment">// disable_udp_gso(sockfd); // 禁用 GSO</span></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 sendmmsg + UDP GSO</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n5. Testing sendmmsg + UDP GSO...\n&quot;</span>);</span><br><span class="line">    enable_udp_gso(sockfd); <span class="comment">// 启用 GSO</span></span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;start);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">        send_mmsg_gso_batch(sockfd, dest_addr, packet_size, packets_per_batch);</span><br><span class="line">    &#125;</span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;end);</span><br><span class="line">    <span class="type">double</span> mmsg_gso_time = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / <span class="number">1e9</span>;</span><br><span class="line">    disable_udp_gso(sockfd); <span class="comment">// 禁用 GSO</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n=== Results ===\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test params: iterations=%d, packets_per_batch=%d, packet_size=%d, GSO_SIZE=%d, total_bits=%llu\n&quot;</span>,</span><br><span class="line">        iterations, packets_per_batch, packet_size, GSO_SIZE, total_bits);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sendto time: %.6f seconds, bitrate=%.2f Mbps\n&quot;</span>, sendto_time, total_bits / <span class="number">1e6</span> / sendto_time);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sendmmsg time: %.6f seconds, bitrate=%.2f Mbps\n&quot;</span>, mmsg_time, total_bits / <span class="number">1e6</span> / mmsg_time);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;UDP GSO(merge sendto) time: %.6f seconds, bitrate=%.2f Mbps\n&quot;</span>, gso_time, total_bits / <span class="number">1e6</span> / gso_time);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;UDP GSO(scatter-gather sendmsg without segment) time: %.6f seconds, bitrate=%.2f Mbps\n&quot;</span>, gso_sendmsg_time0, total_bits / <span class="number">1e6</span> / gso_sendmsg_time0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;UDP GSO(scatter-gather sendmsg with segment) time: %.6f seconds, bitrate=%.2f Mbps\n&quot;</span>, gso_sendmsg_time1, total_bits / <span class="number">1e6</span> / gso_sendmsg_time1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;UDP GSO(merge sendmsg) time: %.6f seconds, bitrate=%.2f Mbps\n&quot;</span>, gso_improved_time, total_bits / <span class="number">1e6</span> / gso_improved_time);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sendmmsg + UDP GSO time: %.6f seconds, bitrate=%.2f Mbps\n&quot;</span>, mmsg_gso_time, total_bits / <span class="number">1e6</span> / mmsg_gso_time);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sendmmsg speedup over sendto: %.2fx\n&quot;</span>, sendto_time / mmsg_time);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;GSO(merge sendto) speedup over sendto: %.2fx\n&quot;</span>, sendto_time / gso_time);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;GSO(scatter-gather sendmsg without segment) speedup over sendto: %.2fx\n&quot;</span>, sendto_time / gso_sendmsg_time0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;GSO(scatter-gather sendmsg with segment) speedup over sendto: %.2fx\n&quot;</span>, sendto_time / gso_sendmsg_time1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;GSO(merge sendmsg) speedup over sendto: %.2fx\n&quot;</span>, sendto_time / gso_improved_time);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sendmmsg + UDP GSO speedup over sendto: %.2fx\n&quot;</span>, sendto_time / mmsg_gso_time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试结果">测试结果</h3>
<p>系统与硬件信息：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@svr22 ~]<span class="comment"># uname -a</span></span><br><span class="line">Linux svr22 5.15.117 <span class="comment">#1 SMP Mon Mar 24 07:44:16 CST 2025 x86_64 x86_64 x86_64 GNU/Linux</span></span><br><span class="line">[root@svr22 ~]<span class="comment"># ethtool ens7f0np0 | grep Speed</span></span><br><span class="line">        Speed: 100000Mb/s</span><br><span class="line">[root@svr22 ~]<span class="comment"># ethtool -i ens7f0np0 | grep bus-info</span></span><br><span class="line">bus-info: 0000:d8:00.0</span><br><span class="line">[root@svr22 ~]<span class="comment"># lspci | grep d8:00.0</span></span><br><span class="line">d8:00.0 Ethernet controller: Mellanox Technologies MT27800 Family [ConnectX-5]</span><br><span class="line">[root@svr22 ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>系统缓冲区配置：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">100G：</span><br><span class="line">sudo sysctl -w net.core.wmem_max=134217728</span><br><span class="line">sudo sysctl -w net.core.wmem_default=134217728</span><br><span class="line">sudo sysctl -w net.core.rmem_max=134217728</span><br><span class="line">sudo sysctl -w net.core.rmem_default=134217728</span><br><span class="line"></span><br><span class="line">ethtool -K ens7f0np0 gso on</span><br><span class="line">ethtool -K ens7f0np0 gro on</span><br><span class="line">ethtool -K ens7f0np0 tx-udp-segmentation on</span><br><span class="line">ethtool -K ens7f0np0 rx-udp-gro-forwarding on</span><br><span class="line">ethtool -K ens7f0np0 rx-gro-list on</span><br></pre></td></tr></table></figure>
<p>所有接口全部执行一次：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> packet_size = <span class="number">1216</span>;</span><br><span class="line"><span class="type">int</span> num_packets = <span class="number">32</span>;</span><br><span class="line"><span class="type">int</span> mode = <span class="number">0</span>; <span class="comment">// 0: 全部执行, 1-6: 执行单个模式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    mode = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (mode) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// 全部执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n=== sendto(without GSO) Example ===\n&quot;</span>);</span><br><span class="line">    send_sendto(sockfd, &amp;dest_addr, packet_size, num_packets);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n=== sendmmsg Example ===\n&quot;</span>);</span><br><span class="line">    send_mmsg_batch(sockfd, &amp;dest_addr, packet_size, num_packets);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n=== UDP GSO(merge sendto) Example ===\n&quot;</span>);</span><br><span class="line">    enable_udp_gso(sockfd);</span><br><span class="line">    send_gso_batch(sockfd, &amp;dest_addr, packet_size, num_packets);</span><br><span class="line">    disable_udp_gso(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n=== UDP GSO(scatter-gather sendmsg without segment) Example ===\n&quot;</span>);</span><br><span class="line">    enable_udp_gso(sockfd);</span><br><span class="line">    send_gso_batch_sendmsg(sockfd, &amp;dest_addr, packet_size, num_packets, <span class="number">0</span>);</span><br><span class="line">    disable_udp_gso(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n=== UDP GSO(scatter-gather sendmsg with segment) Example ===\n&quot;</span>);</span><br><span class="line">    enable_udp_gso(sockfd);</span><br><span class="line">    send_gso_batch_sendmsg(sockfd, &amp;dest_addr, packet_size, num_packets, <span class="number">1</span>);</span><br><span class="line">    disable_udp_gso(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n=== UDP GSO(merge sendmsg) Example ===\n&quot;</span>);</span><br><span class="line">    enable_udp_gso(sockfd);</span><br><span class="line">    send_gso_batch_improved(sockfd, &amp;dest_addr, packet_size, num_packets);</span><br><span class="line">    disable_udp_gso(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n=== sendmmsg + UDP GSO Example ===\n&quot;</span>);</span><br><span class="line">    enable_udp_gso(sockfd);</span><br><span class="line">    send_mmsg_gso_batch(sockfd, &amp;dest_addr, packet_size, num_packets);</span><br><span class="line">    disable_udp_gso(sockfd);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>客户端输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[root@svr22 202509281610]# ./client7_udp_gso_test 0</span><br><span class="line">=== sendto(without GSO) Example ===</span><br><span class="line">Sending 32 packets using sendto, total buffer: 38912 bytes</span><br><span class="line">Approximately 32 packets sent without GSO, total sent 38912 bytes</span><br><span class="line"></span><br><span class="line">=== sendmmsg Example ===</span><br><span class="line">Sending 32 packets using sendmmsg</span><br><span class="line">sendmmsg sent 32 out of 32 packets</span><br><span class="line">Total bytes sent via sendmmsg: 38912</span><br><span class="line"></span><br><span class="line">=== UDP GSO(merge sendto) Example ===</span><br><span class="line">UDP GSO enabled with segment size: 1472</span><br><span class="line">Sending 32 packets using UDP GSO, total buffer: 38912 bytes</span><br><span class="line">GSO sent 38912 bytes, expected 38912 bytes</span><br><span class="line">Approximately 32 packets sent via GSO</span><br><span class="line">UDP GSO disabled</span><br><span class="line"></span><br><span class="line">=== UDP GSO(scatter-gather sendmsg without segment) Example ===</span><br><span class="line">UDP GSO enabled with segment size: 1472</span><br><span class="line">Sending 32 optimized merged packets, total size: 38912 bytes</span><br><span class="line">Optimized merged batch sent 38912 total bytes</span><br><span class="line">UDP GSO disabled</span><br><span class="line"></span><br><span class="line">=== UDP GSO(scatter-gather sendmsg with segment) Example ===</span><br><span class="line">UDP GSO enabled with segment size: 1472</span><br><span class="line">Sending 32 optimized merged packets, total size: 38912 bytes</span><br><span class="line">Optimized merged batch sent 38912 total bytes</span><br><span class="line">UDP GSO disabled</span><br><span class="line"></span><br><span class="line">=== UDP GSO(merge sendmsg) Example ===</span><br><span class="line">UDP GSO enabled with segment size: 1472</span><br><span class="line">Sending 32 packets using UDP GSO, total buffer: 38912 bytes</span><br><span class="line">GSO sent 38912 bytes, expected 38912 bytes, Approximately 32 packets sent via GSO</span><br><span class="line">UDP GSO disabled</span><br><span class="line"></span><br><span class="line">=== sendmmsg + UDP GSO Example ===</span><br><span class="line">UDP GSO enabled with segment size: 1472</span><br><span class="line">Sending 32 packets using sendmmsg + UDP GSO</span><br><span class="line">sendmmsg+GSO sent 32 out of 32 packets</span><br><span class="line">Total bytes sent via sendmmsg+GSO: 38912</span><br><span class="line">UDP GSO disabled</span><br></pre></td></tr></table></figure>
<p>服务端输出（可能分多批接收，但最终接收到的总字节数会与发送端一致）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[root@svr20 202509281610]# ./server7_udp_gso_test 1</span><br><span class="line">UDP GSO Receiver listening on port 8888...</span><br><span class="line">Using simple recvfrom mode</span><br><span class="line">Received packet 1 from 192.168.110.222:45888, size: 10944 bytes</span><br><span class="line">  Likely GSO packet, containing multiple segments</span><br><span class="line">Received packet 2 from 192.168.110.222:45888, size: 59584 bytes</span><br><span class="line">  Likely GSO packet, containing multiple segments</span><br><span class="line">Received packet 3 from 192.168.110.222:45888, size: 7296 bytes</span><br><span class="line">  Likely GSO packet, containing multiple segments</span><br><span class="line">Received packet 4 from 192.168.110.222:45888, size: 38912 bytes</span><br><span class="line">  Likely GSO packet, containing multiple segments</span><br><span class="line">Received packet 5 from 192.168.110.222:45888, size: 38912 bytes</span><br><span class="line">  Likely GSO packet, containing multiple segments</span><br><span class="line">Received packet 6 from 192.168.110.222:45888, size: 38912 bytes</span><br><span class="line">  Likely GSO packet, containing multiple segments</span><br><span class="line">Received packet 7 from 192.168.110.222:45888, size: 38912 bytes</span><br><span class="line">  Likely GSO packet, containing multiple segments</span><br><span class="line">Received packet 8 from 192.168.110.222:45888, size: 38912 bytes</span><br><span class="line">  Likely GSO packet, containing multiple segments</span><br><span class="line"></span><br><span class="line">[root@svr20 202509281610]# ./server7_udp_gso_test 3</span><br><span class="line">UDP GSO Receiver listening on port 8888...</span><br><span class="line">Using recvmsg mode with GRO support</span><br><span class="line">Received packet 1 from 192.168.110.222:34281, size: 3648 bytes</span><br><span class="line">  GSO packet detected, segment size: 1216 bytes</span><br><span class="line">Received packet 2 from 192.168.110.222:34281, size: 4864 bytes</span><br><span class="line">  GSO packet detected, segment size: 1216 bytes</span><br><span class="line">Received packet 3 from 192.168.110.222:34281, size: 4864 bytes</span><br><span class="line">  GSO packet detected, segment size: 1216 bytes</span><br><span class="line">Received packet 4 from 192.168.110.222:34281, size: 4864 bytes</span><br><span class="line">  GSO packet detected, segment size: 1216 bytes</span><br><span class="line">Received packet 5 from 192.168.110.222:34281, size: 2432 bytes</span><br><span class="line">  GSO packet detected, segment size: 1216 bytes</span><br><span class="line">Received packet 6 from 192.168.110.222:34281, size: 1216 bytes</span><br><span class="line">Received packet 7 from 192.168.110.222:34281, size: 2432 bytes</span><br><span class="line">Received packet 8 from 192.168.110.222:34281, size: 2432 bytes</span><br><span class="line">Received packet 9 from 192.168.110.222:34281, size: 2432 bytes</span><br><span class="line">Received packet 10 from 192.168.110.222:34281, size: 2432 bytes</span><br><span class="line">Received packet 11 from 192.168.110.222:34281, size: 7296 bytes</span><br><span class="line">Received packet 12 from 192.168.110.222:34281, size: 2432 bytes</span><br><span class="line">Received packet 13 from 192.168.110.222:34281, size: 36480 bytes</span><br><span class="line">Received packet 14 from 192.168.110.222:34281, size: 38912 bytes</span><br><span class="line">Received packet 15 from 192.168.110.222:34281, size: 38912 bytes</span><br><span class="line">Received packet 16 from 192.168.110.222:34281, size: 38912 bytes</span><br><span class="line">Received packet 17 from 192.168.110.222:34281, size: 38912 bytes</span><br><span class="line">Received packet 18 from 192.168.110.222:34281, size: 1216 bytes</span><br><span class="line">Received packet 19 from 192.168.110.222:34281, size: 37696 bytes</span><br></pre></td></tr></table></figure>
<p>迭代多轮，性能结果（bitrate 只表明通过系统调用发送这些数据的速率，可能不能反应真实的发送速率，更不能表现接收速率）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">=== Results ===</span><br><span class="line">test params: iterations=10000, packets_per_batch=32, packet_size=1216, GSO_SIZE=1472, total_bits=3112960000</span><br><span class="line">sendto time: 0.974089 seconds, bitrate=3195.76 Mbps</span><br><span class="line">sendmmsg time: 0.763818 seconds, bitrate=4075.52 Mbps</span><br><span class="line">UDP GSO(merge sendto) time: 0.299842 seconds, bitrate=10382.01 Mbps</span><br><span class="line">UDP GSO(scatter-gather sendmsg without segment) time: 0.290046 seconds, bitrate=10732.66 Mbps</span><br><span class="line">UDP GSO(scatter-gather sendmsg with segment) time: 0.287964 seconds, bitrate=10810.25 Mbps</span><br><span class="line">UDP GSO(merge sendmsg) time: 0.272673 seconds, bitrate=11416.46 Mbps</span><br><span class="line">sendmmsg + UDP GSO time: 0.856162 seconds, bitrate=3635.95 Mbps</span><br><span class="line">sendmmsg speedup over sendto: 1.28x</span><br><span class="line">GSO(merge sendto) speedup over sendto: 3.25x</span><br><span class="line">GSO(scatter-gather sendmsg without segment) speedup over sendto: 3.36x</span><br><span class="line">GSO(scatter-gather sendmsg with segment) speedup over sendto: 3.38x</span><br><span class="line">GSO(merge sendmsg) speedup over sendto: 3.57x</span><br><span class="line">sendmmsg + UDP GSO speedup over sendto: 1.14x</span><br></pre></td></tr></table></figure>
<img src="../images/udp-accelerating/perf-cmp.png" alt="perf-cmp" width="100%" height="100%">
<h2 id="完整代码">完整代码</h2>
<h2 id="接收侧（服务端）">接收侧（服务端）</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SOL_UDP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOL_UDP (17)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UDP_SEGMENT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UDP_SEGMENT (103)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UDP_GRO</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UDP_GRO (104)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8888</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 65536</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GSO_SIZE (1500 - 20 - 8) <span class="comment">// 最大 GSO 分段大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    RECV_MODE_SIMPLE = <span class="number">1</span>,</span><br><span class="line">    RECV_MODE_MMSG,</span><br><span class="line">    RECV_MODE_MSG</span><br><span class="line">&#125; <span class="type">recv_mode_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">simple_recv_mode</span><span class="params">(<span class="type">int</span> sockfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span>          addr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    <span class="type">char</span>               buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span>                packet_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Using simple recvfrom mode\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// memset(buffer, 0, BUFFER_SIZE);</span></span><br><span class="line">        <span class="type">int</span> n = recvfrom(sockfd, buffer, BUFFER_SIZE, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr, &amp;addr_len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            packet_count++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Received packet %d from %s:%d, size: %d bytes\n&quot;</span>,</span><br><span class="line">                packet_count, inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port), n);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">1500</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;  Likely GSO packet, containing multiple segments\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> print_len = n &lt; <span class="number">100</span> ? n : <span class="number">100</span>;</span><br><span class="line">            <span class="comment">// printf(&quot;  Data: %.*s\n&quot;, print_len, buffer);</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span> &amp;&amp; errno != EAGAIN &amp;&amp; errno != EWOULDBLOCK) &#123;</span><br><span class="line">            perror(<span class="string">&quot;recvfrom failed&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmsg_recv_mode</span><span class="params">(<span class="type">int</span> sockfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>          vlen = <span class="number">256</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>          bufsize = <span class="number">1500</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>    <span class="title">peer_addrs</span>[<span class="title">vlen</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mmsghdr</span>     <span class="title">msgs</span>[<span class="title">vlen</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>       <span class="title">iovecs</span>[<span class="title">vlen</span>];</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>      bufs[vlen][bufsize];</span><br><span class="line">    <span class="type">int</span>                packet_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Using recvmmsg mode\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(msgs, <span class="number">0</span>, <span class="keyword">sizeof</span>(msgs));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">        iovecs[i].iov_base = bufs[i];</span><br><span class="line">        iovecs[i].iov_len = bufsize;</span><br><span class="line">        msgs[i].msg_hdr.msg_iov = &amp;iovecs[i];</span><br><span class="line">        msgs[i].msg_hdr.msg_iovlen = <span class="number">1</span>;</span><br><span class="line">        msgs[i].msg_hdr.msg_name = &amp;peer_addrs[i];</span><br><span class="line">        msgs[i].msg_hdr.msg_namelen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> n = recvmmsg(sockfd, msgs, vlen, MSG_DONTWAIT, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                packet_count++;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">client_addr_ptr</span> =</span> (<span class="keyword">struct</span> sockaddr_in *)&amp;peer_addrs[i];</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Received packet %d from %s:%d, size: %d bytes\n&quot;</span>,</span><br><span class="line">                    packet_count, inet_ntoa(client_addr_ptr-&gt;sin_addr),</span><br><span class="line">                    ntohs(client_addr_ptr-&gt;sin_port), msgs[i].msg_len);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (msgs[i].msg_len &gt; <span class="number">1500</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;  Likely GSO packet, containing multiple segments\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> print_len = msgs[i].msg_len &lt; <span class="number">100</span> ? msgs[i].msg_len : <span class="number">100</span>;</span><br><span class="line">                <span class="comment">// printf(&quot;  Data: %.*s\n&quot;, print_len, (char *)iovecs[i].iov_base);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span> &amp;&amp; errno != EAGAIN &amp;&amp; errno != EWOULDBLOCK) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recvmmsg failed: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">msg_recv_mode</span><span class="params">(<span class="type">int</span> sockfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span>          peer_addrlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>      bufs[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span>                packet_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Using recvmsg mode with GRO support\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">peer_addr</span>;</span></span><br><span class="line">    <span class="type">char</span>            control[CMSG_SPACE(<span class="keyword">sizeof</span>(<span class="type">int</span>))] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span>   <span class="title">msg</span> =</span> &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>    <span class="title">iov</span> =</span> &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> *<span class="title">cmsg</span>;</span></span><br><span class="line">    <span class="type">int</span>             recv_bytes;</span><br><span class="line"></span><br><span class="line">    iov.iov_base = bufs;</span><br><span class="line">    iov.iov_len = BUFFER_SIZE;</span><br><span class="line"></span><br><span class="line">    msg.msg_iov = &amp;iov;</span><br><span class="line">    msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line">    msg.msg_name = &amp;peer_addr;</span><br><span class="line">    msg.msg_namelen = peer_addrlen;</span><br><span class="line">    msg.msg_control = control;</span><br><span class="line">    msg.msg_controllen = <span class="keyword">sizeof</span>(control);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        recv_bytes = recvmsg(sockfd, &amp;msg, MSG_DONTWAIT);</span><br><span class="line">        <span class="keyword">if</span> (recv_bytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> gso_size = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (cmsg = CMSG_FIRSTHDR(&amp;msg); cmsg != <span class="literal">NULL</span>; cmsg = CMSG_NXTHDR(&amp;msg, cmsg)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cmsg-&gt;cmsg_level == SOL_UDP &amp;&amp; cmsg-&gt;cmsg_type == UDP_GRO) &#123;</span><br><span class="line">                    gso_size = *(<span class="type">int</span> *)CMSG_DATA(cmsg);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            packet_count++;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">client_addr_ptr</span> =</span> (<span class="keyword">struct</span> sockaddr_in *)&amp;peer_addr;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Received packet %d from %s:%d, size: %d bytes\n&quot;</span>,</span><br><span class="line">                packet_count, inet_ntoa(client_addr_ptr-&gt;sin_addr),</span><br><span class="line">                ntohs(client_addr_ptr-&gt;sin_port), recv_bytes);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (gso_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;  GSO packet detected, segment size: %d bytes\n&quot;</span>, gso_size);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> print_len = recv_bytes &lt; <span class="number">100</span> ? recv_bytes : <span class="number">100</span>;</span><br><span class="line">            <span class="comment">// printf(&quot;  Data: %.*s\n&quot;, print_len, (char *)iov.iov_base);</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (recv_bytes &lt; <span class="number">0</span> &amp;&amp; errno != EAGAIN &amp;&amp; errno != EWOULDBLOCK) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recvmsg failed: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_usage</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *program_name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;mode&gt;\n&quot;</span>, program_name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Modes:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  1 - Simple recvfrom mode\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  2 - recvmmsg mode (batch receiving)\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  3 - recvmsg mode (with GRO support)\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        print_usage(argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mode = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (mode &lt; RECV_MODE_SIMPLE || mode &gt; RECV_MODE_MSG) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: Invalid mode. Please choose 1, 2, or 3.\n&quot;</span>);</span><br><span class="line">        print_usage(argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>                sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket creation failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> gso_size = GSO_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sockfd, SOL_UDP, UDP_SEGMENT, &amp;gso_size, <span class="keyword">sizeof</span>(gso_size)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt UDP_SEGMENT failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sockfd, IPPROTO_UDP, UDP_GRO, &amp;val, <span class="keyword">sizeof</span>(val)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt UDP_GRO failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    server_addr.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(sockfd, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind failed&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;UDP GSO Receiver listening on port %d...\n&quot;</span>, PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">    <span class="keyword">case</span> RECV_MODE_SIMPLE:</span><br><span class="line">        simple_recv_mode(sockfd);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RECV_MODE_MMSG:</span><br><span class="line">        mmsg_recv_mode(sockfd);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RECV_MODE_MSG:</span><br><span class="line">        msg_recv_mode(sockfd);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="发送侧（客户端）">发送侧（客户端）</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SOL_UDP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOL_UDP (17)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UDP_SEGMENT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UDP_SEGMENT (103)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEST_IP <span class="string">&quot;192.168.110.220&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEST_PORT 8888</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GSO_SIZE (1500 - 20 - 8) <span class="comment">// 最大 GSO 分段大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLEEP_SEC 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_INIT</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 启用 UDP GSO</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">enable_udp_gso</span><span class="params">(<span class="type">int</span> sockfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> gso_size = GSO_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sockfd, SOL_UDP, UDP_SEGMENT, &amp;gso_size, <span class="keyword">sizeof</span>(gso_size)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt UDP_SEGMENT failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;UDP GSO enabled with segment size: %d\n&quot;</span>, gso_size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁用 UDP GSO</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">disable_udp_gso</span><span class="params">(<span class="type">int</span> sockfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> gso_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sockfd, SOL_UDP, UDP_SEGMENT, &amp;gso_size, <span class="keyword">sizeof</span>(gso_size)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt UDP_SEGMENT disable failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;UDP GSO disabled\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 UDP socket</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">create_udp_socket</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket creation failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 socket 为阻塞模式（可选）</span></span><br><span class="line">    <span class="type">int</span> flags = fcntl(sockfd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">    fcntl(sockfd, F_SETFL, flags &amp; ~O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup_dest_addr</span><span class="params">(<span class="keyword">struct</span> sockaddr_in *dest_addr, <span class="type">const</span> <span class="type">char</span> *ip, <span class="type">int</span> port)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dest_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(*dest_addr));</span><br><span class="line">    dest_addr-&gt;sin_family = AF_INET;</span><br><span class="line">    dest_addr-&gt;sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inet_pton(AF_INET, ip, &amp;dest_addr-&gt;sin_addr) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;invalid address&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr_in *dest_addr,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> packet_size, <span class="type">int</span> num_packets)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> total_size = packet_size * num_packets;</span><br><span class="line">    <span class="type">size_t</span> total_sent_size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>  *send_buffer = <span class="built_in">malloc</span>(packet_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!send_buffer) &#123;</span><br><span class="line">        perror(<span class="string">&quot;malloc failed for send buffer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MALLOC_INIT</span></span><br><span class="line">    <span class="built_in">memset</span>(send_buffer, <span class="string">&#x27;X&#x27;</span>, packet_size);</span><br><span class="line">    send_buffer[packet_size - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sending %d packets using sendto, total buffer: %zu bytes\n&quot;</span>, num_packets, total_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_packets; i++) &#123;</span><br><span class="line">        <span class="type">int</span> written = <span class="built_in">snprintf</span>(send_buffer, packet_size,</span><br><span class="line">            <span class="string">&quot;Send packet %d at timestamp: %ld, total packets: %d&quot;</span>,</span><br><span class="line">            i, time(<span class="literal">NULL</span>), num_packets);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MALLOC_INIT</span></span><br><span class="line">        send_buffer[written] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="type">ssize_t</span> sent = sendto(sockfd, send_buffer, packet_size, <span class="number">0</span>,</span><br><span class="line">            (<span class="keyword">struct</span> sockaddr *)dest_addr, <span class="keyword">sizeof</span>(*dest_addr));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;sendto without GSO failed&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            total_sent_size += sent;</span><br><span class="line">            <span class="comment">// printf(&quot;Send sent %zd bytes, expected %u bytes\n&quot;, sent, packet_size);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Approximately %zd packets sent without GSO, total sent %lu bytes\n&quot;</span>,</span><br><span class="line">        total_sent_size / packet_size, total_sent_size);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(send_buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 UDP GSO 发送批量数据包</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_gso_batch</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr_in *dest_addr,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> packet_size, <span class="type">int</span> num_packets)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 计算总缓冲区大小</span></span><br><span class="line">    <span class="type">size_t</span> total_size = packet_size * num_packets;</span><br><span class="line">    <span class="type">char</span>  *gso_buffer = <span class="built_in">malloc</span>(total_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!gso_buffer) &#123;</span><br><span class="line">        perror(<span class="string">&quot;malloc failed for GSO buffer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MALLOC_INIT</span></span><br><span class="line">    <span class="built_in">memset</span>(gso_buffer, <span class="string">&#x27;X&#x27;</span>, total_size);</span><br><span class="line">    gso_buffer[total_size - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备批量数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_packets; i++) &#123;</span><br><span class="line">        <span class="type">char</span> *packet_start = gso_buffer + (i * packet_size);</span><br><span class="line">        <span class="type">int</span>   written = <span class="built_in">snprintf</span>(packet_start, packet_size,</span><br><span class="line">              <span class="string">&quot;GSO Batch packet %d at timestamp: %ld, total packets: %d&quot;</span>,</span><br><span class="line">              i, time(<span class="literal">NULL</span>), num_packets);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MALLOC_INIT</span></span><br><span class="line">        packet_start[written] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sending %d packets using UDP GSO, total buffer: %zu bytes\n&quot;</span>,</span><br><span class="line">        num_packets, total_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 GSO 发送整个缓冲区</span></span><br><span class="line">    <span class="type">ssize_t</span> sent = sendto(sockfd, gso_buffer, total_size, <span class="number">0</span>,</span><br><span class="line">        (<span class="keyword">struct</span> sockaddr *)dest_addr, <span class="keyword">sizeof</span>(*dest_addr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sendto with GSO failed&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;GSO sent %zd bytes, expected %zu bytes\n&quot;</span>, sent, total_size);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Approximately %zd packets sent via GSO\n&quot;</span>, sent / packet_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(gso_buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_gso_batch_sendmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr_in *dest_addr,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> packet_size, <span class="type">int</span> num_packets, <span class="type">int</span> is_segment)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一次性分配所有内存：packet_buffers 数组 + iovec 数组 + 所有数据包缓冲区</span></span><br><span class="line">    <span class="type">size_t</span> total_buffer_size = (<span class="type">size_t</span>)packet_size * num_packets;</span><br><span class="line">    <span class="type">char</span>  *memory_block = <span class="built_in">malloc</span>(num_packets * <span class="keyword">sizeof</span>(<span class="type">char</span> *) + num_packets * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iovec) + total_buffer_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!memory_block) &#123;</span><br><span class="line">        perror(<span class="string">&quot;malloc failed for memory block&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MALLOC_INIT</span></span><br><span class="line">    <span class="built_in">memset</span>(memory_block, <span class="string">&#x27;X&#x27;</span>, total_buffer_size);</span><br><span class="line">    memory_block[total_buffer_size - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置指针位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">msg_iov</span> =</span> (<span class="keyword">struct</span> iovec *)(memory_block + num_packets * <span class="keyword">sizeof</span>(<span class="type">char</span> *));</span><br><span class="line">    <span class="type">char</span>         *data_buffer = (<span class="type">char</span> *)(memory_block + num_packets * <span class="keyword">sizeof</span>(<span class="type">char</span> *) + num_packets * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iovec));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数据包和 iovec</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_packets; i++) &#123;</span><br><span class="line">        <span class="type">char</span> *packet_start = data_buffer + (i * packet_size);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> written = <span class="built_in">snprintf</span>(packet_start, packet_size,</span><br><span class="line">            <span class="string">&quot;Optimized Merged Batch packet %d at timestamp: %ld, total packets: %d&quot;</span>,</span><br><span class="line">            i, time(<span class="literal">NULL</span>), num_packets);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MALLOC_INIT</span></span><br><span class="line">        packet_start[written] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        msg_iov[i].iov_base = packet_start;</span><br><span class="line">        msg_iov[i].iov_len = packet_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 msghdr</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    msg.msg_name = (<span class="type">void</span> *)dest_addr;</span><br><span class="line">    msg.msg_namelen = <span class="keyword">sizeof</span>(*dest_addr);</span><br><span class="line">    msg.msg_iov = msg_iov;</span><br><span class="line">    msg.msg_iovlen = num_packets;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_segment) &#123;</span><br><span class="line">        <span class="comment">// 分配控制消息缓冲区</span></span><br><span class="line">        <span class="type">char</span> control[CMSG_SPACE(<span class="keyword">sizeof</span>(<span class="type">uint16_t</span>))];</span><br><span class="line">        msg.msg_control = control;</span><br><span class="line">        msg.msg_controllen = <span class="keyword">sizeof</span>(control);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 UDP_SEGMENT 控制消息</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> *<span class="title">cm</span> =</span> CMSG_FIRSTHDR(&amp;msg);</span><br><span class="line">        cm-&gt;cmsg_level = SOL_UDP;</span><br><span class="line">        cm-&gt;cmsg_type = UDP_SEGMENT;</span><br><span class="line">        cm-&gt;cmsg_len = CMSG_LEN(<span class="keyword">sizeof</span>(<span class="type">uint16_t</span>));</span><br><span class="line">        *((<span class="type">uint16_t</span> *)CMSG_DATA(cm)) = packet_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sending %d optimized merged packets, total size: %zu bytes\n&quot;</span>,</span><br><span class="line">        num_packets, total_buffer_size);</span><br><span class="line"></span><br><span class="line">    <span class="type">ssize_t</span> sent = sendmsg(sockfd, &amp;msg, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sendmsg with optimized merged packets failed&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Optimized merged batch sent %zd total bytes\n&quot;</span>, sent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(memory_block);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进的使用 UDP GSO 发送批量数据包</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_gso_batch_improved</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr_in *dest_addr,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> packet_size, <span class="type">int</span> num_packets)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 计算总缓冲区大小</span></span><br><span class="line">    <span class="type">size_t</span> total_size = packet_size * num_packets;</span><br><span class="line">    <span class="type">char</span>  *gso_buffer = <span class="built_in">malloc</span>(total_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!gso_buffer) &#123;</span><br><span class="line">        perror(<span class="string">&quot;malloc failed for GSO buffer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MALLOC_INIT</span></span><br><span class="line">    <span class="built_in">memset</span>(gso_buffer, <span class="string">&#x27;X&#x27;</span>, total_size);</span><br><span class="line">    gso_buffer[total_size - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备批量数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_packets; i++) &#123;</span><br><span class="line">        <span class="type">char</span> *packet_start = gso_buffer + (i * packet_size);</span><br><span class="line">        <span class="type">int</span>   written = <span class="built_in">snprintf</span>(packet_start, packet_size,</span><br><span class="line">              <span class="string">&quot;GSO Batch packet %d at timestamp: %ld, total packets: %d&quot;</span>,</span><br><span class="line">              i, time(<span class="literal">NULL</span>), num_packets);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MALLOC_INIT</span></span><br><span class="line">        packet_start[written] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sending %d packets using UDP GSO, total buffer: %zu bytes\n&quot;</span>,</span><br><span class="line">        num_packets, total_size);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> =</span> &#123;</span><br><span class="line">        .iov_base = gso_buffer,</span><br><span class="line">        .iov_len = total_size</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span> =</span> &#123;</span><br><span class="line">        .msg_name = dest_addr,</span><br><span class="line">        .msg_namelen = <span class="keyword">sizeof</span>(*dest_addr),</span><br><span class="line">        .msg_iov = &amp;iov,</span><br><span class="line">        .msg_iovlen = <span class="number">1</span>,</span><br><span class="line">        .msg_control = <span class="literal">NULL</span>, <span class="comment">// 使用 socket-level GSO 可以不加控制信息</span></span><br><span class="line">        .msg_controllen = <span class="number">0</span>,</span><br><span class="line">        .msg_flags = <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// disable_udp_gso 时加控制信息</span></span><br><span class="line">    <span class="type">char</span> control[CMSG_SPACE(<span class="keyword">sizeof</span>(<span class="type">uint16_t</span>))] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    msg.msg_control = control;</span><br><span class="line">    msg.msg_controllen = <span class="keyword">sizeof</span>(control);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> *<span class="title">cm</span> =</span> CMSG_FIRSTHDR(&amp;msg);</span><br><span class="line">    cm-&gt;cmsg_level = SOL_UDP;</span><br><span class="line">    cm-&gt;cmsg_type = UDP_SEGMENT;</span><br><span class="line">    cm-&gt;cmsg_len = CMSG_LEN(<span class="keyword">sizeof</span>(<span class="type">uint16_t</span>));</span><br><span class="line">    *((<span class="type">uint16_t</span> *)CMSG_DATA(cm)) = GSO_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="type">ssize_t</span> sent = sendmsg(sockfd, &amp;msg, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sendmsg with GSO failed&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;GSO sent %zd bytes, expected %zu bytes, Approximately %zd packets sent via GSO\n&quot;</span>,</span><br><span class="line">            sent, total_size, sent / packet_size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sent != total_size) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Warn: Sent %zd bytes less than expected (packet fragmentation may occur)\n&quot;</span>,</span><br><span class="line">                total_size - sent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(gso_buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 sendmmsg 发送批量数据包（用于对比）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_mmsg_batch</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr_in *dest_addr,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> packet_size, <span class="type">int</span> num_packets)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mmsghdr</span> <span class="title">msgs</span>[<span class="title">num_packets</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>   <span class="title">iovecs</span>[<span class="title">num_packets</span>];</span></span><br><span class="line">    <span class="type">char</span>          *buffers[num_packets];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备每个消息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_packets; i++) &#123;</span><br><span class="line">        buffers[i] = <span class="built_in">malloc</span>(packet_size);</span><br><span class="line">        <span class="keyword">if</span> (!buffers[i]) &#123;</span><br><span class="line">            perror(<span class="string">&quot;malloc failed for mmsg buffer&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="built_in">free</span>(buffers[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MALLOC_INIT</span></span><br><span class="line">        <span class="built_in">memset</span>(buffers[i], <span class="string">&#x27;X&#x27;</span>, packet_size);</span><br><span class="line">        buffers[i][packet_size - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> written = <span class="built_in">snprintf</span>(buffers[i], packet_size,</span><br><span class="line">            <span class="string">&quot;sendmmsg packet %d at timestamp: %ld&quot;</span>,</span><br><span class="line">            i, time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MALLOC_INIT</span></span><br><span class="line">        buffers[i][written] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        iovecs[i].iov_base = buffers[i];</span><br><span class="line">        iovecs[i].iov_len = packet_size; <span class="comment">// 使用完整的数据包大小</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;msgs[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(msgs[i]));</span><br><span class="line">        msgs[i].msg_hdr.msg_name = dest_addr;</span><br><span class="line">        msgs[i].msg_hdr.msg_namelen = <span class="keyword">sizeof</span>(*dest_addr);</span><br><span class="line">        msgs[i].msg_hdr.msg_iov = &amp;iovecs[i];</span><br><span class="line">        msgs[i].msg_hdr.msg_iovlen = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sending %d packets using sendmmsg\n&quot;</span>, num_packets);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = sendmmsg(sockfd, msgs, num_packets, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sendmmsg failed&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sendmmsg sent %d out of %d packets\n&quot;</span>, ret, num_packets);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计发送的字节数</span></span><br><span class="line">        <span class="type">size_t</span> total_sent = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line">            total_sent += msgs[i].msg_len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Total bytes sent via sendmmsg: %zu\n&quot;</span>, total_sent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_packets; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(buffers[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 sendmmsg + UDP GSO 发送批量数据包</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_mmsg_gso_batch</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr_in *dest_addr,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> packet_size, <span class="type">int</span> num_packets)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mmsghdr</span> <span class="title">msgs</span>[<span class="title">num_packets</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>   <span class="title">iovecs</span>[<span class="title">num_packets</span>];</span></span><br><span class="line">    <span class="type">char</span>          *buffers[num_packets];</span><br><span class="line">    <span class="type">char</span>          *control_buffers[num_packets]; <span class="comment">// 为每个消息分配控制缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备每个消息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_packets; i++) &#123;</span><br><span class="line">        buffers[i] = <span class="built_in">malloc</span>(packet_size);</span><br><span class="line">        <span class="keyword">if</span> (!buffers[i]) &#123;</span><br><span class="line">            perror(<span class="string">&quot;malloc failed for mmsg_gso buffer&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="built_in">free</span>(buffers[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MALLOC_INIT</span></span><br><span class="line">        <span class="built_in">memset</span>(buffers[i], <span class="string">&#x27;X&#x27;</span>, packet_size);</span><br><span class="line">        buffers[i][packet_size - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> written = <span class="built_in">snprintf</span>(buffers[i], packet_size,</span><br><span class="line">            <span class="string">&quot;sendmmsg+GSO packet %d at timestamp: %ld&quot;</span>,</span><br><span class="line">            i, time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MALLOC_INIT</span></span><br><span class="line">        buffers[i][written] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        iovecs[i].iov_base = buffers[i];</span><br><span class="line">        iovecs[i].iov_len = packet_size; <span class="comment">// 使用完整的数据包大小</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为控制消息分配空间</span></span><br><span class="line">        control_buffers[i] = <span class="built_in">malloc</span>(CMSG_SPACE(<span class="keyword">sizeof</span>(<span class="type">uint16_t</span>)));</span><br><span class="line">        <span class="keyword">if</span> (!control_buffers[i]) &#123;</span><br><span class="line">            perror(<span class="string">&quot;malloc failed for control buffer&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="built_in">free</span>(buffers[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="built_in">free</span>(control_buffers[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;msgs[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(msgs[i]));</span><br><span class="line">        msgs[i].msg_hdr.msg_name = dest_addr;</span><br><span class="line">        msgs[i].msg_hdr.msg_namelen = <span class="keyword">sizeof</span>(*dest_addr);</span><br><span class="line">        msgs[i].msg_hdr.msg_iov = &amp;iovecs[i];</span><br><span class="line">        msgs[i].msg_hdr.msg_iovlen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 GSO 控制信息</span></span><br><span class="line">        msgs[i].msg_hdr.msg_control = control_buffers[i];</span><br><span class="line">        msgs[i].msg_hdr.msg_controllen = CMSG_SPACE(<span class="keyword">sizeof</span>(<span class="type">uint16_t</span>));</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> *<span class="title">cmsg</span> =</span> CMSG_FIRSTHDR(&amp;msgs[i].msg_hdr);</span><br><span class="line">        cmsg-&gt;cmsg_level = SOL_UDP;</span><br><span class="line">        cmsg-&gt;cmsg_type = UDP_SEGMENT;</span><br><span class="line">        cmsg-&gt;cmsg_len = CMSG_LEN(<span class="keyword">sizeof</span>(<span class="type">uint16_t</span>));</span><br><span class="line">        *((<span class="type">uint16_t</span> *)CMSG_DATA(cmsg)) = GSO_SIZE; <span class="comment">// 设置 GSO 分段大小</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：msg_controllen 必须精确设置为控制消息的总长度</span></span><br><span class="line">        msgs[i].msg_hdr.msg_controllen = cmsg-&gt;cmsg_len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sending %d packets using sendmmsg + UDP GSO\n&quot;</span>, num_packets);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = sendmmsg(sockfd, msgs, num_packets, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sendmmsg with GSO failed&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sendmmsg+GSO sent %d out of %d packets\n&quot;</span>, ret, num_packets);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计发送的字节数</span></span><br><span class="line">        <span class="type">size_t</span> total_sent = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line">            total_sent += msgs[i].msg_len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Total bytes sent via sendmmsg+GSO: %zu\n&quot;</span>, total_sent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_packets; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(buffers[i]);</span><br><span class="line">        <span class="built_in">free</span>(control_buffers[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 性能测试函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">performance_test</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr_in *dest_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>                iterations = <span class="number">10000</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>                packets_per_batch = <span class="number">32</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>                packet_size = <span class="number">1216</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> total_bits = <span class="number">8ULL</span> * iterations * packets_per_batch * packet_size;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n=== Performance Test ===\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Iterations: %d, Packets per batch: %d, Packet size: %d, GSO_SIZE: %d\n&quot;</span>,</span><br><span class="line">        iterations, packets_per_batch, packet_size, GSO_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 sendto</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n1. Testing sendto without GSO...\n&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start</span>, <span class="title">end</span>;</span></span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;start);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">        send_sendto(sockfd, dest_addr, packet_size, packets_per_batch);</span><br><span class="line">    &#125;</span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;end);</span><br><span class="line">    <span class="type">double</span> sendto_time = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / <span class="number">1e9</span>;</span><br><span class="line">    sleep(SLEEP_SEC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 sendmmsg</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n2. Testing sendmmsg...\n&quot;</span>);</span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;start);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">        send_mmsg_batch(sockfd, dest_addr, packet_size, packets_per_batch);</span><br><span class="line">    &#125;</span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;end);</span><br><span class="line">    <span class="type">double</span> mmsg_time = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / <span class="number">1e9</span>;</span><br><span class="line">    sleep(SLEEP_SEC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 UDP GSO + sendto 发大包</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n3. Testing UDP GSO (merge sendto)...\n&quot;</span>);</span><br><span class="line">    enable_udp_gso(sockfd); <span class="comment">// 启用 GSO</span></span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;start);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">        send_gso_batch(sockfd, dest_addr, packet_size, packets_per_batch);</span><br><span class="line">    &#125;</span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;end);</span><br><span class="line">    <span class="type">double</span> gso_time = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / <span class="number">1e9</span>;</span><br><span class="line">    disable_udp_gso(sockfd); <span class="comment">// 禁用 GSO</span></span><br><span class="line">    sleep(SLEEP_SEC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 UDP GSO + scatter-gather sendmsg without segment</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n3. Testing UDP GSO (scatter-gather sendmsg without segment)...\n&quot;</span>);</span><br><span class="line">    enable_udp_gso(sockfd); <span class="comment">// 启用 GSO</span></span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;start);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">        send_gso_batch_sendmsg(sockfd, dest_addr, packet_size, packets_per_batch, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;end);</span><br><span class="line">    <span class="type">double</span> gso_sendmsg_time0 = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / <span class="number">1e9</span>;</span><br><span class="line">    disable_udp_gso(sockfd); <span class="comment">// 禁用 GSO</span></span><br><span class="line">    sleep(SLEEP_SEC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 UDP GSO + scatter-gather sendmsg with segment</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n3. Testing UDP GSO (scatter-gather sendmsg with segment)...\n&quot;</span>);</span><br><span class="line">    enable_udp_gso(sockfd); <span class="comment">// 启用 GSO</span></span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;start);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">        send_gso_batch_sendmsg(sockfd, dest_addr, packet_size, packets_per_batch, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;end);</span><br><span class="line">    <span class="type">double</span> gso_sendmsg_time1 = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / <span class="number">1e9</span>;</span><br><span class="line">    disable_udp_gso(sockfd); <span class="comment">// 禁用 GSO</span></span><br><span class="line">    sleep(SLEEP_SEC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 UDP GSO + sendmsg 发大包</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n4. Testing UDP GSO (merge sendmsg)...\n&quot;</span>);</span><br><span class="line">    <span class="comment">// enable_udp_gso(sockfd); // 启用 GSO</span></span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;start);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">        send_gso_batch_improved(sockfd, dest_addr, packet_size, packets_per_batch);</span><br><span class="line">    &#125;</span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;end);</span><br><span class="line">    <span class="type">double</span> gso_improved_time = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / <span class="number">1e9</span>;</span><br><span class="line">    <span class="comment">// disable_udp_gso(sockfd); // 禁用 GSO</span></span><br><span class="line">    sleep(SLEEP_SEC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 sendmmsg + UDP GSO</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n5. Testing sendmmsg + UDP GSO...\n&quot;</span>);</span><br><span class="line">    enable_udp_gso(sockfd); <span class="comment">// 启用 GSO</span></span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;start);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">        send_mmsg_gso_batch(sockfd, dest_addr, packet_size, packets_per_batch);</span><br><span class="line">    &#125;</span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;end);</span><br><span class="line">    <span class="type">double</span> mmsg_gso_time = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / <span class="number">1e9</span>;</span><br><span class="line">    disable_udp_gso(sockfd); <span class="comment">// 禁用 GSO</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n=== Results ===\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test params: iterations=%d, packets_per_batch=%d, packet_size=%d, GSO_SIZE=%d, total_bits=%llu\n&quot;</span>,</span><br><span class="line">        iterations, packets_per_batch, packet_size, GSO_SIZE, total_bits);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sendto time: %.6f seconds, bitrate=%.2f Mbps\n&quot;</span>, sendto_time, total_bits / <span class="number">1e6</span> / sendto_time);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sendmmsg time: %.6f seconds, bitrate=%.2f Mbps\n&quot;</span>, mmsg_time, total_bits / <span class="number">1e6</span> / mmsg_time);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;UDP GSO(merge sendto) time: %.6f seconds, bitrate=%.2f Mbps\n&quot;</span>, gso_time, total_bits / <span class="number">1e6</span> / gso_time);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;UDP GSO(scatter-gather sendmsg without segment) time: %.6f seconds, bitrate=%.2f Mbps\n&quot;</span>, gso_sendmsg_time0, total_bits / <span class="number">1e6</span> / gso_sendmsg_time0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;UDP GSO(scatter-gather sendmsg with segment) time: %.6f seconds, bitrate=%.2f Mbps\n&quot;</span>, gso_sendmsg_time1, total_bits / <span class="number">1e6</span> / gso_sendmsg_time1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;UDP GSO(merge sendmsg) time: %.6f seconds, bitrate=%.2f Mbps\n&quot;</span>, gso_improved_time, total_bits / <span class="number">1e6</span> / gso_improved_time);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sendmmsg + UDP GSO time: %.6f seconds, bitrate=%.2f Mbps\n&quot;</span>, mmsg_gso_time, total_bits / <span class="number">1e6</span> / mmsg_gso_time);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sendmmsg speedup over sendto: %.2fx\n&quot;</span>, sendto_time / mmsg_time);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;GSO(merge sendto) speedup over sendto: %.2fx\n&quot;</span>, sendto_time / gso_time);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;GSO(scatter-gather sendmsg without segment) speedup over sendto: %.2fx\n&quot;</span>, sendto_time / gso_sendmsg_time0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;GSO(scatter-gather sendmsg with segment) speedup over sendto: %.2fx\n&quot;</span>, sendto_time / gso_sendmsg_time1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;GSO(merge sendmsg) speedup over sendto: %.2fx\n&quot;</span>, sendto_time / gso_improved_time);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sendmmsg + UDP GSO speedup over sendto: %.2fx\n&quot;</span>, sendto_time / mmsg_gso_time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>                sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">dest_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;UDP GSO vs sendmmsg Performance Comparison\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 socket</span></span><br><span class="line">    sockfd = create_udp_socket();</span><br><span class="line">    setup_dest_addr(&amp;dest_addr, DEST_IP, DEST_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;test&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 运行性能测试</span></span><br><span class="line">        performance_test(sockfd, &amp;dest_addr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 分别演示</span></span><br><span class="line">        <span class="type">int</span> packet_size = <span class="number">1216</span>;</span><br><span class="line">        <span class="type">int</span> num_packets = <span class="number">32</span>;</span><br><span class="line">        <span class="type">int</span> mode = <span class="number">0</span>; <span class="comment">// 0: 全部执行, 1-6: 执行单个模式</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            mode = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// 全部执行</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n=== sendto(without GSO) Example ===\n&quot;</span>);</span><br><span class="line">            send_sendto(sockfd, &amp;dest_addr, packet_size, num_packets);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n=== sendmmsg Example ===\n&quot;</span>);</span><br><span class="line">            send_mmsg_batch(sockfd, &amp;dest_addr, packet_size, num_packets);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n=== UDP GSO(merge sendto) Example ===\n&quot;</span>);</span><br><span class="line">            enable_udp_gso(sockfd);</span><br><span class="line">            send_gso_batch(sockfd, &amp;dest_addr, packet_size, num_packets);</span><br><span class="line">            disable_udp_gso(sockfd);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n=== UDP GSO(scatter-gather sendmsg without segment) Example ===\n&quot;</span>);</span><br><span class="line">            enable_udp_gso(sockfd);</span><br><span class="line">            send_gso_batch_sendmsg(sockfd, &amp;dest_addr, packet_size, num_packets, <span class="number">0</span>);</span><br><span class="line">            disable_udp_gso(sockfd);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n=== UDP GSO(scatter-gather sendmsg with segment) Example ===\n&quot;</span>);</span><br><span class="line">            enable_udp_gso(sockfd);</span><br><span class="line">            send_gso_batch_sendmsg(sockfd, &amp;dest_addr, packet_size, num_packets, <span class="number">1</span>);</span><br><span class="line">            disable_udp_gso(sockfd);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n=== UDP GSO(merge sendmsg) Example ===\n&quot;</span>);</span><br><span class="line">            enable_udp_gso(sockfd);</span><br><span class="line">            send_gso_batch_improved(sockfd, &amp;dest_addr, packet_size, num_packets);</span><br><span class="line">            disable_udp_gso(sockfd);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n=== sendmmsg + UDP GSO Example ===\n&quot;</span>);</span><br><span class="line">            enable_udp_gso(sockfd);</span><br><span class="line">            send_mmsg_gso_batch(sockfd, &amp;dest_addr, packet_size, num_packets);</span><br><span class="line">            disable_udp_gso(sockfd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n=== sendto(without GSO) Example ===\n&quot;</span>);</span><br><span class="line">            send_sendto(sockfd, &amp;dest_addr, packet_size, num_packets);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n=== sendmmsg Example ===\n&quot;</span>);</span><br><span class="line">            send_mmsg_batch(sockfd, &amp;dest_addr, packet_size, num_packets);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n=== UDP GSO(merge sendto) Example ===\n&quot;</span>);</span><br><span class="line">            enable_udp_gso(sockfd);</span><br><span class="line">            send_gso_batch(sockfd, &amp;dest_addr, packet_size, num_packets);</span><br><span class="line">            disable_udp_gso(sockfd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n=== UDP GSO(scatter-gather sendmsg without segment) Example ===\n&quot;</span>);</span><br><span class="line">            enable_udp_gso(sockfd);</span><br><span class="line">            send_gso_batch_sendmsg(sockfd, &amp;dest_addr, packet_size, num_packets, <span class="number">0</span>);</span><br><span class="line">            disable_udp_gso(sockfd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n=== UDP GSO(scatter-gather sendmsg with segment) Example ===\n&quot;</span>);</span><br><span class="line">            enable_udp_gso(sockfd);</span><br><span class="line">            send_gso_batch_sendmsg(sockfd, &amp;dest_addr, packet_size, num_packets, <span class="number">1</span>);</span><br><span class="line">            disable_udp_gso(sockfd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n=== UDP GSO(merge sendmsg) Example ===\n&quot;</span>);</span><br><span class="line">            enable_udp_gso(sockfd);</span><br><span class="line">            send_gso_batch_improved(sockfd, &amp;dest_addr, packet_size, num_packets);</span><br><span class="line">            disable_udp_gso(sockfd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n=== sendmmsg + UDP GSO Example ===\n&quot;</span>);</span><br><span class="line">            enable_udp_gso(sockfd);</span><br><span class="line">            send_mmsg_gso_batch(sockfd, &amp;dest_addr, packet_size, num_packets);</span><br><span class="line">            disable_udp_gso(sockfd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Invalid mode: %d\n&quot;</span>, mode);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Usage:\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;  %s           # Run all examples\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;  %s &lt;mode&gt;    # Run specific mode (1-6)\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://blog.hidva.com/2020/05/11/udp-gro-gso/">https://blog.hidva.com/2020/05/11/udp-gro-gso/</a></li>
<li><a target="_blank" rel="noopener" href="https://calendar.perfplanet.com/2019/accelerating-udp-packet-transmission-for-quic/">https://calendar.perfplanet.com/2019/accelerating-udp-packet-transmission-for-quic/</a></li>
</ol>
</blockquote>

</div>


  <div class="book-comments">
    




  </div>



<script src="/js/book-post.js"></script>


            </div>
          </div>
          <div class="column col-2 hide-lg">
            <div class="book-post-info">
  
    <div class="book-post-meta">

  <div class="author">

    <!-- Author image -->
    <div class="author-img">
      
        <figure
          class="avatar avatar-lg"
          data-initial="A"
          style="background-color: #3b4351;">
        </figure>
      
    </div>

    <!-- Author title -->
    <div class="author-title">
      <div>aha</div>
      <div>2025-11-19</div>
    </div>
  </div>

  
    <div class="divider"></div>

    <div class="link">
      <a class="category-link" href="/categories/Linux/">Linux</a>

      <a class="tag-none-link" href="/tags/UDP/" rel="tag">#UDP</a> <a class="tag-none-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">#性能优化</a> <a class="tag-none-link" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="tag">#网络编程</a>
    </div>
    
  

  <div class="divider"></div>
</div>
  

  <div class="book-tocbot">
</div>
<div class="book-tocbot-menu">
  <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
  <a onclick="go_top()">Back to top</a>
  <a onclick="go_bottom()">Go to bottom</a>
  <a onclick="toggleSearch()">Search in blogs</a> <!-- 添加搜索文字的点击事件 -->
</div>

<div id="search-overlay" class="search-overlay" style="display: none;"> <!-- 初始状态为隐藏 -->
  <div class="search-box">
    <input type="text" id="search-input" placeholder="Search in all blogs...">
    <button onclick="closeSearch()">Close</button> <!-- 添加关闭按钮 -->
    <div id="search-results" class="search-results"></div>
  </div>
</div>

<script>
  function performSearch(query) {
    if (!query.trim()) {
      return;
    }

    fetch('/search.xml')
      .then(response => response.text())
      .then(data => {
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(data, "text/xml");
        const entries = xmlDoc.getElementsByTagName('entry');
        let results = '';

        for (let i = 0; i < entries.length; i++) {
          const title = entries[i].getElementsByTagName('title')[0].textContent;
          const content = entries[i].getElementsByTagName('content')[0].textContent;
          const url = entries[i].getElementsByTagName('url')[0].textContent;

          let count = (title.match(new RegExp(query, "gi")) || []).length; // 统计查询词出现的次数
          count += (content.match(new RegExp(query, "gi")) || []).length;

          if (count > 0) { // title.includes(query) || content.includes(query)
            results += `
              <div class="search-result-item">
                <a href="${url}">${title}</a> (${count})
              </div>`;
          }
        }

        const searchResultsElement = document.getElementById('search-results');
        searchResultsElement.innerHTML = results;
        searchResultsElement.classList.add('active');
      });
  }

  function toggleSearch() {
    const searchOverlay = document.getElementById('search-overlay');
    searchOverlay.style.display = searchOverlay.style.display === 'none' ? 'flex' : 'none';
  }

  function closeSearch() {
    document.getElementById('search-overlay').style.display = 'none';
  }

  document.getElementById('search-input').addEventListener('input', function() {
    const query = this.value;
    performSearch(query);
  });
</script>

<style>
  .search-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }

  .search-box {
    background: white;
    padding: 20px;
    border-radius: 5px;
    text-align: center;
    width: 80%;
    max-width: 500px;
  }

  .search-results {
    margin-top: 10px;
    max-height: 300px;
    overflow-y: auto;
    background: white;
    padding: 10px;
    border-radius: 5px;
    width: 100%;
  }

  .search-result-item {
    margin: 10px 0;
  }

  .search-result-item a {
    color: blue; /* 设置链接颜色为蓝色 */
    text-decoration: none;
  }

  .search-result-item a:hover {
    text-decoration: underline;
  }
</style>


<script src="/js/book-toc.js"></script>


</div>
          </div>
        </div>
      </div>

      <a class="off-canvas-overlay" onclick="hide_canvas()"></a>

      <button class="floating-button" onclick="toggleDropdownMenu()"></button>

      <div class="dropdown-menu">
        <div class="dropdown-item" onclick="changeBackgroundColor('#FFFFFF', '#000000')">银河白</div>
        <div class="dropdown-item" onclick="changeBackgroundColor('#C7EDCC', '#000000')">豆沙绿</div>
        <div class="dropdown-item" onclick="changeBackgroundColor('#FAF9DE', '#000000')">杏仁黄</div>
        <div class="dropdown-item" onclick="changeBackgroundColor('#E3EDCD', '#000000')">青草绿</div>
        <div class="dropdown-item" onclick="changeBackgroundColor('#FFF2E2', '#000000')">秋叶褐</div>
      </div>
  </div>

  <script>
    function toggleDropdownMenu() {
      document.querySelector('.floating-button').classList.toggle('active');
    }

    document.addEventListener('DOMContentLoaded', function () {
      var storedBackgroundColor = localStorage.getItem('blogBackgroundColor');
      var storedColor = localStorage.getItem('blogColor');

      if (storedBackgroundColor && storedColor) {
        document.body.style.backgroundColor = storedBackgroundColor;
        document.body.style.color = storedColor;
      }
    });

    function changeBackgroundColor(backgroundColor, color) {
      document.body.style.backgroundColor = backgroundColor;
      document.body.style.color = color;

      localStorage.setItem('blogBackgroundColor', backgroundColor);
      localStorage.setItem('blogColor', color);

      document.querySelector('.floating-button').classList.remove('active');
    }
  </script>
</body>

</html>


<script src="/js/book.js"></script>
