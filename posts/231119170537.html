<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"pursue26.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"fold":{"enable":true,"height":300},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="操作系统之 chapter4.1 非连续内存分配之分段与分页介绍了非连续内存的分段与分页技术。那么，如何才能有效的实现逻辑地址到物理地址的转换机制呢？那就是通过页表。本文将介绍页表、快表 TLB、二级 &amp; 多级页表和反向页表，你将学习到如何进行地址转换，以及如何进一步高效的进行地址转换。">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统之 chapter4.2 非连续内存分配之页表">
<meta property="og:url" content="https://pursue26.github.io/posts/231119170537.html">
<meta property="og:site_name" content="aha&#39;s blog">
<meta property="og:description" content="操作系统之 chapter4.1 非连续内存分配之分段与分页介绍了非连续内存的分段与分页技术。那么，如何才能有效的实现逻辑地址到物理地址的转换机制呢？那就是通过页表。本文将介绍页表、快表 TLB、二级 &amp; 多级页表和反向页表，你将学习到如何进行地址转换，以及如何进一步高效的进行地址转换。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pursue26.github.io/images/os-kernel/chapter4/page-table.png">
<meta property="og:image" content="https://pursue26.github.io/images/os-kernel/chapter4/address-translation.png">
<meta property="og:image" content="https://pursue26.github.io/images/os-kernel/chapter4/cpu-tlb.png">
<meta property="og:image" content="https://pursue26.github.io/images/os-kernel/chapter4/secondary-page-table.png">
<meta property="og:image" content="https://pursue26.github.io/images/os-kernel/chapter4/multi-page-table.png">
<meta property="og:image" content="https://pursue26.github.io/images/os-kernel/chapter4/page-registers.png">
<meta property="og:image" content="https://pursue26.github.io/images/os-kernel/chapter4/hash-reverse-page-table.png">
<meta property="og:image" content="https://pursue26.github.io/images/os-kernel/chapter4/hash-reverse-page-table-hash-collisions.png">
<meta property="article:published_time" content="2023-11-19T09:05:37.000Z">
<meta property="article:modified_time" content="2023-12-02T09:27:57.244Z">
<meta property="article:author" content="aha">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="非连续内存分配">
<meta property="article:tag" content="页表">
<meta property="article:tag" content="反向页表">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pursue26.github.io/images/os-kernel/chapter4/page-table.png">


<link rel="canonical" href="https://pursue26.github.io/posts/231119170537.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://pursue26.github.io/posts/231119170537.html","path":"posts/231119170537.html","title":"操作系统之 chapter4.2 非连续内存分配之页表"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>操作系统之 chapter4.2 非连续内存分配之页表 | aha's blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">aha's blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-dailyblog"><a href="/random.html" rel="section"><i class="fa fa-file fa-fw"></i>每日博客</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8"><span class="nav-number">1.</span> <span class="nav-text">页表 </span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text"> 页表概述 </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.</span> <span class="nav-text">页表结构 </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.3.</span> <span class="nav-text">地址转换实例 </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.</span> <span class="nav-text">分页机制的性能问题 </span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E8%A1%A8%EF%BC%88TLB%EF%BC%89%E2%80%94%E2%80%94%E8%A7%A3%E5%86%B3%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98"><span class="nav-number">2.</span> <span class="nav-text">快表（TLB）——解决时间问题 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E7%BA%A7%20-amp-%20%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E2%80%94%E2%80%94%E8%A7%A3%E5%86%B3%E7%A9%BA%E9%97%B4%E9%97%AE%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">二级 &amp; 多级页表——解决空间问题 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%90%91%E9%A1%B5%E8%A1%A8"><span class="nav-number">4.</span> <span class="nav-text">反向页表 </span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%90%91%E9%A1%B5%E8%A1%A8"><span class="nav-number">4.1.</span> <span class="nav-text">什么是反向页表 </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%90%91%E9%A1%B5%E8%A1%A8%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="nav-number">4.2.</span> <span class="nav-text">反向页表的目的 </span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E9%A1%B5%E8%A1%A8%E5%92%8C%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="nav-number">4.2.1.</span> <span class="nav-text">传统页表和多级页表的弊端 </span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%90%91%E9%A1%B5%E8%A1%A8%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">4.2.2.</span> <span class="nav-text">反向页表的优势 </span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E9%A1%B5%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88Page-Registers%EF%BC%89%E7%9A%84%E6%96%B9%E6%A1%88"><span class="nav-number">4.3.</span> <span class="nav-text">基于页寄存器（Page Registers）的方案 </span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%A1%88"><span class="nav-number">4.3.1.</span> <span class="nav-text"> 方案 </span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E5%AF%84%E5%AD%98%E5%99%A8%E7%A9%BA%E9%97%B4%E5%8D%A0%E6%AF%94"><span class="nav-number">4.3.2.</span> <span class="nav-text">页寄存器空间占比 </span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8A%BF"><span class="nav-number">4.3.3.</span> <span class="nav-text">优势 </span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A3%E5%8A%BF"><span class="nav-number">4.3.4.</span> <span class="nav-text">劣势 </span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%85%B3%E8%81%94%E5%86%85%E5%AD%98%EF%BC%88associative-memory%EF%BC%89%E7%9A%84%E6%96%B9%E6%A1%88"><span class="nav-number">4.4.</span> <span class="nav-text">基于关联内存（associative memory）的方案 </span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A3%E5%8A%BF%20-1"><span class="nav-number">4.4.1.</span> <span class="nav-text">劣势 </span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%93%88%E5%B8%8C%EF%BC%88hash%EF%BC%89%E7%9A%84%E6%96%B9%E6%A1%88"><span class="nav-number">4.5.</span> <span class="nav-text">基于哈希（hash）的方案 </span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%A1%88%20-1"><span class="nav-number">4.5.1.</span> <span class="nav-text">方案 </span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%A0%E5%B0%84%E8%BF%87%E7%A8%8B"><span class="nav-number">4.5.2.</span> <span class="nav-text">映射过程 </span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A3%E5%8A%BF%20-2"><span class="nav-number">4.5.3.</span> <span class="nav-text">劣势 </span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8A%BF%20-1"><span class="nav-number">4.5.4.</span> <span class="nav-text">优势 </span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">aha</p>
  <div class="site-description" itemprop="description">经历一个过程然后成为更好的自己</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">78</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://pursue26.github.io/posts/231119170537.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aha">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aha's blog">
      <meta itemprop="description" content="经历一个过程然后成为更好的自己">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="操作系统之 chapter4.2 非连续内存分配之页表 | aha's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统之 chapter4.2 非连续内存分配之页表
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
  
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-19 17:05:37" itemprop="dateCreated datePublished" datetime="2023-11-19T17:05:37+08:00">2023-11-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-12-02 17:27:57" itemprop="dateModified" datetime="2023-12-02T17:27:57+08:00">2023-12-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p><a href="https://pursue26.github.io/posts/231111172507.html">操作系统之 chapter4.1 非连续内存分配之分段与分页 </a> 介绍了非连续内存的分段与分页技术。那么，如何才能有效的实现逻辑地址到物理地址的转换机制呢？那就是通过页表。本文将介绍页表、快表 TLB、二级 &amp; 多级页表和反向页表，你将学习到如何进行地址转换，以及如何进一步高效的进行地址转换。</p>
<span id="more"></span>

<h2 id="页表"><a href="# 页表" class="headerlink" title="页表"></a>页表 </h2><h3 id="页表概述"><a href="# 页表概述" class="headerlink" title="页表概述"></a> 页表概述 </h3><p> 页表是操作系统中用于管理虚拟内存和物理内存之间 <strong> 映射关系 </strong> 的数据结构。它记录了虚拟地址和物理地址之间的对应关系，使得程序可以使用虚拟地址来访问物理内存，而无需关注具体的物理内存地址。</p>
<p>每一个运行的程序都有一个独立的页表：</p>
<ul>
<li>页表属于程序运行状态，会动态变化</li>
<li>PTBR（Page Table Base Register）：页表基址寄存器，用于存储页表的基地址，以指示当前使用的页表位置。</li>
</ul>
<h3 id="页表结构"><a href="# 页表结构" class="headerlink" title="页表结构"></a>页表结构 </h3><p> 页表其实就是一个大数组，它的索引 index 指的是 page-number（页号），索引对应的内容是 frame−number（帧号）。得到帧号后，再叠加上 offset（页帧内偏移）即可得到物理地址。</p>
<img src="/images/os-kernel/chapter4/page-table.png" alt="页表结构" width="60%" height="60%">

<p>页表中还有一些特殊标志位：</p>
<ul>
<li>dirty bit，脏位</li>
<li>resident bit，表示这个页表项是否合法（对应的物理地址中是否存在），0- 不存在，1- 存在</li>
<li>clock/reference bit，时钟 / 参考位</li>
</ul>
<p><strong>上图中 PTBR 的作用</strong>？</p>
<p>当程序访问虚拟内存时，CPU 会将虚拟地址发送给内存管理单元（MMU），MMU 根据页表进行地址转换。在这个过程中，CPU 会读取 PTBR 寄存器中的值，以确定当前使用的页表的位置。通过 <strong> 将虚拟地址的高位（即虚拟页号部分）与页表基地址相加，CPU 可以找到相应的表项，并进行地址转换</strong>，获取虚拟地址对应的物理地址。</p>
<blockquote>
<p>PTBR 的值通常在操作系统进行上下文切换时被修改，以切换不同的页表。这样，不同的进程可以拥有独立的页表，实现虚拟内存的隔离和保护。通过修改 PTBR，操作系统可以控制不同进程之间的地址空间映射关系，从而实现多进程共享物理内存的管理。</p>
</blockquote>
<h3 id="地址转换实例"><a href="# 地址转换实例" class="headerlink" title="地址转换实例"></a>地址转换实例 </h3><p> 具有 16 位地址的系统，具有：</p>
<ul>
<li>每页 1024 bytes，占用 10 位；帧号占用 6 位</li>
<li>物理内存大小为 2^6 * 1024 bytes = 64KB</li>
</ul>
<blockquote>
<p>物理内存是 64KB，还是图中的 32KB 呢？</p>
</blockquote>
<img src="/images/os-kernel/chapter4/address-translation.png" alt="地址转换实例" width="60%" height="60%">

<p>从图中可以了解到：</p>
<ul>
<li><p>对于二元组为 <code>(4, 0)</code> 的逻辑地址空间，它在页表中对应 <code>index = 4</code> 的那个页表项。可以看出，它对应的 resident bit 位的值为 0，表明这个页表项对应的物理地址不存在。这时请求访问物理内存，可能会造成 <strong> 内存访问异常（可能要杀死程序）</strong>。</p>
</li>
<li><p>对于二元组为 <code>(3, 1023)</code> 的逻辑地址空间，它在页表中对应 <code>index = 3</code> 的那个页表项。可以看出，它对应的 resident bit 位的值为 1，表明这个页表项对应的物理地址存在，对应的页帧号的二进制表示为 <code>00100</code>，则对应的物理内存地址为 <code>(4, 1023)</code> ，即 4x1024+1023=5119。</p>
</li>
</ul>
<h3 id="分页机制的性能问题"><a href="# 分页机制的性能问题" class="headerlink" title="分页机制的性能问题"></a>分页机制的性能问题 </h3><p> 进程访问一次内存单元，需要 2 次内存访问：</p>
<ul>
<li>一次用于获取页表项（通过页号查表获取页帧号）。</li>
<li>一次用于访问数据（访问物理内存的数据）。</li>
</ul>
<p>页表可能非常大：</p>
<ul>
<li>64 位的机器，如果每页 1024 字节，那么一个页表的大小是多少（有多少个页号）？<ul>
<li>$2^{64} / 2^{10} = 2^{54}$，这么大的页表，在内存中是放不下的。</li>
</ul>
</li>
<li>每一个运行的程序都需要有一个页表。</li>
</ul>
<p>如何处理？</p>
<ul>
<li>缓存（Caching）：使用 CPU 内部的 TLB（使用相关存储器，可以进行并发的、高速的查询）。</li>
<li>间接（Indirection）访问：使用二级页表、多级页表。</li>
</ul>
<h2 id="快表（TLB）——解决时间问题"><a href="# 快表（TLB）——解决时间问题" class="headerlink" title="快表（TLB）——解决时间问题"></a>快表（TLB）——解决时间问题 </h2><p> 转换后备缓冲区（Translation Look-aside Buffer, TLB）是一种高速缓存，也叫快表，<strong>用于加快虚拟地址到物理地址的转换过程 </strong>。它是页表的一部分，<strong> 用于存储最近使用的虚拟页与物理页的映射关系，以减少对页表的访问次数，提高地址转换的效率</strong>。</p>
<img src="/images/os-kernel/chapter4/cpu-tlb.png" alt="快表" width="60%" height="60%">

<p>TLB 缓存近期访问的页帧转换表项：</p>
<ul>
<li>TLB 是一个小而快速的硬件缓存，使用关联内存（associative memory）实现，具备快速访问性能。每个 TLB 条目包含一个虚拟页号（VPN）和对应的物理页号（PPN），以及一些其他用于管理的标志位，如访问权限、脏位等。</li>
<li>如果 TLB 命中，物理页号可以很快被获取。</li>
<li>如果 TLB 未命中、缺失（TLB miss），对应的表项被更新到 TLB 中（该动作在 x86 的 CPU 中由硬件实现，其他的可能是由操作系统实现）。</li>
</ul>
<blockquote>
<p>当程序访问一个虚拟地址时，CPU 首先在 TLB 中查找对应的虚拟页号。如果找到了匹配的 TLB 条目，就可以直接从 TLB 中获取对应的物理页帧号，然后进行内存访问，无需访问页表。这个过程称为 TLB 命中。</p>
</blockquote>
<p>TLB 缺失会不会很频繁呢？</p>
<p>不会的。假如 32 位的系统，每页的大小为 4K 字节，如果该页的每一个地址都访问一次的话，需要 4K 次才会造成一次 TLB 缺失——因为从当前页首访问到当前页尾，下次访问时会是不同的逻辑页号，这个页号可能不在 TLB 表中。（这是假设情况，实际中 TLB 缺失的频率取决于许多因素，无法简单地通过每页的大小和访问次数来确定 TLB 缺失的频率）</p>
<h2 id="二级 -amp- 多级页表——解决空间问题"><a href="# 二级 -amp- 多级页表——解决空间问题" class="headerlink" title="二级 &amp; 多级页表——解决空间问题"></a>二级 &amp; 多级页表——解决空间问题 </h2><p> 二级 &amp; 多级页表利用时间换空间，来解决页表的空间问题。</p>
<p>二级页表：</p>
<ol>
<li>将页号分为两个部分、页表分为两个，一级页号对应一级页表，二级页号对应二级页表；</li>
<li>一级页号查表获得在二级页表的起始地址，地址加上二级页号的值，在二级页表中获得帧号。</li>
</ol>
<p>二级页表节约了一定的空间 —— 在一级页表中如果 <code>resident bit=0</code>，则在二级页表中 <strong> 不存储 </strong> 相关 <code>index</code>，而只有一张页表的话，这一些 <code>index</code> 都需要保留。</p>
<img src="/images/os-kernel/chapter4/secondary-page-table.png" alt="二级页表" width="60%" height="60%">

<blockquote>
<p>二级页表就像是目录的目录，先找到一级目录，再在一级目录内找到二级目录。</p>
</blockquote>
<p>多级页表：</p>
<ul>
<li>通过把页号分为 <code>k</code> 个部分，来实现多级间接页表，建立一棵「页表树」。</li>
</ul>
<img src="/images/os-kernel/chapter4/multi-page-table.png" alt="多级页表" width="60%" height="60%">

<blockquote>
<p>多级页表就像是目录的目录的目录…</p>
</blockquote>
<h2 id="反向页表"><a href="# 反向页表" class="headerlink" title="反向页表"></a>反向页表 </h2><p> 有没有一种方法使得页表的大小与逻辑地址大小没有那么大的关系，尽量与物理地址大小建立对应关系？——反向页表</p>
<h3 id="什么是反向页表"><a href="# 什么是反向页表" class="headerlink" title="什么是反向页表"></a>什么是反向页表 </h3><p> 在操作系统中，反向页表（Inverted Page Table）是一种用于虚拟内存管理的数据结构。与传统的页表不同，<strong>传统的页表将虚拟页号映射到物理页帧号，而反向页表将物理页帧号映射到虚拟页号</strong>。</p>
<h3 id="反向页表的目的"><a href="# 反向页表的目的" class="headerlink" title="反向页表的目的"></a>反向页表的目的 </h3><p> 反向页表的目的是 <strong> 为了解决大型内存系统（地址的寻址空间非常大）中的页表大小太大（占用内存空间太大）和访问效率的问题</strong>。</p>
<h4 id="传统页表和多级页表的弊端"><a href="# 传统页表和多级页表的弊端" class="headerlink" title="传统页表和多级页表的弊端"></a>传统页表和多级页表的弊端 </h4><p><strong> 传统页表 </strong>：<br> 在传统的页表中，每个进程都有自己的页表，而随着进程数量的增加和每个进程的逻辑地址空间的增大，页表的大小也会急剧增加。这样会导致内存开销大，并且访问页表的时间也会增加。</p>
<p><strong>多级页表 </strong>：<br> 在大型内存系统（64-bits 系统）中，前向映射页表变得繁琐，比如：使用了 5 级页表。</p>
<h4 id="反向页表的优势"><a href="# 反向页表的优势" class="headerlink" title="反向页表的优势"></a>反向页表的优势 </h4><p> 在传统的页表中，每个进程都有自己的页表。而 <strong> 反向页表只有一张，它只需要为系统中的每个物理页帧分配一个表项，每个表项记录了该物理页帧所属的进程号（PID）和虚拟页号 </strong>。当进行地址转换时，<em> 操作系统只需通过物理页帧号查找反向页表，即可得到对应的进程号和虚拟页号</em>。这样就避免了每个进程都拥有一个独立的页表，大大减少了页表的大小。</p>
<p>也就是，<strong>反向页表的大小只跟物理地址空间的大小相对应，而与快速增长的虚拟地址空间的大小无关</strong>。</p>
<blockquote>
<p><em>操作系统只需通过物理页帧号查找反向页表，即可得到对应的进程号和虚拟页号</em>：（个人理解）只要遍历查找的虚拟页号和进程号，跟当前的进程的 PID 和虚拟页号匹配上了，那么就可以使用这个物理页帧号来获取对应的物理内存，并访问数据了。</p>
</blockquote>
<h3 id="基于页寄存器（Page-Registers）的方案"><a href="# 基于页寄存器（Page-Registers）的方案" class="headerlink" title="基于页寄存器（Page Registers）的方案"></a>基于页寄存器（Page Registers）的方案 </h3><h4 id="方案"><a href="# 方案" class="headerlink" title="方案"></a> 方案 </h4><p> 页表中存储（页帧号，页号），使得页表大小与物理内存大小相关，而与逻辑内存关联减小。</p>
<img src="/images/os-kernel/chapter4/page-registers.png" alt="基于页寄存器的方案" width="60%" height="60%">

<p>每一个页帧和一个页寄存器关联，寄存器内容包括：</p>
<ul>
<li>使用位（resident bit）：此帧是否被进程占用</li>
<li>占用页号（occupier）：对应的页号 p</li>
<li>保护为（protection bits）：保护位</li>
</ul>
<h4 id="页寄存器空间占比"><a href="# 页寄存器空间占比" class="headerlink" title="页寄存器空间占比"></a>页寄存器空间占比 </h4><p> 有如下一个操作系统：</p>
<ul>
<li>页面大小：4096 bytes = 4KB</li>
<li>页帧数：4096 = 4K</li>
<li>物理内存大小：4096 * 4096 bytes = 4K * 4KB = 16MB</li>
</ul>
<p>则页寄存器使用的空间（假设 8 bytes/register）：8 bytes * 4096 = 32KB</p>
<ul>
<li>每一个页帧和一个页寄存器关联——页寄存器使用的空间即页表中所有页帧号对应页的页寄存器空间</li>
<li>页寄存器带来的额外内存开销占比：32KB / 16MB = 0.195%</li>
<li>虚拟内存大小：任意</li>
</ul>
<h4 id="优势"><a href="# 优势" class="headerlink" title="优势"></a>优势 </h4><p> 从上面的示例可以看出，基于页寄存器的方案有如下优势：</p>
<ul>
<li>转换表的大小相对于物理内存来说很小</li>
<li>转换表的大小跟逻辑地址空间的大小无关</li>
</ul>
<h4 id="劣势"><a href="# 劣势" class="headerlink" title="劣势"></a>劣势 </h4><p> 需要的信息对调了，即根据帧号可以找到页号。如何转换回来（如何根据页号找到页帧号）？</p>
<p>答：需要在反向页表中搜索想要的页号，才能得到对应的页帧号。</p>
<h3 id="基于关联内存（associative-memory）的方案"><a href="# 基于关联内存（associative-memory）的方案" class="headerlink" title="基于关联内存（associative memory）的方案"></a>基于关联内存（associative memory）的方案 </h3><p> 就是在上方 TLB 中提到的相关存储器，并发的、高速的查询，效率很快。</p>
<p>该方案在设计上，页表中存储（页帧号，页号），而不是像 TLB 中存储（页号，页帧号）。</p>
<h4 id="劣势 -1"><a href="# 劣势 -1" class="headerlink" title="劣势"></a>劣势 </h4><p> 硬件设计太复杂，容量不可能做大，需要放置在 CPU 中。</p>
<p>在反向页表中搜索一个页对应的页帧号：</p>
<ul>
<li>如果帧数较少，页寄存器可以被放在关联内存中。</li>
<li>在关联内存中查找逻辑页号：<ul>
<li>成功：页帧号被提取</li>
<li>失败：页错误异常（page fault）</li>
</ul>
</li>
<li>限制因素，大量的关联存储非常昂贵<ul>
<li>难以在单个时钟周期内完成</li>
<li>耗电</li>
</ul>
</li>
</ul>
<h3 id="基于哈希（hash）的方案"><a href="# 基于哈希（hash）的方案" class="headerlink" title="基于哈希（hash）的方案"></a>基于哈希（hash）的方案 </h3><p> 基于哈希的方案可以有效缓解页帧号 - 页号的映射的开销，需要硬件帮助，但会出现哈希冲突。哈希冲突是指不同的页号可能映射到相同的页帧号，这会导致冲突和错误的映射。</p>
<h4 id="方案 -1"><a href="# 方案 -1" class="headerlink" title="方案"></a>方案 </h4><p> 在基于哈希的反向页表中，为了解决哈希冲突，可以利用进程的 <code>PID</code>，在哈希函数的基础上再加一个 <code>PID</code> 参数，标记当前运行程序的编号，根据 <code>hash(PID, p)</code> 哈希函数，算出当前进程的页号所对应的页帧号。</p>
<img src="/images/os-kernel/chapter4/hash-reverse-page-table.png" alt="基于哈希的方案" width="60%" height="60%">

<h4 id="映射过程"><a href="# 映射过程" class="headerlink" title="映射过程"></a>映射过程 </h4><p> 基于哈希的反向页表解决哈希冲突示意图（图中 vpn 表示虚拟页号，ppn 表示物理页帧号）：<br><img src="/images/os-kernel/chapter4/hash-reverse-page-table-hash-collisions.png" alt="基于哈希的反向页表解决哈希冲突" width="60%" height="60%"></p>
<p>上图为基于哈希的反向页表解决哈希冲突，并搜索一个页对应的页帧号的过程，可以按照以下步骤进行：</p>
<ol>
<li><p>对 <code>PID</code> 和页号做哈希计算 <code>hash(PID, p)</code>，并使用它作为页寄存器表的索引，获取对应的页寄存器内容。</p>
<ul>
<li>如果寄存器表项中包含 <code>p</code> 和 <code>PID</code>，则搜索成功，索引号就是页帧号；</li>
<li>如果寄存器表项中不包含 <code>p</code> 和 <code>PID</code>，说明存在哈希冲突。</li>
</ul>
</li>
<li><p>如果存在哈希冲突：</p>
<ul>
<li>在表项中寻找 <code>next</code> 提供的页寄存器索引，通过该索引，重复步骤 1，直到寄存器表项中包含 <code>p</code> 和 <code>PID</code> 为止。</li>
</ul>
</li>
<li><p>获取页帧号后，根据页帧号和页内偏移可以计算出虚拟地址映射的物理地址，并进行数据访问。</p>
</li>
</ol>
<blockquote>
<p>这样，即使存在哈希冲突，不同的进程会根据不同的 <code>PID</code> 选择不同的页帧号，从而避免了冲突和错误的映射。</p>
</blockquote>
<h4 id="劣势 -2"><a href="# 劣势 -2" class="headerlink" title="劣势"></a>劣势 </h4><p> 基于哈希的反向页表还是需要把反向页表放到内存中，做哈希计算时也需要到内存中取值。由于内存访问的时间开销较大，所以还需要有一个类似 TLB 的机制缓存起来，避免频繁地访问内存，提高寻址的效率。</p>
<h4 id="优势 -1"><a href="# 优势 -1" class="headerlink" title="优势"></a>优势 </h4><p> 目前来说，这种机制只在高端 CPU 中存在，好处：</p>
<ul>
<li>表的容量可以做的很小，只和物理空间关联</li>
<li>反向页表只有一张，它的大小只跟物理地址空间的大小相对应，所以它占的空间节省很多；但它是有代价的，它需要以一种很高速的哈希计算、硬件处理机制、高效函数以及解决冲突的机制才可以使访问的效率得到保障。这种机制由硬件、相应的操作系统软件配合，可以在空间和时间上取得比较好的结果。</li>
</ul>
<blockquote>
<p>参考资料<br>1：<a target="_blank" rel="noopener" href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a><br>2：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_53407527/article/details/124891795">https://blog.csdn.net/weixin_53407527/article/details/124891795</a></p>
</blockquote>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a>
              <a href="/tags/%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" rel="tag"># 非连续内存分配</a>
              <a href="/tags/%E9%A1%B5%E8%A1%A8/" rel="tag"># 页表</a>
              <a href="/tags/%E5%8F%8D%E5%90%91%E9%A1%B5%E8%A1%A8/" rel="tag"># 反向页表</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/231117095232.html" rel="prev" title="数据结构算法之 Dijkstra 单源最短路径（原理部分）">
                  <i class="fa fa-angle-left"></i> 数据结构算法之 Dijkstra 单源最短路径（原理部分）
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/231121152713.html" rel="next" title="数据结构算法之 Dijkstra 单源最短路径（实现部分）">
                  数据结构算法之 Dijkstra 单源最短路径（实现部分） <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">aha</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">286k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">8:41</span>
  </span>
</div>
<div class="busuanzi-count">
</div>
  <div class="powered-by">
    <!--由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动 -->
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="150" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script src="https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#3F3F3F',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
