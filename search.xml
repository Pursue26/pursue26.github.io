<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C 语言之 const 关键字</title>
    <url>/posts/230913200729.html</url>
    <content><![CDATA[<p>宏定义 <code>#define</code> 和 <code>const</code> 关键字在 C 语言中有不同的用途：</p>
<ol>
<li><p><code>#define</code> 用于定义宏常量，它在编译前进行简单的文本替换，没有类型检查和作用域限制。宏常量的值可以是任意的表达式，包括函数调用和运算符操作，但容易导致代码的可读性和可维护性降低。</p>
</li>
<li><p><code>const</code> 关键字用于定义常量变量，具有类型检查和作用域限制的特性。常量变量的值在定义后不能被修改，提高了代码的可读性和可维护性。常量变量的作用域仅限于定义它的代码块内，其他代码块无法访问该常量。</p>
</li>
<li><p><code>const</code> 关键字还可以用于定义指向常量的指针、常量指针以及指向常量的常量指针。这些用法可以在编译阶段进行类型检查，避免了在运行时可能出现的错误。</p>
</li>
<li><p>编译器通常不会为 <em> 普通的</em> <code>const</code> 常量分配存储空间，而是将它们保存在符号表中，成为编译期间的常量。这样可以避免存储和读内存的操作，提高程序的执行效率。</p>
</li>
</ol>
<p>综上所述，虽然 <code>#define</code> 可以用于定义常量，但 <code>const</code> 关键字更加推荐，因为它提供了类型检查和作用域限制，提高了代码的可读性和可维护性，同时能够进行编译期间的优化。</p>
<span id="more"></span>

<h2 id="修饰常量变量（Constant-Variables）"><a href="# 修饰常量变量（Constant-Variables）" class="headerlink" title="修饰常量变量（Constant Variables）"></a>修饰常量变量（Constant Variables）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> var = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> var = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>这两种写法是等价的，都表示变量 <code>n</code> 的值不能被修改了。需要注意的是，用 <code>const</code> 修饰变量时，一定要给变量初始化，否则后续就不能赋值了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C program to demonstrate that constant variables can not be modified</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> var = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compilation error: assignment of read-only variable &#x27;var&#x27;</span></span><br><span class="line">    var = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修饰常量字符串"><a href="# 修饰常量字符串" class="headerlink" title="修饰常量字符串"></a>修饰常量字符串</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>字符指针指向的字符串是不能修改的 </strong>：在 C 语言中，字符串常量是以<strong> 只读方式 </strong> 存储的，编译器会将其 <strong> 存储在只读的数据段 </strong> 中。而使用 <code>const</code> 关键字修饰的指针变量，会告诉编译器不允许通过该指针修改指向的数据。</p>
<p>如果没有 <code>const</code> 的修饰，我们可能会在后面有意无意的写 <code>str[0]=&#39;x&#39;</code> 这样的语句，这样会导致对只读内存区域的赋值，然后程序会立刻异常终止。但是，有了 <code>const</code>，这个错误就能在程序被编译的时候被检查出来，这就是 <code>const</code> 的好处，让逻辑错误在编译期被发现。</p>
<h2 id="指针常量（Pointer-to-Constant）"><a href="# 指针常量（Pointer-to-Constant）" class="headerlink" title="指针常量（Pointer to Constant）"></a>指针常量（Pointer to Constant）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* ptr;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *ptr;</span><br></pre></td></tr></table></figure>

<p>这两种写法是等价的。指针常量可以更改指针 <code>ptr</code> 的地址，以指向任何其他同类型的变量，但不能更改指针 <code>ptr</code> 指向的对象的值。指针常量中的指针被存储在读写区域（read-write area），在本例中为堆栈，所指向的对象可能位于只读区域或读写区域。</p>
<blockquote>
<p>简言之：指针（的地址）可变；指针地址不变的前提下，其指向的内容不可变。</p>
</blockquote>
<p>变量 <code>i</code> 是变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C program to demonstrate that the pointer to point to any other integer variable, </span></span><br><span class="line"><span class="comment">// but the value of the object (entity) pointed can not be changed</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">/* ptr is pointer to constant */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* ptr = &amp;i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line">    <span class="comment">/* error: object pointed cannot be modified using the pointer ptr */</span></span><br><span class="line">    <span class="comment">/* error: assignment of read-only location &#x27;*ptr&#x27; */</span></span><br><span class="line">    *ptr = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    ptr = &amp;j; <span class="comment">/* valid */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量 <code>i</code> 本身就是常量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C program to demonstrate that the pointer to point to any other integer variable, </span></span><br><span class="line"><span class="comment">// but the value of the object (entity) pointed can not be changed</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* i is stored in read only area*/</span></span><br><span class="line">    <span class="type">int</span> <span class="type">const</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* pointer to integer constant. Here i</span></span><br><span class="line"><span class="comment">    is of type &quot;const int&quot;, and &amp;i is of</span></span><br><span class="line"><span class="comment">    type &quot;const int *&quot;. And ptr is of type</span></span><br><span class="line"><span class="comment">    &quot;const int *&quot;, types are matching no issue */</span></span><br><span class="line">    <span class="type">int</span> <span class="type">const</span>* ptr = &amp;i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* error: assignment of read-only location &#x27;*ptr&#x27; */</span></span><br><span class="line">    *ptr = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* valid. We call it up qualification. In</span></span><br><span class="line"><span class="comment">    C/C++, the type of &quot;int *&quot; is allowed to up</span></span><br><span class="line"><span class="comment">    qualify to the type &quot;const int *&quot;. The type of</span></span><br><span class="line"><span class="comment">    &amp;j is &quot;int *&quot; and is implicitly up qualified by</span></span><br><span class="line"><span class="comment">    the compiler to &quot;const int *&quot; */</span></span><br><span class="line"></span><br><span class="line">    ptr = &amp;j;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 C++ 中，不允许进行下限定（down qualification）操作，而在 C 中进行此操作可能会导致警告。下限定是指将已经限定了类型的变量赋值给没有限定类型的变量的情况。</p>
<p>在 C++ 和 C 中，上限定（up qualification）是允许的，不会引发警告或错误。上限定是指将没有限定类型的变量赋值给已经限定了类型的变量的情况。这意味着可以将一个没有限定类型的变量赋值给一个已经限定了类型的变量，而编译器会自动进行类型转换。上限定操作可以用于提升变量的类型精度或实现类型转换。例如，将一个整数赋值给一个浮点数变量，编译器会自动将整数转换为浮点数类型。</p>
</blockquote>
<p>下限定操作示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C program to demonstrate the down qualification</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="type">const</span> j = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ptr is pointing an integer object */</span></span><br><span class="line">    <span class="type">int</span>* ptr = &amp;i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The below assignment is invalid in C++, results in</span></span><br><span class="line"><span class="comment">    error In C, the compiler *may* throw a warning, but</span></span><br><span class="line"><span class="comment">    casting is implicitly allowed */</span></span><br><span class="line">    ptr = &amp;j;  <span class="comment">/* warning: assignment discards ‘const’ qualifier from pointer target type [-Wdiscarded-qualifiers] */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In C++, it is called &#x27;down qualification&#x27;. The type</span></span><br><span class="line"><span class="comment">    of expression &amp;j is &quot;const int *&quot; and the type of ptr</span></span><br><span class="line"><span class="comment">    is &quot;int *&quot;. The assignment &quot;ptr = &amp;j&quot; causes to</span></span><br><span class="line"><span class="comment">    implicitly remove const-ness from the expression &amp;j.</span></span><br><span class="line"><span class="comment">    C++ being more type restrictive, will not allow</span></span><br><span class="line"><span class="comment">    implicit down qualification. However, C++ allows</span></span><br><span class="line"><span class="comment">    implicit up qualification. The reason being, const</span></span><br><span class="line"><span class="comment">    qualified identifiers are bound to be placed in</span></span><br><span class="line"><span class="comment">    read-only memory (but not always). If C++ allows</span></span><br><span class="line"><span class="comment">    above kind of assignment (ptr = &amp;j), we can use &#x27;ptr&#x27;</span></span><br><span class="line"><span class="comment">    to modify value of j which is in read-only memory.</span></span><br><span class="line"><span class="comment">    The consequences are implementation dependent, the</span></span><br><span class="line"><span class="comment">    program may fail</span></span><br><span class="line"><span class="comment">    at runtime. So strict type checking helps clean code.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常量指针指向变量（Constant-Pointer-to-Variable）"><a href="# 常量指针指向变量（Constant-Pointer-to-Variable）" class="headerlink" title="常量指针指向变量（Constant Pointer to Variable）"></a>常量指针指向变量（Constant Pointer to Variable）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="type">const</span> ptr;</span><br></pre></td></tr></table></figure>

<p>上面的声明是一个指向整型变量的常量指针，这意味着我们可以改变该指针所指向的对象的值，但不能改变该指针指向另一个变量。</p>
<blockquote>
<p>简言之：指针（地址）是常量，不可变；指针指向的变量可变。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C program to demonstrate that the value of object pointed</span></span><br><span class="line"><span class="comment">// by pointer can be changed but the pointer can not point to another variable</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* constant pointer to integer */</span></span><br><span class="line">    <span class="type">int</span>* <span class="type">const</span> ptr = &amp;i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line"></span><br><span class="line">    *ptr = <span class="number">100</span>; <span class="comment">/* valid */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* error: assignment of read-only variable &#x27;ptr&#x27; */</span></span><br><span class="line">    ptr = &amp;j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常量指针指向常量（Constant-Pointer-to-Constant）"><a href="# 常量指针指向常量（Constant-Pointer-to-Constant）" class="headerlink" title="常量指针指向常量（Constant Pointer to Constant）"></a>常量指针指向常量（Constant Pointer to Constant）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> ptr;</span><br></pre></td></tr></table></figure>

<p>上面的声明是一个指向常量变量的常量指针，这意味着我们不能更改指针所指向的值，也不能将指针指向其他变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C program to demonstrate that value pointed by the</span></span><br><span class="line"><span class="comment">// pointer can not be changed as well as we cannot point the</span></span><br><span class="line"><span class="comment">// pointer to other variables</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* constant pointer to constant integer */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> ptr = &amp;i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line"></span><br><span class="line">    ptr = &amp;j; <span class="comment">/* error: assignment of read-only variable &#x27;ptr&#x27; */</span></span><br><span class="line">    *ptr = <span class="number">100</span>; <span class="comment">/* error: assignment of read-only location &#x27;*ptr&#x27; */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Type</th>
<th>Declaration</th>
<th>Pointer Value Change</th>
<th>Pointing Value Change</th>
</tr>
</thead>
<tbody><tr>
<td>Pointer to Variable</td>
<td><code>int *ptr</code></td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Pointer to Constant</td>
<td><code>const int *ptr</code></td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Pointer to Constant</td>
<td><code>int const *ptr</code></td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Constant Pointer to Variable</td>
<td><code>int* const ptr</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>Constant Pointer to Constant</td>
<td><code>const int* const ptr</code></td>
<td>No</td>
<td>No</td>
</tr>
</tbody></table>
<p>注：</p>
<ol>
<li><p>Pointer Value Change（指向的值的改变），如 <code>*ptr = 100</code></p>
</li>
<li><p>Pointing Value Change（指针的值的改变），如 <code>ptr = &amp;a</code></p>
</li>
<li><p>如果 <code>const</code> 在 <code>*</code> 的左边，那么 <code>const</code> 可以与类型互换位置，如 <code>const int *ptr</code> 等价于 <code>int const *ptr</code></p>
</li>
<li><p>被 <code>const</code> 修饰的变量，地址不可变还是值不可变，傻傻分不清？观察 <code>const</code> 靠近普通类型还是靠近指针类型：</p>
<ul>
<li>如果 <code>const</code> 靠近的是普通类型，那么常量变量的值不可变，指针地址可变，如 <code>const int *ptr</code>，<code>int const *ptr</code></li>
<li>如果 <code>const</code> 靠近的是指针类型，那么指针指向的基本类型的值可变，指针地址不可变，如 <code>int* const ptr</code></li>
</ul>
</li>
<li><p><strong>指针常量与常量指针记忆方法</strong>：只保留 <code>const</code> 和 <code>*</code>，从右往左读，如下：</p>
<ul>
<li><del>int</del> *<del>ptr</del>指针变量</li>
<li>const <del>int</del> *<del>ptr</del>指针常量</li>
<li><del>int</del> const *<del>ptr</del>指针常量</li>
<li><del>int</del>* const <del>ptr</del>常量指针</li>
<li>const <del>int</del>* const <del>ptr</del>常量指针指向常量变量</li>
</ul>
</li>
</ol>
<blockquote>
<p>参考链接：<a href="https://www.geeksforgeeks.org/const-qualifier-in-c/">https://www.geeksforgeeks.org/const-qualifier-in-c/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>const关键字</tag>
        <tag>下限定</tag>
        <tag>上限定</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之 main 函数参数</title>
    <url>/posts/230916171929.html</url>
    <content><![CDATA[<h2 id="指令行操作"><a href="# 指令行操作" class="headerlink" title="指令行操作"></a> 指令行操作 </h2><p>C 语言支持从 CLI（指令行）传入参数给 main() 函数，多个命令行参数之间用空格分隔，但是如果参数本身带有空格，那么就使用双引号或单引号。</p>
<p>C 语言的 main 函数是程序的入口函数，它可以有两种形式的参数：</p>
<span id="more"></span>

<ol>
<li><p> 无参数形式：main 函数的原型可以是 <code>int main(void)</code>。这表示不接受任何参数，程序执行时不需要从命令行传递参数给 main 函数。</p>
</li>
<li><p> 带参数形式：main 函数的原型可以是 <code>int main(int argc, char *argv[])</code>。其中，<code>argc</code> 表示命令行参数的个数，而 <code>argv</code> 是一个字符串指针数组，每个元素都是一个命令行参数的字符串。</p>
<ul>
<li><code>argc</code> 标识传入的参数个数。如果没有提供任何参数，<code>argc</code> 将被设置为 1；否则，<code>argc</code> 将被设置为传入的参数个数加 1。</li>
<li><code>argv[0]</code> 通常是程序的名称或路径的字符串。</li>
<li><code>argv[1]</code> 到 <code>argv[argc - 1]</code> 是命令行传递给程序的参数，以空格分隔。</li>
</ul>
</li>
</ol>
<p> 值得注意的是，也可以使用 <code>char **argv</code> 来代替 <code>char *argv[]</code> 形参，两者具有相同的类型含义。因为数组变量名 <code>argv</code> 就是指向 <code>argv[]</code> 数组的第一个元素的指针，同时又因为第一个元素的数值就是一个指针，所以此时的数组变量名 <code>argv</code> 的本质就是一个指针的指针（双重指针）。</p>
<p> 下面是一个例子，演示如何使用带参数的 main 函数来接收命令行参数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;number of params: %d\n&quot;</span>, argc);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;param-%d: %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 如果编译并运行这个程序，并在命令行中输入参数，例如 <code>./a.out arg1 arg2 3 arg4</code>，则输出如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">number of params: 5</span><br><span class="line">param-0: ./a.out</span><br><span class="line">param-1: arg1</span><br><span class="line">param-2: arg2</span><br><span class="line">param-3: 3</span><br><span class="line">param-4: arg4</span><br></pre></td></tr></table></figure>

<p> 参考链接：<a href="https://is-cloud.blog.csdn.net/article/details/105347737">https://is-cloud.blog.csdn.net/article/details/105347737</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>main函数参数</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之 typedef 实践</title>
    <url>/posts/230920172849.html</url>
    <content><![CDATA[<p>在 <a href="https://pursue26.github.io/posts/230918174223.html">C 语言之 typedef 自定义类型基础</a> 中介绍了 <code>typedef</code> 的使用，下面介绍一些 <code>typedef</code> 的实践。</p>
<span id="more"></span>

<h2 id="两大陷阱"><a href="# 两大陷阱" class="headerlink" title="两大陷阱"></a>两大陷阱 </h2><h3 id="不是简单的字符串替换"><a href="# 不是简单的字符串替换" class="headerlink" title="不是简单的字符串替换"></a> 不是简单的字符串替换</h3><p><code>typedef</code> 是定义了一种类型的新别名，不同于宏，它不是简单的字符串替换。</p>
<p>当 <code>const</code> 与 <code>typedef</code> 相结合时，如定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* PSTR;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mystrcmp</span><span class="params">(<span class="type">const</span> PSTR, <span class="type">const</span> PSTR)</span>;</span><br></pre></td></tr></table></figure>

<p><code>const PSTR</code> 实际上相当于指针常量 <code>const char*</code> 吗？</p>
<p>不是的，它实际上相当于 <code>char* const</code>。这是因为 <code>const</code> 给予了整个指针本身以常量性，也就是形成了常量指针。简单来说，记住当 <code>const</code> 和 <code>typedef</code> 一起出现时，<code>typedef</code> 不会是简单的字符串替换就行。</p>
<h3 id="与其它存储类关键字不共存"><a href="# 与其它存储类关键字不共存" class="headerlink" title="与其它存储类关键字不共存"></a>与其它存储类关键字不共存 </h3><p><code>typedef</code> 在语法上是一个<strong> 存储类关键字</strong>，虽然它并不真正影响对象的存储特性，但变量只能被一种储类的关键字修饰。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">static</span> <span class="type">int</span> SINT_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">auto</span> <span class="type">int</span> AINT_t;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">typedef</span> <span class="type">int</span> INT_t;</span><br></pre></td></tr></table></figure>

<p>上述代码中，有两个存储类关键字，会编译将失败，报错 error: multiple storage classes in declaration specifiers</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INT_t;</span><br><span class="line"><span class="type">static</span> INT_t a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>这种写法是合法的。</p>
<blockquote>
<p>其它存储类关键字有 <code>auto</code>、<code>extern</code>、<code>mutable</code>、<code>static</code>、<code>register</code> 等。</p>
</blockquote>
<h2 id="typedef、const 与 define 结合"><a href="#typedef、const 与 define 结合" class="headerlink" title="typedef、const 与 define 结合"></a>typedef、const 与 define 结合 </h2><p> 示例 1：通常讲，<code>typedef</code> 要比 <code>define</code> 要好，<strong>特别是在有指针的场合</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> pStr2 char*</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* pStr1;</span><br><span class="line"></span><br><span class="line">pStr1 s1, s2;  </span><br><span class="line">pStr2 s3, s4;</span><br></pre></td></tr></table></figure>

<p>在上述的变量定义中，<code>s1</code>、<code>s2</code>、<code>s3</code>都被定义为 <code>char *</code>，而<code>s4</code> 则定义成了 <code>char</code>，不是我们所预期的指针变量，根本原因就在于<code>define</code> 只是简单的字符串替换而 <code>typedef</code> 则是为一个类型起新名字。</p>
<p>示例 2：当 <code>const</code> 和<code>typedef</code>一起出现时，<code>typedef</code>不会是简单的字符串替换。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* pStr;</span><br><span class="line"><span class="type">char</span> s[<span class="number">4</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *p1 = s;</span><br><span class="line"><span class="type">const</span> pStr p2 = s; <span class="comment">// 实际为 char* const p2 = s;</span></span><br><span class="line"></span><br><span class="line">p1++;  <span class="comment">// 指针常量的指针可变</span></span><br><span class="line">p2++;  <span class="comment">// 编译报错, 常量指针的指针不可变</span></span><br><span class="line">*p1 = <span class="string">&#x27;m&#x27;</span>;  <span class="comment">// 编译报错, 指针常量的值不可变</span></span><br><span class="line"></span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">s[<span class="number">1</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s = %s, %c\r\n&quot;</span>, s, *p1, *p2);  <span class="comment">//dec, e, d</span></span><br><span class="line">*p2 = <span class="string">&#x27;m&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s = %s, %c\r\n&quot;</span>, s, *p1, *p2);  <span class="comment">//mec, e, m</span></span><br></pre></td></tr></table></figure>

<p>示例中，</p>
<ul>
<li><code>const char *p1</code>是限定数据类型为 <code>char *</code> 的指针变量可变，指针变量指向的对象不可变，所以 <code>p1++</code> 正确；</li>
<li><code>p2++</code>出错了，这个问题再一次提醒我们：<code>typedef</code>和 <code>define</code> 不同，它不是简单的文本替换；</li>
<li><code>const pStr p2</code>并不等于 <code>const char *p2</code>，<code>const pStr p2</code> 和<code>const long x</code>本质上没有区别，都是对变量进行只读限制，只不过此处变量 <code>p2</code> 的数据类型是我们自己定义的，而不是系统固有类型。因此，<code>const pStr p2</code>的含义是：限定数据类型为 <code>char *</code> 的指针变量 <code>p2</code> 为只读，因此 <code>p2++</code> 错误。</li>
</ul>
<h2 id="抑制劣质代码"><a href="# 抑制劣质代码" class="headerlink" title="抑制劣质代码"></a>抑制劣质代码 </h2><p> 人们常常使用 <code>typedef</code> 来编写更美观和可读的代码。所谓美观，意指 <code>typedef</code> 能隐藏笨拙的语法构造以及平台相关的数据类型，从而增强可移植性以及未来的可维护性。在编程中使用 <code>typedef</code> 目的一般有两个，一个是给变量一个易记且意义明确的新名字，另一个是简化一些比较复杂的类型声明。</p>
<h3 id="定义易于记忆的类型名"><a href="# 定义易于记忆的类型名" class="headerlink" title="定义易于记忆的类型名"></a>定义易于记忆的类型名</h3><p><code>typedef</code> 使用最多的地方是创建易于记忆的类型名，用它来归档程序员的意图。类型出现在所声明的变量名字中，位于 <code>typedef</code> 关键字右边。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure>

<p>此声明定义了一个 <code>int</code> 的同义字，名字为 <code>size</code>。注意 <code>typedef</code> 并不创建新的类型，它仅仅为现有类型添加一个同义字。因此，你可以在任何需要 <code>int</code> 的上下文中使用 <code>size</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">measure</span><span class="params">(size *pSize)</span>;</span><br><span class="line">size <span class="built_in">array</span>[<span class="number">4</span>];</span><br><span class="line">size len = file.getlength();</span><br></pre></td></tr></table></figure>

<p><code>typedef</code> 还可以掩饰复合类型，如指针和数组。例如，你不用像下面这样重复定义有 81 个字符元素的数组：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> line[<span class="number">81</span>];</span><br><span class="line"><span class="type">char</span> text[<span class="number">81</span>];</span><br></pre></td></tr></table></figure>

<p>定义一个 <code>typedef</code>，每当要用到相同类型和大小的数组时，可以这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> Line[<span class="number">81</span>];</span><br><span class="line">Line text, secondline;</span><br><span class="line">getline(text);</span><br></pre></td></tr></table></figure>

<p>同样，也可以像下面这样隐藏指针语法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">char</span> *<span class="type">pstr_t</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mystrcmp</span><span class="params">(<span class="type">pstr_t</span>, <span class="type">pstr_t</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>记住</strong>，不管什么时候，只要为指针声明 <code>typedef</code>，都要在最终的 <code>typedef</code> 名称中加一个 <code>const</code>，比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">char</span> *<span class="type">cpstr_t</span>;  <span class="comment">// 指针常量, 使得该指针可变, 而指针指向的对象不可变（只读）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* <span class="type">const</span> <span class="type">cpstr_t</span>;  <span class="comment">// 常量指针, 使得该指针不可变（只读）, 但指针指向的对象可变的</span></span><br></pre></td></tr></table></figure>

<h3 id="简化代码"><a href="# 简化代码" class="headerlink" title="简化代码"></a>简化代码 </h3><p> 上面讨论的 <code>typedef</code> 行为有点像 <code>define</code> 宏，用其实际类型替代同义字。不同点是 <code>typedef</code> 在编译时被解释，因此可以让编译器来应付超越预处理器能力的文本替换。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*PF)</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *)</span>;</span><br></pre></td></tr></table></figure>

<p>这个声明引入了 <code>PF</code> 类型作为函数指针的同义字，该函数有两个 <code>const char *</code> 类型的参数以及一个 <code>int</code> 类型的返回值。如果要使用下列形式的函数声明，那么上述这个 <code>typedef</code> 是不可或缺的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PF <span class="title function_">Register</span><span class="params">(PF pf)</span>;</span><br></pre></td></tr></table></figure>

<p><code>Register()</code> 的参数是一个 <code>PF</code> 类型的回调函数，返回某个函数的地址，其署名与先前注册的名字相同。下面我展示一下如果不用 <code>typedef</code>，我们是如何实现这个声明的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*Register (<span class="type">int</span> (*pf)(<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *))) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *); </span><br></pre></td></tr></table></figure>

<p>很少有程序员理解它是什么意思，更不用说这种费解的代码所带来的出错风险了。显然，这里使用 <code>typedef</code> 不是一种特权，而是一种必需。</p>
<p>持怀疑态度的人可能会问：“OK，还会有人写这样的代码吗？”，快速浏览一下揭示 <code>signal()</code> 函数的头文件 <code>&lt;csinal&gt;</code>，有一个同样接口的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// signal 原型</span></span><br><span class="line"><span class="type">void</span> (*signal(<span class="type">int</span> sig, <span class="type">void</span> (*func)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// typedef 优化后</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*pFun)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">pFun <span class="title function_">signal</span><span class="params">(<span class="type">int</span> sig, pFun func)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考链接：<a href="https://www.cnblogs.com/a-s-m/p/10995722.html">https://www.cnblogs.com/a-s-m/p/10995722.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>自定义类型</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之 typedef 自定义类型基础</title>
    <url>/posts/230918174223.html</url>
    <content><![CDATA[<p><code>typedef</code> 关键字用于自定义数据类型的一个别名，或者称之为「定义了一种新的数据类型」。可以有效简化定义一个复杂数据类型的代码实现。</p>
<span id="more"></span>

<h2 id="四个用途"><a href="# 四个用途" class="headerlink" title="四个用途"></a>四个用途 </h2><h3 id="定义一种类型的别名"><a href="# 定义一种类型的别名" class="headerlink" title="定义一种类型的别名"></a> 定义一种类型的别名 </h3><p> 定义一种类型的别名，而不只是简单的宏替换。例如，可以用作同时声明指针类型的 <strong> 多个对象</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* pa, pb;</span><br></pre></td></tr></table></figure>

<p>不符合意图，它只声明了一个指向字符变量的指针 <code>pa</code> 和一个字符变量<code>pb</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* PCHAR;</span><br><span class="line">PCHAR pa, pb;</span><br></pre></td></tr></table></figure>

<p>符合意图，同时声明了两个指向字符变量的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *pa, *pb;</span><br></pre></td></tr></table></figure>

<p>也符合意图，但相对来说没有用 <code>typedef</code> 的形式直观，尤其在需要大量指针的地方，<code>typedef</code> 的方式更省事。</p>
<h3 id="为结构体类型对象起别名"><a href="# 为结构体类型对象起别名" class="headerlink" title="为结构体类型对象起别名"></a>为结构体类型对象起别名</h3><p><code>typedef</code> 可以用在 <code>struct</code> 结构体中，为声明的 <code>struct</code> 结构体类型的对象起别名。</p>
<p><strong>声明 </strong> 结构体类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPOINT</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一般结构体变量的定义为 <code>struct struct_name obj_name</code>，如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPOINT</span> <span class="title">stCoor</span>;</span>  <span class="comment">// 定义一个结构体变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPOINT</span> *<span class="title">pstCoor</span> =</span> <span class="literal">NULL</span>; <span class="comment">// 定义一个结构体指针变量</span></span><br></pre></td></tr></table></figure>

<p><strong>定义 </strong> 结构体类型，而非定义结构体变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagPOINT</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125; stPOINT, *pstPOINT;</span><br></pre></td></tr></table></figure>

<p>使用 <code>typedef</code> 为 <code>struct</code> 声明的结构体类型起别名后，定义该结构体类型的变量时，可以不再书写 <code>struct</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">stPOINT stCoor;  <span class="comment">// 定义一个结构体变量</span></span><br><span class="line">pstPOINT pstCoor = <span class="literal">NULL</span>; <span class="comment">// 定义一个结构体指针变量</span></span><br><span class="line">stPOINT *pstCoor; <span class="comment">// 定义一个结构体指针变量</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面既有「声明」，又有「定义」，那声明结构体类型、定义结构体类型和定义结构体变量的区别：</p>
</blockquote>
<ul>
<li><p>声明结构体类型：只是指定了一个结构体的类型，它相当于一个模型，但其中并无具体数据，系统对之也 <strong> 不分配实际的内存单元</strong>。</p>
</li>
<li><p>定义结构体类型：使用 <code>typedef</code> 为 <code>struct</code> 声明的结构体类型起别名后，即定义了一个结构体类型，但此时 <strong> 未分配内存单元</strong>。</p>
</li>
<li><p>定义结构体变量：其中有具体的数据，也为变量分配内存单元。</p>
</li>
</ul>
<h3 id="定义与平台无关的类型"><a href="# 定义与平台无关的类型" class="headerlink" title="定义与平台无关的类型"></a>定义与平台无关的类型 </h3><p> 例如，定义一个叫 REAL 的浮点类型，在目标平台一上，让它表示最高精度的类型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> REAL;</span><br></pre></td></tr></table></figure>

<p>在不支持 <code>long double</code> 的平台二上，改为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> REAL;</span><br></pre></td></tr></table></figure>

<p>在连 <code>double</code> 都不支持的平台三上，改为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> REAL;</span><br></pre></td></tr></table></figure>

<p>也就是说，当跨平台时，只要修改 <code>typedef</code> 本身就行，不用对其他源码做任何修改。标准库就广泛使用了这个技巧，比如 <code>size_t</code>。</p>
<p>另外，因为 <code>typedef</code> 是定义了一种类型的新别名，不是简单的字符串替换，所以它比宏来得稳健（虽然有时候用宏也可以完成以上的用途）。</p>
<h3 id="为复杂的声明定义一个新的简单的别名"><a href="# 为复杂的声明定义一个新的简单的别名" class="headerlink" title="为复杂的声明定义一个新的简单的别名"></a>为复杂的声明定义一个新的简单的别名</h3><p><code>typedef</code> 为复杂的声明定义一个新的简单的别名的方法是：在原来的声明里逐步用别名替换一部分复杂声明，如此循环，把带变量名的部分留到最后替换，得到的就是原声明的最简化版。</p>
<p>示例一，原声明：<code>int *(*a[5])(int, char*)</code>，变量名为 <code>a</code>。</p>
<ol>
<li>直接用一个新别名 <code>pFun</code> 替换 <code>a</code> 就可以了，即 <code>typedef int *(*pFun)(int, char*)</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pFun a[<span class="number">5</span>];  <span class="comment">// 原声明的最简化版</span></span><br></pre></td></tr></table></figure>

<p>这里，变量 <code>a</code> 是一个数组，数组中的每个元素都是一个指向返回类型为 <code>int*</code>、参数为<code>(int, char*)</code> 的函数指针的指针。</p>
<p>示例二，原声明：<code>void (*b[10]) (void (*)())</code>，变量名为 <code>b</code>。</p>
<ol>
<li>先替换右边部分括号里的，即 <code>typedef void (*pFunParam)()</code>，其中 <code>pFunParam</code> 为别名一；</li>
<li>再替换左边的变量 <code>b</code>，即 <code>typedef void (*pFunx)(pFunParam)</code>，<code>pFunx</code> 为别名二；</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pFunx b[<span class="number">10</span>];  <span class="comment">// 原声明的最简化版</span></span><br></pre></td></tr></table></figure>

<p>这里，变量 <code>b</code> 是一个数组，数组中的每个元素都是一个指向「返回类型为<code>void</code>、参数为一个指向返回类型为<code>void</code>、没有任何参数的函数指针的指针」的指针。</p>
<p>示例三，原声明：<code>doube(*)() (*e)[9]</code>，变量名为 <code>e</code>。</p>
<ol>
<li>先替换左边部分，<code>pFuny</code> 为别名一：<code>typedef double(*pFuny)()</code></li>
<li>再替换右边的变量 <code>e</code>，<code>pFunParamy</code> 为别名二：<code>typedef pFuny (*pFunParamy)[9]</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pFunParamy e;  <span class="comment">// 原声明的最简化版</span></span><br></pre></td></tr></table></figure>

<p>这里，变量 <code>e</code> 是一个指针，<strong>指向 </strong> 一个有 9 个元素的指针数组，数组中的每个元素都是一个指向没有形参、返回值类型为 <code>double</code> 的函数指针。</p>
<blockquote>
<p>示例一与示例三是有差别的，前者是指针数组，后者是指针，只是指向的是一个指针数组。</p>
</blockquote>
<h2 id="右左原则"><a href="# 右左原则" class="headerlink" title="右左原则"></a>右左原则 </h2><p> 理解复杂声明可用的「右左法则」：从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*func)(<span class="type">int</span> *p);</span><br></pre></td></tr></table></figure>

<p>上面的示例中，</p>
<ol>
<li>首先，找到变量名 <code>func</code>，外面有一对圆括号，而且左边是一个<code>*</code> 号，这说明 <code>func</code> 是一个指针；</li>
<li>然后，跳出这个圆括号，先看右边，又遇到圆括号，这说明 <code>(*func)</code> 是一个函数，所以 <code>func</code> 是一个指向这类函数的指针，即函数指针，这类函数具有 <code>int*</code> 类型的形参，返回值类型是<code>int</code>。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*func[<span class="number">5</span>])(<span class="type">int</span> *);</span><br></pre></td></tr></table></figure>
<p>上面的示例中，</p>
<ol>
<li>首先，找到变量名 <code>func</code>，右边是一个<code>[]</code> 运算符，说明 <code>func</code> 是具有 5 个元素的数组；</li>
<li>然后，遇到圆括号了，调转阅读方向，<code>func</code>的左边有一个 <code>*</code>，说明<code>func</code> 的元素是指针（注意这里的 <code>*</code> 不是修饰 <code>func</code>，而是修饰<code>func[5]</code> 的，原因是 <code>[]</code> 运算符优先级比 <code>*</code> 高，<code>func</code>先跟 <code>[]</code> 结合）；</li>
<li>最后，跳出这个括号，看右边，又遇到圆括号，说明 <code>func</code> 数组的元素是函数类型的指针，它指向的函数具有 <code>int*</code> 类型的形参，返回值类型为<code>int</code>。</li>
</ol>
<p>也可以记住这 2 个模式：</p>
<ul>
<li><code>type (*)(....)</code> ——— 函数指针   </li>
<li><code>type (*)[]</code> ——— 数组指针</li>
</ul>
<h2 id="函数指针和数组指针示例"><a href="# 函数指针和数组指针示例" class="headerlink" title="函数指针和数组指针示例"></a>函数指针和数组指针示例 </h2><h3 id="函数指针"><a href="# 函数指针" class="headerlink" title="函数指针"></a> 函数指针 </h3><p> 函数指针是指向函数的指针变量，它可以存储函数的地址。通过函数指针可以在程序运行时动态地调用不同的函数。函数指针的声明方式为：<code>返回类型 (* 指针变量名)(参数列表)</code>。</p>
<p>以下是一个函数指针的示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*pFun)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>; <span class="comment">// 定义一个函数指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    pFun ptr = add; <span class="comment">// 指向 add 函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2 + 3 = %d\n&quot;</span>, ptr(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 调用 add 函数</span></span><br><span class="line"></span><br><span class="line">    ptr = subtract; <span class="comment">// 指向 subtract 函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;5 - 2 = %d\n&quot;</span>, ptr(<span class="number">5</span>, <span class="number">2</span>)); <span class="comment">// 调用 subtract 函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组指针"><a href="# 数组指针" class="headerlink" title="数组指针"></a>数组指针 </h3><p> 数组指针是指向数组的指针变量，它可以存储数组的地址。通过数组指针可以访问数组的元素。数组指针的声明方式为：<code>数据类型 (* 指针变量名)[数组长度]</code>。</p>
<p>以下是一个数组指针的示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*pArr)</span>[5]; <span class="comment">// 定义一个数组指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    pArr ptr = &amp;arr; <span class="comment">// 指向 arr 数组</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Array elements: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, (*ptr)[i]); <span class="comment">// 通过数组指针访问数组元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>自定义类型</tag>
        <tag>右左原则</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之 uthash 哈希表基础</title>
    <url>/posts/230922172626.html</url>
    <content><![CDATA[<p>由于 C 语言本身不存在哈希，但当需要使用哈希表的时候，自己构建又会异常复杂。因此，我们可以调用开源的第三方库 <code>uthash.h</code>，<strong>这只是一个头文件</strong>。我们需要做的就是将头文件通过 <code>#include &quot;uthash.h&quot;</code> 引入到自己的项目中。由于 <code>uthash</code> 仅是头文件，因此没有可链接的库代码。</p>
<span id="more"></span>

<h2 id="uthash 简介"><a href="#uthash 简介" class="headerlink" title="uthash 简介"></a>uthash 简介 </h2><p> 使用 <code>uthash</code> 添加、查找和删除通常是常数时间的操作，此哈希库的目标是简约、高效。它大约有 1000 行 C 代码，它会 <em> 自动内联</em>，因为它是作为宏实现的。</p>
<p><code>uthash</code> 还包括三个额外的头文件，主要提供链表、动态数组和动态字符串。</p>
<ul>
<li><code>utlist.h</code> 为 C 结构提供了链接列表宏。</li>
<li><code>utarray.h</code> 使用宏实现动态数组。</li>
<li><code>utstring.h</code> 实现基本的动态字符串。</li>
</ul>
<blockquote>
<p>内联是一种编译器优化，它将「函数调用」替换为「函数体的代码」。这样可以避免函数调用时所需的开销，从而提高性能。</p>
</blockquote>
<h2 id="uthash 的使用"><a href="#uthash 的使用" class="headerlink" title="uthash 的使用"></a>uthash 的使用 </h2><h3 id="初始化"><a href="# 初始化" class="headerlink" title="初始化"></a> 初始化 </h3><p> 这里我们将 <code>id</code> 作为一个索引值，也就是键 key，将 <code>name</code> 作为值 value，它可以是任意复杂结构。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uthash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;                    <span class="comment">/* key */</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    UT_hash_handle hh;         <span class="comment">/* makes this structure hashable */</span></span><br><span class="line">&#125; HashItem;</span><br><span class="line"></span><br><span class="line">HashItem *hashTbl = <span class="literal">NULL</span>;    <span class="comment">/* important! initialize to NULL */</span></span><br></pre></td></tr></table></figure>

<p>注意：结构中一定要包含 <code>UT_hash_handle hh</code>（<code>hh</code>不需要初始化）。它可以命名为任何名称，但是一般都命名为 <code>hh</code>。</p>
<h3 id="添加"><a href="# 添加" class="headerlink" title="添加"></a>添加</h3><ul>
<li><p><code>HASH_ADD_INT</code>：表示添加的键值为整型，参数为 <code>(head, keyfield_name, item_ptr)</code>；</p>
</li>
<li><p><code>HASH_ADD_STR</code>：表示添加的键值为字符串类型，参数为 <code>(head, keyfield_name, item_ptr)</code>；</p>
</li>
<li><p><code>HASH_ADD_PTR</code>：表示添加的键值为指针类型，参数为 <code>(head, keyfield_name, item_ptr)</code>；</p>
</li>
<li><p><code>HASH_ADD</code>：表示添加的键值可以是任意类型，参数为 <code>(hh_name, head, keyfield_name, key_len, item_ptr)</code>。</p>
</li>
</ul>
<p>这些常见的宏的参数可以看 <a href="https://troydhanson.github.io/uthash/userguide.html#_convenience_macros"> 这里 </a>，一般性的宏（如<code>HASH_ADD</code>）的参数可以看<a href="https://troydhanson.github.io/uthash/userguide.html#_general_macros"> 这里</a>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add_user</span><span class="params">(<span class="type">int</span> user_id, <span class="type">char</span> *name)</span> &#123;</span><br><span class="line">    HashItem *hashNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加前先进行重复性检查，因为当把两个相同 key 值的结构体添加到哈希表中时会报错 */</span></span><br><span class="line">    HASH_FIND_INT(hashTbl, &amp;user_id, hashNode);  <span class="comment">/* id already in the hash? */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 只有在哈希中不存在 ID 的情况下，才创建该项目并将其添加；否则，只修改已经存在的结构 */</span></span><br><span class="line">    <span class="keyword">if</span> (hashNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      hashNode = (HashItem *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashItem));</span><br><span class="line">      hashNode-&gt;id = user_id;</span><br><span class="line">      HASH_ADD_INT(hashTbl, id, hashNode);  <span class="comment">/* id: name of key field */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(hashNode-&gt;name, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>HASH_ADD_INT</code> 函数中，</p>
<ul>
<li>第一个参数 <code>hashTbl</code> 是哈希表；</li>
<li>第二个参数 <code>id</code> 是键字段的名称；</li>
<li>第三个参数 <code>hashNode</code> 是指向要添加的结构的指针。</li>
</ul>
<h3 id="将指向哈希指针的指针传递给函数（重要）"><a href="# 将指向哈希指针的指针传递给函数（重要）" class="headerlink" title="将指向哈希指针的指针传递给函数（重要）"></a>将指向哈希指针的指针传递给函数（重要）</h3><p>在上面的例子中 <code>hashTbl</code> 是一个全局变量，但是如果调用者想将哈希指针传递给函数 <code>add_user</code> 怎么办？乍一看，您似乎可以简单地将 <code>hashTbl</code> 作为参数传递，但这行不通。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_user</span><span class="params">(HashItem *obj, <span class="type">int</span> user_id, <span class="type">char</span> *name)</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  HASH_ADD_INT(obj, id, hashNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确地，你需要 <strong> 传递一个指向哈希指针的指针</strong>（a pointer to the hash pointer）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_user</span><span class="params">(HashItem **obj, <span class="type">int</span> user_id, <span class="type">char</span> *name)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  HASH_ADD_INT(*obj, id, hashNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>必须处理「指向哈希指针的指针」的原因很简单：散列宏会修改它（换句话说，它们修改指针地址本身，而不仅仅是它指向的内容）</strong>。</p>
<p>The reason it’s necessary to deal with a pointer to the hash pointer is simple: the hash macros modify it (in other words, they modify the <em>pointer itself</em> not just what it points to).</p>
<blockquote>
<p>假设哈希表 <code>hashTbl</code> 的指针（地址）是 <code>0x7fffd69b9a10</code>，那么通过运算符 <code>&amp;</code> 可以得到存放该地址的地址，假如为 <code>0x8defd69b9a26</code>，那么后续散列宏修改了哈希指针后，我们还可以通过地址 <code>0x8defd69b9a26</code> 指向的内容（哈希表的地址）来获取最新的哈希表地址。</p>
</blockquote>
<h3 id="查找"><a href="# 查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HashItem *<span class="title function_">find_user</span><span class="params">(<span class="type">int</span> user_id)</span> &#123;</span><br><span class="line">    HashItem *hashNode = <span class="literal">NULL</span>;</span><br><span class="line">    HASH_FIND_INT(hashTbl, &amp;user_id, hashNode);  <span class="comment">/* hashNode: output pointer */</span></span><br><span class="line">    <span class="keyword">return</span> hashNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>HASH_FIND_INT</code> 函数中，</p>
<ul>
<li>第一个参数 <code>hashTbl</code> 是哈希表；</li>
<li>第二个参数是 <code>user_id</code> 的地址（一定要传递地址）；</li>
<li>第三个参数 <code>hashNode</code> 是输出变量。</li>
</ul>
<p>当可以在哈希表中找到相应键值时，返回给定键的结构到 <code>hashNode</code>，当找不到时返回 <code>NULL</code> 到 <code>hashNode</code>。也就是说可以通过判断返回值是否为 <code>NULL</code> 来判断查找的键值是否存在于哈希表中。</p>
<h3 id="替换"><a href="# 替换" class="headerlink" title="替换"></a>替换</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">replace_user</span><span class="params">(HashItem *obj, HashItem *newHashNode)</span> &#123;</span><br><span class="line">    HashItem *oldHashNode = find_user(newHashNode-&gt;id);</span><br><span class="line">    <span class="keyword">if</span> (oldHashNode) &#123;</span><br><span class="line">        HASH_REPLACE_INT(hashTbl, id, newHashNode, oldHashNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>HASH_REPLACE</code> 宏等效于 <code>HASH_ADD</code> 宏，<code>HASH_REPLACE</code> 会尝试查找和删除项目，如果找到并删除了一个项目，它将返回该项目的指针作为输出参数。</p>
<h3 id="删除"><a href="# 删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delete_user</span><span class="params">(HashItem *hashNode)</span> &#123;</span><br><span class="line">    HASH_DEL(hashTbl, hashNode);  <span class="comment">/* user: pointer to delete */</span></span><br><span class="line">    <span class="built_in">free</span>(hashNode);             <span class="comment">/* optional; it&#x27;s up to you */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>要从哈希表中删除结构，必须具有指向它的指针（如果只有键值，应该先执行 <code>HASH_FIND</code> 以获取结构的指针）。</p>
</li>
<li><p>这里 <code>hashTbl</code> 是哈希表，<code>hashNode</code> 是指向我们要从哈希表中删除的结构的指针。删除结构只是将其从哈希表中删除，并非 <code>free</code>，何时释放结构的选择完全取决于自己，<code>uthash</code> 永远不会释放您的结构。</p>
</li>
</ol>
<h3 id="迭代删除"><a href="# 迭代删除" class="headerlink" title="迭代删除"></a>迭代删除 </h3><p> 上面的「删除」只能从哈希表中删除指定的一个结构，如果想将所有结构从哈希表中删除，可以使用迭代删除操作。</p>
<p><code>HASH_ITER</code> 宏是一个删除安全的迭代构造，它扩展为一个简单的 <code>for</code> 循环。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delete_all</span><span class="params">()</span> &#123;</span><br><span class="line">    HashItem *curr = <span class="literal">NULL</span>, *tmp = <span class="literal">NULL</span>;</span><br><span class="line">    HASH_ITER(hh, hashTbl, curr, tmp) &#123;</span><br><span class="line">        HASH_DEL(hashTbl, curr);  <span class="comment">/* delete; users advances to next */</span></span><br><span class="line">        <span class="built_in">free</span>(curr);               <span class="comment">/* optional- if you want to free  */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="一次性删除"><a href="# 一次性删除" class="headerlink" title="一次性删除"></a>一次性删除 </h4><p> 如果你只想删除所有的结构（哈希结点），而不释放它们的内存空间或进行任何逐个元素的清理操作，你可以使用单个操作更高效地完成这个任务。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HASH_CLEAR(hh, hashTbl);</span><br></pre></td></tr></table></figure>

<p>之后，列表头（这里是 <code>hashTbl</code>）将被设置为 <code>NULL</code>。</p>
<blockquote>
<p>在 uthash 中，ut 是 unordered tables，即无序表。</p>
<p>上面全大写的宏，为了方便，有些也被我叫成了函数。</p>
<p>上面的代码，未做充分的指针为空判断，实际使用指针前，要先进行不为空判断。</p>
</blockquote>
<h2 id="uthash 的实践"><a href="#uthash 的实践" class="headerlink" title="uthash 的实践"></a>uthash 的实践 </h2><p> 以 <a href="https://leetcode.cn/problems/two-sum/">LeetCode 两数之和 </a> 为例，介绍 <code>uthash.h</code> 哈希表的使用。</p>
<p>题目大意：从一个数组中找出两个索引不同的数，使得它们的和等于目标值，并返回这两个数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uthash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    UT_hash_handle hh;</span><br><span class="line">&#125; HashItem;</span><br><span class="line"></span><br><span class="line">HashItem *<span class="title function_">hashFindItem</span><span class="params">(HashItem **obj, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    HashItem *pEntry = <span class="literal">NULL</span>;</span><br><span class="line">    HASH_FIND_INT(*obj, &amp;key, pEntry);</span><br><span class="line">    <span class="keyword">return</span> pEntry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hashAddItem</span><span class="params">(HashItem **obj, <span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    HashItem *pEntry = hashFindItem(obj, key);</span><br><span class="line">    <span class="keyword">if</span> (pEntry == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pEntry = (HashItem *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashItem));</span><br><span class="line">        pEntry-&gt;key = key;</span><br><span class="line">        HASH_ADD_INT(*obj, key, pEntry);</span><br><span class="line">    &#125;</span><br><span class="line">    pEntry-&gt;val = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hashFree</span><span class="params">(HashItem **obj)</span> &#123;</span><br><span class="line">    HashItem *curr = <span class="literal">NULL</span>, *tmp = <span class="literal">NULL</span>;</span><br><span class="line">    HASH_ITER(hh, *obj, curr, tmp) &#123;</span><br><span class="line">        HASH_DEL(*obj, curr);  </span><br><span class="line">        <span class="built_in">free</span>(curr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *<span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    HashItem *hashTbl = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        <span class="comment">// 重要：传入的是指向哈希指针的指针</span></span><br><span class="line">        HashItem *hashNode = hashFindItem(&amp;hashTbl, nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (hashNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            hashAddItem(&amp;hashTbl, nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        HashItem *hashNode = hashFindItem(&amp;hashTbl, target - nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (hashNode &amp;&amp; hashNode-&gt;val != i) &#123;</span><br><span class="line">            *returnSize = <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> *ans = (<span class="type">int</span> *)<span class="built_in">malloc</span>((*returnSize) * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">            ans[<span class="number">0</span>] = i, ans[<span class="number">1</span>] = hashNode-&gt;val;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，我们定义了哈希表的查找、添加、释放接口，接口中的第一个参数均为指向哈希表指针的指针（二级指针），这是必须的。</p>
<ol>
<li>首先，在进行哈希操作前，先定义了一个哈希表 <code>hashTbl</code>，他是一个 <code>HashItem</code> 类型的指针；</li>
<li>然后，将数组中的键 - 值对（索引对应的值 - 索引）依次添加到哈希表中，并使用操作符 <code>&amp;</code> 获取指向哈希指针的指针；</li>
<li>最后，经过查找后，不再使用哈希表，这时通过释放接口，将哈希表中的所有哈希结点迭代地删除并释放对应的内存空间。</li>
</ol>
<p>如果哈希表的键值不是整形，而是字符类型呢，应该怎么使用呢？可以参考 <a href="https://pursue26.github.io/posts/230925185057.html#%20%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%AD%97%E5%85%B8%E6%A0%91"> 这里 </a> 的一个例子。</p>
<blockquote>
<p>源码地址：<a href="https://github.com/troydhanson/uthash">https://github.com/troydhanson/uthash</a></p>
</blockquote>
<blockquote>
<p>英文原版用户指导：<a href="https://troydhanson.github.io/uthash/userguide.html">https://troydhanson.github.io/uthash/userguide.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之多维数组</title>
    <url>/posts/230922143003.html</url>
    <content><![CDATA[<p>本文章主要介绍 C 语言创建多维数组的方式及其排序，包括静态多维数组、<code>malloc</code> 动态申请多维数组、指针数组的多维数组和多维结构体数组的创建。</p>
<span id="more"></span>

<h2 id="排序接口"><a href="# 排序接口" class="headerlink" title="排序接口"></a>排序接口</h2><p><code>qsort</code> 函数是 C 语言标准库中的一个排序函数，用于对数组进行快速排序。它的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qsort</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *base, </span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> nmemb, </span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> size, </span></span><br><span class="line"><span class="params">    <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>base</code>：指向需要排序的数组的第一个元素的指针。</li>
<li><code>nmemb</code>：数组中元素的个数。</li>
<li><code>size</code>：每个元素的大小（以字节为单位）。</li>
<li><code>compar</code>：指向比较函数的指针，用于指定数组元素的比较规则。</li>
</ul>
<p><code>base</code> 指定了待排序数组的首地址，再结合 <code>nmemb * size</code> 可以确定要排序的数组的范围。</p>
<p>比较函数 <code>compar</code> 的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">compar</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>a</code> 和 <code>b</code>：指向待比较的两个元素的指针。</li>
</ul>
<p>比较函数 <code>compar</code> 必须返回一个整数值，表示 <code>a</code> 和 <code>b</code> 的大小关系：</p>
<ul>
<li>如果 <code>a</code> 小于 <code>b</code>，则返回一个负整数。</li>
<li>如果 <code>a</code> 等于 <code>b</code>，则返回零。</li>
<li>如果 <code>a</code> 大于 <code>b</code>，则返回一个正整数。</li>
</ul>
<p>通过传入不同的比较函数，<code>qsort</code> 函数可以实现对不同类型的数组进行排序。</p>
<h2 id="静态多维数组"><a href="# 静态多维数组" class="headerlink" title="静态多维数组"></a>静态多维数组 </h2><h3 id="多维数组创建"><a href="# 多维数组创建" class="headerlink" title="多维数组创建"></a> 多维数组创建</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> rows = <span class="number">3</span>, cols = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> arr[rows][cols];</span><br></pre></td></tr></table></figure>

<h3 id="多维数组排序"><a href="# 多维数组排序" class="headerlink" title="多维数组排序"></a>多维数组排序 </h3><p> 按照二维数组第 0 列升序排序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">int</span> *)a)[<span class="number">0</span>] - ((<span class="type">int</span> *)b)[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入 cmp 函数指针的 arr 是一个一维指针</span></span><br><span class="line">qsort(arr, rows, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), cmp);  <span class="comment">// 快速排序</span></span><br></pre></td></tr></table></figure>

<h2 id="malloc 动态申请多维数组"><a href="#malloc 动态申请多维数组" class="headerlink" title="malloc 动态申请多维数组"></a>malloc 动态申请多维数组 </h2><h3 id="多维数组创建 -1"><a href="# 多维数组创建 -1" class="headerlink" title="多维数组创建"></a> 多维数组创建</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> rows = <span class="number">3</span>, cols = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态申请二维数组</span></span><br><span class="line"><span class="type">int</span> **arr = (<span class="type">int</span> **)<span class="built_in">malloc</span>(rows * <span class="keyword">sizeof</span>(<span class="type">int</span> *));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">    arr[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(cols * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(arr);</span><br></pre></td></tr></table></figure>

<p>释放 <code>malloc</code> 申请的多维数组时，不能直接 <code>free(arr)</code>，因为 <code>malloc</code> 和 <code>free</code> 执行次数要一致。</p>
<h3 id="多维数组排序 -1"><a href="# 多维数组排序 -1" class="headerlink" title="多维数组排序"></a>多维数组排序 </h3><p> 按照二维数组第 0 列升序排序，若相等，则按第 1 列升序排序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span> &#123;</span><br><span class="line">    <span class="comment">// a 是一个指向二维数组首行的指针</span></span><br><span class="line">    <span class="comment">// 通过类型转换和解引用操作, ap 指向了 a 所指向的整型数组的首地址</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* ap = *(<span class="type">int</span> **)a;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* bp = *(<span class="type">int</span> **)b;</span><br><span class="line">    <span class="keyword">if</span> (ap[<span class="number">0</span>] == bp[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ap[<span class="number">1</span>] - bp[<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ap[<span class="number">0</span>] - bp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入 cmp 函数指针的 arr 是一个二维指针</span></span><br><span class="line">qsort(arr, rows, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), cmp);</span><br></pre></td></tr></table></figure>

<h2 id="malloc 动态申请多维结构体数组"><a href="#malloc 动态申请多维结构体数组" class="headerlink" title="malloc 动态申请多维结构体数组"></a>malloc 动态申请多维结构体数组 </h2><h3 id="多维结构体数组创建"><a href="# 多维结构体数组创建" class="headerlink" title="多维结构体数组创建"></a> 多维结构体数组创建</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> rows = <span class="number">3</span>, cols = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">&#125; Node_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态申请二维数组</span></span><br><span class="line">Node_t **arr = (Node_t **)<span class="built_in">malloc</span>(rows * <span class="keyword">sizeof</span>(Node_t *));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">    arr[i] = (Node_t *)<span class="built_in">malloc</span>(cols * <span class="keyword">sizeof</span>(Node_t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">    <span class="comment">// 如果结构体成员中有指针且申请了空间, 则需要先释放成员的空间再释放结构体的空间</span></span><br><span class="line">    <span class="built_in">free</span>(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(arr);</span><br></pre></td></tr></table></figure>

<h3 id="多维结构体数组排序"><a href="# 多维结构体数组排序" class="headerlink" title="多维结构体数组排序"></a>多维结构体数组排序 </h3><p> 按照二维数组第 0 列的结构体成员 <code>x</code> 降序排序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// return (Node_t *)a-&gt;x - (Node_t *)b-&gt;x;   // 错误写法</span></span><br><span class="line">    <span class="keyword">return</span> ((Node_t *)a)-&gt;x - ((Node_t *)b)-&gt;x;   <span class="comment">// 正确写法 1</span></span><br><span class="line">    <span class="comment">// return (*(Node_t *)b).x - (*(Node_t *)a).x;     // 正确写法 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">qsort(arr, rows, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), cmp);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-&gt;</code> 操作符的优先级高于 <code>()</code> 操作符。</li>
</ul>
<h2 id="指针数组的多维数组"><a href="# 指针数组的多维数组" class="headerlink" title="指针数组的多维数组"></a>指针数组的多维数组 </h2><p> 使用指针数组的多维数组：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> rows = <span class="number">3</span>, cols = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* arr[rows];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cols; i++) &#123;</span><br><span class="line">    arr[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式创建的多维数组实际上是一个指针数组，每个指针指向一个一维数组，可以在运行时动态分配每个一维数组的大小（方便创建每行元素个数不同的多维数组）。</p>
<h3 id="多维数组排序 -2"><a href="# 多维数组排序 -2" class="headerlink" title="多维数组排序"></a>多维数组排序 </h3><p> 按照二维数组第 0 列降序排序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* ap = *(<span class="type">int</span> **)a;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* bp = *(<span class="type">int</span> **)b;</span><br><span class="line">    <span class="keyword">return</span> bp[<span class="number">0</span>] - ap[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入 cmp 函数指针的 arr 是一个二维指针</span></span><br><span class="line">qsort(arr, rows, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), cmp);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>多维数组</tag>
        <tag>数组排序</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之大小端知识</title>
    <url>/posts/230918114841.html</url>
    <content><![CDATA[<h2 id="字节序"><a href="# 字节序" class="headerlink" title="字节序"></a>字节序 </h2><h3 id="主机字节序"><a href="# 主机字节序" class="headerlink" title="主机字节序"></a> 主机字节序 </h3><p> 在计算机中，数据在内存中的存储是以 byte 为单位的。字节序是由于 CPU 对大于一个字节的变量，在内存中的存放顺序不同而产生的。</p>
<p>不同的计算机体系结构使用不同的字节序，对于大于一个字节的变量表示，有如下两种方式：</p>
<ul>
<li><p>小端模式（Listen Endian, LE）：高位字节存储在高位地址，而低位字节存储在低位地址，与大端模式相反。</p>
</li>
<li><p>大端模式（Big Endian, BE）：高位字节存储在低位地址，而低位字节存储在高位地址。</p>
</li>
</ul>
<span id="more"></span>

<p><img src="/images/le-be-endian.png" alt="大小端模式"></p>
<p>在小端字节序主机系统中进行字节序转换时，需要将低地址的字节和高地址的字节进行交换即可得到大端字节序。</p>
<h3 id="网络字节序"><a href="# 网络字节序" class="headerlink" title="网络字节序"></a>网络字节序 </h3><p> 不同的机器主机字节序不相同，与 CPU 设计有关，数据的顺序是由 CPU 决定的，而与操作系统无关。我们把某个给定系统所用的字节序称为主机字节序（host byte order）。比如 x86 系列 CPU 都是 little-endian 的字节序。</p>
<p>网络字节序是 TCP&#x2F;IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。网络字节序采用 big-endian 排序方式。</p>
<p>由于这个原因，为了确保数据在不同主机之间传输时能够被正确解释，需要在不同字节序之间进行转换，所以在网络通信中，一般需要将数据转换为网络字节序进行传输。</p>
<h2 id="主机字节序类型判断"><a href="# 主机字节序类型判断" class="headerlink" title="主机字节序类型判断"></a>主机字节序类型判断 </h2><p> 可以使用共用体（union）来判断当前 CPU 平台是大端字节序还是小端字节序。这是因为共用体的特点是：使用长度最大的数据类型作为共用体的大小。</p>
<ul>
<li><p>建立一个联合类型 <code>BYTE_ORDER_UN</code>，用于测试字节序，可以通过成员 <code>byte</code> 来访问 <code>value</code> 变量的高字节和低字节。</p>
</li>
<li><p>声明一个 <code>BYTE_ORDER_UN</code> 类型的变量 <code>unByteOrder</code>，将值 <code>0xabcd</code> 赋给成员变量 <code>value</code>。由于在类型 <code>BYTE_ORDER_UN</code> 中，<code>value</code> 和 <code>byte</code> 成员 <strong> 共享一块内存</strong>，所以可以通过 <code>byte</code> 的不同成员来访问 <code>value</code> 的高字节和低字节。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">byte_order</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> byte[<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span>)];</span><br><span class="line">&#125; BYTE_ORDER_UN;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    BYTE_ORDER_UN unByteOrder;</span><br><span class="line">    unByteOrder.value = <span class="number">0xabcd</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((unByteOrder.byte[<span class="number">0</span>] ==<span class="number">0xcd</span>) &amp;&amp; (unByteOrder.byte[<span class="number">1</span>] ==<span class="number">0xab</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Listen endian byte order, byte[0]: 0x%x, byte[1]: 0x%x\n&quot;</span>, \</span><br><span class="line">        unByteOrder.byte[<span class="number">0</span>], unByteOrder.byte[<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>((unByteOrder.byte[<span class="number">0</span>] ==<span class="number">0xab</span>) &amp;&amp; (unByteOrder.byte[<span class="number">1</span>] ==<span class="number">0xcd</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Big endian byte order, byte[0]: 0x%x, byte[1]: 0x%x\n&quot;</span>, \</span><br><span class="line">        unByteOrder.byte[<span class="number">0</span>], unByteOrder.byte[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主机系统为小端字节序的测试结果：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ gcc byteOrder.c -o byteOrder</span><br><span class="line">$ ./byteOrder</span><br><span class="line">Listen endian byte order, byte[0]: 0xcd, byte[1]: 0xab</span><br></pre></td></tr></table></figure>

<h2 id="主机字节序到网络字节序转换"><a href="# 主机字节序到网络字节序转换" class="headerlink" title="主机字节序到网络字节序转换"></a>主机字节序到网络字节序转换 </h2><p> 字节交换的作用是生成一个网络字节序的变量，<strong>其字节的顺序与主机类型和操作系统无关</strong>。进行网络字节序转换的时候，只要转换一次就可以了，不要进行多次的转换。如果进行多次字节序的转换，最后生成的网络字节序的值可能是错误的。例如：</p>
<ul>
<li><p>对于主机为小端字节序的系统，进行两次字节序转换的过程如下图所示，经过两次转换，最终的值与最初的主机字节序相同。</p>
</li>
<li><p>对于主机为大端字节序的系统，无论进行多少次字节序的转换，最终的值与最初的主机字节序相同。</p>
</li>
</ul>
<p><img src="/images/htos-conversion.png" alt="小端系统中的变量多次字节序转换"></p>
<p>下面的例子是对 16 位数值和 32 位数值进行字节序转换，每种类型的数值进行两次转换，最后打印结果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITS16 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITS32 32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">two_bytes_order</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> byte[<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">short</span>)];</span><br><span class="line">&#125; TWO_BYTES_ORDER_UN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">four_bytes_order</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> byte[<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span>)];</span><br><span class="line">&#125; FOUR_BYTES_ORDER_UN;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">showValue</span><span class="params">(<span class="type">void</span> *begin, <span class="type">int</span> flag)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ((flag) / <span class="number">8</span>); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%x (%p) &quot;</span>, *((<span class="type">unsigned</span> <span class="type">char</span> *)begin + i), (<span class="type">unsigned</span> <span class="type">char</span> *)begin + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    TWO_BYTES_ORDER_UN v16_orig, v16_turn1, v16_turn2;</span><br><span class="line">    FOUR_BYTES_ORDER_UN v32_orig, v32_turn1, v32_turn2;</span><br><span class="line"></span><br><span class="line">    v16_orig.value = <span class="number">0xabcd</span>;</span><br><span class="line">    v16_turn1.value = htons(v16_orig.value);</span><br><span class="line">    v16_turn2.value = htons(v16_turn1.value);</span><br><span class="line"></span><br><span class="line">    v32_orig.value = <span class="number">0x12345678</span>;</span><br><span class="line">    v32_turn1.value = htonl(v32_orig.value);</span><br><span class="line">    v32_turn2.value = htonl(v32_turn1.value);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;16 host to network byte order change:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\torig:    &quot;</span>);</span><br><span class="line">    showValue(v16_orig.byte, BITS16);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t1 times: &quot;</span>);</span><br><span class="line">    showValue(v16_turn1.byte, BITS16);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t2 times: &quot;</span>);</span><br><span class="line">    showValue(v16_turn2.byte, BITS16);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;32 host to network byte order change:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\torig:    &quot;</span>);</span><br><span class="line">    showValue(v32_orig.byte, BITS32);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t1 times: &quot;</span>);</span><br><span class="line">    showValue(v32_turn1.byte, BITS32);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t2 times: &quot;</span>);</span><br><span class="line">    showValue(v32_turn2.byte, BITS32);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小端模式到网络字节序转换的测试结果：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ gcc byteOrder2.c -o byteOrder2</span><br><span class="line">$ ./byteOrder2</span><br><span class="line">16 host to network byte order change:</span><br><span class="line">        orig:    cd (0x7ffcd6ad66de) ab (0x7ffcd6ad66df)</span><br><span class="line">        1 times: ab (0x7ffcd6ad66dc) cd (0x7ffcd6ad66dd)</span><br><span class="line">        2 times: cd (0x7ffcd6ad66da) ab (0x7ffcd6ad66db)</span><br><span class="line">32 host to network byte order change:</span><br><span class="line">        orig:    78 (0x7ffcd6ad66d0) 56 (0x7ffcd6ad66d1) 34 (0x7ffcd6ad66d2) 12 (0x7ffcd6ad66d3)</span><br><span class="line">        1 times: 12 (0x7ffcd6ad66c8) 34 (0x7ffcd6ad66c9) 56 (0x7ffcd6ad66ca) 78 (0x7ffcd6ad66cb)</span><br><span class="line">        2 times: 78 (0x7ffcd6ad66c0) 56 (0x7ffcd6ad66c1) 34 (0x7ffcd6ad66c2) 12 (0x7ffcd6ad66c3)</span><br></pre></td></tr></table></figure>

<p>16 位变量 0xabcd 在内存中的表示方式为 cd 在前，ab 在后；进行一次字节序转换后变为 ab 在前，cd 在后。在进行第一次转换后字节序发生了变化，而进行第二次字节序转换后与原始的排列方式一致。</p>
<h2 id="大小端的转换"><a href="# 大小端的转换" class="headerlink" title="大小端的转换"></a>大小端的转换 </h2><p> 上面的代码中 <code>htons</code> 和 <code>htonl</code>，分别给出了主机字节序到网络字节序的 <code>short</code> 和 <code>long</code> 类型的转换接口，那么这个接口是如何实现大小端转换的呢？</p>
<p><strong>通过位运算的方式来实现大小端的转换</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">little_endian_to_big_endian_4bytes</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((value &amp; <span class="number">0x000000ff</span>) &lt;&lt; <span class="number">24</span>) | </span><br><span class="line">           ((value &amp; <span class="number">0x0000ff00</span>) &lt;&lt; <span class="number">8</span>)  | </span><br><span class="line">           ((value &amp; <span class="number">0x00ff0000</span>) &gt;&gt; <span class="number">8</span>)  | </span><br><span class="line">           ((value &amp; <span class="number">0xff000000</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">little_endian_to_big_endian_2bytes</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((value &amp; <span class="number">0x00ff</span>) &lt;&lt; <span class="number">8</span>) | ((value &amp; <span class="number">0xff00</span>) &gt;&gt; <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> little_value4 = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> little_value2 = <span class="number">0xabcd</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> big_value4 = little_endian_to_big_endian_4bytes(little_value4);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> big_value2 = little_endian_to_big_endian_2bytes(little_value2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;LE2 value: 0x%04x\n&quot;</span>, little_value2);  <span class="comment">// LE2 value: 0xabcd</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;BE2 value: 0x%04x\n&quot;</span>, big_value2);  <span class="comment">// BE2 value: 0xcdab</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;LE4 value: 0x%08x\n&quot;</span>, little_value4);  <span class="comment">// LE4 value: 0x12345678</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;BE4 value: 0x%08x\n&quot;</span>, big_value4);  <span class="comment">// BE4 value: 0x78563412</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多变量存储在连续内存中的字节序转换"><a href="# 多变量存储在连续内存中的字节序转换" class="headerlink" title="多变量存储在连续内存中的字节序转换"></a>多变量存储在连续内存中的字节序转换 </h2><p> 示例 1：一个 2 字节变量存储在连续的内存中，与一个 4 字节变量存储在连续的内容中，从小端主机字节序转换为大端网络字节序后的结果一样吗？一样的！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">four_bytes_order</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> val1;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> val2;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> val3;</span><br><span class="line">&#125; FOUR_BYTES_ORDER_S;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITS16 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITS32 32</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">showValue</span><span class="params">(<span class="type">void</span> *begin, <span class="type">int</span> flag)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ((flag) / <span class="number">8</span>); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%x (%p) &quot;</span>, *((<span class="type">unsigned</span> <span class="type">char</span> *)begin + i), (<span class="type">unsigned</span> <span class="type">char</span> *)begin + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    FOUR_BYTES_ORDER_S sOrig, sTurn;</span><br><span class="line">    </span><br><span class="line">    sOrig.val1 = <span class="number">0x1234</span>;</span><br><span class="line">    sOrig.val2 = <span class="number">0x5678</span>;</span><br><span class="line">    sTurn.val1 = htons(sOrig.val1);</span><br><span class="line">    sTurn.val2 = htons(sOrig.val2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;16 + 16 host to network byte order change:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\thost:    &quot;</span>);</span><br><span class="line">    showValue(&amp;sOrig.val1, BITS32);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\tnetwork: &quot;</span>);</span><br><span class="line">    showValue(&amp;sTurn.val1, BITS32);</span><br><span class="line"></span><br><span class="line">    sOrig.val3 = <span class="number">0x12345678</span>;</span><br><span class="line">    sTurn.val3 = htonl(sOrig.val3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;32 host to network byte order change:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\thost:    &quot;</span>);</span><br><span class="line">    showValue(&amp;sOrig.val3, BITS32);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\tnetwork: &quot;</span>);</span><br><span class="line">    showValue(&amp;sTurn.val3, BITS32);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上述连续内存的两个 2 字节变量和一个 4 字节变量，转换成的网络字节序都是 <code>0x12345678</code>：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ gcc byteOrder2.c -o byteOrder3</span><br><span class="line">$ ./byteOrder3</span><br><span class="line">16 + 16 host to network byte order change:</span><br><span class="line">        host:    34 (0x7fffd69b9a10) 12 (0x7fffd69b9a11) 78 (0x7fffd69b9a12) 56 (0x7fffd69b9a13)</span><br><span class="line">        network: 12 (0x7fffd69b9a00) 34 (0x7fffd69b9a01) 56 (0x7fffd69b9a02) 78 (0x7fffd69b9a03)</span><br><span class="line">32 host to network byte order change:</span><br><span class="line">        host:    78 (0x7fffd69b9a18) 56 (0x7fffd69b9a19) 34 (0x7fffd69b9a1a) 12 (0x7fffd69b9a1b)</span><br><span class="line">        network: 12 (0x7fffd69b9a08) 34 (0x7fffd69b9a09) 56 (0x7fffd69b9a0a) 78 (0x7fffd69b9a0b)</span><br></pre></td></tr></table></figure>

<p>示例 2：一个变量 <code>0x12345678abcd9876</code>，分别以 <code>short + long + short</code> 和 <code>long + long</code> 变量存储在一个连续内容中，那么两种存储的小端主机字节序和大端网络字节序在内存中的存储的值顺序一致吗？一致的！</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">val_le = 0x12345678abcd9876</span><br><span class="line"></span><br><span class="line">short + long + short</span><br><span class="line">    a = 0x1234</span><br><span class="line">    b = 0x5678abcd</span><br><span class="line">    c = 0x9876</span><br><span class="line"></span><br><span class="line">分别给出其主机序和网络序：</span><br><span class="line">    内存低地址 -----------------------&gt; 内存高地址 </span><br><span class="line">    小端主机序：34 12 | cd ab 78 56 | 76 98</span><br><span class="line">    大端网络序：12 34 | 56 78 ab cd | 98 76</span><br><span class="line"></span><br><span class="line">long + long</span><br><span class="line">    d = 0x12345678</span><br><span class="line">    e = 0xabcd9876</span><br><span class="line"></span><br><span class="line"> 分别给出其主机序和网络序：</span><br><span class="line">    内存低地址 -----------------------&gt; 内存高地址</span><br><span class="line">    主机序：78 56 34 12 | 76 98 cd ab</span><br><span class="line">    网络序：12 34 56 78 | ab cd 98 76</span><br></pre></td></tr></table></figure>

<p>可以看出, 两种组合变量的主机序到网络序转换后的结果是一致的！</p>
<blockquote>
<p>参考：</p>
<ol>
<li><a href="https://blog.51cto.com/u_15249901/4893764">https://blog.51cto.com/u_15249901/4893764</a></li>
<li><a href="https://blog.csdn.net/Jmilk/article/details/106898871">https://blog.csdn.net/Jmilk/article/details/106898871</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>大小端</tag>
        <tag>字节序</tag>
        <tag>网络字节序</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之锁与原子操作基础</title>
    <url>/posts/230921094127.html</url>
    <content><![CDATA[<h2 id="常见锁介绍"><a href="# 常见锁介绍" class="headerlink" title="常见锁介绍"></a>常见锁介绍 </h2><p> 在 C 语言中，常见的用于解决多线程访问数据的锁包括互斥锁、读写锁、条件变量、自旋锁、屏蔽等。</p>
<span id="more"></span>

<ol>
<li><p>互斥锁（mutex）：互斥锁是一种 <strong> 最基本的锁机制 </strong>，用于<strong> 保护共享资源</strong>，防止多个线程同时访问和修改同一个资源。当一个线程持有了互斥锁后，其他线程需要等待该线程释放锁之后才能访问共享资源。</p>
</li>
<li><p>读写锁（read-write lock）：读写锁是一种 <strong> 特殊的锁机制 </strong>，它允许多个线程同时读取共享资源，但是<strong> 只允许一个线程写入共享资源</strong>。这种锁可以提高读取操作的并发度，同时保证写入操作的正确性和一致性。如果一个线程获取了写锁，其他线程就必须等待它释放锁后才能继续访问；如果一个线程获取了读锁，其他线程也可以获取读锁并访问资源。</p>
</li>
<li><p>条件变量（condition variable）：条件变量是一种 <strong> 用于线程之间通信的同步机制</strong>，它允许线程在某个条件成立时才能继续执行。通常与互斥锁一起使用，当条件变量不满足时，线程释放互斥锁并等待条件变量被激活（通过另一个线程来激活条件变量）；当条件变量满足时，通知线程重新获取互斥锁并继续执行。</p>
</li>
<li><p>自旋锁（spinlock）：自旋锁是一种 <strong> 忙等待锁机制 </strong>，当一个线程尝试获取锁时，如果锁已经被占用，它会一直循环等待直到锁被释放。<strong> 自旋锁适用于锁的持有时间很短的情况</strong>，因为长时间占用 CPU 会影响系统性能。</p>
</li>
<li><p>屏障（barrier）：屏障是一种 <strong> 用于多线程协同的同步机制 </strong>，它允许多个线程在某个点上等待，直到所有线程都到达该点后再继续执行。屏障通常用于<strong> 一组线程 </strong> 需要在某个点进行 <strong> 同步操作 </strong> 的情况，例如多线程排序算法。</p>
</li>
</ol>
<blockquote>
<p>需要根据具体的应用场景选择合适的锁。</p>
</blockquote>
<h2 id="互斥锁"><a href="# 互斥锁" class="headerlink" title="互斥锁"></a>互斥锁 </h2><p> 互斥锁原理：互斥锁属于 sleep-waiting 类型的锁。例如，在一个双核的机器上有两个线程（线程 A 和线程 B），它们分别运行在 Core0 和 Core1 上。假设线程 A 想要通过 <code>pthread_mutex_lock</code> 操作去得到一个临界区的锁，而此时这个锁正被线程 B 所持有，那么线程 A 就会被阻塞，Core0 会在此时进行上下文切换（Context Switch）将线程 A<strong>置于等待队列中</strong>，此时 Core0 就可以运行其它的任务而不必进行忙等待。</p>
<p>互斥锁的实现：通常使用了操作系统提供的原子操作或者硬件提供的锁机制，保证锁的正确性和高效性。</p>
<p>互斥锁有两种类型：递归锁和非递归锁。递归锁允许同一线程在不释放锁的情况下多次获取锁，而非递归锁不允许这种情况发生。</p>
<p>互斥锁使用场景：因互斥锁会引起线程的切换，效率较低；使用互斥锁会引起线程阻塞等待，不会一直占用着 CPU。因此，当锁的内容较多、切换不频繁时，建议使用互斥锁。</p>
<p>互斥锁使用笔记：互斥锁的使用非常简单，主要包括以下几个步骤：</p>
<ul>
<li>定义互斥锁变量，一般使用 <code>pthread_mutex_t</code> 类型；</li>
<li>在需要保护的代码段前调用 <code>pthread_mutex_lock</code> 函数获取锁；</li>
<li>在代码段执行完毕后调用 <code>pthread_mutex_unlock</code> 函数释放锁；</li>
<li>释放锁之后其他线程就可以获取锁并访问共享资源。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化互斥锁</span></span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在需要保护的代码块前加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="comment">// 访问共享资源</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 访问完毕后解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在使用完互斥锁后销毁</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br></pre></td></tr></table></figure>

<h2 id="读写锁"><a href="# 读写锁" class="headerlink" title="读写锁"></a>读写锁 </h2><p> 读写锁的实现：通常使用了计数器和互斥锁等机制，通过控制读写访问的次数和顺序来保证数据的正确性和一致性。</p>
<p>读写锁使用笔记：读写锁的使用也非常简单，主要包括以下几个步骤：</p>
<ul>
<li>定义读写锁变量，一般使用 <code>pthread_rwlock_t</code> 类型；</li>
<li>在需要读取共享资源的代码段前调用 <code>pthread_rwlock_rdlock</code> 函数获取读锁；</li>
<li>在需要写入共享资源的代码段前调用 <code>pthread_rwlock_wrlock</code> 函数获取写锁；</li>
<li>在代码段执行完毕后调用 <code>pthread_rwlock_unlock</code> 函数释放锁；</li>
<li>释放锁之后其他线程就可以获取锁并访问共享资源。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock = PTHREAD_RWLOCK_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化读写锁</span></span><br><span class="line">pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在需要读取共享资源的代码块前加读锁</span></span><br><span class="line">pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line"><span class="comment">// 读取共享资源</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 读取完毕后释放读锁</span></span><br><span class="line">pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在需要写入共享资源的代码块前加写锁</span></span><br><span class="line">pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line"><span class="comment">// 写入共享资源</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 写入完毕后释放写锁</span></span><br><span class="line">pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在使用完读写锁后销毁</span></span><br><span class="line">pthread_rwlock_destroy(&amp;rwlock);</span><br></pre></td></tr></table></figure>

<h2 id="自旋锁"><a href="# 自旋锁" class="headerlink" title="自旋锁"></a>自旋锁 </h2><p> 自旋锁原理：自旋锁属于 busy-waiting 类型的锁。例如，在一个双核的机器上有两个线程（线程 A 和线程 B），它们分别运行在 Core0 和 Core1 上。如果线程 A 是使用 <code>pthread_spin_lock</code> 操作去请求锁，那么线程 A 就会一直在 Core0 上进行忙等待并 <strong> 不停的进行 </strong> 锁请求，直到得到这个锁为止。自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就 <strong> 一直循环 </strong> 在那里看是否该自旋锁的保持者已经释放了锁。</p>
<p>自旋锁使用场景：</p>
<ul>
<li><p>自旋锁的作用是为了解决某项资源的 <strong> 互斥使用</strong>。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁。因此，如果锁的内容较少、阻塞的时间较短，使用自旋锁比较好。</p>
</li>
<li><p>自旋锁在未获得锁的情况下，一直运行（自旋），占用着 CPU，如果不能在很短的时间内获得锁，这无疑会使 CPU 效率降低。因此，要慎重使用自旋锁，<strong>自旋锁只有在内核可抢占式或 SMP 的情况下才真正需要</strong>。在单 CPU 且不可抢占式的内核下，自旋锁的操作为空操作。自旋锁适用于锁使用者保持锁时间比较短的情况下。</p>
</li>
</ul>
<p>自旋锁使用笔记：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义自旋锁</span></span><br><span class="line"><span class="type">pthread_spinlock_t</span> spinlock = PTHREAD_PROCESS_PRIVATE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化自旋锁</span></span><br><span class="line">pthread_spin_init(&amp;spinlock, PTHREAD_PROCESS_PRIVATE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁，如果锁已被其他线程占用，则该函数会一直循环忙等待直到获取到锁</span></span><br><span class="line">pthread_spin_lock(&amp;spinlock);</span><br><span class="line"><span class="comment">// 访问共享资源</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 解锁，使其他线程可以获取锁并访问共享资源</span></span><br><span class="line">pthread_spin_unlock(&amp;spinlock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁自旋锁</span></span><br><span class="line">pthread_spin_destroy(&amp;lock);</span><br></pre></td></tr></table></figure>

<h2 id="条件变量"><a href="# 条件变量" class="headerlink" title="条件变量"></a>条件变量 </h2><p> 条件变量（condition variable）：条件变量是一种 <strong> 用于线程之间通信的同步机制</strong>，它允许线程在某个条件成立时才能继续执行。通常与互斥锁一起使用，当条件变量不满足时，线程释放互斥锁并等待条件变量被激活（通过另一个线程来激活条件变量）；当条件变量满足时，通知线程重新获取互斥锁并继续执行。</p>
<p>条件变量使用笔记：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义互斥锁和定义条件变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化条件变量和自旋锁</span></span><br><span class="line">pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (条件不满足预期条件) &#123;</span><br><span class="line">    <span class="comment">// 等待条件变量通知</span></span><br><span class="line">    pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件满足，访问共享资源</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在使用完条件变量后销毁</span></span><br><span class="line">pthread_cond_destroy(&amp;cond);</span><br><span class="line"><span class="comment">// 在使用完互斥锁后销毁</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在其他线程中通知条件变量</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="comment">// 访问共享资源</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 解锁后再发送通知</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件满足，发送条件变量通知</span></span><br><span class="line">pthread_cond_signal(&amp;cond);</span><br></pre></td></tr></table></figure>

<h3 id="生产消费者同步示例代码"><a href="# 生产消费者同步示例代码" class="headerlink" title="生产消费者同步示例代码"></a>生产消费者同步示例代码 </h3><p> 一个生产者、消费者同步的多线程示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE (4)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> buffer[BUFFER_SIZE];</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 预期条件是 buffer 不能满（当 buffer 满时为条件不满足预期）</span></span><br><span class="line">        <span class="keyword">while</span> (count == BUFFER_SIZE) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        buffer[count++] = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Producer produced: %d\n&quot;</span>, i);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        pthread_cond_signal(&amp;cond);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 预期条件是 buffer 不能空（当 buffer 空时为条件不满足预期）</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> value = buffer[--count];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Consumer consumed: %d\n&quot;</span>, value);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        pthread_cond_signal(&amp;cond);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> producer_thread, consumer_thread;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;producer_thread, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;consumer_thread, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(producer_thread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(consumer_thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例代码中，有一个容量为 4 的缓冲区，生产者线程负责往缓冲区中添加数据，消费者线程负责从缓冲区中取出数据。使用互斥锁和条件变量来保证生产者和消费者的同步。</p>
<p>生产者线程通过加锁后检查缓冲区是否已满，如果已满则等待条件变量通知，否则将数据添加到缓冲区，并发送条件变量通知消费者线程。消费者线程通过加锁后检查缓冲区是否为空，如果为空则等待条件变量通知，否则从缓冲区中取出数据，并发送条件变量通知生产者线程。</p>
<blockquote>
<p>注意，生产者和消费者线程之间的同步是通过互斥锁和条件变量来实现的。互斥锁用于保护共享资源，条件变量用于线程间的通信和同步。</p>
</blockquote>
<p>一种可能的运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Producer produced (from buffer index: 0): 0</span><br><span class="line">Producer produced (from buffer index: 1): 1</span><br><span class="line">Consumer consumed (from buffer index: 1): 1</span><br><span class="line">Consumer consumed (from buffer index: 0): 0</span><br><span class="line">Producer produced (from buffer index: 0): 2</span><br><span class="line">Producer produced (from buffer index: 1): 3</span><br><span class="line">Producer produced (from buffer index: 2): 4</span><br><span class="line">Consumer consumed (from buffer index: 2): 4</span><br><span class="line">Consumer consumed (from buffer index: 1): 3</span><br><span class="line">Consumer consumed (from buffer index: 0): 2</span><br><span class="line">[root@localhost del]#</span><br><span class="line">[root@localhost del]# ./a.out</span><br><span class="line">Producer produced (from buffer index: 0): 0</span><br><span class="line">Producer produced (from buffer index: 1): 1</span><br><span class="line">Producer produced (from buffer index: 2): 2</span><br><span class="line">Producer produced (from buffer index: 3): 3</span><br><span class="line">Consumer consumed (from buffer index: 3): 3</span><br><span class="line">Consumer consumed (from buffer index: 2): 2</span><br><span class="line">Consumer consumed (from buffer index: 1): 1</span><br><span class="line">Consumer consumed (from buffer index: 0): 0</span><br><span class="line">Producer produced (from buffer index: 0): 4</span><br><span class="line">Consumer consumed (from buffer index: 0): 4</span><br><span class="line">[root@localhost del]#</span><br></pre></td></tr></table></figure>

<h2 id="屏障"><a href="# 屏障" class="headerlink" title="屏障"></a>屏障 </h2><p> 屏障（barrier）：屏障是一种 <strong> 用于多线程协同的同步机制 </strong>，它允许多个线程在某个点上等待，直到所有线程都到达该点后再继续执行。屏障通常用于<strong> 一组线程 </strong> 需要在某个点进行 <strong> 同步操作 </strong> 的情况，例如多线程排序算法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义屏障</span></span><br><span class="line"><span class="type">pthread_barrier_t</span> barrier;</span><br><span class="line"><span class="type">int</span> thread_nums = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化屏障</span></span><br><span class="line">pthread_barrier_init(&amp;barrier, <span class="literal">NULL</span>, thread_nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在每个线程中执行以下代码</span></span><br><span class="line">pthread_barrier_wait(&amp;barrier); <span class="comment">// 等待屏障</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有线程都到达屏障后，继续执行以下代码</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在使用完屏障后销毁</span></span><br><span class="line">pthread_barrier_destroy(&amp;barrier);</span><br></pre></td></tr></table></figure>

<h3 id="屏蔽实现线程同步示例代码"><a href="# 屏蔽实现线程同步示例代码" class="headerlink" title="屏蔽实现线程同步示例代码"></a>屏蔽实现线程同步示例代码 </h3><p> 下面是一个完整的示例代码，演示了如何使用 <code>pthread</code> 库中的屏障实现线程同步：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义屏障</span></span><br><span class="line"><span class="type">pthread_barrier_t</span> barrier;</span><br><span class="line"><span class="type">int</span> thread_nums = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 线程执行的一些操作...</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld operation\n&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待屏障</span></span><br><span class="line">    pthread_barrier_wait(&amp;barrier);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有线程都到达屏障后，继续执行以下代码</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld continues after the barrier\n&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程执行的其他操作...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[thread_nums];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化屏障</span></span><br><span class="line">    pthread_barrier_init(&amp;barrier, <span class="literal">NULL</span>, thread_nums);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; thread_nums; i++) &#123;</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, thread_func, (<span class="type">void</span>*)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_nums; i++) &#123;</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁屏障</span></span><br><span class="line">    pthread_barrier_destroy(&amp;barrier);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例代码中，我们定义了一个屏障 <code>pthread_barrier_t</code> 和一个线程数 <code>thread_nums</code>。在主函数中，</p>
<ul>
<li>首先调用 <code>pthread_barrier_init</code> 函数初始化屏障。</li>
<li>然后，创建指定数量的线程，并通过 <code>pthread_create</code> 函数将线程函数 <code>thread_func</code> 分配给每个线程。</li>
<li>在线程函数中，线程首先执行一些操作，然后调用 <code>pthread_barrier_wait</code> 函数等待屏障。<strong>当所有线程都到达屏障后，屏障解除，所有线程继续执行后续的代码</strong>。</li>
<li>最后，我们使用 <code>pthread_join</code> 等待所有线程结束，并使用 <code>pthread_barrier_destroy</code> 销毁屏障。</li>
</ul>
<h2 id="原子操作"><a href="# 原子操作" class="headerlink" title="原子操作"></a>原子操作 </h2><p> 所谓原子操作，就是该操作绝不会在执行完毕前被任何其他任务或事件打断，也就说，它是 <strong> 最小的执行单位</strong>，不可能有比它更小的执行单位。因此这里的原子实际是使用了物理学里的物质微粒的概念。</p>
<p>原子操作需要硬件的支持，因此是架构相关的，其 API 和原子类型的定义都定义在内核源码树的 <code>include/asm/atomic.h</code> 文件中，它们 <strong> 都使用汇编语言实现，因为 C 语言并不能实现这样的操作</strong>。</p>
<p>原子操作主要用于实现资源计数，很多引用计数（Reference Count, refcnt）就是通过原子操作实现的。</p>
<h2 id="总结分析"><a href="# 总结分析" class="headerlink" title="总结分析"></a>总结分析 </h2><p> 互斥锁（Mutex lock），sleep-waiting 类型的锁：与自旋锁相比它需要消耗大量的系统资源来建立锁；随后当线程被阻塞等待时，线程的调度状态被修改，并且线程被加入等待线程队列；最后当锁可用时，在获取锁之前，线程会被从等待队列取出并更改其调度状态；但是在线程被阻塞期间，它不消耗 CPU 资源。</p>
<p>互斥锁适用于那些可能会阻塞很长时间的场景：</p>
<ul>
<li>临界区有 IO 操作</li>
<li>临界区代码复杂或者循环量大</li>
<li>临界区竞争非常激烈</li>
<li>单核处理器</li>
</ul>
<p>自旋锁（Spin lock），busy-waiting 类型的锁：对于自旋锁来说，它只需要消耗很少的资源来建立锁；随后当线程被阻塞时，它就会一直重复检查看锁是否可用了，也就是说当自旋锁处于等待状态时它会一直消耗 CPU 时间。  </p>
<p>自旋锁适用于那些仅需要阻塞很短时间的场景。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>锁</tag>
        <tag>原子操作</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 笔记之函数 &amp; 包 &amp; 判断 &amp; 循环</title>
    <url>/posts/230909120145.html</url>
    <content><![CDATA[<h2 id="Go 语言学习笔记 -5：函数"><a href="#Go 语言学习笔记 -5：函数" class="headerlink" title="Go 语言学习笔记 -5：函数"></a>Go 语言学习笔记 -5：函数</h2><ol>
<li>函数声明语法：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functionname</span><span class="params">(parametername1 <span class="keyword">type</span>, parametername2 <span class="keyword">type</span>)</span></span> returntype &#123;  </span><br><span class="line">    <span class="comment">// 函数体（具体实现的功能）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>如果有连续若干个参数，它们的类型一致，那么我们无须一一罗列，只需在最后一个参数后添加该类型。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functionname</span><span class="params">(parametername1, parametername2 <span class="keyword">type</span>)</span></span> returntype &#123;  </span><br><span class="line">    <span class="comment">// 函数体（具体实现的功能）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Go 语言支持一个函数可以有 <strong> 多个返回值</strong>。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functionname</span><span class="params">(para1 type1, para2 type2)</span></span> (returntype1, returntype2, ...) &#123;</span><br><span class="line">    <span class="comment">// 函数体（具体实现的功能）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<ol start="4">
<li><strong>命名返回值 </strong>：从函数中可以返回一个命名值。一旦命名了返回值，可以认为<strong> 这些值在函数第一行就被声明为变量了</strong>，在函数 return 时不必再跟随命名值。如<code>area, perimeter</code>：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rectProps</span><span class="params">(length, width <span class="type">float64</span>)</span></span> (area, perimeter <span class="type">float64</span>) &#123;  </span><br><span class="line">    area = length * width</span><br><span class="line">    perimeter = (length + width) * <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// 不需要明确指定返回值，默认返回 area, perimeter 的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>空白符</strong>：<code>_</code> 在 Go 中被用作空白符，可以用作表示任何类型的任何值。</li>
</ol>
<p><code>area, _ := rectProps(10.8, 5.6) // 返回值周长被丢弃</code>。</p>
<hr>
<h2 id="Go 语言学习笔记 -6：包"><a href="#Go 语言学习笔记 -6：包" class="headerlink" title="Go 语言学习笔记 -6：包"></a>Go 语言学习笔记 -6：包</h2><ol>
<li><p><code>package packagename</code> 指定了某一源文件属于一个包，它应该放在每一个源文件的第一行。</p>
</li>
<li><p><code>main</code> 包和自定义包目录结构（属于某一个包的源文件都应该放置于一个单独命名的文件夹里，且应该用包名命名文件夹名）：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">    geometry  <span class="comment">// 自定义 main 包</span></span><br><span class="line">        geometry.<span class="keyword">go</span> <span class="comment">// main 函数</span></span><br><span class="line">        rectangle <span class="comment">// 自定义包，文件名为包名</span></span><br><span class="line">            rectprops.<span class="keyword">go</span> <span class="comment">// 属于 rectangle 包的源文件</span></span><br><span class="line">bin</span><br><span class="line">    <span class="comment">// 通过执行 go build geometry/geometry.go 编译得到 </span></span><br><span class="line">    geometry (Linux)</span><br><span class="line">    geometry.exe (Windows)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>导入自定义包：<code>import packagepath</code>，必须指定自定义包 <code>packagename</code> 相对于工作区 <code>src</code> 文件夹的相对路径，如：<code>import &quot;geometry/rectangle&quot;</code>。</p>
</li>
<li><p>导出名字：在 Go 中，任何 <strong> 以大写字母开头的变量或者函数都是被导出的名字，其它包只能访问被导出的函数和变量</strong>（即，如果想在包外访问一个函数，它应该首首字母大写）。</p>
</li>
<li><p><code>init</code> 函数：所有包都可以包含一个 <code>init</code> 函数，<code>init</code> 函数不应该有任何返回值类型和参数。</p>
</li>
</ol>
<ul>
<li><p>包的初始化顺序：1）首先初始化 <strong> 被导入的 </strong> 包；2）然后初始化 <strong> 包级别（package level）的变量 </strong>；3）紧接着<strong> 调用 <code>init</code> 函数</strong>，按照编译器解析它们的顺序进行调用。</p>
</li>
<li><p>如果一个包导入了另一个包，会先初始化 <strong> 被导入的 </strong> 包。</p>
</li>
<li><p>尽管一个包可能会被导入多次，但是它们只会被初始化一次。</p>
</li>
</ul>
<ol start="6">
<li>空白标识符导入包中的使用：导入了包，却不在代码中使用它，这在 Go 中是非法的，会抛出 <code>xxx.go:6: imported and not used: packagename_yyy</code>。</li>
</ol>
<ul>
<li><p>为了避免这种程序错误，通常会在函数外调用其中的一个函数，并将返回值赋给 <code>_</code> 变量，把这一操作称为 <code> 错误屏蔽器</code>。</p>
</li>
<li><p>同时，有时我们并不想使用导入的包中的任一函数或变量，只是为了 <strong> 确保它进行初始化</strong>，这种情况可以使用空白标识符 <code>_</code>，如 <code>import _ &quot;geometry/rectangle&quot;</code>。这样在不调用包中的函数或变量时，也不会报错。</p>
</li>
</ul>
<hr>
<h2 id="Go 语言学习笔记 -7：if-else"><a href="#Go 语言学习笔记 -7：if-else" class="headerlink" title="Go 语言学习笔记 -7：if-else"></a>Go 语言学习笔记 -7：if-else</h2><ol>
<li>即使 <code>if</code> 状态下仅有一条语句，也必须加 <code>&#123; &#125;</code></li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> condition &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>if</code> 还有另外一种形式，它包含一个 <code>statement</code> 可选语句部分，该组件在条件判断之前运行，语法为：<code>if statement; condition &#123;  &#125;</code>，其中 <code>statement</code> 的作用域仅在 <code>if-else</code> 范围内。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; <span class="comment">// num 的范围仅限于 if else 代码块</span></span><br><span class="line">  <span class="keyword">if</span> num:= <span class="number">10</span>; num % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">    fmt.Println(num, <span class="string">&quot;is even.&quot;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(num, <span class="string">&quot;is odd.&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>一个注意点</strong>：<code>else</code> 必须键入在 <code>&#125;</code> 后面，不能另取一行键入，因为 Go 语言默认在每条语句结束时插入一个分号，但 <code>if else</code> 是一个整体。</li>
</ol>
<h2 id="Go 语言学习笔记 -8：循环"><a href="#Go 语言学习笔记 -8：循环" class="headerlink" title="Go 语言学习笔记 -8：循环"></a>Go 语言学习笔记 -8：循环</h2><ol>
<li>Go 语言中唯一的循环语句是 <code>for</code>，没有 <code>while</code> 和 <code>do while</code> 循环。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> initialisation; condition; post &#123;  </span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>for</code> 循环的三个组成部分，即初始化，条件和 post 都是可选的（可有可无），如：<code>for ;i &lt;= 10; &#123;...&#125;</code>、<code>for &#123;...&#125;</code> 或 <code>for i &lt;= 10 &#123;... i += 2&#125;</code>，即 <code>;</code> 也是可以省略的。</li>
</ul>
<ol start="2">
<li><code>break</code> 为跳出循环，<code>continue</code> 为不执行后续语句，进入下一次循环。</li>
</ol>
<hr>
<h2 id="Go 语言学习笔记 -9：switch 语句"><a href="#Go 语言学习笔记 -9：switch 语句" class="headerlink" title="Go 语言学习笔记 -9：switch 语句"></a>Go 语言学习笔记 -9：switch 语句</h2><ol>
<li><code>switch</code>是一个条件语句，它可以被认为是替代多个 <code>if else</code> 子句的常用方式，<code>case</code> 不允许出现重复项。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    finger := <span class="number">4</span></span><br><span class="line">    <span class="keyword">switch</span> finger &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;Thumb&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;Index&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;Middle&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>, <span class="number">5</span>: <span class="comment">// 一个选项多个表达式</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;Ring or Pinky&quot;</span>)</span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">// 默认情况</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;incorrect finger number&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>先声明变量再使用</strong>：<code>switch varname := xxx; varname &#123;...&#125;</code>，此时的 <code>varname</code> 变量的作用域仅限于当前 <code>switch</code> 内。</p>
</li>
<li><p><strong>无表达式的 <code>switch</code><strong>：在 switch 语句中，表达式是可选的，可以被省略。如果省略表达式，则表示这个 switch 语句 </strong> 等同于 switch true</strong>，并且 <strong> 每个 case 表达式都被认定为有效，相应的代码块也会被执行</strong>。</p>
</li>
<li><p><strong>fallthrough</strong>：fallthrough 语句可以在已经执行完成的 case 之后，把控制权转移到下一个 case 的执行代码中，而不会跳出 switch。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> num := <span class="number">3</span>; &#123;</span><br><span class="line">        <span class="keyword">case</span> num == <span class="number">3</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;==&quot;</span>)</span><br><span class="line">            <span class="keyword">fallthrough</span></span><br><span class="line">        <span class="keyword">case</span> num &lt; <span class="number">10</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;yes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>switch 和 case 的表达式不一定是常量。</li>
</ol>
<blockquote>
<p>学习链接：<a href="https://studygolang.com/subject/2">https://studygolang.com/subject/2</a>，感谢如此优秀的教程！</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go函数</tag>
        <tag>Go判断</tag>
        <tag>Go循环</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 笔记之变量与常量</title>
    <url>/posts/230907162612.html</url>
    <content><![CDATA[<h2 id="Go 语言学习笔记 -1：HelloWorld"><a href="#Go 语言学习笔记 -1：HelloWorld" class="headerlink" title="Go 语言学习笔记 -1：HelloWorld"></a>Go 语言学习笔记 -1：HelloWorld</h2><p>Go 语言是一种编译型语言，源代码都会编译成二进制机器码。</p>
<p>所有 Go 源文件都应该放置在工作区里的 src 目录下。Linux 的工作区（Workspace）应该设置在 $HOME&#x2F;go，也可以通过设置 GOPATH 环境变量，用其他目录来作为工作区。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span></span><br><span class="line">  bin <span class="comment">// 编译生成的二进制文件存储位置</span></span><br><span class="line">    hello</span><br><span class="line">  src <span class="comment">// 所有 Go 源文件都应该放置在工作区里的 src 目录下</span></span><br><span class="line">    hello <span class="comment">// 为每个 project 新建一个文件夹</span></span><br><span class="line">      helloworld.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>

<p>第一个 Go 程序</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>解析：</p>
<ul>
<li><p><code>package main</code> - 每一个 Go 文件都应该在开头进行 package name 的声明（译注：只有可执行程序的包名应当为 main）。包（Packages）用于代码的封装与重用，这里的包名称是 main。</p>
</li>
<li><p><code>import &quot;fmt&quot;</code> - 我们引入了 fmt 包，用于在 main 函数里面打印文本到标准输出。</p>
</li>
<li><p><code>func main()</code> - main 是一个特殊的函数。整个程序就是从 main 函数开始运行的。main 函数必须放置在 main 包中。{和} 分别表示 main 函数的开始和结束部分。</p>
</li>
<li><p><code>fmt.Println(&quot;Hello World&quot;)</code> - fmt 包中的 Println 函数用于把文本写入标准输出。</p>
</li>
</ul>
<hr>
<h2 id="Go 语言学习笔记 -2：变量"><a href="#Go 语言学习笔记 -2：变量" class="headerlink" title="Go 语言学习笔记 -2：变量"></a>Go 语言学习笔记 -2：变量 </h2><p><strong> 变量 </strong> 指定了某存储单元（Memory Location）的名称，该存储单元会存储特定类型的值。</p>
<ol>
<li><p>声明单个变量：var name type，例如：var age int</p>
</li>
<li><p>声明变量并初始化：var name type &#x3D; initialValue</p>
</li>
<li><p>类型推断：如果变量有初始值，那么 Go 能够自动推断具有初始值的变量的类型。因此，如果变量有初始值，就可以在变量声明中省略 type， 如 var age &#x3D; 16 指 age 类型为 int 型。</p>
</li>
<li><p>声明多个变量：var name1, name2 type &#x3D; initialValue1, initialValue2</p>
</li>
<li><p>在一个语句中声明不同类型的变量，如：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    age = <span class="number">19</span></span><br><span class="line">    name = “laowang”</span><br><span class="line">    adult = <span class="literal">true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>变量的简短声明语法：<code>:=</code> 操作符，例如：<code>age, name := 20, &quot;zhangsan&quot;</code>。简短声明要求 <code>:=</code> 操作符左边的 <strong> 所有变量都有初始值</strong>。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a, b := <span class="number">20</span>, <span class="number">30</span> <span class="comment">// 声明 a 和 b</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;a is&quot;</span>, a, <span class="string">&quot;b is&quot;</span>, b)</span><br><span class="line">    a, b := <span class="number">40</span>, <span class="number">50</span> <span class="comment">// 错误，没有尚未声明的变量</span></span><br><span class="line">    a, c := <span class="number">40</span>, <span class="number">60</span> <span class="comment">// 正确，有新的尚未声明的变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><p>变量也可以在运行时进行赋值，如 <code>a := math.Min(15, 20)</code></p>
</li>
<li><p>由于 Go 是强类型（Strongly Typed）语言，因此不允许某一类型的变量赋值为其他类型的值。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    age := <span class="number">29</span>      <span class="comment">// age 是 int 类型</span></span><br><span class="line">    age = <span class="string">&quot;naveen&quot;</span> <span class="comment">// 错误，尝试赋值一个字符串给 int 类型变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Go 语言学习笔记 -3：变量类型"><a href="#Go 语言学习笔记 -3：变量类型" class="headerlink" title="Go 语言学习笔记 -3：变量类型"></a>Go 语言学习笔记 -3：变量类型</h2><ol>
<li>Go 语言支持的变量类型：</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">bool</span><br><span class="line">数字类型</span><br><span class="line">    int8, int16, int32, int64, int</span><br><span class="line">    uint8, uint16, uint32, uint64, uint</span><br><span class="line">    float32, float64</span><br><span class="line">    complex64, complex128 // 复数型</span><br><span class="line">    byte</span><br><span class="line">    rune</span><br><span class="line">string</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 Printf 方法中，使用 <code>%T</code> 格式说明符（Format Specifier），可以打印出变量的类型。Go 的 <code>unsafe</code> 包提供了一个 <code>Sizeof</code> 函数，该函数接收变量并返回它的字节大小。如：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;type of age is %T, size of age is %d&quot;</span>, age, unsafe.Sizeof(age))</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>复数类型：<code>complex64</code> 表示实部和虚部都是 <code>float32</code> 类型，<code>complex128</code> 表示实部和虚部都是 <code>float64</code> 类型。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c1 := <span class="built_in">complex</span>(<span class="number">5</span>, <span class="number">7</span>) <span class="comment">// 通过内置函数声明复数变量 c1</span></span><br><span class="line">c2 := <span class="number">8</span> + <span class="number">27i</span> <span class="comment">// 通过简短声明声明复数变量 c2</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>其它变量类型：<code>byte</code> 是 <code>uint8</code> 的别名， <code>rune</code> 是 <code>int32</code> 的别名。</p>
</li>
<li><p>Go 是强类型（Strongly Typed）语言， Go 没有自动类型提升或类型转换：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i, j <span class="type">int</span>, float = <span class="number">5</span>, <span class="number">10.2</span></span><br><span class="line">diff := i - j <span class="comment">// 错误， int - float 不被允许</span></span><br><span class="line">diff := i - <span class="type">int</span>(j) <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Go 语言学习笔记 -4：常量"><a href="#Go 语言学习笔记 -4：常量" class="headerlink" title="Go 语言学习笔记 -4：常量"></a>Go 语言学习笔记 -4：常量</h2><ol>
<li><p>关键字：<code>const</code>，常量不能再重新赋值为其他的值。</p>
</li>
<li><p>常量的值会在 <strong> 编译的时候 </strong> 确定。因为函数调用发生在 <strong> 运行时</strong>，所以不能将函数的返回值赋值给常量。如：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a := math.Sqrt(<span class="number">4</span>) <span class="comment">// 允许</span></span><br><span class="line"><span class="keyword">const</span> b := math.Sqrt(<span class="number">9</span>) <span class="comment">// 不允许，编译先于运行</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>常量是可以没有类型的，如：<code>const name = &quot;zhangsan&quot;</code>；常量也可以是有类型的，如：<code>const name string = &quot;lisi&quot;</code>，即 name 是一个 string 类型的 <strong> 常量</strong>。</p>
</li>
<li><p>Go 的类型策略不允许将一种类型的变量赋值给另一种类型的变量。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> defaultName = <span class="string">&quot;Sam&quot;</span> <span class="comment">// 允许</span></span><br><span class="line">    <span class="keyword">type</span> myString <span class="type">string</span></span><br><span class="line">    <span class="keyword">var</span> customName myString = <span class="string">&quot;Sam&quot;</span> <span class="comment">// 允许</span></span><br><span class="line">    customName = defaultName <span class="comment">// 不允许，即使 myString 是 string 类型的别名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>布尔常量</strong>：字符串常量的规则适用于布尔常量。</li>
</ol>
<p><code>var name = &quot;Sam&quot;</code> 无类型的 <strong> 常量 </strong> Sam 是如何赋值给<strong> 变量</strong> name 的？</p>
<blockquote>
<p>答案是 <strong> 无类型的常量有一个与它们相关联的默认类型，并且当且仅当一行代码需要时才提供它</strong>（常量可以赋值给 “合适的” 类型，而不需要类型转换）。在声明变量时，如果使用常量来赋值，变量会从常量的默认类型中获取类型。在这种情况下，常量 “Sam” 的默认类型是字符串，所以变量 name 的类型也是字符串。</p>
</blockquote>
<blockquote>
<p>学习链接：<a href="https://studygolang.com/subject/2">https://studygolang.com/subject/2</a>，感谢如此优秀的教程！</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go变量与常量</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 笔记之可变参数函数与 Map 集合</title>
    <url>/posts/230913161326.html</url>
    <content><![CDATA[<h2 id="Go 语言学习笔记 -12：可变参数函数"><a href="#Go 语言学习笔记 -12：可变参数函数" class="headerlink" title="Go 语言学习笔记 -12：可变参数函数"></a>Go 语言学习笔记 -12：可变参数函数</h2><ol>
<li><p>可变参数函数是一种 <strong> 参数个数可变 </strong> 的函数。如果函数最后一个参数的类型被记作 <code>...T</code> ，这时函数可以接受任意个 <code>T</code> 类型的参数作为最后一个参数。<strong>只有 </strong> 函数的最后一个参数才允许是可变的。</p>
</li>
<li><p>可变参数函数的 <strong> 工作原理 </strong> 是把可变参数转换为一个新的 <strong> 切片</strong>。</p>
</li>
<li><p>有一个可以直接将切片传入可变参数函数的语法糖，你可以在切片后加上 <code>...</code> 后缀。这样切片将直接传入函数，不再创建新的切片。</p>
</li>
</ol>
<span id="more"></span>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">find</span><span class="params">(num <span class="type">int</span>, nums ...<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    find(<span class="number">89</span>, <span class="number">88</span>, <span class="number">89</span>, <span class="number">90</span>) <span class="comment">// 语法正确，[88, 89, 90] 将被转换为一个新的切片传入 find 函数</span></span><br><span class="line">    find(<span class="number">89</span>) <span class="comment">// 语法正确, 一个长度和容量为 0 的 nil 切片将被传入 find 函数</span></span><br><span class="line">    nums := []<span class="type">int</span>&#123;<span class="number">87</span>, <span class="number">88</span>, <span class="number">89</span>&#125;</span><br><span class="line">    find(<span class="number">89</span>, nums) <span class="comment">// 语法错误，find 的可变参数要求为 int 型，不能传入 []int 切片</span></span><br><span class="line">    find(<span class="number">89</span>, nums...) <span class="comment">// 语法正确，切片直接传入函数，不再创建新的切片</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Go 语言学习笔记 -13：Maps"><a href="#Go 语言学习笔记 -13：Maps" class="headerlink" title="Go 语言学习笔记 -13：Maps"></a>Go 语言学习笔记 -13：Maps</h2><ol>
<li><p>map 是在 Go 中将值（value）与键（key）关联的 <strong> 内置类型</strong>。通过相应的键可以获取到值。</p>
</li>
<li><p>通过向 <code>make</code> 函数传入键和值的类型，可以创建 map。<code>make(map[type of key]type of value)</code> 是创建 map 的语法。如：<code>personSalary := make(map[string]int)</code>。</p>
</li>
<li><p>map 的零值是 <code>nil</code>。如果你想添加元素到 nil map 中，会触发运行时 <code>panic</code>。因此 <strong>map 必须使用 <code>make</code> 函数初始化</strong>。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> personSalary <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> personSalary == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;map is nil. Going to make one.&quot;</span>)</span><br><span class="line">        personSalary = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>) <span class="comment">// 使用 make 方法初始化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    personSalary[<span class="string">&quot;steve&quot;</span>] = <span class="number">12000</span> <span class="comment">// 给 map 添加新元素</span></span><br><span class="line">    personSalary[<span class="string">&quot;jamie&quot;</span>] = <span class="number">15000</span></span><br><span class="line">    personSalary[<span class="string">&quot;mike&quot;</span>] = <span class="number">9000</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;personSalary map contents:&quot;</span>, personSalary) <span class="comment">// map[steve:12000 jamie:15000 mike:9000]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在声明时初始化 map：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">personSalary := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> &#123;</span><br><span class="line">        <span class="string">&quot;steve&quot;</span>: <span class="number">12000</span>,</span><br><span class="line">        <span class="string">&quot;jamie&quot;</span>: <span class="number">15000</span>, <span class="comment">// 逗号不可缺</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>获取 map 中的元素：<code>map[key]</code>。如果获取一个不存在的元素，map 会返回 <strong> 该元素类型的零值</strong>（如：<code>[]T</code> 返回 <code>nil</code>，整形返回 <code>0</code>）。</p>
</li>
<li><p>如何判断某个 key 是否存在于 map 中：<code>value, ok := map[key]</code>，如果 ok 是 true，表示 key 存在，key 对应的值就是 value ，反之表示 key 不存在。</p>
</li>
<li><p>遍历 map 中所有的元素需要用 for range 循环：<code>for key, value := range personSalary &#123;//... &#125;</code>。当使用 for range 遍历 map 时，不保证每次执行程序获取的元素顺序相同。</p>
</li>
<li><p>删除 map 中的元素：<code>delete(map, key)</code>，无返回值。</p>
</li>
<li><p>获取 map 的长度：<code>len(map)</code>。</p>
</li>
<li><p>和 slices 类似，map 也是 <strong> 引用类型 </strong>：当 map 被赋值为一个新变量的时候，它们指向同一个内部数据结构。因此，<strong> 改变其中一个变量，就会影响到另一变量。当 map 作为函数参数传递时也会发生同样的情况，函数中对 map 的任何修改，对于外部的调用都是可见的</strong>。</p>
</li>
<li><p>map 之间不能使用 <code>==</code> 操作符判断，<code>==</code> 只能用来检查 map 是否为 nil。</p>
</li>
</ol>
<blockquote>
<p>学习链接：<a href="https://studygolang.com/subject/2">https://studygolang.com/subject/2</a>，感谢如此优秀的教程！</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go可变参数函数</tag>
        <tag>Go集合Map</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 笔记之字符串和指针</title>
    <url>/posts/230915155105.html</url>
    <content><![CDATA[<h2 id="Go 语言学习笔记 -14：字符串"><a href="#Go 语言学习笔记 -14：字符串" class="headerlink" title="Go 语言学习笔记 -14：字符串"></a>Go 语言学习笔记 -14：字符串</h2><ol>
<li><p>Go 语言中的字符串是一个 <strong> 字节切片</strong>。</p>
</li>
<li><p><code>%x</code> 格式限定符用于指定 16 进制编码，<code>%c</code> 格式限定符用于打印字符串的字符。</p>
</li>
<li><p>在 UTF-8 编码中，一个代码点（字符的编码）可能会占用超过一个字节的空间，所以使用 <code>%c</code> 格式打印时可能会出错，可以用 <code>rune</code> 解决。</p>
</li>
<li><p><code>rune</code> 是 Go 语言的内建类型，它也是 <code>int32</code> 的别称。在 Go 语言中，<code>rune</code> 表示一个代码点。代码点无论占用多少个字节，都可以用一个 <code>rune</code> 来表示。</p>
</li>
</ol>
<span id="more"></span>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">&quot;Señor&quot;</span></span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%c &quot;</span>,s[i]) <span class="comment">// 打印出错，S e Ã ± o r</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">runes := []<span class="type">rune</span>(s)</span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; <span class="built_in">len</span>(runes); i++ &#123; <span class="comment">// 字符串被转化为一个 rune 切片</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%c &quot;</span>,runes[i]) <span class="comment">// 打印正确，S e ñ o r</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>字符串的 for range 循环更简单。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printCharsAndBytes</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> index, <span class="type">rune</span> := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%c starts at byte %d\n&quot;</span>, <span class="type">rune</span>, index)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name := <span class="string">&quot;Señor&quot;</span></span><br><span class="line">    printCharsAndBytes(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">S starts at byte 0  </span></span><br><span class="line"><span class="comment">e starts at byte 1  </span></span><br><span class="line"><span class="comment">ñ starts at byte 2  // ñ 占了两个字节</span></span><br><span class="line"><span class="comment">o starts at byte 4  </span></span><br><span class="line"><span class="comment">r starts at byte 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>用字节切片构造字符串：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包含字符串 Café 用 UTF-8 编码后的 16 进制字节</span></span><br><span class="line">byteSlice := []<span class="type">byte</span>&#123;<span class="number">0x43</span>, <span class="number">0x61</span>, <span class="number">0x66</span>, <span class="number">0xC3</span>, <span class="number">0xA9</span>&#125;</span><br><span class="line">str := <span class="type">string</span>(byteSlice)</span><br><span class="line">fmt.Println(str) <span class="comment">// Café</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>用 <code>rune</code> 切片构造字符串：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包含字符串 Señor 的 16 进制的 Unicode 代码点</span></span><br><span class="line">runeSlice := []<span class="type">rune</span>&#123;<span class="number">0x0053</span>, <span class="number">0x0065</span>, <span class="number">0x00f1</span>, <span class="number">0x006f</span>, <span class="number">0x0072</span>&#125;</span><br><span class="line">str := <span class="type">string</span>(runeSlice)</span><br><span class="line">fmt.Println(str) <span class="comment">// Señor</span></span><br></pre></td></tr></table></figure>

<ol start="8">
<li>字符串的长度：utf-8 package 包中的 <code>func RuneCountInString(s string) (n int)</code> 方法用来 <strong> 获取字符串的长度 </strong>。这个方法传入一个字符串参数然后<strong> 返回字符串中的 rune 的数量</strong>。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">word1 := <span class="string">&quot;Señor&quot;</span> </span><br><span class="line">fmt.Println(utf8.RuneCountInString(word1)) <span class="comment">// 5</span></span><br><span class="line">word2 := <span class="string">&quot;Pets&quot;</span></span><br><span class="line">fmt.Println(utf8.RuneCountInString(word2)) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<ol start="9">
<li>字符串是不可变的：一旦一个字符串被创建，它将不可被修改。为了修改字符串，可以把字符串转化为一个 rune 切片，这个切片可以进行任何想要的改变，最后再转化为一个字符串。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mutate</span><span class="params">(s []<span class="type">rune</span>)</span></span> <span class="type">string</span> &#123;  </span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span> <span class="comment">// 修改切片</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(s) <span class="comment">// 转换为一个字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    h := <span class="string">&quot;hello&quot;</span></span><br><span class="line">    fmt.Println(mutate([]<span class="type">rune</span>(h))) <span class="comment">// 用 rune 切片构造字符串，输出 aello</span></span><br><span class="line">    fmt.Println(h) <span class="comment">// 输出 hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Go 语言学习笔记 -15：指针"><a href="#Go 语言学习笔记 -15：指针" class="headerlink" title="Go 语言学习笔记 -15：指针"></a>Go 语言学习笔记 -15：指针</h2><ol>
<li><p>指针是一种存储变量内存地址（Memory Address）的变量。例如，变量 b 的值为 156，而 b 的内存地址为 0x1040a124，变量 a 存储了 b 的地址。我们就称 a 指向了 b。</p>
</li>
<li><p>指针的声明：指针变量的类型为 <code>*T</code>，该指针指向一个 <code>T</code> 类型的变量。</p>
</li>
</ol>
<ul>
<li>&amp; 操作符用于获取变量的地址。下面的程序把 b 的地址赋值给 <code>*int</code> 类型的 a。我们称 a 指向了 b。当我们打印 a 的值时，会打印出 b 的地址。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b := <span class="number">255</span></span><br><span class="line">    <span class="keyword">var</span> a *<span class="type">int</span> = &amp;b</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Type of a is %T\n&quot;</span>, a) <span class="comment">// *int</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;address of b is&quot;</span>, a)  <span class="comment">// 0x1040a124</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>指针的零值（Zero Value）是 <code>nil</code>。声明变量 <code>var b *int</code>，此时 <code>b == nil</code> 为 <code>true</code>。</p>
</li>
<li><p>指针的解引用：指针的解引用可以获取指针所指向的变量的值。将 <code>a</code> 解引用的语法是 <code>*a</code>。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    b := <span class="number">255</span></span><br><span class="line">    a := &amp;b</span><br><span class="line">    fmt.Println(<span class="string">&quot;address of b is&quot;</span>, a) <span class="comment">// 0x1040a124</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;value of b is&quot;</span>, *a)  <span class="comment">// 255</span></span><br><span class="line">    *a++  <span class="comment">// (*a)++</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;new value of b is&quot;</span>, b) <span class="comment">// 256</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>向函数传递指针参数：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(val *<span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    *val = <span class="number">55</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := <span class="number">58</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;value of a before function call is&quot;</span>, a) <span class="comment">// 58</span></span><br><span class="line">    b := &amp;a</span><br><span class="line">    change(b)</span><br><span class="line">    fmt.Println(<span class="string">&quot;value of a after function call is&quot;</span>, a) <span class="comment">// 55</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>假如我们想要在函数内修改一个数组，并希望调用函数的地方也能得到修改后的数组，一种解决方案是把一个指向数组的指针传递给这个函数（但 Go 语言习惯的方法是用切片处理，见序号 7）。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(arr *[3]<span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    (*arr)[<span class="number">0</span>] = <span class="number">90</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>&#125;</span><br><span class="line">    modify(&amp;a)</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>a[x]</code> 是 <code>(*a)[x]</code> 的简写形式，因此上面代码中的 <code>(*arr)[0]</code> 可以替换为 <code>arr[0]</code>。</li>
</ul>
<ol start="7">
<li><strong>不要向函数传递数组的指针，而应该使用数组切片</strong>：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(sls []<span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    sls[<span class="number">0</span>] = <span class="number">90</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>&#125;</span><br><span class="line">    modify(a[:]) <span class="comment">// 使用切片</span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>别再传递数组指针了，而是使用切片吧。上面的代码更加简洁，也更符合 Go 语言的习惯。</li>
</ul>
<blockquote>
<p>学习链接：<a href="https://studygolang.com/subject/2">https://studygolang.com/subject/2</a>，感谢如此优秀的教程！</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go字符串</tag>
        <tag>Go指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 笔记之数组与切片</title>
    <url>/posts/230912152800.html</url>
    <content><![CDATA[<h2 id="Go 语言学习笔记 -10：数组"><a href="#Go 语言学习笔记 -10：数组" class="headerlink" title="Go 语言学习笔记 -10：数组"></a>Go 语言学习笔记 -10：数组</h2><ol>
<li><p>数组是 <strong> 同一类型元素 </strong> 的集合，Go 语言中不允许混合不同类型的元素。</p>
</li>
<li><p>一个数组的表示形式为 <code>[n]T</code>。n 表示数组中元素的数量，T 代表每个元素的类型。如： <code>var arr [3]int</code>。</p>
</li>
<li><p>数组简略声明：<code>arr := [3]int&#123;12, 78, 50&#125;</code>，在简略声明中，可对部分元素赋值：<code>arr := [3]int&#123;12&#125;</code>，剩下的元素自动赋值为 0 。</p>
</li>
<li><p>可以忽略声明数组的长度，并用 <code>...</code> 代替，让编译器为你自动计算长度：<code>arr := [...]int&#123;12, 21&#125;</code>。</p>
</li>
<li><p><strong>数组是值类型，不是引用类型 </strong>：这意味着当数组赋值给一个新的变量时，该变量会得到一个原始数组的副本。<strong> 如果对新变量进行更改，则不会影响原始数组</strong>。注：对切片的修改会影响原始数组。</p>
</li>
</ol>
<span id="more"></span>

<ol start="6">
<li><strong>当数组作为参数传递给函数时，它们是按值传递，而原始数组保持不变（原始数组不会因为函数调用而改变）</strong>。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeLocal</span><span class="params">(num [5]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    num[<span class="number">0</span>] = <span class="number">55</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;inside function &quot;</span>, num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num := [...]<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;before passing to function &quot;</span>, num)</span><br><span class="line">    changeLocal(num) <span class="comment">// num is passed by value</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;after passing to function &quot;</span>, num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// before passing to function  [5 6 7 8 8]</span></span><br><span class="line"><span class="comment">// inside function  [55 6 7 8 8]</span></span><br><span class="line"><span class="comment">// after passing to function  [5 6 7 8 8]</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li><p>数组的长度：<code>len(arr)</code>。</p>
</li>
<li><p>数组的迭代 for 循环：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;%d-th element of arr is %.2f\n&quot;</span>, i, arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>数组的迭代：Go 提供了一种更好、更简洁的方法，通过 <strong> 使用 for 循环的 <code>range</code> 方法来遍历数组</strong>。<code>range</code> 返回索引和该索引处的值。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;%d-th element of arr is %.2f\n&quot;</span>, i, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>多维数组：1）简略声明；2）先声明二维数组变量，再根据索引来对数组添加值。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr := [<span class="number">3</span>][<span class="number">2</span>]<span class="type">string</span>&#123; <span class="comment">// 简略声明</span></span><br><span class="line">      &#123;<span class="string">&quot;lion&quot;</span>, <span class="string">&quot;tiger&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;pigeon&quot;</span>, <span class="string">&quot;peacock&quot;</span>&#125;, <span class="comment">// this comma is necessary. The compiler will complain if you omit this comma</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v1 := <span class="keyword">range</span> arr &#123; <span class="comment">// 打印二维数组</span></span><br><span class="line">    <span class="keyword">for</span> _, v2 := <span class="keyword">range</span> v1 &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s &quot;</span>, v2)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>数组的缺陷：长度固定，不可能增加数组的长度。</li>
</ol>
<hr>
<h2 id="Go 语言学习笔记 -11：切片"><a href="#Go 语言学习笔记 -11：切片" class="headerlink" title="Go 语言学习笔记 -11：切片"></a>Go 语言学习笔记 -11：切片</h2><ol>
<li><p>切片是 <strong> 由数组建立 </strong> 的一种方便、灵活且功能强大的包装（Wrapper）。<strong>切片本身不拥有任何数据 </strong>。它们只是对现有数组的<strong> 引用</strong>。</p>
</li>
<li><p>创建一个切片 A ：带有 <code>T</code> 类型元素的切片由 <code>[]T</code> 表示。语法：<code>a[start:end]</code> 创建一个从 a 数组索引 start 开始到 end - 1 结束的切片。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">76</span>, <span class="number">77</span>, <span class="number">78</span>, <span class="number">79</span>, <span class="number">80</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b []<span class="type">int</span> = a[<span class="number">1</span>:<span class="number">4</span>] <span class="comment">// 数组切片</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建一个切片 B ：创建一个数组，并返回一个存储在 c 中的 <strong> 切片引用</strong>。注意：<code>[]</code> 内无内容。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c := []<span class="type">int</span>&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125; <span class="comment">// creates and array and returns a slice reference</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p><strong>对切片的修改会影响原始数组</strong>。</p>
</li>
<li><p>当多个切片共用相同的底层数组时，每个切片所做的更改将反映在数组中。</p>
</li>
<li><p><strong>切片的长度和容量</strong>：切片的长度是切片中的元素数。切片的容量是从创建切片索引开始（到数组末尾）的底层数组中的元素数。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fruitarray := [...]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>&#125;</span><br><span class="line">    fruitslice := fruitarray[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">    fmt.Println(<span class="string">&quot;length of slice: %d, capacity: %d&quot;</span>, <span class="built_in">len</span>(fruitslice), <span class="built_in">cap</span>(fruitslice)) <span class="comment">// 2, 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>切片可以重置其容量：<code>slicename[:cap(slicename)]</code>。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fruitarray := [...]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>&#125;</span><br><span class="line">    fruitslice := fruitarray[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">    fmt.Println(<span class="string">&quot;length of slice: %d, capacity: %d&quot;</span>, <span class="built_in">len</span>(fruitslice), <span class="built_in">cap</span>(fruitslice)) <span class="comment">// 2, 3. print: [b, c]</span></span><br><span class="line">    fruitslice = fruitslice[:<span class="built_in">cap</span>(fruitslice)] <span class="comment">// re-slicing furitslice till its capacity. print: [b, c, d]</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;After re-slicing length is&quot;</span>, <span class="built_in">len</span>(fruitslice), <span class="string">&quot;and capacity is&quot;</span>, <span class="built_in">cap</span>(fruitslice)) <span class="comment">// 3, 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><p><strong>使用 <code>make</code> 创建一个切片</strong>：<code>func make ([]T, len, cap)</code> 通过传递类型、长度和容量来创建切片。其中，容量是可选参数，默认值为切片长度。**<code>make</code> 函数创建一个数组，并返回引用该数组的切片 **。如 <code>arrslice := make([]float64, 5, 5)</code>。</p>
</li>
<li><p>切片是动态的，可以使用 <code>append</code> 将新元素追加到切片上。<code>append</code> 函数定义为：<code>func append(slice []T, x ...T) []T</code>，其中 <code>x...T</code> 表示该函数接收 T 类型的参数 x 的个数是可变的，如：<code>arrslice = append(arrslice, 5.6, 7.3)</code>。</p>
</li>
</ol>
<blockquote>
<p><code>append</code> 函数会返回一个新的切片，其中包含了原始切片和追加的元素：</p>
<ol>
<li>如果原始切片的容量足够，<code>append</code> 函数会在原始切片的基础上进行追加；</li>
<li>如果原始切片的容量不够，<code>append</code> 函数会创建一个新的底层数组，并将原始切片中的元素和追加的元素复制到新的底层数组中。</li>
</ol>
<p>因此，append 函数返回的切片可能指向一个新的底层数组，而不是原始切片所指向的底层数组。</p>
</blockquote>
<ol start="10">
<li><p>数组是固定的，但 <strong> 切片具有动态长度 </strong>：切片是由一个指向数组的指针、长度和容量组成的数据结构。当我们向切片中追加元素时，如果切片的长度小于容量，新元素会直接添加到切片的末尾，切片的长度会增加。但是，如果追加元素后切片的长度超过了容量，Go 语言会创建一个新的更大的底层数组，将原来的元素复制到新的数组中，并将新元素添加到新数组的末尾。然后，切片会指向这个新数组（<strong> 相比于旧切片，引用类型的地址改变了</strong>），并且容量会成为原来的两倍（并不是每次执行 <code>append</code> 时容量都会变成旧切片的两倍，只有当长度超过容量时，才会扩充一倍容量）。这样，切片就具有了动态长度的特性。</p>
</li>
<li><p>切片类型的零值为 <code>nil</code>：一个 <code>nil</code> 切片的长度和容量为 0，可以使用 <code>append</code> 函数将值追加到 <code>nil</code> 切片。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names []<span class="type">string</span> <span class="comment">// zero value of a slice is nil</span></span><br><span class="line"><span class="keyword">if</span> names == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;slice is nil going to append&quot;</span>)</span><br><span class="line">    names = <span class="built_in">append</span>(names, <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Sebastian&quot;</span>, <span class="string">&quot;Vinay&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;names contents:&quot;</span>, names)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="12">
<li><p><code>...</code> 可将一个切片添加到另一个切片中：<code>append(slice1, slice2...)</code>。</p>
</li>
<li><p>切片的函数传递：切片在内部可由一个结构体类型表示，即：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    Length         <span class="type">int</span></span><br><span class="line">    Capacity       <span class="type">int</span></span><br><span class="line">    ZerothElement  *<span class="type">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>切片本身包含了长度、容量和指向底层数组首个元素的指针。当切片作为参数传递给函数时，虽然是通过值传递，但是切片内部的指针变量（这里的<code>byte</code>）仍然指向相同的底层数组。因此，当函数内部修改底层数组的值时，这些修改在函数外部是可见的。</p>
</li>
<li><p>然而，如果函数内部修改了切片的长度或容量，将会创建一个新的切片，而不会影响原始切片。这是因为切片的长度和容量是切片结构体的字段，而非底层数组的属性。因此，修改切片的长度或容量会创建一个新的切片结构体，其中的指针变量仍然指向原始的底层数组，但是新的切片具有不同的长度和容量。</p>
</li>
<li><p>因此，可以说当切片传递给函数时，函数内部对底层数组的修改，在函数外部是可见的，但是对切片的长度和容量的修改是不可见的。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifySlice</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">100</span> <span class="comment">// 修改底层数组的值</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">200</span>) <span class="comment">// 创建新的切片，不影响原始切片</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Inside modifySlice:&quot;</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    numbers := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Before modifySlice:&quot;</span>, numbers)</span><br><span class="line">    modifySlice(numbers)</span><br><span class="line">    fmt.Println(<span class="string">&quot;After modifySlice:&quot;</span>, numbers)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Before modifySlice: [1 2 3 4 5]</span></span><br><span class="line"><span class="comment">// Inside modifySlice: [100 2 3 4 5 200]</span></span><br><span class="line"><span class="comment">// After modifySlice: [100 2 3 4 5]  // 函数内部对底层数组的修改在函数外部是可见的</span></span><br></pre></td></tr></table></figure>

<ol start="14">
<li><strong>多维切片</strong>：类似于多维数组，但每行索引对应的元素数量可以不等于其它行。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pls := [][]<span class="type">string</span> &#123;</span><br><span class="line">      &#123;<span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;JavaScript&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;Go&quot;</span>, <span class="string">&quot;Rust&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="15">
<li>内存优化：切片持有对底层数组的引用，只要切片在内存中，数组就不能被垃圾回收。一种回收数组的方法时使用 <code>copy</code> 函数 <code>func copy(dst, src[]T) int</code> 来生成一个切片的副本，这样就可以使用新的切片，原始数组也可以被垃圾回收。注：返回的 int 类型的值为 dst 的长度。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countries</span><span class="params">()</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    countries := []<span class="type">string</span>&#123;<span class="string">&quot;USA&quot;</span>, <span class="string">&quot;Singapore&quot;</span>, <span class="string">&quot;Germany&quot;</span>, <span class="string">&quot;India&quot;</span>, <span class="string">&quot;Australia&quot;</span>&#125;</span><br><span class="line">    neededCountries := countries[:<span class="built_in">len</span>(countries)<span class="number">-2</span>]</span><br><span class="line">    countriesCpy := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(neededCountries))</span><br><span class="line">    <span class="built_in">copy</span>(countriesCpy, neededCountries) <span class="comment">//copies neededCountries to countriesCpy</span></span><br><span class="line">    <span class="keyword">return</span> countriesCpy</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    countriesNeeded := countries()</span><br><span class="line">    fmt.Println(countriesNeeded)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>学习链接：<a href="https://studygolang.com/subject/2">https://studygolang.com/subject/2</a>，感谢如此优秀的教程！</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go数组</tag>
        <tag>Go切片</tag>
      </tags>
  </entry>
  <entry>
    <title>博客文章分类汇总</title>
    <url>/posts/summary.html</url>
    <content><![CDATA[<center><b>这篇文章是个人博客中系列文章的分类汇总。</b></center>

<span id="more"></span>

<h1 id="C 语言系列"><a href="#C 语言系列" class="headerlink" title="C 语言系列"></a>C 语言系列</h1><p><a href="https://pursue26.github.io/posts/230916171929.html">C 语言之 main 函数参数</a><br><a href="https://pursue26.github.io/posts/230922143003.html">C 语言之多维数组</a><br><a href="https://pursue26.github.io/posts/230913200729.html">C 语言之 const 关键字</a><br><a href="https://pursue26.github.io/posts/230918174223.html">C 语言之 typedef 自定义类型基础</a><br><a href="https://pursue26.github.io/posts/230920172849.html">C 语言之 typedef 实践</a><br><a href="https://pursue26.github.io/posts/230922172626.html">C 语言之 uthash 哈希表基础</a><br><a href="https://pursue26.github.io/posts/230921094127.html">C 语言之锁与原子操作基础</a><br><a href="https://pursue26.github.io/posts/230911151334.html">C 语言之 pthread 多线程</a><br><a href="https://pursue26.github.io/posts/230918114841.html">C 语言之大小端知识</a></p>
<h1 id="Golang 语言系列"><a href="#Golang 语言系列" class="headerlink" title="Golang 语言系列"></a>Golang 语言系列</h1><p><a href="https://pursue26.github.io/posts/230907162612.html">Go 笔记之变量与常量</a><br><a href="https://pursue26.github.io/posts/230909120145.html">Go 笔记之函数 &amp; 包 &amp; 判断 &amp; 循环</a><br><a href="https://pursue26.github.io/posts/230912152800.html">Go 笔记之数组与切片</a><br><a href="https://pursue26.github.io/posts/230913161326.html">Go 笔记之可变参数函数与 Map 集合</a><br><a href="https://pursue26.github.io/posts/230915155105.html">Go 笔记之字符串和指针</a></p>
<h1 id="数据结构系列"><a href="# 数据结构系列" class="headerlink" title="数据结构系列"></a>数据结构系列 </h1><p><a href="https://pursue26.github.io/posts/230916094606.html"> 数据结构之二叉树的遍历 </a><br><a href="https://pursue26.github.io/posts/230905224335.html"> 数据结构之拓扑排序 </a><br><a href="https://pursue26.github.io/posts/230925185057.html"> 数据结构之 Trie 字典树</a></p>
<h1 id="Docker 系列"><a href="#Docker 系列" class="headerlink" title="Docker 系列"></a>Docker 系列</h1><p><a href="https://pursue26.github.io/posts/230909171809.html">Docker 学习笔记</a></p>
<h1 id="操作系统系列"><a href="# 操作系统系列" class="headerlink" title="操作系统系列"></a>操作系统系列 </h1><h2 id="操作系统课程学习（清华大学 - 陈渝老师）"><a href="# 操作系统课程学习（清华大学 - 陈渝老师）" class="headerlink" title="操作系统课程学习（清华大学 - 陈渝老师）"></a> 操作系统课程学习（清华大学 - 陈渝老师）</h2><p><a href="https://pursue26.github.io/posts/230921190726.html">操作系统之 chapter1 概述 </a><br><a href="https://pursue26.github.io/posts/230924172528.html"> 操作系统之 chapter2 启动 &amp; 中断 &amp; 异常 &amp; 系统调用</a></p>
]]></content>
  </entry>
  <entry>
    <title>操作系统之 chapter1 概述</title>
    <url>/posts/230921190726.html</url>
    <content><![CDATA[<p>这篇文章主要介绍操作系统的定义、架构层次、界面和内核、内部组成和特征等内容。</p>
<span id="more"></span>

<h1 id="概述"><a href="# 概述" class="headerlink" title="概述"></a>概述 </h1><h2 id="操作系统定义"><a href="# 操作系统定义" class="headerlink" title="操作系统定义"></a> 操作系统定义 </h2><p><strong> 用户角度</strong>：操作系统是一个控制软件。</p>
<ul>
<li>管理应用软件：可以限制不同的应用程序占用不同的资源</li>
<li>为应用程序提供服务：I&#x2F;O 服务，声卡、网卡的访问服务</li>
<li>杀死应用程序</li>
<li>资源管理：CPU、内存、外设资源</li>
<li>管理外设，分配资源</li>
</ul>
<p><strong>程序角度</strong>：操作系统是资源管理器。</p>
<ul>
<li>管理外设</li>
<li>抽象<ul>
<li>CPU 抽象成进程</li>
<li>磁盘抽象成文件</li>
<li>内存抽象成地址空间</li>
</ul>
</li>
</ul>
<h2 id="操作系统的架构层次"><a href="# 操作系统的架构层次" class="headerlink" title="操作系统的架构层次"></a>操作系统的架构层次 </h2><p> 硬件之上、应用软件之下（为应用软件提供服务支持）。</p>
<h2 id="操作系统的界面和内核"><a href="# 操作系统的界面和内核" class="headerlink" title="操作系统的界面和内核"></a>操作系统的界面和内核</h2><p>Linux、Windows、Android 的界面属于外壳（shell），而不是内核（kernel）。kernel 是操作系统的研究重点，在 shell 之下。</p>
<h2 id="操作系统内部组成"><a href="# 操作系统内部组成" class="headerlink" title="操作系统内部组成"></a>操作系统内部组成 </h2><p> 操作系统（kernel）内部组件包括：</p>
<ul>
<li>CPU 调度器</li>
<li>物理内存管理</li>
<li>虚拟内存管理</li>
<li>文件系统管理</li>
<li>中断处理与 I&#x2F;O 设备驱动</li>
</ul>
<h2 id="操作系统特征："><a href="# 操作系统特征：" class="headerlink" title="操作系统特征："></a>操作系统特征：</h2><ul>
<li>并发<ul>
<li>计算机系统中同时存在多个运行的程序，需要 OS 管理和调度。</li>
</ul>
</li>
<li>共享<ul>
<li>“同时”访问或互斥共享。</li>
</ul>
</li>
<li>虚拟<ul>
<li>利用多道程序设计技术，让每一个用户都觉得有一个计算机专门为他服务。</li>
</ul>
</li>
<li>异步<ul>
<li>每个程序的执行不是一贯到底，而是走走停停 &amp; 交替执行，向前推进速度不可预知；</li>
<li>只要运行环境相同，OS 保证程序运行结果相同。</li>
</ul>
</li>
</ul>
<blockquote>
<p>「并发」在一段时间内可以有多个程序运行，而「并行」是在一个时间点上可以有多个程序运行，并行需要多核 CPU 支持。</p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter2 启动 &amp; 中断 &amp; 异常 &amp; 系统调用</title>
    <url>/posts/230924172528.html</url>
    <content><![CDATA[<p>这篇文章主要介绍操作系统的启动、中断、异常、系统调用的特征 &amp; 差别，以及处理流程。</p>
<span id="more"></span>

<h2 id="操作系统启动"><a href="# 操作系统启动" class="headerlink" title="操作系统启动"></a>操作系统启动 </h2><h3 id="作用解析"><a href="# 作用解析" class="headerlink" title="作用解析"></a> 作用解析</h3><ul>
<li>硬盘（disk）：存放 OS 和 BootLoader</li>
<li>BIOS：基本 I&#x2F;O 处理系统</li>
<li>BootLoader：用于加载 OS，将 OS 从 disk 加载到内存中</li>
</ul>
<blockquote>
<p>BIOS 是一种固化在计算机主板上的软件程序，其中的一个主要作用就是：启动计算机 —— 当你启动计算机时，<strong>BIOS 是第一个被执行的程序</strong>。它负责进行硬件自检（POST，Power-On Self-Test）以及初始化计算机的硬件设备，包括处理器、内存、硬盘、显卡等。<strong>BIOS 还负责加载操作系统的引导程序（BootLoader）</strong>。</p>
</blockquote>
<h3 id="启动步骤"><a href="# 启动步骤" class="headerlink" title="启动步骤"></a>启动步骤</h3><p><img src="/images/os-kernel/chapter2/os-startup.png" alt="计算机启动流程"></p>
<p>操作系统启动过程可以概括为以下几个步骤：</p>
<ol>
<li>电源启动</li>
<li>BIOS 自检</li>
<li>加载引导程序（BootLoader）</li>
<li>引导程序的工作</li>
<li>内核初始化：操作系统内核接管控制权后，它会进行一系列的初始化工作，包括初始化进程管理、内存管理、文件系统等重要的系统组件</li>
<li>用户登录</li>
</ol>
<h3 id="BIOS 自检"><a href="#BIOS 自检" class="headerlink" title="BIOS 自检"></a>BIOS 自检</h3><p><img src="/images/os-kernel/chapter2/os-startup-layout.png" alt="计算机启动时内存和硬盘布局"></p>
<p>计算机启动时，BIOS 从一个特定地址（CS:IP &#x3D; 0xF000:FFF0）开始执行，这两个寄存器合在一起可以形成一个具体的物理内存地址。BIOS 就从这个内存地址开始执行 POST（加电自检）、寻找显卡和执行 BIOS。</p>
<blockquote>
<p>段寄存器（CS）和指令寄存器（IP）是计算机中的两种不同类型的寄存器：<br><strong>段寄存器 </strong> 是用于存储内存中的段地址的寄存器。在计算机中，内存被划分为多个段，每个段都有一个唯一的段地址。段寄存器存储着当前程序正在访问的段的地址。当程序需要访问内存中的数据时，它会使用段寄存器中的地址来确定要访问的段，并将其与偏移地址（存储在其他寄存器中）相加以获取最终的物理地址。<br><strong>指令寄存器（也称为程序计数器）</strong>是用于存储下一条要执行的指令的地址的寄存器。在计算机执行程序时，指令寄存器中保存着当前正在执行的指令的地址。当一条指令执行完毕后，指令寄存器会自动增加，以指向下一条将要执行的指令的地址。这样，计算机可以按顺序执行存储器中的指令序列。指令寄存器的值的改变决定了计算机下一步要执行的操作。</p>
</blockquote>
<h3 id="加载 BootLoader"><a href="# 加载 BootLoader" class="headerlink" title="加载 BootLoader"></a>加载 BootLoader</h3><p><img src="/images/os-kernel/chapter2/os-load-bootloader.png" alt="BIOS 加载引导程序"></p>
<p><strong>BIOS 负责加载 BootLoader</strong>：BIOS 会从预设的启动设备（如硬盘、光盘、USB 等）中加载引导程序（BootLoader）到内存中。引导程序通常位于硬盘的特定扇区或光盘的启动区。</p>
<p><strong>引导程序的工作</strong>：引导程序负责初始化硬件（如 CPU、内存等），加载操作系统内核，并将控制权交给内核。它还可以提供多个操作系统的选择菜单（如 GRUB），以供用户选择启动的操作系统。</p>
<p><img src="/images/os-kernel/chapter2/os-bootloader-address.png" alt="引导程序的内存地址空间"></p>
<p>BootLoader 放在硬盘的第一个主引导扇区（512 字节）。这样，BIOS 从硬盘的第一个扇区寻找，一下便能找到 BootLoader。</p>
<p><strong>BIOS 负责加载 BootLoader</strong>：将 BootLoader 从磁盘的引导扇区加载到 0x7C00 内存地址处。</p>
<p><strong>BootLoader 负责加载 OS</strong>：将操作系统的代码和数据从硬盘加载到内存中。之后，控制权交给到 OS（跳转到 OS 的起始地址）。</p>
<h2 id="中断、异常和系统调用"><a href="# 中断、异常和系统调用" class="headerlink" title="中断、异常和系统调用"></a>中断、异常和系统调用 </h2><p> 操作系统与设备和程序之间的交互可以通过中断、异常和系统调用来实现。</p>
<h3 id="定义"><a href="# 定义" class="headerlink" title="定义"></a>定义 </h3><p><strong> 中断（hardware interrupt）</strong>：是指外部事件（如硬件设备请求、定时器中断等）打断程序的正常执行，引发操作系统的处理程序来处理相应的事件。通过中断，设备可以向操作系统发出请求，操作系统可以响应并进行相应的处理。</p>
<p><strong>异常（exception）</strong>：是指程序执行过程中出现的错误或异常情况，如除零错误、访问非法内存等。当发生异常时，操作系统会捕获并进行相应的处理，例如终止异常程序、显示错误消息等。</p>
<p><strong>系统调用（system call）</strong>：是应用程序通过操作系统提供的接口来请求操作系统的服务。通过系统调用，应用程序可以访问操作系统提供的功能，如文件读写、网络通信、内存管理等。应用程序通过系统调用将请求传递给操作系统，操作系统执行相应的操作，并将结果返回给应用程序。</p>
<h3 id="来源"><a href="# 来源" class="headerlink" title="来源"></a>来源 </h3><p><strong> 中断来源于外设</strong>：来自不同的硬件设备的计时器和网络的中断。</p>
<p><strong>异常来源于不良的应用程序</strong>：非法指令或者其他坏的处理状态（如：内存出错）。</p>
<p><strong>系统调用来源于应用程序</strong>：应用程序主动向操作系统发出服务请求。</p>
<h3 id="处理时间"><a href="# 处理时间" class="headerlink" title="处理时间"></a>处理时间</h3><ul>
<li>中断：异步</li>
<li>异常：同步</li>
<li>系统调用：同步或异步<ul>
<li>同步：指应用程序等待系统调用的返回结果</li>
<li>异步：指应用程序发出系统调用后就去干别的事情了</li>
</ul>
</li>
</ul>
<blockquote>
<p>异步：应用程序不知道什么时候会发生 <br> 同步：执行到某一条指令一定会发生该事件</p>
</blockquote>
<h3 id="响应状态"><a href="# 响应状态" class="headerlink" title="响应状态"></a>响应状态</h3><ul>
<li>中断：持续，对用户应用程序是透明的</li>
<li>异常：杀死或重新执行指令</li>
<li>系统调用：等待和持续</li>
</ul>
<h3 id="中断、异常和系统调用比较"><a href="# 中断、异常和系统调用比较" class="headerlink" title="中断、异常和系统调用比较"></a>中断、异常和系统调用比较</h3><p><img src="/images/os-kernel/chapter2/os-interrupt-exception-syscall-compare.png" alt="中断、异常和系统调用比较"></p>
<table>
<thead>
<tr>
<th>交互方式</th>
<th>来源</th>
<th>处理时间</th>
<th>响应状态</th>
</tr>
</thead>
<tbody><tr>
<td>中断</td>
<td>外设</td>
<td>异步</td>
<td>持续，对用户应用程序透明</td>
</tr>
<tr>
<td>异常</td>
<td>不良的应用程序</td>
<td>同步</td>
<td>杀死或重新执行指令</td>
</tr>
<tr>
<td>系统调用</td>
<td>应用程序</td>
<td>同步或异步</td>
<td>等待和持续</td>
</tr>
</tbody></table>
<h3 id="中断和异常处理流程"><a href="# 中断和异常处理流程" class="headerlink" title="中断和异常处理流程"></a>中断和异常处理流程 </h3><p> 中断是外设的事件，异常是内部 CPU 的事件。中断和异常迫使 CPU 访问一些与中断和异常相关的功能和服务。</p>
<h4 id="中断处理流程"><a href="# 中断处理流程" class="headerlink" title="中断处理流程"></a>中断处理流程 </h4><p> 操作系统的中断处理流程包括硬件中断处理和软件中断处理两个部分。</p>
<p>硬件中断处理流程如下：</p>
<ol>
<li>硬件设备产生中断信号，例如外设完成数据传输、定时器到达计时器溢出等。</li>
<li><strong>CPU 检测到中断信号后，会立即停止当前正在执行的指令，并将当前执行指令的上下文（包括寄存器状态、程序计数器等）保存到内存中的堆栈中</strong>。</li>
<li>CPU 根据中断信号的类型，通过中断向量表或中断描述符表（IDT）查找相应的中断处理程序的入口地址。</li>
<li>CPU 跳转到中断处理程序的入口地址，开始执行中断处理程序。</li>
<li>中断处理程序根据中断类型执行相应的操作，例如处理设备的数据、更新操作系统状态等。</li>
<li><strong>中断处理程序执行完毕后，将之前保存的上下文从堆栈中恢复回来</strong>。</li>
<li>CPU 继续执行被中断的指令或者执行下一个指令。</li>
</ol>
<p>软件中断处理流程如下：</p>
<ol>
<li>程序通过系统调用或软中断指令触发软件中断。</li>
<li>CPU 执行软中断指令后，<strong>会暂停当前正在执行的指令，并将当前执行指令的上下文保存到内存中的堆栈中</strong>。</li>
<li>CPU 根据软中断号，在中断向量表或中断描述符表（IDT）中查找相应的中断处理程序的入口地址。</li>
<li>CPU 跳转到中断处理程序的入口地址，开始执行中断处理程序。</li>
<li>中断处理程序根据软中断号执行相应的操作，例如系统调用、异常处理等。</li>
<li>中断处理程序执行完毕后，<strong>将之前保存的上下文从堆栈中恢复回来</strong>。</li>
<li>CPU 继续执行被中断的指令或者执行下一个指令。</li>
</ol>
<p>总的来说，中断处理流程包括 <strong> 中断信号的检测、上下文的保存与恢复、中断处理程序的执行 </strong> 等步骤，以保证操作系统能够及时响应硬件设备的请求或软件的触发。</p>
<blockquote>
<p>应用程序完全不会感知到中断的产生。</p>
</blockquote>
<h4 id="异常处理流程"><a href="# 异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程 </h4><p> 操作系统的异常处理流程如下：</p>
<ol>
<li><strong>异常产生</strong>：异常是指在程序执行过程中发生的错误或异常情况，例如访问非法内存、除零错误等。异常可以由硬件产生，也可以由软件产生。</li>
<li><strong>异常检测</strong>：CPU 会检测到异常的发生，并中断当前正在执行的指令。</li>
<li><strong>异常处理程序选择</strong>：CPU 会通过中断向量表或中断描述符表（IDT）查找相应的异常处理程序的入口地址。</li>
<li><strong>上下文保存</strong>：CPU 会将当前执行指令的上下文（包括寄存器状态、程序计数器等）保存到内存中的堆栈中。</li>
<li><strong>异常处理程序执行</strong>：CPU 跳转到异常处理程序的入口地址，开始执行异常处理程序。</li>
<li><strong>异常处理</strong>：异常处理程序会根据异常类型执行相应的操作，例如打印错误信息、终止异常进程、恢复系统状态等。</li>
<li><strong>上下文恢复</strong>：异常处理程序执行完毕后，将之前保存的上下文从堆栈中恢复回来。</li>
<li><strong>异常返回</strong>：CPU 继续执行被中断（指的是由异常引起的中断，而不是外部设备或事件所引起的中断）的指令或者执行下一个指令。</li>
</ol>
<p>总的来说，异常处理流程包括 <strong> 异常信号的检测、上下文的保存与恢复、异常处理程序的执行 </strong> 等步骤，异常处理流程的目的是在程序出现异常时能够及时处理异常情况，保证系统的稳定性和可靠性。</p>
<h3 id="系统调用"><a href="# 系统调用" class="headerlink" title="系统调用"></a>系统调用 </h3><p> 系统调用来源于应用程序，需要操作系统提供服务，这些服务需要操作系统来执行，这个过程就需要一个接口：<strong>系统调用接口</strong>。应用程序访问主要是通过高层次的 API 接口，而不是直接进行系统调用。</p>
<p><img src="/images/os-kernel/chapter2/os-syscall.png" alt="系统调用示例"></p>
<p><strong>三种最常用的 APIs</strong>：</p>
<ul>
<li>Win32 API：用于 Windows</li>
<li>POSIX API：用于 POSIX-based systems（包括 UNIX，LINUX，Mac OS X）</li>
<li>Java API：用于 JAVA 虚拟机（JVM 跨平台）</li>
</ul>
<p><strong>特点</strong>：</p>
<ul>
<li>通常情况下，每个系统调用对应一个系统调用号<ul>
<li>系统调用接口根据这些序号来维护表的索引</li>
</ul>
</li>
<li>系统调用接口调用内核态中预期的系统调用<ul>
<li>并返回系统调用的状态和其他任何返回值</li>
</ul>
</li>
<li>用户不需要知道系统调用是如何实现的<ul>
<li>只需要获取 API 和了解操作系统将什么作为返回结果</li>
<li>操作系统接口的细节大部分都隐藏在 API 中</li>
</ul>
</li>
</ul>
<p><strong>用户态</strong>：操作系统运行中，CPU 所处的特权级别特别低，不能访问特权指令、I&#x2F;O 指令。</p>
<p><strong>内核态</strong>：操作系统运行中，CPU 所处的级别很高，可以执行任何一条指令，包括特权指令、I&#x2F;O 指令。</p>
<p><strong>系统调用 </strong>：触发 CPU<strong> 从用户态到内核态的转换</strong>。切换程序和内核的堆栈，需要一定的开销，但是换来了安全。</p>
<p><strong>系统调用是跨越操作系统边界的开销</strong>（值得的且必须的，保证了操作系统的安全性）：</p>
<ul>
<li>在执行时间上的开销超过程序调用</li>
<li>开销：<ul>
<li>建立中断、异常、系统调用号与对应服务例程映射关系的初始化开销</li>
<li>建立内核堆栈（用于内核退出时保存，内核执行时恢复，类似于应用程序的堆栈）</li>
<li>验证参数（内核不信任应用程序，故而需要验证参数）</li>
<li>内核态映射到用户态的地址空间（<strong>通过拷贝的方式传递数据</strong>，不像用户态下的应用程序，可以通过指针传递实现）<ul>
<li>更新页面映射权限</li>
</ul>
</li>
<li>内核态独立地址空间<ul>
<li>通过在 TLB 中维护不同的页表实现</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>「内核态独立地址空间」是指在操作系统中，内核和用户程序所使用的内存地址空间是相互独立的。</p>
</blockquote>
<h2 id="什么是更新页面映射权限"><a href="# 什么是更新页面映射权限" class="headerlink" title="什么是更新页面映射权限"></a>什么是更新页面映射权限 </h2><p>「更新页面映射权限」是指在操作系统中，<strong> 对虚拟内存中的页面进行权限的调整或修改</strong>。</p>
<p>在虚拟内存管理中，操作系统将物理内存空间映射到进程的虚拟地址空间中，形成了一种虚拟内存映射。每个页面都有对应的权限，例如读、写、执行等。当需要修改某个页面的权限时，就需要进行页面映射权限的更新。</p>
<p>更新页面映射权限的具体操作包括：</p>
<ol>
<li><strong>检查该页面的当前权限</strong>：首先，操作系统会检查该页面的当前权限，确定要进行哪些修改。</li>
<li><strong>修改页面权限</strong>：根据需要，操作系统会修改页面的权限，例如增加或删除某项权限。</li>
<li><strong>更新页表 </strong>：在虚拟内存管理中，每个进程都有自己的页表，<strong> 用于记录虚拟地址与物理地址之间的映射关系</strong>。当页面的权限发生变化时，操作系统需要更新相应的页表项，以反映最新的权限信息。</li>
</ol>
<p>通过更新页面映射权限，操作系统可以 <strong> 实现对进程的内存访问控制</strong>，保证系统的安全性和稳定性。</p>
<h2 id="应用程序不能直接访问外设"><a href="# 应用程序不能直接访问外设" class="headerlink" title="应用程序不能直接访问外设"></a>应用程序不能直接访问外设 </h2><p> 应用程序不能直接访问外设，而要通过操作系统的原因主要有以下几点：</p>
<ol>
<li>安全性：操作系统（内核）是被信任的第三方，只有操作系统才能执行特权指令，保护硬件和系统资源的安全。</li>
<li>统一性：通过操作系统提供的接口，应用程序可以统一地访问不同的外设，而不需要关心具体的硬件细节。</li>
<li>方便性：操作系统提供了一些高级功能和服务，如文件系统、网络协议等，应用程序可以更方便地使用这些功能。</li>
</ol>
<blockquote>
<p>参考 1：<a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a><br>参考 2：<a href="https://blog.csdn.net/weixin_53407527/category_11825873.html">https://blog.csdn.net/weixin_53407527/category_11825873.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之二叉树的遍历</title>
    <url>/posts/230905224335.html</url>
    <content><![CDATA[<h2 id="二叉树的遍历"><a href="# 二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历 </h2><p> 二叉树是一种非常重要的数据结构，很多其它数据结构都是基于二叉树的基础演变而来的。</p>
<p>所谓遍历 Traversal 是指沿着某条搜索路线，依次对树中每个结点均做一次且仅做一次访问。</p>
<p>对于二叉树，有深度遍历和广度遍历，深度遍历有前序、中序以及后序遍历三种方法，广度遍历即我们平常所说的层次遍历。因为树的定义本身就是递归定义，因此采用递归的方法去实现树的三种遍历不仅容易理解而且代码很简洁，而对于广度遍历来说，需要其他数据结构的支撑。</p>
<p>四种遍历的主要思想是：</p>
<ul>
<li><p>前序遍历：根节点 -&gt; 左子树 -&gt; 右子树</p>
</li>
<li><p>中序遍历：左子树 -&gt; 根节点 -&gt; 右子树</p>
</li>
<li><p>后续遍历：左子树 -&gt; 右子树 -&gt; 根节点</p>
</li>
<li><p>层序遍历：依二叉树的深度从左到右（右到左）按层遍历</p>
</li>
</ul>
<p>其中，前、中、后续指的是「根节点」的遍历顺序，例如前序遍历是先遍历根节点。</p>
<span id="more"></span>

<p>以下为一棵二叉树不同的遍历顺序以及实现方法（非递归实现 &#x2F; 递归实现）：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \   \</span><br><span class="line">4   5   6</span><br><span class="line"></span><br><span class="line">层次遍历顺序：[1 2 3 4 5 6] / 非递归实现：队列 + BFS</span><br><span class="line">前序遍历顺序：[1 2 4 5 3 6] / 非递归实现：栈，递归实现：DFS</span><br><span class="line">中序遍历顺序：[4 2 5 1 3 6] / 非递归实现：栈，递归实现：DFS</span><br><span class="line">后序遍历顺序：[4 5 2 6 3 1] / 非递归实现：栈，递归实现：DFS</span><br></pre></td></tr></table></figure>

<p>层次遍历使用 BFS 实现，利用的就是 BFS 一层一层遍历的特性，而前序、中序、后序遍历利用了 DFS 实现。</p>
<blockquote>
<p>前序、中序、后序遍只是在对节点访问的顺序有一点不同，其它都相同。</p>
</blockquote>
<p>下面直接从 Leetcode 练习题，学习二叉树的不同遍历方法。</p>
<h3 id="二叉树的层序遍历"><a href="# 二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h3><blockquote>
<p>题目链接：<a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></p>
</blockquote>
<p><strong>题目</strong>：给定一个非空二叉树，返回一个由每层节点平均值组成的数组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">输出: [3, 14.5, 11]</span><br><span class="line">解释: 第 0 层的平均值是 3,  第 1 层是 14.5, 第 2 层是 11. 因此返回 [3, 14.5, 11].</span><br></pre></td></tr></table></figure>

<p><strong>层序遍历</strong>：利用队列实现二叉树的层序遍历。</p>
<p>python 双端队列实现二叉树的层序遍历：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">averageOfLevels</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">import</span> collections</span><br><span class="line">    queue = collections.deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        size = <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="built_in">sum</span>, tmp_size = <span class="number">0</span>, size</span><br><span class="line">        <span class="keyword">while</span> size &gt; <span class="number">0</span>:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            size -= <span class="number">1</span></span><br><span class="line">            <span class="built_in">sum</span> += node.val</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">        res.append(<span class="built_in">sum</span> / tmp_size)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>C 语言实现基于链表的队列，然后基于队列实现二叉树的层序遍历：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define the structure for a node in the queue</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define the structure for the queue</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    Node *front;</span><br><span class="line">    Node *rear;</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to create a new node</span></span><br><span class="line">Node *<span class="title function_">createNode</span><span class="params">(<span class="keyword">struct</span> TreeNode *data)</span> &#123;</span><br><span class="line">    Node *newNode = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to create an empty queue</span></span><br><span class="line">Queue* <span class="title function_">createQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    Queue *<span class="built_in">queue</span> = (Queue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to check if the queue is empty</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Queue *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to enqueue an element into the queue</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enQueue</span><span class="params">(Queue *<span class="built_in">queue</span>, <span class="keyword">struct</span> TreeNode *data)</span> &#123;</span><br><span class="line">    Node *newNode = createNode(data);</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear-&gt;next = newNode;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to dequeue an element from the queue</span></span><br><span class="line"><span class="keyword">struct</span> TreeNode *<span class="title function_">deQueue</span><span class="params">(Queue* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *temp = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">data</span> =</span> temp-&gt;data;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;front-&gt;next;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span>* <span class="title function_">averageOfLevels</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    <span class="type">double</span> *ans = (<span class="type">double</span> *)<span class="built_in">malloc</span>(<span class="number">10000</span> * <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">    Queue *<span class="built_in">queue</span> = createQueue();</span><br><span class="line">    enQueue(<span class="built_in">queue</span>, root);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> size = <span class="built_in">queue</span>-&gt;size;</span><br><span class="line">        <span class="type">int</span> tmp_size = size;</span><br><span class="line">        <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">node</span> =</span> deQueue(<span class="built_in">queue</span>);</span><br><span class="line">            sum += node-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">                enQueue(<span class="built_in">queue</span>, node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">                enQueue(<span class="built_in">queue</span>, node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[(*returnSize)++] = sum / tmp_size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之拓扑排序</title>
    <url>/posts/230916094606.html</url>
    <content><![CDATA[<h2 id="什么是拓扑排序"><a href="# 什么是拓扑排序" class="headerlink" title="什么是拓扑排序"></a>什么是拓扑排序 </h2><p> 引用百度百科的拓扑排序定义：</p>
<blockquote>
<p>对一个有向无环图（Directed Acyclic Graph, DAG）$G$ 进行拓扑排序，是将 $G$ 中所有顶点排成一个 <strong> 线性序列 </strong>，使得图中任意一对顶点 $u$ 和 $v$，若边 $&lt;u,v&gt; \in E(G)$，则 $u$ <strong> 在线性序列中出现在 </strong> $v$ 之前。通常，这样的线性序列称为满足拓扑次序（Topological Order）的序列，简称<strong> 拓扑序列</strong>。</p>
</blockquote>
<p>拓扑排序可以被理解为对一个有向无环图进行排序的操作。在这个排序中，图中的顶点被排列成一个线性序列，<strong>满足以下条件：对于图中的任意一对顶点 $u$ 和 $v$，如果存在一条边 $&lt;u,v&gt;$，那么在线性序列中，顶点 $u$ 出现在顶点 $v$ 之前</strong>。</p>
<p>换句话说，拓扑排序可以将有向无环图中的顶点按照它们的依赖关系排序，使得所有的依赖关系都被满足。这对于处理任务的依赖关系非常有用，例如工程项目中的任务调度，编译器中的源代码依赖等。</p>
<span id="more"></span>

<p>例如，下图中 <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code> 是一个正确的拓扑排序，每个节点都在它所依赖的节点后面。而 <code>1-&gt;2-&gt;4-&gt;3-&gt;5</code> 则不满足拓扑排序的要求，<code>4</code> 依赖于 <code>3</code>，却出现在了 <code>3</code> 前面。</p>
<p><img src="/images/data-structure/topo-sort.png"></p>
<h2 id="拓扑排序基本原理"><a href="# 拓扑排序基本原理" class="headerlink" title="拓扑排序基本原理"></a>拓扑排序基本原理 </h2><p> 拓扑排序（Topological Sorting）是一种用于有向无环图（DAG）的排序算法，它将图中的节点按照依赖关系进行排序，使得所有的依赖关系都被满足。</p>
<p>拓扑排序的一些重要知识点：</p>
<ol>
<li><p>有向无环图（DAG）：拓扑排序只能应用于没有环的有向图，因为有环的图存在循环依赖，无法进行拓扑排序。</p>
</li>
<li><p>入度和出度：在拓扑排序中，入度表示指向某个节点的边的数量，出度表示从某个节点发出的边的数量。</p>
</li>
<li><p>拓扑排序算法：拓扑排序算法可以通过深度优先搜索或广度优先搜索（Kahn 算法）来实现。<strong>DFS 通常使用递归或栈来实现，而 BFS 则使用队列来实现</strong>。</p>
</li>
<li><p>多个拓扑排序结果：一个有向图可能存在多种不同的拓扑排序结果，这取决于节点的访问顺序。一种常见的方法是使用优先队列或字典序来选择节点的顺序，以得到特定的排序结果。</p>
</li>
</ol>
<h3 id="要解决的问题"><a href="# 要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题 </h3><p> 对于有向图进行拓扑排序要解决两个问题：</p>
<ul>
<li>一是要判断待排序的有向图是不是无环；</li>
<li>二是按照依赖关系生成正确的序列。</li>
</ul>
<h3 id="基本思想"><a href="# 基本思想" class="headerlink" title="基本思想"></a>基本思想 </h3><p> 拓扑排序的基本思想是：</p>
<ul>
<li><p>入度思想：首先找到图中没有前驱节点的节点（即入度为 0 的节点），将其 <strong> 顺序 </strong> 加入结果列表中，并将其从图中删除。然后，继续寻找新的没有前驱节点的节点，并重复以上过程，直到所有的节点都被加入结果列表中或者无法再找到没有前驱节点的节点为止。</p>
</li>
<li><p>出度思想：首先找到图中没有后驱节点的节点（即出度为 0 的节点），将其 <strong> 逆序 </strong> 加入结果列表中，并将其从图中删除。然后，继续寻找新的没有后驱节点的节点，并重复以上过程，直到所有的节点都被加入结果列表中或者无法再找到没有后驱节点的节点为止。</p>
</li>
</ul>
<h3 id="BFS-Kaha 拓扑排序算法"><a href="#BFS-Kaha 拓扑排序算法" class="headerlink" title="BFS&#x2F;Kaha 拓扑排序算法"></a>BFS&#x2F;Kaha 拓扑排序算法 </h3><p> 拓扑排序的具体步骤：</p>
<ol>
<li>初始化一个结果列表（或者称为拓扑序列）和一个队列。</li>
<li>遍历图中的所有节点（对），统计每个节点的入度（即有多少条边指向该节点）。</li>
<li>将入度为 0 的节点加入队列中。</li>
<li>当队列不为空时，执行以下操作：<ul>
<li>取出队首节点，并将其加入结果列表中。</li>
<li>遍历该节点的所有邻接节点（即该节点指向的节点）：<ul>
<li>将邻接节点的入度减 1。</li>
<li>如果邻接节点的入度减为 0，将其加入队列中。</li>
</ul>
</li>
</ul>
</li>
<li>如果结果列表的长度等于图中的节点数，则说明拓扑排序成功，返回结果列表，表示拓扑序列。</li>
<li>如果结果列表的长度小于图中的节点数，则说明图中存在环，无法进行拓扑排序。</li>
</ol>
<p>通过循环找到入度为 0 的节点，并将其加入结果列表，然后更新与该节点相邻的节点的入度，重复此过程，最终得到一个满足拓扑次序的序列，或者判断出图中存在环。</p>
<blockquote>
<p>BFS &#x2F; Kaha 拓扑排序算法是从入度的角度着手的，这种方法可称之为 <strong> 入度方法</strong>。</p>
</blockquote>
<h3 id="BFS 拓扑排序实现"><a href="#BFS 拓扑排序实现" class="headerlink" title="BFS 拓扑排序实现"></a>BFS 拓扑排序实现 </h3><p> 以 <a href="https://leetcode.cn/problems/course-schedule-ii/">Leetcode 课程表 II</a> 为例，给出 BFS 拓扑排序算法的实现过程。</p>
<p>题目大意：一共有 n 门课程，课程之间存在依赖关系，比如先修完 A 课程，才能修 B 课程。问这个学生能不能修完所有课程，能的话则返回一种可能的课程学习顺序。</p>
<p>代码实现中的关键变量：</p>
<ul>
<li><code>indegree[]</code>：初始化每个节点的入度，并随着节点出队更新入度值；</li>
<li><code>edges[][]</code>：记录每个节点影响的其它节点，用于该节点的入度变为 0 时更新“影响的其它节点”的入度值；</li>
<li><code>queue</code>：队列用于入队、出队所有入度为 0 的节点；</li>
<li><code>ans[]</code>：结果队列用于保存出队的节点；</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ELEM_TYPE int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Define the structure for a node in the queue</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ELEM_TYPE data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define the structure for the queue</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    Node* front;</span><br><span class="line">    Node* rear;</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to create a new node</span></span><br><span class="line">Node* <span class="title function_">createNode</span><span class="params">(ELEM_TYPE data)</span> &#123;</span><br><span class="line">    Node* newNode = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to create an empty queue</span></span><br><span class="line">Queue* <span class="title function_">createQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    Queue* <span class="built_in">queue</span> = (Queue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to check if the queue is empty</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Queue* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to enqueue an element into the queue</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enQueue</span><span class="params">(Queue* <span class="built_in">queue</span>, ELEM_TYPE data)</span> &#123;</span><br><span class="line">    Node* newNode = createNode(data);</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear-&gt;next = newNode;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to dequeue an element from the queue</span></span><br><span class="line">ELEM_TYPE <span class="title function_">deQueue</span><span class="params">(Queue* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* temp = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">    ELEM_TYPE data = temp-&gt;data;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;front-&gt;next;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">findOrder</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>** prerequisites, <span class="type">int</span> prerequisitesSize, <span class="type">int</span>* prerequisitesColSize, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> indegree[numCourses];  <span class="comment">// 每个节点的入度，入度为 0 表示不受其它节点影响 </span></span><br><span class="line">    <span class="type">int</span> **edges = (<span class="type">int</span> **)<span class="built_in">malloc</span>(numCourses * <span class="keyword">sizeof</span>(<span class="type">int</span> *));  <span class="comment">// 二维数组, 记录每个节点影响的节点们</span></span><br><span class="line">    <span class="type">int</span> edgeNums[numCourses];  <span class="comment">// 记录每个节点影响的节点数量, 用于动态扩展空间</span></span><br><span class="line">    <span class="type">int</span> *ans = (<span class="type">int</span> *)<span class="built_in">malloc</span>(numCourses * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">        indegree[i] = <span class="number">0</span>;</span><br><span class="line">        edgeNums[i] = <span class="number">0</span>;</span><br><span class="line">        edges[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">0</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 后续按需扩展</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历所有节点对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prerequisitesSize; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> suff = prerequisites[i][<span class="number">0</span>], pre = prerequisites[i][<span class="number">1</span>];</span><br><span class="line">        edgeNums[pre]++;  <span class="comment">// suff 受到了 pre 影响, 故 pre 节点影响的节点数量 +1</span></span><br><span class="line">        indegree[suff]++;  <span class="comment">// suff 受到了 pre 影响，其入度要 +1</span></span><br><span class="line">        edges[pre] = (<span class="type">int</span> *)<span class="built_in">realloc</span>(edges[pre], edgeNums[pre] * <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 扩展内存</span></span><br><span class="line">        edges[pre][edgeNums[pre] - <span class="number">1</span>] = suff;  <span class="comment">// 在索引(pre, 最后位置) 记录 suff</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue* <span class="built_in">queue</span> = createQueue();</span><br><span class="line">    <span class="comment">// 入度所有不受影响的节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            enQueue(<span class="built_in">queue</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        ELEM_TYPE cur = deQueue(<span class="built_in">queue</span>);</span><br><span class="line">        ans[count++] = cur;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历出队的节点影响的所有节点, 它们的受影响度将 -1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edgeNums[cur]; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> x = edges[cur][i];</span><br><span class="line">            indegree[x]--;</span><br><span class="line">            <span class="keyword">if</span> (indegree[x] == <span class="number">0</span>) &#123;</span><br><span class="line">                enQueue(<span class="built_in">queue</span>, x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">        <span class="built_in">free</span>(edges[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(edges);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断结果队列长度，确定是否可以完成拓扑排序</span></span><br><span class="line">    <span class="keyword">if</span> (count == numCourses) &#123;</span><br><span class="line">        (*returnSize) = count;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (*returnSize) = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DFS 拓扑排序算法"><a href="#DFS 拓扑排序算法" class="headerlink" title="DFS 拓扑排序算法"></a>DFS 拓扑排序算法</h3><p>DFS 拓扑排序算法的思想和 BFS 拓扑排序算法相似，但在具体步骤上有所不同。</p>
<p>DFS 拓扑排序算法的基本思想是：通过递归遍历图中的节点，<strong>从一个起始节点开始</strong>，当遍历到一个节点时，先将其所有未访问的邻居节点进行递归遍历，之后将当前节点添加到结果列表中。如果在递归的过程中，发现当遍历到一个节点时，存在已经被访问过的邻居节点，则说明途中存在环，无法进行拓扑排序。</p>
<p>DFS 拓扑排序的具体步骤如下：</p>
<ol>
<li>初始化一个空的结果列表和一个空的访问状态列表。</li>
<li>对于图中的每个节点，如果该节点未被访问，则调用 DFS 函数进行遍历。</li>
<li>在 DFS 函数中，首先将当前节点标记为正在访问。</li>
<li>递归遍历当前节点的所有未访问的邻居节点，将每个邻居节点作为新的起始节点进行递归遍历。</li>
<li>当没有未访问的邻居节点时，将当前节点的访问状态更新为已访问，并逆序添加到结果列表中。</li>
<li>最终，结果列表中的节点正序顺序即为 DFS 拓扑排序的结果。</li>
</ol>
<blockquote>
<p>需要注意的是：在进行 DFS 拓扑排序的过程中，如果发现某个节点的邻居节点已经被访问过（即已经在结果列表中），那么说明存在环，无法进行拓扑排序。在这种情况下，可以中断排序过程并返回一个表示存在环的标志。</p>
</blockquote>
<p>代码实现中的关键变量：</p>
<ul>
<li><code>visited[]</code>：记录每个节点的访问状态，0 表示未访问，1 表示正在访问，2 表示访问完成；</li>
<li><code>edges[][]</code>：记录每个节点所有邻居节点；</li>
<li><code>ans[]</code>：结果队列；</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span>* visited, <span class="type">int</span>** edges, <span class="type">int</span>* edgeNums, <span class="type">int</span>* ans, <span class="type">int</span>* cnt, <span class="type">bool</span>* valid)</span> &#123;</span><br><span class="line">    visited[node] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edgeNums[node]; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> neigNode = edges[node][i];</span><br><span class="line">        <span class="keyword">if</span> (visited[neigNode] == <span class="number">0</span>) &#123;</span><br><span class="line">            dfs(neigNode, visited, edges, edgeNums, ans, cnt, valid);</span><br><span class="line">            <span class="comment">// 这行代码测试发现不是必须的, 为什么不是必须的？加上可以有剪枝（提前终止）的作用</span></span><br><span class="line">            <span class="keyword">if</span> (!(*valid)) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (visited[neigNode] == <span class="number">1</span>) &#123;</span><br><span class="line">            *valid = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    visited[node] = <span class="number">2</span>;</span><br><span class="line">    ans[--(*cnt)] = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">findOrder</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>** prerequisites, <span class="type">int</span> prerequisitesSize, <span class="type">int</span>* prerequisitesColSize, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span>* visited = (<span class="type">int</span> *)<span class="built_in">malloc</span>(numCourses * <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 记录每一个节点的访问状态</span></span><br><span class="line">    <span class="type">int</span>** edges = (<span class="type">int</span> **)<span class="built_in">malloc</span>(numCourses * <span class="keyword">sizeof</span>(<span class="type">int</span> *));  <span class="comment">// 二维数组, 记录每个节点所有邻居节点</span></span><br><span class="line">    <span class="type">int</span>* edgeNums = (<span class="type">int</span> *)<span class="built_in">malloc</span>(numCourses * <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 记录每个节点的邻居节点数量</span></span><br><span class="line">    <span class="type">int</span>* ans = (<span class="type">int</span> *)<span class="built_in">malloc</span>(numCourses * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span> cnt = numCourses;</span><br><span class="line">    <span class="type">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, numCourses * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">memset</span>(edgeNums, <span class="number">0</span>, numCourses * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">        edges[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">0</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建邻接表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prerequisitesSize; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> suff = prerequisites[i][<span class="number">0</span>], pre = prerequisites[i][<span class="number">1</span>];  <span class="comment">// edge: pre-&gt;suff</span></span><br><span class="line">        edges[pre] = (<span class="type">int</span> *)<span class="built_in">realloc</span>(edges[pre], (edgeNums[pre] + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        edges[pre][edgeNums[pre]] = suff;</span><br><span class="line">        edgeNums[pre]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// DFS 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            dfs(i, visited, edges, edgeNums, ans, &amp;cnt, &amp;valid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">        <span class="built_in">free</span>(edges[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(edges);</span><br><span class="line">    <span class="built_in">free</span>(visited);</span><br><span class="line">    <span class="built_in">free</span>(edgeNums);</span><br><span class="line">    </span><br><span class="line">    *returnSize = (cnt &gt; <span class="number">0</span> || !valid) ? <span class="number">0</span> : numCourses;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考链接：<a href="https://jingsam.github.io/2020/08/11/topological-sort.html">https://jingsam.github.io/2020/08/11/topological-sort.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之 pthread 多线程</title>
    <url>/posts/230911151334.html</url>
    <content><![CDATA[<h2 id="多线程"><a href="# 多线程" class="headerlink" title="多线程"></a>多线程 </h2><h3 id="进程与线程"><a href="# 进程与线程" class="headerlink" title="进程与线程"></a> 进程与线程 </h3><p><strong> 进程</strong>：是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单元，是应用程序运行的载体。进程一般由程序、数据集合和进程控制块三部分组成：</p>
<ul>
<li><p>程序：描述进程的功能，控制进程的指令集（写论文的目的和手段）</p>
</li>
<li><p>数据集：程序在执行时所需要的数据和工作区（写论文的材料）</p>
</li>
<li><p>进程控制块：跟踪每个进程的状态，操作系统会为进程保留进程列表（写作者）</p>
</li>
</ul>
<p><strong>线程 </strong>：线程是程序执行中的一个单一的<strong> 顺序控制流程</strong>，是程序执行流的最小单元，是处理器调度和分派的基本单位。</p>
<ul>
<li><p>一个进程至少有一个线程，一个进程也可以有多个线程。（一个父亲可以有一个、多个孩子）</p>
</li>
<li><p>各个线程之间共享程序的内存空间，即所在进程的内存空间。（多个孩子共享一个家庭空间）</p>
</li>
<li><p>一个标准的线程由线程 ID、当前指令指针 PC、寄存器和堆栈组成。（每个孩子有其自身的成长轨迹）</p>
</li>
</ul>
<span id="more"></span>

<p><strong>进程与线程的区别</strong>：</p>
<ul>
<li><p>线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位。</p>
</li>
<li><p>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线。</p>
</li>
<li><p>进程之间相互独立，但 <strong> 同一进程下的各个线程之间共享程序的内存空间 </strong>（代码段、数据集、堆等）以及一些<strong> 进程级的资源</strong>（如打开文件和信号等），某进程内的线程在其他进程中不可见。</p>
</li>
<li><p><strong>线程上下文切换比进程上下文切换要快得多</strong>。</p>
</li>
</ul>
<h3 id="上下文切换"><a href="# 上下文切换" class="headerlink" title="上下文切换"></a>上下文切换 </h3><h4 id="时间片"><a href="# 时间片" class="headerlink" title="时间片"></a> 时间片 </h4><p> 多任务系统往往需要同时执行多道作业。作业数往往大于机器的 CPU 数，然而一颗 CPU 同时只能执行一项任务，如何让用户感觉这些任务正在同时进行呢? 操作系统的设计者巧妙地利用了 <strong> 时间片轮转的方式</strong>。</p>
<p><strong>时间片是 CPU 分配给各个任务（线程）的时间</strong>。</p>
<blockquote>
<p>思考：单核 CPU 为何也支持多线程呢？</p>
<p>虽然单核 CPU 只有一个物理处理单元，但它可以 <strong> 通过时间分片的方式支持多线程</strong>。在单核 CPU 中，操作系统通过时间片轮转算法将 CPU 时间划分为多个时间片段，每个时间片段分配给一个线程执行。当一个线程的时间片用完后，操作系统会暂停该线程的执行，并切换到下一个线程继续执行。这种切换是非常快速的，以至于我们感觉多个线程在同时执行。</p>
<p>需要注意的是，在单核 CPU 上并发执行的多线程是通过时间片轮转调度实现的，每个线程在任意给定的时间点上 <strong> 只能有一个 </strong> 线程在执行。而在多核 CPU 上，可以实现真正的并行执行，每个核心可以同时执行一个线程，从而提高并发性能。</p>
</blockquote>
<h4 id="上下文切换 -1"><a href="# 上下文切换 -1" class="headerlink" title="上下文切换"></a>上下文切换 </h4><p><strong> 线程上下文 </strong>：是指某一时间点 CPU <strong> 寄存器和程序计数器的内容</strong>，CPU 通过时间片分配算法来循环执行任务（线程），因为时间片非常短，所以 CPU 通过不停地切换线程执行。</p>
<p>换言之，单 CPU 这么频繁，多核 CPU 一定程度上可以减少上下文切换。</p>
<p><strong>上下文切换 </strong>：CPU 切换前把当前任务的状态保存下来（以便下次切换回这个任务时可以再次加载这个任务的状态），然后加载下一任务的状态并执行。<strong> 任务的状态保存及再加载</strong>，这段过程就叫做上下文切换。</p>
<h3 id="多线程编程"><a href="# 多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h3><ul>
<li><p>多进程模式：启动多个进程，每个进程虽然只有一个线程，但是多个进程可以一块执行多个任务。</p>
</li>
<li><p><strong>多线程模式</strong>：启动一个进程，在一个进程内启动多个线程，多个线程一起执行多个任务。</p>
</li>
<li><p>多进程 + 多线程模式：启动多个进程，每个进程再启动多个线程，这样同时执行的任务就更多了。</p>
</li>
</ul>
<p>其实创建线程之后，线程并不是始终保持一个状态的，其状态大概如下：</p>
<ol>
<li>New 创建</li>
<li>Runnable 就绪，等待调度</li>
<li>Running 运行</li>
<li>Blocked 阻塞，阻塞可能在 Wait &#x2F; Locked &#x2F; Sleeping 阶段</li>
<li>Dead 消亡</li>
</ol>
<p>线程有着不同的状态，也有不同的类型。大致可分为：</p>
<ul>
<li><p>主线程：主线程是程序启动时自动创建的线程，它负责执行程序的主要逻辑。主线程通常负责处理用户交互、调度其他线程的创建和管理等任务。</p>
</li>
<li><p>子线程：子线程是由主线程创建的额外线程，用于执行并发任务。子线程可以并行地执行任务，从而提高程序的效率和响应性。</p>
</li>
<li><p>守护线程（后台线程）：守护线程是一种特殊类型的线程，它在后台运行，<strong>不会阻止程序的退出</strong>。当所有的非守护线程都退出时，守护线程也会自动结束。守护线程通常用于执行一些后台任务，如日志记录、定时任务等。</p>
</li>
<li><p>前台线程：前台线程是与守护线程相对的概念，它是指 <strong> 会阻止程序退出的线程</strong>。当所有的前台线程都退出时，程序才会结束。</p>
</li>
</ul>
<h3 id="pthread 多线程"><a href="#pthread 多线程" class="headerlink" title="pthread 多线程"></a>pthread 多线程</h3><p>POSIX 线程（Pthreads）是一套标准的线程 API，用于多线程编程。该库定义了一组 C 语言函数，允许程序员创建和管理多个线程，并提供同步和互斥机制，以确保线程之间的正确协调。</p>
<p>Pthreads 库是 POSIX 标准的一部分，其全称是“Portable Operating System Interface”，旨在为 Unix-like 操作系统（如 Linux、FreeBSD、Mac OS X 等）提供一致的接口。由于该标准的广泛接受和实现，因此 Pthreads 库现在在许多不同的平台上都可用。</p>
<p>Pthreads 库的一个优点是它允许程序员创建轻量级线程（LWP），这些线程比进程更轻量级，因此在创建和销毁它们时所需的开销较小。此外，由于它是标准的 POSIX 接口，因此 Pthreads 库可在不同的操作系统上重用，从而提高了代码的可移植性。</p>
<p>pthread 库需要头文件：<code>pthread.h</code></p>
<p>gcc 编译链接参数：<code>lpthread</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc ./demo.c -o demo -lpthread</span><br></pre></td></tr></table></figure>

<h4 id="创建线程相关"><a href="# 创建线程相关" class="headerlink" title="创建线程相关"></a>创建线程相关 </h4><h5 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create"></a>pthread_create</h5><p><code>pthread_create</code> 是一个用于创建线程的函数，它的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pthread_t 类型的原型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="type">pthread_t</span>;</span><br></pre></td></tr></table></figure>

<p>该函数接收四个参数，分别是：</p>
<ol>
<li><p><code>thread</code>：一个指向线程标识符的指针，由函数创建并返回。</p>
</li>
<li><p><code>attr</code>：一个指向线程属性的指针，用于设置线程的属性。如果不需要设置属性，传入 <code>NULL</code> 即可。</p>
</li>
<li><p><code>start_routine</code>：线程执行的函数指针，该函数接受一个 <code>void *</code> 类型的参数，并返回一个 <code>void *</code> 类型的值。</p>
</li>
<li><p><code>arg</code>：传递给线程执行函数的参数，如果有多个参数，可以传递一个指向参数结构体的指针。</p>
</li>
</ol>
<p>当调用 <code>pthread_create</code> 函数时，它会创建一个新的线程，并将其标识符存储在 <code>thread</code> 指针中。新线程的执行将从 <code>start_routine</code> 函数开始，<code>arg</code>参数将作为 <code>start_routine</code> 的参数传递给它。</p>
<p>创建线程时，可以选择使用默认线程属性，也可以使用 <code>pthread_attr_t</code> 结构体来设置一些属性，例如线程的调度策略、栈大小、优先级等等。如果不需要设置属性，可以将 <code>attr</code> 参数设置为<code>NULL</code>。</p>
<p><code>pthread_create</code>函数成功时返回 0，否则返回一个错误码。如果返回非零错误码，可以使用 <code>perror</code> 函数或 <code>strerror</code> 函数打印出错误信息。</p>
<h5 id="pthread-self"><a href="#pthread-self" class="headerlink" title="pthread_self"></a>pthread_self</h5><p><code>pthread_self</code>函数返回调用它的线程的线程 ID：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<h5 id="pthread-equal"><a href="#pthread-equal" class="headerlink" title="pthread_equal"></a>pthread_equal</h5><p><code>pthread_equal</code>函数通过线程 ID 比较线程是否相等，如果两个线程相等，返回非 0 值，如果不相等，返回 0：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br></pre></td></tr></table></figure>

<h5 id="pthread-detach"><a href="#pthread-detach" class="headerlink" title="pthread_detach"></a>pthread_detach</h5><p><code>pthread_detach</code> 函数用于将指定的线程分离出去，所谓分离出去就是指 <strong> 主线程再不需要 </strong> 通过 <code>pthread_join</code> 等方式，等待该线程的结束并回收其线程控制块（TCB）的资源，<strong>被分离的线程结束后由操作系统负责其资源的回收</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>thread</code> 参数是要分离的线程的标识符，返回值为 0 表示成功，非 0 值表示出错。</p>
<p>需要注意的是，如果一个线程被分离了，就不能再对它调用 <code>pthread_join</code> 函数，否则会出错。因此，在调用 <code>pthread_detach</code> 函数之前，必须确保不会再调用 <code>pthread_join</code> 函数。</p>
<p>一般来说，主线程是要负责创建出来的子线程的资源回收工作的：</p>
<ul>
<li><p>如果主线程先于子线程退出，并且子线程没有设置为分离状态，那么子线程结束后其资源是无法得到回收的，会造成资源浪费和系统臃肿。</p>
</li>
<li><p>如果主线程先于子线程退出，但是子线程是分离状态，那么子线程退出的时候操作系统会自动回收其资源。</p>
</li>
</ul>
<p>分离线程并不是分离了之后，就跟主线程没有一点关系了。主线程退出了，分离线程还是一样退出，只是分离线程的资源是由系统回收的。</p>
<h4 id="终止线程相关"><a href="# 终止线程相关" class="headerlink" title="终止线程相关"></a>终止线程相关 </h4><p> 终止线程的三种方式：</p>
<ol>
<li><p>线程从启动例程返回，返回值就是线程的退出码；</p>
</li>
<li><p>线程可以被同一进程中的其他线程取消（通过<code>pthread_cancel()</code>）；</p>
</li>
<li><p>线程自身调用 <code>pthread_ exit()</code> 函数终止。</p>
</li>
</ol>
<h5 id="pthread-cancel"><a href="#pthread-cancel" class="headerlink" title="pthread_cancel"></a>pthread_cancel</h5><p><code>pthread_cancel</code> 函数是一个用于取消 POSIX 线程的函数。该函数向目标线程发送一个取消请求，如果该线程允许取消，则会在处理该请求时终止该线程的执行。</p>
<blockquote>
<p>线程可以设置为允许取消（默认情况下）或者禁止取消。如果线程允许取消，它将在收到取消请求后 <strong> 尽快取消</strong>，并执行一些清理工作；如果线程禁止取消，它将继续运行，直到完成其任务或者显式地调用 <code>pthread_exit</code> 函数。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure>

<p><code>pthread_cancel</code> 函数有以下两种用法：</p>
<ol>
<li><p><code>int pthread_cancel(pthread_t thread);</code> 此用法向线程 ID 为 <code>thread</code> 的线程发送取消请求。如果请求成功发送，则返回 0。如果线程 ID 无效或请求无法发送，则返回一个非零错误码。</p>
</li>
<li><p><code>void pthread_testcancel(void);</code> 此用法可以在线程执行期间调用，用于测试是否有取消请求已经发送给该线程。如果是，则在线程执行期间发生取消动作，该线程的执行将立即停止。</p>
</li>
</ol>
<p>需要注意的是，<code>pthread_cancel</code> 函数并不保证能够成功地取消目标线程的执行。当目标线程正在执行某些不可取消的操作（例如某些系统调用）时，取消请求可能会被暂时挂起，直到目标线程离开这些操作为止。另外，使用 <code>pthread_cancel</code> 函数需要注意线程同步问题，避免出现死锁等问题。</p>
<p>总的来说，<code>pthread_cancel</code> 函数可以用于线程的优雅终止，但是需要谨慎使用，避免出现意外的问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread is running...\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 在循环中调用 pthread_testcancel 函数检查是否有取消请求</span></span><br><span class="line">        pthread_testcancel();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread_id;</span><br><span class="line">    <span class="comment">// 创建一个线程并启动它</span></span><br><span class="line">    pthread_create(&amp;thread_id, <span class="literal">NULL</span>, &amp;thread_func, <span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 在主线程中调用 pthread_cancel 函数向子线程发送取消请求</span></span><br><span class="line">    pthread_cancel(thread_id);</span><br><span class="line">    <span class="comment">// 等待子线程结束</span></span><br><span class="line">    pthread_join(thread_id, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread has been canceled.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">root@fw:~/w26/ccodes# ./demo</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread has been canceled.</span><br><span class="line">root@fw:~/w26/ccodes#</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，首先创建了一个子线程并启动它，在子线程的循环中不断输出信息，同时在循环中调用 <code>pthread_testcancel</code> 函数检查是否有取消请求。在主线程中等待 5 秒钟后，调用 <code>pthread_cancel</code> 函数向子线程发送取消请求，然后等待子线程结束并输出一条信息表示子线程已经被成功取消。</p>
<p><strong>调用与不调用 <code>pthread_testcancel()</code> 的区别</strong>：</p>
<ol>
<li><p>调用 <code>pthread_testcancel</code> 函数可以让线程在循环或其他 <em> 可取消的操作中 </em> 主动检查是否有取消请求，并在检测到取消请求时 <em> 及时终止 </em> 线程的执行。这样可以增加线程的可靠性，<strong>确保线程在可以取消的时候及时响应取消请求</strong>。</p>
</li>
<li><p>如果不调用 <code>pthread_testcancel</code> 函数，线程可能会在某些不可取消的操作中被阻塞（例如在 <code>sleep</code> 等待时），无法及时响应取消请求，导致取消请求被暂时挂起。</p>
</li>
<li><p>因此，为了保证线程能够及时响应取消请求，通常建议在线程的循环或其他可取消的操作中调用 <code>pthread_testcancel</code> 函数，以便让线程在合适的时机进行取消。但是需要注意的是，在使用 <code>pthread_testcancel</code> 函数时，必须确保线程的同步操作是线程安全的，否则可能会导致程序出现不可预期的错误。</p>
</li>
<li><p>当然，在某些情况下，如果线程不会进入可取消的状态，或者线程在处理临界区时不能被取消，那么调用 <code>pthread_testcancel</code> 函数可能会导致线程被错误地取消。在这种情况下，可以通过设置线程的取消状态为 <code>PTHREAD_CANCEL_DISABLE</code> 来禁用取消操作，以避免意外的取消。</p>
</li>
</ol>
<p>总之，调用 <code>pthread_testcancel</code> 函数可以让线程更加及时地、可靠地响应取消请求，从而增加程序的安全性和稳定性，但需要注意线程同步的问题，以避免出现错误。</p>
<h5 id="pthread-exit"><a href="#pthread-exit" class="headerlink" title="pthread_exit"></a>pthread_exit</h5><p><code>pthread_exit()</code>是一个线程终止函数，它允许一个线程在它的 <strong> 任意位置退出</strong>。该函数接受一个参数，表示线程的返回值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure>

<p>调用 <code>pthread_exit()</code> 函数会立即终止当前线程的执行，并将传递的参数作为线程的返回值。如果该线程被其他线程等待，那么该返回值可以被其他线程获取。</p>
<blockquote>
<p>注意：指针 <code>retval</code> 指向的内容不能为函数中局部变量，因为一旦线程函数终止，它们将不再存在。</p>
</blockquote>
<p><code>pthread_exit()</code>函数通常在以下情况下使用：</p>
<ol>
<li><p>在线程执行完任务后，主动结束自己的执行。</p>
</li>
<li><p>当线程执行出现错误时，使用该函数退出线程。</p>
</li>
<li><p>在主线程中调用 <code>pthread_exit()</code> 函数来结束整个程序的执行。</p>
</li>
</ol>
<blockquote>
<p>注意：如果在主线程中调用了<code>pthread_exit(NULL)</code>，则主线程退出，而不是退出进程，因此如果子线程存在，会继续执行。</p>
<p>需要注意的是，当一个线程调用 <code>pthread_exit()</code> 函数后，该线程会 <strong> 立即终止，不会再执行任何其他操作 </strong>。因此，如果线程需要进行一些清理工作，比如释放内存、关闭文件等，就需要在调用<code>pthread_exit()</code> 函数之前完成这些操作。</p>
</blockquote>
<h4 id="等待线程结束"><a href="# 等待线程结束" class="headerlink" title="等待线程结束"></a>等待线程结束 </h4><h5 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join"></a>pthread_join</h5><p><code>pthread_join</code> 函数用于 <strong> 等待一个指定线程结束，并回收其占用的资源</strong>。它的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>thread</code>：要等待的线程的标识符，即线程创建时返回的 <code>pthread_t</code> 类型的值。该参数指定了需要等待的线程。</p>
</li>
<li><p><code>retval</code>：用于存储线程的返回值的指针。该参数是一个 <strong> 指向指针的指针，因为线程的返回值的类型可能是不确定的，可能是一个整型、浮点型或者指针等类型 </strong>。在<code>pthread_join</code> 函数返回时，线程的返回值将会被存储在 <code>retval</code> 所指向的内存空间中。</p>
</li>
</ol>
<p>需要注意的是，<code>retval</code>参数是可选的，如果不需要获取线程的返回值，可以将其设置为 <code>NULL</code>。另外，如果线程没有返回值，或者<strong> 在线程函数中没有显式地调用 <code>pthread_exit</code> 函数退出线程 </strong>，那么<code>retval</code> 参数将被忽略。</p>
<p>该函数会阻塞当前线程，直到指定的线程 <code>thread</code> 结束执行。具体来说，当我们调用 <code>pthread_join</code> 函数时，如果指定的线程 <code>thread</code> 还在运行中，当前线程就会被阻塞，等待该线程结束；如果线程 <code>thread</code> 已经结束了，那么 <code>pthread_join</code> 函数会立即返回，并将线程的返回值存储在 <code>retval</code> 中。此外，<code>pthread_join</code>函数会自动回收线程占用的资源，避免了资源泄露的问题。</p>
<p>以下是一个简单的示例代码，用于演示如何使用 <code>pthread_join</code> 函数等待线程结束并获取其返回值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *num = (<span class="type">int</span> *)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread is running, parameter is %d\n&quot;</span>, *num);</span><br><span class="line">    <span class="type">int</span> *res = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *res = (*num) * (*num);</span><br><span class="line">    pthread_exit((<span class="type">void</span> *)res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="type">int</span> parameter = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *result;</span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, thread_func, &amp;parameter);</span><br><span class="line">    pthread_join(thread, (<span class="type">void</span> **)&amp;result);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread returned: %d\n&quot;</span>, *result);</span><br><span class="line">    <span class="built_in">free</span>(result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果在线程函数中不调用 <code>pthread_exit</code> 函数退出线程，而是直接返回，那么该线程的返回值将是一个未定义的值，可能会导致程序出现不可预料的错误。因此，<strong>在编写多线程程序时，一定要记得在线程函数中调用 <code>pthread_exit</code> 函数退出线程</strong>。</p>
<h4 id="多线程示例"><a href="# 多线程示例" class="headerlink" title="多线程示例"></a>多线程示例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">my_thread_func</span><span class="params">(<span class="type">void</span> *pointer)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// sleep(1);</span></span><br><span class="line">        <span class="type">int</span> id = *(<span class="type">int</span> *)pointer;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread %d running, i=%d\r\n&quot;</span>, id, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(pointer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> threadId[<span class="number">5</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *arg = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*arg));</span><br><span class="line">        *arg = i;  <span class="comment">// 注意一</span></span><br><span class="line">        pthread_create(&amp;threadId[i], <span class="literal">NULL</span>, my_thread_func, (<span class="type">void</span> *)(arg));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(threadId[i], (<span class="type">void</span> **)(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread end\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于线程之间是异步执行的，因此在输出语句中的 <code>id</code> 值可能会和线程实际运行的顺序不一致，<strong>无法保证顺序执行</strong>。如果需要保证顺序执行，可以使用互斥锁来同步线程之间的执行顺序。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">root@fw:~/w26/ccodes# ./demo</span><br><span class="line">thread 0 running, k=0</span><br><span class="line">thread 2 running, k=0</span><br><span class="line">thread 2 running, k=1</span><br><span class="line">thread 0 running, k=1</span><br><span class="line">thread 1 running, k=0</span><br><span class="line">thread 1 running, k=1</span><br><span class="line">thread 2 running, k=2</span><br><span class="line">thread 1 running, k=2</span><br><span class="line">thread 3 running, k=0</span><br><span class="line">thread 3 running, k=1</span><br><span class="line">thread 3 running, k=2</span><br><span class="line">thread 4 running, k=0</span><br><span class="line">thread 4 running, k=1</span><br><span class="line">thread 4 running, k=2</span><br><span class="line">thread 0 running, k=2</span><br><span class="line">main thread end</span><br><span class="line">root@fw:~/w26/ccodes#</span><br></pre></td></tr></table></figure>

<p>对于注意一的解释：在 <code>main</code> 函数中循环创建 5 个线程时，每个线程的 <code>my_thread_func</code> 函数都被传递了指向 <code>i</code> 的指针，而 <code>i</code> 是一个 <em> 自动变量 </em>，其生命周期仅在循环内部。<strong> 由于线程的创建和调度是异步的</strong>，因此当线程实际运行时，<code>i</code> 可能已经被更新成另一个值，这会导致线程使用了错误的数据。</p>
<p>使用 <code>malloc</code> 申请临时变量来保存自动变量 <code>i</code> 的值，每个线程函数都被传递了一个指向分配的临时变量的指针，该变量保存了正确的 <code>i</code> 值。在线程函数中，使用 <code>*(int *)pointer</code> 获取 <code>i</code> 的值，并在使用完后释放该临时变量的内存空间。</p>
<blockquote>
<p>何为自动变量？</p>
</blockquote>
<p>在 C 和 C++ 等编程语言中，当在函数或代码块内部声明一个变量时，该变量默认为自动变量。自动变量具有以下特点：</p>
<ol>
<li><p>作用域：自动变量的作用域仅限于声明它的代码块内部。这意味着在声明的代码块外部是无法访问到该变量的。</p>
</li>
<li><p>存储方式：自动变量通常存储在栈（stack）上。当进入声明变量的代码块时，该变量会在栈上分配存储空间，当代码块执行完毕时，变量会自动释放所占用的栈空间。</p>
</li>
<li><p>初始化：自动变量在声明时可以选择是否进行初始化。如果未初始化，则其值是不确定的。</p>
</li>
</ol>
<p>自动变量适用于那些在局部范围内使用的临时数据和临时存储需求较小的变量。与全局变量和静态变量相比，自动变量具有更短的生命周期和更小的作用域，能够更有效地管理内存和避免命名冲突。</p>
<h4 id="多线程同步示例"><a href="# 多线程同步示例" class="headerlink" title="多线程同步示例"></a>多线程同步示例 </h4><p> 保证线程内顺序执行，可以使用互斥锁来同步线程之间的执行顺序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">my_thread_func</span><span class="params">(<span class="type">void</span> *pointer)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// sleep(1);</span></span><br><span class="line">        <span class="type">int</span> i = *(<span class="type">int</span> *)(pointer);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread %d running, k=%d\r\n&quot;</span>, i, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(pointer);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> threadId[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *arg = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*arg));</span><br><span class="line">        *arg = i;  <span class="comment">// 注意一</span></span><br><span class="line">        pthread_create(&amp;threadId[i], <span class="literal">NULL</span>, my_thread_func, (<span class="type">void</span> *)(arg));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(threadId[i], (<span class="type">void</span> **)(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread end\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">root@fw:~/w26/ccodes# ./demo</span><br><span class="line">thread 1 running, k=0</span><br><span class="line">thread 1 running, k=1</span><br><span class="line">thread 1 running, k=2</span><br><span class="line">thread 3 running, k=0</span><br><span class="line">thread 3 running, k=1</span><br><span class="line">thread 3 running, k=2</span><br><span class="line">thread 2 running, k=0</span><br><span class="line">thread 2 running, k=1</span><br><span class="line">thread 2 running, k=2</span><br><span class="line">thread 0 running, k=0</span><br><span class="line">thread 0 running, k=1</span><br><span class="line">thread 0 running, k=2</span><br><span class="line">thread 4 running, k=0</span><br><span class="line">thread 4 running, k=1</span><br><span class="line">thread 4 running, k=2</span><br><span class="line">main thread end</span><br><span class="line">root@fw:~/w26/ccodes#</span><br></pre></td></tr></table></figure>

<p>在修改后的代码中，我们使用 <code>pthread_mutex_t</code> 类型定义了一个互斥锁，并在 <code>main</code> 函数中初始化了它。在 <code>my_thread_func</code> 函数中，我们在循环前加锁（某一个线程获取了锁），循环结束后解锁（该线程释放了锁，此时其它线程可以获取锁了），以保证线程的顺序执行（先获取到锁的线程，会执行完锁之间的内容，不再会出现上面未加锁的示例中，执行到一半，便去执行其它线程的内容）。最后在 <code>main</code> 函数结束前销毁互斥锁。</p>
<hr>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>进程与线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 学习笔记</title>
    <url>/posts/230909171809.html</url>
    <content><![CDATA[<h2 id="1- 什么是 Docker？"><a href="#1- 什么是 Docker？" class="headerlink" title="1. 什么是 Docker？"></a>1. 什么是 Docker？</h2><p>Docker 是一个开源的容器化平台，用于构建、打包和部署应用程序。它允许开发人员将应用程序和它们的依赖项打包成一个轻量级、可移植的容器，然后在任何支持 Docker 的环境中运行。</p>
<h3 id="1-1-Docker 的核心概念"><a href="#1-1-Docker 的核心概念" class="headerlink" title="1.1 Docker 的核心概念"></a>1.1 Docker 的核心概念 </h3><p> 在深入学习 Docker 之前，了解以下几个核心概念是很重要的：</p>
<ul>
<li><p><strong>容器（Container）</strong>：一个 <strong> 独立 </strong> 运行的沙箱（sandboxed）应用程序实例，包含应用程序及其所有依赖项。容器是 Docker 的基本构建块，有以下特点：</p>
<ul>
<li><p>利用 <a href="https://medium.com/@saschagrunert/demystifying-containers-part-i-kernel-space-2c53d6979504">kernel namespaces and cgroups</a> 实现隔离 &#x2F; 独立。</p>
</li>
<li><p>是一个可运行的镜像的实例，可以使用 DockerAPI 或 CLI 创建、开始、停止、移动、删除一个容器。</p>
</li>
<li><p>可以运行在本地机器上、虚拟机上或者部署在云上。</p>
</li>
<li><p>可移植的（能运行在任何操作系统上）。</p>
</li>
<li><p>与其它容器隔离并运行自己的软件、二进制文件和配置。</p>
</li>
</ul>
</li>
<li><p><strong>镜像（Image）</strong>：一个只读的模板，用于创建容器。镜像包含了运行应用程序所需的一切，例如代码、运行时环境、库和依赖项。</p>
</li>
<li><p><strong>仓库（Repository）</strong>：用于存储和组织 Docker 镜像的地方。可以将仓库看作是镜像的集合。</p>
</li>
<li><p><strong>Dockerfile</strong>：一个文本文件，包含了一系列命令和指令，用于从头开始构建 Docker 镜像。</p>
</li>
</ul>
<span id="more"></span>

<h3 id="1-2-Dcoker-registry"><a href="#1-2-Dcoker-registry" class="headerlink" title="1.2 Dcoker registry"></a>1.2 Dcoker registry</h3><p>Docker Registry 是用于 <strong> 存储、管理和分发 Docker 镜像的中央仓库</strong>。它允许用户将自己创建的镜像上传到仓库，或者从仓库中拉取他人创建的镜像。在 Docker 中，默认使用 Docker 官方的公共注册服务器，称为 Docker Hub。此外，还可以在本地或私有云环境中搭建自己的 Docker Registry。</p>
<p>以下是 Docker Registry 的一些重要概念：</p>
<ol>
<li><p>镜像（Image）：Docker 镜像是一个包含了应用程序、运行时环境、库和依赖的只读模板。镜像是构建和运行容器的基础。在 Docker Registry 中，镜像被存储和管理。</p>
</li>
<li><p>仓库（Repository）：仓库是包含多个镜像的集合。仓库可以用于组织和管理镜像。每个镜像都有一个唯一的标签（tag），用于标识不同版本或变体的镜像。</p>
</li>
<li><p>注册服务器（Registry Server）：注册服务器是存储和分发镜像的服务器。Docker Hub 是 Docker 官方提供的公共注册服务器。除了 Docker Hub，还可以搭建私有的注册服务器，例如 Docker 官方提供的开源项目 Docker Registry 或第三方的解决方案。</p>
</li>
<li><p>仓库名称（Repository Name）：仓库名称用于唯一标识一个仓库。它由用户名（如果是私有仓库还包括域名）、斜杠和仓库名称组成，例如 <code>username/repository</code> 或<code>domain.com/username/repository</code>。</p>
</li>
<li><p>标签（Tag）：标签用于标识仓库中的镜像的不同版本或变体。通过标签，可以区分不同的镜像，并拉取特定的版本。</p>
</li>
</ol>
<p>常见的 Docker Registry 操作包括：</p>
<ul>
<li><p>拉取镜像（Pull Image）：从注册服务器上拉取镜像到本地，以供使用或进一步构建容器。</p>
</li>
<li><p>推送镜像（Push Image）：将本地创建的镜像推送到注册服务器，以便其他人可以访问和使用。</p>
</li>
<li><p>搜索镜像（Search Image）：在注册服务器上搜索和浏览可用的镜像，以找到感兴趣的镜像。</p>
</li>
<li><p>删除镜像（Delete Image）：从注册服务器上删除不再需要的镜像，释放存储空间。</p>
</li>
</ul>
<p>使用 Docker Registry，你可以方便地共享和分发镜像，构建自己的镜像仓库，并进行版本控制和管理。无论是使用公共注册服务器还是搭建私有的注册服务器，Docker Registry 都是 Docker 生态系统中重要的组成部分之一。</p>
<blockquote>
<p>什么叫分发镜像？<br>分发镜像是指将 Docker 镜像从一个地方复制到另一个地方，以便其他用户可以访问和使用该镜像。</p>
<p>分发镜像的过程一般包括以下步骤：1）Dockerfile 构建镜像；2）打标签；3）推送到 Registry；4）拉取镜像。</p>
<p>分发镜像的好处包括：1）共享性；2）可移植性；3）版本控制：使用标签来管理镜像的不同版本，可以轻松回退到先前的版本或升级到新的版本。</p>
</blockquote>
<h2 id="2-Docker 的安装和配置"><a href="#2-Docker 的安装和配置" class="headerlink" title="2. Docker 的安装和配置"></a>2. Docker 的安装和配置 </h2><h3 id="2-1- 安装 Docker"><a href="#2-1- 安装 Docker" class="headerlink" title="2.1 安装 Docker"></a>2.1 安装 Docker</h3><p> 首先，需要安装 Docker 引擎。以下是在常见操作系统上安装 Docker 的步骤：</p>
<p><strong>Ubuntu</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install docker.io</span></span><br></pre></td></tr></table></figure>

<p><strong>Windows</strong></p>
<ol>
<li>前往 <a href="https://www.docker.com/products/docker-desktop">Docker 官方网站</a> 下载 Docker Desktop。</li>
<li>双击安装包并按照指示完成安装。可能需要更新 WSL，<strong>需要把 Windows 的更新计划打开</strong>，否则可能无法更新 WSL。</li>
</ol>
<h3 id="2-2- 配置 Docker"><a href="#2-2- 配置 Docker" class="headerlink" title="2.2 配置 Docker"></a>2.2 配置 Docker</h3><p>安装完成后，你可能需要进行一些配置。例如，你可以设置 Docker 镜像加速器以加快下载速度。以下是一个示例：</p>
<ol>
<li>打开 Docker 配置文件：</li>
</ol>
<ul>
<li><strong>Ubuntu</strong>：<code>/etc/docker/daemon.json</code></li>
<li><strong>MacOS</strong> &#x2F; <strong>Windows</strong>：Docker Desktop 应用程序 &gt; Preferences &gt; Docker Engine</li>
</ul>
<ol start="2">
<li>如果文件不存在，创建它。然后，将以下内容添加到配置文件中：</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;https://your-mirror.example.com&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;insecure-registries&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>保存配置文件并重启 Docker 服务：</li>
</ol>
<ul>
<li><strong>Ubuntu</strong>：<ul>
<li><code>sudo systemctl daemon-reload</code></li>
<li><code>sudo systemctl restart docker</code></li>
</ul>
</li>
<li><strong>MacOS</strong> &#x2F; <strong>Windows</strong>：在 Docker Desktop 应用程序中点击重启按钮。</li>
</ul>
<h2 id="3- 使用 Docker"><a href="#3- 使用 Docker" class="headerlink" title="3. 使用 Docker"></a>3. 使用 Docker</h2><h3 id="3-1- 运行容器"><a href="#3-1- 运行容器" class="headerlink" title="3.1 运行容器"></a>3.1 运行容器 </h3><p> 要运行一个容器，首先需要一个 Docker 镜像。可以从 Docker 仓库中获取现有的镜像，或者自己创建一个。以下是一个运行基于 Ubuntu 的容器的示例：</p>
<ol>
<li>拉取 Ubuntu 镜像：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker pull ubuntu</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>运行容器：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -it ubuntu /bin/bash</span></span><br></pre></td></tr></table></figure>

<p>这将以交互式终端的方式在 Ubuntu 容器中运行一个 bash shell。你可以在容器中执行任意命令。</p>
<ol start="3">
<li>退出容器：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">exit</span></span></span><br></pre></td></tr></table></figure>

<h3 id="3-2- 构建自定义镜像"><a href="#3-2- 构建自定义镜像" class="headerlink" title="3.2 构建自定义镜像"></a>3.2 构建自定义镜像 </h3><p> 使用 Dockerfile 可以构建自定义的 Docker 镜像。以下是一个简单的示例：</p>
<ol>
<li><p>创建一个新目录，例如 <code>myapp</code>，并在其中创建一个名为<code>Dockerfile</code> 的文件。</p>
</li>
<li><p>在 <code>Dockerfile</code> 中添加以下内容：</p>
</li>
</ol>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用较小的基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 维护者信息</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=<span class="string">&quot;Your Name &lt;your.email@example.com&gt;&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Vim 编辑器</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get install -y vim &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get clean &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装所需的软件包, 将多个 RUN 指令合并为一个（减小 image 的体积）</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install --no-cache-dir --upgrade pip setuptools wheel &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    pip install --no-cache-dir \</span></span><br><span class="line"><span class="language-bash">    langchain==0.0.162 \</span></span><br><span class="line"><span class="language-bash">    openai \</span></span><br><span class="line"><span class="language-bash">    fastapi \</span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地项目文件复制到容器中</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./ /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> ENV_VARIABLE_NAME=value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;/app/src/main.py&quot;</span>, <span class="string">&quot;--extra-arg&quot;</span>, <span class="string">&quot;value&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>以上示例使用了 python 作为基础镜像，并在容器中安装了一些软件包，设置了工作目录，复制了本地文件，并设置了环境变量和默认运行命令。</p>
<ol start="3">
<li>在 <code>Dockerfile</code> 所在的目录中打开终端，并构建镜像：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker build -t aigc/plugins:v1.0.0 .</span></span><br></pre></td></tr></table></figure>

<p>这将使用 <code>Dockerfile</code> 创建一个名为 <code>aigc/plugins</code> 的镜像，版本号为<code>v1.0.0</code>。</p>
<ol start="4">
<li>运行容器：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --restart=always -d --name aigc_plugins -p 8385:8385 \</span></span><br><span class="line"><span class="language-bash">    -v /home/aigc/mount/plugins/data/store:/app/store \</span></span><br><span class="line"><span class="language-bash">    -v /home/aigc/mount/plugins/data/cfg:/app/cfg aigc/plugins:v1.0.0 python /app/src/main.py \</span></span><br><span class="line"><span class="language-bash">    --ip 0.0.0.0 --port 8385 --url http://0.0.0.0:8383/v1/completions</span></span><br></pre></td></tr></table></figure>

<p>现在你可以在自定义镜像的容器中运行你的应用程序。</p>
<ol start="5">
<li>进入容器：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> -it aigc_plugins bash</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>删除容器：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">rm</span> -f aigc_plugins</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">rm</span> -f &lt;container-id&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>查看容器运行的日志，并保存到文件中：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker logs -f aigc_plugins | <span class="built_in">tee</span> -a aigc_plugins_logs.txt</span></span><br></pre></td></tr></table></figure>

<ol start="8">
<li>打包保存镜像：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker save -o aigc_plugins.tar aigc/plugins:v1.0.0</span></span><br></pre></td></tr></table></figure>

<ol start="9">
<li>加载本地镜像包：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker load -i aigc_plugins.tar</span></span><br></pre></td></tr></table></figure>

<h2 id="4-Docker-Volumes 与 Mount"><a href="#4-Docker-Volumes 与 Mount" class="headerlink" title="4. Docker Volumes 与 Mount"></a>4. Docker Volumes 与 Mount</h2><p>Docker Volumes（卷）是 Docker 中用于 <strong> 持久化数据 </strong> 的一种机制，它允许将主机上的目录或文件与容器内的路径进行映射，从而实现数据在容器和主机之间的共享和持久化存储。</p>
<h3 id="4-1- 创建 -Volume"><a href="#4-1- 创建 -Volume" class="headerlink" title="4.1 创建 Volume"></a>4.1 创建 Volume</h3><p>使用 <code>docker volume create</code> 命令可以创建一个新的 Volume。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume create my-volume</span></span><br></pre></td></tr></table></figure>

<p>上述命令将创建一个名为 <code>my-volume</code> 的新 Volume。Docker 会在宿主机的默认 Volume 存储位置上创建一个目录，用于保存 Volume 的数据。</p>
<blockquote>
<p>Where is Docker storing my data when I use a volume?</p>
</blockquote>
<p>使用 <code>docker volume inspect</code> 命令查看 Volume 存储位置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume inspect my-volume</span></span><br></pre></td></tr></table></figure>

<p>接着，你将看到如下信息：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;CreatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021-06-01T16:18:36Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Labels&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Mountpoint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/volumes/my-volume/_data&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my-volume&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p>Mountpoint 是数据在磁盘上的实际位置。请注意，在大多数机器上，您需要具有根访问权限才能从主机访问此目录。但是，这就是它所在的位置。</p>
</blockquote>
<h3 id="4-2- 容器中使用 -Volume"><a href="#4-2- 容器中使用 -Volume" class="headerlink" title="4.2 容器中使用 Volume"></a>4.2 容器中使用 Volume</h3><p>在运行容器时，可以使用 <code>-v</code> 或 <code>--mount</code> 参数将 Volume 挂载到容器内的路径上。</p>
<h4 id="4-2-1-v 参数卷挂载"><a href="#4-2-1-v 参数卷挂载" class="headerlink" title="4.2.1 -v 参数卷挂载"></a>4.2.1 -v 参数卷挂载</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d -v my-volume:/path/in/container my-image</span></span><br></pre></td></tr></table></figure>

<p>上述命令将创建一个基于 <code>my-image</code> 镜像的容器，并将名为 <code>my-volume</code> 的 Volume 挂载到容器内的 <code>/path/in/container</code> 路径上。</p>
<h4 id="4-2-2-–mount 参数卷挂载"><a href="#4-2-2-–mount 参数卷挂载" class="headerlink" title="4.2.2 –mount 参数卷挂载"></a>4.2.2 –mount 参数卷挂载 </h4><p> 使用 <code>--mount</code> 参数可以更细粒度地配置容器中的 Volume 挂载。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d --mount <span class="built_in">type</span>=volume,<span class="built_in">source</span>=my-volume,target=/path/in/container my-image</span></span><br></pre></td></tr></table></figure>

<p>在上述命令中，我们使用了 <code>--mount</code> 参数来指定挂载的类型和配置。<code>type=volume</code> 表示挂载类型为 Volume，<code>source=my-volume</code> 指定了要挂载的 Volume 的名称为 <code>my-volume</code>，<code>target=/path/in/container</code> 指定了挂载到容器内的路径为 <code>/path/in/container</code>。</p>
<p>除了指定挂载类型、Volume 名称和路径外，<code>--mount</code> 参数还可以接受其他选项，例如读写权限、文件系统类型等。下面是一个更详细的示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d --mount <span class="built_in">type</span>=volume,<span class="built_in">source</span>=my-volume,target=/path/in/container,ro,volume-opt=option=value my-image</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们添加了一些额外的选项。<code>ro</code> 表示将 Volume 挂载为只读（read-only），<code>volume-opt=option=value</code> 表示指定了额外的 Volume 选项。你可以根据需要使用适当的选项来满足挂载的要求。</p>
<p>使用 <code>--mount</code> 参数进行 Volume 挂载可以提供更多的灵活性和配置选项，例如指定挂载类型、读写权限、Volume 选项等。这使得我们能够更好地控制容器与 Volume 之间的数据交互。</p>
<h3 id="4-3- 挂载主机目录作为 -Volume"><a href="#4-3- 挂载主机目录作为 -Volume" class="headerlink" title="4.3 挂载主机目录作为 Volume"></a>4.3 挂载主机目录作为 Volume</h3><p>除了使用命名 Volume，还可以直接将主机上的目录或文件挂载为 Volume，即 <strong> 绑定挂载（Bind mounts）</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d -v /path/on/host:/path/in/container my-image</span></span><br></pre></td></tr></table></figure>

<p>上述命令将主机上的 <code>/path/on/host</code> 目录挂载到容器内的 <code>/path/in/container</code> 路径上。</p>
<blockquote>
<p>绑定挂载（Bind mounts）允许将主机文件系统上的特定路径直接挂载到容器内的路径上。<br>卷挂载（Volume mounts）通过使用 Docker 卷 (Volume) 将容器内的路径与主机上的路径进行关联。</p>
</blockquote>
<h3 id="4-4- 查看 -Volume"><a href="#4-4- 查看 -Volume" class="headerlink" title="4.4 查看 Volume"></a>4.4 查看 Volume</h3><p>使用 <code>docker volume ls</code> 命令可以列出所有已创建的 Volumes。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume <span class="built_in">ls</span></span></span><br></pre></td></tr></table></figure>

<p>上述命令将显示所有已创建的 Volumes 的列表，包括它们的名称和所在的路径。</p>
<h3 id="4-5- 删除 -Volume"><a href="#4-5- 删除 -Volume" class="headerlink" title="4.5 删除 Volume"></a>4.5 删除 Volume</h3><p>要删除一个不再需要的 Volume，可以使用 <code>docker volume rm</code> 命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume <span class="built_in">rm</span> my-volume</span></span><br></pre></td></tr></table></figure>

<p>上述命令将删除名为 <code>my-volume</code> 的 Volume。请注意，只有在没有任何容器使用该 Volume 时，才能成功删除。</p>
<h3 id="4-6-Volume-Mounts-Vs-Bind-Mounts"><a href="#4-6-Volume-Mounts-Vs-Bind-Mounts" class="headerlink" title="4.6 Volume Mounts Vs Bind Mounts"></a>4.6 Volume Mounts Vs Bind Mounts</h3><h4 id="4-6-1-Volume-Mounts 的特性"><a href="#4-6-1-Volume-Mounts 的特性" class="headerlink" title="4.6.1 Volume Mounts 的特性"></a>4.6.1 Volume Mounts 的特性 </h4><p> 卷挂载通过使用 Docker 卷 (Volume) 将容器内的路径与主机上的路径进行关联。Docker 卷是一种特殊的目录，用于存储容器中的数据。卷挂载具有以下特点：</p>
<ul>
<li><p><strong>主机位置</strong>：Docker 选择卷的主机位置，通常在宿主机上的特定目录中。</p>
</li>
<li><p><strong>数据持久化</strong>：Volume 提供了一种持久化存储数据的方式。即使容器被删除或重新创建，Volume 中的数据仍然保持不变。</p>
</li>
<li><p><strong>容器间数据共享</strong>：多个容器可以共享同一个 Volume，使得它们可以轻松地共享数据。</p>
</li>
<li><p><strong>与主机文件系统交互</strong>：通过将主机上的目录挂载为 Volume，容器可以访问主机的文件系统，方便与容器之外的环境交互。</p>
</li>
<li><p><strong>备份和迁移</strong>：使用 Volumes 可以方便地备份和迁移容器的数据，通过备份或迁移 Volume，可以快速复制或迁移整个容器的数据。</p>
</li>
<li><p><strong>卷驱动程序支持</strong>：卷挂载支持使用不同的卷驱动程序，例如本地主机文件系统、网络存储或其他存储后端。</p>
</li>
</ul>
<h4 id="4-6-2-Bind-Mounts 的特性"><a href="#4-6-2-Bind-Mounts 的特性" class="headerlink" title="4.6.2 Bind Mounts 的特性"></a>4.6.2 Bind Mounts 的特性 </h4><p> 绑定挂载允许将主机文件系统上的特定路径直接挂载到容器内的路径上。绑定挂载具有以下特点：</p>
<ul>
<li><p><strong>主机位置</strong>：您可以自行选择要挂载的主机路径，它可以是任何主机上的目录或文件。</p>
</li>
<li><p><strong>与主机文件系统实时同步</strong>：容器中的更改会实时反映在绑定挂载的主机路径上，反之亦然。</p>
</li>
<li><p><strong>灵活性</strong>：绑定挂载允许容器与宿主机之间进行更紧密的交互，方便开发人员对文件进行编辑、调试或测试。</p>
</li>
<li><p><strong>支持权限和访问控制</strong>：绑定挂载可以继承主机文件系统的权限设置，以控制容器对文件的读写权限。</p>
</li>
</ul>
<h4 id="4-6-3- 选择使用卷挂载还是绑定挂载"><a href="#4-6-3- 选择使用卷挂载还是绑定挂载" class="headerlink" title="4.6.3 选择使用卷挂载还是绑定挂载"></a>4.6.3 选择使用卷挂载还是绑定挂载</h4><table>
<thead>
<tr>
<th></th>
<th>命名卷 (Named Volumes)</th>
<th>绑定挂载 (Bind Mounts)</th>
</tr>
</thead>
<tbody><tr>
<td>主机位置</td>
<td>由 Docker 选择</td>
<td>由您决定</td>
</tr>
<tr>
<td>挂载示例 (使用 <code>--mount</code>)</td>
<td><code>type=volume,src=my-volume,target=/usr/local/data</code></td>
<td><code>type=bind,src=/path/to/data,target=/usr/local/data</code></td>
</tr>
<tr>
<td>容器内容填充新卷</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>支持卷驱动程序</td>
<td>是</td>
<td>否</td>
</tr>
</tbody></table>
<p>在选择使用卷挂载还是绑定挂载时，可以根据具体需求和场景来进行决策：</p>
<ul>
<li><p>如果需要数据持久性、跨容器共享和卷驱动程序支持，则应选择卷挂载。</p>
</li>
<li><p>如果需要与主机文件系统实时同步、灵活的文件访问和交互，则应选择绑定挂载。</p>
</li>
</ul>
<p>在实际应用中，根据不同的需求，卷挂载和绑定挂载可以结合使用，以满足容器与主机之间数据共享和交互的需求。</p>
<blockquote>
<p>容器内容填充新卷是指在使用卷挂载（Volume Mounts）时，如果目标卷是新创建的并且为空（即没有初始数据），<strong>容器启动时会将容器内的内容填充到新创建的卷中</strong>。</p>
<p>这意味着，如果使用一个新的、空的卷挂载到容器内的路径上，并且容器内的路径中有预先存在的数据，那么在容器启动时，这些数据会被复制到新的卷中，以便卷中具有与容器内部相同的初始数据。这样可以确保在容器重新创建或迁移时，新创建的卷具有与原始容器相同的初始状态。</p>
</blockquote>
<h2 id="5-Container-networking"><a href="#5-Container-networking" class="headerlink" title="5. Container networking"></a>5. Container networking</h2><blockquote>
<p>请记住，默认情况下，容器是独立运行的，对同一台机器上的其他进程或容器一无所知。那么，如何让一个容器与另一个容器通信呢？答案是网络（network）。如果将两个容器放在同一个网络上，它们就可以相互通信。</p>
</blockquote>
<h3 id="5-1- 容器网络特性"><a href="#5-1- 容器网络特性" class="headerlink" title="5.1 容器网络特性"></a>5.1 容器网络特性 </h3><p> 容器网络是 Docker 中一个重要的概念，它允许 <strong> 在容器之间建立网络连接和通信</strong>。通过容器网络，可以实现容器间的数据传输、服务发现和跨主机的容器通信等功能。以下是容器网络的一些关键点和特性：</p>
<ul>
<li><p>** 网络命名空间 (Network Namespace)**：每个容器都有自己独立的网络命名空间，使得容器可以拥有自己的网络栈，包括网络接口、IP 地址和路由表等。这样可以实现容器之间的网络隔离，避免网络冲突和干扰。</p>
</li>
<li><p><strong>虚拟以太网桥 (Virtual Ethernet Bridge)<strong>：Docker 使用虚拟以太网桥来连接容器和宿主机的网络。每个宿主机上的 Docker 守护进程会创建一个名为 docker0 的桥接接口，</strong>通过该接口与容器的网络命名空间相连</strong>。</p>
</li>
<li><p>** 网络驱动程序 (Network Drivers)**：Docker 提供了多种网络驱动程序，用于实现不同的网络功能和配置选项。默认情况下，Docker 使用桥接网络驱动程序 (Bridge Network Driver)，但还支持其他驱动程序，如 Overlay、Host、Macvlan 等，以满足不同的网络需求。</p>
</li>
<li><p><strong>容器间通信 </strong>：容器可以通过使用网络连接和端口来实现相互通信。<strong> 可以使用容器的 IP 地址、端口号或容器名称来访问其他容器上的服务</strong>。容器网络还支持多个容器共享同一个网络端口的负载均衡和服务发现功能。</p>
</li>
<li><p><strong>跨主机容器通信</strong>：通过使用网络驱动程序中的 Overlay 网络模式，可以在多个主机上创建一个虚拟网络，使得不同主机上的容器可以直接通信。这为构建分布式应用和容器编排平台（如 Docker Swarm 和 Kubernetes）提供了基础。</p>
</li>
<li><p><strong>外部网络访问</strong>：容器可以通过端口映射 (Port Mapping) 的方式将容器内部的服务暴露给外部网络。通过将容器的特定端口映射到宿主机上的端口，可以使得外部网络能够访问容器中的应用程序或服务。</p>
</li>
</ul>
<p>容器网络是 Docker 中实现容器间通信和与外部网络交互的重要机制。通过灵活配置和管理容器网络，可以构建具有高可用性、可伸缩性和弹性的容器化应用程序。</p>
<h3 id="5-2- 容器网络实践命令"><a href="#5-2- 容器网络实践命令" class="headerlink" title="5.2 容器网络实践命令"></a>5.2 容器网络实践命令 </h3><h4 id="5-2-1- 创建自定义容器网络"><a href="#5-2-1- 创建自定义容器网络" class="headerlink" title="5.2.1 创建自定义容器网络"></a>5.2.1 创建自定义容器网络</h4><p> 使用 <code>docker network create</code> 命令可以创建自定义的 Docker 网络。例如，创建一个名为 <code>my-network</code> 的自定义网络：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker network create my-network</span></span><br></pre></td></tr></table></figure>

<p>这将在 Docker 中创建一个新的网络，供容器使用。</p>
<h4 id="5-2-2- 运行容器并连接到网络"><a href="#5-2-2- 运行容器并连接到网络" class="headerlink" title="5.2.2 运行容器并连接到网络"></a>5.2.2 运行容器并连接到网络 </h4><p> 在创建容器时，可以使用 <code>--network</code> 参数将容器连接到指定的网络。例如，将一个容器连接到 <code>my-network</code> 网络：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --network my-network my-image</span></span><br></pre></td></tr></table></figure>

<p>这将在启动容器时将其连接到 <code>my-network</code> 网络，使得容器可以与该网络中的其他容器进行通信。</p>
<h4 id="5-2-3- 查看容器网络信息"><a href="#5-2-3- 查看容器网络信息" class="headerlink" title="5.2.3 查看容器网络信息"></a>5.2.3 查看容器网络信息 </h4><p> 使用 <code>docker network inspect</code> 命令可以查看特定网络的详细信息。例如，查看名为 <code>my-network</code> 的网络信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker network inspect my-network</span></span><br></pre></td></tr></table></figure>

<p> 这将显示与 <code>my-network</code> 相关的网络配置和容器列表等信息。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my-network&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;000f5e28bfcafa18622593e04dba1bc70c1bc9480a055c0a0bb2b8ec13039138&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Created&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-06-01T22:51:27.366486209-04:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bridge&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;EnableIPv6&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;IPAM&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;default&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Config&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;Subnet&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.18.0.0/16&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;Gateway&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.18.0.1&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Internal&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Attachable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Ingress&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ConfigFrom&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Network&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ConfigOnly&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Containers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Labels&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h4 id="5-2-4- 容器间通信"><a href="#5-2-4- 容器间通信" class="headerlink" title="5.2.4 容器间通信"></a>5.2.4 容器间通信 </h4><p> 容器可以通过使用容器名称或 IP 地址进行互相通信。例如，通过容器名称进行通信：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --name container1 --network my-network my-image</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --name container2 --network my-network my-image</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>container1</code> 和 <code>container2</code> 这两个容器可以通过彼此的名称进行通信。例如，通过 <code>ping</code> 命令测试容器之间的连通性：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> container1 ping container2</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>container1</code> 容器使用 <code>ping container2</code> 的命令来 ping <code>container2</code> 容器。由于容器名称在容器网络中被解析为相应容器的 IP 地址，因此可以直接使用容器名称来实现容器间的通信。</p>
<blockquote>
<p>通过使用容器名称进行通信，可以减少对容器 IP 地址的依赖，提高容器间通信的灵活性。注意，容器名称必须在同一网络中才能相互解析，因此需要将容器都连接到同一个网络中。</p>
</blockquote>
<h4 id="5-2-5- 端口映射"><a href="#5-2-5- 端口映射" class="headerlink" title="5.2.5 端口映射"></a>5.2.5 端口映射 </h4><p> 使用 <code>-p</code> 参数可以将容器内的端口映射到宿主机上，以使得外部网络可以访问容器中的服务。例如，将容器的 8080 端口映射到宿主机的 80 端口：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -p 80:8080 my-image</span></span><br></pre></td></tr></table></figure>

<p>这将使得宿主机上的 80 端口转发到容器内的 8080 端口，从而允许外部网络通过宿主机的 80 端口访问容器中的服务。</p>
<p>以上是一些与容器网络相关的实践命令和示例。通过灵活运用这些命令，可以有效管理和配置容器网络，实现容器间的通信和与外部网络的交互。</p>
<h2 id="6-Docker-Compose"><a href="#6-Docker-Compose" class="headerlink" title="6. Docker Compose"></a>6. Docker Compose</h2><p>Docker Compose 是一个用于定义和运行 <strong> 多个容器 </strong> 的工具。它使用一个 <code>docker-compose.yml</code> 文件来配置应用程序的服务、网络和卷。以下是一个示例：</p>
<ol>
<li>创建一个名为 <code>docker-compose.yml</code> 的文件，并在其中定义服务：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.9&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">aigc/plugins:v1.0.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">aigc_plugins</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my_network</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">python</span> <span class="string">/app/src/main.py</span> </span><br><span class="line">        <span class="string">--ip</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> </span><br><span class="line">        <span class="string">--port</span> <span class="number">8385</span> </span><br><span class="line">        <span class="string">--url</span> <span class="string">http://0.0.0.0:8383/v1/completions</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8385</span><span class="string">:8385</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/aigc/mount/plugins/data/store:/app/store</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/aigc/mount/plugins/data/cfg:/app/cfg</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">cpus:</span> <span class="string">&quot;0.5&quot;</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">1024M</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">my_network:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">plugins_net</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure>

<p>以上示例定义了一个名为 <code>plugins</code> 的服务，使用当前目录中的 <code>Dockerfile</code> 构建镜像。它将主机的 <code>8385</code> 端口映射到容器的 <code>8385</code> 端口，并将本地的 <code>./</code> 目录挂载到容器的 <code>/app</code> 目录，还设置了一个环境变量。</p>
<ol start="2">
<li>在包含 <code>docker-compose.yml</code> 文件的目录中打开终端，并运行服务：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker-compose up</span></span><br></pre></td></tr></table></figure>

<p>Docker Compose 将自动构建镜像并运行服务。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之字典树</title>
    <url>/posts/230925185057.html</url>
    <content><![CDATA[<h2 id="什么是字典树"><a href="# 什么是字典树" class="headerlink" title="什么是字典树"></a>什么是字典树 </h2><p> 字典树，是一种 <strong> 以空间换时间 </strong> 的数据结构，又称 Trie 树、前缀树，是一种树形结构（字典树是一种数据结构），典型应用是统计、排序、和保存大量字符串（但不仅限于字符串）。所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</p>
<span id="more"></span>

<p><img src="/images/data-structure/trie-demo.png" alt="字典树示意图"></p>
<blockquote>
<p>可能大部分情况你很难直观或者有接触的体验，可能对前缀这个玩意没啥概念，可能做题遇到前缀问题也是暴力匹配蒙混过关，<strong>如果字符串比较少使用哈希表等结构可能也能蒙混过关，但如果字符串比较长、相同前缀较多，那么使用字典树可以大大减少内存的使用和效率 </strong>。<br> 一个字典树的应用场景：在 Google 搜索框输入部分单词下面会有一些神关联的搜索内容，你有时候都很神奇是怎么做到的，这其实就是字典树的一个思想。</p>
</blockquote>
<h2 id="字典树的性质"><a href="# 字典树的性质" class="headerlink" title="字典树的性质"></a>字典树的性质 </h2><p> 字典树是一种高效的数据结构，用于存储和快速检索字符串集合。它具有以下性质：</p>
<ol>
<li>字典树的 <strong> 根节点不包含任何字符</strong>，每个节点都代表一个字符，从根节点到叶节点的路径组成一个字符串。</li>
<li>每个节点可以包含 <strong> 多个子节点</strong>，每个子节点代表一个字符，节点之间的连接表示字符之间的关系。</li>
<li>每个节点的子节点通过不同的字符来标识，不同节点之间的路径上的字符不会重复。</li>
<li>字典树中的每个节点都可以 <strong> 存储一个附加值</strong>，用于表示该节点所代表的字符串的一些信息。</li>
<li>字典树可以 <strong> 高效地插入和查找字符串</strong>。插入操作将一个字符串的字符逐个添加到字典树中，查找操作根据给定的前缀或完整字符串，在字典树中检索相应的字符串。</li>
<li>字典树可以用于 <strong> 前缀匹配</strong>，例如，可以快速找到所有具有相同前缀的字符串。</li>
<li>字典树的 <strong> 空间复杂度相对较高</strong>，因为它需要为每个字符创建一个节点，但它可以通过压缩节点来减少空间占用。</li>
</ol>
<h2 id="设计实现字典树"><a href="# 设计实现字典树" class="headerlink" title="设计实现字典树"></a>设计实现字典树 </h2><p> 上面已经介绍了什么是字典树，那么我们开始设计一个字典树吧！</p>
<p>对于字典树，可能不同的场景或者需求设计上有一些细致的区别，但整体来说一般的字典树有创建、插入、查询（指定字符串）、查询（指定前缀）操作。</p>
<p>以 <a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">LeetCode 实现字典树 </a> 为例，实现字符集是 26 个英文小写字母的字典树的创建、插入、查询操作。</p>
<ul>
<li><code>trieCreate()</code> 初始化字典树对象。</li>
<li><code>void trieInsert(Trie *obj, char *word)</code> 向字典树中插入字符串<code>word</code>。</li>
<li><code>bool trieSearch(Trie *obj, char *word)</code> 搜索字符串 <code>word</code> 是否在字典树中。</li>
<li><code>bool trieStartsWith(Trie *obj, char *prefix)</code> 搜索字符串的前缀 <code>prefix</code> 是否在字典树中。</li>
</ul>
<h3 id="定义字典树类"><a href="# 定义字典树类" class="headerlink" title="定义字典树类"></a>定义字典树类 </h3><p> 字典树中的每一个节点，都是一个 <code>Trie</code> 类，而这个节点标识的字符可以是字符集中的任意一个字符。简单地，可以使用一个 <code>Trie</code> 类型数组（长度为字符集大小）来标识所有子节点。同时，为了表示该节点是否是某一个字符串的结束字符，可以添加一个布尔类型的结束标记 <code>isEnd</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUMS (26)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> *<span class="title">children</span>[<span class="title">NUMS</span>];</span>  <span class="comment">// 子节点指针数组，用于存储子节点的指针</span></span><br><span class="line">    <span class="type">bool</span> isEnd;  <span class="comment">// 表示当前节点是否为一个单词的结束节点</span></span><br><span class="line">    <span class="type">char</span> padding[<span class="number">7</span>];  <span class="comment">// 用于字节对齐的占位</span></span><br><span class="line">&#125; Trie;</span><br></pre></td></tr></table></figure>

<h3 id="字典树创建（初始化）"><a href="# 字典树创建（初始化）" class="headerlink" title="字典树创建（初始化）"></a>字典树创建（初始化）</h3><p>字典树有一个根节点，且字典树的根节点不包含任何字符。所以，我们需要初始化一个 <code>Trie</code> 类，并置空所有的子节点地址，以表示根节点不包含任何字符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Trie* <span class="title function_">trieCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    Trie *node = (Trie *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Trie));</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to create a trie node\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;sizeof(Trie) = %d\n&quot;, sizeof(Trie));  // x64, 216</span></span><br><span class="line">    <span class="built_in">memset</span>(node-&gt;children, <span class="number">0</span>, <span class="keyword">sizeof</span>(Trie));</span><br><span class="line">    node-&gt;isEnd = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用 <code>trieCreate()</code> 函数创建了节点 <code>node</code>，它不包含任何字符。</p>
<h3 id="字典树插入字符串"><a href="# 字典树插入字符串" class="headerlink" title="字典树插入字符串"></a>字典树插入字符串 </h3><p> 插入字符串的过程是逐个字符地搜索并检查它们是否存在于字典树中。如果某个字符不存在，则需要在上一个字符对应的节点上创建一个新的子节点，并将该节点指向新的字符（新的节点）。这样，就能够正确地构建出整个字符串在字典树中的路径。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trieInsert</span><span class="params">(Trie *obj, <span class="type">char</span> *word)</span> &#123;</span><br><span class="line">    Trie* curr = obj;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; word[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> index = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;children[index] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Trie* child = trieCreate();</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;failed to create a new trie\r\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr-&gt;children[index] = child;</span><br><span class="line">            curr-&gt;children[index]-&gt;isEnd = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将当前节点更新为新节点</span></span><br><span class="line">        curr = curr-&gt;children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将最后一个字符所在的节点标记为字符串的结尾</span></span><br><span class="line">    curr-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从根节点开始遍历字符串的每一个字符，然后根据字符计算出在子节点数组中的索引位置：</p>
<ul>
<li>如果该位置为空，则创建一个新的节点，并将该位置指向新节点；</li>
<li>然后，<strong>将当前节点更新为新节点</strong>，继续下一个字符的判断；</li>
<li>最后，将最后一个字符所在的节点标记为字符串的结尾，表示该字符串已经插入到字典树中。</li>
</ul>
<h3 id="字典树查询字符串"><a href="# 字典树查询字符串" class="headerlink" title="字典树查询字符串"></a>字典树查询字符串 </h3><p> 查询字符串的过程是在字典树已经建立好的情况下进行的。类似于插入过程，也是逐个字符地搜索并检查它们是否存在于字典树中（但不需要创建新的子节点）。如果在查询的过程中发现某个节点为空（未被初始化），则说明该字符串在字典树中不存在。如果成功遍历到最后一个字符所对应的节点，并且该节点标记为结束字符，则表明该字符串在字典树中存在；反之，如果最后一个字符对应的节点不是结束字符，则表明该字符串在字典树中不存在。所以 <strong> 在查询过程中，我们需要注意判断节点是否为空以及最后一个字符对应节点的结束字符标记</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">trieSearch</span><span class="params">(Trie *obj, <span class="type">char</span> *word)</span> &#123;</span><br><span class="line">    Trie* curr = obj;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; word[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> index = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;children[index] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr-&gt;isEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从根节点开始遍历字符串的每一个字符：</p>
<ul>
<li>首先，根据字符计算出在子节点数组中的索引位置：<ul>
<li>如果对应位置的子节点为空，则表示字典树中没有该字符串；</li>
<li>如果对应位置的子节点非空，则将当前节点更新为新节点，继续后续字符的判断；</li>
</ul>
</li>
<li>最后，根据结束字符的状态，返回字符串是否存在。</li>
</ul>
<h3 id="字典树前缀查询"><a href="# 字典树前缀查询" class="headerlink" title="字典树前缀查询"></a>字典树前缀查询 </h3><p> 前缀查询的过程也是在字典树已经建立好的情况下进行的。与查询字符串的过程类似，我们仍然是逐个字符地搜索并检查它们是否存在于字典树中。不同之处在于，前缀查询不需要判断前缀字符串的最后一个字符是否是结束字符，只要能成功遍历到最后一个字符，就可以确认该前缀字符串存在于字典树中。</p>
<blockquote>
<p>因为字典树的特点是每个节点都存储了字符集中的每个字符的子节点，所以只要前缀字符串中的每个字符都在字典树中存在对应的子节点，就可以确定该前缀字符串存在于字典树中。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">trieStartsWith</span><span class="params">(Trie *obj, <span class="type">char</span> *prefix)</span> &#123;</span><br><span class="line">    Trie* curr = obj;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; prefix[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> index = prefix[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;children[index] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字典树释放"><a href="# 字典树释放" class="headerlink" title="字典树释放"></a>字典树释放 </h3><p> 字典树释放的过程需要释放 <strong> 每个 </strong> 节点的 <strong> 所有子节点 </strong> 的空间。如果某个节点的子节点不为空，则需要继续深入该子节点，释放它的子节点的空间，直到最底层的叶子节点。然后再回溯到上一层节点，继续释放它的其他子节点，直到所有节点的空间都被释放完毕。所以字典树的释放过程是一个递归地释放每个节点的所有子节点的过程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trieFree</span><span class="params">(Trie *obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUMS; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj-&gt;children[i]) &#123;</span><br><span class="line">            trieFree(obj-&gt;children[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完整字典树代码"><a href="# 完整字典树代码" class="headerlink" title="完整字典树代码"></a>完整字典树代码 </h3><p> 上面的代码汇总在一起就是完整的字典树的最基础的版本了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUMS (26)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> *<span class="title">children</span>[<span class="title">NUMS</span>];</span>  <span class="comment">// 子节点指针数组，用于存储子节点的指针</span></span><br><span class="line">    <span class="type">bool</span> isEnd;  <span class="comment">// 表示当前节点是否为一个单词的结束节点</span></span><br><span class="line">    <span class="type">char</span> padding[<span class="number">7</span>];  <span class="comment">// 用于字节对齐的占位</span></span><br><span class="line">&#125; Trie;</span><br><span class="line"></span><br><span class="line">Trie* <span class="title function_">trieCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    Trie *node = (Trie *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Trie));</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to create a trie node\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;sizeof(Trie) = %d\n&quot;, sizeof(Trie));  // x64, 216</span></span><br><span class="line">    <span class="built_in">memset</span>(node-&gt;children, <span class="number">0</span>, <span class="keyword">sizeof</span>(Trie));</span><br><span class="line">    node-&gt;isEnd = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trieInsert</span><span class="params">(Trie *obj, <span class="type">char</span> *word)</span> &#123;</span><br><span class="line">    Trie* curr = obj;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; word[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> index = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;children[index] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Trie* child = trieCreate();</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;failed to create a new trie\r\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr-&gt;children[index] = child;</span><br><span class="line">            curr-&gt;children[index]-&gt;isEnd = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    curr-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">trieSearch</span><span class="params">(Trie *obj, <span class="type">char</span> *word)</span> &#123;</span><br><span class="line">    Trie* curr = obj;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; word[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> index = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;children[index] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr-&gt;isEnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">trieStartsWith</span><span class="params">(Trie *obj, <span class="type">char</span> *prefix)</span> &#123;</span><br><span class="line">    Trie* curr = obj;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; prefix[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> index = prefix[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;children[index] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trieFree</span><span class="params">(Trie *obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUMS; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj-&gt;children[i]) &#123;</span><br><span class="line">            trieFree(obj-&gt;children[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    Trie *root = trieCreate();</span><br><span class="line"></span><br><span class="line">    trieInsert(root, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line">    trieInsert(root, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search apple: %s\n&quot;</span>, trieSearch(root, <span class="string">&quot;apple&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search banana: %s\n&quot;</span>, trieSearch(root, <span class="string">&quot;banana&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search car: %s\n&quot;</span>, trieSearch(root, <span class="string">&quot;car&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search prefix bana: %s\n&quot;</span>, trieStartsWith(root, <span class="string">&quot;bana&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    trieFree(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度"><a href="# 复杂度" class="headerlink" title="复杂度"></a>复杂度 </h3><p> 时间复杂度：初始化为 $O(1)$，其余操作为 $O(|S|)$，其中 $|S|$ 是每次插入或查询的字符串的长度。</p>
<p>空间复杂度：$O(|T| \times \Sigma)$，其中 $|T|$ 为所有插入字符串的长度之和，$\Sigma$ 为字符集的大小。</p>
<h2 id="为什么根节点不包含任何字符"><a href="# 为什么根节点不包含任何字符" class="headerlink" title="为什么根节点不包含任何字符"></a>为什么根节点不包含任何字符 </h2><p> 字典树的根节点不包含任何字符是为了保持数据结构的一致性和简洁性。每个节点代表一个字符，根节点是整个字典树的起始点，它并不代表具体的字符。</p>
<ul>
<li>如果根节点包含一个字符，那么在插入和搜索操作时就需要额外的处理逻辑。例如，在搜索一个字符串时，需要先判断根节点的字符是否匹配，然后再进入下一层的子节点进行匹配。这样的处理逻辑会增加代码的复杂性。</li>
<li>而将根节点作为一个特殊的节点，不包含任何字符，可以简化操作。在搜索一个字符串时，直接从根节点开始匹配 <strong> 下一层的子节点</strong>（<code>node-&gt;children[x]</code>）即可，不需要额外的判断逻辑。这样的设计使得字典树的实现更加简单和统一。</li>
</ul>
<h2 id="为什么字典树空间复杂度相对较高"><a href="# 为什么字典树空间复杂度相对较高" class="headerlink" title="为什么字典树空间复杂度相对较高"></a>为什么字典树空间复杂度相对较高 </h2><p> 字典树是一种以空间换时间的数据结构（空间复杂度相对较高）。这是因为 <strong> 它需要存储每个节点的子节点指针 </strong>，具体来说，字典树的空间复杂度与字典树中存储的字符串数量和字符串的平均长度相关。<strong> 每个节点都需要存储一个指向下一个字符节点的指针</strong>，而每个字符串的字符数量会决定树的深度。因此，当字典树中包含大量的字符串或者字符串的平均长度较长时，字典树的空间复杂度就相对较高。</p>
<h2 id="哈希表实现的字典树"><a href="# 哈希表实现的字典树" class="headerlink" title="哈希表实现的字典树"></a>哈希表实现的字典树 </h2><p> 字典树基础班很容易，但很可能会出现一些延伸。</p>
<p>对于上面是 26 个字符的，我们很容易用 ASCII 找到对应索引，如果字符可能性比较多，用数组可能浪费的空间比较大，那我们也可以用哈希表实现字典树。使用哈希表替代数组，其实逻辑是一样的，只需要判断时候用哈希表判断是否存在对应的 key 即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uthash/src/uthash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    +-----------------------+</span></span><br><span class="line"><span class="comment">    |         Trie          |</span></span><br><span class="line"><span class="comment">    +-----------------------+</span></span><br><span class="line"><span class="comment">    |   ch                  |</span></span><br><span class="line"><span class="comment">    |   isEnd               |      +-----------------------+</span></span><br><span class="line"><span class="comment">    |   children            | ---&gt; |         Trie          |</span></span><br><span class="line"><span class="comment">    |   hh                  |      +-----------------------+</span></span><br><span class="line"><span class="comment">    +-----------------------+</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> *<span class="title">children</span>;</span></span><br><span class="line">    UT_hash_handle hh;</span><br><span class="line">&#125; Trie;</span><br><span class="line"></span><br><span class="line">Trie* <span class="title function_">trieCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    Trie *node = (Trie *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Trie));</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to create a trie node\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;ch = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    node-&gt;isEnd = <span class="literal">false</span>;</span><br><span class="line">    node-&gt;children = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trieInsert</span><span class="params">(Trie *root, <span class="type">char</span> *word)</span> &#123;</span><br><span class="line">    Trie *curr = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; word[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        Trie *child = <span class="literal">NULL</span>;</span><br><span class="line">        HASH_FIND(hh, curr-&gt;children, &amp;word[i], <span class="keyword">sizeof</span>(<span class="type">char</span>), child);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            child = trieCreate();</span><br><span class="line">            child-&gt;ch = word[i];</span><br><span class="line">            HASH_ADD(hh, curr-&gt;children, ch, <span class="keyword">sizeof</span>(<span class="type">char</span>), child);</span><br><span class="line">        &#125;</span><br><span class="line">        curr = child;</span><br><span class="line">    &#125;</span><br><span class="line">    curr-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">trieSearch</span><span class="params">(Trie *root, <span class="type">char</span> *word)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trie *curr = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; word[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        Trie *child = <span class="literal">NULL</span>;</span><br><span class="line">        HASH_FIND(hh, curr-&gt;children, &amp;word[i], <span class="keyword">sizeof</span>(<span class="type">char</span>), child);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr-&gt;isEnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">trieStartsWith</span><span class="params">(Trie *root, <span class="type">char</span> *prefix)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trie *curr = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; prefix[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        Trie *child = <span class="literal">NULL</span>;</span><br><span class="line">        HASH_FIND(hh, curr-&gt;children, &amp;prefix[i], <span class="keyword">sizeof</span>(<span class="type">char</span>), child);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trieFree</span><span class="params">(Trie *root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Trie *curr, *tmp;</span><br><span class="line">    HASH_ITER(hh, root-&gt;children, curr, tmp) &#123;</span><br><span class="line">        trieFree(curr-&gt;children);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    Trie *root = trieCreate();</span><br><span class="line"></span><br><span class="line">    trieInsert(root, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line">    trieInsert(root, <span class="string">&quot;+861**01[]&#x27;;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search apple: %s\n&quot;</span>, trieSearch(root, <span class="string">&quot;apple&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search +861**01[]&#x27;;/: %s\n&quot;</span>, trieSearch(root, <span class="string">&quot;+861**01[]&#x27;;/&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search car: %s\n&quot;</span>, trieSearch(root, <span class="string">&quot;car&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search prefix app: %s\n&quot;</span>, trieStartsWith(root, <span class="string">&quot;app&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    trieFree(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面为程序运行的结果。可以看到，使用哈希表实现字典树，可以处理的字符种类不再是仅限于英文字母。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Search apple: Found</span><br><span class="line">Search +861**01[]&#x27;;/: Found</span><br><span class="line">Search car: Not Found</span><br><span class="line">Search prefix app: Found</span><br></pre></td></tr></table></figure>

<p>关于 <code>HASH_FIND</code>、<code>HASH_ADD</code> 和 <code>HASH_ITER</code> 的使用可以看 <a href="https://troydhanson.github.io/uthash/userguide.html#_general_macros"> 这里</a>。</p>
<blockquote>
<p>参考连接：<a href="https://segmentfault.com/a/1190000040801084">https://segmentfault.com/a/1190000040801084</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>字典树</category>
      </categories>
      <tags>
        <tag>字典树</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
</search>
