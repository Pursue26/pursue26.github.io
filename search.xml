<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C 语言之 const 关键字</title>
    <url>/posts/230913200729.html</url>
    <content><![CDATA[<p>宏定义 <code>#define</code> 和 <code>const</code> 关键字在 C 语言中有不同的用途：</p>
<ol>
<li><p><code>#define</code> 用于定义宏常量，它在编译前进行简单的文本替换，没有类型检查和作用域限制。宏常量的值可以是任意的表达式，包括函数调用和运算符操作，但容易导致代码的可读性和可维护性降低。</p>
</li>
<li><p><code>const</code> 关键字用于定义常量变量，具有类型检查和作用域限制的特性。常量变量的值在定义后不能被修改，提高了代码的可读性和可维护性。常量变量的作用域仅限于定义它的代码块内，其他代码块无法访问该常量。</p>
</li>
<li><p><code>const</code> 关键字还可以用于定义指向常量的指针、常量指针以及指向常量的常量指针。这些用法可以在编译阶段进行类型检查，避免了在运行时可能出现的错误。</p>
</li>
<li><p>编译器通常不会为 <em> 普通的</em> <code>const</code> 常量分配存储空间，而是将它们保存在符号表中，成为编译期间的常量。这样可以避免存储和读内存的操作，提高程序的执行效率。</p>
</li>
</ol>
<p>综上所述，虽然 <code>#define</code> 可以用于定义常量，但 <code>const</code> 关键字更加推荐，因为它提供了类型检查和作用域限制，提高了代码的可读性和可维护性，同时能够进行编译期间的优化。</p>
<span id="more"></span>

<h2 id="修饰常量变量（Constant-Variables）"><a href="# 修饰常量变量（Constant-Variables）" class="headerlink" title="修饰常量变量（Constant Variables）"></a>修饰常量变量（Constant Variables）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> var = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> var = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>这两种写法是等价的，都表示变量 <code>n</code> 的值不能被修改了。需要注意的是，用 <code>const</code> 修饰变量时，一定要给变量初始化，否则后续就不能赋值了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C program to demonstrate that constant variables can not be modified</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> var = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compilation error: assignment of read-only variable &#x27;var&#x27;</span></span><br><span class="line">    var = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修饰常量字符串"><a href="# 修饰常量字符串" class="headerlink" title="修饰常量字符串"></a>修饰常量字符串</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>字符指针指向的字符串是不能修改的 </strong>：在 C 语言中，字符串常量是以<strong> 只读方式 </strong> 存储的，编译器会将其 <strong> 存储在只读的数据段 </strong> 中。而使用 <code>const</code> 关键字修饰的指针变量，会告诉编译器不允许通过该指针修改指向的数据。</p>
<p>如果没有 <code>const</code> 的修饰，我们可能会在后面有意无意的写 <code>str[0]=&#39;x&#39;</code> 这样的语句，这样会导致对只读内存区域的赋值，然后程序会立刻异常终止。但是，有了 <code>const</code>，这个错误就能在程序被编译的时候被检查出来，这就是 <code>const</code> 的好处，让逻辑错误在编译期被发现。</p>
<h2 id="指针常量（Pointer-to-Constant）"><a href="# 指针常量（Pointer-to-Constant）" class="headerlink" title="指针常量（Pointer to Constant）"></a>指针常量（Pointer to Constant）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* ptr;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *ptr;</span><br></pre></td></tr></table></figure>

<p>这两种写法是等价的。指针常量可以更改指针 <code>ptr</code> 的地址，以指向任何其他同类型的变量，但不能更改指针 <code>ptr</code> 指向的对象的值。指针常量中的指针被存储在读写区域（read-write area），在本例中为堆栈，所指向的对象可能位于只读区域或读写区域。</p>
<blockquote>
<p>简言之：指针（的地址）可变；指针地址不变的前提下，其指向的内容不可变。</p>
</blockquote>
<p>变量 <code>i</code> 是变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C program to demonstrate that the pointer to point to any other integer variable, </span></span><br><span class="line"><span class="comment">// but the value of the object (entity) pointed can not be changed</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">/* ptr is pointer to constant */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* ptr = &amp;i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line">    <span class="comment">/* error: object pointed cannot be modified using the pointer ptr */</span></span><br><span class="line">    <span class="comment">/* error: assignment of read-only location &#x27;*ptr&#x27; */</span></span><br><span class="line">    *ptr = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    ptr = &amp;j; <span class="comment">/* valid */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量 <code>i</code> 本身就是常量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C program to demonstrate that the pointer to point to any other integer variable, </span></span><br><span class="line"><span class="comment">// but the value of the object (entity) pointed can not be changed</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* i is stored in read only area*/</span></span><br><span class="line">    <span class="type">int</span> <span class="type">const</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* pointer to integer constant. Here i</span></span><br><span class="line"><span class="comment">    is of type &quot;const int&quot;, and &amp;i is of</span></span><br><span class="line"><span class="comment">    type &quot;const int *&quot;. And ptr is of type</span></span><br><span class="line"><span class="comment">    &quot;const int *&quot;, types are matching no issue */</span></span><br><span class="line">    <span class="type">int</span> <span class="type">const</span>* ptr = &amp;i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* error: assignment of read-only location &#x27;*ptr&#x27; */</span></span><br><span class="line">    *ptr = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* valid. We call it up qualification. In</span></span><br><span class="line"><span class="comment">    C/C++, the type of &quot;int *&quot; is allowed to up</span></span><br><span class="line"><span class="comment">    qualify to the type &quot;const int *&quot;. The type of</span></span><br><span class="line"><span class="comment">    &amp;j is &quot;int *&quot; and is implicitly up qualified by</span></span><br><span class="line"><span class="comment">    the compiler to &quot;const int *&quot; */</span></span><br><span class="line"></span><br><span class="line">    ptr = &amp;j;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 C++ 中，不允许进行下限定（down qualification）操作，而在 C 中进行此操作可能会导致警告。下限定是指将已经限定了类型的变量赋值给没有限定类型的变量的情况。</p>
<p>在 C++ 和 C 中，上限定（up qualification）是允许的，不会引发警告或错误。上限定是指将没有限定类型的变量赋值给已经限定了类型的变量的情况。这意味着可以将一个没有限定类型的变量赋值给一个已经限定了类型的变量，而编译器会自动进行类型转换。上限定操作可以用于提升变量的类型精度或实现类型转换。例如，将一个整数赋值给一个浮点数变量，编译器会自动将整数转换为浮点数类型。</p>
</blockquote>
<p>下限定操作示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C program to demonstrate the down qualification</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="type">const</span> j = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ptr is pointing an integer object */</span></span><br><span class="line">    <span class="type">int</span>* ptr = &amp;i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The below assignment is invalid in C++, results in</span></span><br><span class="line"><span class="comment">    error In C, the compiler *may* throw a warning, but</span></span><br><span class="line"><span class="comment">    casting is implicitly allowed */</span></span><br><span class="line">    ptr = &amp;j;  <span class="comment">/* warning: assignment discards ‘const’ qualifier from pointer target type [-Wdiscarded-qualifiers] */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In C++, it is called &#x27;down qualification&#x27;. The type</span></span><br><span class="line"><span class="comment">    of expression &amp;j is &quot;const int *&quot; and the type of ptr</span></span><br><span class="line"><span class="comment">    is &quot;int *&quot;. The assignment &quot;ptr = &amp;j&quot; causes to</span></span><br><span class="line"><span class="comment">    implicitly remove const-ness from the expression &amp;j.</span></span><br><span class="line"><span class="comment">    C++ being more type restrictive, will not allow</span></span><br><span class="line"><span class="comment">    implicit down qualification. However, C++ allows</span></span><br><span class="line"><span class="comment">    implicit up qualification. The reason being, const</span></span><br><span class="line"><span class="comment">    qualified identifiers are bound to be placed in</span></span><br><span class="line"><span class="comment">    read-only memory (but not always). If C++ allows</span></span><br><span class="line"><span class="comment">    above kind of assignment (ptr = &amp;j), we can use &#x27;ptr&#x27;</span></span><br><span class="line"><span class="comment">    to modify value of j which is in read-only memory.</span></span><br><span class="line"><span class="comment">    The consequences are implementation dependent, the</span></span><br><span class="line"><span class="comment">    program may fail</span></span><br><span class="line"><span class="comment">    at runtime. So strict type checking helps clean code.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常量指针指向变量（Constant-Pointer-to-Variable）"><a href="# 常量指针指向变量（Constant-Pointer-to-Variable）" class="headerlink" title="常量指针指向变量（Constant Pointer to Variable）"></a>常量指针指向变量（Constant Pointer to Variable）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="type">const</span> ptr;</span><br></pre></td></tr></table></figure>

<p>上面的声明是一个指向整型变量的常量指针，这意味着我们可以改变该指针所指向的对象的值，但不能改变该指针指向另一个变量。</p>
<blockquote>
<p>简言之：指针（地址）是常量，不可变；指针指向的变量可变。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C program to demonstrate that the value of object pointed</span></span><br><span class="line"><span class="comment">// by pointer can be changed but the pointer can not point to another variable</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* constant pointer to integer */</span></span><br><span class="line">    <span class="type">int</span>* <span class="type">const</span> ptr = &amp;i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line"></span><br><span class="line">    *ptr = <span class="number">100</span>; <span class="comment">/* valid */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* error: assignment of read-only variable &#x27;ptr&#x27; */</span></span><br><span class="line">    ptr = &amp;j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常量指针指向常量（Constant-Pointer-to-Constant）"><a href="# 常量指针指向常量（Constant-Pointer-to-Constant）" class="headerlink" title="常量指针指向常量（Constant Pointer to Constant）"></a>常量指针指向常量（Constant Pointer to Constant）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> ptr;</span><br></pre></td></tr></table></figure>

<p>上面的声明是一个指向常量变量的常量指针，这意味着我们不能更改指针所指向的值，也不能将指针指向其他变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C program to demonstrate that value pointed by the</span></span><br><span class="line"><span class="comment">// pointer can not be changed as well as we cannot point the</span></span><br><span class="line"><span class="comment">// pointer to other variables</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* constant pointer to constant integer */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> ptr = &amp;i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line"></span><br><span class="line">    ptr = &amp;j; <span class="comment">/* error: assignment of read-only variable &#x27;ptr&#x27; */</span></span><br><span class="line">    *ptr = <span class="number">100</span>; <span class="comment">/* error: assignment of read-only location &#x27;*ptr&#x27; */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Type</th>
<th>Declaration</th>
<th>Pointer Value Change</th>
<th>Pointing Value Change</th>
</tr>
</thead>
<tbody><tr>
<td>Pointer to Variable</td>
<td><code>int *ptr</code></td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Pointer to Constant</td>
<td><code>const int *ptr</code></td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Pointer to Constant</td>
<td><code>int const *ptr</code></td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Constant Pointer to Variable</td>
<td><code>int* const ptr</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>Constant Pointer to Constant</td>
<td><code>const int* const ptr</code></td>
<td>No</td>
<td>No</td>
</tr>
</tbody></table>
<p>注：</p>
<ol>
<li><p>Pointer Value Change（指向的值的改变），如 <code>*ptr = 100</code></p>
</li>
<li><p>Pointing Value Change（指针的值的改变），如 <code>ptr = &amp;a</code></p>
</li>
<li><p>如果 <code>const</code> 在 <code>*</code> 的左边，那么 <code>const</code> 可以与类型互换位置，如 <code>const int *ptr</code> 等价于 <code>int const *ptr</code></p>
</li>
<li><p>被 <code>const</code> 修饰的变量，地址不可变还是值不可变，傻傻分不清？观察 <code>const</code> 靠近普通类型还是靠近指针类型：</p>
<ul>
<li>如果 <code>const</code> 靠近的是普通类型，那么常量变量的值不可变，指针地址可变，如 <code>const int *ptr</code>，<code>int const *ptr</code></li>
<li>如果 <code>const</code> 靠近的是指针类型，那么指针指向的基本类型的值可变，指针地址不可变，如 <code>int* const ptr</code></li>
</ul>
</li>
<li><p><strong>指针常量与常量指针记忆方法</strong>：只保留 <code>const</code> 和 <code>*</code>，从右往左读，如下：</p>
<ul>
<li><del>int</del> *<del>ptr</del>指针变量</li>
<li>const <del>int</del> *<del>ptr</del>指针常量</li>
<li><del>int</del> const *<del>ptr</del>指针常量</li>
<li><del>int</del>* const <del>ptr</del>常量指针</li>
<li>const <del>int</del>* const <del>ptr</del>常量指针指向常量变量</li>
</ul>
</li>
</ol>
<blockquote>
<p>参考链接：<a href="https://www.geeksforgeeks.org/const-qualifier-in-c/">https://www.geeksforgeeks.org/const-qualifier-in-c/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>const关键字</tag>
        <tag>下限定</tag>
        <tag>上限定</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之 main 函数参数</title>
    <url>/posts/230916171929.html</url>
    <content><![CDATA[<h2 id="指令行操作"><a href="# 指令行操作" class="headerlink" title="指令行操作"></a> 指令行操作 </h2><p>C 语言支持从 CLI（指令行）传入参数给 main() 函数，多个命令行参数之间用空格分隔，但是如果参数本身带有空格，那么就使用双引号或单引号。</p>
<p>C 语言的 main 函数是程序的入口函数，它可以有两种形式的参数：</p>
<span id="more"></span>

<ol>
<li><p> 无参数形式：main 函数的原型可以是 <code>int main(void)</code>。这表示不接受任何参数，程序执行时不需要从命令行传递参数给 main 函数。</p>
</li>
<li><p> 带参数形式：main 函数的原型可以是 <code>int main(int argc, char *argv[])</code>。其中，<code>argc</code> 表示命令行参数的个数，而 <code>argv</code> 是一个字符串指针数组，每个元素都是一个命令行参数的字符串。</p>
<ul>
<li><code>argc</code> 标识传入的参数个数。如果没有提供任何参数，<code>argc</code> 将被设置为 1；否则，<code>argc</code> 将被设置为传入的参数个数加 1。</li>
<li><code>argv[0]</code> 通常是程序的名称或路径的字符串。</li>
<li><code>argv[1]</code> 到 <code>argv[argc - 1]</code> 是命令行传递给程序的参数，以空格分隔。</li>
</ul>
</li>
</ol>
<p> 值得注意的是，也可以使用 <code>char **argv</code> 来代替 <code>char *argv[]</code> 形参，两者具有相同的类型含义。因为数组变量名 <code>argv</code> 就是指向 <code>argv[]</code> 数组的第一个元素的指针，同时又因为第一个元素的数值就是一个指针，所以此时的数组变量名 <code>argv</code> 的本质就是一个指针的指针（双重指针）。</p>
<p> 下面是一个例子，演示如何使用带参数的 main 函数来接收命令行参数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;number of params: %d\n&quot;</span>, argc);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;param-%d: %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 如果编译并运行这个程序，并在命令行中输入参数，例如 <code>./a.out arg1 arg2 3 arg4</code>，则输出如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">number of params: 5</span><br><span class="line">param-0: ./a.out</span><br><span class="line">param-1: arg1</span><br><span class="line">param-2: arg2</span><br><span class="line">param-3: 3</span><br><span class="line">param-4: arg4</span><br></pre></td></tr></table></figure>

<p> 参考链接：<a href="https://is-cloud.blog.csdn.net/article/details/105347737">https://is-cloud.blog.csdn.net/article/details/105347737</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>main函数参数</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之 typedef 实践</title>
    <url>/posts/230920172849.html</url>
    <content><![CDATA[<p>在 <a href="https://pursue26.github.io/posts/230918174223.html">C 语言之 typedef 自定义类型基础</a> 中介绍了 <code>typedef</code> 的使用，下面介绍一些 <code>typedef</code> 的实践。</p>
<span id="more"></span>

<h2 id="两大陷阱"><a href="# 两大陷阱" class="headerlink" title="两大陷阱"></a>两大陷阱 </h2><h3 id="不是简单的字符串替换"><a href="# 不是简单的字符串替换" class="headerlink" title="不是简单的字符串替换"></a> 不是简单的字符串替换</h3><p><code>typedef</code> 是定义了一种类型的新别名，不同于宏，它不是简单的字符串替换。</p>
<p>当 <code>const</code> 与 <code>typedef</code> 相结合时，如定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* PSTR;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mystrcmp</span><span class="params">(<span class="type">const</span> PSTR, <span class="type">const</span> PSTR)</span>;</span><br></pre></td></tr></table></figure>

<p><code>const PSTR</code> 实际上相当于指针常量 <code>const char*</code> 吗？</p>
<p>不是的，它实际上相当于 <code>char* const</code>。这是因为 <code>const</code> 给予了整个指针本身以常量性，也就是形成了常量指针。简单来说，记住当 <code>const</code> 和 <code>typedef</code> 一起出现时，<code>typedef</code> 不会是简单的字符串替换就行。</p>
<h3 id="与其它存储类关键字不共存"><a href="# 与其它存储类关键字不共存" class="headerlink" title="与其它存储类关键字不共存"></a>与其它存储类关键字不共存 </h3><p><code>typedef</code> 在语法上是一个<strong> 存储类关键字</strong>，虽然它并不真正影响对象的存储特性，但变量只能被一种储类的关键字修饰。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">static</span> <span class="type">int</span> SINT_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">auto</span> <span class="type">int</span> AINT_t;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">typedef</span> <span class="type">int</span> INT_t;</span><br></pre></td></tr></table></figure>

<p>上述代码中，有两个存储类关键字，会编译将失败，报错 error: multiple storage classes in declaration specifiers</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INT_t;</span><br><span class="line"><span class="type">static</span> INT_t a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>这种写法是合法的。</p>
<blockquote>
<p>其它存储类关键字有 <code>auto</code>、<code>extern</code>、<code>mutable</code>、<code>static</code>、<code>register</code> 等。</p>
</blockquote>
<h2 id="typedef、const 与 define 结合"><a href="#typedef、const 与 define 结合" class="headerlink" title="typedef、const 与 define 结合"></a>typedef、const 与 define 结合 </h2><p> 示例 1：通常讲，<code>typedef</code> 要比 <code>define</code> 要好，<strong>特别是在有指针的场合</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> pStr2 char*</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* pStr1;</span><br><span class="line"></span><br><span class="line">pStr1 s1, s2;  </span><br><span class="line">pStr2 s3, s4;</span><br></pre></td></tr></table></figure>

<p>在上述的变量定义中，<code>s1</code>、<code>s2</code>、<code>s3</code>都被定义为 <code>char *</code>，而<code>s4</code> 则定义成了 <code>char</code>，不是我们所预期的指针变量，根本原因就在于<code>define</code> 只是简单的字符串替换而 <code>typedef</code> 则是为一个类型起新名字。</p>
<p>示例 2：当 <code>const</code> 和<code>typedef</code>一起出现时，<code>typedef</code>不会是简单的字符串替换。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* pStr;</span><br><span class="line"><span class="type">char</span> s[<span class="number">4</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *p1 = s;</span><br><span class="line"><span class="type">const</span> pStr p2 = s; <span class="comment">// 实际为 char* const p2 = s;</span></span><br><span class="line"></span><br><span class="line">p1++;  <span class="comment">// 指针常量的指针可变</span></span><br><span class="line">p2++;  <span class="comment">// 编译报错, 常量指针的指针不可变</span></span><br><span class="line">*p1 = <span class="string">&#x27;m&#x27;</span>;  <span class="comment">// 编译报错, 指针常量的值不可变</span></span><br><span class="line"></span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">s[<span class="number">1</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s = %s, %c\r\n&quot;</span>, s, *p1, *p2);  <span class="comment">//dec, e, d</span></span><br><span class="line">*p2 = <span class="string">&#x27;m&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s = %s, %c\r\n&quot;</span>, s, *p1, *p2);  <span class="comment">//mec, e, m</span></span><br></pre></td></tr></table></figure>

<p>示例中，</p>
<ul>
<li><code>const char *p1</code>是限定数据类型为 <code>char *</code> 的指针变量可变，指针变量指向的对象不可变，所以 <code>p1++</code> 正确；</li>
<li><code>p2++</code>出错了，这个问题再一次提醒我们：<code>typedef</code>和 <code>define</code> 不同，它不是简单的文本替换；</li>
<li><code>const pStr p2</code>并不等于 <code>const char *p2</code>，<code>const pStr p2</code> 和<code>const long x</code>本质上没有区别，都是对变量进行只读限制，只不过此处变量 <code>p2</code> 的数据类型是我们自己定义的，而不是系统固有类型。因此，<code>const pStr p2</code>的含义是：限定数据类型为 <code>char *</code> 的指针变量 <code>p2</code> 为只读，因此 <code>p2++</code> 错误。</li>
</ul>
<h2 id="抑制劣质代码"><a href="# 抑制劣质代码" class="headerlink" title="抑制劣质代码"></a>抑制劣质代码 </h2><p> 人们常常使用 <code>typedef</code> 来编写更美观和可读的代码。所谓美观，意指 <code>typedef</code> 能隐藏笨拙的语法构造以及平台相关的数据类型，从而增强可移植性以及未来的可维护性。在编程中使用 <code>typedef</code> 目的一般有两个，一个是给变量一个易记且意义明确的新名字，另一个是简化一些比较复杂的类型声明。</p>
<h3 id="定义易于记忆的类型名"><a href="# 定义易于记忆的类型名" class="headerlink" title="定义易于记忆的类型名"></a>定义易于记忆的类型名</h3><p><code>typedef</code> 使用最多的地方是创建易于记忆的类型名，用它来归档程序员的意图。类型出现在所声明的变量名字中，位于 <code>typedef</code> 关键字右边。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure>

<p>此声明定义了一个 <code>int</code> 的同义字，名字为 <code>size</code>。注意 <code>typedef</code> 并不创建新的类型，它仅仅为现有类型添加一个同义字。因此，你可以在任何需要 <code>int</code> 的上下文中使用 <code>size</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">measure</span><span class="params">(size *pSize)</span>;</span><br><span class="line">size <span class="built_in">array</span>[<span class="number">4</span>];</span><br><span class="line">size len = file.getlength();</span><br></pre></td></tr></table></figure>

<p><code>typedef</code> 还可以掩饰复合类型，如指针和数组。例如，你不用像下面这样重复定义有 81 个字符元素的数组：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> line[<span class="number">81</span>];</span><br><span class="line"><span class="type">char</span> text[<span class="number">81</span>];</span><br></pre></td></tr></table></figure>

<p>定义一个 <code>typedef</code>，每当要用到相同类型和大小的数组时，可以这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> Line[<span class="number">81</span>];</span><br><span class="line">Line text, secondline;</span><br><span class="line">getline(text);</span><br></pre></td></tr></table></figure>

<p>同样，也可以像下面这样隐藏指针语法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">char</span> *<span class="type">pstr_t</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mystrcmp</span><span class="params">(<span class="type">pstr_t</span>, <span class="type">pstr_t</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>记住</strong>，不管什么时候，只要为指针声明 <code>typedef</code>，都要在最终的 <code>typedef</code> 名称中加一个 <code>const</code>，比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">char</span> *<span class="type">cpstr_t</span>;  <span class="comment">// 指针常量, 使得该指针可变, 而指针指向的对象不可变（只读）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* <span class="type">const</span> <span class="type">cpstr_t</span>;  <span class="comment">// 常量指针, 使得该指针不可变（只读）, 但指针指向的对象可变的</span></span><br></pre></td></tr></table></figure>

<h3 id="简化代码"><a href="# 简化代码" class="headerlink" title="简化代码"></a>简化代码 </h3><p> 上面讨论的 <code>typedef</code> 行为有点像 <code>define</code> 宏，用其实际类型替代同义字。不同点是 <code>typedef</code> 在编译时被解释，因此可以让编译器来应付超越预处理器能力的文本替换。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*PF)</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *)</span>;</span><br></pre></td></tr></table></figure>

<p>这个声明引入了 <code>PF</code> 类型作为函数指针的同义字，该函数有两个 <code>const char *</code> 类型的参数以及一个 <code>int</code> 类型的返回值。如果要使用下列形式的函数声明，那么上述这个 <code>typedef</code> 是不可或缺的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PF <span class="title function_">Register</span><span class="params">(PF pf)</span>;</span><br></pre></td></tr></table></figure>

<p><code>Register()</code> 的参数是一个 <code>PF</code> 类型的回调函数，返回某个函数的地址，其署名与先前注册的名字相同。下面我展示一下如果不用 <code>typedef</code>，我们是如何实现这个声明的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*Register (<span class="type">int</span> (*pf)(<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *))) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *); </span><br></pre></td></tr></table></figure>

<p>很少有程序员理解它是什么意思，更不用说这种费解的代码所带来的出错风险了。显然，这里使用 <code>typedef</code> 不是一种特权，而是一种必需。</p>
<p>持怀疑态度的人可能会问：“OK，还会有人写这样的代码吗？”，快速浏览一下揭示 <code>signal()</code> 函数的头文件 <code>&lt;csinal&gt;</code>，有一个同样接口的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// signal 原型</span></span><br><span class="line"><span class="type">void</span> (*signal(<span class="type">int</span> sig, <span class="type">void</span> (*func)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// typedef 优化后</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*pFun)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">pFun <span class="title function_">signal</span><span class="params">(<span class="type">int</span> sig, pFun func)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考链接：<a href="https://www.cnblogs.com/a-s-m/p/10995722.html">https://www.cnblogs.com/a-s-m/p/10995722.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>typedef</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之 typedef 自定义类型基础</title>
    <url>/posts/230918174223.html</url>
    <content><![CDATA[<p><code>typedef</code> 关键字用于自定义数据类型的一个别名，或者称之为「定义了一种新的数据类型」。它可以有效简化定义一个复杂数据类型的代码实现。</p>
<span id="more"></span>

<h2 id="定义一种类型的别名"><a href="# 定义一种类型的别名" class="headerlink" title="定义一种类型的别名"></a>定义一种类型的别名 </h2><p> 定义一种类型的别名，而不只是简单的宏替换。例如，可以用作同时声明指针类型的 <strong> 多个对象</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* pa, pb;</span><br></pre></td></tr></table></figure>

<p>不符合意图，它只声明了一个指向字符变量的指针 <code>pa</code> 和一个字符变量<code>pb</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* PCHAR;</span><br><span class="line">PCHAR pa, pb;</span><br></pre></td></tr></table></figure>

<p>符合意图，同时声明了两个指向字符变量的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *pa, *pb;</span><br></pre></td></tr></table></figure>

<p>也符合意图，但相对来说没有用 <code>typedef</code> 的形式直观，尤其在需要大量指针的地方，<code>typedef</code> 的方式更省事。</p>
<h2 id="为结构体类型对象起别名"><a href="# 为结构体类型对象起别名" class="headerlink" title="为结构体类型对象起别名"></a>为结构体类型对象起别名</h2><p><code>typedef</code> 可以用在 <code>struct</code> 结构体中，为声明的 <code>struct</code> 结构体类型的对象起别名。</p>
<p><strong>声明 </strong> 结构体类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPOINT</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一般结构体变量的定义为 <code>struct struct_name obj_name</code>，如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPOINT</span> <span class="title">stCoor</span>;</span>  <span class="comment">// 定义一个结构体变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPOINT</span> *<span class="title">pstCoor</span> =</span> <span class="literal">NULL</span>; <span class="comment">// 定义一个结构体指针变量</span></span><br></pre></td></tr></table></figure>

<p><strong>定义 </strong> 结构体类型（而非定义结构体变量）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagPOINT</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125; stPOINT, *pstPOINT;</span><br></pre></td></tr></table></figure>

<p>使用 <code>typedef</code> 为 <code>struct</code> 声明的结构体类型起别名后，定义该结构体类型的变量时，可以不再书写 <code>struct</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">stPOINT stCoor;  <span class="comment">// 定义一个结构体变量</span></span><br><span class="line">pstPOINT pstCoor = <span class="literal">NULL</span>; <span class="comment">// 定义一个结构体指针变量</span></span><br><span class="line">stPOINT *pstCoor; <span class="comment">// 定义一个结构体指针变量</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面既有「声明」，又有「定义」，那声明结构体类型、定义结构体类型和定义结构体变量的区别：</p>
</blockquote>
<ul>
<li><p>声明结构体类型：只是指定了一个结构体的类型，它相当于一个模型，但其中并无具体数据，系统对之也 <strong> 不分配实际的内存单元</strong>。</p>
</li>
<li><p>定义结构体类型：使用 <code>typedef</code> 为 <code>struct</code> 声明的结构体类型起别名后，即定义了一个结构体类型，但此时 <strong> 未分配内存单元</strong>。</p>
<ul>
<li>这里用定义一词，对应了本文最开始所说的，<code>typedef</code> 关键字用于定义了一种新的数据类型。</li>
</ul>
</li>
<li><p>定义结构体变量：其中有具体的数据，也为变量分配内存单元。</p>
</li>
</ul>
<h2 id="定义与平台无关的类型"><a href="# 定义与平台无关的类型" class="headerlink" title="定义与平台无关的类型"></a>定义与平台无关的类型 </h2><p> 例如，定义一个叫 <code>REAL</code> 的浮点类型，在目标平台上，让它表示最高精度类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> REAL;</span><br></pre></td></tr></table></figure>

<p>在不支持 <code>long double</code> 的平台上，改为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> REAL;</span><br></pre></td></tr></table></figure>

<p>在连 <code>double</code> 都不支持的平台上，改为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> REAL;</span><br></pre></td></tr></table></figure>

<p>也就是说，当跨平台时，只要修改 <code>typedef</code> 定义本身就行，不用对其他源码做任何修改。标准库就广泛使用了这个技巧，比如 <code>size_t</code>。</p>
<p>另外，因为 <code>typedef</code> 是定义了一种类型的别名，而不是简单的字符串替换，所以它比宏来得稳健（虽然有时候用宏也可以完成以上的用途）。</p>
<h2 id="右左原则"><a href="# 右左原则" class="headerlink" title="右左原则"></a>右左原则 </h2><p> 理解、简化复杂声明可用的「右左法则」：从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*func)(<span class="type">void</span> *p);</span><br></pre></td></tr></table></figure>

<p>上面的示例中，</p>
<ol>
<li>首先，找到变量名 <code>func</code>，外面有一对圆括号，而且左边是一个<code>*</code> 号，这说明 <code>func</code> 是一个指针；</li>
<li>然后，跳出这个圆括号，先看右边，又遇到圆括号，这说明 <code>(*func)</code> 是一个函数，所以 <code>func</code> 是一个指向这类函数的指针，即函数指针，这类函数具有 <code>void*</code> 类型的形参，返回值类型是<code>int</code>。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*func[<span class="number">5</span>])(<span class="type">int</span> *);</span><br></pre></td></tr></table></figure>
<p>上面的示例中，</p>
<ol>
<li>首先，找到变量名 <code>func</code>，右边是一个<code>[]</code> 运算符，说明 <code>func</code> 是具有 5 个元素的数组；</li>
<li>然后，遇到圆括号了，调转阅读方向，<code>func</code>的左边有一个 <code>*</code>，说明<code>func</code> 的元素是指针；<ul>
<li>注意，这里的 <code>*</code> 不是修饰 <code>func</code>，而是修饰<code>func[5]</code> 的，原因是 <code>[]</code> 运算符优先级比 <code>*</code> 高，<code>func</code>先跟 <code>[]</code> 结合；</li>
</ul>
</li>
<li>最后，跳出这个括号，看右边，又遇到圆括号，说明 <code>func</code> 数组的元素是函数类型的指针，它指向的函数具有 <code>int*</code> 类型的形参，返回值类型为<code>int</code>。</li>
</ol>
<p>也可以记住这 2 个模式：</p>
<ul>
<li><code>type (*x)(....)</code> ——— 函数指针   </li>
<li><code>type (*x)[]</code> ——— 数组指针</li>
</ul>
<h2 id="为复杂的声明定义一个新的简单的别名"><a href="# 为复杂的声明定义一个新的简单的别名" class="headerlink" title="为复杂的声明定义一个新的简单的别名"></a>为复杂的声明定义一个新的简单的别名</h2><p><code>typedef</code> 为复杂的声明定义一个新的简单的别名的方法是：在原来的声明里逐步用别名替换一部分复杂声明，如此循环，把带变量名的部分留到最后替换，得到的就是原声明的最简化版。</p>
<h3 id="示例一：函数指针数组"><a href="# 示例一：函数指针数组" class="headerlink" title="示例一：函数指针数组"></a>示例一：函数指针数组 </h3><p> 我们知道，<code>int *arr[5]</code> 表示 <code>arr</code> 是一个包含 5 个元素的数组，由于 <code>arr</code> 左边是一个 <code>*</code>，所以数组中的每个元素都是一个指针，是一个 <code>int</code> 类型的指针。</p>
<p>原声明：<code>int *(*a[5])(int, char*)</code>，变量名为 <code>a</code>。</p>
<p>这个声明中，<code>a</code> 也是一个数组，由于 <code>a</code> 左边是一个 <code>*</code>，所以数组中的元素也是指针，是什么指针呢？是一个返回类型为 <code>int*</code>、参数为<code>(int, char*)</code> 的函数指针。</p>
<p>所以，我们可以定义一个新的函数类型，它接受两个参数：一个是 <code>int</code> 类型，另一个是 <code>char*</code> 类型，返回一个 <code>int</code> 类型的指针，即 <code>typedef int *(*pFunc)(int, char*)</code></p>
<p>那么，原声明就变成了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pFunc a[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>这里，变量 <code>a</code> 是一个数组，数组中的每个元素都是一个函数指针，这个函数指针的返回类型为<code>int*</code>、参数为<code>(int, char*)</code>。</p>
<h3 id="示例二：函数指针数组"><a href="# 示例二：函数指针数组" class="headerlink" title="示例二：函数指针数组"></a>示例二：函数指针数组 </h3><p> 原声明：<code>void (*b[10]) (void (*)())</code>，变量名为 <code>b</code>。</p>
<p>这个声明也是一个函数指针数组，只不过不像示例一中的函数的入参是 <code>(int, char*)</code>，这个示例中函数的入参是另外一个函数指针 <code>void (*)()</code>，它指向的函数没有入参，返回值类型是 <code>void</code>。</p>
<p>为了简化声明，我们可以：</p>
<ol>
<li>先替换右边部分括号里的，即 <code>typedef void (*pFuncParam)()</code>，其中 <code>pFuncParam</code> 为别名一，定义了一个没有入参、返回值为 <code>void</code> 的函数指针；</li>
<li>再替换左边的变量 <code>b</code>，即 <code>typedef void (*pFunc)(pFuncParam)</code>，<code>pFunc</code> 为别名二，定义了一个入参为 <code>pFuncParam</code>、返回值为 <code>void</code> 的函数指针。</li>
</ol>
<p>那么，原声明就变成了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pFunc b[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>这里，变量 <code>b</code> 是一个数组，数组中的每个元素都是一个函数指针，这个函数指针的返回类型为<code>void</code>，参数为一个指向返回类型为<code>void</code>、没有入参的函数指针。</p>
<h3 id="示例三：数组指针"><a href="# 示例三：数组指针" class="headerlink" title="示例三：数组指针"></a>示例三：数组指针 </h3><p> 原声明：<code>double (*e)[9]</code>，变量名为 <code>e</code>。这是一个指针，它指向一个有 9 个元素的数组，元素类型为 <code>double</code>。这可以简化为 <code>typedef double (*pArr)[9]</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pArr e;</span><br></pre></td></tr></table></figure>

<p>这里，变量 <code>e</code> 是一个指针，它指向一个长度为 9 的数组，数组的元素类型是 <code>double</code>。</p>
<blockquote>
<p>示例一、二与示例三是有差别的，前者是数组（数组中的元素是指针），后者是指针（指针指向的是一个数组）。</p>
</blockquote>
<h2 id="函数指针和数组指针示例"><a href="# 函数指针和数组指针示例" class="headerlink" title="函数指针和数组指针示例"></a>函数指针和数组指针示例 </h2><h3 id="函数指针"><a href="# 函数指针" class="headerlink" title="函数指针"></a> 函数指针 </h3><p> 函数指针是指向函数的指针变量，它可以存储函数的地址。通过函数指针可以在程序运行时动态地调用不同的函数。函数指针的声明方式为：<code>data_type (*pointer_var_name)(param_list)</code>。</p>
<p>以下是一个函数指针的示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*pFunc)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>; <span class="comment">// 定义一个函数指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    pFunc ptr = add; <span class="comment">// 指向 add 函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2 + 3 = %d\n&quot;</span>, ptr(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 调用 add 函数</span></span><br><span class="line"></span><br><span class="line">    ptr = subtract; <span class="comment">// 指向 subtract 函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;5 - 2 = %d\n&quot;</span>, ptr(<span class="number">5</span>, <span class="number">2</span>)); <span class="comment">// 调用 subtract 函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组指针"><a href="# 数组指针" class="headerlink" title="数组指针"></a>数组指针 </h3><p> 数组指针是指向数组的指针变量，它可以存储数组的地址。通过数组指针可以访问数组的元素。数组指针的声明方式为：<code>data_type (*pointer_var_name)[array_length]</code>。</p>
<p>以下是一个数组指针的示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*pArr)</span>[5]; <span class="comment">// 定义一个数组指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    pArr ptr = &amp;arr; <span class="comment">// 指向 arr 数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, (*ptr)[i], *((<span class="type">int</span> *)ptr + i)); <span class="comment">// 通过数组指针访问数组元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 <code>(*ptr)</code> 为什么要解引用？</p>
<p>这是因为，数组变量名 <code>arr</code> 表示的就是数组的首地址，而在 <code>pArr ptr = &amp;arr</code> 中，<code>ptr</code> 表示指向数组首地址的地址（存储数组首地址的地址空间），所以要解引用来获取数组的首地址，才能访问数组中的数据。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>typedef</tag>
        <tag>右左原则</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之一、二级指针</title>
    <url>/posts/240224193217.html</url>
    <content><![CDATA[<p>本文介绍了 C 语言中的一级指针和二级指针，并通过示例说明了为什么在函数参数中使用一级指针，函数内部对指针形参本身的修改不会影响外部指针的指向。同时，也演示了如何使用二级指针在函数内部改变指针的指向以及进行内存分配操作。</p>
<span id="more"></span>

<h1 id="概念"><a href="# 概念" class="headerlink" title="概念"></a>概念 </h1><p> 在如下的 A 指向 B、B 指向 C 的指向关系中，首先：</p>
<p>C 是一个变量，里面是「一段内容」，这段内容需要存储在一个地址空间里。C 的起始地址是 0x00000008。</p>
<p>B 是一个指针变量，其内容是 C 的地址 0x00000008（专业术语：B 指向 C），但是 B 本身也要占空间的啊，所以 B 也有地址。B 的起始地址是 0x00000004。</p>
<p>那么，到此为止都比较好理解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B == 0x00000008;   // B 的内容，也就是 C 的地址 0x00000008</span><br><span class="line">*B == 一段内容;    // B 解引用，也就是 B 指针指向的 C 的值</span><br><span class="line">&amp;B == 0x00000004;  // B 取地址，B 本身的地址是 0x00000004</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看指针变量 B，就是查看 B 的内容（这里是 C 的地址）。对指针变量 B 解引用，就是查看它的内容（内容是一个地址）下的内容。</p>
</blockquote>
<img src="../images/language-notes/second-rank-pointer.png" alt="指针访问" width="100%" height="100%">

<p>A 是二级指针变量，其中存放着 B 的地址 0x00000004。A 本身也有地址，是 0x00000000。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*A == B == 0x00000008;  // A 解引用，也就是 A 指针指向的 B 的内容（即 B 的内容是 C 的地址）</span><br><span class="line">**A == *B == 一段内容;  // B 解引用，也就是 B 指针指向的 C 的内容</span><br><span class="line">A == &amp;B == 0x00000004;  // A 存的是 B 的地址，B 的地址是 0x00000004</span><br><span class="line">&amp;A == 0x00000000;       // A 取地址，A 本身的地址是 0x00000000</span><br></pre></td></tr></table></figure>

<p>上面三个变量的 C 语言定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> c = <span class="number">123</span>;  <span class="comment">// 一段内容</span></span><br><span class="line"><span class="type">int</span> *b = &amp;c;</span><br><span class="line"><span class="type">int</span> **a = &amp;b;  <span class="comment">// 按顺序定义，定义二级指针前要定义一级指针</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;c, &amp;b, &amp;a = %p, %p, %p\n&quot;</span>, &amp;c, &amp;b, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c, b, a = %d, %p, %p\n&quot;</span>, c, b, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*b, *a, **a = %d, %p, %d\n&quot;</span>, *b, *a, **a);</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;c, &amp;b, &amp;a = 0x7fff05148014, 0x7fff05148018, 0x7fff05148020</span><br><span class="line">c, b, a = 123, 0x7fff05148014, 0x7fff05148018</span><br><span class="line">*b, *a, **a = 123, 0x7fff05148014, 123</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li>c, b, a 各自有各自的地址；</li>
<li>c 的内容是 123，b 的内容是 c 的地址，a 的内容是 b 的地址；</li>
<li>b 解引用是 123，a 解引用就是 b 的内容（即 c 的地址），a 的解引用的解引用（即 b 的解引用）就是 123。</li>
</ul>
<h1 id="使用"><a href="# 使用" class="headerlink" title="使用"></a>使用 </h1><p> 二级指针作为函数参数的作用：在函数外部定义一个指针 p，<strong>在函数内给指针变量（是对指针变量，不是对指针解引用）赋值，函数结束后对指针 p 生效，那么我们就需要二级指针</strong>。</p>
<p>看看下面一段代码：有两个变量 a 和 b、一个指针 q（q 指向 a）。现在，我们想让 q 指向 b（要在函数里面实现）。</p>
<h2 id="一级指针的实现"><a href="# 一级指针的实现" class="headerlink" title="一级指针的实现"></a>一级指针的实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> *q;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>* p)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;note:3, func:&amp;p=%p, p=%p\n&quot;</span>, &amp;p, p);</span><br><span class="line">    p = &amp;b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;note:4, func:&amp;p=%p, p=%p\n&quot;</span>, &amp;p, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;note:1, &amp;a=%p, &amp;b=%p, &amp;q=%p\n&quot;</span>, &amp;a, &amp;b, &amp;q);</span><br><span class="line"></span><br><span class="line">    q = &amp;a;  <span class="comment">// 现在让指针 q 指向 a</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;note:2, *q=%d, q=%p, &amp;q=%p\n&quot;</span>, *q, q, &amp;q);</span><br><span class="line">    func(q);  <span class="comment">// 期望在这个函数里让指针 q 指向 b</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;note:5, *q=%d, q=%p, &amp;q=%p\n&quot;</span>, *q, q, &amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">note:1, &amp;a=0x5627cc40d010, &amp;b=0x5627cc40d014, &amp;q=0x5627cc40d020</span><br><span class="line">note:2, *q=10, q=0x5627cc40d010, &amp;q=0x5627cc40d020</span><br><span class="line">note:3, func:&amp;p=0x7ffd3af06678, p=0x5627cc40d010</span><br><span class="line">note:4, func:&amp;p=0x7ffd3af06678, p=0x5627cc40d014</span><br><span class="line">note:5, *q=10, q=0x5627cc40d010, &amp;q=0x5627cc40d020</span><br></pre></td></tr></table></figure>

<p>从结果可以看出：</p>
<ul>
<li>note:1 -&gt; a, b, q 各自有各自的地址</li>
<li>note:2 -&gt; q 指向了 a，即地址 q 里的内容是 a 的地址</li>
<li>note:3 -&gt; 把指针 q 作为参数传入了函数，在函数内部参数 p 的地址不再是 q 的地址、但参数 p 的内容是 q 的内容（即 a 的地址）。是的，<strong>参数传递是制作了一个副本，也就是指针 p 和指针 q 不是同一个指针、但是指向的地址却是相同的</strong>。</li>
<li>note:4 -&gt; p 指向了 b</li>
<li>note:5 -&gt; 函数退出，<strong>p 的修改并不会对 q 造成影响</strong>。</li>
</ul>
<p>结论：</p>
<p><strong>编译器总是要为函数的每个参数制作临时副本</strong>，指针入参 q 的副本是 p，编译器使得原内存和副本内存指向的内容保持一样，即 <code>p = q</code>，但是这两块内存自身的地址不一样 <code>&amp;p != &amp;q</code>。</p>
<p>如果函数体内的程序修改了参数 p 这块副本内存的内容（比如在这里它指向 b 的地址），但是原内存 q 指向的内容不受影响。所以，在这里并不影响函数外的指针 q。</p>
<p><strong>要想在函数内部修改对函数外部可见（生效），这就需要二级指针操作</strong>。</p>
<h2 id="二级指针的实现"><a href="# 二级指针的实现" class="headerlink" title="二级指针的实现"></a>二级指针的实现 </h2><h3 id="例子一"><a href="# 例子一" class="headerlink" title="例子一"></a> 例子一</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span>* q;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>** p)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;note:3, func:&amp;p=%p, p=%p\n&quot;</span>, &amp;p, p);</span><br><span class="line">    *p = &amp;b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;note:4, func:&amp;p=%p, p=%p\n&quot;</span>, &amp;p, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;note:1, &amp;a=%p, &amp;b=%p, &amp;q=%p\n&quot;</span>, &amp;a, &amp;b, &amp;q);</span><br><span class="line"></span><br><span class="line">    q = &amp;a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;note:2, *q=%d, q=%p, &amp;q=%p\n&quot;</span>, *q, q, &amp;q);</span><br><span class="line">    func(&amp;q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;note:5, *q=%d, q=%p, &amp;q=%p\n&quot;</span>, *q, q, &amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码只修改了三处：</p>
<ul>
<li>函数 func 的形参变成了二级指针 int **p</li>
<li>函数内对二级指针解引用后，指向了 b</li>
<li>main 函数中，将一级指针 p 的地址（即二级指针）传入了函数 func</li>
</ul>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">note:1, &amp;a=0x563b8d952010, &amp;b=0x563b8d952014, &amp;q=0x563b8d952020</span><br><span class="line">note:2, *q=10, q=0x563b8d952010, &amp;q=0x563b8d952020</span><br><span class="line">note:3, func:&amp;p=0x7ffcc73f68b8, p=0x563b8d952020</span><br><span class="line">note:4, func:&amp;p=0x7ffcc73f68b8, p=0x563b8d952020</span><br><span class="line">note:5, *q=100, q=0x563b8d952014, &amp;q=0x563b8d952020</span><br></pre></td></tr></table></figure>

<p>note:3 -&gt; 将一级指针 p 的地址（即二级指针）传入了函数 func。函数内部 &amp;p 就是 <strong> 副本 </strong>p 本身的地址 (&amp;p=..68b8)，二级指针 p 的值 (p=..2020) 就是指针 q 的地址 (&amp;q=..2020)，即<code>*p == q</code>；通过解引用<code>*p=&amp;b</code> 重新指定了 q 指向的地址（即等价于执行了<code>q=&amp;b</code>）。所以，在函数退出后，q 指向的地址发生改变。</p>
<p>结论：<strong>在函数中，通过传递指向指针 (q) 的指针 (&amp;q)，可以修改指针 (q) 本身指向的地址 (q=&amp;b)</strong>。</p>
<h3 id="例子二"><a href="# 例子二" class="headerlink" title="例子二"></a>例子二</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE (100)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_malloc1</span><span class="params">(<span class="type">char</span>* s1)</span> &#123;s1 = (<span class="type">char</span>*)<span class="built_in">malloc</span>(SIZE * <span class="keyword">sizeof</span>(<span class="type">char</span>));&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">my_malloc2</span><span class="params">(<span class="type">char</span>** s2)</span> &#123;*s2 = (<span class="type">char</span>*)<span class="built_in">malloc</span>(SIZE * <span class="keyword">sizeof</span>(<span class="type">char</span>));&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len = <span class="number">3</span>;</span><br><span class="line">    <span class="type">char</span>** p1 = (<span class="type">char</span>**)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="type">char</span>*));</span><br><span class="line">    <span class="type">char</span>** p2 = (<span class="type">char</span>**)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="type">char</span>*));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(p1, <span class="number">0</span>, <span class="keyword">sizeof</span>(p1));</span><br><span class="line">    <span class="built_in">memset</span>(p2, <span class="number">0</span>, <span class="keyword">sizeof</span>(p2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;my_malloc1(), before: p1[%d] is %s\n&quot;</span>, i, p1[i] == <span class="literal">NULL</span> ? <span class="string">&quot;NULL&quot;</span> : <span class="string">&quot;NOT NULL&quot;</span>);</span><br><span class="line">        my_malloc1(p1[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;my_malloc1(), after:  p2[%d] is %s\n&quot;</span>, i, p1[i] == <span class="literal">NULL</span> ? <span class="string">&quot;NULL&quot;</span> : <span class="string">&quot;NOT NULL&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (p1[i]) &#123;<span class="built_in">free</span>(p1[i]);&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;my_malloc2(), before: p2[%d] is %s\n&quot;</span>, i, p2[i] == <span class="literal">NULL</span> ? <span class="string">&quot;NULL&quot;</span> : <span class="string">&quot;NOT NULL&quot;</span>);</span><br><span class="line">        my_malloc2(&amp;p2[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;my_malloc2(), after:  p2[%d] is %s\n&quot;</span>, i, p2[i] == <span class="literal">NULL</span> ? <span class="string">&quot;NULL&quot;</span> : <span class="string">&quot;NOT NULL&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (p2[i]) &#123;<span class="built_in">free</span>(p2[i]);&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_malloc1(), before: p1[0] is NULL</span><br><span class="line">my_malloc1(), after:  p2[0] is NULL</span><br><span class="line">my_malloc1(), before: p1[1] is NULL</span><br><span class="line">my_malloc1(), after:  p2[1] is NULL</span><br><span class="line">my_malloc1(), before: p1[2] is NULL</span><br><span class="line">my_malloc1(), after:  p2[2] is NULL</span><br><span class="line">my_malloc2(), before: p2[0] is NULL</span><br><span class="line">my_malloc2(), after:  p2[0] is NOT NULL</span><br><span class="line">my_malloc2(), before: p2[1] is NULL</span><br><span class="line">my_malloc2(), after:  p2[1] is NOT NULL</span><br><span class="line">my_malloc2(), before: p2[2] is NULL</span><br><span class="line">my_malloc2(), after:  p2[2] is NOT NULL</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们尝试在函数内部给函数外申请的二级指针（指针数组 <code>p1, p2</code> 的每个位置（初始时都是空地址）分配一块内存。</p>
<p>在函数 <code>my_malloc1</code> 中，使用一级指针作为函数参数。就相当于给 <code>p1[i]</code> 的拷贝副本 <code>s1</code> 分配内存，<code>p1[i]</code>依然没有分配内存，所以在函数退出后，<code>p1[i]</code>依然是空地址。</p>
<p>在函数 <code>my_malloc2</code> 中，使用二级指针作为函数参数。<code>&amp;p2[i]</code>的拷贝副本为 <code>s2</code>，<code>*s2</code> 解引用的内容与拷贝前 <code>&amp;p2[i]</code> 指向的内容一致（是 <code>p2[i]</code>），此时对其分配内存，在函数退出后，<code>p2[i]</code> 是一个分配的有效地址。</p>
<h1 id="总结"><a href="# 总结" class="headerlink" title="总结"></a>总结 </h1><p> 在函数中，通过传递指向指针的指针（二级指针），可以修改指针本身指向的地址。</p>
<ul>
<li>通过二级指针，在函数内部改变指针的指向（例子一）。</li>
<li>通过二级指针，在函数内部进行内存分配（例子二）。</li>
</ul>
<p>注意，函数形参使用的是一级指针，就是值传递，值传递在函数里面 <strong> 修改指针 </strong>，改变的是形参的值，而不是实参的值；但可以通过对形参<strong> 解引用赋值</strong>，来改变实参指向的地址里的值。</p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://www.techxiaofei.com/post/cpp/secondary_pointer">https://www.techxiaofei.com/post/cpp/secondary_pointer</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>一级指针</tag>
        <tag>二级指针</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之 uthash 哈希表基础</title>
    <url>/posts/230922172626.html</url>
    <content><![CDATA[<p>由于 C 语言本身不存在哈希，但当需要使用哈希表的时候，自己构建又会异常复杂。因此，我们可以调用开源的第三方库 <code>uthash.h</code>，<strong>这只是一个头文件</strong>。我们需要做的就是将头文件通过 <code>#include &quot;uthash.h&quot;</code> 引入到自己的项目中。由于 <code>uthash</code> 仅是头文件，因此没有可链接的库代码。</p>
<span id="more"></span>

<h2 id="uthash 简介"><a href="#uthash 简介" class="headerlink" title="uthash 简介"></a>uthash 简介 </h2><p> 使用 <code>uthash</code> 添加、查找和删除通常是常数时间的操作，此哈希库的目标是简约、高效。它大约有 1000 行 C 代码，它会 <em> 自动内联</em>，因为它是作为宏实现的。</p>
<p><code>uthash</code> 还包括三个额外的头文件，主要提供链表、动态数组和动态字符串。</p>
<ul>
<li><code>utlist.h</code> 为 C 结构提供了链接列表宏。</li>
<li><code>utarray.h</code> 使用宏实现动态数组。</li>
<li><code>utstring.h</code> 实现基本的动态字符串。</li>
</ul>
<blockquote>
<p>内联是一种编译器优化，它将「函数调用」替换为「函数体的代码」。这样可以避免函数调用时所需的开销，从而提高性能。</p>
</blockquote>
<h2 id="uthash 的使用"><a href="#uthash 的使用" class="headerlink" title="uthash 的使用"></a>uthash 的使用 </h2><h3 id="初始化"><a href="# 初始化" class="headerlink" title="初始化"></a> 初始化 </h3><p> 这里我们将 <code>id</code> 作为一个索引值，也就是键 key，将 <code>name</code> 作为值 value，它可以是任意复杂结构。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uthash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;                    <span class="comment">/* key */</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    UT_hash_handle hh;         <span class="comment">/* makes this structure hashable */</span></span><br><span class="line">&#125; HashItem;</span><br><span class="line"></span><br><span class="line">HashItem *hashTbl = <span class="literal">NULL</span>;    <span class="comment">/* important! initialize to NULL */</span></span><br></pre></td></tr></table></figure>

<p>注意：结构中一定要包含 <code>UT_hash_handle hh</code>（<code>hh</code>不需要初始化）。它可以命名为任何名称，但是一般都命名为 <code>hh</code>。</p>
<h3 id="添加"><a href="# 添加" class="headerlink" title="添加"></a>添加</h3><ul>
<li><p><code>HASH_ADD_INT</code>：表示添加的键值为整型，参数为 <code>(head, keyfield_name, item_ptr)</code>；</p>
</li>
<li><p><code>HASH_ADD_STR</code>：表示添加的键值为字符串类型，参数为 <code>(head, keyfield_name, item_ptr)</code>；</p>
</li>
<li><p><code>HASH_ADD_PTR</code>：表示添加的键值为指针类型，参数为 <code>(head, keyfield_name, item_ptr)</code>；</p>
</li>
<li><p><code>HASH_ADD</code>：表示添加的键值可以是任意类型，参数为 <code>(hh_name, head, keyfield_name, key_len, item_ptr)</code>。</p>
</li>
</ul>
<p>这些常见的宏的参数可以看 <a href="https://troydhanson.github.io/uthash/userguide.html#_convenience_macros"> 这里 </a>，一般性的宏（如<code>HASH_ADD</code>）的参数可以看<a href="https://troydhanson.github.io/uthash/userguide.html#_general_macros"> 这里</a>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add_user</span><span class="params">(<span class="type">int</span> user_id, <span class="type">char</span> *name)</span> &#123;</span><br><span class="line">    HashItem *hashNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加前先进行重复性检查，因为当把两个相同 key 值的结构体添加到哈希表中时会报错 */</span></span><br><span class="line">    HASH_FIND_INT(hashTbl, &amp;user_id, hashNode);  <span class="comment">/* id already in the hash? */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 只有在哈希中不存在 ID 的情况下，才创建该项目并将其添加；否则，只修改已经存在的结构 */</span></span><br><span class="line">    <span class="keyword">if</span> (hashNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      hashNode = (HashItem *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashItem));</span><br><span class="line">      hashNode-&gt;id = user_id;</span><br><span class="line">      HASH_ADD_INT(hashTbl, id, hashNode);  <span class="comment">/* id: name of key field */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(hashNode-&gt;name, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>HASH_ADD_INT</code> 函数中，</p>
<ul>
<li>第一个参数 <code>hashTbl</code> 是哈希表；</li>
<li>第二个参数 <code>id</code> 是键字段的名称；</li>
<li>第三个参数 <code>hashNode</code> 是指向要添加的结构的指针。</li>
</ul>
<h3 id="将指向哈希指针的指针传递给函数（重要）"><a href="# 将指向哈希指针的指针传递给函数（重要）" class="headerlink" title="将指向哈希指针的指针传递给函数（重要）"></a>将指向哈希指针的指针传递给函数（重要）</h3><p>在上面的例子中 <code>hashTbl</code> 是一个全局变量，但是如果调用者想将哈希指针传递给函数 <code>add_user</code> 怎么办？乍一看，您似乎可以简单地将 <code>hashTbl</code> 作为参数传递，但这行不通。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_user</span><span class="params">(HashItem *obj, <span class="type">int</span> user_id, <span class="type">char</span> *name)</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  HASH_ADD_INT(obj, id, hashNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确地，你需要 <strong> 传递一个指向哈希指针的指针</strong>（a pointer to the hash pointer）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_user</span><span class="params">(HashItem **obj, <span class="type">int</span> user_id, <span class="type">char</span> *name)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  HASH_ADD_INT(*obj, id, hashNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>必须处理「指向哈希指针的指针」的原因很简单：散列宏会修改它（换句话说，它们修改指针地址本身，而不仅仅是它指向的内容）</strong>。</p>
<p>The reason it’s necessary to deal with a pointer to the hash pointer is simple: the hash macros modify it (in other words, they modify the <em>pointer itself</em> not just what it points to).</p>
<blockquote>
<p>假设哈希表 <code>hashTbl</code> 的指针（地址）是 <code>0x7fffd69b9a10</code>，那么通过运算符 <code>&amp;</code> 可以得到存放该地址的地址，假如为 <code>0x8defd69b9a26</code>，那么后续散列宏修改了哈希指针后，我们还可以通过地址 <code>0x8defd69b9a26</code> 指向的内容（哈希表的地址）来获取最新的哈希表地址。</p>
</blockquote>
<h3 id="查找"><a href="# 查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HashItem *<span class="title function_">find_user</span><span class="params">(<span class="type">int</span> user_id)</span> &#123;</span><br><span class="line">    HashItem *hashNode = <span class="literal">NULL</span>;</span><br><span class="line">    HASH_FIND_INT(hashTbl, &amp;user_id, hashNode);  <span class="comment">/* hashNode: output pointer */</span></span><br><span class="line">    <span class="keyword">return</span> hashNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>HASH_FIND_INT</code> 函数中，</p>
<ul>
<li>第一个参数 <code>hashTbl</code> 是哈希表；</li>
<li>第二个参数是 <code>user_id</code> 的地址（一定要传递地址）；</li>
<li>第三个参数 <code>hashNode</code> 是输出变量。</li>
</ul>
<p>当可以在哈希表中找到相应键值时，返回给定键的结构到 <code>hashNode</code>，当找不到时返回 <code>NULL</code> 到 <code>hashNode</code>。也就是说可以通过判断返回值是否为 <code>NULL</code> 来判断查找的键值是否存在于哈希表中。</p>
<h3 id="替换"><a href="# 替换" class="headerlink" title="替换"></a>替换</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">replace_user</span><span class="params">(HashItem *obj, HashItem *newHashNode)</span> &#123;</span><br><span class="line">    HashItem *oldHashNode = find_user(newHashNode-&gt;id);</span><br><span class="line">    <span class="keyword">if</span> (oldHashNode) &#123;</span><br><span class="line">        HASH_REPLACE_INT(hashTbl, id, newHashNode, oldHashNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>HASH_REPLACE</code> 宏等效于 <code>HASH_ADD</code> 宏，<code>HASH_REPLACE</code> 会尝试查找和删除项目，如果找到并删除了一个项目，它将返回该项目的指针作为输出参数。</p>
<h3 id="删除"><a href="# 删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delete_user</span><span class="params">(HashItem *hashNode)</span> &#123;</span><br><span class="line">    HASH_DEL(hashTbl, hashNode);  <span class="comment">/* user: pointer to delete */</span></span><br><span class="line">    <span class="built_in">free</span>(hashNode);             <span class="comment">/* optional; it&#x27;s up to you */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>要从哈希表中删除结构，必须具有指向它的指针（如果只有键值，应该先执行 <code>HASH_FIND</code> 以获取结构的指针）。</p>
</li>
<li><p>这里 <code>hashTbl</code> 是哈希表，<code>hashNode</code> 是指向我们要从哈希表中删除的结构的指针。删除结构只是将其从哈希表中删除，并非 <code>free</code>，何时释放结构的选择完全取决于自己，<code>uthash</code> 永远不会释放您的结构。</p>
</li>
</ol>
<h3 id="迭代删除"><a href="# 迭代删除" class="headerlink" title="迭代删除"></a>迭代删除 </h3><p> 上面的「删除」只能从哈希表中删除指定的一个结构，如果想将所有结构从哈希表中删除，可以使用迭代删除操作。</p>
<p><code>HASH_ITER</code> 宏是一个删除安全的迭代构造，它扩展为一个简单的 <code>for</code> 循环。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delete_all</span><span class="params">()</span> &#123;</span><br><span class="line">    HashItem *curr = <span class="literal">NULL</span>, *tmp = <span class="literal">NULL</span>;</span><br><span class="line">    HASH_ITER(hh, hashTbl, curr, tmp) &#123;</span><br><span class="line">        HASH_DEL(hashTbl, curr);  <span class="comment">/* delete; users advances to next */</span></span><br><span class="line">        <span class="built_in">free</span>(curr);               <span class="comment">/* optional- if you want to free  */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="一次性删除"><a href="# 一次性删除" class="headerlink" title="一次性删除"></a>一次性删除 </h4><p> 如果你只想删除所有的结构（哈希结点），而不释放它们的内存空间或进行任何逐个元素的清理操作，你可以使用单个操作更高效地完成这个任务。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HASH_CLEAR(hh, hashTbl);</span><br></pre></td></tr></table></figure>

<p>之后，列表头（这里是 <code>hashTbl</code>）将被设置为 <code>NULL</code>。</p>
<blockquote>
<p>在 uthash 中，ut 是 unordered tables，即无序表。</p>
<p>上面全大写的宏，为了方便，有些也被我叫成了函数。</p>
<p>上面的代码，未做充分的指针为空判断，实际使用指针前，要先进行不为空判断。</p>
</blockquote>
<h2 id="uthash 的实践"><a href="#uthash 的实践" class="headerlink" title="uthash 的实践"></a>uthash 的实践 </h2><p> 以 <a href="https://leetcode.cn/problems/two-sum/">LeetCode 两数之和 </a> 为例，介绍 <code>uthash.h</code> 哈希表的使用。</p>
<p>题目大意：从一个数组中找出两个索引不同的数，使得它们的和等于目标值，并返回这两个数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uthash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    UT_hash_handle hh;</span><br><span class="line">&#125; HashItem;</span><br><span class="line"></span><br><span class="line">HashItem *<span class="title function_">hashFindItem</span><span class="params">(HashItem **obj, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    HashItem *pEntry = <span class="literal">NULL</span>;</span><br><span class="line">    HASH_FIND_INT(*obj, &amp;key, pEntry);</span><br><span class="line">    <span class="keyword">return</span> pEntry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hashAddItem</span><span class="params">(HashItem **obj, <span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    HashItem *pEntry = hashFindItem(obj, key);</span><br><span class="line">    <span class="keyword">if</span> (pEntry == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pEntry = (HashItem *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashItem));</span><br><span class="line">        pEntry-&gt;key = key;</span><br><span class="line">        HASH_ADD_INT(*obj, key, pEntry);</span><br><span class="line">    &#125;</span><br><span class="line">    pEntry-&gt;val = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hashFree</span><span class="params">(HashItem **obj)</span> &#123;</span><br><span class="line">    HashItem *curr = <span class="literal">NULL</span>, *tmp = <span class="literal">NULL</span>;</span><br><span class="line">    HASH_ITER(hh, *obj, curr, tmp) &#123;</span><br><span class="line">        HASH_DEL(*obj, curr);  </span><br><span class="line">        <span class="built_in">free</span>(curr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *<span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    HashItem *hashTbl = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        <span class="comment">// 重要：传入的是指向哈希指针的指针</span></span><br><span class="line">        HashItem *hashNode = hashFindItem(&amp;hashTbl, nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (hashNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            hashAddItem(&amp;hashTbl, nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        HashItem *hashNode = hashFindItem(&amp;hashTbl, target - nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (hashNode &amp;&amp; hashNode-&gt;val != i) &#123;</span><br><span class="line">            *returnSize = <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> *ans = (<span class="type">int</span> *)<span class="built_in">malloc</span>((*returnSize) * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">            ans[<span class="number">0</span>] = i, ans[<span class="number">1</span>] = hashNode-&gt;val;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，我们定义了哈希表的查找、添加、释放接口，接口中的第一个参数均为指向哈希表指针的指针（二级指针），这是必须的。</p>
<ol>
<li>首先，在进行哈希操作前，先定义了一个哈希表 <code>hashTbl</code>，他是一个 <code>HashItem</code> 类型的指针；</li>
<li>然后，将数组中的键 - 值对（索引对应的值 - 索引）依次添加到哈希表中，并使用操作符 <code>&amp;</code> 获取指向哈希指针的指针；</li>
<li>最后，经过查找后，不再使用哈希表，这时通过释放接口，将哈希表中的所有哈希结点迭代地删除并释放对应的内存空间。</li>
</ol>
<p>如果哈希表的键值不是整形，而是字符类型呢，应该怎么使用呢？可以参考 <a href="https://pursue26.github.io/posts/230925185057.html#%20 哈希表实现的字典树"> 这里 </a> 的一个例子。</p>
<blockquote>
<p>源码地址：<a href="https://github.com/troydhanson/uthash">https://github.com/troydhanson/uthash</a></p>
</blockquote>
<blockquote>
<p>英文原版用户指导：<a href="https://troydhanson.github.io/uthash/userguide.html">https://troydhanson.github.io/uthash/userguide.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之关键字介绍</title>
    <url>/posts/231214192113.html</url>
    <content><![CDATA[<p>由 ANSI 标准定义的 C 语言关键字共有 32 个。根据关键字的作用，可以将关键字分为 <strong> 数据类型关键字 </strong> 和<strong>流程控制关键字 </strong> 两大类。</p>
<span id="more"></span>

<h1 id="数据类型关键字"><a href="# 数据类型关键字" class="headerlink" title="数据类型关键字"></a>数据类型关键字 </h1><h2 id="基础数据类型（5 个）"><a href="# 基础数据类型（5 个）" class="headerlink" title="基础数据类型（5 个）"></a> 基础数据类型（5 个）</h2><ul>
<li><code>void</code>：声明函数无返回值或无参数，声明无类型指针，显式丢弃运算结果。</li>
<li><code>char</code>：字符型类型数据，属于整型数据的一种。</li>
<li><code>int</code>：整型数据，通常为编译器指定的机器字长。</li>
<li><code>float</code>：单精度浮点型数据，属于浮点数据的一种。</li>
<li><code>double</code>：双精度浮点型数据，属于浮点数据的一种。</li>
</ul>
<h2 id="类型修饰关键字（4 个）"><a href="# 类型修饰关键字（4 个）" class="headerlink" title="类型修饰关键字（4 个）"></a>类型修饰关键字（4 个）</h2><ul>
<li><code>short</code>：修饰<code>int</code>，短整型数据，可省略被修饰的<code>int</code>。</li>
<li><code>long</code>：修饰<code>int</code>，长整形数据，可省略被修饰的<code>int</code>。</li>
<li><code>signed</code>：修饰整型数据，有符号数据类型。</li>
<li><code>unsigned</code>：修饰整型数据，无符号数据类型。</li>
</ul>
<h2 id="复杂类型关键字（5 个）"><a href="# 复杂类型关键字（5 个）" class="headerlink" title="复杂类型关键字（5 个）"></a>复杂类型关键字（5 个）</h2><ul>
<li><code>struct</code>：结构体声明。</li>
<li><code>union</code>：共用体声明。</li>
<li><code>enum</code>：枚举声明</li>
<li><code>typedef</code>：声明类型别名。</li>
<li><code>sizeof</code>：得到特定类型或特定类型变量的大小。</li>
</ul>
<h2 id="存储级别关键字（6 个）"><a href="# 存储级别关键字（6 个）" class="headerlink" title="存储级别关键字（6 个）"></a>存储级别关键字（6 个）</h2><ul>
<li><code>auto</code>：指定为自动变量，由编译器自动分配及释放，通常在栈上分配。</li>
<li><code>static</code>：指定为静态变量，分配在静态变量区，修饰函数时，指定函数作用域为文件内部。</li>
<li><code>register</code>：指定为寄存器变量，建议编译器将变量存储到寄存器中使用，也可以修饰函数形参，建议编译器通过寄存器而不是堆栈传递参数。</li>
<li><code>extern</code>：指定对应变量为外部变量，即在另外的目标文件中定义，可以认为是约定由另外文件声明的对象的一个「引用」。</li>
<li><code>const</code>：与 <code>volatile</code> 合称「CV 特性」，指定变量不可被当前线程 / 进程改变（但有可能被系统或其他线程 / 进程改变）。</li>
<li><code>volatile</code>：与 <code>const</code> 合称「CV 特性」，指定变量的值有可能会被系统或其他进程 / 线程改变，强制编译器每次从内存中取得该变量的值。</li>
</ul>
<h1 id="流程控制关键字"><a href="# 流程控制关键字" class="headerlink" title="流程控制关键字"></a>流程控制关键字 </h1><h2 id="跳转结构（4 个）"><a href="# 跳转结构（4 个）" class="headerlink" title="跳转结构（4 个）"></a> 跳转结构（4 个）</h2><ul>
<li><code>return</code>：用在函数体中，返回特定值（或者是 <code>void</code> 值，即不返回值）。</li>
<li><code>continue</code>：结束当前循环，开始下一轮循环。</li>
<li><code>break</code>：跳出当前循环或 <code>switch</code> 结构。</li>
<li><code>goto</code>：无条件跳转语句。</li>
</ul>
<h2 id="分支结构（5 个）"><a href="# 分支结构（5 个）" class="headerlink" title="分支结构（5 个）"></a>分支结构（5 个）</h2><ul>
<li><code>if</code>：条件语句。</li>
<li><code>else</code>：条件语句否定分支，与 <code>if</code> 连用。</li>
<li><code>switch</code>：开关语句（多重分支语句）。</li>
<li><code>case</code>：开关语句中的分支标记。</li>
<li><code>default</code>：开关语句中的「其他」分支，可选。</li>
</ul>
<h2 id="循环结构（3 个）"><a href="# 循环结构（3 个）" class="headerlink" title="循环结构（3 个）"></a>循环结构（3 个）</h2><ul>
<li><code>for</code>：循环结构。</li>
<li><code>do</code>：循环结构，与 <code>while</code> 一起使用。</li>
<li><code>while</code>：循环结构。</li>
</ul>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/37908790">https://zhuanlan.zhihu.com/p/37908790</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之代码 TOP-K 问题</title>
    <url>/posts/240307195203.html</url>
    <content><![CDATA[<p>本文整理了 C 语言开发中的可能出现的代码问题，包括返回值处理、断言的使用、系统资源使用、内存释放、内存越界、空野指针和未初始化，并给出了必要的解释和错误示例代码。</p>
<span id="more"></span>


<h1 id="返回值处理（TOP1）"><a href="# 返回值处理（TOP1）" class="headerlink" title="返回值处理（TOP1）"></a>返回值处理（TOP1）</h1><ol>
<li><p>被调函数执行结果对业务流程有影响时，调用者却 <strong> 没有处理其返回值</strong>。</p>
<ul>
<li>若返回值是指针类型，可能导致空指针访问——如被调函数申请内存失败；</li>
<li>若返回值是多种返回值系列，可能导致缺少必要的回退——如中间某步异常退出导致的的资源泄漏。</li>
</ul>
</li>
<li><p>调用者对被调函数的返回值处理不准确，导致有隐患或问题。</p>
<ul>
<li>返回值数据类型被错误转换——如返回值为 int 类型，却被强转为 bool 类型；</li>
<li>返回值比较的目标不是该函数的返回值系列——如用函数 A 的返回值系列跟被调函数 B 的返回值作比较。</li>
</ul>
</li>
</ol>
<h1 id="断言的使用（TOP2）"><a href="# 断言的使用（TOP2）" class="headerlink" title="断言的使用（TOP2）"></a>断言的使用（TOP2）</h1><ol>
<li>使用断言错误，包括：<ul>
<li>在断言中包含非逻辑表达式——如 <code>DBGASSERT(0 == func(&amp;a, &amp;b))</code> 包含了业务逻辑；</li>
<li>对程序运行中可能发生的情况使用了断言检查。</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc -D_DEBUG_VERSION xxx.c  or  gcc xxx.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG_VERSION</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBGASSERT(expression)                                                                                        \</span></span><br><span class="line"><span class="meta">    do &#123;                                                                                                             \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!(expression)) &#123;                                                                                         \</span></span><br><span class="line"><span class="meta">            fprintf(stderr, <span class="string">&quot;Assertion failed: %s, file %s/%s:%d\n&quot;</span>, #expression, __FILE__, __FUNCTION__, __LINE__); \</span></span><br><span class="line"><span class="meta">            abort();                                                                                                 \</span></span><br><span class="line"><span class="meta">        &#125;                                                                                                            \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBGASSERT(expression) ((void)0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>断言用于对程序运行过程中 <strong> 不应该发生 </strong> 的情况进行 <strong> 检查 </strong>。<br> 条件判断用于对程序运行过程中 <strong> 可能发生 </strong> 的情况进行 <strong> 处理</strong>。</p>
</blockquote>
<h1 id="系统资源使用（TOP3）"><a href="# 系统资源使用（TOP3）" class="headerlink" title="系统资源使用（TOP3）"></a>系统资源使用（TOP3）</h1><ol>
<li>资源的申请释放不在同一层次或者不对称。</li>
<li>在成对的系统资源操作之间异常退出。</li>
<li>过早的申请资源，导致不必要的异常回退或资源泄漏等问题。</li>
<li>将申请的资源直接赋给间接变量（包括：数据结构字段、多级指针、全局变量）。</li>
</ol>
<blockquote>
<p>系统资源包括但不限于：动态内存、操作句柄（文件 / 接口）、中断、信号量。</p>
</blockquote>
<h2 id="例子（问题一）"><a href="# 例子（问题一）" class="headerlink" title="例子（问题一）"></a>例子（问题一）</h2><p>资源的申请释放不在同一层次。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag_student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span>* pcName;</span><br><span class="line">    <span class="type">char</span>* pcCard;</span><br><span class="line">&#125; STUDENT_S;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">example1_wrong</span><span class="params">(...)</span> &#123;</span><br><span class="line">    STUDENT_S* pstStu = (STUDENT_S*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(STUDENT_S));</span><br><span class="line">    DBGASSERT(<span class="literal">NULL</span> != pstStu);</span><br><span class="line">    <span class="keyword">while</span> (...) &#123;</span><br><span class="line">        ...;</span><br><span class="line">        <span class="keyword">if</span> (...) &#123;</span><br><span class="line">            <span class="built_in">free</span>(pstStu);  <span class="comment">// 资源释放不在同一层次</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...;</span><br><span class="line">    &#125;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">example1_correct</span><span class="params">(...)</span> &#123;</span><br><span class="line">    STUDENT_S* pstStu = (STUDENT_S*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(STUDENT_S));</span><br><span class="line">    DBGASSERT(<span class="literal">NULL</span> != pstStu);</span><br><span class="line">    <span class="keyword">while</span> (...) &#123;</span><br><span class="line">        ...;</span><br><span class="line">        <span class="keyword">if</span> (...) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...;</span><br><span class="line">    &#125;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="built_in">free</span>(pstStu);  <span class="comment">// 资源释放在同一层次</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的错误示例是申请资源在外层、释放资源在内层；另一种不在同一层是：定义在外层，申请资源在内层、释放资源在外层——可能导致资源泄漏或空指针问题。</p>
</blockquote>
<h2 id="例子（问题二）"><a href="# 例子（问题二）" class="headerlink" title="例子（问题二）"></a>例子（问题二）</h2><p>在成对的系统资源操作之间异常退出，异常退出前忘记释放资源。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">example2_wrong</span><span class="params">(...)</span> &#123;</span><br><span class="line">    STUDENT_S* pstStu = (STUDENT_S*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(STUDENT_S));</span><br><span class="line">    DBGASSERT(<span class="literal">NULL</span> != pstStu);</span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">if</span> (...) &#123;</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// 异常退出应释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="built_in">free</span>(pstStu);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例子（问题三）"><a href="# 例子（问题三）" class="headerlink" title="例子（问题三）"></a>例子（问题三）</h2><p>过早的申请资源，导致不必要的异常回退或资源泄漏等问题。资源申请应在合法性和前提条件满足之后再进行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> case1 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">example3_wrong</span><span class="params">(...)</span> &#123;</span><br><span class="line">    STUDENT_S* pstStu = (STUDENT_S*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(STUDENT_S));</span><br><span class="line">    DBGASSERT(<span class="literal">NULL</span> != pstStu);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">10</span> == case1) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="built_in">free</span>(pstStu);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">example3_correct</span><span class="params">(...)</span> &#123;</span><br><span class="line">    STUDENT_S* pstStu = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">10</span> == case1) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 合法性和前提条件已满足 */</span></span><br><span class="line">    pstStu = (STUDENT_S*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(STUDENT_S));</span><br><span class="line">    DBGASSERT(<span class="literal">NULL</span> != pstStu);</span><br><span class="line">    ...;</span><br><span class="line">    <span class="built_in">free</span>(pstStu);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例子（问题四）"><a href="# 例子（问题四）" class="headerlink" title="例子（问题四）"></a>例子（问题四）</h2><p>将申请的资源直接赋给间接变量（包括：数据结构字段、多级指针、全局变量），这可能会导致一些潜在的错误不能被检测工具检测到。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAC_ADDR_LEN (6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAC_LEN (14)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">example4_wrong</span><span class="params">(...)</span> &#123;</span><br><span class="line">    *ppstData = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(MAC_ADDR_LEN * <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>));</span><br><span class="line">    DBGASSERT(<span class="literal">NULL</span> != *ppstStu);</span><br><span class="line">    <span class="built_in">memcpy</span>(*ppstData, aucMacAddr, MAC_LEN);  <span class="comment">// 复制的长度大于申请的长度</span></span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上述低级错误无法通过工具检测，因为资源被直接赋给了多级指针 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">example4_correct</span><span class="params">(...)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* pcTempData = <span class="literal">NULL</span>;</span><br><span class="line">    pcTempData = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(MAC_ADDR_LEN * <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>));</span><br><span class="line">    DBGASSERT(<span class="literal">NULL</span> != pcTempData);</span><br><span class="line">    <span class="comment">/* 若这里长度书写错误，比如超长，pclint 可以触发 Warning 669 */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pcTempData, aucMacAddr, MAC_LEN);</span><br><span class="line">    *ppstData = pcTempData;  <span class="comment">// 所有操作成功或结束后，挂接资源到相应的变量或数据结构上</span></span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于数据结构的子内存，如对学生的身份证 <code>pstStu-&gt;card</code> 申请资源时，也应先将申请资源挂到局部指针变量上，万事俱备，再赋给数据结构的子内存 <code>pstStu-&gt;card = pcTempCardInfo</code>。</p>
</blockquote>
<h1 id="内存释放（TOP4）"><a href="# 内存释放（TOP4）" class="headerlink" title="内存释放（TOP4）"></a>内存释放（TOP4）</h1><ol>
<li>用不匹配的内存释放函数释放内存资源。</li>
<li>释放非法地址、内存重复释放、释放后再使用。</li>
<li>释放内存前没有先从数据结构上摘除。</li>
<li>内存资源泄漏，没有第一时间释放资源。</li>
</ol>
<p>解释（问题一）：</p>
<ul>
<li>如用结构体 B 的内存释放函数，去释放结构体 A 的指针变量动态申请的内存资源。</li>
</ul>
<p>解释（问题二）：</p>
<ul>
<li>释放非法地址：试图使用 <code>free()</code> 函数释放一个未经 <code>malloc()</code> 或类似函数分配的内存地址；</li>
<li>内存重复释放：如将内存资源传递给某接口（该接口负责内存资源的释放），这时不应再次释放内存资源；</li>
<li>释放后再使用：释放内存后，该内存块的内容和所有权已经归还给系统，再次访问这块内存会导致不可预测的结果。因此，<strong>最好在释放内存资源后，将指针变量赋值为 NULL，这样再次使用会报空指针错误</strong>。</li>
</ul>
<p>解释（问题三）：</p>
<ul>
<li>如删除链表中的节点时，先释放了对应节点的内存资源，再尝试从链表中剔除该节点。应该先剔除再释放对应节点的内存资源。</li>
</ul>
<p>解释（问题四）：</p>
<ul>
<li>如在网络收包接口中，申请了内存资源，但未正确释放，造成了内存泄漏。这样，在大流量的冲击下，短时间内会使系统可用资源耗尽，导致系统崩溃。</li>
</ul>
<h1 id="内存越界（TOP5）"><a href="# 内存越界（TOP5）" class="headerlink" title="内存越界（TOP5）"></a>内存越界（TOP5）</h1><ol>
<li>字符串、内存拷贝或清零等操作越界。</li>
<li>缓冲区空间太小导致数据溢出。</li>
<li>非法参数没有检查导致访问越界。</li>
</ol>
<h2 id="例子（问题一）-1"><a href="# 例子（问题一）-1" class="headerlink" title="例子（问题一）"></a>例子（问题一）</h2><p>字符串拷贝越界。如果以动态申请的内存资源大小为准，我们应该拷贝<code>ulLen-1</code>，但其实申请的内存资源也错了，应该是<code>ulLen+1</code>，要包含字符串末尾的<code>\0</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ulLen = <span class="built_in">strlen</span>(pcWord);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">example1_wrong</span><span class="params">(...)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* pcTemp = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(ulLen * <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>));  <span class="comment">// 少 `\0` 的位置</span></span><br><span class="line">    DBGASSERT(<span class="literal">NULL</span> != pcTemp);</span><br><span class="line">    <span class="built_in">strncpy</span>(pcTemp, pcWord, ulLen); <span class="comment">// 拷贝的字节数错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">example1_correct</span><span class="params">(...)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* pcTemp = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>((ulLen + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>));</span><br><span class="line">    DBGASSERT(<span class="literal">NULL</span> != pcTemp);</span><br><span class="line">    <span class="built_in">strncpy</span>(pcTemp, pcWord, ulLen);</span><br><span class="line">    pcTemp[ulLen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存拷贝越界，内存拷贝应 <strong> 以目的缓冲区的字节数为依据</strong>，才能实现防止访问越界</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* pcTemp = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>));</span><br><span class="line"><span class="built_in">strncpy</span>(pcTemp, pcWord, (<span class="type">unsigned</span> <span class="type">long</span>)<span class="keyword">sizeof</span>(pcWord));  <span class="comment">// wrong</span></span><br><span class="line"><span class="built_in">strncpy</span>(pcTemp, pcWord, (<span class="type">unsigned</span> <span class="type">long</span>)<span class="keyword">sizeof</span>(pcTemp));  <span class="comment">// correct</span></span><br></pre></td></tr></table></figure>

<p>内存清零错误。memset 函数的第三个参数应该是要设置的字节数，而不是数组的大小。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">DBGASSERT(<span class="literal">NULL</span> != arr);</span><br><span class="line"><span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(arr));       <span class="comment">// wrong, sizeof(arr) i.e., sizeof(int*) == 4</span></span><br><span class="line"><span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// correct</span></span><br></pre></td></tr></table></figure>

<h2 id="例子（问题二）-1"><a href="# 例子（问题二）-1" class="headerlink" title="例子（问题二）"></a>例子（问题二）</h2><p>缓冲区空间太小、字符串拼装越界。推荐使用 n 系列函数，比如 snprintf。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">example2_wrong</span><span class="params">(...)</span> &#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(name, <span class="string">&quot;name-%ld&quot;</span>, ulId);  <span class="comment">// ulong 值填充后很可能超过缓冲区大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">example2_correct</span><span class="params">(...)</span> &#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(name, <span class="number">10</span>, <span class="string">&quot;name-%ld&quot;</span>, ulId);  <span class="comment">// 限制最大填充大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="空野指针（TOP6）"><a href="# 空野指针（TOP6）" class="headerlink" title="空野指针（TOP6）"></a>空野指针（TOP6）</h1><ol>
<li>释放全局变量上的资源后没有清零全局变量。</li>
<li><strong>释放数据结构上挂接的内存后没有清零数据结构上的挂接字段</strong>。</li>
<li>访问空指针。</li>
</ol>
<h2 id="例子（问题一）-2"><a href="# 例子（问题一）-2" class="headerlink" title="例子（问题一）"></a>例子（问题一）</h2><p>释放全局变量上的资源后没有清零全局变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">DBGASSERT(<span class="literal">NULL</span> != arr);</span><br><span class="line"><span class="built_in">free</span>(arr);</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">100</span>;  <span class="comment">// 不会报错，但 free 后 arr 地址已经是野指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 正确做法 */</span></span><br><span class="line"><span class="built_in">free</span>(arr);</span><br><span class="line">arr = <span class="literal">NULL</span>;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">100</span>;  <span class="comment">// segment fault</span></span><br></pre></td></tr></table></figure>

<h2 id="例子二（问题二）"><a href="# 例子二（问题二）" class="headerlink" title="例子二（问题二）"></a>例子二（问题二）</h2><p>释放数据结构上挂接的内存后没有清零数据结构上的挂接字段。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">STUDENT_S* pstStu = (STUDENT_S*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(STUDENT_S));</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">example2_wrong</span><span class="params">(...)</span> &#123;</span><br><span class="line">    <span class="type">char</span>* pcTempCard = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">18</span> * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    DBGASSERT(<span class="literal">NULL</span> != pcTempCard);</span><br><span class="line">    pstStu-&gt;pcCard = pcTempCard;  <span class="comment">// 动态资源挂接到数据结构的字段</span></span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">if</span> (...) &#123;</span><br><span class="line">        <span class="built_in">free</span>(pcTempCard);  <span class="comment">// pstStu-&gt;pcCard 字段没有清零</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="未初始化（TOP7）"><a href="# 未初始化（TOP7）" class="headerlink" title="未初始化（TOP7）"></a>未初始化（TOP7）</h1><ol>
<li>导致访问未初始化的变量或数据结构字段或动态内存。</li>
<li>函数的入参未被初始化</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">example1_wrong</span><span class="params">(...)</span> &#123;</span><br><span class="line">    STUDENT_S stStu;</span><br><span class="line">    <span class="keyword">if</span> (...) &#123;</span><br><span class="line">        stStu.age = <span class="number">18</span>;  <span class="comment">// 条件不成立时，该字段不会初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    stStu.pcName = <span class="string">&quot;lihua&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: %d\n&quot;</span>, stStu.pcName, stStu.age);  <span class="comment">// 可能使用未初始化的字段</span></span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nr;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">example2_wrong</span><span class="params">(<span class="type">int</span> *nr)</span> &#123;</span><br><span class="line">    (*nr)++;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br><span class="line">example2_wrong(&amp;nr);  <span class="comment">// 从几开始加?</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>代码问题</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之多维数组</title>
    <url>/posts/230922143003.html</url>
    <content><![CDATA[<p>本文章主要介绍 C 语言创建多维数组的方式及其排序，包括静态多维数组、<code>malloc</code> 动态申请多维数组、指针数组的多维数组和多维结构体数组的创建。</p>
<span id="more"></span>

<h2 id="排序接口"><a href="# 排序接口" class="headerlink" title="排序接口"></a>排序接口</h2><p><code>qsort</code> 函数是 C 语言标准库中的一个排序函数，用于对数组进行快速排序。它的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qsort</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *base, </span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> nmemb, </span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> size, </span></span><br><span class="line"><span class="params">    <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>base</code>：指向需要排序的数组的第一个元素的指针。</li>
<li><code>nmemb</code>：数组中元素的个数。</li>
<li><code>size</code>：每个元素的大小（以字节为单位）。</li>
<li><code>compar</code>：指向比较函数的指针，用于指定数组元素的比较规则。</li>
</ul>
<p><code>base</code> 指定了待排序数组的首地址，再结合 <code>nmemb * size</code> 可以确定要排序的数组的范围。</p>
<p>比较函数 <code>compar</code> 的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">compar</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>a</code> 和 <code>b</code>：指向待比较的两个元素的指针。</li>
</ul>
<p>比较函数 <code>compar</code> 必须返回一个整数值，表示 <code>a</code> 和 <code>b</code> 的大小关系：</p>
<ul>
<li>如果 <code>a</code> 小于 <code>b</code>，则返回一个负整数。</li>
<li>如果 <code>a</code> 等于 <code>b</code>，则返回零。</li>
<li>如果 <code>a</code> 大于 <code>b</code>，则返回一个正整数。</li>
</ul>
<p>通过传入不同的比较函数，<code>qsort</code> 函数可以实现对不同类型的数组进行排序。</p>
<h2 id="静态多维数组"><a href="# 静态多维数组" class="headerlink" title="静态多维数组"></a>静态多维数组 </h2><h3 id="多维数组创建"><a href="# 多维数组创建" class="headerlink" title="多维数组创建"></a> 多维数组创建</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> rows = <span class="number">3</span>, cols = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> arr[rows][cols];</span><br></pre></td></tr></table></figure>

<h3 id="多维数组排序"><a href="# 多维数组排序" class="headerlink" title="多维数组排序"></a>多维数组排序 </h3><p> 按照二维数组第 0 列升序排序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">int</span> *)a)[<span class="number">0</span>] - ((<span class="type">int</span> *)b)[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入 cmp 函数指针的 arr 是一个一维指针</span></span><br><span class="line">qsort(arr, rows, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), cmp);  <span class="comment">// 快速排序</span></span><br></pre></td></tr></table></figure>

<h2 id="malloc 动态申请多维数组"><a href="#malloc 动态申请多维数组" class="headerlink" title="malloc 动态申请多维数组"></a>malloc 动态申请多维数组 </h2><h3 id="多维数组创建 -1"><a href="# 多维数组创建 -1" class="headerlink" title="多维数组创建"></a> 多维数组创建</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> rows = <span class="number">3</span>, cols = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态申请二维数组</span></span><br><span class="line"><span class="type">int</span> **arr = (<span class="type">int</span> **)<span class="built_in">malloc</span>(rows * <span class="keyword">sizeof</span>(<span class="type">int</span> *));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">    arr[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(cols * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(arr);</span><br></pre></td></tr></table></figure>

<p>释放 <code>malloc</code> 申请的多维数组时，不能直接 <code>free(arr)</code>，因为 <code>malloc</code> 和 <code>free</code> 执行次数要一致。</p>
<h3 id="多维数组排序 -1"><a href="# 多维数组排序 -1" class="headerlink" title="多维数组排序"></a>多维数组排序 </h3><p> 按照二维数组第 0 列升序排序，若相等，则按第 1 列升序排序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span> &#123;</span><br><span class="line">    <span class="comment">// a 是一个指向二维数组首行的指针</span></span><br><span class="line">    <span class="comment">// 通过类型转换和解引用操作, ap 指向了 a 所指向的整型数组的首地址</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* ap = *(<span class="type">int</span> **)a;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* bp = *(<span class="type">int</span> **)b;</span><br><span class="line">    <span class="keyword">if</span> (ap[<span class="number">0</span>] == bp[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ap[<span class="number">1</span>] - bp[<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ap[<span class="number">0</span>] - bp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入 cmp 函数指针的 arr 是一个二维指针</span></span><br><span class="line">qsort(arr, rows, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), cmp);</span><br></pre></td></tr></table></figure>

<h2 id="malloc 动态申请多维结构体数组"><a href="#malloc 动态申请多维结构体数组" class="headerlink" title="malloc 动态申请多维结构体数组"></a>malloc 动态申请多维结构体数组 </h2><h3 id="多维结构体数组创建"><a href="# 多维结构体数组创建" class="headerlink" title="多维结构体数组创建"></a> 多维结构体数组创建</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> rows = <span class="number">3</span>, cols = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">&#125; Node_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态申请二维数组</span></span><br><span class="line">Node_t **arr = (Node_t **)<span class="built_in">malloc</span>(rows * <span class="keyword">sizeof</span>(Node_t *));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">    arr[i] = (Node_t *)<span class="built_in">malloc</span>(cols * <span class="keyword">sizeof</span>(Node_t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">    <span class="comment">// 如果结构体成员中有指针且申请了空间, 则需要先释放成员的空间再释放结构体的空间</span></span><br><span class="line">    <span class="built_in">free</span>(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(arr);</span><br></pre></td></tr></table></figure>

<h3 id="多维结构体数组排序"><a href="# 多维结构体数组排序" class="headerlink" title="多维结构体数组排序"></a>多维结构体数组排序 </h3><p> 按照二维数组第 0 列的结构体成员 <code>x</code> 降序排序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// return (Node_t *)a-&gt;x - (Node_t *)b-&gt;x;   // 错误写法</span></span><br><span class="line">    <span class="keyword">return</span> ((Node_t *)a)-&gt;x - ((Node_t *)b)-&gt;x;   <span class="comment">// 正确写法 1</span></span><br><span class="line">    <span class="comment">// return (*(Node_t *)b).x - (*(Node_t *)a).x;     // 正确写法 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">qsort(arr, rows, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), cmp);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-&gt;</code> 操作符的优先级高于 <code>()</code> 操作符。</li>
</ul>
<h2 id="指针数组的多维数组"><a href="# 指针数组的多维数组" class="headerlink" title="指针数组的多维数组"></a>指针数组的多维数组 </h2><p> 使用指针数组的多维数组：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> rows = <span class="number">3</span>, cols = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* arr[rows];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cols; i++) &#123;</span><br><span class="line">    arr[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式创建的多维数组实际上是一个指针数组，每个指针指向一个一维数组，可以在运行时动态分配每个一维数组的大小（方便创建每行元素个数不同的多维数组）。</p>
<h3 id="多维数组排序 -2"><a href="# 多维数组排序 -2" class="headerlink" title="多维数组排序"></a>多维数组排序 </h3><p> 按照二维数组第 0 列降序排序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* ap = *(<span class="type">int</span> **)a;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* bp = *(<span class="type">int</span> **)b;</span><br><span class="line">    <span class="keyword">return</span> bp[<span class="number">0</span>] - ap[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入 cmp 函数指针的 arr 是一个二维指针</span></span><br><span class="line">qsort(arr, rows, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), cmp);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>多维数组</tag>
        <tag>数组排序</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之输出打印函数</title>
    <url>/posts/240103180653.html</url>
    <content><![CDATA[<p>本文汇总 C 语言中不同的数据输出（打印）函数，包括 <code>printf(), fprintf(), sprintf(), snprintf()</code> 和 <code>puts(), putchar()</code>。</p>
<span id="more"></span>

<h1 id="printf- 输出到终端"><a href="#printf- 输出到终端" class="headerlink" title="printf()输出到终端"></a>printf()输出到终端</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>功能 </strong>：将格式化的数据<strong> 打印到标准输出（终端）</strong>。</li>
<li><strong>用法 </strong>：<code>printf</code> 函数使用<strong> 格式字符串</strong> <code>format</code> 来指定输出的格式，可以包含占位符 <code>%</code> 来代表不同类型的数据。</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;My age is %d\n&quot;</span>, age);</span><br></pre></td></tr></table></figure>

<p>输出：<code>My age is 18</code></p>
<h1 id="fprintf- 输出到文件"><a href="#fprintf- 输出到文件" class="headerlink" title="fprintf()输出到文件"></a>fprintf()输出到文件</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>功能 </strong>：将格式化的数据<strong> 打印到指定的文件流</strong>。</li>
<li><strong>用法</strong>：<code>fprintf</code> 函数与 <code>printf</code> 函数类似，不同之处在于它需要指定一个文件流作为输出目标。</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *name = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(file, <span class="string">&quot;Hello, %s!\n&quot;</span>, name);</span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：在当前工作目录下创建一个名为 <code>output.txt</code> 的文件，并将字符串 <code>Hello, World!</code> 写入该文件。</p>
<h1 id="sprintf- 输出到字符串变量"><a href="#sprintf- 输出到字符串变量" class="headerlink" title="sprintf()输出到字符串变量"></a>sprintf()输出到字符串变量</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>功能 </strong>：将格式化的数据<strong> 打印到字符串 <code>str</code> 中</strong>。</li>
<li><strong>用法</strong>：<code>sprintf</code> 函数与 <code>printf</code> 函数类似，不同之处在于它将格式化的数据写入一个字符串 <code>str</code> 中。</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> message[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(message, <span class="string">&quot;My age is %d&quot;</span>, age);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, message);</span><br></pre></td></tr></table></figure>

<p>输出：<code>My age is 18</code></p>
<h1 id="snprintf- 输出到字符串变量"><a href="#snprintf- 输出到字符串变量" class="headerlink" title="snprintf()输出到字符串变量"></a>snprintf()输出到字符串变量</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">snprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>功能 </strong>：将格式化的数据<strong> 打印到指定长度 <code>size</code> 的字符串 <code>str</code> 中，防止字符串溢出</strong>。</li>
<li><strong>用法</strong>：<code>snprintf</code> 函数与 <code>sprintf</code> 函数类似，不同之处在于它需要指定字符串的大小，以避免溢出。</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> message[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="type">char</span> *name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line"><span class="built_in">snprintf</span>(message, <span class="keyword">sizeof</span>(message), <span class="string">&quot;My age is %d, my name is %s&quot;</span>, age, name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, message);</span><br></pre></td></tr></table></figure>

<p>输出：<code>My age is 18, my name is Alic</code>（只打印前 30 个字符，结束符 <code>\0</code> 算一个字符，所以打印内容中没有 <code>e</code>）</p>
<h1 id="puts- 输出字符串到终端"><a href="#puts- 输出字符串到终端" class="headerlink" title="puts()输出字符串到终端"></a>puts()输出字符串到终端</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">puts</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>功能</strong>：<code>puts()</code> 函数用于将字符串输出到标准输出（控制台）。它会自动在输出的字符串末尾添加一个换行符。</li>
<li><strong>用法 </strong>：<code>puts()</code> 函数<strong> 只能用于打印字符串</strong>，无法使用占位符打印其它数据类型的变量。</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="built_in">puts</span>(str);</span><br></pre></td></tr></table></figure>

<p>输出：<code>Hello, world!</code>（字符串末尾自动添加了一个换行符）</p>
<h1 id="putchar- 输出字符到终端"><a href="#putchar- 输出字符到终端" class="headerlink" title="putchar()输出字符到终端"></a>putchar()输出字符到终端</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">putchar</span><span class="params">(<span class="type">int</span> c)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>功能</strong>：<code>putchar()</code> 函数用于将一个字符输出到标准输出（控制台）。</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="built_in">putchar</span>(c);</span><br></pre></td></tr></table></figure>

<p>输出：<code>A</code></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>打印函数</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之大小端知识</title>
    <url>/posts/230918114841.html</url>
    <content><![CDATA[<p>在计算机中，数据在内存中的存储是以 byte 为单位的。字节序是由于 CPU 对大于一个字节的变量，在内存中的存放顺序不同而产生的。</p>
<p>不同的计算机体系结构使用不同的字节序，对于大于一个字节的变量表示，有小端模式（Little Endian, LE）和大端模式（Big Endian, BE）两种表示方式。</p>
<span id="more"></span>

<h1 id="字节序"><a href="# 字节序" class="headerlink" title="字节序"></a>字节序 </h1><h2 id="主机字节序"><a href="# 主机字节序" class="headerlink" title="主机字节序"></a> 主机字节序 </h2><p> 不同的机器的主机字节序不相同，这与 CPU 设计有关，数据的顺序是由 CPU 决定的，而与操作系统无关。我们把某个给定系统所用的字节序称为主机字节序（host byte order）。比如 x86 系列 CPU 都是 little-endian 的字节序。</p>
<ul>
<li><p>小端模式（Little Endian, LE）：高位字节存储在高位地址，而低位字节存储在低位地址。</p>
</li>
<li><p>大端模式（Big Endian, BE）：高位字节存储在低位地址，而低位字节存储在高位地址，与小端模式相反。</p>
</li>
</ul>
<p><img src="../images/le-be-endian.png" alt="大小端模式"></p>
<p>在小端字节序主机系统中进行字节序转换时，需要将低地址的字节和高地址的字节进行交换，便可得到大端字节序。</p>
<h2 id="网络字节序"><a href="# 网络字节序" class="headerlink" title="网络字节序"></a>网络字节序 </h2><p> 网络字节序是 TCP/IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。网络字节序采用 big-endian 方式。</p>
<p>由于这个原因，为了确保数据在不同主机之间传输时能够被正确解释，需要在不同字节序之间进行转换。在网络通信中，一般需要将数据转换为网络字节序进行传输。</p>
<h1 id="主机字节序类型判断"><a href="# 主机字节序类型判断" class="headerlink" title="主机字节序类型判断"></a>主机字节序类型判断 </h1><p> 可以使用共用体（union）来判断当前 CPU 平台是大端字节序还是小端字节序。这是因为共用体的特点是：使用长度最大的数据类型作为共用体的大小。</p>
<ul>
<li><p>建立一个联合类型 <code>BYTE_ORDER_UN</code>，用于测试字节序，可以通过成员 <code>byte</code> 来访问 <code>value</code> 变量的高字节和低字节。</p>
</li>
<li><p>声明一个 <code>BYTE_ORDER_UN</code> 类型的变量 <code>unByteOrder</code>，将值 <code>0xabcd</code> 赋给成员变量 <code>value</code>。由于在类型 <code>BYTE_ORDER_UN</code> 中，<code>value</code> 和 <code>byte</code> 成员 <strong> 共享一块内存</strong>，所以可以通过 <code>byte</code> 的不同成员来访问 <code>value</code> 的高字节和低字节。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">byte_order</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> byte[<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span>)];</span><br><span class="line">&#125; BYTE_ORDER_UN;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    BYTE_ORDER_UN unByteOrder;</span><br><span class="line">    unByteOrder.value = <span class="number">0xabcd</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((unByteOrder.byte[<span class="number">0</span>] == <span class="number">0xcd</span>) &amp;&amp; (unByteOrder.byte[<span class="number">1</span>] == <span class="number">0xab</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Listen endian byte order, byte[0]: 0x%x, byte[1]: 0x%x\n&quot;</span>, \</span><br><span class="line">        unByteOrder.byte[<span class="number">0</span>], unByteOrder.byte[<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>((unByteOrder.byte[<span class="number">0</span>] == <span class="number">0xab</span>) &amp;&amp; (unByteOrder.byte[<span class="number">1</span>] == <span class="number">0xcd</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Big endian byte order, byte[0]: 0x%x, byte[1]: 0x%x\n&quot;</span>, \</span><br><span class="line">        unByteOrder.byte[<span class="number">0</span>], unByteOrder.byte[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主机系统为小端字节序的测试结果：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ gcc byteOrder.c -o byteOrder</span><br><span class="line">$ ./byteOrder</span><br><span class="line">Listen endian byte order, byte[0]: 0xcd, byte[1]: 0xab</span><br></pre></td></tr></table></figure>

<h1 id="主机字节序到网络字节序转换"><a href="# 主机字节序到网络字节序转换" class="headerlink" title="主机字节序到网络字节序转换"></a>主机字节序到网络字节序转换 </h1><p><strong> 字节交换的作用是生成一个网络字节序的变量，其字节的顺序与主机类型和操作系统无关</strong>。进行网络字节序转换的时候，只要转换一次就可以了，不要进行多次转换。如果进行多次字节序的转换，最后生成的网络字节序的值可能是错误的。例如：</p>
<ul>
<li><p>对于主机为小端字节序的系统，进行两次字节序转换的过程如下图所示，经过两次转换，最终的值与最初的主机字节序相同。</p>
</li>
<li><p>对于主机为大端字节序的系统，无论进行多少次字节序的转换，最终的值与最初的主机字节序相同。</p>
</li>
</ul>
<p><img src="../images/htos-conversion.png" alt="小端系统中的变量多次字节序转换"></p>
<p>下面的例子是对 16 位数值和 32 位数值进行字节序转换，每种类型的数值进行两次转换，最后打印结果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITS16 (16)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITS32 (32)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">two_bytes_order</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> byte[<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span>)];</span><br><span class="line">&#125; TWO_BYTES_ORDER_UN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">four_bytes_order</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> byte[<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span>)];</span><br><span class="line">&#125; FOUR_BYTES_ORDER_UN;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">showValue</span><span class="params">(<span class="type">void</span> *begin, <span class="type">int</span> flag)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p = (<span class="type">unsigned</span> <span class="type">char</span> *)begin;</span><br><span class="line">    <span class="type">int</span> byteNums = flag &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; byteNums; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%x (%p) &quot;</span>, *(p + i), p + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    TWO_BYTES_ORDER_UN v16_orig, v16_turn1, v16_turn2;</span><br><span class="line">    FOUR_BYTES_ORDER_UN v32_orig, v32_turn1, v32_turn2;</span><br><span class="line"></span><br><span class="line">    v16_orig.value = <span class="number">0xabcd</span>;</span><br><span class="line">    v16_turn1.value = htons(v16_orig.value);</span><br><span class="line">    v16_turn2.value = htons(v16_turn1.value);</span><br><span class="line"></span><br><span class="line">    v32_orig.value = <span class="number">0x12345678</span>;</span><br><span class="line">    v32_turn1.value = htonl(v32_orig.value);</span><br><span class="line">    v32_turn2.value = htonl(v32_turn1.value);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;16bits host to network byte order change:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\torig:    &quot;</span>);</span><br><span class="line">    showValue(v16_orig.byte, BITS16);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t1 times: &quot;</span>);</span><br><span class="line">    showValue(v16_turn1.byte, BITS16);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t2 times: &quot;</span>);</span><br><span class="line">    showValue(v16_turn2.byte, BITS16);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;32bits host to network byte order change:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\torig:    &quot;</span>);</span><br><span class="line">    showValue(v32_orig.byte, BITS32);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t1 times: &quot;</span>);</span><br><span class="line">    showValue(v32_turn1.byte, BITS32);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t2 times: &quot;</span>);</span><br><span class="line">    showValue(v32_turn2.byte, BITS32);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小端模式到网络字节序转换的测试结果：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ gcc byteOrder2.c -o byteOrder2</span><br><span class="line">$ ./byteOrder2</span><br><span class="line">16bits host to network byte order change:</span><br><span class="line">        orig:    cd (0x7ffcd6ad66de) ab (0x7ffcd6ad66df)</span><br><span class="line">        1 times: ab (0x7ffcd6ad66dc) cd (0x7ffcd6ad66dd)</span><br><span class="line">        2 times: cd (0x7ffcd6ad66da) ab (0x7ffcd6ad66db)</span><br><span class="line">32bits host to network byte order change:</span><br><span class="line">        orig:    78 (0x7ffcd6ad66d0) 56 (0x7ffcd6ad66d1) 34 (0x7ffcd6ad66d2) 12 (0x7ffcd6ad66d3)</span><br><span class="line">        1 times: 12 (0x7ffcd6ad66c8) 34 (0x7ffcd6ad66c9) 56 (0x7ffcd6ad66ca) 78 (0x7ffcd6ad66cb)</span><br><span class="line">        2 times: 78 (0x7ffcd6ad66c0) 56 (0x7ffcd6ad66c1) 34 (0x7ffcd6ad66c2) 12 (0x7ffcd6ad66c3)</span><br></pre></td></tr></table></figure>

<p>16 位变量 0xabcd 在内存中的表示方式为 cd 在前、ab 在后；进行一次字节序转换后变为 ab 在前，cd 在后。在进行第一次转换后字节序发生了变化，而进行第二次字节序转换后与原始的排列方式一致。</p>
<h1 id="大小端的转换"><a href="# 大小端的转换" class="headerlink" title="大小端的转换"></a>大小端的转换 </h1><p> 上面的代码中 <code>htons</code> 和 <code>htonl</code>，分别给出了主机字节序到网络字节序的 <code>short</code> 和 <code>long</code> 类型的转换接口。那么，这个接口是如何实现大小端转换的呢？</p>
<p><strong>通过位运算的方式来实现大小端的转换</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">little_endian_to_big_endian_4bytes</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((value &amp; <span class="number">0x000000ff</span>) &lt;&lt; <span class="number">24</span>) | ((value &amp; <span class="number">0x0000ff00</span>) &lt;&lt; <span class="number">8</span>) | </span><br><span class="line">           ((value &amp; <span class="number">0x00ff0000</span>) &gt;&gt; <span class="number">8</span>) | ((value &amp; <span class="number">0xff000000</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">little_endian_to_big_endian_2bytes</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((value &amp; <span class="number">0x00ff</span>) &lt;&lt; <span class="number">8</span>) | ((value &amp; <span class="number">0xff00</span>) &gt;&gt; <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> little_value2 = <span class="number">0xabcd</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> little_value4 = <span class="number">0x12345678</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> big_value2 = little_endian_to_big_endian_2bytes(little_value2);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> big_value4 = little_endian_to_big_endian_4bytes(little_value4);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;LE2 value: 0x%04x\n&quot;</span>, little_value2);  <span class="comment">// LE2 value: 0xabcd</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;BE2 value: 0x%04x\n&quot;</span>, big_value2);  <span class="comment">// BE2 value: 0xcdab</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;LE4 value: 0x%08x\n&quot;</span>, little_value4);  <span class="comment">// LE4 value: 0x12345678</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;BE4 value: 0x%08x\n&quot;</span>, big_value4);  <span class="comment">// BE4 value: 0x78563412</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="多变量存储在连续内存中的字节序转换"><a href="# 多变量存储在连续内存中的字节序转换" class="headerlink" title="多变量存储在连续内存中的字节序转换"></a>多变量存储在连续内存中的字节序转换 </h1><p> 示例 1：两个 2 字节变量存储在连续的内存中，与一个 4 字节变量存储在连续的内存中，从小端主机字节序转换为大端网络字节序后的结果一样吗？一样的！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">four_bytes_order</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> val1;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> val2;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> val3;</span><br><span class="line">&#125; FOUR_BYTES_ORDER_S;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITS16 (16)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITS32 (32)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">showValue</span><span class="params">(<span class="type">void</span> *begin, <span class="type">int</span> flag)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p = (<span class="type">unsigned</span> <span class="type">char</span> *)begin;</span><br><span class="line">    <span class="type">int</span> byteNums = flag &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; byteNums; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%x (%p) &quot;</span>, *(p + i), p + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    FOUR_BYTES_ORDER_S sOrig, sTurn;</span><br><span class="line">    </span><br><span class="line">    sOrig.val1 = <span class="number">0x1234</span>;</span><br><span class="line">    sOrig.val2 = <span class="number">0x5678</span>;</span><br><span class="line">    sTurn.val1 = htons(sOrig.val1);</span><br><span class="line">    sTurn.val2 = htons(sOrig.val2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;16 + 16 host to network byte order change:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\thost:    &quot;</span>);</span><br><span class="line">    showValue(&amp;sOrig.val1, BITS32);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\tnetwork: &quot;</span>);</span><br><span class="line">    showValue(&amp;sTurn.val1, BITS32);</span><br><span class="line"></span><br><span class="line">    sOrig.val3 = <span class="number">0x12345678</span>;</span><br><span class="line">    sTurn.val3 = htonl(sOrig.val3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;32 host to network byte order change:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\thost:    &quot;</span>);</span><br><span class="line">    showValue(&amp;sOrig.val3, BITS32);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\tnetwork: &quot;</span>);</span><br><span class="line">    showValue(&amp;sTurn.val3, BITS32);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上述连续内存的两个 2 字节变量和一个 4 字节变量，转换成的网络字节序都是 <code>0x12345678</code>：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ gcc byteOrder2.c -o byteOrder3</span><br><span class="line">$ ./byteOrder3</span><br><span class="line">16 + 16 host to network byte order change:</span><br><span class="line">        host:    34 (0x7fffd69b9a10) 12 (0x7fffd69b9a11) 78 (0x7fffd69b9a12) 56 (0x7fffd69b9a13)</span><br><span class="line">        network: 12 (0x7fffd69b9a00) 34 (0x7fffd69b9a01) 56 (0x7fffd69b9a02) 78 (0x7fffd69b9a03)</span><br><span class="line">32 host to network byte order change:</span><br><span class="line">        host:    78 (0x7fffd69b9a18) 56 (0x7fffd69b9a19) 34 (0x7fffd69b9a1a) 12 (0x7fffd69b9a1b)</span><br><span class="line">        network: 12 (0x7fffd69b9a08) 34 (0x7fffd69b9a09) 56 (0x7fffd69b9a0a) 78 (0x7fffd69b9a0b)</span><br></pre></td></tr></table></figure>

<p>示例 2：一个变量 <code>0x12345678abcd9876</code>，分别以 <code>short + long + short</code> 和 <code>long + long</code> 变量存储在一个连续内容中，那么两种存储的小端主机字节序和大端网络字节序在内存中的存储的值顺序一致吗？大端网络字节序是一致的！</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">val_le = 0x12345678abcd9876</span><br><span class="line"></span><br><span class="line">short + long + short</span><br><span class="line">    a = 0x1234</span><br><span class="line">    b = 0x5678abcd</span><br><span class="line">    c = 0x9876</span><br><span class="line"></span><br><span class="line">分别给出其主机序和网络序：</span><br><span class="line">    内存低地址 -----------------------&gt; 内存高地址 </span><br><span class="line">    小端主机序：34 12 | cd ab 78 56 | 76 98</span><br><span class="line">    大端网络序：12 34 | 56 78 ab cd | 98 76</span><br><span class="line"></span><br><span class="line">long + long</span><br><span class="line">    d = 0x12345678</span><br><span class="line">    e = 0xabcd9876</span><br><span class="line"></span><br><span class="line"> 分别给出其主机序和网络序：</span><br><span class="line">    内存低地址 -----------------------&gt; 内存高地址</span><br><span class="line">    主机序：78 56 34 12 | 76 98 cd ab</span><br><span class="line">    网络序：12 34 56 78 | ab cd 98 76</span><br></pre></td></tr></table></figure>

<p>可以看出, 两种组合变量的主机序到网络序转换后的结果是一致的！</p>
<blockquote>
<p>参考：</p>
<ol>
<li><a href="https://blog.51cto.com/u_15249901/4893764">https://blog.51cto.com/u_15249901/4893764</a></li>
<li><a href="https://blog.csdn.net/Jmilk/article/details/106898871">https://blog.csdn.net/Jmilk/article/details/106898871</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>大小端</tag>
        <tag>字节序</tag>
        <tag>网络字节序</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之锁与原子操作基础</title>
    <url>/posts/230921094127.html</url>
    <content><![CDATA[<h2 id="常见锁介绍"><a href="# 常见锁介绍" class="headerlink" title="常见锁介绍"></a>常见锁介绍 </h2><p> 在 C 语言中，常见的用于解决多线程访问数据的锁包括互斥锁、读写锁、条件变量、自旋锁、屏蔽等。</p>
<span id="more"></span>

<ol>
<li><p>互斥锁（mutex）：互斥锁是一种 <strong> 最基本的锁机制 </strong>，用于<strong> 保护共享资源</strong>，防止多个线程同时访问和修改同一个资源。当一个线程持有了互斥锁后，其他线程需要等待该线程释放锁之后才能访问共享资源。</p>
</li>
<li><p>读写锁（read-write lock）：读写锁是一种 <strong> 特殊的锁机制 </strong>，它允许多个线程同时读取共享资源，但是<strong> 只允许一个线程写入共享资源</strong>。这种锁可以提高读取操作的并发度，同时保证写入操作的正确性和一致性。如果一个线程获取了写锁，其他线程就必须等待它释放锁后才能继续访问；如果一个线程获取了读锁，其他线程也可以获取读锁并访问资源。</p>
</li>
<li><p>条件变量（condition variable）：条件变量是一种 <strong> 用于线程之间通信的同步机制</strong>，它允许线程在某个条件成立时才能继续执行。通常与互斥锁一起使用，当条件变量不满足时，线程释放互斥锁并等待条件变量被激活（通过另一个线程来激活条件变量）；当条件变量满足时，通知线程重新获取互斥锁并继续执行。</p>
</li>
<li><p>自旋锁（spinlock）：自旋锁是一种 <strong> 忙等待锁机制 </strong>，当一个线程尝试获取锁时，如果锁已经被占用，它会一直循环等待直到锁被释放。<strong> 自旋锁适用于锁的持有时间很短的情况</strong>，因为长时间占用 CPU 会影响系统性能。</p>
</li>
<li><p>屏障（barrier）：屏障是一种 <strong> 用于多线程协同的同步机制 </strong>，它允许多个线程在某个点上等待，直到所有线程都到达该点后再继续执行。屏障通常用于<strong> 一组线程 </strong> 需要在某个点进行 <strong> 同步操作 </strong> 的情况，例如多线程排序算法。</p>
</li>
</ol>
<blockquote>
<p>需要根据具体的应用场景选择合适的锁。</p>
</blockquote>
<h2 id="互斥锁"><a href="# 互斥锁" class="headerlink" title="互斥锁"></a>互斥锁 </h2><p> 互斥锁原理：互斥锁属于 sleep-waiting 类型的锁。例如，在一个双核的机器上有两个线程（线程 A 和线程 B），它们分别运行在 Core0 和 Core1 上。假设线程 A 想要通过 <code>pthread_mutex_lock</code> 操作去得到一个临界区的锁，而此时这个锁正被线程 B 所持有，那么线程 A 就会被阻塞，Core0 会在此时进行上下文切换（Context Switch）将线程 A<strong>置于等待队列中</strong>，此时 Core0 就可以运行其它的任务而不必进行忙等待。</p>
<p>互斥锁的实现：通常使用了操作系统提供的原子操作或者硬件提供的锁机制，保证锁的正确性和高效性。</p>
<p>互斥锁有两种类型：递归锁和非递归锁。递归锁允许同一线程在不释放锁的情况下多次获取锁，而非递归锁不允许这种情况发生。</p>
<p>互斥锁使用场景：因互斥锁会引起线程的切换，效率较低；使用互斥锁会引起线程阻塞等待，不会一直占用着 CPU。因此，当锁的内容较多、切换不频繁时，建议使用互斥锁。</p>
<p>互斥锁使用笔记：互斥锁的使用非常简单，主要包括以下几个步骤：</p>
<ul>
<li>定义互斥锁变量，一般使用 <code>pthread_mutex_t</code> 类型；</li>
<li>在需要保护的代码段前调用 <code>pthread_mutex_lock</code> 函数获取锁；</li>
<li>在代码段执行完毕后调用 <code>pthread_mutex_unlock</code> 函数释放锁；</li>
<li>释放锁之后其他线程就可以获取锁并访问共享资源。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化互斥锁</span></span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在需要保护的代码块前加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="comment">// 访问共享资源</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 访问完毕后解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在使用完互斥锁后销毁</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br></pre></td></tr></table></figure>

<h2 id="读写锁"><a href="# 读写锁" class="headerlink" title="读写锁"></a>读写锁 </h2><p> 读写锁的实现：通常使用了计数器和互斥锁等机制，通过控制读写访问的次数和顺序来保证数据的正确性和一致性。</p>
<p>读写锁使用笔记：读写锁的使用也非常简单，主要包括以下几个步骤：</p>
<ul>
<li>定义读写锁变量，一般使用 <code>pthread_rwlock_t</code> 类型；</li>
<li>在需要读取共享资源的代码段前调用 <code>pthread_rwlock_rdlock</code> 函数获取读锁；</li>
<li>在需要写入共享资源的代码段前调用 <code>pthread_rwlock_wrlock</code> 函数获取写锁；</li>
<li>在代码段执行完毕后调用 <code>pthread_rwlock_unlock</code> 函数释放锁；</li>
<li>释放锁之后其他线程就可以获取锁并访问共享资源。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock = PTHREAD_RWLOCK_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化读写锁</span></span><br><span class="line">pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在需要读取共享资源的代码块前加读锁</span></span><br><span class="line">pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line"><span class="comment">// 读取共享资源</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 读取完毕后释放读锁</span></span><br><span class="line">pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在需要写入共享资源的代码块前加写锁</span></span><br><span class="line">pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line"><span class="comment">// 写入共享资源</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 写入完毕后释放写锁</span></span><br><span class="line">pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在使用完读写锁后销毁</span></span><br><span class="line">pthread_rwlock_destroy(&amp;rwlock);</span><br></pre></td></tr></table></figure>

<h2 id="自旋锁"><a href="# 自旋锁" class="headerlink" title="自旋锁"></a>自旋锁 </h2><p> 自旋锁原理：自旋锁属于 busy-waiting 类型的锁。例如，在一个双核的机器上有两个线程（线程 A 和线程 B），它们分别运行在 Core0 和 Core1 上。如果线程 A 是使用 <code>pthread_spin_lock</code> 操作去请求锁，那么线程 A 就会一直在 Core0 上进行忙等待并 <strong> 不停的进行 </strong> 锁请求，直到得到这个锁为止。自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就 <strong> 一直循环 </strong> 在那里看是否该自旋锁的保持者已经释放了锁。</p>
<p>自旋锁使用场景：</p>
<ul>
<li><p>自旋锁的作用是为了解决某项资源的 <strong> 互斥使用</strong>。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁。因此，如果锁的内容较少、阻塞的时间较短，使用自旋锁比较好。</p>
</li>
<li><p>自旋锁在未获得锁的情况下，一直运行（自旋），占用着 CPU，如果不能在很短的时间内获得锁，这无疑会使 CPU 效率降低。因此，要慎重使用自旋锁，<strong>自旋锁只有在内核可抢占式或 SMP 的情况下才真正需要</strong>。在单 CPU 且不可抢占式的内核下，自旋锁的操作为空操作。自旋锁适用于锁使用者保持锁时间比较短的情况下。</p>
</li>
</ul>
<p>自旋锁使用笔记：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义自旋锁</span></span><br><span class="line"><span class="type">pthread_spinlock_t</span> spinlock = PTHREAD_PROCESS_PRIVATE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化自旋锁</span></span><br><span class="line">pthread_spin_init(&amp;spinlock, PTHREAD_PROCESS_PRIVATE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁，如果锁已被其他线程占用，则该函数会一直循环忙等待直到获取到锁</span></span><br><span class="line">pthread_spin_lock(&amp;spinlock);</span><br><span class="line"><span class="comment">// 访问共享资源</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 解锁，使其他线程可以获取锁并访问共享资源</span></span><br><span class="line">pthread_spin_unlock(&amp;spinlock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁自旋锁</span></span><br><span class="line">pthread_spin_destroy(&amp;lock);</span><br></pre></td></tr></table></figure>

<h2 id="条件变量"><a href="# 条件变量" class="headerlink" title="条件变量"></a>条件变量 </h2><p> 条件变量（condition variable）：条件变量是一种 <strong> 用于线程之间通信的同步机制</strong>，它允许线程在某个条件成立时才能继续执行。通常与互斥锁一起使用，当条件变量不满足时，线程释放互斥锁并等待条件变量被激活（通过另一个线程来激活条件变量）；当条件变量满足时，通知线程重新获取互斥锁并继续执行。</p>
<p>条件变量使用笔记：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义互斥锁和定义条件变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化条件变量和自旋锁</span></span><br><span class="line">pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (条件不满足预期条件) &#123;</span><br><span class="line">    <span class="comment">// 等待条件变量通知</span></span><br><span class="line">    pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件满足，访问共享资源</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在使用完条件变量后销毁</span></span><br><span class="line">pthread_cond_destroy(&amp;cond);</span><br><span class="line"><span class="comment">// 在使用完互斥锁后销毁</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在其他线程中通知条件变量</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="comment">// 访问共享资源</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 解锁后再发送通知</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件满足，发送条件变量通知</span></span><br><span class="line">pthread_cond_signal(&amp;cond);</span><br></pre></td></tr></table></figure>

<h3 id="生产消费者同步示例代码"><a href="# 生产消费者同步示例代码" class="headerlink" title="生产消费者同步示例代码"></a>生产消费者同步示例代码 </h3><p> 一个生产者、消费者同步的多线程示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE (4)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> buffer[BUFFER_SIZE];</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 预期条件是 buffer 不能满（当 buffer 满时为条件不满足预期）</span></span><br><span class="line">        <span class="keyword">while</span> (count == BUFFER_SIZE) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        buffer[count++] = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Producer produced: %d\n&quot;</span>, i);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        pthread_cond_signal(&amp;cond);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 预期条件是 buffer 不能空（当 buffer 空时为条件不满足预期）</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> value = buffer[--count];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Consumer consumed: %d\n&quot;</span>, value);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        pthread_cond_signal(&amp;cond);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> producer_thread, consumer_thread;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;producer_thread, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;consumer_thread, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(producer_thread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(consumer_thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例代码中，有一个容量为 4 的缓冲区，生产者线程负责往缓冲区中添加数据，消费者线程负责从缓冲区中取出数据。使用互斥锁和条件变量来保证生产者和消费者的同步。</p>
<p>生产者线程通过加锁后检查缓冲区是否已满，如果已满则等待条件变量通知，否则将数据添加到缓冲区，并发送条件变量通知消费者线程。消费者线程通过加锁后检查缓冲区是否为空，如果为空则等待条件变量通知，否则从缓冲区中取出数据，并发送条件变量通知生产者线程。</p>
<blockquote>
<p>注意，生产者和消费者线程之间的同步是通过互斥锁和条件变量来实现的。互斥锁用于保护共享资源，条件变量用于线程间的通信和同步。</p>
</blockquote>
<p>一种可能的运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Producer produced (from buffer index: 0): 0</span><br><span class="line">Producer produced (from buffer index: 1): 1</span><br><span class="line">Consumer consumed (from buffer index: 1): 1</span><br><span class="line">Consumer consumed (from buffer index: 0): 0</span><br><span class="line">Producer produced (from buffer index: 0): 2</span><br><span class="line">Producer produced (from buffer index: 1): 3</span><br><span class="line">Producer produced (from buffer index: 2): 4</span><br><span class="line">Consumer consumed (from buffer index: 2): 4</span><br><span class="line">Consumer consumed (from buffer index: 1): 3</span><br><span class="line">Consumer consumed (from buffer index: 0): 2</span><br><span class="line">[root@localhost del]#</span><br><span class="line">[root@localhost del]# ./a.out</span><br><span class="line">Producer produced (from buffer index: 0): 0</span><br><span class="line">Producer produced (from buffer index: 1): 1</span><br><span class="line">Producer produced (from buffer index: 2): 2</span><br><span class="line">Producer produced (from buffer index: 3): 3</span><br><span class="line">Consumer consumed (from buffer index: 3): 3</span><br><span class="line">Consumer consumed (from buffer index: 2): 2</span><br><span class="line">Consumer consumed (from buffer index: 1): 1</span><br><span class="line">Consumer consumed (from buffer index: 0): 0</span><br><span class="line">Producer produced (from buffer index: 0): 4</span><br><span class="line">Consumer consumed (from buffer index: 0): 4</span><br><span class="line">[root@localhost del]#</span><br></pre></td></tr></table></figure>

<h2 id="屏障"><a href="# 屏障" class="headerlink" title="屏障"></a>屏障 </h2><p> 屏障（barrier）：屏障是一种 <strong> 用于多线程协同的同步机制 </strong>，它允许多个线程在某个点上等待，直到所有线程都到达该点后再继续执行。屏障通常用于<strong> 一组线程 </strong> 需要在某个点进行 <strong> 同步操作 </strong> 的情况，例如多线程排序算法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义屏障</span></span><br><span class="line"><span class="type">pthread_barrier_t</span> barrier;</span><br><span class="line"><span class="type">int</span> thread_nums = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化屏障</span></span><br><span class="line">pthread_barrier_init(&amp;barrier, <span class="literal">NULL</span>, thread_nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在每个线程中执行以下代码</span></span><br><span class="line">pthread_barrier_wait(&amp;barrier); <span class="comment">// 等待屏障</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有线程都到达屏障后，继续执行以下代码</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在使用完屏障后销毁</span></span><br><span class="line">pthread_barrier_destroy(&amp;barrier);</span><br></pre></td></tr></table></figure>

<h3 id="屏蔽实现线程同步示例代码"><a href="# 屏蔽实现线程同步示例代码" class="headerlink" title="屏蔽实现线程同步示例代码"></a>屏蔽实现线程同步示例代码 </h3><p> 下面是一个完整的示例代码，演示了如何使用 <code>pthread</code> 库中的屏障实现线程同步：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义屏障</span></span><br><span class="line"><span class="type">pthread_barrier_t</span> barrier;</span><br><span class="line"><span class="type">int</span> thread_nums = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 线程执行的一些操作...</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld operation\n&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待屏障</span></span><br><span class="line">    pthread_barrier_wait(&amp;barrier);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有线程都到达屏障后，继续执行以下代码</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld continues after the barrier\n&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程执行的其他操作...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[thread_nums];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化屏障</span></span><br><span class="line">    pthread_barrier_init(&amp;barrier, <span class="literal">NULL</span>, thread_nums);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; thread_nums; i++) &#123;</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, thread_func, (<span class="type">void</span>*)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_nums; i++) &#123;</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁屏障</span></span><br><span class="line">    pthread_barrier_destroy(&amp;barrier);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例代码中，我们定义了一个屏障 <code>pthread_barrier_t</code> 和一个线程数 <code>thread_nums</code>。在主函数中，</p>
<ul>
<li>首先调用 <code>pthread_barrier_init</code> 函数初始化屏障。</li>
<li>然后，创建指定数量的线程，并通过 <code>pthread_create</code> 函数将线程函数 <code>thread_func</code> 分配给每个线程。</li>
<li>在线程函数中，线程首先执行一些操作，然后调用 <code>pthread_barrier_wait</code> 函数等待屏障。<strong>当所有线程都到达屏障后，屏障解除，所有线程继续执行后续的代码</strong>。</li>
<li>最后，我们使用 <code>pthread_join</code> 等待所有线程结束，并使用 <code>pthread_barrier_destroy</code> 销毁屏障。</li>
</ul>
<h2 id="原子操作"><a href="# 原子操作" class="headerlink" title="原子操作"></a>原子操作 </h2><p> 所谓原子操作，就是该操作绝不会在执行完毕前被任何其他任务或事件打断，也就说，它是 <strong> 最小的执行单位</strong>，不可能有比它更小的执行单位。因此这里的原子实际是使用了物理学里的物质微粒的概念。</p>
<p>原子操作需要硬件的支持，因此是架构相关的，其 API 和原子类型的定义都定义在内核源码树的 <code>include/asm/atomic.h</code> 文件中，它们 <strong> 都使用汇编语言实现，因为 C 语言并不能实现这样的操作</strong>。</p>
<p>原子操作主要用于实现资源计数，很多引用计数（Reference Count, refcnt）就是通过原子操作实现的。</p>
<h2 id="总结分析"><a href="# 总结分析" class="headerlink" title="总结分析"></a>总结分析 </h2><p> 互斥锁（Mutex lock），sleep-waiting 类型的锁：与自旋锁相比它需要消耗大量的系统资源来建立锁；随后当线程被阻塞等待时，线程的调度状态被修改，并且线程被加入等待线程队列；最后当锁可用时，在获取锁之前，线程会被从等待队列取出并更改其调度状态；但是在线程被阻塞期间，它不消耗 CPU 资源。</p>
<p>互斥锁适用于那些可能会阻塞很长时间的场景：</p>
<ul>
<li>临界区有 IO 操作</li>
<li>临界区代码复杂或者循环量大</li>
<li>临界区竞争非常激烈</li>
<li>单核处理器</li>
</ul>
<p>自旋锁（Spin lock），busy-waiting 类型的锁：对于自旋锁来说，它只需要消耗很少的资源来建立锁；随后当线程被阻塞时，它就会一直重复检查看锁是否可用了，也就是说当自旋锁处于等待状态时它会一直消耗 CPU 时间。  </p>
<p>自旋锁适用于那些仅需要阻塞很短时间的场景。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>锁</tag>
        <tag>原子操作</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 笔记之函数 &amp; 包 &amp; 判断 &amp; 循环</title>
    <url>/posts/230909120145.html</url>
    <content><![CDATA[<h2 id="Go 语言学习笔记 -5：函数"><a href="#Go 语言学习笔记 -5：函数" class="headerlink" title="Go 语言学习笔记 -5：函数"></a>Go 语言学习笔记 -5：函数</h2><ol>
<li>函数声明语法：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functionname</span><span class="params">(parametername1 <span class="keyword">type</span>, parametername2 <span class="keyword">type</span>)</span></span> returntype &#123;  </span><br><span class="line">    <span class="comment">// 函数体（具体实现的功能）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>如果有连续若干个参数，它们的类型一致，那么我们无须一一罗列，只需在最后一个参数后添加该类型。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functionname</span><span class="params">(parametername1, parametername2 <span class="keyword">type</span>)</span></span> returntype &#123;  </span><br><span class="line">    <span class="comment">// 函数体（具体实现的功能）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Go 语言支持一个函数可以有 <strong> 多个返回值</strong>。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functionname</span><span class="params">(para1 type1, para2 type2)</span></span> (returntype1, returntype2, ...) &#123;</span><br><span class="line">    <span class="comment">// 函数体（具体实现的功能）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<ol start="4">
<li><strong>命名返回值 </strong>：从函数中可以返回一个命名值。一旦命名了返回值，可以认为<strong> 这些值在函数第一行就被声明为变量了</strong>，在函数 return 时不必再跟随命名值。如<code>area, perimeter</code>：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rectProps</span><span class="params">(length, width <span class="type">float64</span>)</span></span> (area, perimeter <span class="type">float64</span>) &#123;  </span><br><span class="line">    area = length * width</span><br><span class="line">    perimeter = (length + width) * <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// 不需要明确指定返回值，默认返回 area, perimeter 的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>空白符</strong>：<code>_</code> 在 Go 中被用作空白符，可以用作表示任何类型的任何值。</li>
</ol>
<p><code>area, _ := rectProps(10.8, 5.6) // 返回值周长被丢弃</code>。</p>
<hr>
<h2 id="Go 语言学习笔记 -6：包"><a href="#Go 语言学习笔记 -6：包" class="headerlink" title="Go 语言学习笔记 -6：包"></a>Go 语言学习笔记 -6：包</h2><ol>
<li><p><code>package packagename</code> 指定了某一源文件属于一个包，它应该放在每一个源文件的第一行。</p>
</li>
<li><p><code>main</code> 包和自定义包目录结构（属于某一个包的源文件都应该放置于一个单独命名的文件夹里，且应该用包名命名文件夹名）：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">    geometry  <span class="comment">// 自定义 main 包</span></span><br><span class="line">        geometry.<span class="keyword">go</span> <span class="comment">// main 函数</span></span><br><span class="line">        rectangle <span class="comment">// 自定义包，文件名为包名</span></span><br><span class="line">            rectprops.<span class="keyword">go</span> <span class="comment">// 属于 rectangle 包的源文件</span></span><br><span class="line">bin</span><br><span class="line">    <span class="comment">// 通过执行 go build geometry/geometry.go 编译得到 </span></span><br><span class="line">    geometry (Linux)</span><br><span class="line">    geometry.exe (Windows)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>导入自定义包：<code>import packagepath</code>，必须指定自定义包 <code>packagename</code> 相对于工作区 <code>src</code> 文件夹的相对路径，如：<code>import &quot;geometry/rectangle&quot;</code>。</p>
</li>
<li><p>导出名字：在 Go 中，任何 <strong> 以大写字母开头的变量或者函数都是被导出的名字，其它包只能访问被导出的函数和变量</strong>（即，如果想在包外访问一个函数，它应该首首字母大写）。</p>
</li>
<li><p><code>init</code> 函数：所有包都可以包含一个 <code>init</code> 函数，<code>init</code> 函数不应该有任何返回值类型和参数。</p>
</li>
</ol>
<ul>
<li><p>包的初始化顺序：1）首先初始化 <strong> 被导入的 </strong> 包；2）然后初始化 <strong> 包级别（package level）的变量 </strong>；3）紧接着<strong> 调用 <code>init</code> 函数</strong>，按照编译器解析它们的顺序进行调用。</p>
</li>
<li><p>如果一个包导入了另一个包，会先初始化 <strong> 被导入的 </strong> 包。</p>
</li>
<li><p>尽管一个包可能会被导入多次，但是它们只会被初始化一次。</p>
</li>
</ul>
<ol start="6">
<li>空白标识符导入包中的使用：导入了包，却不在代码中使用它，这在 Go 中是非法的，会抛出 <code>xxx.go:6: imported and not used: packagename_yyy</code>。</li>
</ol>
<ul>
<li><p>为了避免这种程序错误，通常会在函数外调用其中的一个函数，并将返回值赋给 <code>_</code> 变量，把这一操作称为 <code> 错误屏蔽器</code>。</p>
</li>
<li><p>同时，有时我们并不想使用导入的包中的任一函数或变量，只是为了 <strong> 确保它进行初始化</strong>，这种情况可以使用空白标识符 <code>_</code>，如 <code>import _ &quot;geometry/rectangle&quot;</code>。这样在不调用包中的函数或变量时，也不会报错。</p>
</li>
</ul>
<hr>
<h2 id="Go 语言学习笔记 -7：if-else"><a href="#Go 语言学习笔记 -7：if-else" class="headerlink" title="Go 语言学习笔记 -7：if-else"></a>Go 语言学习笔记 -7：if-else</h2><ol>
<li>即使 <code>if</code> 状态下仅有一条语句，也必须加 <code>&#123; &#125;</code></li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> condition &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>if</code> 还有另外一种形式，它包含一个 <code>statement</code> 可选语句部分，该组件在条件判断之前运行，语法为：<code>if statement; condition &#123;  &#125;</code>，其中 <code>statement</code> 的作用域仅在 <code>if-else</code> 范围内。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; <span class="comment">// num 的范围仅限于 if else 代码块</span></span><br><span class="line">  <span class="keyword">if</span> num:= <span class="number">10</span>; num % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">    fmt.Println(num, <span class="string">&quot;is even.&quot;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(num, <span class="string">&quot;is odd.&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>一个注意点</strong>：<code>else</code> 必须键入在 <code>&#125;</code> 后面，不能另取一行键入，因为 Go 语言默认在每条语句结束时插入一个分号，但 <code>if else</code> 是一个整体。</li>
</ol>
<h2 id="Go 语言学习笔记 -8：循环"><a href="#Go 语言学习笔记 -8：循环" class="headerlink" title="Go 语言学习笔记 -8：循环"></a>Go 语言学习笔记 -8：循环</h2><ol>
<li>Go 语言中唯一的循环语句是 <code>for</code>，没有 <code>while</code> 和 <code>do while</code> 循环。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> initialisation; condition; post &#123;  </span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>for</code> 循环的三个组成部分，即初始化，条件和 post 都是可选的（可有可无），如：<code>for ;i &lt;= 10; &#123;...&#125;</code>、<code>for &#123;...&#125;</code> 或 <code>for i &lt;= 10 &#123;... i += 2&#125;</code>，即 <code>;</code> 也是可以省略的。</li>
</ul>
<ol start="2">
<li><code>break</code> 为跳出循环，<code>continue</code> 为不执行后续语句，进入下一次循环。</li>
</ol>
<hr>
<h2 id="Go 语言学习笔记 -9：switch 语句"><a href="#Go 语言学习笔记 -9：switch 语句" class="headerlink" title="Go 语言学习笔记 -9：switch 语句"></a>Go 语言学习笔记 -9：switch 语句</h2><ol>
<li><code>switch</code>是一个条件语句，它可以被认为是替代多个 <code>if else</code> 子句的常用方式，<code>case</code> 不允许出现重复项。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    finger := <span class="number">4</span></span><br><span class="line">    <span class="keyword">switch</span> finger &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;Thumb&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;Index&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;Middle&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>, <span class="number">5</span>: <span class="comment">// 一个选项多个表达式</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;Ring or Pinky&quot;</span>)</span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">// 默认情况</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;incorrect finger number&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>先声明变量再使用</strong>：<code>switch varname := xxx; varname &#123;...&#125;</code>，此时的 <code>varname</code> 变量的作用域仅限于当前 <code>switch</code> 内。</p>
</li>
<li><p><strong>无表达式的 <code>switch</code></strong>：在 switch 语句中，表达式是可选的，可以被省略。如果省略表达式，则表示这个 switch 语句 <strong> 等同于 switch true</strong>，并且 <strong> 每个 case 表达式都被认定为有效，相应的代码块也会被执行</strong>。</p>
</li>
<li><p><strong>fallthrough</strong>：fallthrough 语句可以在已经执行完成的 case 之后，把控制权转移到下一个 case 的执行代码中，而不会跳出 switch。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> num := <span class="number">3</span>; &#123;</span><br><span class="line">        <span class="keyword">case</span> num == <span class="number">3</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;==&quot;</span>)</span><br><span class="line">            <span class="keyword">fallthrough</span></span><br><span class="line">        <span class="keyword">case</span> num &lt; <span class="number">10</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;yes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>switch 和 case 的表达式不一定是常量。</li>
</ol>
<blockquote>
<p>学习链接：<a href="https://studygolang.com/subject/2">https://studygolang.com/subject/2</a>，感谢如此优秀的教程！</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go函数</tag>
        <tag>Go判断</tag>
        <tag>Go循环</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 笔记之变量与常量</title>
    <url>/posts/230907162612.html</url>
    <content><![CDATA[<h2 id="Go 语言学习笔记 -1：HelloWorld"><a href="#Go 语言学习笔记 -1：HelloWorld" class="headerlink" title="Go 语言学习笔记 -1：HelloWorld"></a>Go 语言学习笔记 -1：HelloWorld</h2><p>Go 语言是一种编译型语言，源代码都会编译成二进制机器码。</p>
<p>所有 Go 源文件都应该放置在工作区里的 src 目录下。Linux 的工作区（Workspace）应该设置在 $HOME/go，也可以通过设置 GOPATH 环境变量，用其他目录来作为工作区。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span></span><br><span class="line">  bin <span class="comment">// 编译生成的二进制文件存储位置</span></span><br><span class="line">    hello</span><br><span class="line">  src <span class="comment">// 所有 Go 源文件都应该放置在工作区里的 src 目录下</span></span><br><span class="line">    hello <span class="comment">// 为每个 project 新建一个文件夹</span></span><br><span class="line">      helloworld.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>

<p>第一个 Go 程序</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>解析：</p>
<ul>
<li><p><code>package main</code> - 每一个 Go 文件都应该在开头进行 package name 的声明（译注：只有可执行程序的包名应当为 main）。包（Packages）用于代码的封装与重用，这里的包名称是 main。</p>
</li>
<li><p><code>import &quot;fmt&quot;</code> - 我们引入了 fmt 包，用于在 main 函数里面打印文本到标准输出。</p>
</li>
<li><p><code>func main()</code> - main 是一个特殊的函数。整个程序就是从 main 函数开始运行的。main 函数必须放置在 main 包中。{和} 分别表示 main 函数的开始和结束部分。</p>
</li>
<li><p><code>fmt.Println(&quot;Hello World&quot;)</code> - fmt 包中的 Println 函数用于把文本写入标准输出。</p>
</li>
</ul>
<hr>
<h2 id="Go 语言学习笔记 -2：变量"><a href="#Go 语言学习笔记 -2：变量" class="headerlink" title="Go 语言学习笔记 -2：变量"></a>Go 语言学习笔记 -2：变量 </h2><p><strong> 变量 </strong> 指定了某存储单元（Memory Location）的名称，该存储单元会存储特定类型的值。</p>
<ol>
<li><p>声明单个变量：var name type，例如：var age int</p>
</li>
<li><p>声明变量并初始化：var name type = initialValue</p>
</li>
<li><p>类型推断：如果变量有初始值，那么 Go 能够自动推断具有初始值的变量的类型。因此，如果变量有初始值，就可以在变量声明中省略 type， 如 var age = 16 指 age 类型为 int 型。</p>
</li>
<li><p>声明多个变量：var name1, name2 type = initialValue1, initialValue2</p>
</li>
<li><p>在一个语句中声明不同类型的变量，如：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    age = <span class="number">19</span></span><br><span class="line">    name = “laowang”</span><br><span class="line">    adult = <span class="literal">true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>变量的简短声明语法：<code>:=</code> 操作符，例如：<code>age, name := 20, &quot;zhangsan&quot;</code>。简短声明要求 <code>:=</code> 操作符左边的 <strong> 所有变量都有初始值</strong>。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a, b := <span class="number">20</span>, <span class="number">30</span> <span class="comment">// 声明 a 和 b</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;a is&quot;</span>, a, <span class="string">&quot;b is&quot;</span>, b)</span><br><span class="line">    a, b := <span class="number">40</span>, <span class="number">50</span> <span class="comment">// 错误，没有尚未声明的变量</span></span><br><span class="line">    a, c := <span class="number">40</span>, <span class="number">60</span> <span class="comment">// 正确，有新的尚未声明的变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><p>变量也可以在运行时进行赋值，如 <code>a := math.Min(15, 20)</code></p>
</li>
<li><p>由于 Go 是强类型（Strongly Typed）语言，因此不允许某一类型的变量赋值为其他类型的值。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    age := <span class="number">29</span>      <span class="comment">// age 是 int 类型</span></span><br><span class="line">    age = <span class="string">&quot;naveen&quot;</span> <span class="comment">// 错误，尝试赋值一个字符串给 int 类型变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Go 语言学习笔记 -3：变量类型"><a href="#Go 语言学习笔记 -3：变量类型" class="headerlink" title="Go 语言学习笔记 -3：变量类型"></a>Go 语言学习笔记 -3：变量类型</h2><ol>
<li>Go 语言支持的变量类型：</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">bool</span><br><span class="line">数字类型</span><br><span class="line">    int8, int16, int32, int64, int</span><br><span class="line">    uint8, uint16, uint32, uint64, uint</span><br><span class="line">    float32, float64</span><br><span class="line">    complex64, complex128 // 复数型</span><br><span class="line">    byte</span><br><span class="line">    rune</span><br><span class="line">string</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 Printf 方法中，使用 <code>%T</code> 格式说明符（Format Specifier），可以打印出变量的类型。Go 的 <code>unsafe</code> 包提供了一个 <code>Sizeof</code> 函数，该函数接收变量并返回它的字节大小。如：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;type of age is %T, size of age is %d&quot;</span>, age, unsafe.Sizeof(age))</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>复数类型：<code>complex64</code> 表示实部和虚部都是 <code>float32</code> 类型，<code>complex128</code> 表示实部和虚部都是 <code>float64</code> 类型。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c1 := <span class="built_in">complex</span>(<span class="number">5</span>, <span class="number">7</span>) <span class="comment">// 通过内置函数声明复数变量 c1</span></span><br><span class="line">c2 := <span class="number">8</span> + <span class="number">27i</span> <span class="comment">// 通过简短声明声明复数变量 c2</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>其它变量类型：<code>byte</code> 是 <code>uint8</code> 的别名， <code>rune</code> 是 <code>int32</code> 的别名。</p>
</li>
<li><p>Go 是强类型（Strongly Typed）语言， Go 没有自动类型提升或类型转换：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i, j <span class="type">int</span>, float = <span class="number">5</span>, <span class="number">10.2</span></span><br><span class="line">diff := i - j <span class="comment">// 错误， int - float 不被允许</span></span><br><span class="line">diff := i - <span class="type">int</span>(j) <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Go 语言学习笔记 -4：常量"><a href="#Go 语言学习笔记 -4：常量" class="headerlink" title="Go 语言学习笔记 -4：常量"></a>Go 语言学习笔记 -4：常量</h2><ol>
<li><p>关键字：<code>const</code>，常量不能再重新赋值为其他的值。</p>
</li>
<li><p>常量的值会在 <strong> 编译的时候 </strong> 确定。因为函数调用发生在 <strong> 运行时</strong>，所以不能将函数的返回值赋值给常量。如：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a := math.Sqrt(<span class="number">4</span>) <span class="comment">// 允许</span></span><br><span class="line"><span class="keyword">const</span> b := math.Sqrt(<span class="number">9</span>) <span class="comment">// 不允许，编译先于运行</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>常量是可以没有类型的，如：<code>const name = &quot;zhangsan&quot;</code>；常量也可以是有类型的，如：<code>const name string = &quot;lisi&quot;</code>，即 name 是一个 string 类型的 <strong> 常量</strong>。</p>
</li>
<li><p>Go 的类型策略不允许将一种类型的变量赋值给另一种类型的变量。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> defaultName = <span class="string">&quot;Sam&quot;</span> <span class="comment">// 允许</span></span><br><span class="line">    <span class="keyword">type</span> myString <span class="type">string</span></span><br><span class="line">    <span class="keyword">var</span> customName myString = <span class="string">&quot;Sam&quot;</span> <span class="comment">// 允许</span></span><br><span class="line">    customName = defaultName <span class="comment">// 不允许，即使 myString 是 string 类型的别名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>布尔常量</strong>：字符串常量的规则适用于布尔常量。</li>
</ol>
<p><code>var name = &quot;Sam&quot;</code> 无类型的 <strong> 常量 </strong> Sam 是如何赋值给<strong> 变量</strong> name 的？</p>
<blockquote>
<p>答案是 <strong> 无类型的常量有一个与它们相关联的默认类型，并且当且仅当一行代码需要时才提供它</strong>（常量可以赋值给 “合适的” 类型，而不需要类型转换）。在声明变量时，如果使用常量来赋值，变量会从常量的默认类型中获取类型。在这种情况下，常量 “Sam” 的默认类型是字符串，所以变量 name 的类型也是字符串。</p>
</blockquote>
<blockquote>
<p>学习链接：<a href="https://studygolang.com/subject/2">https://studygolang.com/subject/2</a>，感谢如此优秀的教程！</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go变量与常量</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 笔记之字符串和指针</title>
    <url>/posts/230915155105.html</url>
    <content><![CDATA[<h2 id="Go 语言学习笔记 -14：字符串"><a href="#Go 语言学习笔记 -14：字符串" class="headerlink" title="Go 语言学习笔记 -14：字符串"></a>Go 语言学习笔记 -14：字符串</h2><ol>
<li><p>Go 语言中的字符串是一个 <strong> 字节切片</strong>。</p>
</li>
<li><p><code>%x</code> 格式限定符用于指定 16 进制编码，<code>%c</code> 格式限定符用于打印字符串的字符。</p>
</li>
<li><p>在 UTF-8 编码中，一个代码点（字符的编码）可能会占用超过一个字节的空间，所以使用 <code>%c</code> 格式打印时可能会出错，可以用 <code>rune</code> 解决。</p>
</li>
<li><p><code>rune</code> 是 Go 语言的内建类型，它也是 <code>int32</code> 的别称。在 Go 语言中，<code>rune</code> 表示一个代码点。代码点无论占用多少个字节，都可以用一个 <code>rune</code> 来表示。</p>
</li>
</ol>
<span id="more"></span>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">&quot;Señor&quot;</span></span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%c &quot;</span>,s[i]) <span class="comment">// 打印出错，S e Ã ± o r</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">runes := []<span class="type">rune</span>(s)</span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; <span class="built_in">len</span>(runes); i++ &#123; <span class="comment">// 字符串被转化为一个 rune 切片</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%c &quot;</span>,runes[i]) <span class="comment">// 打印正确，S e ñ o r</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>字符串的 for range 循环更简单。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printCharsAndBytes</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> index, <span class="type">rune</span> := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%c starts at byte %d\n&quot;</span>, <span class="type">rune</span>, index)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name := <span class="string">&quot;Señor&quot;</span></span><br><span class="line">    printCharsAndBytes(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">S starts at byte 0  </span></span><br><span class="line"><span class="comment">e starts at byte 1  </span></span><br><span class="line"><span class="comment">ñ starts at byte 2  // ñ 占了两个字节</span></span><br><span class="line"><span class="comment">o starts at byte 4  </span></span><br><span class="line"><span class="comment">r starts at byte 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>用字节切片构造字符串：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包含字符串 Café 用 UTF-8 编码后的 16 进制字节</span></span><br><span class="line">byteSlice := []<span class="type">byte</span>&#123;<span class="number">0x43</span>, <span class="number">0x61</span>, <span class="number">0x66</span>, <span class="number">0xC3</span>, <span class="number">0xA9</span>&#125;</span><br><span class="line">str := <span class="type">string</span>(byteSlice)</span><br><span class="line">fmt.Println(str) <span class="comment">// Café</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>用 <code>rune</code> 切片构造字符串：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包含字符串 Señor 的 16 进制的 Unicode 代码点</span></span><br><span class="line">runeSlice := []<span class="type">rune</span>&#123;<span class="number">0x0053</span>, <span class="number">0x0065</span>, <span class="number">0x00f1</span>, <span class="number">0x006f</span>, <span class="number">0x0072</span>&#125;</span><br><span class="line">str := <span class="type">string</span>(runeSlice)</span><br><span class="line">fmt.Println(str) <span class="comment">// Señor</span></span><br></pre></td></tr></table></figure>

<ol start="8">
<li>字符串的长度：utf-8 package 包中的 <code>func RuneCountInString(s string) (n int)</code> 方法用来 <strong> 获取字符串的长度 </strong>。这个方法传入一个字符串参数然后<strong> 返回字符串中的 rune 的数量</strong>。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">word1 := <span class="string">&quot;Señor&quot;</span> </span><br><span class="line">fmt.Println(utf8.RuneCountInString(word1)) <span class="comment">// 5</span></span><br><span class="line">word2 := <span class="string">&quot;Pets&quot;</span></span><br><span class="line">fmt.Println(utf8.RuneCountInString(word2)) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<ol start="9">
<li>字符串是不可变的：一旦一个字符串被创建，它将不可被修改。为了修改字符串，可以把字符串转化为一个 rune 切片，这个切片可以进行任何想要的改变，最后再转化为一个字符串。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mutate</span><span class="params">(s []<span class="type">rune</span>)</span></span> <span class="type">string</span> &#123;  </span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span> <span class="comment">// 修改切片</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(s) <span class="comment">// 转换为一个字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    h := <span class="string">&quot;hello&quot;</span></span><br><span class="line">    fmt.Println(mutate([]<span class="type">rune</span>(h))) <span class="comment">// 用 rune 切片构造字符串，输出 aello</span></span><br><span class="line">    fmt.Println(h) <span class="comment">// 输出 hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Go 语言学习笔记 -15：指针"><a href="#Go 语言学习笔记 -15：指针" class="headerlink" title="Go 语言学习笔记 -15：指针"></a>Go 语言学习笔记 -15：指针</h2><ol>
<li><p>指针是一种存储变量内存地址（Memory Address）的变量。例如，变量 b 的值为 156，而 b 的内存地址为 0x1040a124，变量 a 存储了 b 的地址。我们就称 a 指向了 b。</p>
</li>
<li><p>指针的声明：指针变量的类型为 <code>*T</code>，该指针指向一个 <code>T</code> 类型的变量。</p>
</li>
</ol>
<ul>
<li>&amp; 操作符用于获取变量的地址。下面的程序把 b 的地址赋值给 <code>*int</code> 类型的 a。我们称 a 指向了 b。当我们打印 a 的值时，会打印出 b 的地址。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b := <span class="number">255</span></span><br><span class="line">    <span class="keyword">var</span> a *<span class="type">int</span> = &amp;b</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Type of a is %T\n&quot;</span>, a) <span class="comment">// *int</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;address of b is&quot;</span>, a)  <span class="comment">// 0x1040a124</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>指针的零值（Zero Value）是 <code>nil</code>。声明变量 <code>var b *int</code>，此时 <code>b == nil</code> 为 <code>true</code>。</p>
</li>
<li><p>指针的解引用：指针的解引用可以获取指针所指向的变量的值。将 <code>a</code> 解引用的语法是 <code>*a</code>。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    b := <span class="number">255</span></span><br><span class="line">    a := &amp;b</span><br><span class="line">    fmt.Println(<span class="string">&quot;address of b is&quot;</span>, a) <span class="comment">// 0x1040a124</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;value of b is&quot;</span>, *a)  <span class="comment">// 255</span></span><br><span class="line">    *a++  <span class="comment">// (*a)++</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;new value of b is&quot;</span>, b) <span class="comment">// 256</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>向函数传递指针参数：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(val *<span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    *val = <span class="number">55</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := <span class="number">58</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;value of a before function call is&quot;</span>, a) <span class="comment">// 58</span></span><br><span class="line">    b := &amp;a</span><br><span class="line">    change(b)</span><br><span class="line">    fmt.Println(<span class="string">&quot;value of a after function call is&quot;</span>, a) <span class="comment">// 55</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>假如我们想要在函数内修改一个数组，并希望调用函数的地方也能得到修改后的数组，一种解决方案是把一个指向数组的指针传递给这个函数（但 Go 语言习惯的方法是用切片处理，见序号 7）。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(arr *[3]<span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    (*arr)[<span class="number">0</span>] = <span class="number">90</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>&#125;</span><br><span class="line">    modify(&amp;a)</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>a[x]</code> 是 <code>(*a)[x]</code> 的简写形式，因此上面代码中的 <code>(*arr)[0]</code> 可以替换为 <code>arr[0]</code>。</li>
</ul>
<ol start="7">
<li><strong>不要向函数传递数组的指针，而应该使用数组切片</strong>：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(sls []<span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    sls[<span class="number">0</span>] = <span class="number">90</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>&#125;</span><br><span class="line">    modify(a[:]) <span class="comment">// 使用切片</span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>别再传递数组指针了，而是使用切片吧。上面的代码更加简洁，也更符合 Go 语言的习惯。</li>
</ul>
<blockquote>
<p>学习链接：<a href="https://studygolang.com/subject/2">https://studygolang.com/subject/2</a>，感谢如此优秀的教程！</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go字符串</tag>
        <tag>Go指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 笔记之数组与切片</title>
    <url>/posts/230912152800.html</url>
    <content><![CDATA[<h2 id="Go 语言学习笔记 -10：数组"><a href="#Go 语言学习笔记 -10：数组" class="headerlink" title="Go 语言学习笔记 -10：数组"></a>Go 语言学习笔记 -10：数组</h2><ol>
<li><p>数组是 <strong> 同一类型元素 </strong> 的集合，Go 语言中不允许混合不同类型的元素。</p>
</li>
<li><p>一个数组的表示形式为 <code>[n]T</code>。n 表示数组中元素的数量，T 代表每个元素的类型。如： <code>var arr [3]int</code>。</p>
</li>
<li><p>数组简略声明：<code>arr := [3]int&#123;12, 78, 50&#125;</code>，在简略声明中，可对部分元素赋值：<code>arr := [3]int&#123;12&#125;</code>，剩下的元素自动赋值为 0 。</p>
</li>
<li><p>可以忽略声明数组的长度，并用 <code>...</code> 代替，让编译器为你自动计算长度：<code>arr := [...]int&#123;12, 21&#125;</code>。</p>
</li>
<li><p><strong>数组是值类型，不是引用类型 </strong>：这意味着当数组赋值给一个新的变量时，该变量会得到一个原始数组的副本。<strong> 如果对新变量进行更改，则不会影响原始数组</strong>。注：对切片的修改会影响原始数组。</p>
</li>
</ol>
<span id="more"></span>

<ol start="6">
<li><strong>当数组作为参数传递给函数时，它们是按值传递，而原始数组保持不变（原始数组不会因为函数调用而改变）</strong>。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeLocal</span><span class="params">(num [5]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    num[<span class="number">0</span>] = <span class="number">55</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;inside function &quot;</span>, num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num := [...]<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;before passing to function &quot;</span>, num)</span><br><span class="line">    changeLocal(num) <span class="comment">// num is passed by value</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;after passing to function &quot;</span>, num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// before passing to function  [5 6 7 8 8]</span></span><br><span class="line"><span class="comment">// inside function  [55 6 7 8 8]</span></span><br><span class="line"><span class="comment">// after passing to function  [5 6 7 8 8]</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li><p>数组的长度：<code>len(arr)</code>。</p>
</li>
<li><p>数组的迭代 for 循环：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;%d-th element of arr is %.2f\n&quot;</span>, i, arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>数组的迭代：Go 提供了一种更好、更简洁的方法，通过 <strong> 使用 for 循环的 <code>range</code> 方法来遍历数组</strong>。<code>range</code> 返回索引和该索引处的值。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;%d-th element of arr is %.2f\n&quot;</span>, i, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>多维数组：1）简略声明；2）先声明二维数组变量，再根据索引来对数组添加值。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr := [<span class="number">3</span>][<span class="number">2</span>]<span class="type">string</span>&#123; <span class="comment">// 简略声明</span></span><br><span class="line">      &#123;<span class="string">&quot;lion&quot;</span>, <span class="string">&quot;tiger&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;pigeon&quot;</span>, <span class="string">&quot;peacock&quot;</span>&#125;, <span class="comment">// this comma is necessary. The compiler will complain if you omit this comma</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v1 := <span class="keyword">range</span> arr &#123; <span class="comment">// 打印二维数组</span></span><br><span class="line">    <span class="keyword">for</span> _, v2 := <span class="keyword">range</span> v1 &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s &quot;</span>, v2)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>数组的缺陷：长度固定，不可能增加数组的长度。</li>
</ol>
<hr>
<h2 id="Go 语言学习笔记 -11：切片"><a href="#Go 语言学习笔记 -11：切片" class="headerlink" title="Go 语言学习笔记 -11：切片"></a>Go 语言学习笔记 -11：切片</h2><ol>
<li><p>切片是 <strong> 由数组建立 </strong> 的一种方便、灵活且功能强大的包装（Wrapper）。<strong>切片本身不拥有任何数据 </strong>。它们只是对现有数组的<strong> 引用</strong>。</p>
</li>
<li><p>创建一个切片 A ：带有 <code>T</code> 类型元素的切片由 <code>[]T</code> 表示。语法：<code>a[start:end]</code> 创建一个从 a 数组索引 start 开始到 end - 1 结束的切片。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">76</span>, <span class="number">77</span>, <span class="number">78</span>, <span class="number">79</span>, <span class="number">80</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b []<span class="type">int</span> = a[<span class="number">1</span>:<span class="number">4</span>] <span class="comment">// 数组切片</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建一个切片 B ：创建一个数组，并返回一个存储在 c 中的 <strong> 切片引用</strong>。注意：<code>[]</code> 内无内容。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c := []<span class="type">int</span>&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125; <span class="comment">// creates and array and returns a slice reference</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p><strong>对切片的修改会影响原始数组</strong>。</p>
</li>
<li><p>当多个切片共用相同的底层数组时，每个切片所做的更改将反映在数组中。</p>
</li>
<li><p><strong>切片的长度和容量</strong>：切片的长度是切片中的元素数。切片的容量是从创建切片索引开始（到数组末尾）的底层数组中的元素数。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fruitarray := [...]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>&#125;</span><br><span class="line">    fruitslice := fruitarray[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">    fmt.Println(<span class="string">&quot;length of slice: %d, capacity: %d&quot;</span>, <span class="built_in">len</span>(fruitslice), <span class="built_in">cap</span>(fruitslice)) <span class="comment">// 2, 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>切片可以重置其容量：<code>slicename[:cap(slicename)]</code>。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fruitarray := [...]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>&#125;</span><br><span class="line">    fruitslice := fruitarray[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">    fmt.Println(<span class="string">&quot;length of slice: %d, capacity: %d&quot;</span>, <span class="built_in">len</span>(fruitslice), <span class="built_in">cap</span>(fruitslice)) <span class="comment">// 2, 3. print: [b, c]</span></span><br><span class="line">    fruitslice = fruitslice[:<span class="built_in">cap</span>(fruitslice)] <span class="comment">// re-slicing furitslice till its capacity. print: [b, c, d]</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;After re-slicing length is&quot;</span>, <span class="built_in">len</span>(fruitslice), <span class="string">&quot;and capacity is&quot;</span>, <span class="built_in">cap</span>(fruitslice)) <span class="comment">// 3, 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><p><strong>使用 <code>make</code> 创建一个切片</strong>：<code>func make ([]T, len, cap)</code> 通过传递类型、长度和容量来创建切片。其中，容量是可选参数，默认值为切片长度。<strong><code>make</code> 函数创建一个数组，并返回引用该数组的切片</strong>。如 <code>arrslice := make([]float64, 5, 5)</code>。</p>
</li>
<li><p>切片是动态的，可以使用 <code>append</code> 将新元素追加到切片上。<code>append</code> 函数定义为：<code>func append(slice []T, x ...T) []T</code>，其中 <code>x...T</code> 表示该函数接收 T 类型的参数 x 的个数是可变的，如：<code>arrslice = append(arrslice, 5.6, 7.3)</code>。</p>
</li>
</ol>
<blockquote>
<p><code>append</code> 函数会返回一个新的切片，其中包含了原始切片和追加的元素：</p>
<ol>
<li>如果原始切片的容量足够，<code>append</code> 函数会在原始切片的基础上进行追加；</li>
<li>如果原始切片的容量不够，<code>append</code> 函数会创建一个新的底层数组，并将原始切片中的元素和追加的元素复制到新的底层数组中。</li>
</ol>
<p>因此，append 函数返回的切片可能指向一个新的底层数组，而不是原始切片所指向的底层数组。</p>
</blockquote>
<ol start="10">
<li><p>数组是固定的，但 <strong> 切片具有动态长度 </strong>：切片是由一个指向数组的指针、长度和容量组成的数据结构。当我们向切片中追加元素时，如果切片的长度小于容量，新元素会直接添加到切片的末尾，切片的长度会增加。但是，如果追加元素后切片的长度超过了容量，Go 语言会创建一个新的更大的底层数组，将原来的元素复制到新的数组中，并将新元素添加到新数组的末尾。然后，切片会指向这个新数组（<strong> 相比于旧切片，引用类型的地址改变了</strong>），并且容量会成为原来的两倍（并不是每次执行 <code>append</code> 时容量都会变成旧切片的两倍，只有当长度超过容量时，才会扩充一倍容量）。这样，切片就具有了动态长度的特性。</p>
</li>
<li><p>切片类型的零值为 <code>nil</code>：一个 <code>nil</code> 切片的长度和容量为 0，可以使用 <code>append</code> 函数将值追加到 <code>nil</code> 切片。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names []<span class="type">string</span> <span class="comment">// zero value of a slice is nil</span></span><br><span class="line"><span class="keyword">if</span> names == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;slice is nil going to append&quot;</span>)</span><br><span class="line">    names = <span class="built_in">append</span>(names, <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Sebastian&quot;</span>, <span class="string">&quot;Vinay&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;names contents:&quot;</span>, names)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="12">
<li><p><code>...</code> 可将一个切片添加到另一个切片中：<code>append(slice1, slice2...)</code>。</p>
</li>
<li><p>切片的函数传递：切片在内部可由一个结构体类型表示，即：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    Length         <span class="type">int</span></span><br><span class="line">    Capacity       <span class="type">int</span></span><br><span class="line">    ZerothElement  *<span class="type">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>切片本身包含了长度、容量和指向底层数组首个元素的指针。当切片作为参数传递给函数时，虽然是通过值传递，但是切片内部的指针变量（这里的<code>byte</code>）仍然指向相同的底层数组。因此，当函数内部修改底层数组的值时，这些修改在函数外部是可见的。</p>
</li>
<li><p>然而，如果函数内部修改了切片的长度或容量，将会创建一个新的切片，而不会影响原始切片。这是因为切片的长度和容量是切片结构体的字段，而非底层数组的属性。因此，修改切片的长度或容量会创建一个新的切片结构体，其中的指针变量仍然指向原始的底层数组，但是新的切片具有不同的长度和容量。</p>
</li>
<li><p>因此，可以说当切片传递给函数时，函数内部对底层数组的修改，在函数外部是可见的，但是对切片的长度和容量的修改是不可见的。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifySlice</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">100</span> <span class="comment">// 修改底层数组的值</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">200</span>) <span class="comment">// 创建新的切片，不影响原始切片</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Inside modifySlice:&quot;</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    numbers := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Before modifySlice:&quot;</span>, numbers)</span><br><span class="line">    modifySlice(numbers)</span><br><span class="line">    fmt.Println(<span class="string">&quot;After modifySlice:&quot;</span>, numbers)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Before modifySlice: [1 2 3 4 5]</span></span><br><span class="line"><span class="comment">// Inside modifySlice: [100 2 3 4 5 200]</span></span><br><span class="line"><span class="comment">// After modifySlice: [100 2 3 4 5]  // 函数内部对底层数组的修改在函数外部是可见的</span></span><br></pre></td></tr></table></figure>

<ol start="14">
<li><strong>多维切片</strong>：类似于多维数组，但每行索引对应的元素数量可以不等于其它行。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pls := [][]<span class="type">string</span> &#123;</span><br><span class="line">      &#123;<span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;JavaScript&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;Go&quot;</span>, <span class="string">&quot;Rust&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="15">
<li>内存优化：切片持有对底层数组的引用，只要切片在内存中，数组就不能被垃圾回收。一种回收数组的方法时使用 <code>copy</code> 函数 <code>func copy(dst, src[]T) int</code> 来生成一个切片的副本，这样就可以使用新的切片，原始数组也可以被垃圾回收。注：返回的 int 类型的值为 dst 的长度。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countries</span><span class="params">()</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    countries := []<span class="type">string</span>&#123;<span class="string">&quot;USA&quot;</span>, <span class="string">&quot;Singapore&quot;</span>, <span class="string">&quot;Germany&quot;</span>, <span class="string">&quot;India&quot;</span>, <span class="string">&quot;Australia&quot;</span>&#125;</span><br><span class="line">    neededCountries := countries[:<span class="built_in">len</span>(countries)<span class="number">-2</span>]</span><br><span class="line">    countriesCpy := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(neededCountries))</span><br><span class="line">    <span class="built_in">copy</span>(countriesCpy, neededCountries) <span class="comment">//copies neededCountries to countriesCpy</span></span><br><span class="line">    <span class="keyword">return</span> countriesCpy</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    countriesNeeded := countries()</span><br><span class="line">    fmt.Println(countriesNeeded)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>学习链接：<a href="https://studygolang.com/subject/2">https://studygolang.com/subject/2</a>，感谢如此优秀的教程！</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go数组</tag>
        <tag>Go切片</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 1029 两地调度</title>
    <url>/posts/231107094652.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/two-city-scheduling/">1029 两地调度</a>：公司计划面试 <code>2N</code> 人。第 <code>i</code> 个面试者飞往 A 市的费用为 <code>costs[i][0]</code>，飞往 B 市的费用为 <code>costs[i][1]</code>。返回将每个面试者都飞到某一座城市的最低费用，要求每个城市都有 <code>N</code> 个面试者抵达。</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：costs = [[10,20],[30,200],[400,50],[30,20]]</span><br><span class="line">输出：110</span><br><span class="line">解释：</span><br><span class="line">第一个人去 a 市，费用为 10。</span><br><span class="line">第二个人去 a 市，费用为 30。</span><br><span class="line">第三个人去 b 市，费用为 50。</span><br><span class="line">第四个人去 b 市，费用为 20。</span><br><span class="line"></span><br><span class="line">最低总费用为 10 + 30 + 50 + 20 = 110，每个城市都有一半的人在面试。</span><br></pre></td></tr></table></figure>

<h2 id="排序 - 贪心算法"><a href="# 排序 - 贪心算法" class="headerlink" title="排序 + 贪心算法"></a>排序 + 贪心算法 </h2><p> 要求每个城市都有 <code>N</code> 个面试者抵达。我们可以选择 <code>N</code> 个面试者去 A 市，那么剩下的 <code>N</code> 个面试者自然就得去 B 市了。<strong>那哪些人去 A 市呢</strong>？</p>
<p>「每个人」只需要考虑自己选哪个城市更省钱，但必须要有 <code>N</code> 个人去 A 市，<code>N</code> 个人去 B 市。因此，我们只需要 <strong> 比较「所有人」去 B 市与去 A 市的成本差——差值越大，说明去 A 市比去 B 市省出来的成本更多；差值越小，说明能省出来的成本就越少，这些人就去 B 市吧</strong>。</p>
<p>时间复杂度：<code>O(nlogn)</code>，排序所需时间，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *pa, <span class="type">const</span> <span class="type">void</span> *pb)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *arr1 = *(<span class="type">const</span> <span class="type">int</span> **)pa;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *arr2 = *(<span class="type">const</span> <span class="type">int</span> **)pb;</span><br><span class="line">    <span class="comment">// 按 B 市与 A 市成本差降序排序</span></span><br><span class="line">    <span class="keyword">return</span> (arr2[<span class="number">1</span>] - arr2[<span class="number">0</span>]) - (arr1[<span class="number">1</span>] - arr1[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">twoCitySchedCost</span><span class="params">(<span class="type">int</span>** costs, <span class="type">int</span> costsSize, <span class="type">int</span>* costsColSize)</span> &#123;</span><br><span class="line">    qsort(costs, costsSize, <span class="keyword">sizeof</span>(costs[<span class="number">0</span>]), cmp);</span><br><span class="line">    <span class="type">int</span> minCost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; costsSize; ++i) &#123;</span><br><span class="line">        <span class="comment">// 前一半差值大的去 A 市, 后一半差值小的去 B 市</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; (costsSize &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">            minCost += costs[i][<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minCost += costs[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 1410 实体解析器</title>
    <url>/posts/231123181539.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/html-entity-parser/">1410 HTML 实体解析器 </a> 是一种特殊的解析器，它将 HTML 代码作为输入，并用字符本身替换掉所有这些特殊的字符实体。给你输入字符串 <code>text</code> ，请你实现一个 HTML 实体解析器，返回解析器解析后的字符串。</p>
<span id="more"></span>

<p>HTML 里这些特殊字符和它们对应的字符实体包括：<br>双引号：字符实体为 <code>&amp;quot;</code> ，对应的字符是 <code>&quot;</code> 。<br>单引号：字符实体为 <code>&amp;apos;</code> ，对应的字符是 <code>&#39;</code> 。<br>与符号：字符实体为 <code>&amp;amp;</code> ，对应对的字符是 <code>&amp;</code> 。<br>大于号：字符实体为 <code>&amp;gt;</code> ，对应的字符是 <code>&gt;</code> 。<br>小于号：字符实体为 <code>&amp;lt;</code> ，对应的字符是 <code>&lt;</code> 。<br>斜线号：字符实体为 <code>&amp;frasl;</code> ，对应的字符是 <code>/</code> 。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：text = &quot;&amp;amp; is an HTML entity but &amp;ambassador; is not.&quot;</span><br><span class="line">输出：&quot;&amp; is an HTML entity but &amp;ambassador; is not.&quot;</span><br><span class="line"></span><br><span class="line">输入：text = &quot;and I quote: &amp;quot;...&amp;quot;&quot;</span><br><span class="line">输出：&quot;and I quote: \&quot;...\&quot;&quot;</span><br><span class="line"></span><br><span class="line">输入：text = &quot;&amp;&amp;&amp;&quot;</span><br><span class="line">输出：&quot;&amp;&amp;&amp;&quot;</span><br></pre></td></tr></table></figure>

<h2 id="哈希表 - 模拟"><a href="# 哈希表 - 模拟" class="headerlink" title="哈希表 + 模拟"></a>哈希表 + 模拟 </h2><p> 这个解法，是我今天刷题时写的，主要练习一下使用 <code>uthash.h</code> 构建 key 为字符串，value 为字符的哈希表。</p>
<p>解法描述：</p>
<ol>
<li>首先，我们可以将这六个字符实体存入一个哈希表中，它的 key 为字符实体，value 为对应的字符；</li>
<li>然后，向右遍历给定的文本 <code>text</code>，当遍历到的字符是 <code>&amp;</code> 时，我们就可以查表判断 <code>&amp;</code> 字符之后的一段字符串，是否是这 6 个字符实体中的一个：<ul>
<li>如果是，则替换为对应的字符；如果遍历完这一段字符，也没找到，则不替换；</li>
<li>如果中间遇到新的 <code>&amp;</code>，则不应替换，并及时停止、继续步骤 2。</li>
</ul>
</li>
<li>遍历完文本 <code>text</code> 后，则字符实体替换结束。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建 key 为字符串，value 为字符的哈希表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *key;</span><br><span class="line">    <span class="type">char</span> val;</span><br><span class="line">    UT_hash_handle hh;</span><br><span class="line">&#125; HashItem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代地释放所有哈希节点的空间</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hashFree</span><span class="params">(HashItem **obj)</span> &#123;</span><br><span class="line">    HashItem *curr = <span class="literal">NULL</span>, *tmp = <span class="literal">NULL</span>;</span><br><span class="line">    HASH_ITER(hh, *obj, curr, tmp) &#123;</span><br><span class="line">        HASH_DEL(*obj, curr);  </span><br><span class="line">        <span class="built_in">free</span>(curr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LEN (7)  <span class="comment">// strlen(&quot;&amp;frasl;&quot;)</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">entityParser</span><span class="params">(<span class="type">char</span>* text)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *entities[] = &#123;<span class="string">&quot;&amp;quot;&quot;</span>, <span class="string">&quot;&amp;apos;&quot;</span>, <span class="string">&quot;&amp;amp;&quot;</span>, <span class="string">&quot;&amp;gt;&quot;</span>, <span class="string">&quot;&amp;lt;&quot;</span>, <span class="string">&quot;&amp;frasl;&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="type">char</span> entitiesVal[] = &#123;<span class="string">&#x27;\&quot;&#x27;</span>, <span class="string">&#x27;\&#x27;&#x27;</span>, <span class="string">&#x27;&amp;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;/&#x27;</span>&#125;;</span><br><span class="line">    HashItem *hashTbl = <span class="literal">NULL</span>, *hashNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; entities[i]; i++) &#123;</span><br><span class="line">        hashNode = (HashItem *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashItem));</span><br><span class="line">        hashNode-&gt;key = entities[i];</span><br><span class="line">        hashNode-&gt;val = entitiesVal[i];</span><br><span class="line">        <span class="comment">// 已知添加的 key 不会重复，这里就不在添加前先查找 key 是否存在了</span></span><br><span class="line">        HASH_ADD_STR(hashTbl, key, hashNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(text), ;</span><br><span class="line">    <span class="type">char</span> *ans = (<span class="type">char</span> *)<span class="built_in">malloc</span>((n + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (text[i] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (text[i] != <span class="string">&#x27;&amp;&#x27;</span>) &#123; <span class="comment">// 不是字符实体首字符</span></span><br><span class="line">            ans[idx++] = text[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 是字符实体首字符</span></span><br><span class="line">            hashNode = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="type">char</span> temp[<span class="number">8</span>] = &#123;<span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历接下可能出现字符实体的一段字符串</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; fmin(i + MAX_LEN, n); j++) &#123;</span><br><span class="line">                temp[j - i] = text[j];</span><br><span class="line">                HASH_FIND_STR(hashTbl, temp, hashNode);</span><br><span class="line">                <span class="keyword">if</span> (hashNode) &#123; <span class="comment">// 找到则替换，指针后移特定长度</span></span><br><span class="line">                    ans[idx++] = hashNode-&gt;val;</span><br><span class="line">                    i = j + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!hashNode) &#123; <span class="comment">// 遍历完也没找到</span></span><br><span class="line">                ans[idx++] = text[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans[idx] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    hashFree(&amp;hashTbl);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑最坏情况，如字符串 <code>&amp;&amp;&amp;&amp;&amp;&amp;</code>。在外循环中，遍历的每个位置都要进入内循环去查表，在内层循环中，每次都是探测到「一段字符串」的 <strong> 最后位置</strong>，才发现不是字符实体。</p>
<ul>
<li>时间复杂度：<code>O(kn)</code>，<code>k</code> 表示字符实体的最大长度，哈希表查表为 <code>O(1)</code>。</li>
<li>空间复杂度：<code>O(s + 6)</code>，<code>s</code> 表示字符实体的长度和，为哈希表存储的 6 个字符实体的空间。</li>
</ul>
<h2 id="字符串操作 - 模拟（官方）"><a href="# 字符串操作 - 模拟（官方）" class="headerlink" title="字符串操作 + 模拟（官方）"></a>字符串操作 + 模拟（官方）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">entityChar</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *entity;</span><br><span class="line">    <span class="type">char</span> character;</span><br><span class="line">&#125; EntityChar;</span><br><span class="line"></span><br><span class="line">EntityChar entityList[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;&amp;quot;&quot;</span>, <span class="string">&#x27;\&quot;&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;&amp;apos;&quot;</span>, <span class="string">&#x27;\&#x27;&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;&amp;amp;&quot;</span>, <span class="string">&#x27;&amp;&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;&amp;gt;&quot;</span>, <span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;&amp;lt;&quot;</span>, <span class="string">&#x27;&lt;&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;&amp;frasl;&quot;</span>, <span class="string">&#x27;/&#x27;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">entityParser</span><span class="params">(<span class="type">char</span> *text)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(text);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="keyword">sizeof</span>(entityList) / <span class="keyword">sizeof</span>(entityList[<span class="number">0</span>]);  <span class="comment">// 字符实体的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *ans = (<span class="type">char</span> *)<span class="built_in">malloc</span>((n + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="type">char</span> *p = ans;  <span class="comment">// 使用指针的方式填充结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">        <span class="type">bool</span> isEntity = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (text[i] == <span class="string">&#x27;&amp;&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line">                <span class="type">char</span> *pKey = entityList[j].entity;</span><br><span class="line">                <span class="type">char</span> *pVal = &amp;entityList[j].character;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strncmp</span>(text + i, pKey, <span class="built_in">strlen</span>(pKey)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">strcpy</span>(p, pVal);  <span class="comment">// 这样写可以兼容值是字符串的情况</span></span><br><span class="line">                    p += <span class="built_in">strlen</span>(pVal);</span><br><span class="line">                    i += <span class="built_in">strlen</span>(pKey);</span><br><span class="line">                    isEntity = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isEntity) &#123;</span><br><span class="line">            *(p++) = text[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑最坏情况，如字符串 <code>&amp;&amp;&amp;&amp;&amp;&amp;</code>。在外循环中，遍历的每个位置都要进入内循环去查表，在内层循环中，要比较 <strong> 每一个长度不同 </strong> 的字符实体。</p>
<ul>
<li>时间复杂度：<code>O(sn)</code>，<code>s</code> 为字符实体的长度和。</li>
<li>空间复杂度：<code>O(s + 6)</code>，变量 <code>entityList</code> 的空间。</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>哈希表</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 117 填充每个节点的下一个右侧节点指针 II</title>
    <url>/posts/231103121209.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117 填充每个节点的下一个右侧节点指针 II</a>：给定一个包含指针 <code>next</code> 成员的二叉树：填充它的每个 <code>next</code> 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 <code>next</code> 指针设置为 <code>NULL</code>。初始状态下，所有 <code>next</code> 指针都被设置为 <code>NULL</code>。</p>
<span id="more"></span>

<p>树结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node *left;</span><br><span class="line">    Node *right;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例图：<br><img src="https://assets.leetcode.com/uploads/2019/02/15/117_sample.png" alt=""></p>
<h2 id="队列 - 层序遍历"><a href="# 队列 - 层序遍历" class="headerlink" title="队列 + 层序遍历"></a>队列 + 层序遍历 </h2><p> 根据题目描述，「填充它的每个 <code>next</code> 指针，让这个指针指向（同层的）其下一个右侧节点」，我们很容易想到使用「层序遍历」解决这个问题。而层序遍历通常需要借助 FIFO 队列实现。</p>
<p><strong>关于借助队列的树的层序遍历</strong>：首先要入队根节点；然后，记录队列中的节点个数 <code>size</code>；随后，弹出 <code>size</code> 个节点，在弹出的过程中入队弹出节点的左、右节点；最后，在这 <code>size</code> 个节点弹出后，队列中剩下的节点，就是刚刚入队的树的下一层节点。只要队列不为空，我们就反复进行上述操作，直到队列为空为止（二叉树的叶子层没有左、右节点，便不会再有节点入队，队列也就为空了）。</p>
<p>时间复杂度：<code>O(n)</code>，一趟遍历，空间复杂度：<code>O(n)</code>，需要使用队列保存二叉树中的节点。</p>
<blockquote>
<p>关于队列，我们可以使用 <a href="https://pursue26.github.io/posts/231017105123.html"> 数据结构之队列（链表实现）</a>中实现的接口。但是，为了简单、清晰，我在这里直接使用数组模拟 FIFO 队列。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">TreeNode_t</span>;</span></span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">connect</span><span class="params">(<span class="keyword">struct</span> Node* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	TreeNode_t *<span class="built_in">queue</span>[<span class="number">6000</span>];</span><br><span class="line">    <span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;  <span class="comment">// 队列的头尾指针</span></span><br><span class="line">    <span class="built_in">queue</span>[rear++] = root;  <span class="comment">// 树不为空, 首先入队根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (rear - front &gt; <span class="number">0</span>) &#123;  <span class="comment">// 队列不为空</span></span><br><span class="line">        <span class="type">int</span> size = rear - front;  <span class="comment">// 当前队列的数据大小</span></span><br><span class="line">        TreeNode_t *curNode = <span class="literal">NULL</span>, *preNode = <span class="literal">NULL</span>;  <span class="comment">// 当前节点和上一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 弹出这几个数据（某一层的所有节点）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            curNode = <span class="built_in">queue</span>[front++];  <span class="comment">// 首指针后移</span></span><br><span class="line">            <span class="comment">// 链接前后两个节点, 并更新上一个节点为当前节点</span></span><br><span class="line">            <span class="keyword">if</span> (preNode) &#123;</span><br><span class="line">                preNode-&gt;next = curNode;</span><br><span class="line">            &#125;</span><br><span class="line">            preNode = curNode;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 入队左右子树的节点</span></span><br><span class="line">            <span class="keyword">if</span> (curNode-&gt;left) &#123;</span><br><span class="line">                <span class="built_in">queue</span>[rear++] = curNode-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curNode-&gt;right) &#123;</span><br><span class="line">                <span class="built_in">queue</span>[rear++] = curNode-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每层的最后一个节点指向空地址</span></span><br><span class="line">        curNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="利用已建立的链表构建下一层链表"><a href="# 利用已建立的链表构建下一层链表" class="headerlink" title="利用已建立的链表构建下一层链表"></a>利用已建立的链表构建下一层链表 </h2><p> 根据题目描述，「填充它的每个 <code>next</code> 指针，让这个指针指向（同层的）其下一个右侧节点」。这样填充后，二叉树的每一层都将是一个单链表，链表的头节点是每层最左侧的树节点。这样，我们就可以根据链表中的节点，获得它的下一层的左、右孩子节点。</p>
<p>因此，我们可以利用当前层的链表 <code>currLayer</code> 来构建下一层的链表 <code>nextLayer</code>：</p>
<ul>
<li>下一层的构建过程就是：不断的访问 <code>currLayer</code> 中的节点，通过它访问下一层的左、右孩子节点，将这些孩子链接起来，就是 <code>nextLayer</code>；</li>
<li>构建的下一层的链表时，要记录下一层的头结点，以便更新当前层为下一层。<ul>
<li>下一层的头结点，就是 <code>currLayer</code> 中的节点里，第一个有孩子节点（若有左、右孩子，左孩子优先）。</li>
</ul>
</li>
</ul>
<p>最后，当下一层为叶子结点层时，便不会有下一层链表，当前层链表会更新为 <code>NULL</code>，标志着每层的链表构建完成。</p>
<p>时间复杂度：<code>O(n)</code>，一趟遍历，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">connect</span><span class="params">(<span class="keyword">struct</span> Node* root)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">currLayer</span> =</span> root;  <span class="comment">// 首层的链表为树的根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要当前层不为空, 就可以试探下一层</span></span><br><span class="line">    <span class="keyword">while</span> (currLayer) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">node</span> =</span> currLayer;  <span class="comment">// 获取当前层的头节点, 用于遍历</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">nextLayer</span> =</span> <span class="literal">NULL</span>;  <span class="comment">// 记录下一层的头节点</span></span><br><span class="line">        <span class="type">bool</span> isFirst = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        currLayer = <span class="literal">NULL</span>;  <span class="comment">// 置空当前层</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (node) &#123;  <span class="comment">// 遍历当前层构成的链表</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">data</span>[2] =</span> &#123;node-&gt;left, node-&gt;right&#125;;</span><br><span class="line">            <span class="comment">// 遍历当前节点的左右节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (data[i]) &#123;</span><br><span class="line">                    <span class="comment">// 判断是否是下一层的第一个节点</span></span><br><span class="line">                    <span class="keyword">if</span> (isFirst) &#123;</span><br><span class="line">                        nextLayer = data[i];</span><br><span class="line">                        currLayer = nextLayer;  <span class="comment">// 更新当前层为下一层头节点, 用于下一轮最外层 while 循环</span></span><br><span class="line">                        isFirst = <span class="literal">false</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        nextLayer-&gt;next = data[i];  <span class="comment">// 链接下一层的节点</span></span><br><span class="line">                        nextLayer = nextLayer-&gt;next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>评论区用户 @M9988：方法二确实比方法一巧妙。但是，作为面试准备的话，我更推崇练习方法一。因为方法一才是层序（BFS）遍历的通用模式。把这个 BFS 模板练熟以后，面试方可信手拈来（再在里面做附加逻辑）。方法二，技巧性强，可以提高，但是面试的话还是把场景套上模板的熟练能力。</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树遍历</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树遍历</tag>
        <tag>层序遍历</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 142 环形链表 II</title>
    <url>/posts/231102165703.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142 环形链表 II</a>：给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 <code>pos</code> 是 -1，则在该链表中没有环。注意：<code>pos</code> 不作为参数进行传递，仅仅是为了标识链表的实际情况。说明：不允许修改给定的链表。</p>
<span id="more"></span>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入: head = [3,2,0,-4], pos = 1</span><br><span class="line">输出: 返回索引为 1 的链表节点 </span><br><span class="line">解释: 链表中有一个环，其尾部连接到第二个节点。</span><br><span class="line"></span><br><span class="line">输入: head = [1,2], pos = 0</span><br><span class="line">输出: 返回索引为 0 的链表节点 </span><br><span class="line">解释: 链表中有一个环，其尾部连接到第一个节点。</span><br><span class="line"></span><br><span class="line">输入: head = [1], pos = -1</span><br><span class="line">输出: 返回 null </span><br><span class="line">解释: 链表中没有环。</span><br></pre></td></tr></table></figure>

<h2 id="哈希表 - 遍历"><a href="# 哈希表 - 遍历" class="headerlink" title="哈希表 + 遍历"></a>哈希表 + 遍历 </h2><p> 我们可以借助一个哈希表来存储链表中的节点，随着遍历的进行，会第二次遇到相同的节点，这个最先遇到的节点就是入环的第一个节点。</p>
<p>时间复杂度：<code>O(n)</code>，一趟遍历，空间复杂度：<code>O(n)</code>，哈希表最多存储链表的全部节点。</p>
<h2 id="快慢指针"><a href="# 快慢指针" class="headerlink" title="快慢指针"></a>快慢指针 </h2><p> 前置知识：<strong>使用快慢指针可以判断链表中是否存在环。若存在环，则快慢指针终有相遇的时候，若不存在环，快指针最后会退出链表</strong>。</p>
<p>因此，判断环形链表入环的第一个节点，也可以使用快慢指针。</p>
<p><img src="../images/leetcode/lc-142.png" alt=""></p>
<p>如上图，当快慢指针在位置 $O$ 相遇时，假设快指针绕环走过 $n$ 圈，那么其走过链表的总长度为 $a + b + n(b + c)$。同样地，慢指针绕环走过 $m$ 圈，那么其走过链表的总长度为 $a + b + m(b + c)$。</p>
<p>假设快指针每次走 $2$ 步，慢指针每次走 $1$ 步，那么有 $a + b + n(b + c) = 2(a + b + m(b + c))$，化简得 $a+b = (n - 2m)(b + c)$。</p>
<p>那么，$n$ 和 $m$ 分别是几圈呢？</p>
<p>当慢指针第一次进入环的起始位置时（假设为位置 $A$），由于快指针一定在慢指针前面，所以此时快指针已经在环上（假设为位置 $B$）。因为快指针的速度是慢指针的速度的 $2$ 倍，当它们在环上移动时，慢指针移动一圈会又回到环的起点位置 $A$，此时快指针移动了两圈也回到位置 $B$。</p>
<p>相同的时间下，快指针在走这两圈的路上一定会遇到（且为 $1$ 次）只走一圈的满指针；且因为慢指针慢，要「追上」慢指针，快指针一定会走过环一圈，使其「落后于」慢指针，然后再相遇，故 $n = 1, m = 0$。代入 $a+b = (n - 2m)(b + c)$ 有 $a = c$。</p>
<p>因此，我们 <strong> 只需要在快慢指针相遇时，再申请一个指针，从链表头开始走（与慢指针同速度）。当慢指针和这个新申请的指针相遇时，就是环形链表入环的第一个节点</strong>。</p>
<p>时间复杂度：<code>O(n)</code>，一趟遍历，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode *<span class="title function_">detectCycle</span><span class="params">(<span class="keyword">struct</span> ListNode *head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">slow</span> =</span> head, *fast = head, *node = head;</span><br><span class="line">    <span class="comment">// 判断快指针能不能再往后移动两个节点</span></span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="comment">// 相遇</span></span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未相遇</span></span><br><span class="line">    <span class="keyword">if</span> ((fast == <span class="literal">NULL</span>) || (fast-&gt;next == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确定环形链表入环的第一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (node != slow) &#123;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 笔记之可变参数函数与 Map 集合</title>
    <url>/posts/230913161326.html</url>
    <content><![CDATA[<h2 id="Go 语言学习笔记 -12：可变参数函数"><a href="#Go 语言学习笔记 -12：可变参数函数" class="headerlink" title="Go 语言学习笔记 -12：可变参数函数"></a>Go 语言学习笔记 -12：可变参数函数</h2><ol>
<li><p>可变参数函数是一种 <strong> 参数个数可变 </strong> 的函数。如果函数最后一个参数的类型被记作 <code>...T</code> ，这时函数可以接受任意个 <code>T</code> 类型的参数作为最后一个参数。<strong>只有 </strong> 函数的最后一个参数才允许是可变的。</p>
</li>
<li><p>可变参数函数的 <strong> 工作原理 </strong> 是把可变参数转换为一个新的 <strong> 切片</strong>。</p>
</li>
<li><p>有一个可以直接将切片传入可变参数函数的语法糖，你可以在切片后加上 <code>...</code> 后缀。这样切片将直接传入函数，不再创建新的切片。</p>
</li>
</ol>
<span id="more"></span>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">find</span><span class="params">(num <span class="type">int</span>, nums ...<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    find(<span class="number">89</span>, <span class="number">88</span>, <span class="number">89</span>, <span class="number">90</span>) <span class="comment">// 语法正确，[88, 89, 90] 将被转换为一个新的切片传入 find 函数</span></span><br><span class="line">    find(<span class="number">89</span>) <span class="comment">// 语法正确, 一个长度和容量为 0 的 nil 切片将被传入 find 函数</span></span><br><span class="line">    nums := []<span class="type">int</span>&#123;<span class="number">87</span>, <span class="number">88</span>, <span class="number">89</span>&#125;</span><br><span class="line">    find(<span class="number">89</span>, nums) <span class="comment">// 语法错误，find 的可变参数要求为 int 型，不能传入 []int 切片</span></span><br><span class="line">    find(<span class="number">89</span>, nums...) <span class="comment">// 语法正确，切片直接传入函数，不再创建新的切片</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Go 语言学习笔记 -13：Maps"><a href="#Go 语言学习笔记 -13：Maps" class="headerlink" title="Go 语言学习笔记 -13：Maps"></a>Go 语言学习笔记 -13：Maps</h2><ol>
<li><p>map 是在 Go 中将值（value）与键（key）关联的 <strong> 内置类型</strong>。通过相应的键可以获取到值。</p>
</li>
<li><p>通过向 <code>make</code> 函数传入键和值的类型，可以创建 map。<code>make(map[type of key]type of value)</code> 是创建 map 的语法。如：<code>personSalary := make(map[string]int)</code>。</p>
</li>
<li><p>map 的零值是 <code>nil</code>。如果你想添加元素到 nil map 中，会触发运行时 <code>panic</code>。因此 <strong>map 必须使用 <code>make</code> 函数初始化</strong>。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> personSalary <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> personSalary == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;map is nil. Going to make one.&quot;</span>)</span><br><span class="line">        personSalary = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>) <span class="comment">// 使用 make 方法初始化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    personSalary[<span class="string">&quot;steve&quot;</span>] = <span class="number">12000</span> <span class="comment">// 给 map 添加新元素</span></span><br><span class="line">    personSalary[<span class="string">&quot;jamie&quot;</span>] = <span class="number">15000</span></span><br><span class="line">    personSalary[<span class="string">&quot;mike&quot;</span>] = <span class="number">9000</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;personSalary map contents:&quot;</span>, personSalary) <span class="comment">// map[steve:12000 jamie:15000 mike:9000]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在声明时初始化 map：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">personSalary := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> &#123;</span><br><span class="line">        <span class="string">&quot;steve&quot;</span>: <span class="number">12000</span>,</span><br><span class="line">        <span class="string">&quot;jamie&quot;</span>: <span class="number">15000</span>, <span class="comment">// 逗号不可缺</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>获取 map 中的元素：<code>map[key]</code>。如果获取一个不存在的元素，map 会返回 <strong> 该元素类型的零值</strong>（如：<code>[]T</code> 返回 <code>nil</code>，整形返回 <code>0</code>）。</p>
</li>
<li><p>如何判断某个 key 是否存在于 map 中：<code>value, ok := map[key]</code>，如果 ok 是 true，表示 key 存在，key 对应的值就是 value ，反之表示 key 不存在。</p>
</li>
<li><p>遍历 map 中所有的元素需要用 for range 循环：<code>for key, value := range personSalary &#123;//... &#125;</code>。当使用 for range 遍历 map 时，不保证每次执行程序获取的元素顺序相同。</p>
</li>
<li><p>删除 map 中的元素：<code>delete(map, key)</code>，无返回值。</p>
</li>
<li><p>获取 map 的长度：<code>len(map)</code>。</p>
</li>
<li><p>和 slices 类似，map 也是 <strong> 引用类型 </strong>：当 map 被赋值为一个新变量的时候，它们指向同一个内部数据结构。因此，<strong> 改变其中一个变量，就会影响到另一变量。当 map 作为函数参数传递时也会发生同样的情况，函数中对 map 的任何修改，对于外部的调用都是可见的</strong>。</p>
</li>
<li><p>map 之间不能使用 <code>==</code> 操作符判断，<code>==</code> 只能用来检查 map 是否为 nil。</p>
</li>
</ol>
<blockquote>
<p>学习链接：<a href="https://studygolang.com/subject/2">https://studygolang.com/subject/2</a>，感谢如此优秀的教程！</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go可变参数函数</tag>
        <tag>Go集合Map</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 1631 最小体力消耗路径</title>
    <url>/posts/231211184652.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/path-with-minimum-effort/description/">1631 最小体力消耗路径</a>：你准备参加一场远足活动。给你一个二维 <code>rows x cols</code> 的地图 <code>heights</code> ，其中 <code>heights[row][col]</code> 表示格子 <code>(row, col)</code> 的高度。一开始你在最左上角的格子 <code>(0, 0)</code>，且你希望去最右下角的格子 <code>(rows-1, cols-1)</code> （注意下标从 <code>0</code> 开始编号）。你每次可以往上、下、左、右四个方向之一移动，你想要找到耗费体力最小的一条路径。</p>
<p>一条路径耗费的体力值是 <strong> 路径上相邻格子之间高度差的绝对值的最大值 </strong> 决定的。请你返回从左上角走到右下角的最小体力消耗值。</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：heights = [</span><br><span class="line">    [1,2,1,1,1],</span><br><span class="line">    [1,2,1,2,1],</span><br><span class="line">    [1,2,1,2,1],</span><br><span class="line">    [1,2,1,2,1],</span><br><span class="line">    [1,1,1,2,1]</span><br><span class="line">]</span><br><span class="line">输出：0</span><br><span class="line">解释：按着值为 1 的格子走，不需要消耗任何体力。</span><br></pre></td></tr></table></figure>

<h2 id="思考"><a href="# 思考" class="headerlink" title="思考"></a>思考 </h2><p> 这个题，跟以往常见的移动规则不太一样。<strong>常见的是只能向下、向右移动，而此题可以向四个方向移动</strong>。如果是只能向下、向右移动，那么可以用动态规划解决，其状态转移方程为：</p>
<p>$$<br>dp[i][j] = min(max(dp[i - 1][j], abs(h[i][j] - h[i - 1][j])), max(dp[i][j - 1], abs(h[i][j] - h[i][j - 1])));<br>$$</p>
<p>其中，$dp[i][j]$ 表示移动到格子 $(i, j)$ 时消耗的最小体力，它可以从上方的格子到达该格子、也可以从左侧的格子到达该格子。所以 $dp[i][j]$ 会选择两者中体力消耗较少的那个格子作为经过点。</p>
<p>只能向下、向右移动的动态规划解法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">minimumEffortPathRightDown</span><span class="params">(<span class="type">int</span>** heights, <span class="type">int</span> heightsSize, <span class="type">int</span>* heightsColSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> m = heightsSize, n = *heightsColSize;</span><br><span class="line">    <span class="type">int</span> dp[m][n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = fmax(dp[i][j - <span class="number">1</span>], <span class="built_in">fabs</span>(heights[i][j] - heights[i][j - <span class="number">1</span>]));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span> &amp;&amp; i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = fmax(dp[i - <span class="number">1</span>][j], <span class="built_in">fabs</span>(heights[i][j] - heights[i - <span class="number">1</span>][j]));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                dp[i][j] = fmin(fmax(dp[i - <span class="number">1</span>][j], <span class="built_in">fabs</span>(heights[i][j] - heights[i - <span class="number">1</span>][j])), fmax(dp[i][j - <span class="number">1</span>], <span class="built_in">fabs</span>(heights[i][j] - heights[i][j - <span class="number">1</span>])));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题转换"><a href="# 问题转换" class="headerlink" title="问题转换"></a>问题转换 </h2><p> 我们可以将本题抽象成如下的一个 <strong> 图论模型</strong>：</p>
<ul>
<li><p>我们将地图中的 <strong> 每一个格子看成图中的一个节点</strong>；</p>
</li>
<li><p>我么将两个相邻（左右相邻或者上下相邻）的 <strong> 两个格子对应的节点之间连接一条无向边</strong>，边的权值为这两个格子的高度差的绝对值；</p>
</li>
<li><p>我们需要找到一条从左上角到右下角的「最短路径」，其中一条路径的长度定义为其经过的 <strong> 所有边权的最大值</strong>。</p>
</li>
</ul>
<p>一般地，<strong>「图」中的所有节点的编号都是不一样的</strong>。所以我们需要将二维的坐标点，转换成唯一的编号。这可以按 $id = rows * m + cols$ 来表示。比如，对于 $m = 4, n = 3$，从 $(3, 2)$ 向上移动到 $(2, 2)$ 就是从节点 $14$ 移动到节点 $10$。</p>
<h2 id="并查集解法"><a href="# 并查集解法" class="headerlink" title="并查集解法"></a>并查集解法 </h2><p> 我们可以将地图中的 <code>mn</code> 个格子（节点）放入并查集中，初始时，所有节点各为一个集合。随着「路径的形成」，路径上的节点将会汇集在不同的集合中（不加干预的话，最终所有的点会汇聚成一个集合）。</p>
<p>因此，<strong>如果左上角和右下角所对应的节点，被合并到同一个集合内，就可以说明形成了一条从左上角到右下角路径</strong>，路径被连通。</p>
<p>但是，我们要找的是一条从左上角到右下角的「最短路径」。所以，我们 <strong> 可以按边权从小到大的顺序，将这条边的两个点合并到集合中</strong>。一旦出现左上角和右下角在同一个集合中，那便是从左上角到右下角的「最短路径」（这次移动的高度差就是首尾连通路径上的最大高度差，但同时也是所有可能的首尾连通路径上的最小高度差）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> from; <span class="comment">// 从哪个坐标</span></span><br><span class="line">    <span class="type">int</span> to; <span class="comment">// 移动到哪个坐标</span></span><br><span class="line">    <span class="type">int</span> h; <span class="comment">// 移动的高度差的绝对值</span></span><br><span class="line">&#125; Edge;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> rank[], <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">        rank[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[x] == x) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 路径压缩</span></span><br><span class="line">        parent[x] = findSet(parent, parent[x]);</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unionSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> rank[], <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> rootX = findSet(parent, x);</span><br><span class="line">    <span class="type">int</span> rootY = findSet(parent, y);</span><br><span class="line">    <span class="comment">// 属于不同集合</span></span><br><span class="line">    <span class="keyword">if</span> (rootX != rootY) &#123;</span><br><span class="line">        <span class="comment">// 将深度较小的树连到另一棵树</span></span><br><span class="line">        <span class="keyword">if</span> (rank[rootX] &lt; rank[rootY]) &#123;</span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootX] &gt; rank[rootY]) &#123;</span><br><span class="line">            parent[rootY] = rootX;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将前者所在的树的根节点连接到后者所在的树的根节点上</span></span><br><span class="line">            <span class="comment">// 被连接的树的高度将会加一, 对应的 rank 值加一</span></span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">            rank[rootY]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isSameSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> findSet(parent, x) == findSet(parent, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *pa, <span class="type">const</span> <span class="type">void</span> *pb)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((Edge *)pa)-&gt;h - ((Edge *)pb)-&gt;h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">minimumEffortPath</span><span class="params">(<span class="type">int</span>** heights, <span class="type">int</span> heightsSize, <span class="type">int</span>* heightsColSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> m = heightsSize, n = *heightsColSize;</span><br><span class="line">    <span class="keyword">if</span> (m * n &lt;= <span class="number">1</span>) &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在矩阵中向右、向下移动，移动可以产生这么多线段（最后一行和最后一列不能移动）</span></span><br><span class="line">    Edge edgeInfo[m * n * <span class="number">2</span>]; <span class="comment">// 实际为 m * n * 2 - m - n;</span></span><br><span class="line">    <span class="type">int</span> edgeSize = <span class="number">0</span>, id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">            id = i * n + j; <span class="comment">// 将二维坐标按行转换为一维坐标点</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; m - <span class="number">1</span>) &#123; <span class="comment">// 向右（对于目的点到源点就是向左）</span></span><br><span class="line">                edgeInfo[edgeSize].from = id;</span><br><span class="line">                edgeInfo[edgeSize].to = id + n;</span><br><span class="line">                edgeInfo[edgeSize].h = <span class="built_in">fabs</span>(heights[i][j] - heights[i + <span class="number">1</span>][j]);</span><br><span class="line">                edgeSize++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; n - <span class="number">1</span>) &#123; <span class="comment">// 向下（对于目的点到源点就是向上）</span></span><br><span class="line">                edgeInfo[edgeSize].from = id;</span><br><span class="line">                edgeInfo[edgeSize].to = id + <span class="number">1</span>;</span><br><span class="line">                edgeInfo[edgeSize].h = <span class="built_in">fabs</span>(heights[i][j] - heights[i][j + <span class="number">1</span>]);</span><br><span class="line">                edgeSize++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    qsort(edgeInfo, edgeSize, <span class="keyword">sizeof</span>(Edge), cmp); <span class="comment">// 按高度差的绝对值排序</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ufSize = m * n; <span class="comment">// 用实际的 edgeSize 会有问题（考虑仅一次移动时，有两个坐标点）</span></span><br><span class="line">    <span class="type">int</span> parent[ufSize], rank[ufSize];</span><br><span class="line">    init(&amp;parent, &amp;rank, ufSize);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edgeSize; i++) &#123; <span class="comment">// 现在按高度顺序遍历每一次移动</span></span><br><span class="line">        unionSet(&amp;parent, &amp;rank, edgeInfo[i].from, edgeInfo[i].to); <span class="comment">// 合并该次移动</span></span><br><span class="line">        <span class="comment">// 经过数次移动后，如果左上角和右下角的点在同一个集合中，那么首尾已经连通，即为答案</span></span><br><span class="line">        <span class="comment">// 因为，这次移动的高度差就是首尾连通路径上的最大高度差，但同时也是所有可能的首尾连通路径上的最小高度差</span></span><br><span class="line">        <span class="keyword">if</span> (isSameSet(&amp;parent, <span class="number">0</span>, m * n - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> edgeInfo[i].h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ~(<span class="number">0x1</span>U &lt;&lt; <span class="number">31</span>); <span class="comment">// 无效返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>本题有多种解法，如二分查找、并查集、dijkstra 算法，有时间再补充。</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>图</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>并查集</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 146 LRU 缓存</title>
    <url>/posts/231201184542.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/lru-cache/">LRU 缓存</a>：请你设计并实现一个满足 LRU（Least Recently Used）缓存约束的数据结构。</p>
<p>实现 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code> 以正整数作为容量 <code>capacity</code> 初始化 LRU 缓存。</li>
<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code>。</li>
<li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该逐出最久未使用的关键字。</li>
</ul>
<p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入 </span><br><span class="line">[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br><span class="line"> 输出 </span><br><span class="line">[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br><span class="line"></span><br><span class="line"> 解释</span><br><span class="line">LRUCache lRUCache = new LRUCache(2);</span><br><span class="line">lRUCache.put(1, 1); // 缓存是 &#123;1=1&#125;</span><br><span class="line">lRUCache.put(2, 2); // 缓存是 &#123;1=1, 2=2&#125;</span><br><span class="line">lRUCache.get(1);    // 返回 1</span><br><span class="line">lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br><span class="line">lRUCache.get(2);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br><span class="line">lRUCache.get(1);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.get(3);    // 返回 3</span><br><span class="line">lRUCache.get(4);    // 返回 4</span><br></pre></td></tr></table></figure>

<h2 id="题目分析"><a href="# 题目分析" class="headerlink" title="题目分析"></a>题目分析 </h2><p> 最近最久使用页面置换算法（Least Recently Used, LRU）是操作系统中局部页面置换算法中性能较好的一种算法，当一个缺页中断发生时，它选择 <strong> 最近最久未使用 </strong> 的那个页面淘汰。</p>
<p>在题目中，如果 <code>get</code> 方法获取的关键字存在于缓存中，除了要返回关键字对应的值，同时这条记录将会被刷新为最近（最新）被使用的一条记录。同样地，如果 <code>put</code> 方法存储的关键字存在于缓存中，除了要修改关键字对应的值，同时这条记录也将会被刷新为最近（最新）被使用的一条记录。</p>
<p>题目还要求使用 <code>O(1)</code> 的平均时间复杂度完成 <code>get</code> 和 <code>put</code> 方法，这可以使用「双向链表」和「哈希表」来共同设计这个 LRU 缓存数据结构。</p>
<h2 id="双向链表 - 哈希表"><a href="# 双向链表 - 哈希表" class="headerlink" title="双向链表 + 哈希表"></a>双向链表 + 哈希表 </h2><p> 使用「双向链表」和「哈希表」来共同设计这个 LRU 缓存数据结构：</p>
<ul>
<li>双向链表用于维护缓存中的记录，使得这些记录按照访问时间顺序排序，也就是「链表头为最近最久未使用」的一条记录，「链表尾为最新使用」的一条记录。</li>
<li>哈希表用于存储「节点关键字和它在链表中的地址」。</li>
</ul>
<p>这样，我们在进行 <code>get</code> 操作时，可以使用关键字查找哈希表中的 <code>key</code>，来获取它在双向链表中的地址：</p>
<ul>
<li>若查找失败，则返回 <code>-1</code>；</li>
<li>若查找成功，则将对应的节点从链表头部（或中间、尾部）移动到链表的尾部。</li>
</ul>
<p>在进行 <code>put</code> 操作时，可以使用关键字查找哈希表中的 <code>key</code>，来获取它在双向链表中的地址：</p>
<ul>
<li>若查找成功，则将对应的节点从链表头部（或中间、尾部）移动到链表的尾部；</li>
<li>若查找失败，则需要新建一个节点并将其追加到链表尾部，在追加节点前，需要判断缓存大小是否小于容量大小：<ul>
<li>若小于，则直接新建一个节点并将其追加到链表尾部即可；</li>
<li>若不小于，则需要删除链表头的节点，并将该节点从哈希表中删除；再新建一个节点并将其追加到链表尾部。</li>
</ul>
</li>
</ul>
<h3 id="数据结构设计"><a href="# 数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计 </h3><p> 双向链表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义双向链表的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">doubleLinked</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> page;  <span class="comment">// 键，逻辑页面</span></span><br><span class="line">    <span class="type">int</span> frame;  <span class="comment">// 值，物理页帧面</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">doubleLinked</span> *<span class="title">prev</span>;</span>  <span class="comment">// 前一个节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">doubleLinked</span> *<span class="title">next</span>;</span>  <span class="comment">// 后一个节点指针</span></span><br><span class="line">&#125; stDLinked;</span><br></pre></td></tr></table></figure>

<p>哈希表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义哈希表的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> key;  <span class="comment">// 键，对应着双向链表的键</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">doubleLinked</span> *<span class="title">dlNode</span>;</span>  <span class="comment">// 双向链表节点指针</span></span><br><span class="line">    UT_hash_handle hh;  <span class="comment">// 哈希表句柄</span></span><br><span class="line">&#125; stHash;</span><br></pre></td></tr></table></figure>

<p>LRU 缓存：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 LRU 缓存的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    stDLinked *front;  <span class="comment">// 链表头指针</span></span><br><span class="line">    stDLinked *rear;  <span class="comment">// 链表尾指针</span></span><br><span class="line">    stHash *hashTbl;  <span class="comment">// 哈希表指针</span></span><br><span class="line">    <span class="type">int</span> size;  <span class="comment">// 当前缓存大小</span></span><br><span class="line">    <span class="type">int</span> capacity;  <span class="comment">// 缓存容量</span></span><br><span class="line">&#125; LRUCache;</span><br></pre></td></tr></table></figure>

<p>上述数据结构关系图：</p>
<img src="../images/data-structure/LRU-cache-struct.png" alt="LRU 缓存结构" width="100%" height="100%">

<h3 id="接口实现"><a href="# 接口实现" class="headerlink" title="接口实现"></a>接口实现 </h3><p> 创建 LRU 缓存：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 LRU 缓存</span></span><br><span class="line">LRUCache *<span class="title function_">lRUCacheCreate</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    LRUCache *lru = (LRUCache *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LRUCache));</span><br><span class="line">    lru-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    lru-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    lru-&gt;hashTbl = <span class="literal">NULL</span>; <span class="comment">// 哈希表指针初始化为空</span></span><br><span class="line">    lru-&gt;size = <span class="number">0</span>;</span><br><span class="line">    lru-&gt;capacity = capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lru;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现 <code>get</code> 方法和 <code>put</code> 方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printDLinked</span><span class="params">(stDLinked *node)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;print DL: &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d)-&gt;&quot;</span>, node-&gt;page, node-&gt;frame);</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将指定的节点移动到尾结点后</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dlNodeMoveToRear</span><span class="params">(LRUCache *obj, stDLinked *node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    stDLinked *prevNode = node-&gt;prev;</span><br><span class="line">    stDLinked *nextNode = node-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定的节点是链表首节点，但不是链表尾结点</span></span><br><span class="line">    <span class="keyword">if</span> (!prevNode &amp;&amp; nextNode) &#123;</span><br><span class="line">        nextNode-&gt;prev = prevNode;</span><br><span class="line">        obj-&gt;front = nextNode;</span><br><span class="line">        obj-&gt;rear-&gt;next = node;</span><br><span class="line">        node-&gt;prev = obj-&gt;rear;</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        obj-&gt;rear = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevNode &amp;&amp; nextNode) &#123; <span class="comment">// 指定的节点是链表中间节点</span></span><br><span class="line">        nextNode-&gt;prev = prevNode;</span><br><span class="line">        prevNode-&gt;next = nextNode;</span><br><span class="line">        obj-&gt;rear-&gt;next = node;</span><br><span class="line">        node-&gt;prev = obj-&gt;rear;</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        obj-&gt;rear = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 指定的节点是链表尾结点无需处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 LRU 缓存</span></span><br><span class="line">LRUCache *<span class="title function_">lRUCacheCreate</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    LRUCache *lru = (LRUCache *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LRUCache));</span><br><span class="line">    lru-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    lru-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    lru-&gt;hashTbl = <span class="literal">NULL</span>; <span class="comment">// 哈希表指针初始化为空</span></span><br><span class="line">    lru-&gt;size = <span class="number">0</span>;</span><br><span class="line">    lru-&gt;capacity = capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lru;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定的逻辑页面对应的物理页帧号，若存在，则一并将该页表项移动到链表尾部</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lRUCacheGet</span><span class="params">(LRUCache *obj, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line">    stHash *hashNode = <span class="literal">NULL</span>;</span><br><span class="line">    HASH_FIND_INT(obj-&gt;hashTbl, &amp;key, hashNode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hashNode) &#123;</span><br><span class="line">        res = hashNode-&gt;dlNode-&gt;frame;</span><br><span class="line">        dlNodeMoveToRear(obj, hashNode-&gt;dlNode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;Get: (%d, %d) &quot;, key, res);</span></span><br><span class="line">    <span class="comment">// printDLinked(obj-&gt;front);</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往链表中插入页表项，若逻辑页面存在，则修改对应的物理页帧号并将该页表项移动到链表尾部，</span></span><br><span class="line"><span class="comment">// 不存在，则直接将该页表项移动到链表尾部</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lRUCachePut</span><span class="params">(LRUCache *obj, <span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    stHash *hashNode = <span class="literal">NULL</span>;</span><br><span class="line">    HASH_FIND_INT(obj-&gt;hashTbl, &amp;key, hashNode);</span><br><span class="line">    <span class="keyword">if</span> (hashNode) &#123; <span class="comment">// 一. 存在逻辑页面，则直接移动该页表项到链表尾部</span></span><br><span class="line">        dlNodeMoveToRear(obj, hashNode-&gt;dlNode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 二. 不存在逻辑页面，则将该页表项移动到链表尾部</span></span><br><span class="line">        <span class="comment">// 0. 申请追加的链表节点</span></span><br><span class="line">        stDLinked *addNode = (stDLinked *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stDLinked));</span><br><span class="line">        addNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        addNode-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 先检查链表长度是否大于等于最大容量，是则先删除链表头，再追加节点</span></span><br><span class="line">        <span class="keyword">if</span> (obj-&gt;size &gt;= obj-&gt;capacity) &#123;</span><br><span class="line">            <span class="comment">// 1.1 获取链表头节点，并与双向链表断开</span></span><br><span class="line">            stDLinked *delNode = obj-&gt;front;</span><br><span class="line">            obj-&gt;front = obj-&gt;front-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (obj-&gt;front) &#123; obj-&gt;front-&gt;prev = <span class="literal">NULL</span>; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1.2 从哈希表中删除对应的哈希节点</span></span><br><span class="line">            stHash *delHashNode = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="type">int</span> delKey = delNode-&gt;page;</span><br><span class="line">            HASH_FIND_INT(obj-&gt;hashTbl, &amp;delKey, delHashNode);</span><br><span class="line">            HASH_DEL(obj-&gt;hashTbl, delHashNode);</span><br><span class="line">            <span class="built_in">free</span>(delHashNode);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1.3 释放链表节点空间</span></span><br><span class="line">            delNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(delNode);</span><br><span class="line">            <span class="comment">// 1.4 链表长度减一</span></span><br><span class="line">            obj-&gt;size--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 追加节点：分为链表为空和非空两种情况</span></span><br><span class="line">        <span class="keyword">if</span> (obj-&gt;size == <span class="number">0</span>) &#123;</span><br><span class="line">            obj-&gt;front = addNode;</span><br><span class="line">            obj-&gt;rear = obj-&gt;front;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            obj-&gt;rear-&gt;next = addNode;</span><br><span class="line">            addNode-&gt;prev = obj-&gt;rear;</span><br><span class="line">            obj-&gt;rear = addNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 追加节点后，将其添加到哈希表中</span></span><br><span class="line">        hashNode = (stHash *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stHash));</span><br><span class="line">        hashNode-&gt;key = key;</span><br><span class="line">        hashNode-&gt;dlNode = addNode;</span><br><span class="line">        HASH_ADD_INT(obj-&gt;hashTbl, key, hashNode);</span><br><span class="line">        <span class="comment">// 4. 追加节点后，链表长度加一</span></span><br><span class="line">        obj-&gt;size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 三. 最后，统一修改或添加逻辑页面对应的物理页面</span></span><br><span class="line">    hashNode-&gt;dlNode-&gt;page = key;</span><br><span class="line">    hashNode-&gt;dlNode-&gt;frame = value;</span><br><span class="line">    <span class="comment">// printf(&quot;Put: (%d, %d) &quot;, key, value);</span></span><br><span class="line">    <span class="comment">// printDLinked(obj-&gt;front);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放哈希表空间</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hashFree</span><span class="params">(stHash **obj)</span> &#123;</span><br><span class="line">    stHash *curr = <span class="literal">NULL</span>, *tmp = <span class="literal">NULL</span>;</span><br><span class="line">    HASH_ITER(hh, *obj, curr, tmp) &#123;</span><br><span class="line">        HASH_DEL(*obj, curr);</span><br><span class="line">        <span class="built_in">free</span>(curr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放 LRU 缓存空间</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lRUCacheFree</span><span class="params">(LRUCache *obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        hashFree(&amp;(obj-&gt;hashTbl));</span><br><span class="line">        <span class="keyword">while</span> (obj-&gt;front) &#123;</span><br><span class="line">            stDLinked *tmp = obj-&gt;front;</span><br><span class="line">            obj-&gt;front = obj-&gt;front-&gt;next;</span><br><span class="line">            tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = lRUCacheCreate(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = lRUCacheGet(obj, key);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * lRUCachePut(obj, key, value);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * lRUCacheFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="代码执行结果"><a href="# 代码执行结果" class="headerlink" title="代码执行结果"></a>代码执行结果 </h2><p> 针对上面的测试用例，给出了每步操作后的双向链表的内容，如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Put: (1, 1) print DL: (1, 1)-&gt;NULL</span><br><span class="line">Put: (2, 2) print DL: (1, 1)-&gt;(2, 2)-&gt;NULL</span><br><span class="line">Get: (1, 1) print DL: (2, 2)-&gt;(1, 1)-&gt;NULL</span><br><span class="line">Put: (3, 3) print DL: (1, 1)-&gt;(3, 3)-&gt;NULL</span><br><span class="line">Get: (2, -1) print DL: (1, 1)-&gt;(3, 3)-&gt;NULL</span><br><span class="line">Put: (4, 4) print DL: (3, 3)-&gt;(4, 4)-&gt;NULL</span><br><span class="line">Get: (1, -1) print DL: (3, 3)-&gt;(4, 4)-&gt;NULL</span><br><span class="line">Get: (3, 3) print DL: (4, 4)-&gt;(3, 3)-&gt;NULL</span><br><span class="line">Get: (4, 4) print DL: (3, 3)-&gt;(4, 4)-&gt;NULL</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>设计</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>LeetCode</tag>
        <tag>双向链表</tag>
        <tag>页面置换算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 160 相交链表</title>
    <url>/posts/231025143947.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists">160 相交链表</a>：编写一个程序，找到两个无环单链表相交的起始节点，如果不存在交点则返回 <code>null</code>。要求时间复杂度为 <code>O(m+n)</code>，空间复杂度为 <code>O(1)</code>。</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A:          a1 → a2</span><br><span class="line">                    ↘</span><br><span class="line">                      c1 → c2 → c3</span><br><span class="line">                    ↗</span><br><span class="line">B:    b1 → b2 → b3</span><br></pre></td></tr></table></figure>

<p>但是不会出现以下相交的情况，因为每个节点只有 <strong> 一个</strong> <code>next</code> 指针，也就只能有一个后继节点，而以下示例中节点 <code>c</code> 有两个后继节点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A:          a1 → a2       d1 → d2</span><br><span class="line">                    ↘  ↗</span><br><span class="line">                      c</span><br><span class="line">                    ↗  ↘</span><br><span class="line">B:    b1 → b2 → b3        e1 → e2</span><br></pre></td></tr></table></figure>

<h2 id="暴力解法"><a href="# 暴力解法" class="headerlink" title="暴力解法"></a>暴力解法 </h2><p> 两重循环，对于链表 A 的每一个节点，依次从头到尾遍历链表 B 的每一个节点，当链表 A 的当前节点与链表 B 的当前节点 <strong> 首次 </strong> 相同时，即为相交的起始节点，即可返回答案。</p>
<p>很显然，时间复杂度：<code>O(mn)</code>，空间复杂度：<code>O(1)</code>，不满足题意。</p>
<h2 id="哈希表解法"><a href="# 哈希表解法" class="headerlink" title="哈希表解法"></a>哈希表解法 </h2><p> 遍历链表 A 时存储指针地址到哈希表中。遍历链表 B 时，判断当前节点是否在哈希表中，若在（<strong>第一个 </strong> 在的），即为相交的起始节点，即可返回答案。</p>
<p>很显然，时间复杂度：<code>O(m+n)</code>，空间复杂度：<code>O(m)</code>，不满足题意。</p>
<h2 id="双指针解法"><a href="# 双指针解法" class="headerlink" title="双指针解法"></a>双指针解法 </h2><p> 设链表 A 的长度为 a + c，链表 B 的长度为 b + c，其中 c 为尾部公共部分长度，<strong>可知长度满足：a + c + b = b + c + a</strong>。</p>
<p>当访问链表 A 的指针访问到链表尾部时，<strong>令它从链表 B 的头部开始访问链表 B</strong>；同样地，当访问链表 B 的指针访问到链表尾部时，<strong>令它从链表 A 的头部开始访问链表 A</strong>。</p>
<p>这样就能控制访问 A 和 B 两个链表的指针 <strong> 能同时访问到相交点 </strong>。如果不存在交点，那么 a + b = b + a，以下实现代码中<code>nodeA</code> 和<code>nodeB</code>会同时为<code>null</code>，从而退出循环。</p>
<p>时间复杂度：<code>O(m+n)</code>，空间复杂度：<code>O(1)</code>，满足题意。</p>
<p>C 语言实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode *<span class="title function_">getIntersectionNode</span><span class="params">(<span class="keyword">struct</span> ListNode *headA, <span class="keyword">struct</span> ListNode *headB)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">nodeA</span> =</span> headA, *nodeB = headB;</span><br><span class="line">    <span class="keyword">while</span> (nodeA != nodeB) &#123;</span><br><span class="line">        nodeA = (nodeA != <span class="literal">NULL</span> ? nodeA-&gt;next : headB);</span><br><span class="line">        nodeB = (nodeB != <span class="literal">NULL</span> ? nodeB-&gt;next : headA);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nodeA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Python 语言实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        nodeA, nodeB = headA, headB</span><br><span class="line">        <span class="keyword">while</span>(nodeA != nodeB):</span><br><span class="line">            nodeA = headB <span class="keyword">if</span>(nodeA == <span class="literal">None</span>) <span class="keyword">else</span> nodeA.<span class="built_in">next</span></span><br><span class="line">            nodeB = headA <span class="keyword">if</span>(nodeB == <span class="literal">None</span>) <span class="keyword">else</span> nodeB.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> nodeA</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 206 反转链表</title>
    <url>/posts/231025185947.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206 反转链表</a>：反转一个单链表。例如，输入：<code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>；输出：<code>5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code>。</p>
<span id="more"></span>

<h2 id="LIFO 堆栈解法"><a href="#LIFO 堆栈解法" class="headerlink" title="LIFO 堆栈解法"></a>LIFO 堆栈解法 </h2><p> 可以使用堆栈的后进先出特性来实现链表的反转。遍历链表中的节点，并存储在堆栈中；遍历完后，依次弹出堆栈中的节点，并将它与上一个节点链接起来。</p>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(n)</code>。</p>
<h2 id="双指针解法"><a href="# 双指针解法" class="headerlink" title="双指针解法"></a>双指针解法 </h2><p> 可以借助一前一后两个指针，在遍历链表的过程中，将两个前后两个节点的指向关系反转。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1  2  3  4  5  NULL</span><br><span class="line"> -&gt; -&gt; -&gt; -&gt; -&gt;</span><br><span class="line"> &lt;- &lt;- &lt;- &lt;- &lt;-</span><br></pre></td></tr></table></figure>

<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">pre</span> =</span> head, *cur = head-&gt;next;  <span class="comment">// 双指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">suff</span> =</span> <span class="literal">NULL</span>, *tail = <span class="literal">NULL</span>;  <span class="comment">// 临时指针和结果指针</span></span><br><span class="line">    pre-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            tail = cur;  <span class="comment">// 记录最后一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        suff = cur-&gt;next;  <span class="comment">// 记录下一个节点</span></span><br><span class="line">        cur-&gt;next = pre;  <span class="comment">// 转向关系反转</span></span><br><span class="line">        pre = cur;  <span class="comment">// 更新上一个节点</span></span><br><span class="line">        cur = suff;  <span class="comment">// 更新当前节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="头插法"><a href="# 头插法" class="headerlink" title="头插法"></a>头插法 </h2><p> 对于链表中的每一个节点，我们 <strong> 都将它插在新链表的头结点之前</strong>，对于链表 <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>：</p>
<ol>
<li>遍历前新链表为 <code>NULL</code>；</li>
<li>遍历第一个节点时，将其插入在新链表 <code>NULL</code> 的头结点之前，更新后的链表为 <code>1-&gt;NULL</code>;</li>
<li>遍历第二个节点时，将其插入在新链表 <code>1-&gt;NULL</code> 的头结点之前，更新后的链表为 <code>2-&gt;1-&gt;NULL</code>;</li>
<li>…</li>
<li>遍历最后一个节点时，将其插入在新链表 <code>4-&gt;3-&gt;2-&gt;1-&gt;NULL</code> 的头结点之前，更新后的链表为 <code>5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code>;</li>
</ol>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">newHead</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> =</span> head;  <span class="comment">// 当前节点</span></span><br><span class="line">        head = head-&gt;next;  <span class="comment">// 先找到下一个节点</span></span><br><span class="line">        cur-&gt;next = newHead;  <span class="comment">// 当前节点指向新链表的头</span></span><br><span class="line">        newHead = cur;  <span class="comment">// 更新新链表的头</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>双指针解法与头插法有什么区别？</p>
</blockquote>
<p>双指针解法是反转前后两个节点的指向关系；头插法是初始化一个新的空链表，依次将待反转链表的节点，追加在新链表的最前面。</p>
<h2 id="递归解法"><a href="# 递归解法" class="headerlink" title="递归解法"></a>递归解法 </h2><p> 假设我们要反转链表 <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>，可以先反转节点 <code>1</code> 后面 <strong> 更短的链表</strong>，即 <code>2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>，这会得到 <code>5-&gt;4-&gt;3-&gt;2-&gt;NULL</code>。最后，再将节点 <code>1</code> 链接到上面反转的链表的最后一个非空节点（即节点 <code>2</code>）和 <code>NULL</code> 节点之间。</p>
<p>递归的终止条件就是链表无需反转了，即链表没有节点或只有一个节点。</p>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(n)</code>，递归深度可能达到 <code>n</code> 层。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur</span> =</span> reverseList(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是用递归方式实现单链表的反转。让我们逐行解析代码的实现原理：</p>
<ol>
<li>首先，检查头指针 <code>head</code> 是否为空或者链表只有一个节点（即 <code>head-&gt;next</code> 为空）。如果是的话，直接返回头指针。</li>
<li>如果链表有多个节点，递归调用 <code>reverseList</code> 函数，传入 <code>head-&gt;next</code> 作为参数，<strong>目的是将 <code>head-&gt;next</code> 节点及之后的节点进行反转</strong>。</li>
<li>在递归调用之后，我们得到了反转后的链表的头指针 <code>cur</code>，它的尾结点是 <code>head-&gt;next</code>。</li>
<li>然后，我们 <strong> 将 <code>head</code> 节点插入到反转后的链表的末尾</strong>，即 <code>head-&gt;next-&gt;next = head</code>。这一步是将 <code>head</code> 节点的下一个节点（<code>head-&gt;next</code>）指向 <code>head</code>，实现反转。</li>
<li>最后，将 <code>head</code> 的下一个节点指向 <code>NULL</code>，以确保链表的末尾指向 <code>NULL</code>。</li>
<li>返回反转后的链表的头指针 <code>cur</code>。</li>
</ol>
<p>这段代码的核心思想是通过递归来实现链表的反转。通过不断地调用 <code>reverseList</code> 函数，<strong>每次反转两个节点</strong>，最终实现整个链表的反转。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 21 合并两个有序链表</title>
    <url>/posts/231026101239.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21 合并两个有序链表</a>：输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">    链表 A：1-&gt;2-&gt;4</span><br><span class="line">    链表 B：1-&gt;3-&gt;4</span><br><span class="line">    合并链表：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>

<h2 id="双指针解法"><a href="# 双指针解法" class="headerlink" title="双指针解法"></a>双指针解法 </h2><p> 使用两个指针遍历链表，分别指向链表 A 和链表 B 的头结点，然后比较两个指针所指向的节点的大小关系，将较小的节点链接到合并链表的末尾，并后移对应的指针；直到其中一个指针为空时，将另一个非空指针指向的剩余链表拼接到合并链表的末尾。</p>
<p>时间复杂度：<code>O(m+n)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">mergeTwoLists</span><span class="params">(<span class="keyword">struct</span> ListNode* list1, <span class="keyword">struct</span> ListNode* list2)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据大小关系确定合并链表的头结点, 并确定每个链表的起始位置</span></span><br><span class="line">    <span class="keyword">if</span> (list1-&gt;val &lt;= list2-&gt;val) &#123;</span><br><span class="line">        head = list1;</span><br><span class="line">        list1 = list1-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        head = list2;</span><br><span class="line">        list2 = list2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> =</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (list1 &amp;&amp; list2) &#123;</span><br><span class="line">        <span class="comment">// 比较两个指针所指向的节点的大小关系，将较小的节点链接到合并链表的末尾</span></span><br><span class="line">        <span class="keyword">if</span> (list1-&gt;val &lt;= list2-&gt;val) &#123;</span><br><span class="line">            cur-&gt;next = list1;</span><br><span class="line">            list1 = list1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur-&gt;next = list2;</span><br><span class="line">            list2 = list2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将非空指针指向的剩余链表拼接到合并链表的末尾</span></span><br><span class="line">    cur-&gt;next = (list1 == <span class="literal">NULL</span> ? list2 : list1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的双指针直接复用的两个链表指针变量。</p>
</blockquote>
<p>上面代码虽然清晰，但是有点长了。其实，我们可以 <strong> 利用一个临时的「哑结点」作为合并链表的头结点的上一个节点</strong>，来简化操作。</p>
<p>这样，就不需要上面代码中 <code>while</code> 循环前的「根据大小关系确定合并链表的头结点, 并确定每个链表的起始位置」判断了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">mergeTwoLists</span><span class="params">(<span class="keyword">struct</span> ListNode* list1, <span class="keyword">struct</span> ListNode* list2)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>;</span>  <span class="comment">// 哑结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> =</span> &amp;dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (list1 &amp;&amp; list2) &#123;</span><br><span class="line">        <span class="comment">// 比较两个指针所指向的节点的大小关系，将较小的节点链接到合并链表的末尾</span></span><br><span class="line">        <span class="keyword">if</span> (list1-&gt;val &lt;= list2-&gt;val) &#123;</span><br><span class="line">            cur-&gt;next = list1;</span><br><span class="line">            list1 = list1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur-&gt;next = list2;</span><br><span class="line">            list2 = list2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将非空指针指向的剩余链表拼接到合并链表的末尾</span></span><br><span class="line">    cur-&gt;next = (list1 == <span class="literal">NULL</span> ? list2 : list1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.next;  <span class="comment">// 返回哑结点的下一个节点, 即为合并链表的头结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归解法"><a href="# 递归解法" class="headerlink" title="递归解法"></a>递归解法 </h2><p> 我们同样可以利用递归实现合并两个链表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">mergeTwoLists</span><span class="params">(<span class="keyword">struct</span> ListNode* list1, <span class="keyword">struct</span> ListNode* list2)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (list1-&gt;val &lt;= list2-&gt;val) &#123;</span><br><span class="line">        list1-&gt;next = mergeTwoLists(list1-&gt;next, list2);</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list2-&gt;next = mergeTwoLists(list1, list2-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这种写法，跟双指针解法中的第一个代码块相似，直接在原有的链表上进行操作，并直接返回较小节点的头节点作为合并后的链表头。</p>
<p>同样地，我们也可以像双指针解法中的第二个代码块那样，利用一个哑结点，将哑结点的下一个节点指向链表 A 和链表 B 中较小的节点 N，并递归地将较小的节点 N 指向后续合并链表的头结点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">mergeTwoLists</span><span class="params">(<span class="keyword">struct</span> ListNode* list1, <span class="keyword">struct</span> ListNode* list2)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> =</span> &amp;dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (list1-&gt;val &lt;= list2-&gt;val) &#123;</span><br><span class="line">        cur-&gt;next = list1;</span><br><span class="line">        list1-&gt;next = mergeTwoLists(list1-&gt;next, list2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cur-&gt;next = list2;</span><br><span class="line">        list2-&gt;next = mergeTwoLists(list1, list2-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">    cur = cur-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 19 删除链表的倒数第 N 个节点</title>
    <url>/posts/231027150243.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19 删除链表的倒数第 N 个节点</a>：给定一个链表，删除链表的倒数第 N 个节点，并且返回链表的头节点。进阶：你能尝试使用一趟扫描实现吗？</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>

<h2 id="两趟遍历"><a href="# 两趟遍历" class="headerlink" title="两趟遍历"></a>两趟遍历 </h2><p> 删除倒数第 <code>n</code> 个，即需要统计链表长度 <code>L</code>，然后删除正数第 <code>L-n+1</code> 个即可。</p>
<p>第一趟遍历：统计链表长度；第二趟遍历：删除节点。</p>
<p>时间复杂度：<code>O(L)</code>，遍历了两遍链表，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeNthFromEnd</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node</span> =</span> head;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    node = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除的是第一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (n == size) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newHead</span> =</span> head-&gt;next;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(head);</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">temp</span> =</span> node-&gt;next;</span><br><span class="line">    node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">    temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快慢指针（一趟遍历）"><a href="# 快慢指针（一趟遍历）" class="headerlink" title="快慢指针（一趟遍历）"></a>快慢指针（一趟遍历）</h2><p>进阶：你能尝试使用一趟扫描实现吗？</p>
<p>我们可以使用两个指针（快慢指针），让快指针先走 <code>n</code> 步，然后快指针和慢指针同时、同速度走，当快指针走完时，慢指针刚好走了 <code>L-n</code> 步。</p>
<p>时间复杂度：<code>O(L)</code>，遍历了一遍链表，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeNthFromEnd</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">slow</span> =</span> head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除的是第一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newHead</span> =</span> head-&gt;next;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(head);</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next) &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">temp</span> =</span> slow-&gt;next;</span><br><span class="line">    slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">    temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 2477 达到首都的最少油耗</title>
    <url>/posts/231206201243.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/">2477 达到首都的最少油耗</a>：给你一棵 <code>n</code> 个节点的树（一个无向、连通、无环图），每个节点表示一个城市，编号从 <code>0</code> 到 <code>n - 1</code> ，且恰好有 <code>n - 1</code> 条路，<code>0</code> 是首都。给你一个二维整数数组 <code>roads</code> ，其中 <code>roads[i] = [a_i, b_i]</code> ，表示城市 <code>a_i</code> 和 <code>b_i</code> 之间有一条双向路。</p>
<ul>
<li>每个城市有一辆车（均有 <code>seats</code> 个座位），且每个城市需要一名代表去首都参加会议。</li>
<li>代表可以选择乘坐自己所在城市的车辆，也可以选择乘坐其他城市的车辆。</li>
<li>相邻城市之间的车辆油耗是一升。</li>
</ul>
<p>你需要计算所有代表到达首都所需的最少汽油量。</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">- 代表 2 到达城市 3 ，消耗 1 升汽油。</span><br><span class="line">- 代表 2 和代表 3 一起到达城市 1 ，消耗 1 升汽油。</span><br><span class="line">- 代表 2 和代表 3 一起到达首都，消耗 1 升汽油。</span><br><span class="line">- 代表 1 直接到达首都，消耗 1 升汽油。</span><br><span class="line">- 代表 5 直接到达首都，消耗 1 升汽油。</span><br><span class="line">- 代表 6 到达城市 4 ，消耗 1 升汽油。</span><br><span class="line">- 代表 4 和代表 6 一起到达首都，消耗 1 升汽油。</span><br><span class="line">最少消耗 7 升汽油。</span><br></pre></td></tr></table></figure>

<h2 id="形象化数组"><a href="# 形象化数组" class="headerlink" title="形象化数组"></a>形象化数组 </h2><p> 将数组转换为树的形状：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       0</span><br><span class="line">     / | \</span><br><span class="line">    1  4  5</span><br><span class="line">   /   |</span><br><span class="line">  3    6</span><br><span class="line"> /</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h2 id="问题转换与解题思路"><a href="# 问题转换与解题思路" class="headerlink" title="问题转换与解题思路"></a>问题转换与解题思路 </h2><p> 题目等价于给出了一棵以节点 <code>0</code> 为根节点的多叉树，初始时树上的每一个节点都有一个人和一辆车，现在所有人都需要通过「车子」向节点 <code>0</code> 移动。</p>
<p>我们可以 <strong> 贪心地 </strong> 从每个叶子节点派车出发，只要车上还有空座位，就把该节点的人拉上车，并向根节点移动。要是车上没有座位了，那么就增派一辆车，也向根节点移动。这样就能保证所有人都到达首都，且油耗最少。</p>
<p>对于上面的示例路径 <code>2-&gt;3-&gt;1-&gt;0</code>，按上面的思路，有：</p>
<ul>
<li>三个人需要去首都，在节点 <code>2</code> 派出一辆车，在节点 <code>1</code> 增派了一辆车，一共需要两辆车，消耗 4 升汽油。</li>
</ul>
<p>通过观察分析，我们可以发现：</p>
<ul>
<li><code>x</code> 个人通过某一段公路到达「该段路的终点」，该段路 <strong> 需要消耗的油量（需要的车辆数）为「人数 / 座位数」向上取整</strong>。如：<ul>
<li>节点 <code>2</code> 一起移动到节点 <code>3</code>，需要的汽油总量为 <code>ceil(1, 2) = 1</code>；</li>
<li>节点 <code>2,3</code> 一起移动到节点 <code>1</code>，需要的汽油总量为 <code>ceil(2, 2) = 1</code>；</li>
<li>节点 <code>2,3,1</code> 一起移动到节点 <code>0</code>，需要的汽油总量为 <code>ceil(3, 2) = 2</code>。</li>
</ul>
</li>
<li><strong>一条子树总共需要的油量为每一段路需要的油量（需要的车辆数）之和</strong>。</li>
</ul>
<p>那么，我们可以通过从根节点 <code>0</code> 往下进行 <strong> 深度优先搜索 </strong>，根据<strong> 路上累计的人数 </strong> 计算统计每一条边上消耗的汽油（需要的车辆数），把所有边上消耗的汽油相加即为最终答案。</p>
<h2 id="数据转换与存储"><a href="# 数据转换与存储" class="headerlink" title="数据转换与存储"></a>数据转换与存储 </h2><p> 题目使用了一个二维数组存储图数据，而我们需要的是每一个节点的邻居节点。所以首先需要将二维数组中的数据转换到邻接矩阵中，存储每个节点的邻居节点，而邻居节点的数量是不固定的。</p>
<p>对于 Python 语言，我们可以使用二维列表完成每个邻居节点的存储：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = roadsSize + <span class="number">1</span></span><br><span class="line">graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="keyword">for</span> edge <span class="keyword">in</span> roads:</span><br><span class="line">    x, y = edge[<span class="number">0</span>], edge[<span class="number">1</span>]</span><br><span class="line">    graph[x].append(y)</span><br><span class="line">    graph[y].append(x)</span><br></pre></td></tr></table></figure>

<p>对于 C 语言，我们需要定义一个二维结构体列表，列表中的每一个位置是一个链表，存储它的所有邻居节点（具体看后面的代码实现）。</p>
<blockquote>
<p>一个节点的所有邻居节点就是它在树中的父节点和子节点的集合，有些节点可能既有父节点又有子节点，而有些节点只有父节点。</p>
</blockquote>
<h2 id="贪心 - 深度优先搜索"><a href="# 贪心 - 深度优先搜索" class="headerlink" title="贪心 + 深度优先搜索"></a>贪心 + 深度优先搜索 </h2><p> 通过从根节点 <code>0</code> 往下进行 <strong> 深度优先搜索 </strong>，根据<strong> 路上累计的人数 </strong> 计算统计每一条边上消耗的汽油（需要的车辆数），把所有边上消耗的汽油相加即为最终答案。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单链表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">linked</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">linked</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; ListNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个链表节点</span></span><br><span class="line">ListNode *<span class="title function_">createListNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    ListNode *node = (ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    node-&gt;val = val;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放链表空间</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeList</span><span class="params">(ListNode *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">        ListNode *cur = <span class="built_in">list</span>;</span><br><span class="line">        <span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印链表内容</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(ListNode *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">list</span>-&gt;val);</span><br><span class="line">        <span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向上取整</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">myCeil</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b - <span class="number">1</span>) / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">minimumFuelCost</span><span class="params">(<span class="type">int</span>** roads, <span class="type">int</span> roadsSize, <span class="type">int</span>* roadsColSize, <span class="type">int</span> seats)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = roadsSize + <span class="number">1</span>; <span class="comment">// n 个节点有 n-1 条路，n-1=roadsSize</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个二维列表，存储每个节点的邻居节点（在树中看，邻居就是它的子节点和父节点）</span></span><br><span class="line">    ListNode **graph = (ListNode **)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(ListNode *));</span><br><span class="line">    <span class="built_in">memset</span>(graph, <span class="literal">NULL</span>, n * <span class="keyword">sizeof</span>(ListNode *));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; roadsSize; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x = roads[i][<span class="number">0</span>], y = roads[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// y 的邻居节点是 x，将 x 追加到节点 y 对应的列表中</span></span><br><span class="line">        ListNode *nodeX = createListNode(x);</span><br><span class="line">        nodeX-&gt;next = graph[y];</span><br><span class="line">        graph[y] = nodeX;</span><br><span class="line"></span><br><span class="line">        ListNode *nodeY = createListNode(y);</span><br><span class="line">        nodeY-&gt;next = graph[x];</span><br><span class="line">        graph[x] = nodeY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，每个节点的邻居节点就有了（邻居在列表中的顺序无关紧要）</span></span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     printf(&quot;node %d can be reached: &quot;, i);</span></span><br><span class="line">    <span class="comment">//     printList(graph[i]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">-1</span>, seats, &amp;res, graph); <span class="comment">// 从多叉树的根节点出发，向下遍历每棵子树</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        freeList(graph[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(graph);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> father, <span class="type">int</span> seats, <span class="type">long</span> <span class="type">long</span> *res, <span class="type">const</span> ListNode **graph)</span> &#123;</span><br><span class="line">    <span class="type">int</span> peopleSum = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历当前节点的邻居节点（包含父节点和子节点）</span></span><br><span class="line">    <span class="keyword">for</span> (ListNode *node = graph[cur]; node; node = node-&gt;next) &#123;</span><br><span class="line">        <span class="type">int</span> val = node-&gt;val;</span><br><span class="line">        <span class="comment">// 递归地遍历当前节点的子节点，不递归当前节点的父节点</span></span><br><span class="line">        <span class="keyword">if</span> (val != father) &#123;</span><br><span class="line">            <span class="comment">// 累计以当前节点为根的子节点人数</span></span><br><span class="line">            peopleSum += dfs(val, cur, seats, res, graph);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur != <span class="number">0</span>) &#123; <span class="comment">// 不是根节点时，计算耗油</span></span><br><span class="line">        *res += myCeil(peopleSum, seats);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> peopleSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码分析"><a href="# 代码分析" class="headerlink" title="代码分析"></a>代码分析 </h2><h3 id="向上取整"><a href="# 向上取整" class="headerlink" title="向上取整"></a> 向上取整</h3><p><code>a</code> 与 <code>b</code> 相除的向上取整公式：<code>(a + b - 1) / b</code>。因为 <code>a/b</code> 的余数最大为 <code>b-1</code>，我们多加一个 <code>b-1</code> 会使得：</p>
<ul>
<li>当原来余数为 <code>0</code> 时，新公式计算出来的商的部分还是原来的值；</li>
<li>当原来余数不为 <code>0</code> 时，多加的那部分 <code>b-1</code> 结合原来不为 <code>0</code> 的余数，会使得商的值加一。</li>
</ul>
<p>这样，便达到一个向上取整的效果。</p>
<h3 id="邻居节点"><a href="# 邻居节点" class="headerlink" title="邻居节点"></a>邻居节点 </h3><p> 每个节点的邻居节点打印（以上面的示例为例）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node 0 can be reached: 5 4 1 </span><br><span class="line">node 1 can be reached: 0 3 </span><br><span class="line">node 2 can be reached: 3 </span><br><span class="line">node 3 can be reached: 2 1 </span><br><span class="line">node 4 can be reached: 6 0 </span><br><span class="line">node 5 can be reached: 0 </span><br><span class="line">node 6 can be reached: 4 </span><br></pre></td></tr></table></figure>

<h3 id="DFS 理解"><a href="#DFS 理解" class="headerlink" title="DFS 理解"></a>DFS 理解 </h3><p> 在小破站上看到一个评论：</p>
<blockquote>
<p>处理递归，核心就是千万不要想子问题的过程，你的脑子才能处理几层？马上就绕迷糊了。重要的是，要想子问题的结果，思路就清晰了。</p>
<blockquote>
<p>是的，只要代码的边界条件和非边界条件的逻辑写对了，其它的事情交给数学归纳法就好了。也就是说，写对了这两个逻辑，你的代码自动就是正确的了，没必要想递归是怎么一层一层走的。</p>
</blockquote>
</blockquote>
<p><strong>基于上面的评论，这道题中的 DFS 需要做的是（个人理解）</strong>：</p>
<ol>
<li>从多叉树的根节点出发，向下遍历每棵子树（也就是递归地遍历当前节点的子节点，不递归当前节点的父节点）；</li>
<li>也就是说，当遍历的节点的邻居节点是父节点时，不再递归，会得到一个返回值 <code>1</code>；</li>
<li>当遍历的节点的邻居节点是子节点时，递归地遍历它的子节点，累计子树的大小（累计返回值）；</li>
<li>计算完子树大小后，计算到达该子树的根节点时的油耗，累加到最终结果中。</li>
</ol>
<p>例如，对于上面的序号 2，当遍历节点 <code>2</code> 时，递归函数是 <code>dfs(2, 3, ...)</code>，节点 <code>2</code> 中存储的节点是 <code>3</code>，也就是它的父节点，且它没有其它节点了。所以，<code>for</code> 循环结束，不再递归，累计油耗到答案，并返回人数 <code>1</code>。这个返回值后面要累计给 <code>dfs(3, 1, ...)</code> 的返回值 <code>1</code>，即当前的 <code>peopleSum</code> 值就是 <code>dfs(2, 3, ...) + dfs(3, 1, ...) = 2</code>，从节点 <code>3</code> 到它的父节点 <code>1</code> 需要油耗 <code>ceil(2, 2) = 1</code>。</p>
<p><strong>为什么不需要计算根节点 <code>0</code> 的耗油 </strong>？<br> 根节点 <code>0</code> 不需要累计油耗到答案，是因为累计的是每个节点到其父节点的公路上的油耗，根节点没有它的父节点，即没有公路，也就不需要油耗了。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>深度优先搜索</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>递归</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 234 回文链表</title>
    <url>/posts/231101094219.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">234 回文链表 </a>：请判断一个链表是否为回文链表。所谓回文链表就是以链表中间为中心点两边对称。<strong> 进阶</strong>：你能否用 <code>O(n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度解决此题？</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;2-&gt;1; 输出: true</span><br><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;1; 输出: false</span><br></pre></td></tr></table></figure>

<h2 id="多次遍历"><a href="# 多次遍历" class="headerlink" title="多次遍历"></a>多次遍历 </h2><p> 我们可以遍历链表中的每个节点，依次把它们存储在数组中，最后从数组的两头往中间判断链表是否是回文数组。</p>
<p>这就需要对链表进行两次遍历。第一次遍历，计算链表的长度，用于申请合适的数组空间；第二次遍历，向数组中存储链表节点。最后，我们需要对数组进行一次遍历，来判断链表是否是回文链表。</p>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(n)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node</span> =</span> head;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算链表的长度</span></span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        size++;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">nums</span>[<span class="title">size</span>];</span></span><br><span class="line">    node = head;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 向数组中存储链表节点</span></span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        nums[size++] = node;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数组的两头往中间判断链表是否是回文链表</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[left++]-&gt;val != nums[right--]-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快慢指针 - 反转链表"><a href="# 快慢指针 - 反转链表" class="headerlink" title="快慢指针 + 反转链表"></a>快慢指针 + 反转链表</h2><blockquote>
<p>你能否用 <code>O(n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度解决此题？</p>
</blockquote>
<p>可以使用快慢指针找到链表的中点，然后断开链表，并将前一段链表进行反转，然后同时遍历两段链表，来判断原链表是否是回文链表。</p>
<p>这样，就不需要额外的申请内存空间（但是会修改入参的内容）。</p>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">newHead</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> =</span> head;  <span class="comment">// 当前节点</span></span><br><span class="line">        head = head-&gt;next;  <span class="comment">// 先找到下一个节点</span></span><br><span class="line">        cur-&gt;next = newHead;  <span class="comment">// 当前节点指向新链表的头</span></span><br><span class="line">        newHead = cur;  <span class="comment">// 更新新链表的头</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快慢指针寻找链表中点两侧的节点</span></span><br><span class="line">    <span class="comment">// 1-&gt;2-&gt;2-&gt;1, 1-&gt;2-&gt;3-&gt;2-&gt;1</span></span><br><span class="line">    <span class="comment">//    ↑  ↑        ↑     ↑</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span> =</span> head, *slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新指定快指针的位置</span></span><br><span class="line">    <span class="keyword">if</span> (fast) &#123;</span><br><span class="line">        fast = slow-&gt;next-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fast = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断开链表, 并反转链表</span></span><br><span class="line">    slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">reverseHead</span> =</span> reverseList(head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断链表是否是回文链表</span></span><br><span class="line">    <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast-&gt;val != reverseHead-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        reverseHead = reverseHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 2 两数相加</title>
    <url>/posts/231031120718.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/add-two-numbers/">2 两数相加 </a>：给出两个<strong> 非空 </strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong> 逆序 </strong> 的方式存储的，并且它们的每个节点只能存储 <strong> 一位 </strong> 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure>

<h2 id="一次遍历（哑结点）"><a href="# 一次遍历（哑结点）" class="headerlink" title="一次遍历（哑结点）"></a>一次遍历（哑结点）</h2><p>对于待相加的两个链表中的节点，它们相加可能出现进位（相加的值大于 9）。这时在下次相加时就要考虑这个带进位的结果；同时，最后一次相加的结果可能有进位，也可能没有进位，这也是不能忽略的。</p>
<p>每次相加都要创建一个链表节点，用于存储相加的值，并把它们链接起来，形成题目要求的返回的新链表。</p>
<p>时间复杂度：<code>O(max(m, n))</code>，空间复杂度：<code>O(1)</code>，不考虑输出占用的空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">addTwoNumbers</span><span class="params">(<span class="keyword">struct</span> ListNode* l1, <span class="keyword">struct</span> ListNode* l2)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> =</span> &amp;dummy;</span><br><span class="line">    <span class="type">int</span> curSum = <span class="number">0</span>, carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l1 || l2 || carry &gt; <span class="number">0</span>) &#123;  <span class="comment">// 把最后一次加法是否有进位放在这里, 简化代码</span></span><br><span class="line">        <span class="comment">// 创建节点并指向 NULL</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node</span> =</span> (<span class="keyword">struct</span> ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算当前两节点相加的和, 加上进位</span></span><br><span class="line">        curSum = carry;</span><br><span class="line">        <span class="keyword">if</span> (l1) &#123;</span><br><span class="line">            curSum += l1-&gt;val;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2) &#123;</span><br><span class="line">            curSum += l2-&gt;val;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算本次加法的进位和相加值</span></span><br><span class="line">        carry = curSum &gt; <span class="number">9</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        curSum = curSum % <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将下一个节点指向新节点, 并修改其值为相加值</span></span><br><span class="line">        node-&gt;val = curSum;</span><br><span class="line">        cur-&gt;next = node;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// // 判断最后一次加法是否有进位, 有责增加一个节点存储进位值</span></span><br><span class="line">    <span class="comment">// if (carry &gt; 0) &#123;</span></span><br><span class="line">    <span class="comment">//     struct ListNode *node = (struct ListNode *)malloc(sizeof(struct ListNode));</span></span><br><span class="line">    <span class="comment">//     node-&gt;next = NULL;</span></span><br><span class="line">    <span class="comment">//     node-&gt;val = carry;</span></span><br><span class="line">    <span class="comment">//     cur-&gt;next = node;</span></span><br><span class="line">    <span class="comment">//     cur-&gt;next-&gt;next = NULL;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 445 两数相加 II</title>
    <url>/posts/231031163133.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/add-two-numbers-ii/">445 两数相加 II</a>：给你两个非空链表来代表两个非负整数。<strong>数字最高位位于链表开始位置</strong>。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。你可以假设除了数字 0 之外，这两个数字都不会以零开头。进阶：如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [7,2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,8,0,7]</span><br></pre></td></tr></table></figure>

<h2 id="反转链表再遍历"><a href="# 反转链表再遍历" class="headerlink" title="反转链表再遍历"></a>反转链表再遍历 </h2><p> 其实我们可以利用 <a href="https://pursue26.github.io/posts/231025185947.html">LeetCode 刷题之 206 反转链表 </a> 和 <a href="https://pursue26.github.io/posts/231031120718.html">LeetCode 刷题之 2 两数相加 </a> 完成该题。</p>
<p>首先，将链表 <code>l1</code> 和链表 <code>l2</code> 反转，然后调用两数相加的代码，最后再对返回的链表再次反转即可。</p>
<p>时间复杂度：<code>O(max(m, n))</code>，空间复杂度：<code>O(1)</code>，不考虑输出占用的空间；递归调用栈的空间复杂度：<code>O(max(m, n))</code>，如果采用迭代的方式反转链表，则为常数空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">tail</span> =</span> reverseList(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">addTwoNumbers_i</span><span class="params">(<span class="keyword">struct</span> ListNode* l1, <span class="keyword">struct</span> ListNode* l2)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> =</span> &amp;dummy;</span><br><span class="line">    <span class="type">int</span> curSum = <span class="number">0</span>, carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l1 || l2 || carry &gt; <span class="number">0</span>) &#123;  <span class="comment">// 把最后一次加法是否有进位放在这里, 简化代码</span></span><br><span class="line">        <span class="comment">// 创建节点并指向 NULL</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node</span> =</span> (<span class="keyword">struct</span> ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算当前两节点相加的和, 加上进位</span></span><br><span class="line">        curSum = carry;</span><br><span class="line">        <span class="keyword">if</span> (l1) &#123;</span><br><span class="line">            curSum += l1-&gt;val;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2) &#123;</span><br><span class="line">            curSum += l2-&gt;val;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算本次加法的进位和相加值</span></span><br><span class="line">        carry = curSum &gt; <span class="number">9</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        curSum = curSum % <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将下一个节点指向新节点, 并修改其值为相加值</span></span><br><span class="line">        node-&gt;val = curSum;</span><br><span class="line">        cur-&gt;next = node;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">addTwoNumbers</span><span class="params">(<span class="keyword">struct</span> ListNode* l1, <span class="keyword">struct</span> ListNode* l2)</span>&#123;</span><br><span class="line">    l1 = reverseList(l1);</span><br><span class="line">    l2 = reverseList(l2);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">head</span> =</span> addTwoNumbers_i(l1, l2);</span><br><span class="line">    <span class="keyword">return</span> reverseList(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LIFO 堆栈"><a href="#LIFO 堆栈" class="headerlink" title="LIFO 堆栈"></a>LIFO 堆栈</h2><blockquote>
<p>进阶：如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p>
</blockquote>
<p><strong>记住：如果需要考虑链表反转，首先考虑栈（后进先出）</strong>。</p>
<p>因此，我们可以申请两个栈空间，依次遍历两个链表，将节点按遍历顺序放入各自的堆栈中。然后，依次同时从两个堆栈中各弹出一个节点，进行两数相加，将相加形成的新节点，放入第三个堆栈中，直到相加操作结束。最后，依次弹出第三个堆栈中的节点，并将它们链接在一起，即为答案。</p>
<p>堆栈的实现：我们可以使用 <a href="https://pursue26.github.io/posts/231016161508.html"> 数据结构之堆栈（数组实现）</a>或 <a href="https://pursue26.github.io/posts/231016184406.html"> 数据结构之堆栈（链表实现）</a>中实现的堆栈数据结构。但是，为了简便，这里使用了普通数组来模拟堆栈。</p>
<p>时间复杂度：<code>O(max(m, n))</code>，空间复杂度：<code>O(max(m, n))</code>，即堆栈占用的空间，不考虑输出占用的空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">addTwoNumbers</span><span class="params">(<span class="keyword">struct</span> ListNode* l1, <span class="keyword">struct</span> ListNode* l2)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">stack1</span>[101], *<span class="title">stack2</span>[101], *<span class="title">stack3</span>[101];</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node1</span> =</span> l1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node2</span> =</span> l2;</span><br><span class="line">    <span class="type">int</span> pos1 = <span class="number">0</span>, pos2 = <span class="number">0</span>, pos3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (node1) &#123;</span><br><span class="line">        stack1[pos1++] = node1;</span><br><span class="line">        node1 = node1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (node2) &#123;</span><br><span class="line">        stack2[pos2++] = node2;</span><br><span class="line">        node2 = node2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pos1--;  <span class="comment">// 变成索引值</span></span><br><span class="line">    pos2--;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> curSum = <span class="number">0</span>, carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos1 &gt;= <span class="number">0</span> || pos2 &gt;= <span class="number">0</span> || carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建节点并指向 NULL</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node</span> =</span> (<span class="keyword">struct</span> ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算当前两节点相加的和, 加上进位</span></span><br><span class="line">        curSum = carry;</span><br><span class="line">        <span class="keyword">if</span> (pos1 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            curSum += stack1[pos1]-&gt;val;</span><br><span class="line">            pos1--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            curSum += stack2[pos2]-&gt;val;</span><br><span class="line">            pos2--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算本次加法的进位和相加值</span></span><br><span class="line">        carry = curSum &gt; <span class="number">9</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        curSum = curSum % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 相加和入第三个堆栈</span></span><br><span class="line">        node-&gt;val = curSum;</span><br><span class="line">        stack3[pos3++] = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">ans</span> =</span> stack3[--pos3];</span><br><span class="line">    <span class="comment">// 依次弹出第三个堆栈中的节点</span></span><br><span class="line">    <span class="keyword">while</span> (pos3 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        stack3[pos3]-&gt;next = stack3[pos3 - <span class="number">1</span>];</span><br><span class="line">        pos3--;</span><br><span class="line">    &#125;</span><br><span class="line">    stack3[pos3]-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 725 分隔链表</title>
    <url>/posts/231101135228.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/split-linked-list-in-parts/">725 分隔链表</a>：给定一个头结点为 <code>root</code> 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 <code>null</code>。这 k 个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。返回一个由上述 k 部分组成的数组。</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3], k = 5</span><br><span class="line">输出：[[1],[2],[3],[],[]]</span><br><span class="line">输入：head = [1,2,3,4,5,6,7,8,9,10], k = 3</span><br><span class="line">输出：[[1,2,3,4],[5,6,7],[8,9,10]]</span><br></pre></td></tr></table></figure>

<p>函数接口：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode** <span class="title function_">splitListToParts</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> k, <span class="type">int</span>* returnSize)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="两趟遍历"><a href="# 两趟遍历" class="headerlink" title="两趟遍历"></a>两趟遍历 </h2><p> 该题就是正常的遍历，然后划分即可。首先，一次遍历计算链表的长度 <code>size</code>；然后，根据链表长度 <code>size</code> 和 <code>k</code> 值，计算划分的链表的长度，前 <code>size % k</code> 段的长度为 <code>size / k + 1</code>，后 <code>size - size % k</code> 段的长度为 <code>size / k</code>。</p>
<p>时间复杂度：<code>O(n)</code>，两趟遍历，空间复杂度：<code>O(1)</code>，不算输出占用的空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode** <span class="title function_">splitListToParts</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> k, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node</span> =</span> head;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算链表长度</span></span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        size++;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    node = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请返回的空间, 并全部初始化为 NULL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> **<span class="title">ans</span> =</span> (<span class="keyword">struct</span> ListNode **)<span class="built_in">malloc</span>(k * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode *));</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0</span>, k * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode *));</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a = size / k, b = size % k;</span><br><span class="line">    <span class="type">int</span> splitSize = <span class="number">0</span>, idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> save = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        <span class="comment">// 存储划分的每段链表的头节点</span></span><br><span class="line">        <span class="keyword">if</span> (save) &#123;</span><br><span class="line">            ans[idx++] = node;</span><br><span class="line">            save = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        splitSize++;</span><br><span class="line">        <span class="comment">// 前 b 次划分的链表长度为 a+1, 后 size-b 次划分的链表长度为 a</span></span><br><span class="line">        <span class="keyword">if</span> (splitSize &lt; a + (b &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>)) &#123;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            splitSize = <span class="number">0</span>;</span><br><span class="line">            b = fmax(--b, <span class="number">0</span>);  <span class="comment">// b 减到 0 停止</span></span><br><span class="line">            save = <span class="literal">true</span>;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">tmp</span> =</span> node;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = k;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 435 无重叠区间</title>
    <url>/posts/231109150855.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435 无重叠区间</a>：给定一个区间的集合 <code>intervals</code>，其中 <code>intervals[i] = [start_i, end_i]</code>。返回需要移除区间的最小数量，使剩余区间互不重叠。注意，区间 <code>[1,2]</code> 和 <code>[2,3]</code> 的边界相互接触，但没有相互重叠。</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: intervals = [[1,4],[2,3],[4,6]]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 移除 [1,4] 后，剩下的区间没有重叠。</span><br></pre></td></tr></table></figure>

<h2 id="右区间排序 - 贪心算法"><a href="# 右区间排序 - 贪心算法" class="headerlink" title="右区间排序 + 贪心算法"></a>右区间排序 + 贪心算法 </h2><p> 既然说，移除最少的区间，使剩下区间互相不重叠。对于示例，因为 <code>[1,4]</code> 和 <code>[2,3]</code> 这两个区间重叠了，但都没跟 <code>[4,6]</code> 区间重叠，而 <code>[1,4]</code> 区间的右边界太大了，可能会影响到后续区间的最小值，有造成更多区间被移除的风险。所以，我们才移除右边界较大的那个区间。</p>
<p>因此，我们可以按照区间的右边界升序排序，然后使用一前、一后两个指针，指向待比较的两个区间，判断这两个区间是否需要移除一个：</p>
<ul>
<li>前指针指向的区间的右边界不大于后指针指向的区间的左边界，则不需要移除：<ul>
<li>前指针指向后区间，后指针后移一个区间</li>
</ul>
</li>
<li>前指针指向的区间的右边界大于后指针指向的区间的左边界，则需要移除：<ul>
<li>直接移除后区间（区间已经排序，留下右边界小的区间），前指针保持固定，后指针后移一个区间</li>
</ul>
</li>
</ul>
<p>时间复杂度：<code>O(nlogn)</code>，排序所需时间，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *pa, <span class="type">const</span> <span class="type">void</span> *pb)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *arr1 = *(<span class="type">const</span> <span class="type">int</span> **)pa;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *arr2 = *(<span class="type">const</span> <span class="type">int</span> **)pb;</span><br><span class="line">    <span class="keyword">return</span> arr1[<span class="number">1</span>] - arr2[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>** intervals, <span class="type">int</span> intervalsSize, <span class="type">int</span>* intervalsColSize)</span>&#123;</span><br><span class="line">    qsort(intervals, intervalsSize, <span class="keyword">sizeof</span>(intervals[<span class="number">0</span>]), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pre = <span class="number">0</span>, cur = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt; intervalsSize) &#123;</span><br><span class="line">        <span class="comment">// 不需要移除</span></span><br><span class="line">        <span class="keyword">if</span> (intervals[pre][<span class="number">1</span>] &lt;= intervals[cur][<span class="number">0</span>]) &#123;</span><br><span class="line">            pre = cur;  <span class="comment">// 前指针指向后一个区间</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 需要移除</span></span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        cur++;  <span class="comment">// 后指针后移一个区间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="左区间排序 - 贪心算法"><a href="# 左区间排序 - 贪心算法" class="headerlink" title="左区间排序 + 贪心算法"></a>左区间排序 + 贪心算法 </h2><p> 当然，我们也可以按照区间的左边界升序排序。但在需要移除时，需要进一步判断是移除前一个区间，还是后一个区间；也就是，对上一节中的「直接移除后区间（区间已经排序，留下右边界小的区间）」的判断。</p>
<p>时间复杂度：<code>O(nlogn)</code>，排序所需时间，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *pa, <span class="type">const</span> <span class="type">void</span> *pb)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *arr1 = *(<span class="type">const</span> <span class="type">int</span> **)pa;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *arr2 = *(<span class="type">const</span> <span class="type">int</span> **)pb;</span><br><span class="line">    <span class="keyword">return</span> arr1[<span class="number">0</span>] - arr2[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>** intervals, <span class="type">int</span> intervalsSize, <span class="type">int</span>* intervalsColSize)</span>&#123;</span><br><span class="line">    qsort(intervals, intervalsSize, <span class="keyword">sizeof</span>(intervals[<span class="number">0</span>]), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pre = <span class="number">0</span>, cur = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt; intervalsSize) &#123;</span><br><span class="line">        <span class="comment">// 不需要移除</span></span><br><span class="line">        <span class="keyword">if</span> (intervals[pre][<span class="number">1</span>] &lt;= intervals[cur][<span class="number">0</span>]) &#123;</span><br><span class="line">            pre = cur;  <span class="comment">// 前指针指向后一个区间</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 需要移除</span></span><br><span class="line">            <span class="comment">// 进一步判断是移除前一个区间，还是后一个区间</span></span><br><span class="line">            <span class="keyword">if</span> (intervals[pre][<span class="number">1</span>] &gt;= intervals[cur][<span class="number">1</span>]) &#123;</span><br><span class="line">                pre = cur;  <span class="comment">// 移除前一个区间</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        cur++;  <span class="comment">// 后指针后移一个区间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个题目，其实是 <strong> 预定会议的一个问题</strong>，给定若干个会议时间（开始时间 - 结束时间），然后去预定会议，那么能够成功预定的最大会议数是多少？其核心是找出最大不重叠区间的个数。</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>博客文章分类汇总</title>
    <url>/posts/summary.html</url>
    <content><![CDATA[<center><b>这篇文章是个人博客中系列文章的分类汇总。</b></center>

<span id="more"></span>

<h1 id="基础知识"><a href="# 基础知识" class="headerlink" title="基础知识"></a>基础知识 </h1><p><a href="https://pursue26.github.io/posts/231010144856.html"> 模运算（求余运算）</a><br><a href="https://pursue26.github.io/posts/231014105311.html">异或运算 </a><br><a href="https://pursue26.github.io/posts/231210181853.html"> 计算机中的寄存器 </a><br><a href="https://pursue26.github.io/posts/231213183051.html"> 正则表达式基础</a></p>
<h1 id="C 语言系列"><a href="#C 语言系列" class="headerlink" title="C 语言系列"></a>C 语言系列</h1><p><a href="https://pursue26.github.io/posts/230916171929.html">C 语言之 main 函数参数</a><br><a href="https://pursue26.github.io/posts/231214192113.html">C 语言之关键字介绍</a><br><a href="https://pursue26.github.io/posts/240103180653.html">C 语言之输出打印函数</a><br><a href="https://pursue26.github.io/posts/230922143003.html">C 语言之多维数组</a><br><a href="https://pursue26.github.io/posts/230913200729.html">C 语言之 const 关键字</a><br><a href="https://pursue26.github.io/posts/230918174223.html">C 语言之 typedef 自定义类型基础</a><br><a href="https://pursue26.github.io/posts/230920172849.html">C 语言之 typedef 实践</a><br><a href="https://pursue26.github.io/posts/240224193217.html">C 语言之一、二级指针</a><br><a href="https://pursue26.github.io/posts/240307195203.html">C 语言之代码 TOP-K 问题</a><br><a href="https://pursue26.github.io/posts/230922172626.html">C 语言之 uthash 哈希表基础</a><br><a href="https://pursue26.github.io/posts/230921094127.html">C 语言之锁与原子操作基础</a><br><a href="https://pursue26.github.io/posts/230911151334.html">C 语言之 pthread 多线程</a><br><a href="https://pursue26.github.io/posts/230918114841.html">C 语言之大小端知识</a></p>
<h1 id="Golang 语言系列"><a href="#Golang 语言系列" class="headerlink" title="Golang 语言系列"></a>Golang 语言系列</h1><p><a href="https://pursue26.github.io/posts/230907162612.html">Go 笔记之变量与常量</a><br><a href="https://pursue26.github.io/posts/230909120145.html">Go 笔记之函数 &amp; 包 &amp; 判断 &amp; 循环</a><br><a href="https://pursue26.github.io/posts/230912152800.html">Go 笔记之数组与切片</a><br><a href="https://pursue26.github.io/posts/230913161326.html">Go 笔记之可变参数函数与 Map 集合</a><br><a href="https://pursue26.github.io/posts/230915155105.html">Go 笔记之字符串和指针</a></p>
<h1 id="数据结构与算法系列"><a href="# 数据结构与算法系列" class="headerlink" title="数据结构与算法系列"></a>数据结构与算法系列 </h1><h2 id="数据结构系列"><a href="# 数据结构系列" class="headerlink" title="数据结构系列"></a> 数据结构系列 </h2><p><a href="https://pursue26.github.io/posts/231007174854.html"> 数据结构之链表（数组实现）</a><br><a href="https://pursue26.github.io/posts/231008213450.html">数据结构之链表（链式实现）</a><br><a href="https://pursue26.github.io/posts/231016161508.html">数据结构之堆栈（数组实现）</a><br><a href="https://pursue26.github.io/posts/231016184406.html">数据结构之堆栈（链表实现）</a><br><a href="https://pursue26.github.io/posts/231127185207.html">数据结构之单调栈 </a><br><a href="https://pursue26.github.io/posts/231017105123.html"> 数据结构之队列（链表实现）</a><br><a href="https://pursue26.github.io/posts/231017154121.html">数据结构之双端队列（链表实现）</a><br><a href="https://pursue26.github.io/posts/231018102559.html">数据结构之堆基础与堆结构（数组实现）</a><br><a href="https://pursue26.github.io/posts/231019102311.html">数据结构之优先队列（堆实现）</a><br><a href="https://pursue26.github.io/posts/230905224335.html">数据结构之二叉树的遍历 </a><br><a href="https://pursue26.github.io/posts/231020174358.html"> 数据结构之二叉搜索树 </a><br><a href="https://pursue26.github.io/posts/230916094606.html"> 数据结构之拓扑排序 </a><br><a href="https://pursue26.github.io/posts/230925185057.html"> 数据结构之 Trie 字典树 </a><br><a href="https://pursue26.github.io/posts/231023164532.html"> 数据结构之并查集（数组实现）</a></p>
<h2 id="数据结构算法系列"><a href="# 数据结构算法系列" class="headerlink" title="数据结构算法系列"></a>数据结构算法系列 </h2><h3 id="查找算法系列"><a href="# 查找算法系列" class="headerlink" title="查找算法系列"></a> 查找算法系列 </h3><p><a href="https://pursue26.github.io/posts/231124181658.html"> 数据结构算法之二分查找 </a><br><a href="https://pursue26.github.io/posts/231227190828.html"> 数据结构算法之哈希表实现</a></p>
<h3 id="排序算法系列"><a href="# 排序算法系列" class="headerlink" title="排序算法系列"></a>排序算法系列 </h3><p><a href="https://pursue26.github.io/posts/231218181635.html"> 数据结构算法之归并排序 </a><br><a href="https://pursue26.github.io/posts/231108163339.html"> 数据结构算法之快速排序 </a><br><a href="https://pursue26.github.io/posts/231107171607.html"> 数据结构算法之堆排序</a></p>
<h3 id="图算法系列"><a href="# 图算法系列" class="headerlink" title="图算法系列"></a>图算法系列 </h3><p><a href="https://pursue26.github.io/posts/231116150205.html"> 数据结构算法之 Floyd 多源最短路径 </a><br><a href="https://pursue26.github.io/posts/231117095232.html"> 数据结构算法之 Dijkstra 单源最短路径（原理部分）</a><br><a href="https://pursue26.github.io/posts/231121152713.html">数据结构算法之 Dijkstra 单源最短路径（实现部分）</a></p>
<h1 id="工具"><a href="# 工具" class="headerlink" title="工具"></a>工具 </h1><h2 id="GNU"><a href="#GNU" class="headerlink" title="GNU"></a>GNU</h2><p><a href="https://pursue26.github.io/posts/240207180410.html"> 编译之 GCC 编译过程分解</a></p>
<h1 id="Docker 系列"><a href="#Docker 系列" class="headerlink" title="Docker 系列"></a>Docker 系列</h1><p><a href="https://pursue26.github.io/posts/230909171809.html">Docker 学习笔记</a></p>
<h1 id="计算机网络系列"><a href="# 计算机网络系列" class="headerlink" title="计算机网络系列"></a>计算机网络系列 </h1><p><a href="https://pursue26.github.io/posts/231011192359.html"> 计网之 OSI 参考模型 </a><br><a href="https://pursue26.github.io/posts/240306203742.html"> 计网之 ACL 访问控制列表 </a><br><a href="https://pursue26.github.io/posts/240130190208.html"> 计网之路由表、转发表与快速转发工作原理 </a><br><a href="https://pursue26.github.io/posts/231221200716.html"> 计网之 VXLAN 网络虚拟化技术</a></p>
<h1 id="操作系统系列"><a href="# 操作系统系列" class="headerlink" title="操作系统系列"></a>操作系统系列 </h1><h2 id="操作系统课程学习（清华大学 - 陈渝老师）"><a href="# 操作系统课程学习（清华大学 - 陈渝老师）" class="headerlink" title="操作系统课程学习（清华大学 - 陈渝老师）"></a> 操作系统课程学习（<a href="https://www.bilibili.com/video/BV1uW411f72n/">清华大学 - 陈渝老师 </a>）</h2><p><a href="https://pursue26.github.io/posts/230921190726.html"> 操作系统之 chapter1 概述 </a><br><a href="https://pursue26.github.io/posts/230924172528.html"> 操作系统之 chapter2 启动 &amp; 中断 &amp; 异常 &amp; 系统调用 </a><br><a href="https://pursue26.github.io/posts/231017195157.html"> 操作系统之 chapter3.1 内存分层体系与地址空间生成 </a><br><a href="https://pursue26.github.io/posts/231108195351.html"> 操作系统之 chapter3.2 连续内存分配 </a><br><a href="https://pursue26.github.io/posts/231111172507.html"> 操作系统之 chapter4.1 非连续内存分配之分段与分页 </a><br><a href="https://pursue26.github.io/posts/231119170537.html"> 操作系统之 chapter4.2 非连续内存分配之页表 </a><br><a href="https://pursue26.github.io/posts/231123184526.html"> 操作系统之 chapter5.1 虚拟内存管理之覆盖技术与交换技术 </a><br><a href="https://pursue26.github.io/posts/231127193658.html"> 操作系统之 chapter5.2 内存管理之虚存技术 </a><br><a href="https://pursue26.github.io/posts/231129182631.html"> 操作系统之 chapter6.1 局部页面置换算法 </a><br><a href="https://pursue26.github.io/posts/231207184239.html"> 操作系统之 chapter6.2 全局页面置换算法 </a><br><a href="https://pursue26.github.io/posts/231207204958.html"> 操作系统之 chapter7.1 进程描述 </a><br><a href="https://pursue26.github.io/posts/231210211306.html"> 操作系统之 chapter7.2 进程状态 </a><br><a href="https://pursue26.github.io/posts/231215213932.html"> 操作系统之 chapter7.3 线程 </a><br><a href="https://pursue26.github.io/posts/231218220813.html"> 操作系统之 chapter7.4 进程控制 </a><br><a href="https://pursue26.github.io/posts/231228193143.html"> 操作系统之 chapter8 调度 </a><br><a href="https://pursue26.github.io/posts/240104202828.html"> 操作系统之 chapter9 同步与互斥 </a><br><a href="https://pursue26.github.io/posts/240113115605.html"> 操作系统之 chapter10.1 信号量与管程 </a><br><a href="https://pursue26.github.io/posts/240205182643.html"> 操作系统之 chapter10.2 经典同步问题</a></p>
<h1 id="LeetCode 刷题系列"><a href="#LeetCode 刷题系列" class="headerlink" title="LeetCode 刷题系列"></a>LeetCode 刷题系列 </h1><h2 id="链表相关"><a href="# 链表相关" class="headerlink" title="链表相关"></a> 链表相关</h2><p><a href="https://pursue26.github.io/posts/231025143947.html">LeetCode 刷题之 160 相交链表</a><br><a href="https://pursue26.github.io/posts/231025185947.html">LeetCode 刷题之 206 反转链表</a><br><a href="https://pursue26.github.io/posts/231026101239.html">LeetCode 刷题之 21 合并两个有序链表</a><br><a href="https://pursue26.github.io/posts/231026184514.html">LeetCode 刷题之 83 删除排序链表中的重复元素</a><br><a href="https://pursue26.github.io/posts/231027150243.html">LeetCode 刷题之 19 删除链表的倒数第 N 个节点</a><br><a href="https://pursue26.github.io/posts/231031120718.html">LeetCode 刷题之 2 两数相加</a><br><a href="https://pursue26.github.io/posts/231031163133.html">LeetCode 刷题之 445 两数相加 II</a><br><a href="https://pursue26.github.io/posts/231101094219.html">LeetCode 刷题之 234 回文链表</a><br><a href="https://pursue26.github.io/posts/231101135228.html">LeetCode 刷题之 725 分隔链表</a><br><a href="https://pursue26.github.io/posts/231102120708.html">LeetCode 刷题之 328 奇偶链表</a><br><a href="https://pursue26.github.io/posts/231102165703.html">LeetCode 刷题之 142 环形链表 II</a></p>
<h2 id="设计"><a href="# 设计" class="headerlink" title="设计"></a>设计</h2><p><a href="https://pursue26.github.io/posts/231201184542.html">LeetCode 刷题之 146 LRU 缓存</a></p>
<h2 id="贪心算法"><a href="# 贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p><a href="https://pursue26.github.io/posts/231107094652.html">LeetCode 刷题之 1029 两地调度</a><br><a href="https://pursue26.github.io/posts/231109150855.html">LeetCode 刷题之 435 无重叠区间</a></p>
<h2 id="哈希表"><a href="# 哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p><a href="https://pursue26.github.io/posts/231123181539.html">LeetCode 刷题之 1410 实体解析器</a></p>
<h2 id="树的遍历"><a href="# 树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><p><a href="https://pursue26.github.io/posts/231103121209.html">LeetCode 刷题之 117 填充每个节点的下一个右侧节点指针 II</a></p>
<h2 id="深度优先搜索（递归）"><a href="# 深度优先搜索（递归）" class="headerlink" title="深度优先搜索（递归）"></a>深度优先搜索（递归）</h2><p><a href="https://pursue26.github.io/posts/231206201243.html">LeetCode 刷题之 2477 达到首都的最少油耗</a></p>
<h2 id="图或路径问题"><a href="# 图或路径问题" class="headerlink" title="图或路径问题"></a>图或路径问题</h2><p><a href="https://pursue26.github.io/posts/231211184652.html">LeetCode 刷题之 1631 最小体力消耗路径</a></p>
<h1 id="项目"><a href="# 项目" class="headerlink" title="项目"></a>项目 </h1><h2 id="开源项目"><a href="# 开源项目" class="headerlink" title="开源项目"></a> 开源项目 </h2><p><a href="https://pursue26.github.io/posts/240303201855.html"> 项目之线程池原理与实现</a></p>
<h2 id="非开源项目"><a href="# 非开源项目" class="headerlink" title="非开源项目"></a>非开源项目 </h2><p><a href="https://pursue26.github.io/posts/231202180319.html"> 项目之确定性网络 CSQF</a></p>
]]></content>
  </entry>
  <entry>
    <title>LeetCode 刷题之 328 奇偶链表</title>
    <url>/posts/231102120708.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/odd-even-linked-list/">328 奇偶链表</a>：给定一个单链表，把所有的奇数位节点和偶数位节点分别链接在一起，并链接这两个链表（即奇数位的尾结点的下一个节点是偶数位的首节点）。请尝试使用原地算法完成。你的算法的空间复杂度应为 <code>O(1)</code>，时间复杂度应为 <code>O(n)</code>。</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: head = [1,2,3,4,5]</span><br><span class="line">输出: [1,3,5,2,4]</span><br><span class="line">输入: head = [2,1,3,5,6,4,7]</span><br><span class="line">输出: [2,3,6,7,1,5,4]</span><br></pre></td></tr></table></figure>


<h2 id="数组 - 遍历"><a href="# 数组 - 遍历" class="headerlink" title="数组 + 遍历"></a>数组 + 遍历 </h2><p> 可以使用两个数组，一个数组按序存储奇数位节点，一个数组按序存储偶数位节点。最后，先遍历奇数数组，再遍历偶数数组，即可。</p>
<p>时间复杂度：<code>O(n)</code>，三趟遍历，空间复杂度：<code>O(n)</code>，用于临时存储链表中的节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">oddEvenList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node</span> =</span> head;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        size++;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    node = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配两个数组的空间, 使用位运算计算</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">odd</span>[(<span class="title">size</span> &gt;</span>&gt; <span class="number">1</span>) + (size &amp; <span class="number">1</span>)];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">even</span>[(<span class="title">size</span> &gt;</span>&gt; <span class="number">1</span>)];</span><br><span class="line">    <span class="type">int</span> oddIdx = <span class="number">0</span>, evenIdx = <span class="number">0</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((size &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 一个数组按序存储奇数位节点</span></span><br><span class="line">            odd[oddIdx++] = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 一个数组按序存储偶数位节点</span></span><br><span class="line">            even[evenIdx++] = node;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先遍历奇数数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; oddIdx; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; oddIdx - <span class="number">1</span>) &#123;</span><br><span class="line">            odd[i]-&gt;next = odd[i + <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 奇数位的尾结点的下一个节点是偶数位的首节点</span></span><br><span class="line">            odd[i]-&gt;next = even[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再遍历偶数数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; evenIdx; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; evenIdx - <span class="number">1</span>) &#123;</span><br><span class="line">            even[i]-&gt;next = even[i + <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            even[i]-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双指针交替遍历"><a href="# 双指针交替遍历" class="headerlink" title="双指针交替遍历"></a>双指针交替遍历 </h2><p> 可以使用奇指针和偶指针两个指针来进行模拟。首先，奇指针 <code>odd</code> 指向链表第一个节点，偶指针 <code>even</code> 指向链表第二个节点。那么，偶指针的下一个节点 <code>even-&gt;next</code> 就是下一个奇数节点 <code>odd = even-&gt;next</code>，这个奇数节点的下一个节点就是下一个偶数节点 <code>even = odd-&gt;next</code>。然后，我们将前后相邻的奇数位、偶数位节点分别链接起来。最后，再将最后一个奇数位节点链接到第一个偶数位节点即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ------- </span><br><span class="line">|       |</span><br><span class="line">1---2---3---4---5</span><br><span class="line"> -/- -/-</span><br><span class="line">    |       |</span><br><span class="line">     -------</span><br><span class="line"></span><br><span class="line">         -------</span><br><span class="line">        |       |</span><br><span class="line">1---2---3---4---5</span><br><span class="line">         -/- -/-</span><br><span class="line">            |       |</span><br><span class="line">             -------</span><br></pre></td></tr></table></figure>

<p>时间复杂度：<code>O(n)</code>，一趟遍历，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">oddEvenList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">odd</span> =</span> head, *even = head-&gt;next;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">evenHead</span> =</span> even;  <span class="comment">// 记录第一个偶数位节点, 否则会因为破坏链表的链接关系, 无法找到这个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (odd-&gt;next &amp;&amp; even-&gt;next) &#123;</span><br><span class="line">        <span class="comment">// 临时记录奇数位和偶数位节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">oddTmp</span> =</span> odd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">evenTmp</span> =</span> even;</span><br><span class="line">        <span class="comment">// 找到下一个奇数位和偶数位节点</span></span><br><span class="line">        odd = even-&gt;next;  <span class="comment">// odd = odd-&gt;next-&gt;next;</span></span><br><span class="line">        even = odd-&gt;next;  <span class="comment">// even = even-&gt;next-&gt;next;</span></span><br><span class="line">        <span class="comment">// 分别链接前后相邻的奇数位和偶数位节点</span></span><br><span class="line">        oddTmp-&gt;next = odd;</span><br><span class="line">        evenTmp-&gt;next = even;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将最后一个奇数位节点链接到第一个偶数位节点</span></span><br><span class="line">    odd-&gt;next = evenHead;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>while</code> 循环中，<code>odd-&gt;next &amp;&amp; even-&gt;next</code> 表示 <strong> 至少还有未链接到奇数链表末尾的奇数位节点</strong>，这个条件等价于 <code>odd-&gt;next &amp;&amp; odd-&gt;next-&gt;next</code>。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 83 删除排序链表中的重复元素</title>
    <url>/posts/231026184514.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83 删除排序链表中的重复元素</a>：给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">输出: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure>

<h2 id="双指针解法"><a href="# 双指针解法" class="headerlink" title="双指针解法"></a>双指针解法 </h2><p> 我们可以使用 <strong> 一前、一后两个指针，找到前、后相邻的两个值不相等的节点，将它们链接起来</strong>。然后，将「前指针」重新指向「后指针」，「后指针」往后移动，继续找前、后相邻的两个值不相等的节点…直到后指针为空为止。</p>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">deleteDuplicates</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">left</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">right</span> =</span> head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left-&gt;val == right-&gt;val) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">temp</span> =</span> right;</span><br><span class="line">            right = right-&gt;next;</span><br><span class="line">            <span class="comment">// 释放节点空间</span></span><br><span class="line">            temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将它们链接起来</span></span><br><span class="line">            left-&gt;next = right;</span><br><span class="line">            <span class="comment">// 将前指针重新指向后指针，后指针往后移动</span></span><br><span class="line">            left = right;</span><br><span class="line">            right = right-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    left-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么退出前还有一行 <code>left-&gt;next = NULL</code> 代码？<br>这是因为，如果原链表最后是以重复的元素退出 <code>while</code> 循环的，则 <code>left</code> 就是最后一个节点，但 <code>left-&gt;next</code> 此时还不是 <code>NULL</code>，所以需要这一行代码。</p>
<h2 id="单指针解法"><a href="# 单指针解法" class="headerlink" title="单指针解法"></a>单指针解法 </h2><p> 其实，我们也可以只使用一个指针，这个指针指向当前节点，只要「下一个节点」与当前节点的值相等，我们就更新当前节点的 <strong> 下一个节点 </strong> 为「再」下一个节点；遇到不相等时，才 <strong> 更新当前指针 </strong> 为「下一个节点」。</p>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">deleteDuplicates</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 「下一个节点」与当前节点的值相等</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val == cur-&gt;next-&gt;val) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">temp</span> =</span> cur-&gt;next;</span><br><span class="line">            <span class="comment">// 更新当前节点的下一个节点为「再」「下一个节点」</span></span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            <span class="comment">// 释放节点空间</span></span><br><span class="line">            temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不相等时，才更新当前指针为「下一个节点」</span></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归解法"><a href="# 递归解法" class="headerlink" title="递归解法"></a>递归解法 </h2><p> 假设，函数 <code>deleteDuplicates(head)</code> 已经了实现删除链表 <code>head</code> 中的重复节点，并返回删除后的链表的头节点。</p>
<p>那么，我们以 <code>head-&gt;next</code> 为头节点调用函数 <code>deleteDuplicates(head-&gt;next)</code>，将实现以 <code>head-&gt;next</code> 为头节点的 <strong> 子链表 </strong> 的去重操作，这时只需要将 <code>head</code> 的下一个节点指向这个去重的链表，就可以实现对 <strong> 完整链表 </strong> 的去重操作了。</p>
<p>但是，可能会遇到 <code>head</code> 和它的下一个节点 <code>head-&gt;next</code> 的值相等的时候，这是就需要 <strong> 修正头节点的地址</strong> —— 抛弃前面的节点。</p>
<p>递归的终止条件就是，链表为空或者只有一个节点。因为这时不需要进行去重操作。</p>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(n)</code>。</p>
<p>一种写法：先递归处理下一个节点，然后再判断下一个节点的值是否与当前节点的值相等，如果相等则删除当前节点，重新指定头节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">deleteDuplicates</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    head-&gt;next = deleteDuplicates(head-&gt;next);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next-&gt;val == head-&gt;val) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">temp</span> =</span> head;</span><br><span class="line">        head = head-&gt;next;  <span class="comment">// 修正头节点的地址</span></span><br><span class="line">        temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种写法：先判断下一个节点的值是否与当前节点的值相等，如果相等则先删除当前节点，然后递归地处理下一个节点，并更新头节点为删除重复节点之后的头节点；否则，说明相邻节点不重复，递归地处理下一个节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">deleteDuplicates</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next-&gt;val == head-&gt;val) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">temp</span> =</span> head-&gt;next;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(head);</span><br><span class="line">        head = deleteDuplicates(temp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        head-&gt;next = deleteDuplicates(head-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不管哪种写法，针对链表中的重复节点，都是删除前面的节点，保留下最后一个节点。</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter10.1 信号量与管程</title>
    <url>/posts/240113115605.html</url>
    <content><![CDATA[<p>锁（Lock）可以实现对临界区的互斥访问，但多道程序设计仅考虑互斥问题是不够的。除了互斥，还需要考虑同步，以及在临界区内允许多个进程（或线程）进入临界区执行的情况。为了实现这些目标，需要借助更高层的同步互斥的语义，并利用硬件实现的原子操作来实现。</p>
<p>本文介绍信号量（Semaphore），包括二元信号量和一般（计数）信号量。信号量可以实现多个进程（或线程）之间的互斥和同步操作，并允许多个进程（或线程）进入临界区执行。同时，介绍了一种更高级的抽象——管程（Monitor），它可以缓解信号量机制在编写并发程序上的复杂性、简化并发编程。管程是一种程序结构，包含了一组共享变量和操作集合，用于控制对共享资源的访问。</p>
<span id="more"></span>

<img src="../images/os-kernel/chapter10/lock.png" alt="多程序理念" width="70%" height="70%">

<h1 id="信号量（Semaphore）"><a href="# 信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h1><h2 id="信号量操作"><a href="# 信号量操作" class="headerlink" title="信号量操作"></a>信号量操作 </h2><p> 信号量（Semaphore）是一种抽象数据结构，用于实现多个进程（或线程）之间的同步和互斥操作的机制。它是一个整型变量（<code>sem</code>），可以用来控制对共享资源的访问。</p>
<p>一个整型变量（<code>sem</code>），具有 2 个原子操作：</p>
<ul>
<li><code>P()</code> 操作：<code>sem</code> 减 1，如果 <code>sem &lt; 0</code>，等待，否则继续；</li>
<li><code>V()</code> 操作：<code>sem</code> 加 1，如果 <code>sem &lt;= 0</code>，唤醒一个等待的进程 P。</li>
</ul>
<p>信号量类似铁路，初始化 2 个资源控制信号灯，进入临界区的进程执行 <code>P()</code> 操作，当临界区已经有 2 个进程时，信号量不足，变为红灯。当再来的进程想要进入临界区时，只能等待，直到某一个进程离开了临界区，变为绿灯，此时进程执行 <code>V()</code> 操作，并将等待的进程唤醒，进入临界区。</p>
<img src="../images/os-kernel/chapter10/semaphore-vivid.gif" alt="信号量比喻" width="80%" height="80%">

<blockquote>
<p>信号量由 dijkstra 在 20 世纪 60 年代提出。<code>P()</code>操作是荷兰语中的 Proberen，意为“尝试”或“试图获取资源”；<code>V()</code>操作是荷兰语中的 Verhogen，意为“增加”或“释放资源”。</p>
</blockquote>
<h2 id="信号量特征"><a href="# 信号量特征" class="headerlink" title="信号量特征"></a>信号量特征</h2><ul>
<li>信号量是整数；</li>
<li>信号量是被保护的变量：初始化完成后，唯一改变一个信号量的值的办法是通过 <code>P(), V()</code> 操作（操作必须是原子）；</li>
<li><code>P()</code> 操作能够阻塞、<code>V()</code> 操作不会阻塞；</li>
<li>我们假定信号量是公平的：<ul>
<li>如果 <code>V()</code> 被无限频繁调用（在同一个信号量上），那么没有线程会被阻塞在 <code>P()</code> 操作上；</li>
<li>在实践中，FIFO 经常被使用，也就是先被阻塞的线程，先出。</li>
</ul>
</li>
</ul>
<blockquote>
<p>自旋锁（Spinlock）能否是 FIFO 类型？不能，锁已被其他线程占用时，该线程会一直自旋（忙等待）直到锁被释放。</p>
</blockquote>
<h2 id="信号量两种类型"><a href="# 信号量两种类型" class="headerlink" title="信号量两种类型"></a>信号量两种类型</h2><ul>
<li>二进制信号量：值可以是 0 或 1；</li>
<li>一般 / 计数信号量：值可取任意非负值。</li>
</ul>
<details>
  <summary>可以通过使用一个类型的信号量来实现另一个类型的信号量（两者相互实现）。</summary>

<ol>
<li><p>使用二进制信号量实现计数信号量：<br>可以使用一个二进制信号量作为互斥锁（类似于互斥量），用于控制对计数信号量的访问。每当线程要进行计数操作时，需要先获取互斥锁，然后进行计数操作，最后释放互斥锁。这样可以确保每次只有一个线程可以访问计数信号量，保证计数的正确性和一致性。</p>
</li>
<li><p>使用计数信号量实现二进制信号量：<br>可以使用一个计数信号量来实现二进制信号量。计数信号量的初始值为 1，表示资源可用。当线程需要访问二进制信号量时，需要先尝试获取计数信号量。如果计数信号量的值为 1，表示资源可用，线程可以继续执行。如果计数信号量的值为 0，表示资源不可用，线程需要等待。当资源被释放时，线程释放计数信号量，将其值设置为 1，表示资源可用。</p>
</li>
</ol>
</details>

<h2 id="信号量两种用途"><a href="# 信号量两种用途" class="headerlink" title="信号量两种用途"></a>信号量两种用途</h2><ul>
<li>互斥；</li>
<li>条件同步（如调度约束：一个线程等待另一个线程的事情发生）。</li>
</ul>
<h1 id="信号量使用"><a href="# 信号量使用" class="headerlink" title="信号量使用"></a>信号量使用 </h1><h2 id="用二进制信号量实现互斥"><a href="# 用二进制信号量实现互斥" class="headerlink" title="用二进制信号量实现互斥"></a> 用二进制信号量实现互斥</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mutex = <span class="keyword">new</span> <span class="built_in">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">mutex-&gt;<span class="built_in">P</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Critical Section; */</span></span><br><span class="line"></span><br><span class="line">mutex-&gt;<span class="built_in">V</span>();</span><br></pre></td></tr></table></figure>

<p>必须成对使用 <code>P(), V()</code> 操作：</p>
<ul>
<li><code>P()</code> 操作保证互斥访问临界资源；</li>
<li><code>V()</code> 操作在使用后释放临界资源；</li>
<li><code>P(), V()</code> 操作不能次序错误、重复或遗漏。</li>
</ul>
<h2 id="用二进制信号量实现调度约束（同步）"><a href="# 用二进制信号量实现调度约束（同步）" class="headerlink" title="用二进制信号量实现调度约束（同步）"></a>用二进制信号量实现调度约束（同步）</h2><p><code>P()</code> 等待，<code>V()</code> 发出信号后，两个线程实现同步：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">condition = <span class="keyword">new</span> <span class="built_in">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* thread A */</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">condition-&gt;<span class="built_in">P</span>();</span><br><span class="line"><span class="comment">// （阻塞等待，直到其它线程执行了 `V()` 操作）...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* thread B */</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">condition-&gt;<span class="built_in">V</span>();</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h2 id="生产者 - 消费者问题（线程同步）"><a href="# 生产者 - 消费者问题（线程同步）" class="headerlink" title="生产者 - 消费者问题（线程同步）"></a>生产者 - 消费者问题（线程同步）</h2><h3 id="问题描述与分析"><a href="# 问题描述与分析" class="headerlink" title="问题描述与分析"></a>问题描述与分析 </h3><p> 生产者 - 消费者问题 <strong> 是一个线程同步的问题</strong>，其中一个线程等待另一个线程完成某个任务。这个问题通常用于模拟生产者和消费者的情景。</p>
<p>例如，在有界缓冲区的生产者 - 消费者问题中：</p>
<ul>
<li>一个或多个生产者生成数据并将其放入缓冲区；</li>
<li>单个消费者每次从缓冲区中取出数据；</li>
<li>在任何给定的时刻，<strong>只有一个 </strong> 生产者或消费者能够访问该缓冲区。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ----------      --------      ----------</span><br><span class="line">| Producer | -&gt; | Buffer | -&gt; | Consumer |</span><br><span class="line"> ----------      --------      ----------</span><br></pre></td></tr></table></figure>

<p>在这种情况下，缓冲区有一个固定的大小，生产者在缓冲区已满时需要等待，而消费者在缓冲区为空时需要等待。</p>
<p>互斥（锁机制）是不够解决这个问题的，因为 <strong> 生产者和消费者需要在某些条件下等待对方的操作完成 </strong>。因此，需要使用其他<strong> 同步机制 </strong> 来协调生产者和消费者的操作。</p>
<h3 id="实现关键与实现方式"><a href="# 实现关键与实现方式" class="headerlink" title="实现关键与实现方式"></a>实现关键与实现方式 </h3><p> 实现生产者 - 消费者问题的关键点（正确定要求）：</p>
<ul>
<li>在任何一个时刻，只能有一个线程操作缓冲区（互斥约束）；</li>
<li>当缓冲区为空时，消费者必须等待生产者（调度，同步约束）；</li>
<li>当缓冲区为满时，生产者必须等待消费者（调度，同步约束）。</li>
</ul>
<p>实现方式：上述每个约束使用一个单独的信号量：</p>
<ul>
<li>二进制信号量 <code>mutex</code>，初始化为 1，实现互斥访问；</li>
<li>一般信号量 <code>emptySem</code>，初始化为 n，实现缓冲区空时的同步约束；</li>
<li>一般信号量 <code>fullSem</code>，初始化为 0，实现缓冲区满时的同步约束。</li>
</ul>
<h3 id="实现代码"><a href="# 实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BoundedBuffer</span> &#123;</span><br><span class="line">    mutex = <span class="keyword">new</span> <span class="built_in">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line">    emptySem = <span class="keyword">new</span> <span class="built_in">Semaphore</span>(n); <span class="comment">// 初始化时，空的程度为〇，每次消费数据后，空的程度提升</span></span><br><span class="line">    fullSem = <span class="keyword">new</span> <span class="built_in">Semaphore</span>(<span class="number">0</span>);  <span class="comment">// 初始化时，满的程度为〇，每次生产数据后，满的程度提升</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者 添加数据</span></span><br><span class="line">BoundedBuffer::<span class="built_in">Deposit</span>(c) &#123;</span><br><span class="line">    emptySem-&gt;<span class="built_in">P</span>(); <span class="comment">// 生产前，空信号量减一</span></span><br><span class="line">    mutex-&gt;<span class="built_in">P</span>();</span><br><span class="line">    <span class="comment">// Add `c` to the buffer;</span></span><br><span class="line">    mutex-&gt;<span class="built_in">V</span>();</span><br><span class="line">    fullSem-&gt;<span class="built_in">V</span>(); <span class="comment">// 生产后，满信号量加一</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者 取出数据</span></span><br><span class="line">BoundedBuffer::<span class="built_in">Remove</span>(c) &#123;</span><br><span class="line">    fullSem-&gt;<span class="built_in">P</span>(); <span class="comment">// 消费前，满信号量减一</span></span><br><span class="line">    mutex-&gt;<span class="built_in">P</span>();</span><br><span class="line">    <span class="comment">// Remove `c` from buffer; </span></span><br><span class="line">    mutex-&gt;<span class="built_in">V</span>();</span><br><span class="line">    emptySem-&gt;<span class="built_in">V</span>(); <span class="comment">// 消费后，空信号量加一</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，当生产者添加了 n 个数据后，缓冲区满。此时再想添加数据时，<code>emptySem</code> 会小于 0，需要等待。同样地，当消费者取出了一些数据后，缓冲区空。此时再想取出数据时，<code>fullSem</code> 会小于 0，需要等待。缓冲区不满、也不空时，可以互斥的添加或取出数据，无需等待。</p>
<h1 id="信号量实现"><a href="# 信号量实现" class="headerlink" title="信号量实现"></a>信号量实现 </h1><p> 使用硬件原语：</p>
<ul>
<li>禁用中断</li>
<li>原子指令（Test-And-Set）</li>
</ul>
<p>类似锁：如禁用中断</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Semaphore</span> &#123;</span><br><span class="line">    <span class="type">int</span> sem;</span><br><span class="line">    WaitQueue q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Semaphore::<span class="built_in">P</span>() &#123;</span><br><span class="line">    --sem;</span><br><span class="line">    <span class="keyword">if</span> (sem &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Add this thread `t` to queue `q`;</span></span><br><span class="line">        <span class="built_in">block</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Semaphore::<span class="built_in">V</span>() &#123;</span><br><span class="line">    ++sem;</span><br><span class="line">    <span class="keyword">if</span> (sem &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Remove a thread `t` from queue `q`;</span></span><br><span class="line">        <span class="built_in">wakeup</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="管程（monitor）与条件变量"><a href="# 管程（monitor）与条件变量" class="headerlink" title="管程（monitor）与条件变量"></a>管程（monitor）与条件变量 </h1><h2 id="管程定义"><a href="# 管程定义" class="headerlink" title="管程定义"></a> 管程定义 </h2><p> 管程（monitor）是一种程序结构，结构内的多个子程序形成的多个工作线程互斥访问共享资源——这些共享资源一般是硬件或一群变量。管程实现了 <strong> 在一个时间点，最多只有一个线程在执行管程的某个子程序</strong>。与那些通过修改数据结构实现互斥访问的并发程序设计相比，管程实现很大程度上简化了程序设计。（来自 Wikipedia 的定义）</p>
<p>管程的目的是：将互斥和条件同步的 <strong> 关注点分离 </strong> 开来。</p>
<ul>
<li>互斥指的是确保在同一时间只有一个进程可以访问共享资源，而条件同步指的是进程之间通过条件变量进行等待和唤醒的机制。</li>
</ul>
<blockquote>
<p>关注点分离（Separation of Concerns, SoC）是将计算机程序分隔为不同部分的设计原则，每一部分会有各自的关注焦点。</p>
</blockquote>
<p>管程主要包含的两个组件：</p>
<ul>
<li>一个锁：用于指定临界区，实现对共享资源的互斥访问；</li>
<li>零或多个条件变量：等待 / 通知信号量，用于管程并发访问共享数据。</li>
</ul>
<p>实现管程的一般方法包括 <strong> 收集相关共享数据和定义方法来访问这些共享数据</strong>：</p>
<ul>
<li>共享数据通常包括需要互斥访问的临界区和条件变量等。</li>
<li>方法定义了对共享数据的操作，用于实现互斥访问和条件等待 / 通知的功能。</li>
</ul>
<p>通过将共享数据和操作封装在一个对象或模块中，可以有效地实现对并发访问的同步控制。</p>
<blockquote>
<p>概括之，管程包含一系列共享变量，以及针对这些变量的一系列操作函数（方法），这些变量和函数被封装在一个对象或模块中，便形成了管程的程序结构。</p>
</blockquote>
<h2 id="管程设计与实现"><a href="# 管程设计与实现" class="headerlink" title="管程设计与实现"></a>管程设计与实现</h2><img src="../images/os-kernel/chapter10/monitor-arch.png" alt="管程结构" width="70%" height="70%">

<p>如上图所示，多个线程都想进入管程访问共享资源，这就需要一个 entry queue 等待队列，等待获取管程的锁。当某个线程取得锁后，可以进入管程的临界区，并执行管程管理的一些列操作，如函数 <code>Wait(x)</code> 和 <code>Signal(x)</code>。但当在执行某一个操作时，函数可能对共享变量的需求得不到满足，<strong>这时线程会先释放锁 </strong>，并将自身挂到相应的条件变量关联的等待队列上，直到条件变量得到满足后，<strong> 重新获得锁</strong>，并执行相应的操作。</p>
<p>为了完成上述动作，需要实现如下操作：</p>
<p>锁 Lock：</p>
<ul>
<li><code>Lock::Acquire()</code>：等待…直到锁可用，然后抢占锁；</li>
<li><code>Lock::Release()</code>：释放锁，唤醒等待者（若有）。</li>
</ul>
<p>条件变量 Condition variable：</p>
<ul>
<li>允许线程在等待状态下进入临界区，而且可以在某个时刻原子释放锁并进入睡眠。</li>
<li><code>Wait()</code> 操作用于释放锁、进入睡眠并重新获得锁。</li>
<li><code>Signal()</code>操作用于唤醒等待者（或者使用 <code>broadcast()</code> 操作唤醒所有等待者）。</li>
</ul>
<blockquote>
<p>条件变量“允许线程在等待状态下（让其他线程）进入临界区”的意思是，当线程需要等待某个条件满足时，它可以调用条件变量的 <code>Wait()</code> 操作来暂时释放锁并进入等待状态。在等待期间，<strong>其他线程 </strong> 可以获得锁并访问临界区。当条件满足时，等待的线程会被唤醒，并重新获得锁，然后可以进入临界区执行相应的操作。</p>
<p>这样做的好处是，在等待状态下，线程不会占用系统资源，同时其他线程有机会进入临界区执行任务，提高了系统的并发性能。当条件满足时，被唤醒的线程可以安全地继续执行，而不会出现竞争条件和数据不一致的问题。</p>
</blockquote>
<p><strong>条件变量的实现</strong>：</p>
<ul>
<li>需要维护每个条件队列；</li>
<li>需要实现线程的条件等待 <code>Wait()</code> 和通知<code>Signal()</code>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">    <span class="type">int</span> numWaiting = <span class="number">0</span>;</span><br><span class="line">    WaitQueue q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Condition::<span class="built_in">Wait</span>(lock) &#123;</span><br><span class="line">    numWaiting++;</span><br><span class="line">    <span class="comment">// Add this thread `t` to `q`;</span></span><br><span class="line">    <span class="built_in">release</span>(lock);</span><br><span class="line">    <span class="built_in">schedule</span>(); <span class="comment">// 运行态 -&gt; 等待态 need mutex</span></span><br><span class="line">    <span class="built_in">require</span>(lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Condition::<span class="built_in">Signal</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (numWaiting &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Remove a thread `t` from `q`;</span></span><br><span class="line">        <span class="built_in">wakeup</span>(t); <span class="comment">// 等待态 -&gt; 就绪态 need mutex</span></span><br><span class="line">        numWaiting--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>上面的 <code>Wait(lock)</code> 函数，为什么是先释放锁、再获取锁呢？</strong></p>
<p>当在执行某一个操作时，函数可能对共享变量的需求得不到满足，<strong>这时线程会先释放锁，以便其它线程可以获取锁并执行</strong>。如果不释放锁，那所有线程都将无法获取锁，而持有锁的线程也无法满足条件继续执行并释放锁，最终会造成系统崩溃。</p>
<h2 id="管程解决生产者 - 消费者问题"><a href="# 管程解决生产者 - 消费者问题" class="headerlink" title="管程解决生产者 - 消费者问题"></a>管程解决生产者 - 消费者问题</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BoundedBuffer</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    Lock lock;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// buffer 为空</span></span><br><span class="line">    Condition notFull, notEmpty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BoundedBuffer::<span class="built_in">Deposit</span>(c) &#123;</span><br><span class="line">    lock-&gt;<span class="built_in">Acquire</span>(); <span class="comment">// 管程的定义：只有一个线程能够进入管程，所以将锁放在函数的最开始和最末尾，而不像信号量那样紧贴着临界区</span></span><br><span class="line">    <span class="keyword">while</span> (count == n) &#123;</span><br><span class="line">        notFull.<span class="built_in">Wait</span>(&amp;lock); <span class="comment">// 内部释放刚刚获取的锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Add `c` to the buffer;</span></span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.<span class="built_in">Signal</span>();</span><br><span class="line">    lock-&gt;<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BoundedBuffer::<span class="built_in">Remove</span>(c) &#123;</span><br><span class="line">    lock-&gt;<span class="built_in">Acquire</span>();</span><br><span class="line">    <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        notEmpty.<span class="built_in">Wait</span>(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Remove `c` from buffer;</span></span><br><span class="line">    count--;</span><br><span class="line">    notFull.<span class="built_in">Signal</span>();</span><br><span class="line">    lock-&gt;<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Deposit(c)</code> 和 <code>Remove(c)</code> 中的 <code>while</code> 可以改成 <code>if</code> 吗？</p>
</blockquote>
<h2 id="管程条件变量的释放处理方式"><a href="# 管程条件变量的释放处理方式" class="headerlink" title="管程条件变量的释放处理方式"></a>管程条件变量的释放处理方式 </h2><p> 把上面的 <code>Deposit(c)</code> 和 <code>Remove(c)</code> 分别看做下图中的线程 T1 和 T2，管程条件变量的释放后的处理方式有两种：Hoare-style 和 Hoare-style。</p>
<img src="../images/os-kernel/chapter10/hansen-vs-hoare.png" alt="管程条件变量的释放处理方式" width="80%" height="80%">

<p>Hansen-style 的<code>Deposit(c)</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Hansen_style::<span class="built_in">Deposit</span>(c) &#123;</span><br><span class="line">    lock-&gt;<span class="built_in">Acquire</span>();</span><br><span class="line">    <span class="keyword">while</span> (count == n) &#123; <span class="comment">// using `while` for Hansen-style</span></span><br><span class="line">        notFull.<span class="built_in">Wait</span>(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Add thing...</span></span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.<span class="built_in">Signal</span>();</span><br><span class="line">    lock-&gt;<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Hansen-style 管程：条件变量的释放仅仅是一个提示、还需要 <strong> 重新检查 </strong> 条件，所以用 <code>while</code> 反复检查。</p>
<p>Hoare-style 的<code>Deposit(c)</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Hoare_style::<span class="built_in">Deposit</span>(c) &#123;</span><br><span class="line">    lock-&gt;<span class="built_in">Acquire</span>();</span><br><span class="line">    <span class="keyword">if</span> (count == n) &#123; <span class="comment">// using `if` for Hoare-style</span></span><br><span class="line">        notFull.<span class="built_in">Wait</span>(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Add thing...</span></span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.<span class="built_in">Signal</span>();</span><br><span class="line">    lock-&gt;<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Hoare-style 管程：条件变量释放的同时表示放弃管程访问、释放后条件变量的状态可用，所以用 <code>if</code>。</p>
<ul>
<li>Hansen-style 管程：高效。</li>
<li>Hoare-style 管程：低效。</li>
</ul>
<p>在 Hansen-style 管程中，使用 <code>while</code> 循环来防止虚假唤醒（spurious wakeups）。虚假唤醒指的是当一个线程被唤醒时，条件可能并没有满足，但唤醒仍然发生。因此，使用 <code>while</code> 循环来检查条件是否满足，如果条件不满足，则线程继续等待。<br>在 Hoare-style 管程中，使用 <code>if</code> 语句来等待条件满足。Hoare-style 管程假设条件变量的等待队列中只有满足条件的线程，因此使用 <code>if</code> 语句即可。虽然在 Hoare-style 管程中也可能发生虚假唤醒，但它并不对此进行特别处理。（由 GPT 生成）</p>
<p>现在，这张图多了两种种并发编程的实现，即信号量和「锁 + 条件变量」的管程：<br><img src="../images/os-kernel/chapter10/concurrent-summary.png" alt="多程序理念" width="80%" height="80%"></p>
<blockquote>
<p>参考资料：<br>1：<a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a><br>2：<a href="https://blog.csdn.net/weixin_53407527/article/details/125207305">https://blog.csdn.net/weixin_53407527/article/details/125207305</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>信号量</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>信号量</tag>
        <tag>管程</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter1 概述</title>
    <url>/posts/230921190726.html</url>
    <content><![CDATA[<p>这篇文章主要介绍操作系统的定义、架构层次、界面和内核、内部组成和特征等内容。</p>
<span id="more"></span>

<h1 id="概述"><a href="# 概述" class="headerlink" title="概述"></a>概述 </h1><h2 id="操作系统定义"><a href="# 操作系统定义" class="headerlink" title="操作系统定义"></a> 操作系统定义 </h2><p><strong> 用户角度</strong>：操作系统是一个控制软件。</p>
<ul>
<li>管理应用软件：可以限制不同的应用程序占用不同的资源</li>
<li>为应用程序提供服务：I/O 服务，声卡、网卡的访问服务</li>
<li>杀死应用程序</li>
</ul>
<p><strong>程序角度</strong>：操作系统是资源管理器。</p>
<ul>
<li>管理外设，分配资源</li>
<li>抽象化作用<ul>
<li>CPU 抽象成进程</li>
<li>磁盘抽象成文件</li>
<li>内存抽象成地址空间</li>
</ul>
</li>
</ul>
<h2 id="操作系统的架构层次"><a href="# 操作系统的架构层次" class="headerlink" title="操作系统的架构层次"></a>操作系统的架构层次 </h2><p> 硬件之上、应用软件之下（为应用软件提供服务支持）。</p>
<h2 id="操作系统的界面和内核"><a href="# 操作系统的界面和内核" class="headerlink" title="操作系统的界面和内核"></a>操作系统的界面和内核</h2><p>Linux、Windows、Android 的界面属于外壳（shell），而不是内核（kernel）。kernel 是操作系统的研究重点，处于 shell 之下。</p>
<h2 id="操作系统内部组成"><a href="# 操作系统内部组成" class="headerlink" title="操作系统内部组成"></a>操作系统内部组成 </h2><p> 操作系统（kernel）内部组件包括：</p>
<ul>
<li>CPU 调度器</li>
<li>物理内存管理</li>
<li>虚拟内存管理</li>
<li>文件系统管理</li>
<li>中断处理与 I/O 设备驱动</li>
</ul>
<h2 id="操作系统特征："><a href="# 操作系统特征：" class="headerlink" title="操作系统特征："></a>操作系统特征：</h2><ul>
<li>并发<ul>
<li>计算机系统中同时存在多个运行的程序，需要 OS 管理和调度。</li>
</ul>
</li>
<li>共享<ul>
<li>“同时”访问或互斥共享。</li>
</ul>
</li>
<li>虚拟<ul>
<li>利用多道程序设计技术，让每一个用户都觉得有一个计算机专门为他服务。</li>
</ul>
</li>
<li>异步<ul>
<li>每个程序的执行不是一贯到底，而是走走停停 &amp; 交替执行，向前推进速度不可预知；</li>
<li>只要运行环境相同，OS 保证程序运行结果相同。</li>
</ul>
</li>
</ul>
<blockquote>
<p>「并发」在一段时间内可以有多个程序运行，而「并行」是在一个时间点上可以有多个程序运行，并行需要多核 CPU 支持。</p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>概述</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>概述</tag>
      </tags>
  </entry>
  <entry>
    <title>异或运算</title>
    <url>/posts/231014105311.html</url>
    <content><![CDATA[<p>异或是一个数学运算符，英文为 exclusive OR，缩写成 XOR。异或的数学符号为 $\bigoplus$，计算机符号为「XOR」。如果二进制数 a 和 b 的同位置的值不相同，则该位置的结果为 1，反之为 0。</p>
<span id="more"></span>

<h2 id="异或也叫半加运算"><a href="# 异或也叫半加运算" class="headerlink" title="异或也叫半加运算"></a>异或也叫半加运算 </h2><p> 异或也叫半加运算，其运算法则相当于 <strong> 不带进位的二进制加法</strong>，如 $0 \bigoplus 0=0, 1 \bigoplus 0=1, 0 \bigoplus 1=1, 1 \bigoplus 1=0$，这些法则与加法是相同的，如 $0+0=0, 1+0=1, 0+1=1, 1+1=(1)0$，只是不带进位，所以异或常被认作不进位加法。</p>
<h2 id="异或运算性质"><a href="# 异或运算性质" class="headerlink" title="异或运算性质"></a>异或运算性质</h2><ol>
<li>归零律：任何数与自身异或都等于 0，即 $a \bigoplus a=0$</li>
<li>恒等律：任何数与 0 异或都等于其本身，即 $a \bigoplus 0=a$</li>
<li>交换律：即 $a \bigoplus b = b \bigoplus a$</li>
<li>结合律：即 $a \bigoplus b \bigoplus c = a \bigoplus (b \bigoplus c) = (a \bigoplus b) \bigoplus c$</li>
<li>自反性：对给定的数 b，用同样的运算因子 a 作两次异或运算后仍得到 b 本身，即 $a \bigoplus b \bigoplus a = b$</li>
</ol>
<h2 id="异或运算应用"><a href="# 异或运算应用" class="headerlink" title="异或运算应用"></a>异或运算应用 </h2><h3 id="交换两个数"><a href="# 交换两个数" class="headerlink" title="交换两个数"></a> 交换两个数 </h3><p> 若需要交换两个 <strong> 整形变量 </strong> 的值，除了借用中间变量进行交换外，还可以利用异或的自反性，仅使用两个变量进行交换，如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> &#123;</span><br><span class="line">    (*a) = (*a)^(*b);  <span class="comment">// a1 = a^b</span></span><br><span class="line">    (*b) = (*a)^(*b);  <span class="comment">// b = (a^b)^b = a</span></span><br><span class="line">    (*a) = (*a)^(*b);  <span class="comment">// a = (a^b)^a = b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="找出重复的数"><a href="# 找出重复的数" class="headerlink" title="找出重复的数"></a>找出重复的数 </h3><p> 假设一个集合中有 $n$ 个数，范围为 $[1, n-1]$，其中有 $n - 2$ 个互不相同的数，有一个数重复一次，设计一个 $O(n)$ 时间复杂度，$O(1)$ 空间复杂度的算法，找出这个数。</p>
<p>推导：</p>
<ol>
<li>假设不包含重复的第二个数的所有数的异或的结果为 $1 \bigoplus2 \bigoplus … \bigoplus (n-1) = T$；</li>
<li>那么，包含第二个重复的数的所有数的异或结果为 $1 \bigoplus2 \bigoplus … \bigoplus (n-1) \bigoplus x = T \bigoplus x$。</li>
</ol>
<p>通过自反性可以得出这个重复的数为 $T \bigoplus (T \bigoplus x) = x$。这里利用的异或的自反性，同时需要具备一个前置条件，就是：我们需要知道集合中都出现过哪些数，这样才能求出序号 1 的结果。</p>
<p>例如，下面的代码中，数组 <code>nums[n]</code> 存储着 $[1, n-1]$ 区间中的所有数，但只有一个数是重复的数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">find_duplicate</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  <span class="comment">// 所有数异或</span></span><br><span class="line">        res ^= nums[i];  <span class="comment">// T^x</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;  <span class="comment">// 所有不重复的数异或</span></span><br><span class="line">        res ^= i;  <span class="comment">// res := (T^x)^T</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="找出不成对的一个数"><a href="# 找出不成对的一个数" class="headerlink" title="找出不成对的一个数"></a>找出不成对的一个数</h3><p><a href="https://leetcode.cn/problems/single-number">LeetCode 习题</a>：一个数组存放若干整数，一个数出现奇数次，其余数均出现偶数次，找出这个出现奇数次的数。</p>
<p>思路：使用异或运算的归零律、恒等律和交换律，将数组中的所有数异或求结果——所有出现偶数次的数的异或的结果是 0；再异或上那个出现奇数次的数，最终结果就是 0 异或 x，即那个不成对的数 x。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        res ^= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="找出不成对的两个数"><a href="# 找出不成对的两个数" class="headerlink" title="找出不成对的两个数"></a>找出不成对的两个数</h3><p><a href="https://leetcode.cn/problems/single-number-iii">LeetCode 习题</a>：一个数组存放若干整数，两个不同的数出现了奇数次，其余数均出现偶数次，找出这两个出现奇数次的数。</p>
<p>假设这两个出现奇数次的数为 x 和 y：</p>
<ol>
<li>按照上述方法，将所有数做异或，计算出 x 和 y 或后的结果 z；</li>
<li>在异或中，同位置的值不同则结果为 1。基于此，可以找到 z 的二进制中最右侧的那个 1（假设 x 的二进制在同位置为 1），然后丢弃左侧的二进制数；</li>
<li>再次遍历数组，跳过那个同位置不为 1 的数（即 y），这就等价于数组是「成对的数中有且仅有一个不成对的数」，即找到了一个不成对的数（这里为 x）；</li>
<li>另一个数 y 便是：x^(x^y)，即 x^z。</li>
</ol>
<blockquote>
<p>序号 2 中，当然也可能跳过成对的数，但没关系，因为这个数不会跳过一个、保留一个，就当少了一对成对的数，不会对找出那个不成对的数有影响。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *ans = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">long</span> xor = <span class="number">0</span>, lsb = <span class="number">0</span>;  <span class="comment">// 防止溢出风险</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        xor ^= <span class="number">1LL</span> * nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    lsb = xor &amp; (~xor + <span class="number">1</span>);</span><br><span class="line">    ans[<span class="number">0</span>] = <span class="number">0</span>, ans[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nums[i] &amp; lsb) != <span class="number">0</span>) &#123;</span><br><span class="line">            ans[<span class="number">0</span>] ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[<span class="number">1</span>] = xor ^ ans[<span class="number">0</span>];</span><br><span class="line">    (*returnSize) = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是如何计算上述序号 2 中的那个二进制数的呢？</p>
<p>一个整数 <code>x</code> 与<code>(~x+1)</code>进行按位与运算的结果是将 <code>x</code> 的最右边的 1 保留下来，其他位都置为 0。这个操作通常用于获取 <code>x</code> 的最右边的 1 所代表的值，也可以称为获取 <code>x</code> 的最低有效位（LSB）。<br>举个例子，假设 <code>x</code> 的二进制表示为 10110100，那么 <code>~x</code> 的二进制表示为 01001011，然后再加上 1，得到 <code>(~x+1)</code> 的二进制表示为 01001100。最后，将 <code>x</code> 与<code>(~x+1)</code>进行按位与运算，得到的结果就是 00000100，即 <code>x</code> 的最右边的 1 所代表的值为 4。</p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://www.cnblogs.com/jasonkoo/articles/2760411.html">https://www.cnblogs.com/jasonkoo/articles/2760411.html</a></li>
<li><a href="https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677">https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>异或运算</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter2 启动 &amp; 中断 &amp; 异常 &amp; 系统调用</title>
    <url>/posts/230924172528.html</url>
    <content><![CDATA[<p>这篇文章主要介绍操作系统的启动，中断、异常、系统调用的特征和差别，以及处理流程（机制）。</p>
<span id="more"></span>

<h2 id="操作系统启动"><a href="# 操作系统启动" class="headerlink" title="操作系统启动"></a>操作系统启动 </h2><h3 id="作用解析"><a href="# 作用解析" class="headerlink" title="作用解析"></a> 作用解析</h3><ul>
<li>硬盘（disk）：存放 OS 和 BootLoader</li>
<li>BIOS：基本 I/O 处理系统</li>
<li>BootLoader：用于加载 OS，将 OS 从 disk 加载到内存中</li>
</ul>
<blockquote>
<p>BIOS 是一种固化在计算机主板上的软件程序，其中的一个主要作用就是：启动计算机 —— 当你启动计算机时，<strong>BIOS 是第一个被执行的程序</strong>。它负责进行硬件自检（POST，Power-On Self-Test）以及初始化计算机的硬件设备，包括处理器、内存、硬盘、显卡等。<strong>BIOS 还负责加载操作系统的引导程序（BootLoader）</strong>。</p>
</blockquote>
<h3 id="启动步骤"><a href="# 启动步骤" class="headerlink" title="启动步骤"></a>启动步骤</h3><img src="../images/os-kernel/chapter2/os-startup.png" alt="计算机启动流程" width="60%" height="60%">

<p>操作系统启动过程可以概括为以下几个步骤：</p>
<ol>
<li>电源启动</li>
<li>BIOS 自检</li>
<li>加载引导程序（BootLoader）</li>
<li>引导程序的工作</li>
<li>内核初始化：操作系统内核接管控制权后，它会进行一系列的初始化工作，包括初始化进程管理、内存管理、文件系统等重要的系统组件</li>
<li>用户登录</li>
</ol>
<h4 id="BIOS 自检"><a href="#BIOS 自检" class="headerlink" title="BIOS 自检"></a>BIOS 自检</h4><img src="../images/os-kernel/chapter2/os-startup-layout.png" alt="计算机启动时内存和硬盘布局" width="60%" height="60%">

<p>计算机启动时，BIOS 从一个特定地址（CS:IP = 0xF000:FFF0）开始执行，这两个寄存器合在一起可以形成一个具体的物理内存地址。BIOS 就从这个内存地址开始执行 POST（加电自检）、寻找显卡和执行 BIOS。</p>
<blockquote>
<p>段寄存器（CS）和指令寄存器（IP）是计算机中的两种不同类型的寄存器：<br><strong>段寄存器 </strong> 是用于存储内存中的段地址的寄存器。在计算机中，内存被划分为多个段，每个段都有一个唯一的段地址。段寄存器存储着当前程序正在访问的段的地址。当程序需要访问内存中的数据时，它会使用段寄存器中的地址来确定要访问的段，并将其与偏移地址（存储在其他寄存器中）相加以获取最终的物理地址。<br><strong>指令寄存器（也称为程序计数器）</strong>是用于存储下一条要执行的指令的地址的寄存器。在计算机执行程序时，指令寄存器中保存着当前正在执行的指令的地址。当一条指令执行完毕后，指令寄存器会自动增加，以指向下一条将要执行的指令的地址。这样，计算机可以按顺序执行存储器中的指令序列。指令寄存器的值的改变决定了计算机下一步要执行的操作。</p>
</blockquote>
<h4 id="加载 BootLoader"><a href="# 加载 BootLoader" class="headerlink" title="加载 BootLoader"></a>加载 BootLoader</h4><img src="../images/os-kernel/chapter2/os-load-bootloader.png" alt="BIOS 加载引导程序" width="60%" height="60%">

<p><strong>BIOS 负责加载 BootLoader</strong>：BIOS 会从预设的启动设备（如硬盘、光盘、USB 等）中加载引导程序（BootLoader）到内存中。引导程序通常位于硬盘的特定扇区或光盘的启动区。</p>
<p><strong>引导程序的工作</strong>：引导程序负责初始化硬件（如 CPU、内存等），加载操作系统内核，并将控制权交给内核。它还可以提供多个操作系统的选择菜单（如 GRUB），以供用户选择启动的操作系统。</p>
<h4 id="加载 OS"><a href="# 加载 OS" class="headerlink" title="加载 OS"></a>加载 OS</h4><p>BootLoader 放在硬盘的第一个主引导扇区（512 字节）。这样，BIOS 从硬盘的第一个扇区寻找，一下便能找到 BootLoader。</p>
<img src="../images/os-kernel/chapter2/os-bootloader-address.png" alt="引导程序的内存地址空间" width="60%" height="60%">

<p><strong>BIOS 负责加载 BootLoader</strong>：将 BootLoader 从磁盘的引导扇区加载到 0x7C00 内存地址处。</p>
<p><strong>BootLoader 负责加载 OS</strong>：将操作系统的代码和数据从硬盘加载到内存中。之后，控制权交给到 OS（跳转到 OS 的起始地址）。</p>
<h2 id="中断、异常和系统调用"><a href="# 中断、异常和系统调用" class="headerlink" title="中断、异常和系统调用"></a>中断、异常和系统调用 </h2><p> 操作系统与设备和程序之间的交互可以通过中断、异常和系统调用来实现。</p>
<h3 id="定义"><a href="# 定义" class="headerlink" title="定义"></a>定义 </h3><p><strong> 中断（hardware interrupt）</strong>：是指外部事件（如硬件设备请求、定时器中断等）打断程序的正常执行，引发操作系统的处理程序来处理相应的事件。通过中断，设备可以向操作系统发出请求，操作系统可以响应并进行相应的处理。</p>
<p><strong>异常（exception）</strong>：是指程序执行过程中出现的错误或异常情况，如除零错误、访问非法内存等。当发生异常时，操作系统会捕获并进行相应的处理，例如终止异常程序、显示错误消息等。</p>
<p><strong>系统调用（system call）</strong>：是应用程序通过操作系统提供的接口来请求操作系统的服务。通过系统调用，应用程序可以访问操作系统提供的功能，如文件读写、网络通信、内存管理等。应用程序通过系统调用将请求传递给操作系统，操作系统执行相应的操作，并将结果返回给应用程序。</p>
<h3 id="来源"><a href="# 来源" class="headerlink" title="来源"></a>来源 </h3><p><strong> 中断来源于外设</strong>：来自不同的硬件设备的计时器和网络的中断。</p>
<p><strong>异常来源于不良的应用程序</strong>：非法指令或者其他坏的处理状态（如：内存出错）。</p>
<p><strong>系统调用来源于应用程序</strong>：应用程序主动向操作系统发出服务请求。</p>
<h3 id="处理时间"><a href="# 处理时间" class="headerlink" title="处理时间"></a>处理时间</h3><ul>
<li>中断：异步</li>
<li>异常：同步</li>
<li>系统调用：同步或异步<ul>
<li>同步：指应用程序等待系统调用的返回结果</li>
<li>异步：指应用程序发出系统调用后就去干别的事情了</li>
</ul>
</li>
</ul>
<blockquote>
<p>异步：应用程序不知道什么时候会发生 <br> 同步：执行到某一条指令一定会发生该事件</p>
</blockquote>
<h3 id="响应状态"><a href="# 响应状态" class="headerlink" title="响应状态"></a>响应状态</h3><ul>
<li>中断：持续，对用户应用程序是透明的（用户程序感知不到）</li>
<li>异常：杀死或重新执行指令</li>
<li>系统调用：等待和持续</li>
</ul>
<h3 id="中断、异常和系统调用比较"><a href="# 中断、异常和系统调用比较" class="headerlink" title="中断、异常和系统调用比较"></a>中断、异常和系统调用比较</h3><img src="../images/os-kernel/chapter2/os-interrupt-exception-syscall-compare.png" alt="中断、异常和系统调用比较" width="60%" height="60%">

<table>
<thead>
<tr>
<th>交互方式</th>
<th>来源</th>
<th>处理时间</th>
<th>响应状态</th>
</tr>
</thead>
<tbody><tr>
<td>中断</td>
<td>外设</td>
<td>异步</td>
<td>持续，对用户应用程序透明</td>
</tr>
<tr>
<td>异常</td>
<td>不良的应用程序</td>
<td>同步</td>
<td>杀死或重新执行指令</td>
</tr>
<tr>
<td>系统调用</td>
<td>应用程序</td>
<td>同步或异步</td>
<td>等待和持续</td>
</tr>
</tbody></table>
<h3 id="中断和异常处理流程"><a href="# 中断和异常处理流程" class="headerlink" title="中断和异常处理流程"></a>中断和异常处理流程 </h3><p> 中断是外设的事件，异常是内部 CPU 的事件。中断和异常迫使 CPU 访问一些与中断和异常相关的功能和服务。</p>
<h4 id="中断处理流程"><a href="# 中断处理流程" class="headerlink" title="中断处理流程"></a>中断处理流程 </h4><p> 操作系统的中断处理流程包括硬件中断处理和软件中断处理两个部分。</p>
<p><strong>硬件中断 </strong> 处理流程如下：</p>
<ol>
<li>硬件设备产生中断信号，例如外设完成数据传输、定时器到达计时器溢出等。</li>
<li><strong>CPU 检测到中断信号后，会立即停止当前正在执行的指令，并将当前执行指令的上下文（包括寄存器状态、程序计数器等）保存到内存中的堆栈中</strong>。</li>
<li>CPU 根据中断信号的类型，通过中断向量表或中断描述符表（IDT）查找相应的中断处理程序的入口地址。</li>
<li>CPU 跳转到中断处理程序的入口地址，开始执行中断处理程序。</li>
<li>中断处理程序根据中断类型执行相应的操作，例如处理设备的数据、更新操作系统状态等。</li>
<li><strong>中断处理程序执行完毕后，将之前保存的上下文从堆栈中恢复回来</strong>。</li>
<li>CPU 继续执行被中断的指令或者执行下一个指令。</li>
</ol>
<p><strong>软件中断 </strong> 处理流程如下：</p>
<ol>
<li>程序通过系统调用或软中断指令触发软件中断。</li>
<li>CPU 执行软中断指令后，<strong>会暂停当前正在执行的指令，并将当前执行指令的上下文保存到内存中的堆栈中</strong>。</li>
<li>CPU 根据软中断号，在中断向量表或中断描述符表（IDT）中查找相应的中断处理程序的入口地址。</li>
<li>CPU 跳转到中断处理程序的入口地址，开始执行中断处理程序。</li>
<li>中断处理程序根据软中断号执行相应的操作，例如系统调用、异常处理等。</li>
<li>中断处理程序执行完毕后，<strong>将之前保存的上下文从堆栈中恢复回来</strong>。</li>
<li>CPU 继续执行被中断的指令或者执行下一个指令。<br>可以概括为：“触发软中断——暂存上下文——查表——跳转（进入）——执行——退出——恢复上下文——继续”。</li>
</ol>
<p>中断处理流程可以概括为：“产生中断——暂存上下文——查表——跳转（进入）——执行——退出——恢复上下文——继续执行”。</p>
<p>总的来说，中断处理流程包括 <strong> 中断信号的检测、上下文的保存与恢复、中断处理程序的执行 </strong> 等步骤，以保证操作系统能够及时响应硬件设备的请求或软件的触发。</p>
<blockquote>
<p>应用程序完全不会感知到中断的产生。</p>
</blockquote>
<h4 id="异常处理流程"><a href="# 异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程 </h4><p> 操作系统的异常处理流程如下：</p>
<ol>
<li><strong>异常产生</strong>：异常是指在程序执行过程中发生的错误或异常情况，例如访问非法内存、除零错误等。异常可以由硬件产生，也可以由软件产生。</li>
<li><strong>异常检测</strong>：CPU 会检测到异常的发生，并中断当前正在执行的指令。</li>
<li><strong>异常处理程序选择</strong>：CPU 会通过中断向量表或中断描述符表（IDT）查找相应的异常处理程序的入口地址。</li>
<li><strong>上下文保存</strong>：CPU 会将当前执行指令的上下文（包括寄存器状态、程序计数器等）保存到内存中的堆栈中。</li>
<li><strong>异常处理程序执行</strong>：CPU 跳转到异常处理程序的入口地址，开始执行异常处理程序。</li>
<li><strong>异常处理</strong>：异常处理程序会根据异常类型执行相应的操作，例如打印错误信息、终止异常进程、恢复系统状态等。</li>
<li><strong>上下文恢复</strong>：异常处理程序执行完毕后，将之前保存的上下文从堆栈中恢复回来。</li>
<li><strong>异常返回</strong>：CPU 继续执行被中断（指的是由异常引起的中断，而不是外部设备或事件所引起的中断）的指令或者执行下一个指令。</li>
</ol>
<p>总的来说，异常处理流程包括 <strong> 异常信号的检测、上下文的保存与恢复、异常处理程序的执行 </strong> 等步骤，异常处理流程的目的是在程序出现异常时能够及时处理异常情况，保证系统的稳定性和可靠性。</p>
<h3 id="系统调用"><a href="# 系统调用" class="headerlink" title="系统调用"></a>系统调用 </h3><p> 系统调用来源于应用程序，需要操作系统提供服务，这些服务需要操作系统来执行，这个过程就需要一个接口：<strong>系统调用接口</strong>。应用程序访问主要是通过高层次的 API 接口，而不是直接进行系统调用。</p>
<img src="../images/os-kernel/chapter2/os-syscall.png" alt="系统调用示例" width="60%" height="60%">

<p><strong>三种最常用的 APIs</strong>：</p>
<ul>
<li>Win32 API：用于 Windows</li>
<li>POSIX API：用于 POSIX-based systems（包括 UNIX，LINUX，Mac OS X）</li>
<li>Java API：用于 JAVA 虚拟机（JVM 跨平台）</li>
</ul>
<p><strong>特点</strong>：</p>
<ul>
<li>通常情况下，每个系统调用对应一个系统调用号<ul>
<li>系统调用接口根据这些序号来维护表的索引</li>
</ul>
</li>
<li>系统调用接口调用内核态中预期的系统调用<ul>
<li>并返回系统调用的状态和其他任何返回值</li>
</ul>
</li>
<li>用户不需要知道系统调用是如何实现的<ul>
<li>只需要获取 API 和了解操作系统将什么作为返回结果</li>
<li>操作系统接口的细节大部分都隐藏在 API 中</li>
</ul>
</li>
</ul>
<p><strong>用户态</strong>：操作系统运行中，CPU 所处的特权级别特别低，不能访问特权指令、I/O 指令。</p>
<p><strong>内核态</strong>：操作系统运行中，CPU 所处的级别很高，可以执行任何一条指令，包括特权指令、I/O 指令。</p>
<p><strong>系统调用 </strong>：触发 CPU<strong> 从用户态到内核态的转换</strong>。切换程序和内核的堆栈，需要一定的开销，但是换来了安全。</p>
<p><strong>系统调用是跨越操作系统边界的开销</strong>（值得的且必须的，保证了操作系统的安全性）：</p>
<ul>
<li>在执行时间上的开销超过程序调用</li>
<li>开销：<ul>
<li>建立中断、异常、系统调用号与对应服务例程映射关系的初始化开销</li>
<li>建立内核堆栈（用于内核退出时保存，内核执行时恢复，类似于应用程序的堆栈）</li>
<li>验证参数（内核不信任应用程序，故而需要验证参数）</li>
<li>内核态映射到用户态的地址空间（<strong>通过拷贝的方式传递数据</strong>，不像用户态下的应用程序，可以通过指针传递实现）<ul>
<li>更新页面映射权限</li>
</ul>
</li>
<li>内核态独立地址空间<ul>
<li>通过在 TLB 中维护不同的页表实现</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>「内核态独立地址空间」是指在操作系统中，内核和用户程序所使用的内存地址空间是相互独立的。</p>
</blockquote>
<h2 id="什么是更新页面映射权限"><a href="# 什么是更新页面映射权限" class="headerlink" title="什么是更新页面映射权限"></a>什么是更新页面映射权限 </h2><p>「更新页面映射权限」是指在操作系统中，<strong> 对虚拟内存中的页面进行权限的调整或修改</strong>。</p>
<p>在虚拟内存管理中，操作系统将物理内存空间映射到进程的虚拟地址空间中，形成了一种虚拟内存映射。每个页面都有对应的权限，例如读、写、执行等。当需要修改某个页面的权限时，就需要进行页面映射权限的更新。</p>
<p>更新页面映射权限的具体操作包括：</p>
<ol>
<li><strong>检查该页面的当前权限</strong>：首先，操作系统会检查该页面的当前权限，确定要进行哪些修改。</li>
<li><strong>修改页面权限</strong>：根据需要，操作系统会修改页面的权限，例如增加或删除某项权限。</li>
<li><strong>更新页表 </strong>：在虚拟内存管理中，每个进程都有自己的页表，<strong> 用于记录虚拟地址与物理地址之间的映射关系</strong>。当页面的权限发生变化时，操作系统需要更新相应的页表项，以反映最新的权限信息。</li>
</ol>
<p>通过更新页面映射权限，操作系统可以 <strong> 实现对进程的内存访问控制</strong>，保证系统的安全性和稳定性。</p>
<h2 id="应用程序不能直接访问外设"><a href="# 应用程序不能直接访问外设" class="headerlink" title="应用程序不能直接访问外设"></a>应用程序不能直接访问外设 </h2><p> 应用程序不能直接访问外设，而要通过操作系统的原因主要有以下几点：</p>
<ol>
<li>安全性：操作系统（内核）是被信任的第三方，只有操作系统才能执行特权指令，保护硬件和系统资源的安全。</li>
<li>统一性：通过操作系统提供的接口，应用程序可以统一地访问不同的外设，而不需要关心具体的硬件细节。</li>
<li>方便性：操作系统提供了一些高级功能和服务，如文件系统、网络协议等，应用程序可以更方便地使用这些功能。</li>
</ol>
<blockquote>
<p>参考资料：<br>1：<a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a><br>2：<a href="https://blog.csdn.net/weixin_53407527/category_11825873.html">https://blog.csdn.net/weixin_53407527/category_11825873.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>中断、异常和系统调用</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>中断</tag>
        <tag>异常</tag>
        <tag>系统调用</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter3.2 连续内存分配</title>
    <url>/posts/231108195351.html</url>
    <content><![CDATA[<p>这篇文章主要介绍操作系统的连续内存分配，包括内存的内碎片与外碎片、内存的动态分配算法、压缩式碎片整理与交换式碎片整理。</p>
<span id="more"></span>

<h2 id="连续内存分配"><a href="# 连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配 </h2><p> 连续内存分配：给进程分配一块不小于指定大小的、连续的物理内存区域。</p>
<h3 id="内存碎片问题"><a href="# 内存碎片问题" class="headerlink" title="内存碎片问题"></a>内存碎片问题 </h3><p> 内存碎片问题指的是空闲的内存无法被利用，细分为外部碎片和内部碎片。</p>
<ul>
<li>外部碎片：分配单元（进程）间的未使用内存</li>
<li>内部碎片：分配单元（进程）内的不能被利用的内存</li>
</ul>
<h3 id="分区的动态分配"><a href="# 分区的动态分配" class="headerlink" title="分区的动态分配"></a>分区的动态分配 </h3><p> 动态分区分配：当程序被加载执行时，分配一个进程指定大小可变的分区（块、内存块），且分区的物理地址是连续的。</p>
<p>分区的动态分配方式有以下三种：</p>
<ol>
<li>第一匹配分配（first fit）：在空闲的内存块中，从低内存往高内存顺序搜索，找到 <strong> 第一个 </strong> 比需求大的空闲块, 分配给应用程序。</li>
<li>最优适配分配（best fit）：在空闲的内存块中，找到比需求大的 <strong> 最小的 </strong> 空闲块, 分配给应用程序。</li>
<li>最差适配分配（worst fit）：在空闲的内存块中，找到比 <strong> 最大的 </strong> 空闲块, 分配给应用程序。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|....| 500bytes |.......| 1k bytes |...| 400bytes |...|    </span><br></pre></td></tr></table></figure>

<p>例如，现在有一个应用程序，需要 300bytes 的内存块，那么第一匹配分配将会选择 500bytes 的内存块，最优适配分配将会选择 400bytes 的内存块，最差适配分配将会选择 1k bytes 的内存块。</p>
<p>分配方式的区别：</p>
<table>
<thead>
<tr>
<th></th>
<th>第一匹配分配</th>
<th>最优适配分配</th>
<th>最差适配分配</th>
</tr>
</thead>
<tbody><tr>
<td>分配方式原理 &amp; 实现</td>
<td>按地址排序的空闲块列表、需要寻找合适的分区、重分配时需检查合并相邻空闲分区</td>
<td>按尺寸排序的空闲块列表、需要寻找合适的分区、重分配时需检查合并相邻空闲分区</td>
<td>按尺寸排序的空闲块列表、分配最大分区、重分配时需检查合并相邻空闲分区，并调整空闲分区列表顺序</td>
</tr>
<tr>
<td>优势</td>
<td>简单易实现、容易产生更大空闲块</td>
<td>相对简单、对小尺寸分配高效、可避免大的空闲分区被拆分</td>
<td>分配快、对中尺寸分配高效</td>
</tr>
<tr>
<td>劣势</td>
<td>容易产生外部碎片、不确定性、分配大块时较慢</td>
<td>容易产生外部碎片、重分配慢（释放分区较慢）、产生微小碎片</td>
<td>容易产生外部碎片、重分配慢（释放分区较慢）、容易破坏大的空闲分区，后续难以分配大的分区</td>
</tr>
</tbody></table>
<blockquote>
<p>三种分配方式并无优劣之分，因为我们无法判断内存请求的大小。</p>
</blockquote>
<h2 id="碎片整理"><a href="# 碎片整理" class="headerlink" title="碎片整理"></a>碎片整理 </h2><p> 可以看到的是，三种分区动态分配的方式都会产生外部碎片，因此我们可以对碎片进行一定的整理来解决碎片问题。</p>
<p>何为碎片整理？即通过调整应用程序（进程）占用的分区位置来减少或避免分区碎片，以腾出更大的内存块。</p>
<h3 id="压缩式碎片整理"><a href="# 压缩式碎片整理" class="headerlink" title="压缩式碎片整理"></a>压缩式碎片整理</h3><ul>
<li>方式：重置程序以合并外部碎片</li>
<li>条件：要求所有程序是动态可重定位的</li>
<li>需要解决的问题：<ul>
<li>何时重置？（在程序处于等待状态时才可以重置）</li>
<li>需要考虑内存拷贝的开销</li>
</ul>
</li>
</ul>
<p>一个压缩式碎片整理的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 原始应用程序的内存块和外部碎片</span><br><span class="line">|....| 500bytes |.......| 1k bytes |...| 400bytes |...|   </span><br><span class="line"></span><br><span class="line">// 新增一个应用程序，需要 1200bytes 的内存块，通过压缩式碎片整理，腾出一块满足需求的内存卡分配给新的应用程序</span><br><span class="line">|....|.......|...|...| 500bytes | 1k bytes | 400bytes |   </span><br></pre></td></tr></table></figure>

<h3 id="交换式碎片整理"><a href="# 交换式碎片整理" class="headerlink" title="交换式碎片整理"></a>交换式碎片整理</h3><ul>
<li>方式：运行程序需要更多的内存时，抢占等待的程序并且回收它们的内存，以增大可用内存空间</li>
<li>需要解决的问题：<ul>
<li>哪些程序应该被回收？</li>
</ul>
</li>
</ul>
<p>一个交换式碎片整理的示例：</p>
<ol>
<li>运行中：P3</li>
<li>等待中：P1，P2，P4</li>
<li>内存分布 -&gt; 主存：OS / P1 / P3 / P2 / P4 磁盘：空</li>
<li>当 P3 程序需要更大的内存时，可将等待中的 P4 程序先放入虚拟内存中 -&gt; </li>
<li>内存分布 -&gt; 主存：OS / P1 /    P3   / P2 磁盘：P4</li>
</ol>
<blockquote>
<p>参考资料：<br>1：<a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a><br>2：<a href="https://blog.csdn.net/weixin_53407527/article/details/124891795">https://blog.csdn.net/weixin_53407527/article/details/124891795</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>连续内存分配</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>连续内存分配</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter3.1 内存分层体系与地址空间生成</title>
    <url>/posts/231017195157.html</url>
    <content><![CDATA[<p>这篇文章主要介绍计算机的体系结构，内存的分层体系，操作系统的内存管理，地址空间和地址生成等内容。</p>
<span id="more"></span>

<h2 id="计算机体系结构"><a href="# 计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构 </h2><p>CPU：主要完成了对整个程序或软件的执行的控制。<br> 内存：主要是放置了程序的代码和它所处理的数据。<br>外设：各种外部设备配合程序更好的完成工作。</p>
<img src="/images/os-kernel/chapter3/computer-architecture.png" alt="计算机体系结构" width="60%" height="60%">

<h2 id="内存分层体系"><a href="# 内存分层体系" class="headerlink" title="内存分层体系"></a>内存分层体系</h2><img src="/images/os-kernel/chapter3/memory-layering.png" alt="内存分层体系" width="60%" height="60%">

<p>计算机内存包含多个层次，包括 CPU 寄存器、cache 和主存（物理内存）、硬盘（虚拟内存）。硬盘用于保存持久化数据。</p>
<ul>
<li>CPU 寄存器和 cache：<ul>
<li>访问速度快，但容量小；</li>
<li>寄存器是 CPU 内部的存储单元，用于存储临时数据和指令；</li>
<li>cache 是位于 CPU 和主存之间的高速缓存，<strong>用于加速对主存的访问</strong>。</li>
</ul>
</li>
<li>主存（物理内存）：<ul>
<li>存放操作系统和程序代码等数据；</li>
<li>容量较大，但访问速度相对较慢；</li>
<li>主存中的数据掉电会丢失。</li>
</ul>
</li>
<li>硬盘（虚拟内存）：<ul>
<li>保存持久化数据，即使掉电也不会丢失；</li>
<li>访问速度较慢，但容量可以很大。</li>
</ul>
</li>
</ul>
<p>操作系统会根据需要将数据从主存中放到硬盘中，以便管理数据的容量和提高运行效率。</p>
<h2 id="操作系统的内存管理"><a href="# 操作系统的内存管理" class="headerlink" title="操作系统的内存管理"></a>操作系统的内存管理 </h2><h3 id="目标"><a href="# 目标" class="headerlink" title="目标"></a> 目标 </h3><p> 操作系统的内存管理到底要做什么事情呢？它有如下几个重要的目标。</p>
<ul>
<li>抽象：逻辑地址空间<ul>
<li>操作系统通过提供逻辑地址空间，将底层细节抽象化，使应用程序不需要关心物理内存和外设的管理。</li>
</ul>
</li>
<li>保护：独立地址空间<ul>
<li>为了避免应用程序相互访问彼此的地址空间，操作系统提供了独立的地址空间，将它们隔离，以保护应用程序免受破坏。</li>
</ul>
</li>
<li>共享：访问相同内存<ul>
<li>多个应用程序之间也可能进行交互，操作系统允许多个应用程序共享相同的内存空间，以实现高效和可靠的数据传递。</li>
</ul>
</li>
<li>虚拟：更多的地址空间<ul>
<li>物理内存空间有限，操作系统将必要的数据放在主存中，而将暂时不需要访问的数据临时存放在磁盘上，从而扩展了可用的地址空间。</li>
</ul>
</li>
</ul>
<img src="/images/os-kernel/chapter3/os-memory-management.png" alt="操作系统的内存管理" width="60%" height="60%">

<p>在这张图中，操作系统将进程 P1、进程 P2、进程 P3 和进程 P4 将必要的数据被放在主存中（进程 P1 优先级最高，所有的数据都在主存中），暂时不需要访问的数据（进程 P4/P2/P3 的一部分数据）临时存放在磁盘上。</p>
<p>从上图中，也可以看出进程（我们的程序）属于逻辑地址空间，主存和磁盘的内存空间属于物理内存空间。</p>
<h3 id="内存管理的不同方法"><a href="# 内存管理的不同方法" class="headerlink" title="内存管理的不同方法"></a>内存管理的不同方法</h3><ul>
<li>程序重定位（relocation）</li>
<li>分段（segmentation）</li>
<li>分页（page）</li>
<li>虚拟内存（virtual memory）</li>
<li>按需分页虚拟内存<ul>
<li>目前多数操作系统（如 Linux）采用</li>
</ul>
</li>
</ul>
<blockquote>
<p>内存管理的实现高度依赖于硬件：</p>
<ul>
<li>必须知道内存架构（与计算机存储架构紧耦合）</li>
<li>MMU（内存管理单元）：硬件组件负责处理 CPU 的内存访问请求</li>
</ul>
</blockquote>
<h2 id="地址空间与地址生成"><a href="# 地址空间与地址生成" class="headerlink" title="地址空间与地址生成"></a>地址空间与地址生成 </h2><h3 id="地址空间定义"><a href="# 地址空间定义" class="headerlink" title="地址空间定义"></a> 地址空间定义 </h3><p> 物理地址空间就是内存条和硬盘的空间，它的管理和控制由硬件来完成的。</p>
<p>逻辑地址空间就是一个运行的程序所拥有的的内存空间，是一种一维的线性地址空间（这种设计可以使得应用程序很容易的进行数据访问操作）。</p>
<blockquote>
<p>逻辑地址空间的设计使得数据访问更加方便的「其中一个原因」就是：<br>逻辑地址空间是一维的线性地址空间，即内存地址在逻辑上是连续的。这种设计使得程序可以使用简单的地址计算来访问数据，而不需要考虑数据在内存中的实际物理位置。这样，程序员可以通过 <strong> 使用相对地址来访问数据，而不需要关注数据的具体位置</strong>。</p>
</blockquote>
<img src="/images/os-kernel/chapter3/memory-space.png" alt="地址空间" width="60%" height="60%">

<h3 id="物理 -vs- 逻辑地址空间对应关系"><a href="# 物理 -vs- 逻辑地址空间对应关系" class="headerlink" title="物理 vs. 逻辑地址空间对应关系"></a>物理 vs. 逻辑地址空间对应关系</h3><p>「物理地址空间 vs. 逻辑地址空间」是如何建立对应关系的？</p>
<p>一个运行的程序所访问的逻辑地址空间，最终都会对应着物理地址空间中的某一位置，可能放在主存中、也可能放在硬盘中。物理地址空间和逻辑地址空间通过映射关系对应起来（映射关系由操作系统进行有效地管理）。</p>
<h3 id="逻辑地址生成"><a href="# 逻辑地址生成" class="headerlink" title="逻辑地址生成"></a>逻辑地址生成 </h3><p> 下图展示了逻辑地址的生成过程。</p>
<img src="/images/os-kernel/chapter3/logical-address-generation.png" alt="逻辑地址生成" width="60%" height="60%">

<ol>
<li>C 程序文件（.c 文件）中的函数和变量名即逻辑地址。编译器会将 C 程序转换为汇编语言程序（.s 文件），并在汇编代码中使用符号来代表函数和变量的名字。</li>
<li>汇编语言程序（.s 文件）中的符号仍然是逻辑地址。编译器将汇编语言程序转换为机器语言程序（.o 文件），并将变量和函数的符号名转换为逻辑地址。</li>
<li>链接器（linker）将多个机器语言程序（.o 文件）链接在一起，形成一个单一的可执行文件（.exe 文件）。链接器会为每个变量和函数分配唯一的逻辑地址，并解决不同文件之间的符号引用关系。</li>
<li>加载器（loader）将可执行文件（.exe 文件）加载到内存中运行。加载器会将可执行文件的代码和数据加载到内存的适当位置，并进行地址的重定位。由于加载过程中会存在一定的偏移量，程序需要根据偏移量来进行正确的数据访问和指令操作。</li>
</ol>
<blockquote>
<p>逻辑地址生成的过程可以在编译器、链接器和加载器等工具的协同作用下完成，操作系统通常不需要干预该过程。这样的设计使得程序员可以方便地使用符号和逻辑地址进行开发，而无需关心实际的物理地址和内存布局。</p>
</blockquote>
<h3 id="物理地址生成"><a href="# 物理地址生成" class="headerlink" title="物理地址生成"></a>物理地址生成 </h3><p> 下图展示了物理地址的生成过程。</p>
<img src="/images/os-kernel/chapter3/physical-address-generation.png" alt="物理地址生成" width="60%" height="60%">

<p>物理地址的生成过程是由操作系统的内存管理单元（MMU）来完成的。MMU 负责将逻辑地址转换为物理地址，使得程序能够正确地访问内存。</p>
<ol>
<li>分页：操作系统将整个物理内存划分为固定大小的页面（page），通常是 4KB 或者更大的大小。同时，逻辑地址空间也被划分为相同大小的页面。</li>
<li>页表：每个进程都有一个页表，用于记录逻辑地址与物理地址的映射关系。页表的每个表项（entry）记录了逻辑页面号与物理页面号的对应关系。</li>
<li>地址转换：当程序访问某个逻辑地址时，MMU 会根据页表中的映射关系将逻辑地址转换为物理地址。具体的转换过程是 <strong> 通过逻辑地址中的页号（page number）和页内偏移（page offset）进行计算得到</strong>。</li>
<li>物理地址访问：得到物理地址后，程序就可以使用该地址直接访问内存中的数据或指令。</li>
</ol>
<blockquote>
<p>需要注意的是，物理地址生成的过程是 <strong> 在程序运行时 </strong> 由硬件执行的，而不是编译、链接或加载阶段进行的。<strong>操作系统会在程序加载到内存时设置好页表，并将页表的基地址告诉 MMU，以便进行地址转换</strong>。这样，程序在运行过程中，无需关心物理地址的生成和管理，而是通过逻辑地址进行访问。</p>
</blockquote>
<p>为了加快地址转换的速度，操作系统会将逻辑地址到物理地址的映射关系存储在内存中，并由 CPU 进行缓存。</p>
<blockquote>
<p>具体来说，当 CPU 首次访问某个逻辑地址时，MMU 会根据页表将逻辑地址转换为物理地址，并将该映射关系存储在一个特殊的高速缓存中，称为转换后备缓冲器（Translation Lookaside Buffer，简称 TLB）。TLB 是一种硬件缓存，用于临时存储逻辑地址到物理地址的映射关系。<br>当程序再次访问相同的逻辑地址时，CPU 会首先检查 TLB 中是否存在该映射关系：</p>
<ul>
<li>如果存在，则可以直接从 TLB 中获取物理地址，从而避免了访问内存的开销；</li>
<li>如果 TLB 中没有找到对应的映射关系，则需要通过页表来进行地址转换，并将新的映射关系存储到 TLB 中，以便下次访问时可以直接使用。</li>
</ul>
</blockquote>
<h3 id="地址安全检查"><a href="# 地址安全检查" class="headerlink" title="地址安全检查"></a>地址安全检查 </h3><p> 为了避免应用程序相互访问彼此的地址空间，操作系统提供了独立的地址空间，将它们隔离，以保护应用程序免受破坏。</p>
<img src="/images/os-kernel/chapter3/address-security-check.png" alt="地址安全检查" width="60%" height="60%">


<p>地址安全检查使应用程序在内存中正常执行，同时保证在内存中不同的应用程序之间不会相互破坏。</p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://blog.csdn.net/weixin_53407527/article/details/124930556">Operation System- 第 3 章 - 内存分层体系 &amp; 地址空间生成</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>地址空间与地址生成</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>内存分层体系</tag>
        <tag>地址空间生成</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter5.1 内存管理之覆盖技术与交换技术</title>
    <url>/posts/231123184526.html</url>
    <content><![CDATA[<p>这篇文章主要介绍操作系统的虚拟内存的起因，并对上世纪 80 年代流行的内存覆盖技术和内存交换技术进行回顾。同时，我们将在下一小节中给出虚拟内存管理技术——虚存技术。</p>
<span id="more"></span>

<h2 id="虚拟内存的起因"><a href="# 虚拟内存的起因" class="headerlink" title="虚拟内存的起因"></a>虚拟内存的起因 </h2><p> 理想中存储器：更大、更快、更便宜的非易失性存储器。</p>
<p>实际中，操作系统中存储器的层次结构：</p>
<table>
<thead>
<tr>
<th align="center">存储器层次结构</th>
<th align="center">典型访问时间</th>
<th align="center">典型容量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">寄存器（Register）</td>
<td align="center">1 nsec</td>
<td align="center">数 KB</td>
</tr>
<tr>
<td align="center">高速缓存（Cache）</td>
<td align="center">2 nsec</td>
<td align="center">数 MB</td>
</tr>
<tr>
<td align="center">主存储器（Main Memory）</td>
<td align="center">10 nsec</td>
<td align="center">数 GB</td>
</tr>
<tr>
<td align="center">硬盘、磁盘</td>
<td align="center">10 msec</td>
<td align="center">数 TB</td>
</tr>
<tr>
<td align="center">磁带</td>
<td align="center">100 sec</td>
<td align="center">数 TB</td>
</tr>
</tbody></table>
<p>使用硬盘 / 磁盘，使更多的程序可以在有限的内存中运行。</p>
<h2 id="解决内存不足的方法"><a href="# 解决内存不足的方法" class="headerlink" title="解决内存不足的方法"></a>解决内存不足的方法 </h2><p><strong> 在计算机系统中，尤其是在多道程序运行的环境下，可能会出现内存不够用的情况，怎么办</strong>？</p>
<ul>
<li><p>如果是 <strong> 程序太大 </strong>，超过了内存的容量，可以采用<strong> 手动的覆盖（overlay）技术</strong>，只把需要的指令和数据保存在内存当中；</p>
</li>
<li><p>如果是 <strong> 程序太多 </strong>，超过了内存的容量，可以采用<strong> 自动的交换（swapping）技术</strong>，把暂时不能执行的程序送到外存中；</p>
</li>
<li><p>如果想要在有限容量的内存中，以更小的页粒度为单位装入更多、更大的程序，可以采用 <strong> 自动的虚拟存储技术</strong>。</p>
</li>
</ul>
<h2 id="覆盖技术"><a href="# 覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术 </h2><h3 id="目标"><a href="# 目标" class="headerlink" title="目标"></a> 目标 </h3><p> 是在较小的可用内存中运行较大的程序。常用于多道程序系统，与分区存储管理配合使用。</p>
<h3 id="原理"><a href="# 原理" class="headerlink" title="原理"></a>原理 </h3><p> 把程序按照其自身逻辑结构，划分为若干个功能上相互独立的程序模块，那些 <strong> 不会同时执行的模块共享同一块内存区域，按时间先后来加载、运行</strong>。</p>
<ul>
<li><p>必要部分（常用功能）的代码和数据，放在内存的常驻区；</p>
</li>
<li><p>可选部分（不常用功能）在其他程序模块中实现，平时存放在外存中，在需要用到时才装入内存；</p>
</li>
<li><p>不存在调用关系的模块不必同时装入到内存，从而可以相互覆盖，即这些模块共用一个分区。</p>
</li>
</ul>
<p>覆盖技术示例：<br><img src="../images/os-kernel/chapter5/overlay.png" alt="覆盖技术示例" width="60%" height="60%"></p>
<p>示例中，程序大小为 190K，而整个内存的大小才 110K，内存放不下这个程序。采用覆盖技术，将不会同时执行的模块放在同一个覆盖区（谁执行将谁放在覆盖区中，不执行的先暂存在外存中）。</p>
<p>因此不需要将整个程序 190k 的数据全部放入内存中，而是划分为：常驻区（20k） 覆盖区 0（50k） 覆盖区 1（40k） 压缩至了 110k 的内存空间使用。</p>
<p>另一种覆盖方式：A 在常驻区，B、E 和 F 在覆盖区 0，C 和 D 在覆盖区 1，这样可以压缩至 20 + 50 + 30 = 100K 的内存空间使用。</p>
<blockquote>
<p>程序串行执行，每次只会用到某个分区中的一个模块，不同的模块占用区域的时间不一样，所以可以往同一个分区存放。</p>
</blockquote>
<h3 id="缺点"><a href="# 缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>需要由程序员来把一个大的程序划分为若干个小的功能模块，并确定各个模块之间的覆盖关系，费时费力，增加了编程的复杂度；</li>
<li>覆盖模块从外存装入内存，实际上是以时间延长来换取空间节省。</li>
</ul>
<h2 id="交换技术"><a href="# 交换技术" class="headerlink" title="交换技术"></a>交换技术 </h2><h3 id="目的"><a href="# 目的" class="headerlink" title="目的"></a> 目的 </h3><p> 多道程序在内存时，让正在运行的程序或需要运行的程序获得更多的内存资源。</p>
<h3 id="原理 -1"><a href="# 原理 -1" class="headerlink" title="原理"></a>原理</h3><ul>
<li>可将暂时不能运行的程序送到外存，从而获得空闲内存空间。</li>
<li>操作系统把一个进程的整个地址空间的内容保存到外存中（换出，swap out），而将外存中的某个进程的地址空间读入到内存中（换入，swap in）。<ul>
<li>换入换出内容的大小为整个程序的地址空间。</li>
</ul>
</li>
</ul>
<blockquote>
<p>换入换出是通过操作系统的内存管理机制来完成的。操作系统会维护一个页表（page table），记录每个进程的虚拟内存和物理内存之间的映射关系。当一个进程被换出时，操作系统会将该进程的所有页面（包括代码、数据和堆栈）从内存复制到外存中的一个交换文件中。而当一个进程需要被换入时，操作系统会将该进程的所有页面从交换文件中复制回内存，并更新页面表中的映射关系。这样就可以实现进程的换入换出。</p>
</blockquote>
<p>交换技术示例：<br><img src="../images/os-kernel/chapter5/swap.png" alt="交换技术示例" width="60%" height="60%"></p>
<h3 id="缺点 -1"><a href="# 缺点 -1" class="headerlink" title="缺点"></a>缺点 </h3><p> 交换技术实现中的几个问题：</p>
<ul>
<li><p>交换时机的确定（何时需要发生交换）：只当内存空间不够或有不够的危险时，才进行换出操作；</p>
</li>
<li><p>交换区的大小：外存的交换区必须足够大，以存放所有用户进程的所有内存映像的拷贝，必须能够对这些内存映像进行直接存取；</p>
</li>
<li><p>程序换入时的重定位：换出后再换入的内存位置一定要在原来的位置上吗？不一定。最好采用动态地址映射的方法，否则寻址可能出现问题。</p>
<ul>
<li>动态地址映射：程序的虚拟地址一样，物理地址换入后不一样了，这没关系，靠页表映射解决就可以啦。</li>
</ul>
</li>
</ul>
<blockquote>
<p>交换技术是可以由操作系统帮助完成的，对于程序员来说是透明的，减轻了程序员的负担，但是系统的开销变大了。</p>
</blockquote>
<h2 id="覆盖技术与交换技术对比"><a href="# 覆盖技术与交换技术对比" class="headerlink" title="覆盖技术与交换技术对比"></a>覆盖技术与交换技术对比</h2><table>
<thead>
<tr>
<th align="center">特点</th>
<th align="center">覆盖技术</th>
<th align="center">交换技术</th>
</tr>
</thead>
<tbody><tr>
<td align="center">适用范围</td>
<td align="center">仅适用于没有调用关系的程序模块之间</td>
<td align="center">适用于任意进程之间</td>
</tr>
<tr>
<td align="center">逻辑覆盖结构</td>
<td align="center">需要程序员给出各个模块之间的逻辑覆盖结构</td>
<td align="center">不需要程序员给出各个模块之间的逻辑覆盖结构</td>
</tr>
<tr>
<td align="center">发生位置</td>
<td align="center">程序的内部</td>
<td align="center">内存中程序与管理程序 / 操作系统之间</td>
</tr>
<tr>
<td align="center">程序员负担</td>
<td align="center">增加程序员负担</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">处理器开销</td>
<td align="center">-</td>
<td align="center">增加处理器开销</td>
</tr>
<tr>
<td align="center">交换最小单位</td>
<td align="center">模块为单位</td>
<td align="center">进程为单位</td>
</tr>
</tbody></table>
<blockquote>
<p>参考资料：<br>1：<a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a><br>2：<a href="https://blog.csdn.net/weixin_53407527/article/details/124983180">https://blog.csdn.net/weixin_53407527/article/details/124983180</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>内存管理技术</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>覆盖技术</tag>
        <tag>交换技术</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter4.2 非连续内存分配之页表</title>
    <url>/posts/231119170537.html</url>
    <content><![CDATA[<p><a href="https://pursue26.github.io/posts/231111172507.html">操作系统之 chapter4.1 非连续内存分配之分段与分页 </a> 介绍了非连续内存的分段与分页技术。那么，如何才能有效的实现逻辑地址到物理地址的转换机制呢？那就是通过页表。本文将介绍页表、快表 TLB、二级 &amp; 多级页表和反向页表，你将学习到如何进行地址转换，以及如何进一步高效的进行地址转换。</p>
<span id="more"></span>

<h2 id="页表"><a href="# 页表" class="headerlink" title="页表"></a>页表 </h2><h3 id="页表概述"><a href="# 页表概述" class="headerlink" title="页表概述"></a> 页表概述 </h3><p> 页表是操作系统中用于管理虚拟内存和物理内存之间 <strong> 映射关系 </strong> 的数据结构。它记录了虚拟地址和物理地址之间的对应关系，使得程序可以使用虚拟地址来访问物理内存，而无需关注具体的物理内存地址。</p>
<p>每一个运行的程序都有一个独立的页表：</p>
<ul>
<li>页表属于程序运行状态，会动态变化</li>
<li>PTBR（Page Table Base Register）：页表基址寄存器，用于存储页表的基地址，以指示当前使用的页表位置。</li>
</ul>
<h3 id="页表结构"><a href="# 页表结构" class="headerlink" title="页表结构"></a>页表结构 </h3><p> 页表其实就是一个大数组，它的索引 index 指的是 page-number（页号），索引对应的内容是 frame−number（帧号）。得到帧号后，再叠加上 offset（页帧内偏移）即可得到物理地址。</p>
<img src="/images/os-kernel/chapter4/page-table.png" alt="页表结构" width="60%" height="60%">

<p>页表中还有一些特殊标志位：</p>
<ul>
<li>dirty bit，脏位</li>
<li>resident bit，表示这个页表项是否合法（对应的物理地址中是否存在），0- 不存在，1- 存在</li>
<li>clock/reference bit，时钟 / 参考位</li>
</ul>
<p><strong>上图中 PTBR 的作用</strong>？</p>
<p>当程序访问虚拟内存时，CPU 会将虚拟地址发送给内存管理单元（MMU），MMU 根据页表进行地址转换。在这个过程中，CPU 会读取 PTBR 寄存器中的值，以确定当前使用的页表的位置。通过 <strong> 将虚拟地址的高位（即虚拟页号部分）与页表基地址相加，CPU 可以找到相应的表项，并进行地址转换</strong>，获取虚拟地址对应的物理地址。</p>
<blockquote>
<p>PTBR 的值通常在操作系统进行上下文切换时被修改，以切换不同的页表。这样，不同的进程可以拥有独立的页表，实现虚拟内存的隔离和保护。通过修改 PTBR，操作系统可以控制不同进程之间的地址空间映射关系，从而实现多进程共享物理内存的管理。</p>
</blockquote>
<h3 id="地址转换实例"><a href="# 地址转换实例" class="headerlink" title="地址转换实例"></a>地址转换实例 </h3><p> 具有 16 位地址的系统，具有：</p>
<ul>
<li>每页 1024 bytes，占用 10 位；帧号占用 6 位</li>
<li>物理内存大小为 2^6 * 1024 bytes = 64KB</li>
</ul>
<blockquote>
<p>物理内存是 64KB，还是图中的 32KB 呢？</p>
</blockquote>
<img src="/images/os-kernel/chapter4/address-translation.png" alt="地址转换实例" width="60%" height="60%">

<p>从图中可以了解到：</p>
<ul>
<li><p>对于二元组为 <code>(4, 0)</code> 的逻辑地址空间，它在页表中对应 <code>index = 4</code> 的那个页表项。可以看出，它对应的 resident bit 位的值为 0，表明这个页表项对应的物理地址不存在。这时请求访问物理内存，可能会造成 <strong> 内存访问异常（可能要杀死程序）</strong>。</p>
</li>
<li><p>对于二元组为 <code>(3, 1023)</code> 的逻辑地址空间，它在页表中对应 <code>index = 3</code> 的那个页表项。可以看出，它对应的 resident bit 位的值为 1，表明这个页表项对应的物理地址存在，对应的页帧号的二进制表示为 <code>00100</code>，则对应的物理内存地址为 <code>(4, 1023)</code> ，即 4x1024+1023=5119。</p>
</li>
</ul>
<h3 id="分页机制的性能问题"><a href="# 分页机制的性能问题" class="headerlink" title="分页机制的性能问题"></a>分页机制的性能问题 </h3><p> 进程访问一次内存单元，需要 2 次内存访问：</p>
<ul>
<li>一次用于获取页表项（通过页号查表获取页帧号）。</li>
<li>一次用于访问数据（访问物理内存的数据）。</li>
</ul>
<p>页表可能非常大：</p>
<ul>
<li>64 位的机器，如果每页 1024 字节，那么一个页表的大小是多少（有多少个页号）？<ul>
<li>$2^{64} / 2^{10} = 2^{54}$，这么大的页表，在内存中是放不下的。</li>
</ul>
</li>
<li>每一个运行的程序都需要有一个页表。</li>
</ul>
<p>如何处理？</p>
<ul>
<li>缓存（Caching）：使用 CPU 内部的 TLB（使用相关存储器，可以进行并发的、高速的查询）。</li>
<li>间接（Indirection）访问：使用二级页表、多级页表。</li>
</ul>
<h2 id="快表（TLB）——解决时间问题"><a href="# 快表（TLB）——解决时间问题" class="headerlink" title="快表（TLB）——解决时间问题"></a>快表（TLB）——解决时间问题 </h2><p> 转换后备缓冲区（Translation Look-aside Buffer, TLB）是一种高速缓存，也叫快表，<strong>用于加快虚拟地址到物理地址的转换过程 </strong>。它是页表的一部分，<strong> 用于存储最近使用的虚拟页与物理页的映射关系，以减少对页表的访问次数，提高地址转换的效率</strong>。</p>
<img src="/images/os-kernel/chapter4/cpu-tlb.png" alt="快表" width="60%" height="60%">

<p>TLB 缓存近期访问的页帧转换表项：</p>
<ul>
<li>TLB 是一个小而快速的硬件缓存，使用关联内存（associative memory）实现，具备快速访问性能。每个 TLB 条目包含一个虚拟页号（VPN）和对应的物理页号（PPN），以及一些其他用于管理的标志位，如访问权限、脏位等。</li>
<li>如果 TLB 命中，物理页号可以很快被获取。</li>
<li>如果 TLB 未命中、缺失（TLB miss），对应的表项被更新到 TLB 中（该动作在 x86 的 CPU 中由硬件实现，其他的可能是由操作系统实现）。</li>
</ul>
<blockquote>
<p>当程序访问一个虚拟地址时，CPU 首先在 TLB 中查找对应的虚拟页号。如果找到了匹配的 TLB 条目，就可以直接从 TLB 中获取对应的物理页帧号，然后进行内存访问，无需访问页表。这个过程称为 TLB 命中。</p>
</blockquote>
<p>TLB 缺失会不会很频繁呢？</p>
<p>不会的。假如 32 位的系统，每页的大小为 4K 字节，如果该页的每一个地址都访问一次的话，需要 4K 次才会造成一次 TLB 缺失——因为从当前页首访问到当前页尾，下次访问时会是不同的逻辑页号，这个页号可能不在 TLB 表中。（这是假设情况，实际中 TLB 缺失的频率取决于许多因素，无法简单地通过每页的大小和访问次数来确定 TLB 缺失的频率）</p>
<h2 id="二级 -amp- 多级页表——解决空间问题"><a href="# 二级 -amp- 多级页表——解决空间问题" class="headerlink" title="二级 &amp; 多级页表——解决空间问题"></a>二级 &amp; 多级页表——解决空间问题 </h2><p> 二级 &amp; 多级页表利用时间换空间，来解决页表的空间问题。</p>
<p>二级页表：</p>
<ol>
<li>将页号分为两个部分、页表分为两个，一级页号对应一级页表，二级页号对应二级页表；</li>
<li>一级页号查表获得在二级页表的起始地址，地址加上二级页号的值，在二级页表中获得帧号。</li>
</ol>
<p>二级页表节约了一定的空间 —— 在一级页表中如果 <code>resident bit=0</code>，则在二级页表中 <strong> 不存储 </strong> 相关 <code>index</code>，而只有一张页表的话，这一些 <code>index</code> 都需要保留。</p>
<img src="/images/os-kernel/chapter4/secondary-page-table.png" alt="二级页表" width="60%" height="60%">

<blockquote>
<p>二级页表就像是目录的目录，先找到一级目录，再在一级目录内找到二级目录。</p>
</blockquote>
<p>多级页表：</p>
<ul>
<li>通过把页号分为 <code>k</code> 个部分，来实现多级间接页表，建立一棵「页表树」。</li>
</ul>
<img src="/images/os-kernel/chapter4/multi-page-table.png" alt="多级页表" width="60%" height="60%">

<blockquote>
<p>多级页表就像是目录的目录的目录…</p>
</blockquote>
<h2 id="反向页表"><a href="# 反向页表" class="headerlink" title="反向页表"></a>反向页表 </h2><p> 有没有一种方法使得页表的大小与逻辑地址大小没有那么大的关系，尽量与物理地址大小建立对应关系？——反向页表</p>
<h3 id="什么是反向页表"><a href="# 什么是反向页表" class="headerlink" title="什么是反向页表"></a>什么是反向页表 </h3><p> 在操作系统中，反向页表（Inverted Page Table）是一种用于虚拟内存管理的数据结构。与传统的页表不同，<strong>传统的页表将虚拟页号映射到物理页帧号，而反向页表将物理页帧号映射到虚拟页号</strong>。</p>
<h3 id="反向页表的目的"><a href="# 反向页表的目的" class="headerlink" title="反向页表的目的"></a>反向页表的目的 </h3><p> 反向页表的目的是 <strong> 为了解决大型内存系统（地址的寻址空间非常大）中的页表大小太大（占用内存空间太大）和访问效率的问题</strong>。</p>
<h4 id="传统页表和多级页表的弊端"><a href="# 传统页表和多级页表的弊端" class="headerlink" title="传统页表和多级页表的弊端"></a>传统页表和多级页表的弊端 </h4><p><strong> 传统页表 </strong>：<br> 在传统的页表中，每个进程都有自己的页表，而随着进程数量的增加和每个进程的逻辑地址空间的增大，页表的大小也会急剧增加。这样会导致内存开销大，并且访问页表的时间也会增加。</p>
<p><strong>多级页表 </strong>：<br> 在大型内存系统（64-bits 系统）中，前向映射页表变得繁琐，比如：使用了 5 级页表。</p>
<h4 id="反向页表的优势"><a href="# 反向页表的优势" class="headerlink" title="反向页表的优势"></a>反向页表的优势 </h4><p> 在传统的页表中，每个进程都有自己的页表。而 <strong> 反向页表只有一张，它只需要为系统中的每个物理页帧分配一个表项，每个表项记录了该物理页帧所属的进程号（PID）和虚拟页号 </strong>。当进行地址转换时，<em> 操作系统只需通过物理页帧号查找反向页表，即可得到对应的进程号和虚拟页号</em>。这样就避免了每个进程都拥有一个独立的页表，大大减少了页表的大小。</p>
<p>也就是，<strong>反向页表的大小只跟物理地址空间的大小相对应，而与快速增长的虚拟地址空间的大小无关</strong>。</p>
<blockquote>
<p><em>操作系统只需通过物理页帧号查找反向页表，即可得到对应的进程号和虚拟页号</em>：（个人理解）只要遍历查找的虚拟页号和进程号，跟当前的进程的 PID 和虚拟页号匹配上了，那么就可以使用这个物理页帧号来获取对应的物理内存，并访问数据了。</p>
</blockquote>
<h3 id="基于页寄存器（Page-Registers）的方案"><a href="# 基于页寄存器（Page-Registers）的方案" class="headerlink" title="基于页寄存器（Page Registers）的方案"></a>基于页寄存器（Page Registers）的方案 </h3><h4 id="方案"><a href="# 方案" class="headerlink" title="方案"></a> 方案 </h4><p> 页表中存储（页帧号，页号），使得页表大小与物理内存大小相关，而与逻辑内存关联减小。</p>
<img src="/images/os-kernel/chapter4/page-registers.png" alt="基于页寄存器的方案" width="60%" height="60%">

<p>每一个页帧和一个页寄存器关联，寄存器内容包括：</p>
<ul>
<li>使用位（resident bit）：此帧是否被进程占用</li>
<li>占用页号（occupier）：对应的页号 p</li>
<li>保护为（protection bits）：保护位</li>
</ul>
<h4 id="页寄存器空间占比"><a href="# 页寄存器空间占比" class="headerlink" title="页寄存器空间占比"></a>页寄存器空间占比 </h4><p> 有如下一个操作系统：</p>
<ul>
<li>页面大小：4096 bytes = 4KB</li>
<li>页帧数：4096 = 4K</li>
<li>物理内存大小：4096 * 4096 bytes = 4K * 4KB = 16MB</li>
</ul>
<p>则页寄存器使用的空间（假设 8 bytes/register）：8 bytes * 4096 = 32KB</p>
<ul>
<li>每一个页帧和一个页寄存器关联——页寄存器使用的空间即页表中所有页帧号对应页的页寄存器空间</li>
<li>页寄存器带来的额外内存开销占比：32KB / 16MB = 0.195%</li>
<li>虚拟内存大小：任意</li>
</ul>
<h4 id="优势"><a href="# 优势" class="headerlink" title="优势"></a>优势 </h4><p> 从上面的示例可以看出，基于页寄存器的方案有如下优势：</p>
<ul>
<li>转换表的大小相对于物理内存来说很小</li>
<li>转换表的大小跟逻辑地址空间的大小无关</li>
</ul>
<h4 id="劣势"><a href="# 劣势" class="headerlink" title="劣势"></a>劣势 </h4><p> 需要的信息对调了，即根据帧号可以找到页号。如何转换回来（如何根据页号找到页帧号）？</p>
<p>答：需要在反向页表中搜索想要的页号，才能得到对应的页帧号。</p>
<h3 id="基于关联内存（associative-memory）的方案"><a href="# 基于关联内存（associative-memory）的方案" class="headerlink" title="基于关联内存（associative memory）的方案"></a>基于关联内存（associative memory）的方案 </h3><p> 就是在上方 TLB 中提到的相关存储器，并发的、高速的查询，效率很快。</p>
<p>该方案在设计上，页表中存储（页帧号，页号），而不是像 TLB 中存储（页号，页帧号）。</p>
<h4 id="劣势 -1"><a href="# 劣势 -1" class="headerlink" title="劣势"></a>劣势 </h4><p> 硬件设计太复杂，容量不可能做大，需要放置在 CPU 中。</p>
<p>在反向页表中搜索一个页对应的页帧号：</p>
<ul>
<li>如果帧数较少，页寄存器可以被放在关联内存中。</li>
<li>在关联内存中查找逻辑页号：<ul>
<li>成功：页帧号被提取</li>
<li>失败：页错误异常（page fault）</li>
</ul>
</li>
<li>限制因素，大量的关联存储非常昂贵<ul>
<li>难以在单个时钟周期内完成</li>
<li>耗电</li>
</ul>
</li>
</ul>
<h3 id="基于哈希（hash）的方案"><a href="# 基于哈希（hash）的方案" class="headerlink" title="基于哈希（hash）的方案"></a>基于哈希（hash）的方案 </h3><p> 基于哈希的方案可以有效缓解页帧号 - 页号的映射的开销，需要硬件帮助，但会出现哈希冲突。哈希冲突是指不同的页号可能映射到相同的页帧号，这会导致冲突和错误的映射。</p>
<h4 id="方案 -1"><a href="# 方案 -1" class="headerlink" title="方案"></a>方案 </h4><p> 在基于哈希的反向页表中，为了解决哈希冲突，可以利用进程的 <code>PID</code>，在哈希函数的基础上再加一个 <code>PID</code> 参数，标记当前运行程序的编号，根据 <code>hash(PID, p)</code> 哈希函数，算出当前进程的页号所对应的页帧号。</p>
<img src="/images/os-kernel/chapter4/hash-reverse-page-table.png" alt="基于哈希的方案" width="60%" height="60%">

<h4 id="映射过程"><a href="# 映射过程" class="headerlink" title="映射过程"></a>映射过程 </h4><p> 基于哈希的反向页表解决哈希冲突示意图（图中 vpn 表示虚拟页号，ppn 表示物理页帧号）：<br><img src="/images/os-kernel/chapter4/hash-reverse-page-table-hash-collisions.png" alt="基于哈希的反向页表解决哈希冲突" width="60%" height="60%"></p>
<p>上图为基于哈希的反向页表解决哈希冲突，并搜索一个页对应的页帧号的过程，可以按照以下步骤进行：</p>
<ol>
<li><p>对 <code>PID</code> 和页号做哈希计算 <code>hash(PID, p)</code>，并使用它作为页寄存器表的索引，获取对应的页寄存器内容。</p>
<ul>
<li>如果寄存器表项中包含 <code>p</code> 和 <code>PID</code>，则搜索成功，索引号就是页帧号；</li>
<li>如果寄存器表项中不包含 <code>p</code> 和 <code>PID</code>，说明存在哈希冲突。</li>
</ul>
</li>
<li><p>如果存在哈希冲突：</p>
<ul>
<li>在表项中寻找 <code>next</code> 提供的页寄存器索引，通过该索引，重复步骤 1，直到寄存器表项中包含 <code>p</code> 和 <code>PID</code> 为止。</li>
</ul>
</li>
<li><p>获取页帧号后，根据页帧号和页内偏移可以计算出虚拟地址映射的物理地址，并进行数据访问。</p>
</li>
</ol>
<blockquote>
<p>这样，即使存在哈希冲突，不同的进程会根据不同的 <code>PID</code> 选择不同的页帧号，从而避免了冲突和错误的映射。</p>
</blockquote>
<h4 id="劣势 -2"><a href="# 劣势 -2" class="headerlink" title="劣势"></a>劣势 </h4><p> 基于哈希的反向页表还是需要把反向页表放到内存中，做哈希计算时也需要到内存中取值。由于内存访问的时间开销较大，所以还需要有一个类似 TLB 的机制缓存起来，避免频繁地访问内存，提高寻址的效率。</p>
<h4 id="优势 -1"><a href="# 优势 -1" class="headerlink" title="优势"></a>优势 </h4><p> 目前来说，这种机制只在高端 CPU 中存在，好处：</p>
<ul>
<li>表的容量可以做的很小，只和物理空间关联</li>
<li>反向页表只有一张，它的大小只跟物理地址空间的大小相对应，所以它占的空间节省很多；但它是有代价的，它需要以一种很高速的哈希计算、硬件处理机制、高效函数以及解决冲突的机制才可以使访问的效率得到保障。这种机制由硬件、相应的操作系统软件配合，可以在空间和时间上取得比较好的结果。</li>
</ul>
<blockquote>
<p>参考资料：<br>1：<a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a><br>2：<a href="https://blog.csdn.net/weixin_53407527/article/details/124891795">https://blog.csdn.net/weixin_53407527/article/details/124891795</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>非连续内存分配</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>非连续内存分配</tag>
        <tag>页表</tag>
        <tag>反向页表</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter5.2 内存管理之虚存技术</title>
    <url>/posts/231127193658.html</url>
    <content><![CDATA[<p>在文章 <a href="https://pursue26.github.io/posts/231123184526.html"> 操作系统之 chapter5.1 虚拟内存管理之覆盖技术与交换技术 </a> 中，介绍了内存管理的覆盖技术和交换技术；这篇文章将介绍虚拟内存管理技术（虚存技术），它结合了覆盖技术和交换技术中的优点。</p>
<span id="more"></span>

<h1 id="虚拟内存管理技术"><a href="# 虚拟内存管理技术" class="headerlink" title="虚拟内存管理技术"></a>虚拟内存管理技术 </h1><p> 如果想要在有限容量的内存中，以 <strong> 更小的页粒度为单位 </strong> 装入更多、更大的程序，可以采用自动的虚拟存储技术。</p>
<h2 id="目标"><a href="# 目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li><p>像覆盖技术那样，不是把程序的所有内容都放在内存中，因而能够运行比当前的空闲内存空间还要大的程序。但做的更好，由操作系统自动来完成，无需程序员的干涉。</p>
</li>
<li><p>像交换技术那样，能够实现进程在内存与外存之间的交换，因而获得更多的空闲内存空间。但做的更好，只对进程的部分内容在内存和外存之间进行交换。</p>
</li>
</ul>
<img src="/images/os-kernel/chapter5/memory-management.png" alt="操作系统内存管理" width="60%" height="60%">

<h2 id="程序局部性原理"><a href="# 程序局部性原理" class="headerlink" title="程序局部性原理"></a>程序局部性原理 </h2><p> 程序的局部性原理（principle of locality）：指程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定的区域。</p>
<ul>
<li>时间局部性：一条指令的一次执行和下次执行、一个数据的一次访问和下次访问都集中在一个较短时期内；</li>
<li>空间局部性：当前指令和邻近的几条指令、当前访问的数据和邻近的几个数据都集中在一个较小区域内。</li>
</ul>
<p>程序的局部性原理表明，从理论上来说，虚拟存储技术是能够实现的。而且在实现了以后应该是能够取得一个满意的效果。</p>
<h3 id="经典实例"><a href="# 经典实例" class="headerlink" title="经典实例"></a>经典实例 </h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 题目描述：</span></span><br><span class="line"><span class="comment">页面大小为 4KB，分配给每个进程的物理页面是 1。 </span></span><br><span class="line"><span class="comment">在一个进程中，定义了如下的二维数组 int arr[1024][1024]，该数组按行存放在内存，每一行放在一个页面中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">考虑一下程序的编写方法对缺页率的影响？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序编写方法 1：（发生了 1024*1024 次缺页中断）</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">1024</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">        arr[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序编写方法 2：（发生了 1024 次缺页中断）</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">1024</span>; j++) &#123;</span><br><span class="line">        arr[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为数组是「按行」存放在一块连续的内存中的，上面的二维数组每行有 1024 个元素（类型为 <code>int</code> 型），所以该数组的一行数据，占用 4K 字节，正好为一个物理页面的空间。</p>
<ul>
<li>方法一是按列访问的，即访问完第 0 列，再访问第 1 列，每列的不同行处在不同的物理页面中，因此会发生 $1024^{2}$ 次缺页中断；</li>
<li>方法二是按行访问的，即访问完第 0 行，再访问第 1 行，访问的每行都是在同一个物理页面中，因此只会发生 $1024$ 次缺页中断。</li>
</ul>
<h3 id="实例耗时测试"><a href="# 实例耗时测试" class="headerlink" title="实例耗时测试"></a>实例耗时测试</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">1024</span>][<span class="number">1024</span>];</span><br><span class="line">    <span class="type">clock_t</span> start, end;</span><br><span class="line">    <span class="type">double</span> cpu_time_used;</span><br><span class="line"></span><br><span class="line">    start = clock();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1024</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">            arr[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    end = clock();</span><br><span class="line">    cpu_time_used = ((<span class="type">double</span>)(end - start)) / CLOCKS_PER_SEC;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 代码执行耗时：%f 秒 \n&quot;</span>, cpu_time_used);</span><br><span class="line"></span><br><span class="line">    start = clock();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1024</span>; j++) &#123;</span><br><span class="line">            arr[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    end = clock();</span><br><span class="line">    cpu_time_used = ((<span class="type">double</span>)(end - start)) / CLOCKS_PER_SEC;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 代码执行耗时：%f 秒 \n&quot;</span>, cpu_time_used);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>连续运行三次的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost xxx]# ./a.out</span><br><span class="line">代码执行耗时：0.008293 秒 </span><br><span class="line"> 代码执行耗时：0.002611 秒 </span><br><span class="line">[root@localhost xxx]# ./a.out</span><br><span class="line"> 代码执行耗时：0.008260 秒 </span><br><span class="line"> 代码执行耗时：0.002613 秒 </span><br><span class="line">[root@localhost xxx]# ./a.out</span><br><span class="line"> 代码执行耗时：0.008252 秒 </span><br><span class="line"> 代码执行耗时：0.002575 秒</span><br></pre></td></tr></table></figure>

<h2 id="基本概念"><a href="# 基本概念" class="headerlink" title="基本概念"></a>基本概念 </h2><p> 可以在页式或段式内存管理的基础上实现虚拟内存管理技术。</p>
<ul>
<li>在装入程序时，不必将其全部装入内存，而只需将当前需要执行的部分页面（或段）装入到内存中，就可以让程序开始执行；</li>
<li>一方面，在程序执行过程中，如果需执行的指令或访问的数据尚未在内存中（称为缺页或缺段），则由 CPU 通知操作系统将相应的页面（或段）调入到内存，然后继续执行程序；</li>
<li>另一方面，操作系统将内存中暂时不使用的页面（或段）调出保存在外存上，从而腾出更多空闲内存空间，存放将要装入的程序以及将要调入的页面（或段）。</li>
</ul>
<h2 id="基本特征"><a href="# 基本特征" class="headerlink" title="基本特征"></a>基本特征</h2><ul>
<li><strong>大的用户空间</strong>：通过把物理内存和外存相结合，提供给用户的虚拟内存空间通常大于实际的物理内存，即实现了这两者的分离。<ul>
<li>如 32 位的虚拟地址理论上可以访问 4GB，而可能计算机上仅有 256M 的物理内存，但硬盘容量大于 4GB。</li>
</ul>
</li>
<li><strong>部分交换</strong>：与交换技术相比较，虚拟存储的调入和调出是对部分虚拟地址空间进行的（交换粒度更小，效率更高）。</li>
<li><strong>不连续性</strong>：物理内存分配的不连续性，虚拟地址空间使用的不连续性。</li>
</ul>
<h2 id="页式内存管理"><a href="# 页式内存管理" class="headerlink" title="页式内存管理"></a>页式内存管理 </h2><p> 页表：完成逻辑页到物理页帧的映射。首先，根据页号查找页表对应的索引项；然后，查看该表项对应的 resident bit 的状态，1 表示映射关系存在，确定页帧号；最后，页帧号加上原来的页内偏移，即可获得物理地址。</p>
<blockquote>
<p>resident bit 的值为 0 表示虚拟地址对应的逻辑页当前不在内存中，而是在外存（磁盘）中存储。</p>
</blockquote>
<h2 id="虚拟页式内存管理"><a href="# 虚拟页式内存管理" class="headerlink" title="虚拟页式内存管理"></a>虚拟页式内存管理 </h2><h3 id="实现"><a href="# 实现" class="headerlink" title="实现"></a> 实现 </h3><p> 大部分虚拟存储系统都采用虚拟页式存储管理技术，即在页式存储管理的基础上，增加「请求调页」和「页面置换」两个功能。</p>
<h3 id="基本思路"><a href="# 基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><ul>
<li>当一个用户程序要调入内存运行时，不是将该程序的所有页面都装入内存，而是只装入部分的页面，就可启动程序运行；</li>
<li>在程序运行过程中，如果发现要运行的程序或要访问的数据不在内存中，CPU 将发出缺页的中断请求，操作系统将处理这个中断——将外存中相应的页面调入内存，使得该程序能够继续运行。</li>
</ul>
<blockquote>
<p>页面置换功能实现的好坏决定了整体的效率，后面专门讲这些设计有效的置换算法。</p>
</blockquote>
<h3 id="页表表项"><a href="# 页表表项" class="headerlink" title="页表表项"></a>页表表项 </h3><p> 为了实现「请求调页」和「页面置换」功能，我们需要在页表表项中增加一些位 <code>bit</code> 来辅助实现。</p>
<p>页表表项示意图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">逻辑页号 | 访问位 | 修改位 |   保护位   | 驻留位 | 物理页帧号</span><br></pre></td></tr></table></figure>

<ul>
<li>驻留位：表示该页是在内存中还是在外存中。<ul>
<li>值为 1 表示该页位于内存中，该页表表项有效，物理页帧可以被使用；</li>
<li>值为 0 表示当前页在外存中，访问该页表表项将导致缺页异常。</li>
</ul>
</li>
<li>保护位：表示允许对该页做何种类型的访问，如只读，可读写，可执行等。</li>
<li>修改位：表示此页在内存中是否被修改过。<ul>
<li>当系统回收该物理页面时，根据此位来决定是否把物理页面的内容写回外存。</li>
</ul>
</li>
<li>访问位：如果该页被访问过（包括读写操作），则设置此位。<ul>
<li>用于页面置换算法。</li>
</ul>
</li>
</ul>
<h3 id="缺页中断"><a href="# 缺页中断" class="headerlink" title="缺页中断"></a>缺页中断 </h3><p> 缺页中断处理过程：</p>
<ol start="0">
<li>产生缺页中断；</li>
<li>如果在内存中有空闲的物理页面，则分配一物理页帧 <code>f</code>，然后转第 4 步；否则转到第 2 步；</li>
<li>采用某种页面置换算法，选择一个将被替换的物理页帧 <code>f</code>，它所对应的逻辑页为 <code>q</code>。如果该页在内存期间被修改过，则需要把它写回外存；</li>
<li>对 <code>q</code> 所对应的页表项修改，把驻留位置为 <code>0</code>；</li>
<li>将需要访问的页 <code>p</code> 装入到物理页面 <code>f</code> 当中；</li>
<li>修改 <code>p</code> 所对应的页表项的内容，把驻留位置为 <code>1</code>，把物理页帧号置为 <code>f</code>；</li>
<li>重新运行被中断的指令。</li>
</ol>
<p>缺页中断操作系统处理流程：<br><img src="/images/os-kernel/chapter5/missing-page-interrupt.png" alt="缺页中断操作系统处理" width="60%" height="60%"></p>
<h3 id="后备存储（backing-store）"><a href="# 后备存储（backing-store）" class="headerlink" title="后备存储（backing store）"></a>后备存储（backing store）</h3><p>系统在何处保存未被映射到物理内存中的页呢？</p>
<ul>
<li>能够简单地识别在二级存储器中的页</li>
<li>交换空间（磁盘或者文件）：特殊格式，用于存储未被映射的页面</li>
</ul>
<p>后背存储（二级存储）：一个虚拟地址空间的页面，可以被映射到一个文件（在二级存储中）的某个位置，以便在需要时重新加载到主存储器中。</p>
<p>在操作系统中，不同段可以被映射到不同的文件：</p>
<ul>
<li>代码段：映射到可执行二进制文件；</li>
<li>动态加载的共享库程序段：映射到动态调用的库文件；</li>
<li>其他段：可能被映射到交换文件（swap file）</li>
</ul>
<blockquote>
<p>操作系统中一般会有主存储器（也称为一级存储器或内存）和辅助存储器（如硬盘、SSD 等）两种类型的存储设备。主存储器用于存储当前正在运行的进程和其所需的数据，而辅助存储器用于存储暂时不需要的进程或数据，辅助存储器也称为后背存储或二级存储。</p>
</blockquote>
<h3 id="虚拟内存性能分析"><a href="# 虚拟内存性能分析" class="headerlink" title="虚拟内存性能分析"></a>虚拟内存性能分析 </h3><p> 为了便于理解分页的开销，使用有效存储器访问时间（effective memory access time, EAT）来衡量。</p>
<p>EAT = 访存时间 * 页表命中几率 + page fault 处理时间 * page fault 几率</p>
<p>实例：</p>
<ul>
<li>访问物理内存时间：10 ns</li>
<li>磁盘访问时间：5 ms</li>
<li>参数 p = page fault 几率</li>
<li>参数 q = dirty page 几率</li>
</ul>
<p>则 $EAT = 10 \times (1-p) + 5 \times 10^{6} \times p \times (1+q)$</p>
<p>其中，$1 + q$ 的 $1$ 表示发生 dirty page 后需要将页面写回外存的耗时。</p>
<blockquote>
<p>dirty page 是指在计算机系统中的内存中的一个页面，其中的数据已经被修改，与磁盘上的对应页面的数据不同步。当进程对内存中的页面进行写操作时，该页面会被标记为“脏页”，表示该页面的数据已经被修改但尚未写回到磁盘。在后续的页面调度或内存回写操作中，操作系统会将脏页的数据写回到磁盘，以确保内存中的数据与磁盘上的数据保持一致性。这样可以防止数据丢失或不一致的情况发生。</p>
</blockquote>
<blockquote>
<p>参考资料：<br>1：<a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a><br>2：<a href="https://blog.csdn.net/weixin_53407527/article/details/124983180">https://blog.csdn.net/weixin_53407527/article/details/124983180</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>内存管理技术</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>虚存技术</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter6.1 局部页面置换算法</title>
    <url>/posts/231129182631.html</url>
    <content><![CDATA[<p>本文将介绍页面置换算法中的 <strong> 局部 </strong> 页面置换算法，包括最优页面置换算法（OPT）、先进先出页面置换算法（FIFO）、最近最久使用页面置换算法（LRU）、时钟页面置换算法（Clock）、二次机会页面置换算法（Enhanced Clock）和最不常用页面置换算法（LFU），并介绍了 Belady 现象。</p>
<span id="more"></span>

<h1 id="页面置换算法"><a href="# 页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法 </h1><h2 id="功能与目标"><a href="# 功能与目标" class="headerlink" title="功能与目标"></a> 功能与目标</h2><ul>
<li><p>功能：当缺页中断发生，需要调入新的页面，而内存已满时，选择内存当中哪个物理页面被置换。</p>
</li>
<li><p>目标：尽可能地减少页面的换进换出次数（即缺页中断的次数）。具体来说，把 <strong> 未来 </strong> 不再使用的或短期内较少使用的页面换出，通常只能在局部性原理指导下 <strong> 依据过去的统计数据来进行预测</strong>。</p>
</li>
<li><p>页面锁定（frame locking）：用于描述必须常驻内存的操作系统的关键部分或时间关键（time-critical）的应用进程。</p>
<ul>
<li>实现方法：在页表中添加锁定标记位（lock bit）。</li>
</ul>
</li>
</ul>
<h2 id="实验设置与评价方法"><a href="# 实验设置与评价方法" class="headerlink" title="实验设置与评价方法"></a>实验设置与评价方法 </h2><p> 如何评价一个页面置换算法的优劣？</p>
<p>模拟一个页面置换的行为，并记录产生页缺失的数量。若有更少的缺失，则有更好的性能。</p>
<h1 id="局部页面置换算法"><a href="# 局部页面置换算法" class="headerlink" title="局部页面置换算法"></a>局部页面置换算法 </h1><h2 id="最优页面置换算法（OPT）"><a href="# 最优页面置换算法（OPT）" class="headerlink" title="最优页面置换算法（OPT）"></a> 最优页面置换算法（OPT）</h2><p>基本思路：当一个缺页中断发生时，对于保存在内存当中的每一个逻辑页面，计算在它的下一次访问之前，还需等待多长时间，从中选择等待时间最长的那个，作为被置换的页面。</p>
<p>缺点：这是一种理想情况，在实际系统中是 <strong> 无法实现 </strong> 的，因为操作系统无法知道每一个页面要等待多长时间以后才会再次被访问。</p>
<p>OPT 算法页面置换示例：<br><img src="../images/os-kernel/chapter6/opt-algorithm-demo.png" alt="最优页面置换算法" width="60%" height="60%"></p>
<p>如上图，在 <code>time=0</code> 的初始时刻，内存中有四个物理页 <code>a,b,c,d</code>。在访问到 <code>time=5</code> 时，程序需要访问物理页 <code>e</code>，但它在内存中不存在；从图中可以看到，接下来要访问的物理页分别是 <code>b,a,b,c,d</code>，物理页 <code>d</code> 是将来最长时间才被访问的物理页。所以，在访问物理页 <code>e</code> 时，<strong>最优解 </strong> 是将物理页 <code>d</code> 置换出去。但操作系统无法预知未来，所以这个算法无法实际应用。</p>
<blockquote>
<p>OPT 算法可用作其他算法的性能评价的依据（在一个模拟器上运行某个程序，并记录每一次的页面访问情况，在第二遍运行时即可使用最优算法）。</p>
</blockquote>
<h2 id="先进先出页面置换算法（FIFO）"><a href="# 先进先出页面置换算法（FIFO）" class="headerlink" title="先进先出页面置换算法（FIFO）"></a>先进先出页面置换算法（FIFO）</h2><p>基本思路：选择在内存中驻留时间最长的页面淘汰。具体来说，系统维护着一个链表，记录了所有位于内存中的逻辑页面。从链表的排列顺序来看，链首页面的驻留时间最长，链尾页面的驻留时间最短。<strong>当发生一个缺页中断时，把链首页面淘汰出去，并把新的页面添加到链表的末尾</strong>。</p>
<blockquote>
<p>如果访问一个页面时，没有产生缺页中断，这时链表会有何动作？<br>会遍历链表，找出对应的逻辑页面，将它从链表内部删除，并添加在链表尾部（让该页面刷新为驻留时间最短的页面）。</p>
</blockquote>
<p>缺点：涉及到链表遍历，性能较差，置换出的页面有可能是经常要访问的页面，并且有 Belady 现象。FIFO 算法很少单独使用。</p>
<p>FIFO 算法页面置换示例（初始时，假设链表首部为页面 <code>a</code>，尾部为页面 <code>d</code>）：<br><img src="../images/os-kernel/chapter6/fifo-algorithm-demo.png" alt="先进先出页面置换算法" width="60%" height="60%"></p>
<h2 id="最近最久使用页面置换算法（LRU）"><a href="# 最近最久使用页面置换算法（LRU）" class="headerlink" title="最近最久使用页面置换算法（LRU）"></a>最近最久使用页面置换算法（LRU）</h2><p>基本思路：最近最久使用页面置换算法（Least Recently Used, LRU），当一个缺页中断发生时，选择 <strong> 最近最久未使用 </strong> 的那个页面淘汰。</p>
<p>LRU 算法是对 OPT 算法的 <strong> 一个近似</strong>，其依据是程序的局部性原理，即在最近一小段时间（最近几条指令）内，如果某些页面被频繁地访问，那么在将来的一小段时间内，它们还可能会再一次被频繁地访问。反过来说，如果过去某些页面长时间未被访问，那么在将来它们可能会继续得不到访问。</p>
<p>LRU 算法页面置换示例：<br><img src="../images/os-kernel/chapter6/lru-algorithm-demo.png" alt="最近最久使用页面置换算法" width="60%" height="60%"></p>
<blockquote>
<p>LRU 算法需要记录各个页面使用时间的先后顺序，开销比较大。</p>
</blockquote>
<p>该算法两种可能的实现方法是：</p>
<ol>
<li><p>系统维护一个页面链表，最新使用过的页面作为首结点，最久未使用的作为尾结点。</p>
<ul>
<li>每一次访问内存时，找出相应的页面，把它从链表中摘下来，再移动到链表的首部；</li>
<li>每次缺页中断发生时，总是淘汰链表末尾的页面，它就是最久未使用的。</li>
</ul>
</li>
<li><p>设置一个活动页面栈，栈顶存储最新使用过的页面的页号，栈底存储最久未使用过的页面的页号。</p>
<ul>
<li>当访问某页时，将此页号压入栈顶，并考察栈内是否有与此页面相同的页号，若有则抽出</li>
<li>每次缺页中断发生时，总是淘汰栈底的页面，它就是最久未使用的。</li>
</ul>
</li>
</ol>
<blockquote>
<p>这两种实现在查找某一个页面是否在链表（或栈）中时，都是线性时间复杂度，效率低。<a href="https://pursue26.github.io/posts/231201184542.html">LeetCode 刷题之 146LRU 缓存 </a> 中给出了一种常数时间复杂度的设计，它使用了双向链表 + 哈希表来实现。</p>
</blockquote>
<h2 id="时钟页面置换算法（Clock）"><a href="# 时钟页面置换算法（Clock）" class="headerlink" title="时钟页面置换算法（Clock）"></a>时钟页面置换算法（Clock）</h2><blockquote>
<p>Clock 算法是对 LRU 算法的近似，对 FIFO 算法的一种改进。</p>
</blockquote>
<p>基本思想：借助页表项的访问位（access bit），当一个页面被装入内存时，把该位重置为 <code>0</code>，如果这个页面后续被访问（读 / 写操作），则硬件（软件也能置位）把该位置为 <code>1</code>。</p>
<p>在设计上，把各个页面组织成 <strong> 环形链表（类似钟的表面）</strong>，把指针指向最老（最先进来）的页面。当发生缺页中断时，考察指针所指向的最老页面：</p>
<ul>
<li>若它的访问位为 <code>0</code>，则可以立即淘汰；<ul>
<li>解释：也就是在内存中，但没有被访问过。</li>
</ul>
</li>
<li>若访问位为 <code>1</code>，则将访问位置为 <code>0</code>，然后指针往下移动一格；<ul>
<li>解释：它是最老的页面，但是被访问过，那就先不淘汰它，如果后续没有未访问过的页面的话，则指针会转一圈再回来，并把它淘汰。</li>
</ul>
</li>
<li>如此下去，直到找到被淘汰的页面，然后把指针移动到下一格。</li>
</ul>
<p>Clock 算法页面置换示意图（used bit 即 access bit）：<br><img src="../images/os-kernel/chapter6/clock-algorithm.png" alt="时钟页面置换算法" width="60%" height="60%"></p>
<p>在上图中，维持一个保存在内存中环形页面链表。初始时，假设 resident bit 都为 1，也就是虚拟页对应的物理页面存在；图中指针顺时针移动，下次将被替换的页面为 Page 1。</p>
<p>Clock 算法页面置换示例：<br><img src="../images/os-kernel/chapter6/clock-algorithm-demo.png" alt="时钟页面置换算法" width="60%" height="60%"></p>
<blockquote>
<p>上图的置换流程可以参考上面的文字和伪代码。</p>
</blockquote>
<h2 id="改进型的时钟页面置换算法（Enhanced-Clock）"><a href="# 改进型的时钟页面置换算法（Enhanced-Clock）" class="headerlink" title="改进型的时钟页面置换算法（Enhanced Clock）"></a>改进型的时钟页面置换算法（Enhanced Clock）</h2><p>改进型的时钟页面置换算法，又可称为二次机会算法。</p>
<p>改进原因：因为考虑到时钟页面置换算法，有时候会把一些 dirty bit 为 1（有过写操作）的页面进行置换，这需要把页面写回外存中（而非直接释放），代价会比较大。因此，可以结合 access bit 和 dirty bit，共同决定应该置换哪一页。</p>
<p>换句话说，当页面替换时，可以按照如下的优先级规则进行：</p>
<table>
<thead>
<tr>
<th align="center">优先级</th>
<th align="center">access</th>
<th align="center">dirty</th>
<th align="center">替换次数</th>
<th align="center">置位结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">直接替换</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">一次机会</td>
<td align="center">(0, 0)</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">一次机会</td>
<td align="center">(0, 0)</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">两次机会</td>
<td align="center">(0, 1)</td>
</tr>
</tbody></table>
<p>根据这个优先级规则，替换时会优先选择优先级较低的页面进行替换，以提高缓存的命中率。</p>
<blockquote>
<p>两次机会时，优先重置 access bit 位。</p>
</blockquote>
<p>改进型 Clock 算法页面置换示例：<br><img src="../images/os-kernel/chapter6/enhanced-clock-algorithm-demo.png" alt="改进型时钟页面置换算法" width="60%" height="60%"></p>
<p>在上图中，当 <code>time=4</code> 时刻结束时，内存的 4 个页面均被访问，但是仅有页面 <code>a</code> 和页面 <code>b</code> 被写过，在 <code>time=5</code> 时，根据上述优先级规则，页面 <code>a</code> 和页面 <code>b</code> 有两次机会，页面 <code>c</code> 和页面 <code>d</code> 有一次机会，最后指针会指向页面 <code>c</code> 进行置换，然后指针往下移动一格。</p>
<blockquote>
<p>弹幕中看到大家的两个问题，这个给机会的过程，会将 dirty bit 从 1 重置为 0，那么：<br>1）被写过的页面，是什么时候写回外存中去的？是每次从 1 重置为 0 后，就随即写回外存，还是最后被置时才会写回外存（如果是这种，其它重置为 0 的页面，还怎么知道它有没有被写过）？<br>2）这里的 access bit 和 dirty bit 的修改是否是直接修改的页表中对应的位？</p>
</blockquote>
<h2 id="最不常用页面置换算法（LFU）"><a href="# 最不常用页面置换算法（LFU）" class="headerlink" title="最不常用页面置换算法（LFU）"></a>最不常用页面置换算法（LFU）</h2><p>基本思路：最不常用页面置换算法（Least Frequently used, LFU），当一个缺页中断发生时，选择 <strong> 访问次数最少 </strong> 的那个页面，并淘汰。</p>
<p>实现方法：对每一个页面设置一个访问计数器，每当一个页面被访问时，该页面的访问计数器加 1。 当发生缺页中断时，淘汰计数值最小的那个页面。</p>
<p>LRU 和 LFU 的对比：LRU 考察的是 <strong> 多久未访问 </strong>，时间越短越好（不会被置换出去）；而 LFU 考察的是<strong> 访问的次数或频度</strong>，访问次数越多越好。</p>
<p>LFU 算法页面置换示例：<br><img src="../images/os-kernel/chapter6/lfu-algorithm-demo.png" alt="最不常用页面置换算法" width="60%" height="60%"></p>
<blockquote>
<p>问题：<br>一个页面在进程开始时使用得很多，但以后就不使用了，LFU 统计的是整体的访问次数，所以此时这个页面还会被保留在内存中。<br>实现也费时费力，需要对每一个页面加一个计数器。</p>
<p>解决方法：<br>定期把次数寄存器右移一位。它最主要的问题是只考虑频率而没考虑时间，我们可以隔一段时间砍掉一半的次数，进而改善这个问题。</p>
</blockquote>
<h2 id="Belady 现象"><a href="#Belady 现象" class="headerlink" title="Belady 现象"></a>Belady 现象 </h2><p> 在采用 FIFO 算法时，有时会出现在分配的物理页面数增加，缺页率反而提高的异常现象。</p>
<p>原因：FIFO 算法的置换特征与进程访问内存的动态特征是矛盾的，它仅仅按照页面进入内存的顺序进行替换，与置换算法的目标（即替换较少使用的页面）是不一致的，因此，被它置换出去的页面不一定是进程不会访问的。</p>
<blockquote>
<p>Belady 是一个科学家的名字。</p>
</blockquote>
<p>时钟、改进型的时钟页面置换是否有 Belady 现象？</p>
<ul>
<li>没有。</li>
</ul>
<p>为什么 LRU 页面置换算法没有 Belady 现象？</p>
<ul>
<li>简单解释：LRU 符合一类叫称之为「栈算法」的特点。</li>
</ul>
<h1 id="总结与比较"><a href="# 总结与比较" class="headerlink" title="总结与比较"></a>总结与比较 </h1><h2 id="局部页面算法汇总"><a href="# 局部页面算法汇总" class="headerlink" title="局部页面算法汇总"></a> 局部页面算法汇总</h2><table>
<thead>
<tr>
<th>算法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>最优页面置换算法 (OPT)</td>
<td>选择未来最长时间内不再被访问的页面进行置换。</td>
</tr>
<tr>
<td>先进先出页面置换算法 (FIFO)</td>
<td>最早进入内存的页面被置换出去。</td>
</tr>
<tr>
<td>最近最久未使用页面置换算法 (LRU)</td>
<td>根据页面最近被访问的时间进行置换，最久未被使用的页面被置换出去。</td>
</tr>
<tr>
<td>时钟页面置换算法 (Clock)</td>
<td>使用一个指针按顺序扫描页面，如果找到一个未被使用的页面，则置换出去；否则，将指针指向的页面标记为未使用。</td>
</tr>
<tr>
<td>二次机会页面置换算法 (Second-Chance)</td>
<td>类似于时钟算法，但是给予页面第二次机会，如果页面被访问或被写入过，则将其标记为未访问或未被写入，否则置换出去。</td>
</tr>
<tr>
<td>最不常用页面置换算法 (LFU)</td>
<td>根据页面被访问的频率进行置换，最不常被使用的页面被置换出去。</td>
</tr>
</tbody></table>
<h2 id="LRU、FIFO 和 Clock 比较"><a href="#LRU、FIFO 和 Clock 比较" class="headerlink" title="LRU、FIFO 和 Clock 比较"></a>LRU、FIFO 和 Clock 比较</h2><table>
<thead>
<tr>
<th align="center">算法</th>
<th>原理</th>
<th>性能</th>
<th>开销</th>
</tr>
</thead>
<tbody><tr>
<td align="center">LRU</td>
<td>根据最近访问时间排序页面，动态调整页面顺序</td>
<td>性能较好</td>
<td>系统开销较大</td>
</tr>
<tr>
<td align="center">FIFO</td>
<td>根据进入时间排序页面，顺序固定不变</td>
<td>可发生 Belady 现象</td>
<td>开销较小</td>
</tr>
<tr>
<td align="center">Clock</td>
<td>不动态调整页面顺序，仅做标记，缺页时移动到链表末尾</td>
<td>性能适中</td>
<td>系统开销适中</td>
</tr>
</tbody></table>
<ul>
<li>LRU 算法可退化为 FIFO 算法。</li>
<li>Clock 算法是对 LRU 算法和 FIFO 算法的折中，不能记录精确访问顺序，可退化为 FIFO 算法。</li>
</ul>
<p>从算法的退化可以看出，不同的算法只是页面替换的一个环节，<strong>如果要有效减少缺页产生的次数，除了算法本身之外，我们还要对访问序列有一定的要求，访问序列最好是具有局部性的访问特征</strong>，那么 LRU、Clock 算法才会发挥特征，如果序列不具有局部性，那么 LRU、Clock、FIFO 就没什么区别了。</p>
<blockquote>
<p>参考资料：<br>1：<a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a><br>2：<a href="https://blog.csdn.net/weixin_53407527/article/details/125008097">https://blog.csdn.net/weixin_53407527/article/details/125008097</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>局部页面置换算法</category>
      </categories>
      <tags>
        <tag>页面置换算法</tag>
        <tag>操作系统</tag>
        <tag>局部页面置换算法</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter6.2 全局页面置换算法</title>
    <url>/posts/231207184239.html</url>
    <content><![CDATA[<p>本文将介绍页面置换算法中的 <strong> 全局 </strong> 页面置换算法。首先，介绍了局部页面置换算法的局限性；然后，介绍了工作集模型和工作集、常驻集；最后，介绍了两个全局页面置换算法——工作集页面置换算法和缺页率页面置换算法。</p>
<span id="more"></span>

<h1 id="局部置换算法的问题"><a href="# 局部置换算法的问题" class="headerlink" title="局部置换算法的问题"></a>局部置换算法的问题 </h1><h2 id="物理页帧分配角度"><a href="# 物理页帧分配角度" class="headerlink" title="物理页帧分配角度"></a> 物理页帧分配角度 </h2><p> 假设一：<br>给一个程序分配了一个大小固定为 3 的物理页帧（如 <code>a, b, c</code>），而现在程序 A 需要访问 <code>a, b, c, d, a, b, c, d, ...</code> 的物理页帧。那么，在使用 FIFO 页面置换算法的情况下，从时刻 4（第一次访问 <code>d</code>）开始，每一次访问都会产生一个缺页中断。</p>
<p>假设二：<br>给一个程序分配了一个大小固定为 4 的物理页帧（如 <code>a, b, c, b</code>），而现在程序 B 需要访问 <code>a, b, c, d, a, b, c, d, ...</code> 的物理页帧。那么，在使用 FIFO 页面置换算法的情况下，不会产生缺页中断。</p>
<p>由此可以看出：<strong>物理页帧的大小确实会对同一个页面置换算法的效果产生很大影响</strong>。这说明，如果对一个程序分配固定的物理页帧、使用指定页面置换算法，其实在某种程度上限制了程序产生缺页的灵活性。</p>
<h2 id="程序内存访问角度"><a href="# 程序内存访问角度" class="headerlink" title="程序内存访问角度"></a>程序内存访问角度 </h2><p> 因为程序在运行过程中可能会有阶段性，它可能一开始访问需要很多内存，中间时候需要很少，结束的时候又需要很多，它是 <strong> 动态变化 </strong> 的过程，它 <strong> 对物理页帧的需求是可变的</strong>。</p>
<p>在局部页面置换算法中，都是假定物理页帧是固定的，如果一个系统只跑这一个程序，那我可以把所有物理页帧都分给它；而操作系统可以跑多个程序，这时再给每个程序分配固定的页帧，其实就限制了灵活性，我们能不能根据程序的不同阶段给它动态分配，调整它物理页帧的大小，这实际上就是全局页面置换算法所考虑的问题。</p>
<h2 id="全局 -Vs- 局部"><a href="# 全局 -Vs- 局部" class="headerlink" title="全局 Vs. 局部"></a>全局 Vs. 局部</h2><table>
<thead>
<tr>
<th>算法</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>局部置换算法</td>
<td>- 不考虑进程的访存差异<br>- 固定分配物理页帧，限制了程序的灵活性<br>- 适用于单个程序运行的情况</td>
</tr>
<tr>
<td>全局置换算法</td>
<td>- 考虑进程的访存差异<br>- 动态调整物理页帧的大小，根据程序的不同阶段进行分配<br>- 适用于多个程序运行的情况</td>
</tr>
</tbody></table>
<h1 id="全局置换算法要解决的问题"><a href="# 全局置换算法要解决的问题" class="headerlink" title="全局置换算法要解决的问题"></a>全局置换算法要解决的问题 </h1><p> 进程在不同阶段的内存需求是变化的，这句需要解决以下问题：</p>
<ul>
<li>分配给进程的内存也需要在不同阶段有所变化；</li>
<li>全局置换算法需要确定分配给进程的物理页面数；</li>
</ul>
<h1 id="工作集与常驻集"><a href="# 工作集与常驻集" class="headerlink" title="工作集与常驻集"></a>工作集与常驻集 </h1><h2 id="工作集模型"><a href="# 工作集模型" class="headerlink" title="工作集模型"></a> 工作集模型 </h2><p> 前面介绍的各种局部页面置换算法，都是基于一个前提，即 <strong> 程序的局部性原理</strong>。但是此原理是否成立？</p>
<ul>
<li>如果局部性原理不成立，那么各种页面置换算法就没有什么分别，也没有什么意义。例如：假设进程对逻辑页面的访问顺序是 <code>1,2,3,4,5,6,6,7,8,9,...</code>，即单调递增，那么在物理页面数量有限的前提下，不管采用何种置换算法，每次的页面访问都必然导致缺页中断。</li>
<li><strong>如果局部性原理是成立的，那么如何来证明它的存在，如何来对它进行定量地分析？这就是工作集模型</strong>！</li>
</ul>
<h2 id="工作集"><a href="# 工作集" class="headerlink" title="工作集"></a>工作集 </h2><h3 id="什么是工作集"><a href="# 什么是工作集" class="headerlink" title="什么是工作集"></a> 什么是工作集 </h3><p> 工作集：一个进程当前（过去一段时间内）正在使用的逻辑页面集合，可表示为二元函数 $W(t, \Delta)$。</p>
<ul>
<li>$t$ 是当前的执行时刻；</li>
<li>$\Delta$ 称为工作集窗口（working-set window），即一个定长的页面访问时间窗口；</li>
<li>$W(t, \Delta)$ 是指 <strong> 在当前时刻 $t$ 前的 $\Delta$ 时间窗口中的所有访问页面所组成的集合</strong>；</li>
<li>$|W(t, \Delta)|$ 指工作集的大小，即页面数目。</li>
</ul>
<h3 id="工作集示例"><a href="# 工作集示例" class="headerlink" title="工作集示例"></a>工作集示例 </h3><p> 假设一个进程有如下的页面访问顺序，工作集窗为 $\Delta = 10$：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 6 1 5 7 7 7 7 5 1 6 3 4 4 4 3 4 3 4 4 4 1 3 2 7</span><br><span class="line">                   |                     |</span><br><span class="line">&lt;---- Delta ----&gt; t1  &lt;---- Delta ----&gt; t2</span><br></pre></td></tr></table></figure>

<ul>
<li>在 $t_{1}$ 时刻的工作集为：$W(t_{1}, \Delta) = \{1,2,5,6,7\}$。</li>
<li>在 $t_{2}$ 时刻的工作集为：$W(t_{2}, \Delta) = \{3,4\}$。</li>
</ul>
<h3 id="工作集访问与程序访问的关联"><a href="# 工作集访问与程序访问的关联" class="headerlink" title="工作集访问与程序访问的关联"></a>工作集访问与程序访问的关联</h3><ul>
<li>工作集大小的变化：进程开始执行后，随着访问新页面逐步建立较稳定的工作集。</li>
<li><strong>当内存访问的局部性区域的位置大致稳定时，工作集大小也大致稳定</strong>。</li>
<li><strong>局部性区域的位置改变时，工作集快速扩张和收缩，并过渡到下一个稳定值</strong>。</li>
</ul>
<img src="/images/os-kernel/chapter6/working-set.png" alt="工作集变化曲线" width="60%" height="60%">

<h2 id="常驻集"><a href="# 常驻集" class="headerlink" title="常驻集"></a>常驻集 </h2><p> 常驻集：在当前时刻（那一瞬间），进程实际驻留在内存当中的页面集合。</p>
<p>工作集与常驻集的关系：</p>
<ul>
<li>工作集是进程在运行过程中固有的性质。</li>
<li>常驻集取决于系统分配给进程的物理页面数目和页面置换算法。</li>
</ul>
<p>缺页率与工作集、常驻集的关系：</p>
<ul>
<li>常驻集 $\supseteq$ 工作集时，即一个进程的整个工作集都在内存当中时，缺页较少；</li>
<li>工作集发生剧烈变动（过渡）时，缺页较多；</li>
<li>进程常驻集大小达到一定数目后，再给它分配更多的物理页面，缺页率也不会明显下降。</li>
</ul>
<h1 id="全局页面置换算法"><a href="# 全局页面置换算法" class="headerlink" title="全局页面置换算法"></a>全局页面置换算法 </h1><h2 id="工作集页面置换算法（Working-set）"><a href="# 工作集页面置换算法（Working-set）" class="headerlink" title="工作集页面置换算法（Working-set）"></a> 工作集页面置换算法（Working-set）</h2><h3 id="思路与实现"><a href="# 思路与实现" class="headerlink" title="思路与实现"></a>思路与实现 </h3><p><strong> 思路</strong>：在每次的内存访问时，换出不在工作集中的页面。</p>
<p><strong>窗口大小</strong>：当前时刻前 $\Delta$ 个内存访问的页引用是工作集，$\Delta$ 被称为窗口大小。</p>
<p><strong>实现方式</strong>：</p>
<ul>
<li>访存链表：维护工作集窗口内的访存页面链表。<ul>
<li>在访存时，换出不在工作集的页面，更新访存链表；</li>
<li>在缺页时，换入页面，更新访存链表</li>
</ul>
</li>
</ul>
<h3 id="示例"><a href="# 示例" class="headerlink" title="示例"></a>示例 </h3><p> 工作集页面置换算法示例：<br><img src="/images/os-kernel/chapter6/working-set-algorithm-demo.png" alt="工作集页面置换算法示例" width="60%" height="60%"></p>
<p>上图中，在时刻 0，程序已经访问了内存中的 <code>e, d, a</code> 三个物理页面，假设 $\Delta = 4$，此时的工作集为 <code>&#123;e, d, a&#125;</code>：</p>
<ul>
<li>在时刻 1，访存 <code>c</code> 不在工作集中，产生缺页中断，换入页面 <code>c</code>，工作集更新为 <code>&#123;e, d, a, c&#125;</code>；</li>
<li>在时刻 2，访存 <code>c</code> 在工作集中，工作集更新为 <code>&#123;d, a, c&#125;</code>；</li>
<li>在时刻 3，访存 <code>d</code> 在工作集中，工作集更新为 <code>&#123;a, c, d&#125;</code>；</li>
<li>在时刻 4，访存 <code>b</code> 不在工作集中，产生缺页中断，换入页面 <code>b</code>，工作集更新为 <code>&#123;c, d, b&#125;</code>；</li>
<li>…</li>
</ul>
<p>可以看出：</p>
<ul>
<li>在工作集窗口在滑动过程中，如果页面不再在工作集的窗口范围内，则会直接淘汰这个窗口，而 <strong> 不会等待缺页中断再淘汰</strong>。</li>
<li>在缺页时，会换入页面，但是更新后的工作集的页面，除了新增的换入页面外，工作集中的页面不一定会改变（因为可能换出了页面 X，但窗口内还有页面 X）。</li>
</ul>
<h3 id="特点"><a href="# 特点" class="headerlink" title="特点"></a>特点 </h3><p> 工作集页面置换算法在当前物理内存中放哪些页，取决于是否在工作集窗口之内。这样可以确保在物理内存中始终有足够多的页存在，以便为其他运行程序提供更多的内存空间，进一步减少页面置换的次数。通过减少页面置换次数，可以降低多个程序的缺页数，<strong>提高系统的整体性能</strong>。</p>
<h2 id="缺页率页面置换算法（PFF）"><a href="# 缺页率页面置换算法（PFF）" class="headerlink" title="缺页率页面置换算法（PFF）"></a>缺页率页面置换算法（PFF）</h2><h3 id="思路与影响因素"><a href="# 思路与影响因素" class="headerlink" title="思路与影响因素"></a>思路与影响因素 </h3><p><strong> 可变分配策略：常驻集大小可变</strong>。例如：每个进程在刚开始运行的时候，先根据程序大小给它分配一定数目的物理页面，然后在进程运行过程中，再动态地调整常驻集的大小。</p>
<ul>
<li>可 <strong> 采用全局页面置换的方式</strong>，当发生一个缺页中断时，被置换出的页面可以是其他进程中的页面，各个并发进程竞争地使用物理页面。</li>
<li>优缺点：性能较好，但增加了系统开销。</li>
<li>具体实现：可以 <strong> 使用缺页率算法（PFF，page fault frequency）来动态调整常驻集的大小</strong>。</li>
</ul>
<p><strong>缺页率（page fault rate）</strong>：表示「缺页次数 / 内存访问次数」或 「缺页平均时间间隔的倒数」。</p>
<p>缺页率置换算法通过动态调整常驻集大小，使每个进程的缺页率保持在一个合理的范围内。</p>
<ul>
<li>若进程缺页率过高，则增加常驻集以分配更多的物理页面；</li>
<li>若进程缺页率过低，则减少常驻集以减少它的物理页面数。</li>
</ul>
<p><strong>影响缺页率的因素</strong>：</p>
<ul>
<li>页面置换算法</li>
<li>分配给进程的物理页面数目</li>
<li>页面本身的大小</li>
<li>程序的编写方法</li>
</ul>
<h3 id="实现与示例"><a href="# 实现与示例" class="headerlink" title="实现与示例"></a>实现与示例 </h3><p><strong> 算法实现</strong>：保持追踪缺失发生概率，设预定的缺页时间阈值为 $T$。</p>
<ul>
<li>访存时，设置引用位（access bit）标志；</li>
<li>缺页时，计算从上次缺页时间 $t_{last}$ 到现在 $t_{current}$ 的时间间隔：<ul>
<li>如果发生页缺失之间的时间是「大」的，之后减少常驻集。<ul>
<li>$t_{current}-t_{last}&gt; T$，则置换出所有在 $[t_{last}, t_{current}]$ 时间内没有被引用的页，并增加缺失页到常驻集中。换句话说，就是只保留在 $[t_{last}, t_{current}]$ 时间内被引用的页面。</li>
</ul>
</li>
<li>如果这个发生页缺失的时间是「小」的，之后增加常驻集。<ul>
<li>$t_{current}-t_{last}\leqslant T$，则增加缺失页到常驻集中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/images/os-kernel/chapter6/pff-algorithm-demo.png" alt="缺页率页面置换算法示例" width="60%" height="60%">

<p>在上图中，时刻 <code>0</code> 的常驻集为 <code>&#123;a, d, e&#125;</code>：</p>
<ul>
<li>在时刻 <code>1</code> 时，页面 <code>c</code> 不在常驻集中，且为首次发生缺页，则增加缺失页到常驻集中，当前的常驻集为 <code>&#123;a, c, d, e&#125;</code>；</li>
<li>在时刻 <code>2, 3</code> 时，页面 <code>c, d</code> 都在常驻集中，没有发生缺页，当前的常驻集为 <code>&#123;a, c, d, e&#125;</code>；</li>
<li>在时刻 <code>4</code> 时，页面 <code>b</code> 不在常驻集中，发生缺页，且 $t_{current}-t_{last} = 4 - 1 &gt; T$，则增加缺失页到常驻集中、只保留在 $[1, 4]$ 之间被引用的页面，当前的常驻集 <code>&#123;c, d, b&#125;</code>；</li>
<li>…</li>
</ul>
<blockquote>
<p>我个人觉得图片中的「工作集」应该是「常驻集」，所以文字描述中，也叙述成了「常驻集」。</p>
</blockquote>
<h1 id="内存抖动问题（thrashing）"><a href="# 内存抖动问题（thrashing）" class="headerlink" title="内存抖动问题（thrashing）"></a>内存抖动问题（thrashing）</h1><p><strong>什么是内存抖动 </strong>？<br> 如果分配给一个进程的物理页面太少，不能包含整个的工作集，即常驻集 $\subset$ 工作集。那么，进程将会造成很多的缺页中断，需要频繁的在内存与外存之间替换页面，从而使进程的运行速度变得很慢，我们把这种状态称为「抖动」。</p>
<p><strong>产生抖动的原因 </strong>？<br> 进程过多：随着驻留内存的进程数目增加，分配给每个进程的物理页面数不断就减小，缺页率不断上升，从而产生抖动。</p>
<p><strong>内存抖动为什么会导致系统性能下降 </strong>？<br> 内存抖动导致系统性能下降的原因是因为频繁的页面置换会引起磁盘 I/O 的开销，这是一个相对较慢的操作。此外，频繁的页面置换还会导致 CPU 时间被浪费在页面置换和上下文切换上，从而降低了系统的吞吐量。</p>
<p><strong>如何改善内存抖动 </strong>？<br> 操作系统需要在并发水平和缺页率之间达到一个平衡，这需要调整进程的内存分配策略：选择一个恰当的并发进程数量，并为每个进程分配恰当的物理页面数（可以使用动态页面分配算法，根据进程的实时需求动态调整页面的分配情况）。</p>
<blockquote>
<p>参考资料：<br>1：<a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a><br>2：<a href="https://blog.csdn.net/weixin_53407527/article/details/125008097">https://blog.csdn.net/weixin_53407527/article/details/125008097</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>全局页面置换算法</category>
      </categories>
      <tags>
        <tag>页面置换算法</tag>
        <tag>操作系统</tag>
        <tag>全局页面置换算法</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter7.1 进程描述</title>
    <url>/posts/231207204958.html</url>
    <content><![CDATA[<p>进程是一个具有一定独立功能的 <strong> 程序 </strong> 在一个 <strong> 数据集合 </strong> 上的 <strong> 一次动态执行 </strong> 过程（进程 = 程序 + 数据 + 动态执行）。一个进程包含了程序代码、相关数据以及进程控制块等信息。程序代码定义了进程要执行的操作，数据则是程序在运行过程中使用的变量、数据结构等。动态执行指的是进程在计算机系统中被调度并执行的过程。</p>
<p>本文是进程与线程的第一部分，主要介绍进程的静态部分，包括进程的定义、组成、特点和进程控制结构等。</p>
<span id="more"></span>

<h1 id="进程描述"><a href="# 进程描述" class="headerlink" title="进程描述"></a>进程描述 </h1><h2 id="进程的定义"><a href="# 进程的定义" class="headerlink" title="进程的定义"></a> 进程的定义 </h2><p> 进程（process）是一个具有一定独立功能的 <strong> 程序 </strong> 在一个 <strong> 数据集合 </strong> 上的 <strong> 一次动态执行 </strong> 过程。</p>
<blockquote>
<p>保存在磁盘中的静态程序代码文件，通过编译、链接转换成可执行文件，然后被加载到内存中执行，称为一个进程，进行实际的执行操作。</p>
</blockquote>
<h2 id="进程的组成"><a href="# 进程的组成" class="headerlink" title="进程的组成"></a>进程的组成 </h2><p><strong> 一个进程包括</strong>：</p>
<ul>
<li>程序的代码；</li>
<li>程序处理的数据；</li>
<li>程序计数器中的值：用于指示下一条将要运行的指令；</li>
<li>一组通用的寄存器的当前值：用于存储临时数据和中间结果，包括通用寄存器、状态寄存器等。</li>
<li>堆和栈：堆用于动态分配内存，存储动态创建的对象和数据结构；栈用于存储函数调用和局部变量等。</li>
<li>一组系统资源（如打开的文件、网络连接）</li>
</ul>
<p>总之，进程包含了正在运行的一个程序的所有状态信息。</p>
<p><strong>进程和程序的联系</strong>：</p>
<ul>
<li>程序是产生进程的基础；</li>
<li>程序的每次运行构成不同的进程；</li>
<li>进程是程序功能的体现；</li>
<li>通过多次执行，一个程序可以对应多个进程；通过调用关系，一个进程可以包括多个程序。</li>
</ul>
<p><strong>进程和程序的区别</strong>：</p>
<ul>
<li>进程是动态的、程序是静态的。<ul>
<li>程序是有序代码的集合，进程是程序的执行，进程有核心态（如打开文件是通过系统调用，由操作系统在内核态处理的）、用户态。</li>
</ul>
</li>
<li>进程是暂时的、程序是永久的。<ul>
<li>进程是一个状态变化的过程，程序可以长久保存。</li>
</ul>
</li>
<li>进程和程序的组成不同：进程的组成包括程序、数据和进程控制块（进程状态信息）。</li>
</ul>
<h2 id="进程的特点"><a href="# 进程的特点" class="headerlink" title="进程的特点"></a>进程的特点</h2><ul>
<li><strong>动态性</strong>：可动态地创建和结束进程；</li>
<li><strong>并发性</strong>：进程可以被独立调度并占用 CPU 运行；<ul>
<li>并发：多个进程在一段时间内交替执行。</li>
<li>并行：在某一时刻，多个进程在同时执行（并行仅在多核设备上才支持）。</li>
</ul>
</li>
<li><strong>独立性</strong>：不同进程的工作不相互影响；<ul>
<li>内存管理中的页表是保障措施之一（每个进程都有自己的页表，不会访问到对方的页表的地址空间）。</li>
</ul>
</li>
<li><strong>制约性</strong>：因访问共享数据或资源，或进程间同步而产生制约。<ul>
<li>这可能会导致资源竞争或数据不一致等问题，因此需要采取相应的措施来解决制约问题，如使用互斥锁、信号量等机制来进行进程间的同步与通信。</li>
</ul>
</li>
</ul>
<blockquote>
<p>老师抛出了一个问题：如果你要设计一个 OS, 怎么样来实现其中的进程管理机制？</p>
</blockquote>
<h2 id="进程控制块（PCB）"><a href="# 进程控制块（PCB）" class="headerlink" title="进程控制块（PCB）"></a>进程控制块（PCB）</h2><h3 id="PCB 概述"><a href="#PCB 概述" class="headerlink" title="PCB 概述"></a>PCB 概述 </h3><p><strong> 计算机中有那么多进程，那这些进程是如何被操作系统管理起来的呢</strong>？</p>
<p>进程控制块 （Process Control Block, PCB）：操作系统中用于管理和维护进程的 <strong> 数据结构</strong>。</p>
<p>每个进程在操作系统中都有一个对应的 PCB，它包含了进程的各种属性和状态信息。换句话说，操作系统用 PCB 来描述进程的基本情况以及运行变化的过程。PCB 是进程存在的唯一标志。</p>
<p><strong>使用 PCB</strong>：</p>
<ul>
<li>进程的创建：为该进程生成一个 PCB；</li>
<li>进程的终止：回收它的 PCB；</li>
<li>进程的组织管理：通过对 PCB 的组织管理来实现。</li>
</ul>
<p><strong>PCB 三大类信息</strong>：</p>
<ol>
<li><p>进程标志信息：包括进程标志（Process ID）、产生者标志（Parent Process ID）和用户标志（User ID）。这些信息用于唯一标识进程、记录父进程和标识进程所属的用户。</p>
</li>
<li><p>CPU 状态信息保存区：保存了进程的运行现场信息，包括用户可见寄存器（用于用户程序的数据、地址等寄存器）、控制和状态寄存器（如程序计数器 PC、程序状态字 PSW）以及栈指针（用于过程调用、系统调用、中断处理和返回时的栈操作）。</p>
</li>
<li><p>进程控制信息：包括调度和状态信息（用于操作系统调度和占用 CPU 资源）、进程间通信信息（用于支持进程间通信的标志、信号、信件等）、存储管理信息（包含指向进程映像存储空间的数据结构）、进程所用资源（说明进程打开、使用的系统资源，如打开的文件等）以及有关数据结构的链接信息（用于连接到进程队列或其他相关进程的 PCB）。</p>
</li>
</ol>
<p><strong>PCB 的组织方式</strong>：</p>
<p><strong>多个进程的 PCB 是如何被操作系统有效地管理的呢</strong>？</p>
<p>链表：<strong>同一状态 </strong> 的进程其 PCB 构成 <strong> 一个 </strong> 链表，<strong>多个状态 </strong> 对应 <strong> 多个不同 </strong> 的链表。</p>
<ul>
<li>各状态的进程形成不同的链表：就绪链表、阻塞链表。</li>
</ul>
<p>索引表：<strong>同一状态 </strong> 的进程归入一个 <code>index</code> 表（由 <code>index</code> 指向 PCB），<strong>多个状态 </strong> 对应 <strong> 多个不同 </strong> 的 <code>index</code> 表。</p>
<ul>
<li>各状态的进程形成不同的索引表：就绪索引表、阻塞索引表。</li>
</ul>
<h3 id="PCB 扩展内容"><a href="#PCB 扩展内容" class="headerlink" title="PCB 扩展内容"></a>PCB 扩展内容</h3><blockquote>
<p>以下内容由 GPT 生成，不保证内容的 100% 准确。</p>
</blockquote>
<p>PCB 通常包含以下重要的信息：</p>
<ol>
<li><p>进程标识符（Process ID）：唯一标识该进程的数字或字符串。</p>
</li>
<li><p>程序计数器（Program Counter）：存储当前执行指令的地址，用于指示下一条要执行的指令。</p>
</li>
<li><p>寄存器集合：保存进程执行过程中的寄存器内容，包括通用寄存器、程序状态字、堆栈指针等。</p>
</li>
<li><p>进程状态（Process State）：表示进程当前所处的状态，常见的状态有就绪（Ready）、运行（Running）、阻塞（Blocked）等。</p>
</li>
<li><p>进程优先级（Process Priority）：用于确定进程的调度顺序，通常由进程调度算法根据一定的策略进行设置。</p>
</li>
<li><p>资源指针（Resource Pointers）：指向进程所拥有的资源的指针，如打开文件列表、内存分配信息等。</p>
</li>
<li><p>父进程指针（Parent Process Pointer）：指向该进程的父进程。</p>
</li>
<li><p>子进程指针（Child Process Pointer）：指向该进程的子进程。</p>
</li>
<li><p>进程控制信息（Process Control Information）：存储了进程的创建时间、运行时间、等待时间等统计信息。</p>
</li>
</ol>
<p>PCB 在操作系统中起到了重要的作用，它记录了进程的基本信息，并且通过操作系统的调度算法，可以根据 PCB 中的信息对进程进行管理和调度。当进程状态发生变化时，PCB 中的相应字段也会随之更新，以便操作系统能够及时响应和处理进程的状态变化。</p>
<p>以下是一个用 C 语言表示 PCB 的数据结构的示例（操作系统实际 PCB 设计可能有所不同）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlock</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> processID;</span><br><span class="line">    <span class="type">int</span> programCounter;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RegisterSet</span> &#123;</span></span><br><span class="line">        <span class="comment">// 寄存器集合，包括通用寄存器、程序状态字、堆栈指针等</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; registers;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">ProcessState</span> &#123;</span></span><br><span class="line">        READY,</span><br><span class="line">        RUNNING,</span><br><span class="line">        BLOCKED</span><br><span class="line">    &#125; state;</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">    <span class="type">void</span> *resourcePointers;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlock</span> *<span class="title">parentProcess</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlock</span> *<span class="title">childProcess</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlInformation</span> &#123;</span></span><br><span class="line">        <span class="comment">// 进程的统计信息，如创建时间、运行时间、等待时间等</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; controlInfo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述的数据结构中，<code>ProcessControlBlock</code>表示进程控制块，包含了进程的各种属性和状态信息。其中，<code>registers</code>表示寄存器集合，<code>state</code>表示进程状态，<code>priority</code>表示进程优先级，<code>resourcePointers</code>表示资源指针，<code>parentProcess</code>和 <code>childProcess</code> 分别表示父进程和子进程的指针，<code>controlInfo</code>表示进程的控制信息。</p>
<blockquote>
<p>参考资料：<br>1：<a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a><br>2：<a href="https://blog.csdn.net/weixin_53407527/article/details/125027431">https://blog.csdn.net/weixin_53407527/article/details/125027431</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>进程与线程</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter7.2 进程状态</title>
    <url>/posts/231210211306.html</url>
    <content><![CDATA[<p>进程是一个具有一定独立功能的 <strong> 程序 </strong> 在一个 <strong> 数据集合 </strong> 上的 <strong> 一次动态执行 </strong> 过程。</p>
<p>本文是进程与线程的第二部分，主要介绍进程的状态，包括进程的生命周期管理、进程状态变化模型和进程挂起模型，以及操作系统如何管理进程的状态队列。</p>
<span id="more"></span>

<h1 id="进程的生命周期管理"><a href="# 进程的生命周期管理" class="headerlink" title="进程的生命周期管理"></a>进程的生命周期管理 </h1><p> 一个进程的生命周期包括：进程的创建、就绪、运行、等待（阻塞）、终止。</p>
<h2 id="进程创建"><a href="# 进程创建" class="headerlink" title="进程创建"></a>进程创建 </h2><p> 引起进程创建的 3 个主要事件：</p>
<ul>
<li>系统初始化（创建出计算机的首个进程）；</li>
<li>用户请求创建一个新进程；</li>
<li>正在运行的进程执行了创建进程的系统调用。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P_create</span><br></pre></td></tr></table></figure>

<h2 id="进程就绪"><a href="# 进程就绪" class="headerlink" title="进程就绪"></a>进程就绪 </h2><p> 一个进程被创建完成后，便会进入就绪状态，等待操作系统的调度执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P_create -&gt; P_ready</span><br></pre></td></tr></table></figure>

<h2 id="进程运行"><a href="# 进程运行" class="headerlink" title="进程运行"></a>进程运行 </h2><p> 内核选择一个 <strong> 就绪 </strong> 的进程，让它占用 CPU 并执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P_create -&gt; P_ready -&gt; P_running</span><br></pre></td></tr></table></figure>

<blockquote>
<p>计算机有那么多进程呢，操作系统如何选择进程？又为何选择这个进程？这由后续要讲解的调度算法控制！</p>
</blockquote>
<h2 id="进程等待（阻塞）"><a href="# 进程等待（阻塞）" class="headerlink" title="进程等待（阻塞）"></a>进程等待（阻塞）</h2><p>在以下情况下，进程等待（阻塞）：</p>
<ul>
<li>请求并等待系统服务，无法马上完成；</li>
<li>启动某种操作，无法马上完成；</li>
<li>需要的数据没有到达。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P_create -&gt; P_ready -&gt; P_running</span><br><span class="line">                           ↓</span><br><span class="line">                       P_waiting</span><br></pre></td></tr></table></figure>

<p><strong>进程只能自己阻塞自己</strong>，因为只有进程自身才能知道何时需要等待某种事件的发生。</p>
<h2 id="进程唤醒"><a href="# 进程唤醒" class="headerlink" title="进程唤醒"></a>进程唤醒 </h2><p> 唤醒进程的原因：</p>
<ul>
<li>被阻塞进程需要的资源可被满足；</li>
<li>被阻塞进程等待的事件到达；</li>
<li>将该进程的 PCB 插入到就绪队列。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P_create -&gt; P_ready -&gt; P_running</span><br><span class="line">               ↑           ↓</span><br><span class="line">               &lt;------ P_waiting</span><br></pre></td></tr></table></figure>

<p>被唤醒的进程将进入就绪状态，<strong>进程只能被别的进程或操作系统唤醒</strong>。</p>
<h2 id="进程结束"><a href="# 进程结束" class="headerlink" title="进程结束"></a>进程结束 </h2><p> 在以下四种情况下，进程结束：</p>
<ul>
<li>正常退出（自愿的）；</li>
<li>错误退出（自愿的）；</li>
<li>致命错误（强制性的）；</li>
<li>被其他进程所杀死（强制性的）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P_create -&gt; P_ready -&gt; P_running -&gt; Exit</span><br><span class="line">               ↑           ↓</span><br><span class="line">               &lt;------ P_waiting</span><br></pre></td></tr></table></figure>

<h1 id="进程状态变化模型"><a href="# 进程状态变化模型" class="headerlink" title="进程状态变化模型"></a>进程状态变化模型 </h1><h2 id="三种基本状态"><a href="# 三种基本状态" class="headerlink" title="三种基本状态"></a> 三种基本状态 </h2><p> 进程的三种基本状态（进程在生命结束前处于三种基本状态之一）：</p>
<ul>
<li>运行状态（Running）：当一个进程正在 CPU 上运行时。</li>
<li>就绪状态（Ready）：一个进程获得了除 CPU 之外的一切所需资源，一旦得到 CPU 便可运行。</li>
<li>等待（阻塞）状态（Waiting/Blocked）：一个进程正在等待某一事件而暂停运行时。如等待某资源、等待输入 / 输出完成。</li>
</ul>
<blockquote>
<p>不同操作系统设置的进程状态数目可能不同。</p>
</blockquote>
<h2 id="其它基本状态"><a href="# 其它基本状态" class="headerlink" title="其它基本状态"></a>其它基本状态 </h2><p> 进程其它的基本状态：</p>
<ul>
<li>创建状态（New）：一个进程正在被创建，还没被转到就绪状态之前的状态；</li>
<li>结束状态（Exit）： 一个进程正在从系统中消失时的状态。</li>
</ul>
<h2 id="进程状态变化"><a href="# 进程状态变化" class="headerlink" title="进程状态变化"></a>进程状态变化</h2><img src="../images/os-kernel/chapter7/process-state.png" alt="进程状态变化图" width="80%" height="80%">

<p>进程可能的状态变化如下：</p>
<ul>
<li><code>NULL -&gt; New</code>：一个新进程被产生出来执行一个程序。</li>
<li><code>New -&gt; Ready</code>：当进程创建并并初始化完成后，一切就绪准备运行时，变为就绪状态。<ul>
<li>该变化过程是否会持续很久？很快。</li>
</ul>
</li>
<li><code>Ready -&gt; Running</code>：处于就绪态的进程被进程调度程序选中后，就分配到 CPU 上来运行。</li>
<li><code>Running -&gt; Exit</code>：当进程表示它已经完成或者发生异常，当前运行的进程会由操作系统作结束处理。</li>
<li><code>Running -&gt; Ready</code>：处于运行状态的进程在其运行过程中，<strong>由于分配它的 CPU 时间片用完而让出 CPU，或者当一个高优先级的进程就绪时，操作系统可能会抢占当前正在运行的低优先级进程，并将其切换到就绪态，以便优先执行高优先级进程</strong>。</li>
<li><code>Running -&gt; Blocked</code>：当进程请求某个事件且必须等待时。<ul>
<li>例如，等待一个计时器的到达、读 / 写文件比较慢等。</li>
</ul>
</li>
<li><code>Blocked -&gt; Ready</code>：当进程等待到某个事件到来时，它从阻塞状态变到就绪状态。</li>
</ul>
<h1 id="进程挂起模型"><a href="# 进程挂起模型" class="headerlink" title="进程挂起模型"></a>进程挂起模型 </h1><h2 id="进程挂起"><a href="# 进程挂起" class="headerlink" title="进程挂起"></a> 进程挂起 </h2><p> 进程挂起（suspend）是指操作系统进程管理将前台的进程暂停并转入后台的动作。将进程挂起可以让用户在前台执行其他的进程。挂起的进程通常释放除 CPU 以外已经占有的系统资源，如内存等。在需要时用户可以恢复进程的运行，将被挂起的进程从后台转入前台，并从暂停处开始继续运行。（Wikipedia）</p>
<p>进程挂起：为了合理且充分地利用系统资源。</p>
<p>进程在挂起状态时，意味着进程 <strong> 没有占用内存空间</strong>，处在挂起状态的进程映像在磁盘上（把进程放到磁盘上）。</p>
<h2 id="两种挂起状态"><a href="# 两种挂起状态" class="headerlink" title="两种挂起状态"></a>两种挂起状态</h2><ul>
<li><strong>阻塞挂起状态</strong>：进程在外存，并等待某事件的出现。</li>
<li><strong>就绪挂起状态</strong>：进程在外村，但只要进入内存，即可运行。</li>
</ul>
<h2 id="与挂起相关的状态转换"><a href="# 与挂起相关的状态转换" class="headerlink" title="与挂起相关的状态转换"></a>与挂起相关的状态转换 </h2><p> 带有挂起状态的进程状态转移模型：</p>
<img src="../images/os-kernel/chapter7/process-state-transfer-with-suspend.png" alt="带有挂起状态的进程状态转移模型" width="80%" height="80%">

<p>可以将挂起状态间的转化分为两类，<strong>一类是进程处于内存中时发生的挂起，另一类是进程处于外存时的挂起</strong>。</p>
<h3 id="进程处于内存时的挂起"><a href="# 进程处于内存时的挂起" class="headerlink" title="进程处于内存时的挂起"></a>进程处于内存时的挂起 </h3><p><strong> 阻塞 -&gt; 阻塞挂起</strong>：</p>
<ul>
<li>条件：当没有进程处于就绪状态（即没有可以立即执行的进程）或者就绪进程需要更多的内存资源时，系统会进行阻塞挂起的转换。</li>
<li>目的：为了让其他进程先执行，以便提交新进程或者为就绪进程提供所需的内存资源。换句话说，系统会将当前的进程暂时停止执行，以满足其他进程的需求，直到满足某种条件后再重新唤醒该进程。</li>
</ul>
<p><strong>就绪 -&gt; 就绪挂起</strong>：</p>
<ul>
<li>条件：当有高优先级阻塞（系统认为会很快就绪的）进程和低优先级就绪进程时，系统会选择挂起低优先级就绪进程。</li>
<li>目的：让优先级更高的进程得到更多的资源运行。</li>
</ul>
<blockquote>
<p>通常，<strong>操作系统更倾向于挂起阻塞态进程而不是就绪态进程 </strong>，因为就绪态进程可以立即执行，而阻塞态进程占用了内存空间但不能立即执行。<br> 但是，如果释放内存以得到足够空间的 <strong> 唯一方法 </strong> 是挂起一个就绪态进程的话，那么这种转换也是必需的；并且，如果操作系统确信高优先级的阻塞态进程很快就会就绪，那么它可能选择挂起一个低优先级的就绪态进程，而不是一个高优先级的阻塞态进程。</p>
</blockquote>
<p><strong>运行 -&gt; 就绪挂起</strong>：</p>
<ul>
<li>条件：对抢先式分时系统（即可抢占 CPU 资源），当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时，系统可能会把运行进程转到就绪挂起状态。</li>
<li>目的：让优先级更高的进程得到更多的资源运行。</li>
</ul>
<h3 id="进程处于外存时的挂起"><a href="# 进程处于外存时的挂起" class="headerlink" title="进程处于外存时的挂起"></a>进程处于外存时的挂起 </h3><p><strong> 阻塞挂起 -&gt; 就绪挂起</strong>：</p>
<p>条件：当有阻塞挂起因相关事件出现时，系统会把阻塞挂起进程转换为就绪挂起进程。</p>
<h3 id="解挂（激活）"><a href="# 解挂（激活）" class="headerlink" title="解挂（激活）"></a>解挂（激活）</h3><p>既然有将内存中的进程挂起到外存的，那么也会有解挂重新激活进程的操作：即将一个进程从外存转到内存。</p>
<p><strong>就绪挂起 -&gt; 就绪态</strong>：</p>
<p>条件：内存中没有就绪进程，或挂起的就绪进程优先级高于内存中的就绪进程时，会进行这种转换。但一般情况下也会发生这种转换，不一定是上述两种条件。</p>
<p><strong>阻塞挂起 -&gt; 阻塞态</strong>：</p>
<p>条件：当一个进程释放足够内存时，系统会把一个高优先级阻塞挂起（系统认为会很快出现所等待的事件）进程转换为阻塞进程。</p>
<h1 id="状态队列"><a href="# 状态队列" class="headerlink" title="状态队列"></a>状态队列 </h1><p> 状态队列（State Queue）是操作系统中用于管理进程状态的数据结构，用于存储不同状态的进程。</p>
<p><strong>状态队列</strong>：</p>
<ul>
<li>由操作系统来维护 <strong> 一组 </strong> 队列，用来表示系统当中所有进程的当前状态；</li>
<li>不同的状态分别用不同的队列来表示，如就绪队列、各种类型的阻塞队列；</li>
<li>每个进程的 PCB 都根据它的状态加入到相应的队列当中，当一个进程的状态发生变化时，它的 PCB 从一个状态队列中脱离出来，加入到另外一个状态队列中。</li>
</ul>
<details>
  <summary>操作系统如何通过 PCB 和定义的进程状态来管理和调度进程的？</summary>

<ol>
<li>将进程根据其状态放入对应的队列中。</li>
<li>根据调度算法从就绪队列中选择一个进程进行执行。</li>
<li>将选中的进程的 PCB 信息加载到 CPU 寄存器中，设置进程状态为运行态。</li>
<li>执行选中的进程，根据需要进行上下文切换。</li>
<li>如果进程遇到事件（如等待 I/O 完成），将进程状态设置为阻塞态，记录事件信息到 PCB 中。</li>
<li>当事件发生后，将进程状态设置为就绪态，将其放回就绪队列中等待调度。</li>
<li>重复步骤 2 至步骤 6，实现多任务的并发执行和合理的进程调度。【由 GPT 生成】</li>
</ol>
</details>

<blockquote>
<p>参考资料：<br>1：<a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a><br>2：<a href="https://blog.csdn.net/weixin_53407527/article/details/125027431">https://blog.csdn.net/weixin_53407527/article/details/125027431</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>进程与线程</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter4.1 非连续内存分配之分段与分页</title>
    <url>/posts/231111172507.html</url>
    <content><![CDATA[<p>这篇文章主要介绍操作系统的非连续内存分配，包括非连续内存分配的必要性、分段（segmentation）与分页（paging）技术。</p>
<span id="more"></span>

<h2 id="非连续内存分配的必要性"><a href="# 非连续内存分配的必要性" class="headerlink" title="非连续内存分配的必要性"></a>非连续内存分配的必要性 </h2><p> 第三章介绍的是连续内存管理，即：操作系统加载到内存以及程序加载到内存中时，分配一块连续的空闲内存块，但是容易出现碎片问题。这一章介绍的非连续内存分配，这可以有效的减少碎片的出现。</p>
<h3 id="连续内存分配的缺点"><a href="# 连续内存分配的缺点" class="headerlink" title="连续内存分配的缺点"></a>连续内存分配的缺点</h3><ol>
<li>分配给一个程序的物理内存是连续的</li>
<li>内存利用率低</li>
<li>有外碎片、内碎片的问题</li>
</ol>
<blockquote>
<p>能否通过一些手段来改善这些情况？非连续内存分配！</p>
</blockquote>
<h3 id="非连续内存分配的优点"><a href="# 非连续内存分配的优点" class="headerlink" title="非连续内存分配的优点"></a>非连续内存分配的优点</h3><ol>
<li>分配给一个程序的物理内存是非连续的</li>
<li>更好的内存利用和管理</li>
<li>允许共享代码与数据（共享库等…）</li>
<li>支持动态加载和动态链接</li>
</ol>
<h3 id="非连续内存分配的缺点"><a href="# 非连续内存分配的缺点" class="headerlink" title="非连续内存分配的缺点"></a>非连续内存分配的缺点 </h3><p> 建立虚拟地址和物理地址的转换难度大。</p>
<ul>
<li>软件方案（开销相当大）</li>
<li>硬件方案（采用硬件辅助机制）<ul>
<li>分段（segmentation）技术</li>
<li>分页（paging）技术</li>
</ul>
</li>
</ul>
<h2 id="非连续内存分配"><a href="# 非连续内存分配" class="headerlink" title="非连续内存分配"></a>非连续内存分配 </h2><h3 id="分段（segmentation）"><a href="# 分段（segmentation）" class="headerlink" title="分段（segmentation）"></a> 分段（segmentation）</h3><h4 id="分段"><a href="# 分段" class="headerlink" title="分段"></a>分段 </h4><p> 分段（segmentation）是一种非连续内存分配技术，用于操作系统中 <strong> 管理进程的内存空间</strong>。在分段技术中，进程的内存空间被划分为多个段，每个段具有不同的大小和功能。</p>
<img src="../images/os-kernel/chapter4/process-memory-segmentation.png" alt="进程内存空间划分" width="50%" height="50%">

<p>「段」：在程序执行时，会存在来自不同文件的函数和不同的数据字段。这些函数可能分布在程序的不同文件中，而数据字段则可以包括堆、栈、.bss、.data 等不同类型。</p>
<ul>
<li>堆用于动态内存分配</li>
<li>栈用于函数调用和局部变量存储</li>
<li>.bss 用于存储未初始化的静态变量</li>
<li>.data 用于存储已初始化的静态变量</li>
</ul>
<p>「分段」：更好的实现内存的分离和共享。</p>
<p>程序的分段地址空间如下图所示：<br><img src="../images/os-kernel/chapter4/process-segmentation-space.png" alt="程序的分段地址空间" width="60%" height="60%"></p>
<p>把左边运行程序的逻辑地址空间看成一个连续的一维线性数组，通过段机制的映射关系，把不同的内存块（如：代码、数据、堆、栈）分别映射到不同的内存中的段，可以看到映射到物理地址空间后，位置不一样，变得不连续了。</p>
<p>分段的逻辑视图，连续的逻辑地址空间被分配到物理空间中的不连续内存空间中：<br><img src="../images/os-kernel/chapter4/segmentation-logical-view.png" alt="分段的逻辑视图" width="60%" height="60%"></p>
<h4 id="段表"><a href="# 段表" class="headerlink" title="段表"></a>段表 </h4><p> 段表是一种数据结构，用于 <strong> 存储和管理分段技术下的进程内存空间</strong>。它通常是一个数组或链表，每个元素表示一个段的相关信息。一个段对应着一个内存块。</p>
<p>下面是一个简化的段表数据结构示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentEntry</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> segmentID;      <span class="comment">// 段 ID</span></span><br><span class="line">    <span class="type">int</span> baseAddress;    <span class="comment">// 段基址</span></span><br><span class="line">    <span class="type">int</span> limit;          <span class="comment">// 段界限</span></span><br><span class="line">    <span class="type">int</span> permissions;    <span class="comment">// 段访问权限</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，每个段表项包含了以下信息：</p>
<ul>
<li><code>segmentID</code>：段的唯一标识符，用于区分不同的段。</li>
<li><code>baseAddress</code>：段的基址，指示段在内存中的起始位置。</li>
<li><code>limit</code>：段的界限，指示段的大小。通常以字节为单位。</li>
<li><code>permissions</code>：段的访问权限，用于控制对段的读、写和执行操作。</li>
</ul>
<p>段表根据进程的需要进行动态更新，以反映内存中段的分配和释放情况。通过段表，操作系统可以轻松地查找和管理进程的各个段，实现内存隔离和安全性。</p>
<h4 id="分段寻址方案"><a href="# 分段寻址方案" class="headerlink" title="分段寻址方案"></a>分段寻址方案 </h4><p> 逻辑地址空间连续，但是物理地址空间不连续，使用映射机制进行关联。</p>
<img src="../images/os-kernel/chapter4/segmentation-scheme.png" alt="硬件分段实现方案" width="60%" height="60%">

<p>程序访问物理内存地址需要：一个二维的二元组 <code>(segmentID, addrOffset)</code>，即 <code>(段号, 段内偏移地址)</code>。</p>
<p>操作系统会维护一张段表，以 <code>segmentID</code> 为索引，存储着 <code>(baseAddress, limit)</code> 信息。</p>
<p>因此，逻辑地址通过段表映射后的物理地址为：段号对应的段基址 + 二元组中的段内偏移地址</p>
<blockquote>
<p>段表在寻址之前操作系统就已经建立好了，之后段机制就可以正常工作了。</p>
</blockquote>
<h3 id="分页（paging）"><a href="# 分页（paging）" class="headerlink" title="分页（paging）"></a>分页（paging）</h3><h4 id="分页"><a href="# 分页" class="headerlink" title="分页"></a>分页 </h4><p> 分页（paging）是操作系统中的一种非连续内存分配技术。它将物理内存和逻辑内存进行分割：</p>
<ul>
<li>将逻辑内存空间划分成相等大小的页面（page）<ul>
<li>大小是 2 的幂，例如：512bytes / 4096bytes / 8192bytes</li>
</ul>
</li>
<li>将物理内存空间也划分成相等大小的物理页帧（page frame）<ul>
<li>大小是 2 的幂，例如：512bytes / 4096bytes / 8192bytes</li>
</ul>
</li>
</ul>
<blockquote>
<p>逻辑空间中内存划分叫做页（page），物理空间中内存划分叫做页帧（page frame）；划分的 page 大小和 frame 大小要保持一致。</p>
</blockquote>
<h4 id="页到页帧的转换"><a href="# 页到页帧的转换" class="headerlink" title="页到页帧的转换"></a>页到页帧的转换 </h4><p> 页到页帧的转换方案（pages to page frames）/ 逻辑地址到物理地址的转换方案：</p>
<ul>
<li>通过页表（page table）</li>
<li>内存管理单元（MMU）/ 快表（TLB）</li>
</ul>
<h4 id="帧（Frame）"><a href="# 帧（Frame）" class="headerlink" title="帧（Frame）"></a>帧（Frame）</h4><p>物理内存被分割为大小相等的帧，一个内存的物理地址是一个二元组 <code>(f, o)</code>：</p>
<ul>
<li><code>f</code> 为页帧号（一共有 $F$ 位，可以表示 $2^F$ 个不同的页帧）</li>
<li><code>o</code> 为页帧内偏移（一共有 $S$ 位，每个页帧有 $2^S$ 字节）</li>
</ul>
<p>页帧位占用高地址空间，页帧内偏移位占用低地址空间。二元组对应的物理地址为 $addr = 2^{S} \times f + o$。</p>
<blockquote>
<p>好比一本书，一共有 $2^F$ 页，每页最多可以写 $2^S$ 个字，当前打开的页面是第 $f$ 页，笔处在本页第 $o$ 个字的位置，处在全书第 $2^{S} \times f + o$ 个字的位置。</p>
</blockquote>
<p>举个栗子：一个由 $16 bit$ 组成的地址空间，$9 bit$ 大小（512 字节）的页帧，物理地址的二元组为 $(3,6)$，请问物理地址是多少？</p>
<p>由描述可知，$S=9, F=16-9=7, f=3, o=6$，二元组对应的物理地址为 $2^{9} \times 3 + 6 = 1542$。</p>
<blockquote>
<p>分页和分段的最大区别：这里的 $S$ 是一个固定的数，即每页页帧大小相同，而分段中的段的大小不固定。</p>
</blockquote>
<h4 id="页（Page）"><a href="# 页（Page）" class="headerlink" title="页（Page）"></a>页（Page）</h4><p>进程的逻辑地址空间被划分为大小相等的页，一个进程的逻辑地址是一个二元组 <code>(p, o)</code>：</p>
<ul>
<li><code>p</code> 为页号（一共有 $P$ 位，可以表示 $2^P$ 个不同的页）</li>
<li><code>o</code> 为页内偏移（一共有 $S$ 位，每页有 $2^S$ 字节）</li>
</ul>
<p>二元组对应的逻辑（虚拟）地址为 $addr = 2^{S} \times p + o$。</p>
<blockquote>
<p>通常页号大小 <strong> 不等于 </strong> 页帧号大小（即 $p \neq f$），页内偏移跟页帧内偏移大小一致，页和页帧的字节数大小一致。</p>
</blockquote>
<h4 id="页寻址方案"><a href="# 页寻址方案" class="headerlink" title="页寻址方案"></a>页寻址方案 </h4><p> 页寻址要解决的就是，如何通过逻辑地址访问到对应的物理内存空间的数据。</p>
<p>当进程需要访问一个逻辑地址时，操作系统将逻辑地址分成两个部分：页号（page number）和页内偏移（page offset）。页号用于索引页表（page table），页表记录了每个页号对应的物理页帧号。通过找到页表中对应的物理页帧号，再加上页内偏移，就可以得到实际的物理地址，从而进行物理内存访问。</p>
<img src="../images/os-kernel/chapter4/page-addressing-scheme.png" alt="页寻址方案" width="60%" height="60%">

<blockquote>
<p>页寻址过程：逻辑地址 -&gt; 页号 -&gt; 查找页表 -&gt; 物理页帧号 -&gt; 利用页内偏移 -&gt; 实际物理地址 -&gt; 物理内存访问。</p>
</blockquote>
<ul>
<li>页表保存了逻辑地址到物理地址的映射关系（页号：物理页帧号）</li>
<li>实际上，逻辑地址空间大于物理内存空间</li>
<li>页映射到帧</li>
<li>页是连续的虚拟内存（逻辑地址中的页号是连续的）</li>
<li>帧是非连续的物理内存（物理地址中的帧号是不连续的），有助于减少碎片的产生</li>
<li>不是所有的页都有对应的帧</li>
</ul>
<p>为什么逻辑地址映射到物理地址空间后的内存是不连续的？<br>这是因为页寻址时，通过查找页表，将进程的连续页号 $p$ 映射到不连续的页帧号 $f$，不连续的页帧号对应着不连续的物理内存块。</p>
<blockquote>
<p>参考资料：<br>1：<a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a><br>2：<a href="https://blog.csdn.net/weixin_53407527/article/details/124891795">https://blog.csdn.net/weixin_53407527/article/details/124891795</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>非连续内存分配</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>非连续内存分配</tag>
        <tag>分段</tag>
        <tag>分页</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter7.3 线程</title>
    <url>/posts/231215213932.html</url>
    <content><![CDATA[<p>线程（Thread）是计算机程序中的执行单元，是进程中的一条执行流程。一个进程可以包含多个线程，每个线程可以独立执行不同的任务。线程可以并发执行，因此可以提高程序的执行效率。</p>
<p>从两个方面重新理解进程（Process）：</p>
<ul>
<li>从资源组合的角度：进程将一组相关的资源组合在一起，构成了一个资源平台（环境），包括地址空间（代码段、数据段）、打开的文件等各种资源；</li>
<li>从运行的角度：进程是指代码在这个资源平台上执行的一条或多条执行流程（线程）。</li>
</ul>
<span id="more"></span>

<h1 id="为什么使用线程"><a href="# 为什么使用线程" class="headerlink" title="为什么使用线程"></a>为什么使用线程 </h1><p> 实例：编写一个 MP3 播放软件，其核心功能为：</p>
<ol>
<li>从 MP3 音频文件中读取数据；</li>
<li>对数据进行解压缩；</li>
<li>把解压缩后的音频数据播放出来。</li>
</ol>
<h2 id="单进程实现"><a href="# 单进程实现" class="headerlink" title="单进程实现"></a>单进程实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Read(); <span class="comment">// I/O</span></span><br><span class="line">        Decompress(); <span class="comment">// CPU</span></span><br><span class="line">        Play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Read() &#123;...&#125;</span><br><span class="line">Decompress() &#123;...&#125;</span><br><span class="line">Play() &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    问题：</span></span><br><span class="line"><span class="comment">    分片的读取、解压、播放的话，播放出来的声音能否连贯？</span></span><br><span class="line"><span class="comment">        大概率是不能的，因为从硬盘读取是很慢的。</span></span><br><span class="line"><span class="comment">    各个函数之间不是并发执行，影响资源的使用效率。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="多进程实现"><a href="# 多进程实现" class="headerlink" title="多进程实现"></a>多进程实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 程序 1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Read() &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序 2</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Decompress();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Decompress() &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序 3</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Play() &#123;...&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    问题：</span></span><br><span class="line"><span class="comment">    进程之间如何通信、共享数据？另外，维护进程的系统开销较大；</span></span><br><span class="line"><span class="comment">    创建进程时，分配资源，建立 PCB；撤销进程时，回收资源，撤销 PCB；进程切换时，保存当前进程的状态信息。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<details>
  <summary>操作系统为进程分配哪些资源？</summary>
【由 GPT 生成】创建进程时，操作系统需要为进程分配一些资源，其中包括：

<ol>
<li>内存空间：为进程分配一定大小的内存空间，用于存储进程的代码、数据和堆栈等信息。</li>
<li>文件描述符：为进程分配文件描述符，用于访问打开的文件。</li>
<li>I/O 设备：为进程分配所需的 I/O 设备，如键盘、显示器、打印机等。</li>
<li>网络资源：如果进程需要进行网络通信，需要分配网络资源，如 IP 地址、端口等。</li>
<li>CPU 时间片：为进程分配 CPU 时间片，用于执行进程的代码。</li>
<li>进程标识符：为进程分配唯一的进程标识符，用于标识和管理进程。</li>
<li>环境变量：为进程设置环境变量，用于配置进程运行环境。</li>
<li>系统资源：为进程分配其他系统资源，如共享内存、消息队列等。</li>
</ol>
<p>这些资源的分配是由操作系统负责管理和调度的，通过建立进程控制块（PCB）来管理进程的资源和状态。</p>
</details>

<h2 id="如何解决"><a href="# 如何解决" class="headerlink" title="如何解决"></a>如何解决 </h2><p> 需要提出一种新的实体，满足以下特征：</p>
<ul>
<li>实体之间可以 <strong> 并发执行</strong>；</li>
<li>实体之间 <strong> 共享相同的地址空间</strong>。</li>
</ul>
<p>这种实体就是线程（Thread）。</p>
<h1 id="什么是线程"><a href="# 什么是线程" class="headerlink" title="什么是线程"></a>什么是线程 </h1><h2 id="线程定义"><a href="# 线程定义" class="headerlink" title="线程定义"></a> 线程定义 </h2><p> 线程（Thread）是计算机程序中的执行单元，是 <strong> 进程中的一条执行流程</strong>。一个进程可以包含多个线程，每个线程可以独立执行不同的任务。线程可以并发执行，因此可以提高程序的执行效率。</p>
<p>从两个方面重新理解进程（Process）：</p>
<ul>
<li>从资源组合的角度：进程将一组相关的资源组合在一起，构成了一个资源平台（环境），包括地址空间（代码段、数据段）、打开的文件等各种资源；</li>
<li>从运行的角度：进程是指代码在这个资源平台上执行的一条或多条执行流程（线程）。</li>
</ul>
<h2 id="进程中的多线程"><a href="# 进程中的多线程" class="headerlink" title="进程中的多线程"></a>进程中的多线程 </h2><p> 进程中的多线程：<br><img src="../images/os-kernel/chapter7/thread.png" alt="进程中的多线程" width="80%" height="80%"></p>
<p>从图中可以看出：</p>
<ul>
<li>每个线程有各自的线程控制块（TCB）、程序计数器（PC）、堆栈指针（SP）、状态寄存器等；</li>
<li>每个线程有共享的资源：代码段、数据段、堆空间等（意味着多个线程都可以访问和修改这些资源）。</li>
</ul>
<img src="../images/os-kernel/chapter7/single-multi-thread.png" alt="单线程 Vs. 多线程" width="80%" height="80%">

<blockquote>
<p>线程 = 进程 - 共享资源</p>
</blockquote>
<h2 id="线程的优缺点"><a href="# 线程的优缺点" class="headerlink" title="线程的优缺点"></a>线程的优缺点 </h2><p> 优点：</p>
<ul>
<li>一个进程中可以 <strong> 同时存在多个 </strong> 线程；</li>
<li>各个线程之间可以 <strong> 并发地执行</strong>；</li>
<li>各个线程之间可以 <strong> 共享地址空间和文件资源 </strong> 等。</li>
</ul>
<p>缺点：</p>
<ul>
<li>一个线程崩溃，会导致其所属进程的所有线程崩溃。（给了它「权限」就得有更高的「责任」）</li>
</ul>
<blockquote>
<p>线程的优点也是线程的缺点，由于共享资源，安全性得不到保障。</p>
</blockquote>
<h2 id="线程与进程比较"><a href="# 线程与进程比较" class="headerlink" title="线程与进程比较"></a>线程与进程比较</h2><ul>
<li>进程是资源分配单位，线程是 CPU 调度单位；</li>
<li>进程拥有一个完整的资源平台，而 <strong> 线程只独享必不可少的资源</strong>（如寄存器、堆栈等）；</li>
<li>线程同样具有「就绪、阻塞、运行」三种基本状态，同样具有状态之间的转换关系；</li>
<li><strong>线程能减少并发执行的时间、空间开销</strong>：<ul>
<li>线程的 <strong> 创建时间 </strong> 比进程短（因为线程直接利用了所属进程的一些状态信息，如页表、文件描述符等）；</li>
<li>线程的 <strong> 终止时间 </strong> 比进程短（因为线程不需要像进程那样进行资源的清理和释放）；</li>
<li>同一进程内的线程 <strong> 切换时间 </strong> 比进程短（因为同一进程的不同线程的切换不需要切换页表）；</li>
<li>由于同一进程的各个线程之间共享内存和文件资源，可 <strong> 直接进行通信</strong>（直接通过内存地址进行数据传递），而不需要借助内核。</li>
</ul>
</li>
</ul>
<h1 id="线程的实现"><a href="# 线程的实现" class="headerlink" title="线程的实现"></a>线程的实现 </h1><p> 主要有三种线程的实现方式：</p>
<ul>
<li>用户线程：在用户空间实现，操作系统看不到用户线程，由应用程序进行管理。<ul>
<li>POSIX Pthreads (Mac/Windows/Linux OS)、Mach C-threads (Mach OS)、Solaris threads (Solaris OS)</li>
</ul>
</li>
<li>内核线程：在内核空间实现，操作系统管理的线程。<ul>
<li>Windows、Linux、Solaris</li>
</ul>
</li>
<li>轻量级进程（LightWeight Process）：在内核中实现，支持用户线程。<ul>
<li>Solaris、Linux</li>
</ul>
</li>
</ul>
<h2 id="用户线程"><a href="# 用户线程" class="headerlink" title="用户线程"></a>用户线程 </h2><p> 操作系统只能看到进程、看不到线程，线程的 TCB 在线程库中实现。</p>
<img src="../images/os-kernel/chapter7/user-thread.png" alt="用户线程" width="80%" height="80%">

<p><strong>在用户空间实现的线程机制，它不依赖于操作系统的内核，由一组用户级的线程库（如 <code>pthread.h</code>）函数来完成线程的管理，包括进程的创建、终止、同步和调度等</strong>。</p>
<ul>
<li>由于用户线程的维护由相应的进程来完成（通过线程库函数），不需要操作系统内核了解用户线程的存在，可用于不支持线程技术的多进程操作系统；</li>
<li>每个进程都需要有它自己私有的 <strong> 线程控制块（TCB）列表</strong>，用来跟踪记录它的各个线程的状态信息（PC、栈指针、寄存器），TCB 由线程库函数来维护；</li>
<li><strong>用户线程的切换也是由线程库函数来完成，无需进行用户态到内核态的切换，速度特别快</strong>；</li>
<li>允许每个进程拥有自定义的线程调度算法。</li>
</ul>
<p><strong>用户线程的缺点</strong>：</p>
<ul>
<li>阻塞性的系统调用如何实现？如果一个线程发起系统调用而阻塞，则整个进程在等待；</li>
<li>当一个线程运行时，除非它主动交出 CPU 使用权，否则它所在的进程中的其他线程将无法运行；</li>
<li>由于时间片分配给进程，所以与其它进程相比，在多线程执行时，每个线程得到的时间片较少，执行会较慢。</li>
</ul>
<h2 id="内核线程"><a href="# 内核线程" class="headerlink" title="内核线程"></a>内核线程 </h2><p> 操作系统能够看到进程、也可能看到线程，线程在内核中实现。</p>
<img src="../images/os-kernel/chapter7/kernel-thread.png" alt="内核线程" width="80%" height="80%">

<p><strong>内核线程是指在操作系统的内核当中实现的一种线程机制，由操作系统的内核来完成线程的创建、终止和管理</strong>。</p>
<ul>
<li>在支持内核线程的操作系统中，由 <strong> 内核来维护进程和线程的上下文信息</strong>（PCB 和 TCB）；</li>
<li>线程的创建、终止和切换都是通过系统调用 / 内核函数的方式来进行，由内核来完成，因此系统开销较大；</li>
<li>在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并 <strong> 不会影响 </strong> 其他内核线程在 CPU 上的运行；</li>
<li>时间片分配给线程，多线程的进程获得更多 CPU 时间。</li>
</ul>
<h2 id="轻量级进程"><a href="# 轻量级进程" class="headerlink" title="轻量级进程"></a>轻量级进程 </h2><p> 它是内核支持的用户线程。一个进程可以有一个或多个轻量化进程，每个轻量级进程由一个单独的内核线程来支持。</p>
<blockquote>
<p>参考资料：<br>1：<a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a><br>2：<a href="https://blog.csdn.net/weixin_53407527/article/details/125027431">https://blog.csdn.net/weixin_53407527/article/details/125027431</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>进程与线程</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter8 调度</title>
    <url>/posts/231228193143.html</url>
    <content><![CDATA[<p>本文介绍进程的调度算法，包括进程调度的相关背景、调度准则，以及各种调度算法。</p>
<span id="more"></span>

<h1 id="背景"><a href="# 背景" class="headerlink" title="背景"></a>背景 </h1><h2 id="上下文切换"><a href="# 上下文切换" class="headerlink" title="上下文切换"></a> 上下文切换</h2><ul>
<li>将 CPU 从一个进程 / 线程切换到另一个进程 / 线程；</li>
<li>在切换过程中，当前进程 / 线程的执行上下文（CPU 状态）被保存到进程 / 线程控制块（PCB/TCB）中；</li>
<li>然后，下一个进程 / 线程的上下文被读取。</li>
</ul>
<h2 id="CPU 调度"><a href="#CPU 调度" class="headerlink" title="CPU 调度"></a>CPU 调度</h2><ul>
<li>CPU 调度是从就绪队列中选择下一个要运行的进程 / 线程；</li>
<li>调度程序是一个内核函数，通过一些调度策略来选择进程 / 线程；</li>
<li>调度什么时候发生？</li>
</ul>
<h2 id="内核运行调度程序的条件"><a href="# 内核运行调度程序的条件" class="headerlink" title="内核运行调度程序的条件"></a>内核运行调度程序的条件</h2><ul>
<li>一个进程从运行状态切换到等待状态。</li>
<li>一个进程被终止。</li>
</ul>
<blockquote>
<p>满足上述其中一个条件，即可运行调度程序。</p>
</blockquote>
<h2 id="不可抢占系统"><a href="# 不可抢占系统" class="headerlink" title="不可抢占系统"></a>不可抢占系统</h2><ul>
<li>调度程序必须等待事件结束。</li>
</ul>
<h2 id="可以抢占系统"><a href="# 可以抢占系统" class="headerlink" title="可以抢占系统"></a>可以抢占系统</h2><ul>
<li>调度程序在中断事件被响应后执行。</li>
<li>当前进程从运行状态切换到就绪状态（进程时间片用完），或者一个进程从等待状态切换到就绪状态。</li>
<li>当前运行的进程可以被换出。</li>
</ul>
<h1 id="调度原则"><a href="# 调度原则" class="headerlink" title="调度原则"></a>调度原则 </h1><h2 id="调度策略"><a href="# 调度策略" class="headerlink" title="调度策略"></a> 调度策略</h2><ul>
<li>调度策略：<ul>
<li>确定如何从就绪队列中选择下一个执行进程。</li>
</ul>
</li>
<li>调度策略要解决的问题：<ul>
<li>挑选就绪队列中的哪一个进程？</li>
<li>通过什么样的准则来选择？</li>
</ul>
</li>
<li>调度算法：<ul>
<li>在调度程序中实现的调度策略。</li>
</ul>
</li>
<li>比较调度算法的准则：<ul>
<li>哪一个策略或算法比较好？</li>
</ul>
</li>
</ul>
<h2 id="程序执行模型"><a href="# 程序执行模型" class="headerlink" title="程序执行模型"></a>程序执行模型</h2><img src="../images/os-kernel/chapter8/cpu-vs-io-model.png" alt="程序执行模型" width="80%" height="80%">

<p>当某进程在进行 I/O 时，没有占用 CPU，此时希望其它进程能有效利用 CPU，使得 CPU 尽可能忙，充分利用资源。</p>
<h2 id="评价指标"><a href="# 评价指标" class="headerlink" title="评价指标"></a>评价指标</h2><ul>
<li><p><strong>CPU 使用率</strong>：CPU 处于忙状态所占时间的百分比。</p>
</li>
<li><p><strong>吞吐量</strong>：单位时间内完成的进程数量。</p>
</li>
<li><p><strong>周转时间</strong>：一个进程从到达就绪队列到完成（结束）所花费的时间，包括所有等待时间。</p>
<ul>
<li>周转时间 = 完成时间 - 达到时间</li>
<li>带权周转时间 = 周转时间 / 运行时间</li>
</ul>
</li>
<li><p><strong>等待时间</strong>：进程在就绪队列中的总时间。</p>
<ul>
<li>等待时间 = 周转时间 - 运行时间，也等于开始执行时间 - 达到时间</li>
</ul>
</li>
<li><p><strong>响应时间</strong>：从一个请求被提交到产生第一次响应所花费的总时间。</p>
</li>
</ul>
<h2 id="评价指标不可兼得"><a href="# 评价指标不可兼得" class="headerlink" title="评价指标不可兼得"></a>评价指标不可兼得 </h2><p> 人们通常需要「更快的」服务，但什么是「更快的」服务？</p>
<ul>
<li>在传输文件时，高带宽是更快的；</li>
<li>在玩游戏时，低延迟是更快的；</li>
<li>这两个因素是独立的。</li>
</ul>
<p>评价指标的期望：</p>
<ul>
<li>减少响应时间：及时处理用户的输出，并尽快将输出提供给用户；</li>
<li>减少平均响应时间的波动：在交互系统中，可预测性比高差异性低平均更重要；</li>
<li>增加吞吐量：减少开销（操作系统开销、上下文切换）、高效利用系统资源（CPU、I/O 设备）；</li>
<li>减少等待时间：减少每个进程的等待时间。</li>
</ul>
<blockquote>
<p>其实这些指标是有矛盾的，比如 <strong> 很难同时满足 </strong> 最小响应时间和最大吞吐量，要么只顾及某一点，要么对两点进行折中。</p>
</blockquote>
<ul>
<li>吞吐量是操作系统的计算带宽。</li>
<li>响应时间是操作系统的计算延迟。</li>
</ul>
<h2 id="将「公平」作为重要指标"><a href="# 将「公平」作为重要指标" class="headerlink" title="将「公平」作为重要指标"></a>将「公平」作为重要指标</h2><ul>
<li>保证每个进程占用相同的 CPU 时间。<ul>
<li>这公平吗？如果一个用户比其他用户运行更多的进程怎么办？</li>
</ul>
</li>
<li>保证每个进程等待相同的时间。</li>
<li>公平通常会增加平均响应时间。</li>
</ul>
<h1 id="调度算法"><a href="# 调度算法" class="headerlink" title="调度算法"></a>调度算法 </h1><h2 id="先来先服务算法（FCFS）"><a href="# 先来先服务算法（FCFS）" class="headerlink" title="先来先服务算法（FCFS）"></a> 先来先服务算法（FCFS）</h2><p>先来先服务算法（First Come First Served, FCFS）为非抢占式算法。</p>
<p><strong>调度策略：依据进程进入就绪状态的先后顺序调度</strong>。</p>
<ul>
<li>如果当前运行的进程进入阻塞或结束状态时，就绪队列中的下一个进程会得到 CPU。</li>
</ul>
<img src="../images/os-kernel/chapter8/fcfs-algorithm.png" alt="先来先服务算法" width="80%" height="80%">

<p>如上图，如果就绪队列前面的进程执行时间较长，周转时间会边长，如果用户请求后面的进程，可能会等待较长时间。</p>
<h3 id="算法特点"><a href="# 算法特点" class="headerlink" title="算法特点"></a>算法特点 </h3><p> 优点：简单。</p>
<p>缺点：</p>
<ul>
<li>平均等待时间波动较大；</li>
<li>花费时间少的任务可能排在花费时间长的任务后面；</li>
<li>可能导致 I/O 和 CPU 之间的重叠处理（一起闲、一起忙）：CPU 密集型进程会导致 I/O 设备闲置时，I/O 密集型进程也在等待。</li>
</ul>
<h2 id="短进程优先算法（SPN-SRT）"><a href="# 短进程优先算法（SPN-SRT）" class="headerlink" title="短进程优先算法（SPN/SRT）"></a>短进程优先算法（SPN/SRT）</h2><p>在 FCFS 算法中可以观察到，如果把短进程排到前面，周转时间会下降。因此，短进程优先调度算法被提出。</p>
<ul>
<li>短进程优先算法：Shortest Process Next, SPN</li>
<li>短作业优先算法：Shortest Job First, SJF</li>
<li>最短剩余时间优先算法：Shortest Remaining Time, SRT</li>
</ul>
<blockquote>
<p>SPN 和 SJF 是同一个算法的两种不同叫法，为非抢占式算法；而 SRT 是可抢占式 SPN 算法。</p>
</blockquote>
<p>短进程优先算法 <strong> 调度策略：按照预测的完成时间来将任务入队</strong>（队列内时间越短的任务越靠前）。</p>
<img src="../images/os-kernel/chapter8/spn-algorithm.png" alt="短进程优先算法" width="80%" height="80%">

<p>如上图，就绪队列中的四个进程 <code>w, x, y, z</code> 的完成时间分别是 <code>9, 12, 34, 62</code>，因此进程 <code>w</code> 在队列头、进程 <code>z</code> 在队列尾。</p>
<blockquote>
<p>在抢占式 SRT 调度算法中，如果发现某个进程比当前进程的剩余时间片还短，则 <strong> 抢占 CPU 并运行该进程</strong>。在 SPN 调度算法中，不可抢占，会将该进程放到就绪队列最前面。</p>
</blockquote>
<h3 id="最优平均周转时间"><a href="# 最优平均周转时间" class="headerlink" title="最优平均周转时间"></a>最优平均周转时间 </h3><p> 短进程优先算法具有最优平均周转时间。</p>
<img src="../images/os-kernel/chapter8/spn-turnaround.png" alt="SPN 最优平均周转时间" width="80%" height="80%">

<p>如上图，如果按进程的完成时间从短到长来调度，可以证明其具有最优的平均周转时间。其它情况下，如将 <code>P3</code> 安排在 <code>P5</code> 后运行，则不具有最优的平均周转时间。</p>
<h3 id="算法特点 -1"><a href="# 算法特点 -1" class="headerlink" title="算法特点"></a>算法特点</h3><p>SPN (SJF) 调度算法的问题：</p>
<ul>
<li><strong>可能会导致饥饿</strong>：当有连续的短任务流时，长任务可能会被短任务持续占用 CPU，导致长任务等待时间增加，可能出现饥饿现象。</li>
<li><strong>需要预测下一个 CPU 突发持续时间（进程在一次调度中连续占用 CPU 的时间长度）</strong>。<ul>
<li>简单的解决：询问用户。但如果用户欺骗呢？就杀死进程！那如果用户不知道怎么办？</li>
</ul>
</li>
</ul>
<h3 id="进程执行时间预估"><a href="# 进程执行时间预估" class="headerlink" title="进程执行时间预估"></a>进程执行时间预估 </h3><p><strong> 用历史 </strong> 的执行时间 $t_{n}$ 和预估时间 $\tau_{n}$ <strong>来估计未来 </strong> 的执行时间 $\tau_{n+1}$。其中，$t_{n}$ 为第 $n$ 次 <strong> 实际的 </strong>CPU 突发的持续时间，$\tau_{n}$ 为第 $n$ 次<strong> 预估的</strong>CPU 突发的持续时间。</p>
<p>$$<br>\tau_{n+1} = \alpha t_{n} + (1 - \alpha)\tau_{n}, \quad \alpha \in [0, 1]<br>$$</p>
<h2 id="最高响应比优先算法（HRRN）"><a href="# 最高响应比优先算法（HRRN）" class="headerlink" title="最高响应比优先算法（HRRN）"></a>最高响应比优先算法（HRRN）</h2><p>最高响应比优先算法（Highest Response Ratio Next, HRRN）为非抢占式调度算法。</p>
<p><strong>调度策略：选择就绪就绪队列中响应比最高的进程</strong>。其中，响应比 $R = \frac{w + s}{s} = 1 + \frac{w}{s}$，$w$ 表示等待时间（waiting time），$s$ 表示服务执行时间（service time）。</p>
<h3 id="算法特点 -2"><a href="# 算法特点 -2" class="headerlink" title="算法特点"></a>算法特点</h3><ul>
<li>在短进程优先算法的基础上改进，关注进程的等待时间：<ul>
<li>不再仅仅考虑执行时间 $s$ 参数，也增加了等待时间 $w$ 参数。</li>
</ul>
</li>
<li>防止长任务被无限期推迟。</li>
<li><strong>依然需要预估服务执行时间</strong>。</li>
</ul>
<h2 id="时间片轮询算法（RR）"><a href="# 时间片轮询算法（RR）" class="headerlink" title="时间片轮询算法（RR）"></a>时间片轮询算法（RR）</h2><p>时间片轮询算法（Round Robin, RR）将为每个进程被分配一个固定的时间片，<strong>当一个进程的时间片用完后，它会被剥夺 CPU，并放到就绪队列的末尾，等待下一次调度</strong>。</p>
<p>这种方式使得每个进程能够公平地分享 CPU 时间，避免了长时间的饥饿现象。同时，时间片轮转算法也 <strong> 具有抢占性</strong>，因为当一个进程的时间片用完时，它可以被剥夺 CPU，并让其他进程获得执行的机会。</p>
<p>时间片轮询算法 <strong> 调度策略：使用时间片和抢占来轮流执行就绪队列中的任务</strong>。一个进程的时间片用完后，按 FCFS 算法切换到下一个就绪进程。</p>
<img src="../images/os-kernel/chapter8/rr-algorithm.png" alt="时间片轮询算法" width="80%" height="80%">

<h3 id="轮询算法示例"><a href="# 轮询算法示例" class="headerlink" title="轮询算法示例"></a>轮询算法示例 </h3><p> 假设有如下进程：</p>
<table>
<thead>
<tr>
<th align="center">进程</th>
<th align="center">执行时间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">P1</td>
<td align="center">53</td>
</tr>
<tr>
<td align="center">P2</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">P3</td>
<td align="center">68</td>
</tr>
<tr>
<td align="center">P4</td>
<td align="center">24</td>
</tr>
</tbody></table>
<p>假设为进程分配的时间片为 20，进程没有 I/O 等待，那么进程调度的甘特图为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        | P1  | P2 | P3  | P4  | P1  | P3  | P4 | P1 | P3  | P3 |</span><br><span class="line">    ----|-----|----|-----|-----|-----|-----|----|----|-----|----|---&gt;</span><br><span class="line">time    0    20   28    48    68    88    108  112  125   145  153</span><br><span class="line">gap       20    8    20    20    20    20    4    13   20    8</span><br></pre></td></tr></table></figure>

<p>每个进程的等待时间为：<br>$$<br>\begin{cases}<br>P1 = (68-20) + (112-88) = 72 \\<br>P2 = (20-0) = 20 \\<br>P3 = (28-0) + (88-48) + (125-108) = 85 \\<br>P4 = (48-0) + (108-68) = 88<br>\end{cases}<br>$$</p>
<p>平均等待时间为：<br>$$<br>P_{avg} = (72+20+85+88)/4 = 66.25<br>$$</p>
<blockquote>
<p>一般 FCFS 算法比 RR 算法的平均等待时间更短——这是因为 FCFS 中没有频繁的上下文切换（一个进程执行完毕后，才会切换一次上下文，执行下一个进程）。但是，FCFS 达不到像 RR 那样及时响应每一个进程。</p>
</blockquote>
<h3 id="算法特点 -3"><a href="# 算法特点 -3" class="headerlink" title="算法特点"></a>算法特点</h3><ul>
<li>RR 花销：额外的上下文切换（以保证每个进程都有机会被执行）。</li>
<li>若时间片分配太大：<ul>
<li>进程等待时间过长；</li>
<li>极限情况下会退化成 FCFS 算法。</li>
</ul>
</li>
<li>若时间片分配太小：<ul>
<li>反应迅速；</li>
<li>吞吐量因大量的上下文切换开销而受到影响。</li>
</ul>
</li>
</ul>
<p>目标：</p>
<ul>
<li>选择一个合适的时间片大小</li>
<li>经验规则：维持上下文切换的开销在 1% 以内（占程序运行），是可以接受的。</li>
</ul>
<h2 id="多级队列（MQ）"><a href="# 多级队列（MQ）" class="headerlink" title="多级队列（MQ）"></a>多级队列（MQ）</h2><p>多级队列（Multilevel Queues, MQ）<strong>将进程放在多个就绪队列，每个队列具有不同的优先级</strong>。</p>
<p>就绪队列被划分成多个独立的队列：</p>
<ul>
<li>比如，前台（交互）、后台（批处理）</li>
</ul>
<p>每个队列拥有自己的调度策略：</p>
<ul>
<li>比如，前台（RR）、后台（FCFS）</li>
</ul>
<p>调度必须在不同的队列间进行：</p>
<ul>
<li>以固定优先级方式调度：先处理前台队列，再处理后台队列。<ul>
<li>可能造成饥饿。</li>
</ul>
</li>
<li>以时间片轮询方式调度：每个队列都得到一个确定的能够调度其进程的 CPU 总时间。<ul>
<li>比如，80% 给使用 RR 的前台，20% 给使用 FCFS 的后台。</li>
</ul>
</li>
</ul>
<h3 id="算法特点 -4"><a href="# 算法特点 -4" class="headerlink" title="算法特点"></a>算法特点</h3><ul>
<li>保证公平性的同时，尽量减少进程的等待时间。</li>
<li>高优先级队列中的进程可以立即执行。</li>
<li>低优先级队列中的进程可以获得更多的时间片来执行，从而增加了它们完成的机会。</li>
<li>可以根据进程的行为动态地调整优先级。</li>
</ul>
<h2 id="多级反馈队列（MFQ）"><a href="# 多级反馈队列（MFQ）" class="headerlink" title="多级反馈队列（MFQ）"></a>多级反馈队列（MFQ）</h2><p>在多级队列中，各个队列之间是没有交互的。进一步改进，<strong>进程可在不同队列间移动的多级队列算法 </strong>，即多级反馈队列（Multilevel Feedback Queues, MFQ）算法，它<strong> 可以根据情况（反馈）调整进程的优先级、队列</strong>。</p>
<ol>
<li>初始时，所有进程都被放入最高优先级的队列中。</li>
<li>当一个进程获得执行时，它被分配一个时间片来执行，如果在时间片用完之前进程没有完成，<strong>它将被移到下一个较低优先级的队列中</strong>。</li>
<li>如果一个进程在一个较低优先级队列中 <strong> 等待了一段时间仍然没有执行，它可以被提升到更高优先级的队列中</strong>。</li>
</ol>
<img src="../images/os-kernel/chapter8/mfq-algorithm.png" alt="多级反馈队列算法" width="80%" height="80%">

<h3 id="算法特点 -5"><a href="# 算法特点 -5" class="headerlink" title="算法特点"></a>算法特点 </h3><p> 优点：</p>
<ul>
<li>CPU 密集型任务的优先级下降很快；</li>
<li>I/O 密集型任务停留在高优先级（这是因为这种进程存在 I/O 等待，分配给它的时间片用不完，不会被降级）。</li>
</ul>
<h1 id="调度算法总结"><a href="# 调度算法总结" class="headerlink" title="调度算法总结"></a>调度算法总结</h1><table>
<thead>
<tr>
<th>调度算法</th>
<th>特点</th>
<th>是否可抢占</th>
<th>是否饥饿</th>
</tr>
</thead>
<tbody><tr>
<td>先来先服务（FCFS）</td>
<td>不公平，平均等待时间较长</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>短进程优先（SPN / SRT）</td>
<td>不公平，平均等待时间较短，需要预估进程执行时间</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>最高响应比优先（HRRN）</td>
<td>不公平，考虑等待时间和执行时间的比例，防止长任务被无限期推迟</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>时间片轮循（RR）</td>
<td>公平，但是平均等待时间较长</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>多级反馈队列（MFQ）</td>
<td>结合多种算法，根据进程需求动态调整优先级</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>公平共享调度（FSS）</td>
<td>公平是第一要素</td>
<td>是</td>
<td>否</td>
</tr>
</tbody></table>
<blockquote>
<p>参考资料：<br>1：<a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a><br>2：<a href="https://blog.csdn.net/weixin_53407527/article/details/125097356">https://blog.csdn.net/weixin_53407527/article/details/125097356</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>调度算法</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>调度算法</tag>
        <tag>进程调度</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之二叉树的遍历</title>
    <url>/posts/230905224335.html</url>
    <content><![CDATA[<h2 id="二叉树的遍历"><a href="# 二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历 </h2><p> 二叉树是一种非常重要的数据结构，很多其它数据结构都是基于二叉树的基础演变而来的。</p>
<p>所谓遍历 Traversal 是指沿着某条搜索路线，依次对树中每个结点均做一次且仅做一次访问。</p>
<p>对于二叉树，有深度遍历和广度遍历，深度遍历有前序、中序以及后序遍历三种方法，广度遍历即我们平常所说的层次遍历。因为树的定义本身就是递归定义，因此采用递归的方法去实现树的三种遍历不仅容易理解而且代码很简洁，而对于广度遍历来说，需要其他数据结构的支撑。</p>
<p>四种遍历的主要思想是：</p>
<ul>
<li><p>前序遍历：根节点 -&gt; 左子树 -&gt; 右子树</p>
</li>
<li><p>中序遍历：左子树 -&gt; 根节点 -&gt; 右子树</p>
</li>
<li><p>后续遍历：左子树 -&gt; 右子树 -&gt; 根节点</p>
</li>
<li><p>层序遍历：依二叉树的深度从左到右（右到左）按层遍历</p>
</li>
</ul>
<p>其中，前、中、后续指的是「根节点」的遍历顺序，例如前序遍历是先遍历根节点。</p>
<span id="more"></span>

<p>以下为一棵二叉树不同的遍历顺序以及实现方法（非递归实现 / 递归实现）：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \   \</span><br><span class="line">4   5   6</span><br><span class="line"></span><br><span class="line">层次遍历顺序：[1 2 3 4 5 6] / 非递归实现：队列 + BFS</span><br><span class="line">前序遍历顺序：[1 2 4 5 3 6] / 非递归实现：栈，递归实现：DFS</span><br><span class="line">中序遍历顺序：[4 2 5 1 3 6] / 非递归实现：栈，递归实现：DFS</span><br><span class="line">后序遍历顺序：[4 5 2 6 3 1] / 非递归实现：栈，递归实现：DFS</span><br></pre></td></tr></table></figure>

<p>层次遍历使用 BFS 实现，利用的就是 BFS 一层一层遍历的特性，而前序、中序、后序遍历利用了 DFS 实现。</p>
<blockquote>
<p>前序、中序、后序遍只是在对节点访问的顺序有一点不同，其它都相同。</p>
</blockquote>
<p>下面直接从 Leetcode 练习题，学习二叉树的不同遍历方法。</p>
<h3 id="二叉树的层序遍历"><a href="# 二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h3><blockquote>
<p>题目链接：<a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></p>
</blockquote>
<p><strong>题目</strong>：给定一个非空二叉树，返回一个由每层节点平均值组成的数组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">输出: [3, 14.5, 11]</span><br><span class="line">解释: 第 0 层的平均值是 3,  第 1 层是 14.5, 第 2 层是 11. 因此返回 [3, 14.5, 11].</span><br></pre></td></tr></table></figure>

<p><strong>层序遍历</strong>：利用队列实现二叉树的层序遍历。</p>
<p>python 双端队列实现二叉树的层序遍历：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">averageOfLevels</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">import</span> collections</span><br><span class="line">    queue = collections.deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        size = <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="built_in">sum</span>, tmp_size = <span class="number">0</span>, size</span><br><span class="line">        <span class="keyword">while</span> size &gt; <span class="number">0</span>:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            size -= <span class="number">1</span></span><br><span class="line">            <span class="built_in">sum</span> += node.val</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">        res.append(<span class="built_in">sum</span> / tmp_size)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>C 语言实现基于链表的队列，然后基于队列实现二叉树的层序遍历：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define the structure for a node in the queue</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define the structure for the queue</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    Node *front;</span><br><span class="line">    Node *rear;</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to create a new node</span></span><br><span class="line">Node *<span class="title function_">createNode</span><span class="params">(<span class="keyword">struct</span> TreeNode *data)</span> &#123;</span><br><span class="line">    Node *newNode = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to create an empty queue</span></span><br><span class="line">Queue* <span class="title function_">createQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    Queue *<span class="built_in">queue</span> = (Queue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to check if the queue is empty</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Queue *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to enqueue an element into the queue</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enQueue</span><span class="params">(Queue *<span class="built_in">queue</span>, <span class="keyword">struct</span> TreeNode *data)</span> &#123;</span><br><span class="line">    Node *newNode = createNode(data);</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear-&gt;next = newNode;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to dequeue an element from the queue</span></span><br><span class="line"><span class="keyword">struct</span> TreeNode *<span class="title function_">deQueue</span><span class="params">(Queue* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *temp = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">data</span> =</span> temp-&gt;data;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;front-&gt;next;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span>* <span class="title function_">averageOfLevels</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    <span class="type">double</span> *ans = (<span class="type">double</span> *)<span class="built_in">malloc</span>(<span class="number">10000</span> * <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">    Queue *<span class="built_in">queue</span> = createQueue();</span><br><span class="line">    enQueue(<span class="built_in">queue</span>, root);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> size = <span class="built_in">queue</span>-&gt;size;</span><br><span class="line">        <span class="type">int</span> tmp_size = size;</span><br><span class="line">        <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">node</span> =</span> deQueue(<span class="built_in">queue</span>);</span><br><span class="line">            sum += node-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">                enQueue(<span class="built_in">queue</span>, node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">                enQueue(<span class="built_in">queue</span>, node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[(*returnSize)++] = sum / tmp_size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter7.4 进程控制</title>
    <url>/posts/231218220813.html</url>
    <content><![CDATA[<p>本文主要介绍进程控制中的进程切换（进程的上下文切换）、进程创建 <code>fork()</code>、进程加载与执行 <code>exec()</code>、进程等待与终止 <code>wait(), exit()</code>。</p>
<span id="more"></span>

<h1 id="进程上下文切换"><a href="# 进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换 </h1><p> 进程的上下文切换（context switch）会停止当前运行的进程（从运行状态变成其它状态），并调度其它进程运行（从就绪状态变成运行状态）。</p>
<ul>
<li>在切换之前，<strong>存储 </strong> 进程的上下文；</li>
<li>在切换之后，<strong>恢复 </strong> 进程的上下文，即进程不能显示它曾经被暂停过；</li>
<li><strong>快速 </strong> 切换（进程的上下文切换非常频繁，通常在 10ms 左右）。</li>
</ul>
<p>需要存储什么上下文？</p>
<ul>
<li>各种寄存器信息（PC, SP, …）；</li>
<li>CPU 状态；</li>
<li>内存地址空间（大部分情况不用保存，因为不同进程的地址空间各占一块独立的区域，不会被别的进程访问）。</li>
</ul>
<p>进程的上下文切换示意图：</p>
<img src="../images/os-kernel/chapter7/context-switch.png" alt="上下文切换示意图" width="80%" height="80%">

<p>操作系统为活跃进程准备了进程控制块（PCB），并将其放在一个合适的队列里：</p>
<ul>
<li>就绪队列；</li>
<li>等待 I/O 队列（不同 I/O 设备对应着不同队列）；</li>
<li>僵尸队列。</li>
</ul>
<h1 id="进程创建"><a href="# 进程创建" class="headerlink" title="进程创建"></a>进程创建 </h1><p>Unix 进程创建的两个<strong> 系统调用</strong>：<code>fork()</code> 和 <code>exec()</code>：</p>
<ul>
<li><code>fork()</code> 把一个进程复制成二个进程：<ul>
<li><code>parent(old PID)</code> 和 <code>child(new PID)</code>，两个进程只有 <code>PID</code> 号不一样。</li>
</ul>
</li>
<li><code>exec()</code> 用新程序来重写当前进程，但不改变当前进程的 <code>PID</code> 号：<ul>
<li><code>exec(&#39;program&#39;, argc, argv0, argv1, ...);</code></li>
</ul>
</li>
</ul>
<p><strong>用 <code>fork()</code> 和 <code>exec()</code> 创建进程的示例程序</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父进程代码</span></span><br><span class="line"><span class="type">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// child process, Do anything</span></span><br><span class="line">    exec(<span class="string">&#x27;/path/to/program&#x27;</span>, argc, argv0, argv1, ...);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// parent process</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>fork()</code> 创建一个继承的子进程</strong>：</p>
<ul>
<li>它复制了父进程的所有变量、内存；</li>
<li>它复制了父进程的所有 CPU 寄存器（有一个寄存器例外）；</li>
<li><strong>开销昂贵</strong>。</li>
</ul>
<p><code>fork()</code> 的返回值：</p>
<ul>
<li>子进程的 <code>fork()</code> 返回 0，父进程的 <code>fork()</code> 返回子进程的 <code>PID</code> 号；</li>
<li><code>fork()</code> 的返回值可方便后续使用，子进程可使用 <code>getpid()</code> 获取 <code>PID</code> 号。</li>
</ul>
<p><strong><code>fork()</code> 的地址空间复制示意图</strong>：</p>
<img src="../images/os-kernel/chapter7/fork-copy-memory.png" alt="fork 地址空间复制" width="80%" height="80%">

<p>上图中，父进程在执行到 <code>fork()</code> 代码的时候，会复制一个子进程，然后父子进程相继向下执行，但是父进程和子进程的局部变量 <code>childPID</code> 的值不同，会进入不同的 <code>if</code> 分支继续执行。</p>
<p><strong><code>fork()</code> 的实现开销昂贵，在 99% 的情况下，我们在调用 <code>fork()</code> 之后调用<code>exec()</code></strong>，也就是说：</p>
<ul>
<li><code>fork()</code> 操作的内存复制是没有意义的；</li>
<li>子进程可能关闭打开的文件和连接。</li>
</ul>
<p>Unix 的 <code>vfork()</code>，有时也称为轻量级 <code>fork()</code>：</p>
<ul>
<li>一个创建进程的系统调用，<strong>不需要 </strong> 创建一个同样的内存映像；</li>
<li>子进程应该几乎立即调用<code>exec()</code>；</li>
<li>现在已不再使用，取而代之的是 Copy on Write (COW) 技术。</li>
</ul>
<h1 id="进程加载与执行"><a href="# 进程加载与执行" class="headerlink" title="进程加载与执行"></a>进程加载与执行 </h1><p> 使用系统调用 <code>exec()</code> 来加载程序，并取代当前运行的程序。</p>
<ul>
<li>它允许一个进程「加载」一个不同的程序，并从 <code>main(int argc, char *argv[])</code> 开始执行；</li>
<li>它允许一个进程指定参数的数量 <code>argc</code> 和字符串参数数组 <code>*argv[]</code>；</li>
</ul>
<p>如果调用成功，则是相同的进程，但是运行了一个不同的程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in the parent process</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// 是子进程</span></span><br><span class="line">        exec_status = exec(<span class="string">&quot;/bin/calc&quot;</span>, argc, argv0, argv1, ...);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123; <span class="comment">// 是父进程</span></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">        child_status = wait(pid);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* error occurred */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// calc main function</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> q = <span class="number">7</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="../images/os-kernel/chapter7/exec-system-call.png" alt="exec 系统调用" width="80%" height="80%">

<p>执行完 <code>exec()</code> 后，<code>pid</code> 改变了，<code>open files</code> 的路径也改变了；PCB 中的代码段完全被新的程序 <code>calc</code> 所替换，且执行地址也发生了变化。</p>
<h1 id="进程等待与终止"><a href="# 进程等待与终止" class="headerlink" title="进程等待与终止"></a>进程等待与终止 </h1><h2 id="进程等待"><a href="# 进程等待" class="headerlink" title="进程等待"></a> 进程等待</h2><p><strong><code>wait()</code> 系统调用的作用是父进程用来等待子进程的结束</strong>：</p>
<ul>
<li>子进程结束时，通过 <code>exit()</code> 向父进程返回一个值，父进程通过 <code>wait()</code> 接收并处理返回值。</li>
</ul>
<blockquote>
<p>子进程无法释放掉自己的 PCB，父进程在子进程执行结束后，接收返回值，帮助子进程释放内存中的 PCB 等资源。</p>
</blockquote>
<p><strong><code>wait()</code> 系统调用的功能</strong>：</p>
<ul>
<li>有子进程存活时，会使父进程进入等待状态，来等待子进程的结束。当子进程调用 <code>exit()</code> 时，操作系统会解锁父进程，并将 <code>exit()</code> 的返回值作为父进程中 <code>wait()</code> 的返回值。</li>
<li>无子进程存活时，<code>wait()</code> 立即返回。</li>
<li>有僵尸进程等待时，<code>wait()</code> 立即返回其中一个僵尸进程的返回值。</li>
</ul>
<blockquote>
<p>僵尸进程（Zombie Process）是指一个已经完成执行（子进程已经终止），但是父进程尚未调用 <code>wait()</code> 或 <code>waitpid()</code> 来获取子进程的终止状态的进程。</p>
</blockquote>
<h2 id="进程终止"><a href="# 进程终止" class="headerlink" title="进程终止"></a>进程终止 </h2><p> 进程结束执行时调用 <code>exit()</code>，完成进程资源回收。</p>
<p><strong><code>exit()</code> 系统调用的功能</strong>：</p>
<ul>
<li>将调用参数作为进程的「结果」；</li>
<li>关闭所有打开的文件、链接等占用资源；</li>
<li>释放内存；</li>
<li>释放大部分进程相关的内核数据结构；</li>
<li>检查是否父进程是存活着的：<ul>
<li>若存活，则保留结果的值知道父进程需要它，进入僵尸（zombie/defunct）状态。</li>
<li>若没有存活，则释放所有的数据结构，进程结束死亡。</li>
</ul>
</li>
<li>清理所有等待的僵尸进程。</li>
</ul>
<blockquote>
<p>进程终止是最终的垃圾收集（资源回收）。</p>
</blockquote>
<h1 id="进程控制 -vs- 进程状态"><a href="# 进程控制 -vs- 进程状态" class="headerlink" title="进程控制 vs. 进程状态"></a>进程控制 vs. 进程状态</h1><img src="../images/os-kernel/chapter7/process-control-vs-process-state.png" alt="进程控制与进程状态" width="80%" height="80%">

<p>执行 <code>exec()</code> 时，进程可能处于不同的状态。</p>
<blockquote>
<p>参考资料：<br>1：<a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a><br>2：<a href="https://blog.csdn.net/weixin_53407527/article/details/125027431">https://blog.csdn.net/weixin_53407527/article/details/125027431</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>进程与线程</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>上下文切换</tag>
        <tag>进程控制</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之优先队列（堆实现）</title>
    <url>/posts/231019102311.html</url>
    <content><![CDATA[<p>优先队列（priority queue）是最重要的元素始终位于最前面的队列。与普通队列不同的是，优先队列中的元素并不是按照先进先出的顺序进行处理，而是根据其优先级决定处理顺序，具有较高优先级的元素会优先被处理。<br>优先队列可以是最大优先队列（最大的元素在前）或最小优先队列（最小的元素在先）。优先队列对于需要处理大数据量，并且需要反复确定哪一个现在是最大的或最小（最重要）的数据的算法非常有用。</p>
<span id="more"></span>

<h2 id="优先队列的实现方式"><a href="# 优先队列的实现方式" class="headerlink" title="优先队列的实现方式"></a>优先队列的实现方式 </h2><p> 在实现上，优先队列可以使用不同的数据结构来实现，例如堆、二叉搜索树、有序动态数组等。</p>
<ol>
<li><strong>使用有序动态数组实现</strong>：将最重要的数据放在数组的末尾。<ul>
<li>缺点：插入新数据很慢，因为插入的数据必须保证数组依然有序。这就需要利用二分搜索算法确定插入的位置，并使用线性时间向后移动数组，以便新数据插入到那里。</li>
</ul>
</li>
<li><strong>使用平衡二叉树实现</strong>：这对于构建双端优先队列非常有用，因为它同时有效地实现了「查找最小值」和「查找最大值」（最重要和最不重要）。</li>
<li><strong>使用堆实现</strong>：堆是实现优先队列的天然数据结构。事实上，堆和优先队列这两个术语经常被用作同义词。<ul>
<li>优点：堆比有序动态数组更有效，因为堆只需部分排序，堆的插入和删除操作都是 <code>O(log n)</code> 时间复杂度。</li>
</ul>
</li>
</ol>
<blockquote>
<p>使用堆来实现优先队列是最常见和高效的方式。</p>
</blockquote>
<h2 id="基于堆实现优先队列"><a href="# 基于堆实现优先队列" class="headerlink" title="基于堆实现优先队列"></a>基于堆实现优先队列 </h2><p><a href="https://pursue26.github.io/posts/231018102559.html"> 数据结构之堆基础与堆结构（数组实现）</a>介绍了堆的基本理论知识和最大堆的实现。因此，我们基于这篇文章中实现的最大堆，进行简单的修改，实现优先队列这种数据结构。</p>
<h3 id="优先队列结构定义"><a href="# 优先队列结构定义" class="headerlink" title="优先队列结构定义"></a>优先队列结构定义 </h3><p> 为了体现堆中数据的复杂性，不再使用整形数值作为堆中的数据，而是使用结构体作为堆中的数据节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义堆中的数据, 不同优先级的待学习课程</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">    <span class="type">char</span> *course;</span><br><span class="line">&#125; Node_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Heap</span> &#123;</span></span><br><span class="line">    Node_t *heap;   <span class="comment">// 堆的数组</span></span><br><span class="line">    <span class="type">int</span> size;       <span class="comment">// 堆的当前大小</span></span><br><span class="line">    <span class="type">int</span> capacity;   <span class="comment">// 堆的容量</span></span><br><span class="line">&#125; PriorityQueue_t;</span><br></pre></td></tr></table></figure>

<h3 id="优先队列完整代码"><a href="# 优先队列完整代码" class="headerlink" title="优先队列完整代码"></a>优先队列完整代码 </h3><p> 这里，我们直接给出优先队列数据结构的完整代码，不明白的函数可以参考 <a href="https://pursue26.github.io/posts/231018102559.html"> 数据结构之堆基础与堆结构（数组实现）</a>中对应的小节。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义堆中的数据, 不同优先级的待学习课程</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">    <span class="type">char</span> *course;</span><br><span class="line">&#125; Node_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Heap</span> &#123;</span></span><br><span class="line">    Node_t *heap;   <span class="comment">// 堆的数组</span></span><br><span class="line">    <span class="type">int</span> size;       <span class="comment">// 堆的当前大小</span></span><br><span class="line">    <span class="type">int</span> capacity;   <span class="comment">// 堆的容量</span></span><br><span class="line">&#125; PriorityQueue_t;</span><br><span class="line"></span><br><span class="line">PriorityQueue_t* <span class="title function_">initPriorityQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PriorityQueue_t *<span class="built_in">queue</span> = (PriorityQueue_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(PriorityQueue_t));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;heap = (Node_t *)<span class="built_in">malloc</span>(capacity * <span class="keyword">sizeof</span>(Node_t));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;capacity = capacity;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getParentIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (index - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getLeftChildIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getRightChildIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (index &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(Node_t *s1, Node_t *s2)</span> &#123;</span><br><span class="line">    Node_t temp = *s1;</span><br><span class="line">    <span class="built_in">memcpy</span>(s1, s2, <span class="keyword">sizeof</span>(Node_t));</span><br><span class="line">    <span class="built_in">memcpy</span>(s2, &amp;temp, <span class="keyword">sizeof</span>(Node_t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">siftUp</span><span class="params">(PriorityQueue_t *<span class="built_in">queue</span>, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    Node_t *heap = <span class="built_in">queue</span>-&gt;heap;</span><br><span class="line">    <span class="type">int</span> parentIndex = getParentIndex(index);</span><br><span class="line">    <span class="keyword">while</span> ((index &gt; <span class="number">0</span>) &amp;&amp; (heap[index].priority &gt; heap[parentIndex].priority)) &#123;</span><br><span class="line">        swap(&amp;(heap[index]), &amp;(heap[parentIndex]));</span><br><span class="line">        index = parentIndex;  <span class="comment">// 交换节点后, 更新当前节点的位置</span></span><br><span class="line">        parentIndex = getParentIndex(index);  <span class="comment">// 重新获取父节点位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">siftDown</span><span class="params">(PriorityQueue_t* <span class="built_in">queue</span>, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxIndex = index;</span><br><span class="line">    <span class="type">int</span> leftChildIndex = getLeftChildIndex(index);</span><br><span class="line">    <span class="type">int</span> rightChildIndex = getRightChildIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来的两个判断为找出具有更大值的孩子的索引</span></span><br><span class="line">    <span class="keyword">if</span> (leftChildIndex &lt; <span class="built_in">queue</span>-&gt;size &amp;&amp; <span class="built_in">queue</span>-&gt;heap[leftChildIndex].priority &gt; <span class="built_in">queue</span>-&gt;heap[maxIndex].priority) &#123;</span><br><span class="line">        maxIndex = leftChildIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rightChildIndex &lt; <span class="built_in">queue</span>-&gt;size &amp;&amp; <span class="built_in">queue</span>-&gt;heap[rightChildIndex].priority &gt; <span class="built_in">queue</span>-&gt;heap[maxIndex].priority) &#123;</span><br><span class="line">        maxIndex = rightChildIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index != maxIndex) &#123;</span><br><span class="line">        swap(&amp;(<span class="built_in">queue</span>-&gt;heap[index]), &amp;(<span class="built_in">queue</span>-&gt;heap[maxIndex]));</span><br><span class="line">        siftDown(<span class="built_in">queue</span>, maxIndex);  <span class="comment">// 递归方式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(PriorityQueue_t *<span class="built_in">queue</span>, Node_t *node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;size &gt;= <span class="built_in">queue</span>-&gt;capacity) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Queue is full!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;heap[<span class="built_in">queue</span>-&gt;size] = *node;  <span class="comment">// 存储在堆数组的最后一个索引后面</span></span><br><span class="line">    siftUp(<span class="built_in">queue</span>, <span class="built_in">queue</span>-&gt;size);  <span class="comment">// 进行堆化中的上浮操作</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">peek</span><span class="params">(PriorityQueue_t *<span class="built_in">queue</span>, Node_t* top)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(top, <span class="number">0</span>, <span class="keyword">sizeof</span>(Node_t));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Queue is empty!\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(top, &amp;(<span class="built_in">queue</span>-&gt;heap[<span class="number">0</span>]), <span class="keyword">sizeof</span>(Node_t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop</span><span class="params">(PriorityQueue_t *<span class="built_in">queue</span>, Node_t* top)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(top, <span class="number">0</span>, <span class="keyword">sizeof</span>(Node_t));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Queue is empty!\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(top, &amp;(<span class="built_in">queue</span>-&gt;heap[<span class="number">0</span>]), <span class="keyword">sizeof</span>(Node_t));</span><br><span class="line">        <span class="built_in">queue</span>-&gt;heap[<span class="number">0</span>] = <span class="built_in">queue</span>-&gt;heap[<span class="built_in">queue</span>-&gt;size - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">queue</span>-&gt;size--;</span><br><span class="line">        siftDown(<span class="built_in">queue</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printPriorityQueue</span><span class="params">(PriorityQueue_t *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Priority queue:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">queue</span>-&gt;size; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;    %s: %d\n&quot;</span>, <span class="built_in">queue</span>-&gt;heap[i].course, <span class="built_in">queue</span>-&gt;heap[i].priority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyPriorityQueue</span><span class="params">(PriorityQueue_t *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">queue</span>-&gt;heap);</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">10</span>, capacity = <span class="number">10</span>;</span><br><span class="line">    Node_t node[] = &#123;</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="string">&quot;Computer Science&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">7</span>, <span class="string">&quot;Discrete Mathematics&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">26</span>, <span class="string">&quot;Data Structures and Algorithms&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">25</span>, <span class="string">&quot;Operating Systems&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">19</span>, <span class="string">&quot;C Programming Languages&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">17</span>, <span class="string">&quot;Computer Networks&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="string">&quot;Database Management Systems&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">90</span>, <span class="string">&quot;Artificial Intelligence&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, <span class="string">&quot;Linear Algebra&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">36</span>, <span class="string">&quot;Calculus&quot;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    PriorityQueue_t *<span class="built_in">queue</span> = initPriorityQueue(capacity);</span><br><span class="line">    Node_t *topNode = (Node_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node_t));</span><br><span class="line">    <span class="built_in">memset</span>(topNode, <span class="number">0</span>, <span class="keyword">sizeof</span>(Node_t));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        push(<span class="built_in">queue</span>, &amp;(node[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    printPriorityQueue(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    peek(<span class="built_in">queue</span>, topNode);</span><br><span class="line">    <span class="keyword">if</span> (topNode-&gt;course &amp;&amp; topNode != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Priority queue top course: %s\n&quot;</span>, topNode-&gt;course);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pop(<span class="built_in">queue</span>, topNode);</span><br><span class="line">    <span class="keyword">if</span> (topNode-&gt;course &amp;&amp; topNode != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Priority queue pop course: %s\n&quot;</span>, topNode-&gt;course);</span><br><span class="line">    &#125;</span><br><span class="line">    printPriorityQueue(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        pop(<span class="built_in">queue</span>, topNode);</span><br><span class="line">        <span class="keyword">if</span> (topNode-&gt;course &amp;&amp; topNode != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Priority queue pop course: %s\n&quot;</span>, topNode-&gt;course);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(topNode);</span><br><span class="line">    destroyPriorityQueue(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Priority queue:</span><br><span class="line">    Artificial Intelligence: 90</span><br><span class="line">    Calculus: 36</span><br><span class="line">    Computer Networks: 17</span><br><span class="line">    Operating Systems: 25</span><br><span class="line">    Data Structures and Algorithms: 26</span><br><span class="line">    Discrete Mathematics: 7</span><br><span class="line">    Database Management Systems: 1</span><br><span class="line">    Computer Science: 2</span><br><span class="line">    Linear Algebra: 3</span><br><span class="line">    C Programming Languages: 19</span><br><span class="line">Priority queue top course: Artificial Intelligence</span><br><span class="line">Priority queue pop course: Artificial Intelligence</span><br><span class="line">Priority queue:</span><br><span class="line">    Calculus: 36</span><br><span class="line">    Data Structures and Algorithms: 26</span><br><span class="line">    Computer Networks: 17</span><br><span class="line">    Operating Systems: 25</span><br><span class="line">    C Programming Languages: 19</span><br><span class="line">    Discrete Mathematics: 7</span><br><span class="line">    Database Management Systems: 1</span><br><span class="line">    Computer Science: 2</span><br><span class="line">    Linear Algebra: 3</span><br><span class="line">Priority queue pop course: Calculus</span><br><span class="line">Priority queue pop course: Data Structures and Algorithms</span><br><span class="line">Priority queue pop course: Operating Systems</span><br><span class="line">Priority queue pop course: C Programming Languages</span><br><span class="line">Priority queue pop course: Computer Networks</span><br><span class="line">Priority queue pop course: Discrete Mathematics</span><br><span class="line">Priority queue pop course: Linear Algebra</span><br><span class="line">Priority queue pop course: Computer Science</span><br><span class="line">Priority queue pop course: Database Management Systems</span><br><span class="line">Queue is empty!</span><br></pre></td></tr></table></figure>

<p>在这个代码中，你可能已经注意到函数 <code>peek</code> 和 <code>pop</code> 的返回值类型是 <code>void</code>，且增加了一个入参 <code>Node_t *</code>。这是因为，这里实现的堆优先队列中存储的是复杂的结构体，我们在获取堆顶数据或弹出堆顶数据时，需要保存数据的所有内容。完成这个目的可以考虑以下两种方式：</p>
<ol>
<li>增加一个 <code>Node_t *</code> 入参：将外部申请的一块空间的地址传进来，用于保存堆顶数据，同时也可以处理堆优先队列为空的分支。这种方式，在读取数据及时的情况下，可以实现重复利用这块空间。</li>
<li>将函数 <code>peek</code> 和 <code>pop</code> 的返回值修改为 <code>Node_t *</code>：这种方式需要在函数内部 <code>malloc</code> 一块空间用于保存返回的数据块，后续需要由用户手动释放每次函数调用所申请的空间，避免内存泄漏。<ul>
<li>这种方式，需要多次 <code>malloc</code> 申请空间和多次 <code>free</code> 释放空间，且没有尽可能地遵循谁申请谁释放的原则。</li>
<li><strong>我们不能将堆顶的地址直接作为函数的返回值，因为堆顶的地址的数据是不固定的（在堆化时会被修改）</strong>。</li>
</ul>
</li>
</ol>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://github.com/kodecocodes/swift-algorithm-club/tree/master/Priority%20Queue">Priority Queue in swift-algorithm-club</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>优先队列</category>
      </categories>
      <tags>
        <tag>优先队列</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之双端队列（链表实现）</title>
    <url>/posts/231017154121.html</url>
    <content><![CDATA[<p>队列提供了一种先进先出（FIFO, First-In First-Out）的存储结构。在 <a href="https://pursue26.github.io/posts/231017105123.html"> 数据结构之队列（链表实现）</a>中，我们介绍了链表实现的队列数据结构，但这种普通的队列只能从尾部插入节点、从首部删除节点。</p>
<p>双端队列（Deque, double-ended queue）是普通队列的扩展，是指允许两端都可以进行入队和出队操作的队列，它不遵循 FIFO 原则。这篇文章扩展了 <a href="https://pursue26.github.io/posts/231017105123.html"> 数据结构之队列（链表实现）</a>，实现了基于链表的双端队列。</p>
<span id="more"></span>

<h2 id="FIFO 队列结构和接口"><a href="#FIFO 队列结构和接口" class="headerlink" title="FIFO 队列结构和接口"></a>FIFO 队列结构和接口 </h2><p> 下面是 <a href="https://pursue26.github.io/posts/231017105123.html"> 数据结构之队列（链表实现）</a>中实现的普通队列的数据结构和 API 接口。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagTreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagTreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagTreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagLinkedNode</span> &#123;</span></span><br><span class="line">    TreeNode_t *data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagLinkedNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LinkedNode_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagQueue</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    LinkedNode_t *front;</span><br><span class="line">    LinkedNode_t *rear;</span><br><span class="line">&#125; Queue_t;</span><br><span class="line"></span><br><span class="line">Queue_t *<span class="title function_">createQueue</span><span class="params">(<span class="type">int</span> max_size)</span>;</span><br><span class="line">LinkedNode_t *<span class="title function_">createNode</span><span class="params">(TreeNode_t *data)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Queue_t *<span class="built_in">queue</span>)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Queue_t *<span class="built_in">queue</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">enQueue</span><span class="params">(Queue_t *<span class="built_in">queue</span>, TreeNode_t *data)</span>;</span><br><span class="line">TreeNode_t *<span class="title function_">deQueue</span><span class="params">(Queue_t* <span class="built_in">queue</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(Queue_t* <span class="built_in">queue</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">freeQueue</span><span class="params">(Queue_t* <span class="built_in">queue</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>为了实现双端队列，我们需要在普通队列的基础上，增加两个操作：</p>
<ol>
<li>一个就是在队列首部执行入队操作（插入节点），我们使用接口 <code>void enQueueFront(Queue_t *queue, TreeNode_t *data)</code>；</li>
<li>另一个就是在队列尾部执行出队操作（删除节点），我们使用接口 <code>TreeNode_t *deQueueRear(Queue_t* queue)</code>。</li>
</ol>
<p>下面就来实现这两个接口。为了一致，这里不再修改队列结构体的别名从 <code>Queue_t</code> 到 <code>Deque_t</code>。</p>
<h2 id="双端队列之队首入队操作"><a href="# 双端队列之队首入队操作" class="headerlink" title="双端队列之队首入队操作"></a>双端队列之队首入队操作</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">enQueueFront</span><span class="params">(Queue_t *<span class="built_in">queue</span>, TreeNode_t *data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;queue is full.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LinkedNode_t *newNode = createNode(data);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">            <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newNode-&gt;next = <span class="built_in">queue</span>-&gt;front;  <span class="comment">// 新节点指向队列头结点</span></span><br><span class="line">            <span class="built_in">queue</span>-&gt;front = newNode;  <span class="comment">// 新节点成为队列头结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;size += <span class="number">1</span>;  <span class="comment">// 更新队列大小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>普通队列在队尾入队的过程是：队列尾指针指向新入队的节点，然后更新队列尾指针为该节点地址。与普通队列在队尾入队操作不同的是，双端队列在队首入队的过程是：新节点指向队列头指针，然后更新队列头指针为新节点地址。</p>
<h2 id="双端队列之队尾出队操作"><a href="# 双端队列之队尾出队操作" class="headerlink" title="双端队列之队尾出队操作"></a>双端队列之队尾出队操作</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode_t *<span class="title function_">deQueueRear</span><span class="params">(Queue_t* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedNode_t *prev = <span class="literal">NULL</span>;</span><br><span class="line">    LinkedNode_t *curr = <span class="built_in">deque</span>-&gt;front;</span><br><span class="line">    <span class="keyword">while</span> (curr-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode_t *data = curr-&gt;data;</span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        prev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">deque</span>-&gt;rear = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">deque</span>-&gt;front = <span class="built_in">deque</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">deque</span>-&gt;size -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(curr);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>普通队列执行出队操作的时间复杂度为 <code>O(1)</code>，而这里双端队列在队尾出队的操作的时间复杂度为 <code>O(n)</code>。这是因为普通队列在队首出队后，可以直接通过 <code>queue-&gt;front-&gt;next</code> 操作确定新的头指针，而双端队列在队尾出队后，只能通过遍历队列中的节点，找到倒数第二个节点，才能确定新的尾指针。</p>
<p>那么，如何提高双端队列的队尾出队操作的时间复杂度呢？</p>
<p>可以通过将链表修改为双端链表，即不再只有一个 <code>next</code> 指针，同时还有一个 <code>prev</code> 指针，用于指向链表中当前节点的上一个节点。这样就可以实现 <code>O(1)</code> 时间复杂度的双端队列的队尾出队操作。</p>
<h2 id="双端链表实现的双端队列"><a href="# 双端链表实现的双端队列" class="headerlink" title="双端链表实现的双端队列"></a>双端链表实现的双端队列 </h2><h3 id="结构示意图"><a href="# 结构示意图" class="headerlink" title="结构示意图"></a> 结构示意图 </h3><p> 下面是一个示意双端队列的线条图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">front                                               rear</span><br><span class="line">  ↓                                                  ↓</span><br><span class="line">+---+            +---+            +---+            +---+</span><br><span class="line">|   | ← prev   ← |   | ← prev   ← |   | ← prev   ← |   |</span><br><span class="line">|   |            |   |            |   |            |   |</span><br><span class="line">|   | → next   → |   | → next   → |   | → next   → |   |</span><br><span class="line">+---+            +---+            +---+            +---+</span><br></pre></td></tr></table></figure>

<p>在双端队列中，有两个方向：从头 <code>front</code> 到尾 <code>rear</code> 和从尾到头。每个节点都有一个指向前一个节点的指针 <code>prev</code> 和一个指向后一个节点的指针 <code>next</code>。<code>front</code> 指向队列的头部节点，<code>rear</code> 指向队列的尾部节点。</p>
<img src="../images/data-structure/deque-struct.png" alt="双端队列数据结构" width="80%" height="80%">

<h3 id="完整代码"><a href="# 完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagTreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagTreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagTreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagLinkedNode</span> &#123;</span></span><br><span class="line">    TreeNode_t *data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagLinkedNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagLinkedNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LinkedNode_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagQueue</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    LinkedNode_t *front;</span><br><span class="line">    LinkedNode_t *rear;</span><br><span class="line">&#125; Deque_t;</span><br><span class="line"></span><br><span class="line">Deque_t *<span class="title function_">createDeque</span><span class="params">(<span class="type">int</span> max_size)</span> &#123;</span><br><span class="line">    Deque_t *<span class="built_in">deque</span> = (Deque_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Deque_t));</span><br><span class="line">    <span class="built_in">deque</span>-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">deque</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">deque</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">deque</span>-&gt;max = max_size;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">deque</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LinkedNode_t *<span class="title function_">createNode</span><span class="params">(TreeNode_t *data)</span> &#123;</span><br><span class="line">    LinkedNode_t *newNode = (LinkedNode_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkedNode_t));</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Deque_t *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">deque</span>-&gt;size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Deque_t *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">deque</span>-&gt;size &gt;= <span class="built_in">deque</span>-&gt;max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enDeque</span><span class="params">(Deque_t *<span class="built_in">deque</span>, TreeNode_t *data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;deque is full.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LinkedNode_t *newNode = createNode(data);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">            <span class="built_in">deque</span>-&gt;front = <span class="built_in">deque</span>-&gt;rear = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LinkedNode_t *curRear = <span class="built_in">deque</span>-&gt;rear;</span><br><span class="line">            curRear-&gt;next = newNode;  <span class="comment">// 尾指针链接新数据</span></span><br><span class="line">            <span class="built_in">deque</span>-&gt;rear = newNode;  <span class="comment">// 尾指针指向新数据</span></span><br><span class="line">            <span class="built_in">deque</span>-&gt;rear-&gt;prev = curRear;  <span class="comment">// !! 双端队列!!, 尾指针的上一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">deque</span>-&gt;size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enDequeFront</span><span class="params">(Deque_t *<span class="built_in">deque</span>, TreeNode_t *data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;deque is full.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LinkedNode_t *newNode = createNode(data);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">            <span class="built_in">deque</span>-&gt;front = <span class="built_in">deque</span>-&gt;rear = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newNode-&gt;next = <span class="built_in">deque</span>-&gt;front;  <span class="comment">// 新节点指向队列头结点</span></span><br><span class="line">            <span class="built_in">deque</span>-&gt;front-&gt;prev = newNode;  <span class="comment">// !! 双端队列!!, 头指针的上一个节点</span></span><br><span class="line">            <span class="built_in">deque</span>-&gt;front = newNode;  <span class="comment">// 新节点成为队列头结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">deque</span>-&gt;size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode_t *<span class="title function_">deDeque</span><span class="params">(Deque_t* <span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedNode_t *node = <span class="built_in">deque</span>-&gt;front;</span><br><span class="line">    TreeNode_t *data = node-&gt;data;</span><br><span class="line">    <span class="comment">// 根据当前队列中节点的数量，决定是否同步更新队列的尾指针</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">deque</span>-&gt;size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">deque</span>-&gt;front = <span class="built_in">deque</span>-&gt;front-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">deque</span>-&gt;front = <span class="built_in">deque</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">deque</span>-&gt;size -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode_t *<span class="title function_">deDequeRear</span><span class="params">(Deque_t* <span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedNode_t *node = <span class="built_in">deque</span>-&gt;rear;</span><br><span class="line">    TreeNode_t *data = node-&gt;data;</span><br><span class="line">    <span class="comment">// 根据当前队列中节点的数量，决定是否同步更新队列的尾指针</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">deque</span>-&gt;size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">deque</span>-&gt;rear = <span class="built_in">deque</span>-&gt;rear-&gt;prev;</span><br><span class="line">        <span class="built_in">deque</span>-&gt;rear-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">deque</span>-&gt;front = <span class="built_in">deque</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">deque</span>-&gt;size -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printDeque</span><span class="params">(Deque_t* <span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Deque is empty\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Deque: &quot;</span>);</span><br><span class="line">        LinkedNode_t *node = <span class="built_in">deque</span>-&gt;front;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;data-&gt;val);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeDeque</span><span class="params">(Deque_t* <span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">deque</span> &amp;&amp;(!isEmpty(<span class="built_in">deque</span>)))&#123;</span><br><span class="line">        LinkedNode_t *node = <span class="built_in">deque</span>-&gt;front;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            LinkedNode_t *tmp = node-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(node);</span><br><span class="line">            node = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(<span class="built_in">deque</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    Deque_t *<span class="built_in">deque</span> = createDeque(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一些测试用的树节点</span></span><br><span class="line">    TreeNode_t *node = (TreeNode_t *)<span class="built_in">malloc</span>(<span class="number">5</span> * <span class="keyword">sizeof</span>(TreeNode_t));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        node[i].val = <span class="number">10</span> + i;</span><br><span class="line">        node[i].left = <span class="literal">NULL</span>;</span><br><span class="line">        node[i].right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printDeque(<span class="built_in">deque</span>);</span><br><span class="line"></span><br><span class="line">    enDequeFront(<span class="built_in">deque</span>, &amp;node[<span class="number">0</span>]);</span><br><span class="line">    enDequeFront(<span class="built_in">deque</span>, &amp;node[<span class="number">1</span>]);</span><br><span class="line">    enDeque(<span class="built_in">deque</span>, &amp;node[<span class="number">2</span>]);</span><br><span class="line">    printDeque(<span class="built_in">deque</span>);</span><br><span class="line"></span><br><span class="line">    enDequeFront(<span class="built_in">deque</span>, &amp;node[<span class="number">3</span>]);</span><br><span class="line">    enDeque(<span class="built_in">deque</span>, &amp;node[<span class="number">4</span>]);</span><br><span class="line">    printDeque(<span class="built_in">deque</span>);</span><br><span class="line"></span><br><span class="line">    TreeNode_t *data1 = deDeque(<span class="built_in">deque</span>);</span><br><span class="line">    TreeNode_t *data2 = deDequeRear(<span class="built_in">deque</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Removed data: %d %d\n&quot;</span>, data1-&gt;val, data2-&gt;val); <span class="comment">// 实际工程中要先判非空再取数据</span></span><br><span class="line">    TreeNode_t *data3 = deDequeRear(<span class="built_in">deque</span>);</span><br><span class="line">    TreeNode_t *data4 = deDeque(<span class="built_in">deque</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Removed data: %d %d\n&quot;</span>, data3-&gt;val, data4-&gt;val);</span><br><span class="line">    printDeque(<span class="built_in">deque</span>);</span><br><span class="line"></span><br><span class="line">    freeDeque(<span class="built_in">deque</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放测试用的树节点内存</span></span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Deque is empty</span><br><span class="line">Deque: 11 10 12</span><br><span class="line">Deque: 13 11 10 12 14</span><br><span class="line">Removed data: 13 14</span><br><span class="line">Removed data: 12 11</span><br><span class="line">Deque: 10</span><br></pre></td></tr></table></figure>

<p>在上述代码中，与 <a href="https://pursue26.github.io/posts/231017105123.html#%20%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C"> 普通队列中的入队操作 </a> 的两点区别是：</p>
<ol>
<li>在双端链表实现的双端队列中，在 <strong> 队尾入队 </strong> 操作中增加了队尾指针的前一个节点的代码 <code>deque-&gt;rear-&gt;prev = curRear</code>，服务于队尾出队的操作。</li>
<li>在双端链表实现的双端队列中，在 <strong> 队首入队 </strong> 操作中增加了队首指针的前一个节点的代码 <code>deque-&gt;front-&gt;prev = newNode</code>，服务于队尾出队的操作。</li>
</ol>
<p>为什么序号 2 中的那行代码也服务于队尾出队操作呢？</p>
<p>设想以下操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">enDequeFront(<span class="built_in">deque</span>, &amp;node[<span class="number">0</span>]);</span><br><span class="line">enDequeFront(<span class="built_in">deque</span>, &amp;node[<span class="number">1</span>]);</span><br><span class="line">deDequeRear(<span class="built_in">deque</span>);</span><br></pre></td></tr></table></figure>
<p>一开始就往队首插入节点，如果没有代码 <code>deque-&gt;front-&gt;prev = newNode</code>，那么尾结点的前一个节点地址将为 <code>NULL</code>，则无法更新指定尾结点。</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>队列</category>
      </categories>
      <tags>
        <tag>队列</tag>
        <tag>双端队列</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之堆栈（数组实现）</title>
    <url>/posts/231016161508.html</url>
    <content><![CDATA[<p>栈与数组类似，但功能受限，只能通过 push 将新元素添加到栈的顶部，通过 pop 从栈中移除顶部的元素，并通过 peek 查看顶部的元素而不将其弹出。栈提供了后进先出（LIFO, last-in first-out）的顺序，最后推入的元素将在下一次弹出时首先出栈。</p>
<span id="more"></span>

<h2 id="堆栈的实现方式"><a href="# 堆栈的实现方式" class="headerlink" title="堆栈的实现方式"></a>堆栈的实现方式 </h2><p> 在 C 语言中，可以使用以下方法来实现堆栈（stack）数据结构：</p>
<ol>
<li><p>使用数组：可以使用一个固定大小的数组来表示堆栈。堆栈有两个重要的指针：一个是指向栈顶的指针，另一个是指向栈底的指针。在数组中，栈顶指针指向最新添加的元素，栈底指针指向最旧的元素。可以使用数组的索引来实现栈的推入 (push) 和弹出 (pop) 操作。</p>
</li>
<li><p>使用链表：可以使用链表来表示堆栈。链表中的每个节点包含一个元素和一个指向下一个节点的指针。栈顶指针指向链表的第一个节点，栈底指针指向链表的最后一个节点。入栈操作将创建一个新节点，并将其插入链表的开头；出栈操作将删除链表的第一个节点。</p>
</li>
</ol>
<blockquote>
<p>链表实现堆栈时，<strong>采用头插法</strong>，即在链表头结点前插入新节点、删除节点。这样做，方便 push 和 pop 操作；如果在链表的最后插入新节点，那么在 pop 操作时，更新栈顶的节点指针将会很麻烦 &amp; 费时。</p>
</blockquote>
<p>这篇文章将介绍使用数组实现堆栈这种数据结构。</p>
<h2 id="数组实现堆栈"><a href="# 数组实现堆栈" class="headerlink" title="数组实现堆栈"></a>数组实现堆栈 </h2><h3 id="定义并初始化堆栈结构"><a href="# 定义并初始化堆栈结构" class="headerlink" title="定义并初始化堆栈结构"></a> 定义并初始化堆栈结构 </h3><p> 使用一个固定长度的数组来实现具有先进先出的堆栈结构。为了将不同的堆栈和栈顶位置对应起来，这里使用一个结构体来组合堆栈和栈顶位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE (3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCEPTION_VALUE (-1) </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data[MAX_SIZE];  <span class="comment">// 数组实现堆栈</span></span><br><span class="line">    <span class="type">int</span> top;  <span class="comment">// 初始化栈顶位置</span></span><br><span class="line">&#125; Stack;</span><br></pre></td></tr></table></figure>

<h3 id="初始化堆栈"><a href="# 初始化堆栈" class="headerlink" title="初始化堆栈"></a>初始化堆栈</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// memset(stack-&gt;data, 0, MAX_SIZE * sizeof(int));</span></span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断堆栈是否为空"><a href="# 判断堆栈是否为空" class="headerlink" title="判断堆栈是否为空"></a>判断堆栈是否为空</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断堆栈是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断堆栈是否已满"><a href="# 判断堆栈是否已满" class="headerlink" title="判断堆栈是否已满"></a>判断堆栈是否已满</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断堆栈是否已满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == MAX_SIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="入栈操作"><a href="# 入栈操作" class="headerlink" title="入栈操作"></a>入栈操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元素入栈</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">push</span><span class="params">(Stack *<span class="built_in">stack</span>, <span class="type">int</span> element)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is full\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;data[++(<span class="built_in">stack</span>-&gt;top)] = element;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="出栈操作"><a href="# 出栈操作" class="headerlink" title="出栈操作"></a>出栈操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元素出栈</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[(<span class="built_in">stack</span>-&gt;top)--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了区分栈空时的返回值与正常出栈的数据，需要定义异常值为不会出现在正常数据中的值；或者修改函数的返回值为指针类型，返回值不为空时对应着有效数据。</p>
<h3 id="获取栈顶元素"><a href="# 获取栈顶元素" class="headerlink" title="获取栈顶元素"></a>获取栈顶元素</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取栈顶元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="打印堆栈数据"><a href="# 打印堆栈数据" class="headerlink" title="打印堆栈数据"></a>打印堆栈数据</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印堆栈中的元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printStack</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">stack</span>-&gt;top; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">stack</span>-&gt;data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组实现堆栈完整代码"><a href="# 数组实现堆栈完整代码" class="headerlink" title="数组实现堆栈完整代码"></a>数组实现堆栈完整代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE (3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCEPTION_VALUE (-1) </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data[MAX_SIZE];  <span class="comment">// 数组实现堆栈</span></span><br><span class="line">    <span class="type">int</span> top;  <span class="comment">// 初始化栈顶位置</span></span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// memset(stack-&gt;data, 0, MAX_SIZE * sizeof(int));</span></span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == MAX_SIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">push</span><span class="params">(Stack *<span class="built_in">stack</span>, <span class="type">int</span> element)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is full\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;data[++(<span class="built_in">stack</span>-&gt;top)] = element;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[(<span class="built_in">stack</span>-&gt;top)--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printStack</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">stack</span>-&gt;top; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">stack</span>-&gt;data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> *argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    Stack stack1;</span><br><span class="line">    initStack(&amp;stack1);</span><br><span class="line"></span><br><span class="line">    printStack(&amp;stack1);</span><br><span class="line">    push(&amp;stack1, <span class="number">1</span>);</span><br><span class="line">    push(&amp;stack1, <span class="number">2</span>);</span><br><span class="line">    push(&amp;stack1, <span class="number">3</span>);</span><br><span class="line">    printStack(&amp;stack1);</span><br><span class="line">    push(&amp;stack1, <span class="number">4</span>);</span><br><span class="line">    printStack(&amp;stack1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Pop element: %d\n&quot;</span>, pop(&amp;stack1));</span><br><span class="line">    printStack(&amp;stack1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Top element: %d\n&quot;</span>, peek(&amp;stack1));</span><br><span class="line">    printStack(&amp;stack1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stack is empty</span><br><span class="line">Stack: 1 2 3</span><br><span class="line">Stack is full</span><br><span class="line">Stack: 1 2 3</span><br><span class="line">Pop element: 3</span><br><span class="line">Stack: 1 2</span><br><span class="line">Top element: 2</span><br><span class="line">Stack: 1 2</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>堆栈</category>
      </categories>
      <tags>
        <tag>堆栈</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之并查集（数组实现）</title>
    <url>/posts/231023164532.html</url>
    <content><![CDATA[<p>并查集（Union-Find Disjoint Sets, UFDS）是一种用于处理一些不相交集合的数据结构，实现为一个森林，其中的每棵树表示一个集合，树中的节点表示对应集合中的元素。</p>
<p>顾名思义，并查集支持两种操作：</p>
<ul>
<li>合并（Union）：合并两个元素所属集合（合并对应的树），通常是将两个集合的根节点连接在一起。</li>
<li>查找（Find）：查找某个元素所属集合，通常是找到该元素所在集合的根节点，这可以用于判断两个元素是否属于同一集合。</li>
</ul>
<span id="more"></span>

<p>下图是一个具有四个不相交集合的树构成的森林。<br><img src="../images/data-structure/UFDS-demo3.png" alt=""></p>
<h2 id="并查集应用场景"><a href="# 并查集应用场景" class="headerlink" title="并查集应用场景"></a>并查集应用场景 </h2><p> 并查集数据结构最常见的应用是跟踪无向图的连接组件。它还用于实现 Kruskal 算法的高效版本，以查找图的最小生成树。</p>
<p>关于并查集的应用，后面的学习中再做整理~</p>
<h2 id="并查集实现"><a href="# 并查集实现" class="headerlink" title="并查集实现"></a>并查集实现 </h2><p> 上面介绍了什么是并查集，并给出了并查集支持的一些操作。下面开始，逐步实现基于数组的并查集。</p>
<h3 id="初始化"><a href="# 初始化" class="headerlink" title="初始化"></a>初始化 </h3><p><strong> 并查集的实现可以使用数组来表示每个元素所属的集合</strong>，其中：</p>
<ul>
<li>数组的索引表示元素的值；</li>
<li>数组的值表示该元素所属的集合的代表元素。</li>
</ul>
<blockquote>
<p>一般用树的根节点作为该集合的代表元素。</p>
</blockquote>
<p>初始时，每个元素都是独立的集合，它属于它自己（表示为一棵只有根节点的树），即每个元素的值和索引相同（将根节点的父亲设为自己）。</p>
<p>初始化时，就像这样，自己指向自己，树的高度为 0。<br><img src="../images/data-structure/UFDS-init.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化并查集</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> rank[], <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">        rank[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里 <code>rank[i]</code> 的值是以顶点 <code>i</code> 为根的子树高度的上限，它用作后面 <code>UnionSet(i, j)</code> 操作的引导启发式。先不用管 <code>rank[i]</code> 了，后面还会遇到。</p>
</blockquote>
<h3 id="查找"><a href="# 查找" class="headerlink" title="查找"></a>查找 </h3><p> 就像文章一开头说的那样，并查集的查找操作，是查找某个元素所属集合，通常是找到该元素所在集合的根节点。具体地，</p>
<ul>
<li>查找当前元素的父元素，若父元素不是自己，则更新它为当前元素，并查找它的父元素，直到当前元素的父元素是自己为止。</li>
</ul>
<h4 id="并查集查找（迭代实现）"><a href="# 并查集查找（迭代实现）" class="headerlink" title="并查集查找（迭代实现）"></a>并查集查找（迭代实现）</h4><p>朴素的并查集查找操作（迭代实现）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找元素所属的集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (parent[x] != x) &#123;</span><br><span class="line">        x = parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="并查集查找（递归实现）"><a href="# 并查集查找（递归实现）" class="headerlink" title="并查集查找（递归实现）"></a>并查集查找（递归实现）</h4><p>朴素的并查集查找操作（递归实现）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找元素所属的集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[x] == x) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findSet(parent, parent[x]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="并查集查找（带路径压缩的递归实现）"><a href="# 并查集查找（带路径压缩的递归实现）" class="headerlink" title="并查集查找（带路径压缩的递归实现）"></a>并查集查找（带路径压缩的递归实现）</h4><p>想一想，一个集合中的所有元素，虽然有共同的代表元素，但是这棵树可能呈现不同的形状。</p>
<p><img src="../images/data-structure/UFDS-same-set.png" alt=""></p>
<p>上面这张图中，左边与右边集合中的元素一致，且代表元素都是 1，<strong>但是树的形状不同</strong>。这样的话，对于同一个元素（比如 4），查找到其代表元素 1 的迭代（递归）次数是不一样的，左边需要 3 次才能完成，而右边只需要 1 次就能完成。</p>
<p>因此，<strong>为了提高效率，就需要尽可能降低迭代（递归）次数。这就需要进行「路径压缩」</strong>。</p>
<p>想一想，上面递归方式实现的查找操作 <code>findSet(int parent[], int x)</code> 中，是查找元素 <code>x</code> 的代表元素并返回。在这个函数内部，如果当前元素的父元素不是代表元素，函数会递归的查找其父元素的代表元素（我们被划分在同一个集合中了，假如我的代表元素是 R，那么我的父元素的代表元素也是 R 呀）。</p>
<p>因此，我们可以 <strong> 在递归的过程中，更新当前元素的代表元素，从而实现「路径压缩」</strong>，以加快后续查找。</p>
<p>并查集查找操作（带路径压缩的递归实现）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找元素所属的集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[x] == x) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 路径压缩</span></span><br><span class="line">        parent[x] = findSet(parent, parent[x]);</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="路径压缩查找示例"><a href="# 路径压缩查找示例" class="headerlink" title="路径压缩查找示例"></a>路径压缩查找示例 </h4><p> 假如，我们有如下的不相交集合：<br><img src="../images/data-structure/UFDS-demo1.png" alt=""></p>
<p>现在，我们使用带路径压缩的并查集查找函数，查找元素 1 的代表元素，这一过程可以可视化为下面的动画。<br><img src="../images/data-structure/UFDS-demo2.gif" alt=""></p>
<blockquote>
<p>图中 <code>r</code> 就是 <code>rank</code> 的缩写，<code>s</code> 代表的是元素的数量。</p>
</blockquote>
<h3 id="合并"><a href="# 合并" class="headerlink" title="合并"></a>合并 </h3><p> 要合并两棵树（集合），我们只需要将一棵树的根节点连到另一棵树的根节点。要完成这一操作，我们需要：</p>
<ol>
<li>查找一个元素 <code>x</code> 的代表元素；</li>
<li>查找另一个元素 <code>y</code> 的代表元素；</li>
<li>若两者的代表元素不同，则将其中一棵树的根节点连接到另一棵树的根节点上；若两者的代表元素相同，则无需合并。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 合并两个集合</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unionSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> rootX = findSet(parent, x);</span><br><span class="line">    <span class="type">int</span> rootY = findSet(parent, y);</span><br><span class="line">    <span class="comment">// 属于不同集合</span></span><br><span class="line">    <span class="keyword">if</span> (rootX != rootY) &#123;</span><br><span class="line">        <span class="comment">// 将前者所在的树的根节点连接到后者所在的树的根节点上</span></span><br><span class="line">        parent[rootX] = rootY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启发式合并"><a href="# 启发式合并" class="headerlink" title="启发式合并"></a>启发式合并 </h3><p> 合并时，选择哪棵树的根节点作为新树的根节点会影响未来操作的复杂度。我们可以 <strong> 将节点较少或深度（树高）较小的树连接到另一棵</strong>，以免发生退化。</p>
<blockquote>
<p>这样做的目的是尽量避免将较大的树作为子树合并到较小的树上，从而保持树的平衡，减小树的高度。</p>
<p>在并查集中，「退化」指的是树结构变得非常不平衡，即树的高度非常大，接近于线性结构（如链表）。</p>
</blockquote>
<p>因此，在初始化小节中，数组 <code>rank[i]</code> 就是用来维护以顶点 <code>i</code> 为根的子树高度的上限，它就是在这里被使用的啦。</p>
<h4 id="启发式合并（以树高为标准）"><a href="# 启发式合并（以树高为标准）" class="headerlink" title="启发式合并（以树高为标准）"></a>启发式合并（以树高为标准）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">unionSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> rank[], <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> rootX = findSet(parent, x);</span><br><span class="line">    <span class="type">int</span> rootY = findSet(parent, y);</span><br><span class="line">    <span class="comment">// 属于不同集合</span></span><br><span class="line">    <span class="keyword">if</span> (rootX != rootY) &#123;</span><br><span class="line">        <span class="comment">// 将深度较小的树连到另一棵树</span></span><br><span class="line">        <span class="keyword">if</span> (rank[rootX] &lt; rank[rootY]) &#123;</span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootX] &gt; rank[rootY]) &#123;</span><br><span class="line">            parent[rootY] = rootX;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将前者所在的树的根节点连接到后者所在的树的根节点上</span></span><br><span class="line">            <span class="comment">// 被连接的树的高度将会加一, 对应的 rank 值加一</span></span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">            rank[rootY]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在初始化时，每个元素都是一个独立的集合，每个树的高度都为 0：</p>
<ul>
<li>在进行第一次集合合并时（比如元素 1 和元素 3），则 <code>unionSet(parent, rank, 1, 3)</code> 操作，会合并为一棵 <code>3-&gt;1</code> 的树，其中 3 为根节点，这棵新树会长高一个单位；</li>
<li>在进行第二次集合合并时（比如元素 1 和元素 4），则 <code>unionSet(parent, rank, 1, 4)</code> 操作，会合并为一棵 <code>4&lt;-3-&gt;1</code> 的树，其中 3 为根节点，由于 1 所在的树高大于 4 所在的树高，因此在合并后，树高不会变得更高，因此不会更新 <code>rank</code> 值。</li>
</ul>
<blockquote>
<p><strong>注意：在启发式合并的过程中，只能保证根节点对应 <code>rank</code> 值是正确的，不能保证其它位置的 <code>rank</code> 值的正确性</strong>。</p>
</blockquote>
<h4 id="启发式合并示例"><a href="# 启发式合并示例" class="headerlink" title="启发式合并示例"></a>启发式合并示例 </h4><p> 假如，我们有如下几个不相交集合：<br><img src="../images/data-structure/UFDS-demo3.png" alt=""></p>
<p>现在，我们使用以树高为标准的启发式合并，执行 <code>unionSet(parent, rank, 10, 8)</code>，这一过程可以可视化为下面的动画。<br><img src="../images/data-structure/UFDS-demo4.gif" alt=""></p>
<p>这里 <code>x = 10, y = 8</code> 与 <code>x = 8, y = 10</code> 执行后，得到的树是不一样的哦。</p>
<blockquote>
<p>你可能已经发现了：在执行合并的过程中，树也会被路径压缩，这是因为并查集的合并接口调用了查找接口。</p>
</blockquote>
<h3 id="相同集合"><a href="# 相同集合" class="headerlink" title="相同集合"></a>相同集合 </h3><p> 判断两个元素是否属于同一集合。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isSameSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> findSet(parent, x) == findSet(parent, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并查集复杂度"><a href="# 并查集复杂度" class="headerlink" title="并查集复杂度"></a>并查集复杂度 </h2><p> 时间复杂度：</p>
<ul>
<li>初始化：<code>O(n)</code></li>
<li>朴素查找：<code>O(n)</code></li>
<li>带路径压缩的查找：<code>O(h)</code>，可以优化至 <code>O(α(n))</code>，其中 <code>h</code> 是树的高度，足够平衡时 <code>h = log(n)</code>，<code>α</code> 是阿克曼函数</li>
<li>带路径压缩的合并：<code>O(h)</code>，可以优化至 <code>O(α(n))</code></li>
</ul>
<p>空间复杂度：<code>O(n)</code></p>
<blockquote>
<p>这里的并查集数据结构的实现，是采用的 Quick Union 方式，而不是 Quick Find 方式。</p>
</blockquote>
<h2 id="并查集完整代码测试"><a href="# 并查集完整代码测试" class="headerlink" title="并查集完整代码测试"></a>并查集完整代码测试 </h2><h3 id="完整代码"><a href="# 完整代码" class="headerlink" title="完整代码"></a> 完整代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> rank[], <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">        rank[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[x] == x) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 路径压缩</span></span><br><span class="line">        parent[x] = findSet(parent, parent[x]);</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unionSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> rank[], <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> rootX = findSet(parent, x);</span><br><span class="line">    <span class="type">int</span> rootY = findSet(parent, y);</span><br><span class="line">    <span class="comment">// 属于不同集合</span></span><br><span class="line">    <span class="keyword">if</span> (rootX != rootY) &#123;</span><br><span class="line">        <span class="comment">// 将深度较小的树连到另一棵树</span></span><br><span class="line">        <span class="keyword">if</span> (rank[rootX] &lt; rank[rootY]) &#123;</span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootX] &gt; rank[rootY]) &#123;</span><br><span class="line">            parent[rootY] = rootX;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将前者所在的树的根节点连接到后者所在的树的根节点上</span></span><br><span class="line">            <span class="comment">// 被连接的树的高度将会加一, 对应的 rank 值加一</span></span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">            rank[rootY]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isSameSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> findSet(parent, x) == findSet(parent, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试代码"><a href="# 测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE (101)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> rank[], <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">findSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unionSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> rank[], <span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">isSameSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> parent[MAX_SIZE];</span><br><span class="line">    <span class="type">int</span> rank[MAX_SIZE];</span><br><span class="line">    <span class="type">int</span> size = <span class="number">10</span>; <span class="comment">// 假设有 10 个元素，从 0 到 9 编号</span></span><br><span class="line"></span><br><span class="line">    init(parent, rank, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 findSet 函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(0): %d\n&quot;</span>, findSet(parent, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(1): %d\n&quot;</span>, findSet(parent, <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(2): %d\n&quot;</span>, findSet(parent, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 unionSet 函数</span></span><br><span class="line">    unionSet(parent, rank, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    unionSet(parent, rank, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    unionSet(parent, rank, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    unionSet(parent, rank, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">    unionSet(parent, rank, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(0): %d\n&quot;</span>, findSet(parent, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(1): %d\n&quot;</span>, findSet(parent, <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(2): %d\n&quot;</span>, findSet(parent, <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(3): %d\n&quot;</span>, findSet(parent, <span class="number">3</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(4): %d\n&quot;</span>, findSet(parent, <span class="number">4</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(5): %d\n&quot;</span>, findSet(parent, <span class="number">5</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(6): %d\n&quot;</span>, findSet(parent, <span class="number">6</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(7): %d\n&quot;</span>, findSet(parent, <span class="number">7</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(8): %d\n&quot;</span>, findSet(parent, <span class="number">8</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(9): %d\n&quot;</span>, findSet(parent, <span class="number">9</span>));</span><br><span class="line"></span><br><span class="line">    unionSet(parent, rank, <span class="number">6</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(6): %d\n&quot;</span>, findSet(parent, <span class="number">6</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(8): %d\n&quot;</span>, findSet(parent, <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 isSameSet 函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;isSameSet(0, 1): %d\n&quot;</span>, isSameSet(parent, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;isSameSet(2, 3): %d\n&quot;</span>, isSameSet(parent, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;isSameSet(1, 3): %d\n&quot;</span>, isSameSet(parent, <span class="number">1</span>, <span class="number">3</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;isSameSet(6, 9): %d\n&quot;</span>, isSameSet(parent, <span class="number">6</span>, <span class="number">9</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试结果"><a href="# 测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">findSet(0): 0</span><br><span class="line">findSet(1): 1</span><br><span class="line">findSet(2): 2</span><br><span class="line">findSet(0): 1</span><br><span class="line">findSet(1): 1</span><br><span class="line">findSet(2): 3</span><br><span class="line">findSet(3): 3</span><br><span class="line">findSet(4): 5</span><br><span class="line">findSet(5): 5</span><br><span class="line">findSet(6): 7</span><br><span class="line">findSet(7): 7</span><br><span class="line">findSet(8): 9</span><br><span class="line">findSet(9): 9</span><br><span class="line">findSet(6): 9</span><br><span class="line">findSet(8): 9</span><br><span class="line">isSameSet(0, 1): 1</span><br><span class="line">isSameSet(2, 3): 1</span><br><span class="line">isSameSet(1, 3): 0</span><br><span class="line">isSameSet(6, 9): 1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://visualgo.net/en/ufds">https://visualgo.net/en/ufds</a></li>
<li><a href="https://oi-wiki.org/ds/dsu">https://oi-wiki.org/ds/dsu</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>Disjoint-Set</tag>
        <tag>Union-Find</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之拓扑排序</title>
    <url>/posts/230916094606.html</url>
    <content><![CDATA[<h2 id="什么是拓扑排序"><a href="# 什么是拓扑排序" class="headerlink" title="什么是拓扑排序"></a>什么是拓扑排序 </h2><p> 引用百度百科的拓扑排序定义：</p>
<blockquote>
<p>对一个有向无环图（Directed Acyclic Graph, DAG）$G$ 进行拓扑排序，是将 $G$ 中所有顶点排成一个 <strong> 线性序列 </strong>，使得图中任意一对顶点 $u$ 和 $v$，若边 $&lt;u,v&gt; \in E(G)$，则 $u$ <strong> 在线性序列中出现在 </strong> $v$ 之前。通常，这样的线性序列称为满足拓扑次序（Topological Order）的序列，简称<strong> 拓扑序列</strong>。</p>
</blockquote>
<p>拓扑排序可以被理解为对一个有向无环图进行排序的操作。在这个排序中，图中的顶点被排列成一个线性序列，<strong>满足以下条件：对于图中的任意一对顶点 $u$ 和 $v$，如果存在一条边 $&lt;u,v&gt;$，那么在线性序列中，顶点 $u$ 出现在顶点 $v$ 之前</strong>。</p>
<p>换句话说，拓扑排序可以将有向无环图中的顶点按照它们的依赖关系排序，使得所有的依赖关系都被满足。这对于处理任务的依赖关系非常有用，例如工程项目中的任务调度，编译器中的源代码依赖等。</p>
<span id="more"></span>

<p>例如，下图中 <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code> 是一个正确的拓扑排序，每个节点都在它所依赖的节点后面。而 <code>1-&gt;2-&gt;4-&gt;3-&gt;5</code> 则不满足拓扑排序的要求，<code>4</code> 依赖于 <code>3</code>，却出现在了 <code>3</code> 前面。</p>
<p><img src="../images/data-structure/topo-sort.png" alt=""></p>
<h2 id="拓扑排序基本原理"><a href="# 拓扑排序基本原理" class="headerlink" title="拓扑排序基本原理"></a>拓扑排序基本原理 </h2><p> 拓扑排序（Topological Sorting）是一种用于有向无环图（DAG）的排序算法，它将图中的节点按照依赖关系进行排序，使得所有的依赖关系都被满足。</p>
<p>拓扑排序的一些重要知识点：</p>
<ol>
<li><p>有向无环图（DAG）：拓扑排序只能应用于没有环的有向图，因为有环的图存在循环依赖，无法进行拓扑排序。</p>
</li>
<li><p>入度和出度：在拓扑排序中，入度表示指向某个节点的边的数量，出度表示从某个节点发出的边的数量。</p>
</li>
<li><p>拓扑排序算法：拓扑排序算法可以通过深度优先搜索或广度优先搜索（Kahn 算法）来实现。<strong>DFS 通常使用递归或栈来实现，而 BFS 则使用队列来实现</strong>。</p>
</li>
<li><p>多个拓扑排序结果：一个有向图可能存在多种不同的拓扑排序结果，这取决于节点的访问顺序。一种常见的方法是使用优先队列或字典序来选择节点的顺序，以得到特定的排序结果。</p>
</li>
</ol>
<h3 id="要解决的问题"><a href="# 要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题 </h3><p> 对于有向图进行拓扑排序要解决两个问题：</p>
<ul>
<li>一是要判断待排序的有向图是不是无环；</li>
<li>二是按照依赖关系生成正确的序列。</li>
</ul>
<h3 id="基本思想"><a href="# 基本思想" class="headerlink" title="基本思想"></a>基本思想 </h3><p> 拓扑排序的基本思想是：</p>
<ul>
<li><p>入度思想：首先找到图中没有前驱节点的节点（即入度为 0 的节点），将其 <strong> 顺序 </strong> 加入结果列表中，并将其从图中删除。然后，继续寻找新的没有前驱节点的节点，并重复以上过程，直到所有的节点都被加入结果列表中或者无法再找到没有前驱节点的节点为止。</p>
</li>
<li><p>出度思想：首先找到图中没有后驱节点的节点（即出度为 0 的节点），将其 <strong> 逆序 </strong> 加入结果列表中，并将其从图中删除。然后，继续寻找新的没有后驱节点的节点，并重复以上过程，直到所有的节点都被加入结果列表中或者无法再找到没有后驱节点的节点为止。</p>
</li>
</ul>
<h3 id="BFS-Kaha 拓扑排序算法"><a href="#BFS-Kaha 拓扑排序算法" class="headerlink" title="BFS/Kaha 拓扑排序算法"></a>BFS/Kaha 拓扑排序算法 </h3><p> 拓扑排序的具体步骤：</p>
<ol>
<li>初始化一个结果列表（或者称为拓扑序列）和一个队列。</li>
<li>遍历图中的所有节点（对），统计每个节点的入度（即有多少条边指向该节点）。</li>
<li>将入度为 0 的节点加入队列中。</li>
<li>当队列不为空时，执行以下操作：<ul>
<li>取出队首节点，并将其加入结果列表中。</li>
<li>遍历该节点的所有邻接节点（即该节点指向的节点）：<ul>
<li>将邻接节点的入度减 1。</li>
<li>如果邻接节点的入度减为 0，将其加入队列中。</li>
</ul>
</li>
</ul>
</li>
<li>如果结果列表的长度等于图中的节点数，则说明拓扑排序成功，返回结果列表，表示拓扑序列。</li>
<li>如果结果列表的长度小于图中的节点数，则说明图中存在环，无法进行拓扑排序。</li>
</ol>
<p>通过循环找到入度为 0 的节点，并将其加入结果列表，然后更新与该节点相邻的节点的入度，重复此过程，最终得到一个满足拓扑次序的序列，或者判断出图中存在环。</p>
<blockquote>
<p>BFS / Kaha 拓扑排序算法是从入度的角度着手的，这种方法可称之为 <strong> 入度方法</strong>。</p>
</blockquote>
<h3 id="BFS 拓扑排序实现"><a href="#BFS 拓扑排序实现" class="headerlink" title="BFS 拓扑排序实现"></a>BFS 拓扑排序实现 </h3><p> 以 <a href="https://leetcode.cn/problems/course-schedule-ii/">Leetcode 课程表 II</a> 为例，给出 BFS 拓扑排序算法的实现过程。</p>
<p>题目大意：一共有 n 门课程，课程之间存在依赖关系，比如先修完 A 课程，才能修 B 课程。问这个学生能不能修完所有课程，能的话则返回一种可能的课程学习顺序。</p>
<p>代码实现中的关键变量：</p>
<ul>
<li><code>indegree[]</code>：初始化每个节点的入度，并随着节点出队更新入度值；</li>
<li><code>edges[][]</code>：记录每个节点影响的其它节点，用于该节点的入度变为 0 时更新“影响的其它节点”的入度值；</li>
<li><code>queue</code>：队列用于入队、出队所有入度为 0 的节点；</li>
<li><code>ans[]</code>：结果队列用于保存出队的节点；</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ELEM_TYPE int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Define the structure for a node in the queue</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ELEM_TYPE data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define the structure for the queue</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    Node* front;</span><br><span class="line">    Node* rear;</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to create a new node</span></span><br><span class="line">Node* <span class="title function_">createNode</span><span class="params">(ELEM_TYPE data)</span> &#123;</span><br><span class="line">    Node* newNode = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to create an empty queue</span></span><br><span class="line">Queue* <span class="title function_">createQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    Queue* <span class="built_in">queue</span> = (Queue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to check if the queue is empty</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Queue* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to enqueue an element into the queue</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enQueue</span><span class="params">(Queue* <span class="built_in">queue</span>, ELEM_TYPE data)</span> &#123;</span><br><span class="line">    Node* newNode = createNode(data);</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear-&gt;next = newNode;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to dequeue an element from the queue</span></span><br><span class="line">ELEM_TYPE <span class="title function_">deQueue</span><span class="params">(Queue* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* temp = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">    ELEM_TYPE data = temp-&gt;data;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;front-&gt;next;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">findOrder</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>** prerequisites, <span class="type">int</span> prerequisitesSize, <span class="type">int</span>* prerequisitesColSize, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> indegree[numCourses];  <span class="comment">// 每个节点的入度，入度为 0 表示不受其它节点影响 </span></span><br><span class="line">    <span class="type">int</span> **edges = (<span class="type">int</span> **)<span class="built_in">malloc</span>(numCourses * <span class="keyword">sizeof</span>(<span class="type">int</span> *));  <span class="comment">// 二维数组, 记录每个节点影响的节点们</span></span><br><span class="line">    <span class="type">int</span> edgeNums[numCourses];  <span class="comment">// 记录每个节点影响的节点数量, 用于动态扩展空间</span></span><br><span class="line">    <span class="type">int</span> *ans = (<span class="type">int</span> *)<span class="built_in">malloc</span>(numCourses * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">        indegree[i] = <span class="number">0</span>;</span><br><span class="line">        edgeNums[i] = <span class="number">0</span>;</span><br><span class="line">        edges[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">0</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 后续按需扩展</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历所有节点对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prerequisitesSize; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> suff = prerequisites[i][<span class="number">0</span>], pre = prerequisites[i][<span class="number">1</span>];</span><br><span class="line">        edgeNums[pre]++;  <span class="comment">// suff 受到了 pre 影响, 故 pre 节点影响的节点数量 +1</span></span><br><span class="line">        indegree[suff]++;  <span class="comment">// suff 受到了 pre 影响，其入度要 +1</span></span><br><span class="line">        edges[pre] = (<span class="type">int</span> *)<span class="built_in">realloc</span>(edges[pre], edgeNums[pre] * <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 扩展内存</span></span><br><span class="line">        edges[pre][edgeNums[pre] - <span class="number">1</span>] = suff;  <span class="comment">// 在索引(pre, 最后位置) 记录 suff</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue* <span class="built_in">queue</span> = createQueue();</span><br><span class="line">    <span class="comment">// 入度所有不受影响的节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            enQueue(<span class="built_in">queue</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        ELEM_TYPE cur = deQueue(<span class="built_in">queue</span>);</span><br><span class="line">        ans[count++] = cur;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历出队的节点影响的所有节点, 它们的受影响度将 -1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edgeNums[cur]; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> x = edges[cur][i];</span><br><span class="line">            indegree[x]--;</span><br><span class="line">            <span class="keyword">if</span> (indegree[x] == <span class="number">0</span>) &#123;</span><br><span class="line">                enQueue(<span class="built_in">queue</span>, x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">        <span class="built_in">free</span>(edges[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(edges);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断结果队列长度，确定是否可以完成拓扑排序</span></span><br><span class="line">    <span class="keyword">if</span> (count == numCourses) &#123;</span><br><span class="line">        (*returnSize) = count;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (*returnSize) = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DFS 拓扑排序算法"><a href="#DFS 拓扑排序算法" class="headerlink" title="DFS 拓扑排序算法"></a>DFS 拓扑排序算法</h3><p>DFS 拓扑排序算法的思想和 BFS 拓扑排序算法相似，但在具体步骤上有所不同。</p>
<p>DFS 拓扑排序算法的基本思想是：通过递归遍历图中的节点，<strong>从一个起始节点开始</strong>，当遍历到一个节点时，先将其所有未访问的邻居节点进行递归遍历，之后将当前节点添加到结果列表中。如果在递归的过程中，发现当遍历到一个节点时，存在已经被访问过的邻居节点，则说明途中存在环，无法进行拓扑排序。</p>
<p>DFS 拓扑排序的具体步骤如下：</p>
<ol>
<li>初始化一个空的结果列表和一个空的访问状态列表。</li>
<li>对于图中的每个节点，如果该节点未被访问，则调用 DFS 函数进行遍历。</li>
<li>在 DFS 函数中，首先将当前节点标记为正在访问。</li>
<li>递归遍历当前节点的所有未访问的邻居节点，将每个邻居节点作为新的起始节点进行递归遍历。</li>
<li>当没有未访问的邻居节点时，将当前节点的访问状态更新为已访问，并逆序添加到结果列表中。</li>
<li>最终，结果列表中的节点正序顺序即为 DFS 拓扑排序的结果。</li>
</ol>
<blockquote>
<p>需要注意的是：在进行 DFS 拓扑排序的过程中，如果发现某个节点的邻居节点已经被访问过（即已经在结果列表中），那么说明存在环，无法进行拓扑排序。在这种情况下，可以中断排序过程并返回一个表示存在环的标志。</p>
</blockquote>
<p>代码实现中的关键变量：</p>
<ul>
<li><code>visited[]</code>：记录每个节点的访问状态，0 表示未访问，1 表示正在访问，2 表示访问完成；</li>
<li><code>edges[][]</code>：记录每个节点所有邻居节点；</li>
<li><code>ans[]</code>：结果队列；</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span>* visited, <span class="type">int</span>** edges, <span class="type">int</span>* edgeNums, <span class="type">int</span>* ans, <span class="type">int</span>* cnt, <span class="type">bool</span>* valid)</span> &#123;</span><br><span class="line">    visited[node] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edgeNums[node]; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> neigNode = edges[node][i];</span><br><span class="line">        <span class="keyword">if</span> (visited[neigNode] == <span class="number">0</span>) &#123;</span><br><span class="line">            dfs(neigNode, visited, edges, edgeNums, ans, cnt, valid);</span><br><span class="line">            <span class="comment">// 这行代码测试发现不是必须的, 为什么不是必须的？加上可以有剪枝（提前终止）的作用</span></span><br><span class="line">            <span class="keyword">if</span> (!(*valid)) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (visited[neigNode] == <span class="number">1</span>) &#123;</span><br><span class="line">            *valid = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    visited[node] = <span class="number">2</span>;</span><br><span class="line">    ans[--(*cnt)] = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">findOrder</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>** prerequisites, <span class="type">int</span> prerequisitesSize, <span class="type">int</span>* prerequisitesColSize, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span>* visited = (<span class="type">int</span> *)<span class="built_in">malloc</span>(numCourses * <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 记录每一个节点的访问状态</span></span><br><span class="line">    <span class="type">int</span>** edges = (<span class="type">int</span> **)<span class="built_in">malloc</span>(numCourses * <span class="keyword">sizeof</span>(<span class="type">int</span> *));  <span class="comment">// 二维数组, 记录每个节点所有邻居节点</span></span><br><span class="line">    <span class="type">int</span>* edgeNums = (<span class="type">int</span> *)<span class="built_in">malloc</span>(numCourses * <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 记录每个节点的邻居节点数量</span></span><br><span class="line">    <span class="type">int</span>* ans = (<span class="type">int</span> *)<span class="built_in">malloc</span>(numCourses * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span> cnt = numCourses;</span><br><span class="line">    <span class="type">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, numCourses * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">memset</span>(edgeNums, <span class="number">0</span>, numCourses * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">        edges[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">0</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建邻接表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prerequisitesSize; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> suff = prerequisites[i][<span class="number">0</span>], pre = prerequisites[i][<span class="number">1</span>];  <span class="comment">// edge: pre-&gt;suff</span></span><br><span class="line">        edges[pre] = (<span class="type">int</span> *)<span class="built_in">realloc</span>(edges[pre], (edgeNums[pre] + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        edges[pre][edgeNums[pre]] = suff;</span><br><span class="line">        edgeNums[pre]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// DFS 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            dfs(i, visited, edges, edgeNums, ans, &amp;cnt, &amp;valid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">        <span class="built_in">free</span>(edges[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(edges);</span><br><span class="line">    <span class="built_in">free</span>(visited);</span><br><span class="line">    <span class="built_in">free</span>(edgeNums);</span><br><span class="line">    </span><br><span class="line">    *returnSize = (cnt &gt; <span class="number">0</span> || !valid) ? <span class="number">0</span> : numCourses;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考链接：<a href="https://jingsam.github.io/2020/08/11/topological-sort.html">https://jingsam.github.io/2020/08/11/topological-sort.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之链表（链式实现）</title>
    <url>/posts/231008213450.html</url>
    <content><![CDATA[<p>线性表中的「单链表」的实现，包括单链表的顺序存储（数组实现）和单链表的链式存储。<a href="https://pursue26.github.io/posts/231007174854.html">上篇文章 </a> 介绍了单链表的顺序存储（数组实现），这篇文章主要介绍单链表的链式存储（结构体指针实现）。</p>
<span id="more"></span>

<h2 id="链表的链式存储（结构体指针实现）"><a href="# 链表的链式存储（结构体指针实现）" class="headerlink" title="链表的链式存储（结构体指针实现）"></a>链表的链式存储（结构体指针实现）</h2><p>链表的 API 主要包括：</p>
<ul>
<li>创建并初始化链表</li>
<li>查找链表中的元素</li>
<li>向链表中插入元素</li>
<li>删除链表中的元素</li>
<li>获取链表的长度</li>
</ul>
<h3 id="链表结构定义"><a href="# 链表结构定义" class="headerlink" title="链表结构定义"></a>链表结构定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义链表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; Linked_t;</span><br></pre></td></tr></table></figure>

<p>这段代码定义了一个名为 <code>Linked_t</code> 的结构体，用来表示一个结构体实现的链表。</p>
<p>该结构体包含两个成员变量：</p>
<ol>
<li><code>int data</code>：一个整形变量，用来存储链表中的元素。</li>
<li><code>struct Node* next</code>：一个链表结构体指针，用于指向链表中当前结点的下一个结点的指针（地址）。</li>
</ol>
<p>链表中的不同元素，通过节点之间的指针首尾连接起来。</p>
<h3 id="创建并初始化链表"><a href="# 创建并初始化链表" class="headerlink" title="创建并初始化链表"></a>创建并初始化链表 </h3><p> 使用动态申请内存空间的方式创建并初始化一个链表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Linked_t *<span class="title function_">createNode</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Linked_t *linked = (Linked_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linked_t));</span><br><span class="line">    linked-&gt;data = data;</span><br><span class="line">    linked-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// printf(&quot;Linked_t size is %d bytes.\n&quot;, sizeof(linked));</span></span><br><span class="line">    <span class="keyword">return</span> linked;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查找链表中的元素"><a href="# 查找链表中的元素" class="headerlink" title="查找链表中的元素"></a>查找链表中的元素 </h3><p> 在链表中查找目标元素第一次出现时的结点，不存在则返回空。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Linked_t *<span class="title function_">findNode</span><span class="params">(Linked_t *linked, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    Linked_t *curNode = linked;</span><br><span class="line">    <span class="keyword">while</span> (curNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curNode-&gt;data == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> curNode;</span><br><span class="line">        &#125;</span><br><span class="line">        curNode = curNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 没有找到元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="向链表末尾插入元素"><a href="# 向链表末尾插入元素" class="headerlink" title="向链表末尾插入元素"></a>向链表末尾插入元素 </h3><p> 在链表末尾插入新结点，插入成功时返回链表头结点，失败时返回空地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Linked_t *<span class="title function_">insertTailNode</span><span class="params">(Linked_t *linked, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (linked == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;linked is NULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Linked_t *curNode = linked;</span><br><span class="line">    <span class="keyword">while</span> (curNode-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        curNode = curNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Linked_t *newNode = createNode(data);</span><br><span class="line">    curNode-&gt;next = newNode;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> linked;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="向链表指定结点前插入元素"><a href="# 向链表指定结点前插入元素" class="headerlink" title="向链表指定结点前插入元素"></a>向链表指定结点前插入元素 </h3><p> 在链表的指定结点前插入新结点，如果指定的结点为空，则在末尾插入结点，最后返回插入新结点后链表的头结点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Linked_t *<span class="title function_">insertNode</span><span class="params">(Linked_t *linked, Linked_t *node, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (linked == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;linked is NULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node == linked) &#123;  <span class="comment">// 在链表头结点前插入新结点</span></span><br><span class="line">        Linked_t *newNode = createNode(data);</span><br><span class="line">        newNode-&gt;next = linked;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> insertTailNode(linked, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Linked_t *preNode = linked;</span><br><span class="line">    Linked_t *curNode = preNode-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (curNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curNode == node) &#123;  <span class="comment">// 在链表结点中间插入新结点</span></span><br><span class="line">            Linked_t *newNode = createNode(data);</span><br><span class="line">            preNode-&gt;next = newNode;</span><br><span class="line">            newNode-&gt;next = curNode;</span><br><span class="line">            <span class="keyword">return</span> linked;</span><br><span class="line">        &#125;</span><br><span class="line">        preNode = curNode;</span><br><span class="line">        curNode = curNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The specified node does not exist in the linked list.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> linked;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除链表中的元素"><a href="# 删除链表中的元素" class="headerlink" title="删除链表中的元素"></a>删除链表中的元素 </h3><p> 删除链表中指定索引位置的元素，并返回新的链表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Linked_t *<span class="title function_">deleteNode</span><span class="params">(Linked_t *linked, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (linked == <span class="literal">NULL</span> || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> linked;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">        Linked_t *newHead = linked-&gt;next;</span><br><span class="line">        linked-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(linked);</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        Linked_t *preNode = linked, *curNode = preNode-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (curNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span> (cnt == index) &#123;</span><br><span class="line">                Linked_t *curNext = curNode-&gt;next;</span><br><span class="line">                curNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="built_in">free</span>(curNode);</span><br><span class="line">                preNode-&gt;next = curNext;</span><br><span class="line">                <span class="keyword">return</span> linked;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                preNnode = curNode;</span><br><span class="line">                curNode = curNode-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The specified index is illegal.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> linked;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取链表的长度"><a href="# 获取链表的长度" class="headerlink" title="获取链表的长度"></a>获取链表的长度 </h3><p> 获取链表中有效数据元素的长度（结点的数量）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getLinkedLength</span><span class="params">(Linked_t *linked)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (linked != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        linked = linked-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="释放链表空间"><a href="# 释放链表空间" class="headerlink" title="释放链表空间"></a>释放链表空间</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freeLinked</span><span class="params">(Linked_t *linked)</span> &#123;</span><br><span class="line">    Linked_t *curNode = linked;</span><br><span class="line">    Linked_t *tmpNode = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (curNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        tmpNode = curNode-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(curNode);</span><br><span class="line">        curNode = tmpNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表的数组实现完整代码"><a href="# 链表的数组实现完整代码" class="headerlink" title="链表的数组实现完整代码"></a>链表的数组实现完整代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE (100)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; Linked_t;</span><br><span class="line"></span><br><span class="line">Linked_t *<span class="title function_">createNode</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Linked_t *linked = (Linked_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linked_t));</span><br><span class="line">    linked-&gt;data = data;</span><br><span class="line">    linked-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// printf(&quot;Linked_t size is %d bytes.\n&quot;, sizeof(linked));</span></span><br><span class="line">    <span class="keyword">return</span> linked;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Linked_t *<span class="title function_">findNode</span><span class="params">(Linked_t *linked, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    Linked_t *curNode = linked;</span><br><span class="line">    <span class="keyword">while</span> (curNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curNode-&gt;data == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> curNode;</span><br><span class="line">        &#125;</span><br><span class="line">        curNode = curNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 没有找到元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Linked_t *<span class="title function_">insertTailNode</span><span class="params">(Linked_t *linked, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (linked == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;linked is NULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Linked_t *curNode = linked;</span><br><span class="line">    <span class="keyword">while</span> (curNode-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        curNode = curNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Linked_t *newNode = createNode(data);</span><br><span class="line">    curNode-&gt;next = newNode;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> linked;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Linked_t *<span class="title function_">insertNode</span><span class="params">(Linked_t *linked, Linked_t *node, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (linked == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;linked is NULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node == linked) &#123;  <span class="comment">// 在链表头结点前插入新结点</span></span><br><span class="line">        Linked_t *newNode = createNode(data);</span><br><span class="line">        newNode-&gt;next = linked;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> insertTailNode(linked, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Linked_t *preNode = linked;</span><br><span class="line">    Linked_t *curNode = preNode-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (curNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curNode == node) &#123;  <span class="comment">// 在链表结点中间插入新结点</span></span><br><span class="line">            Linked_t *newNode = createNode(data);</span><br><span class="line">            preNode-&gt;next = newNode;</span><br><span class="line">            newNode-&gt;next = curNode;</span><br><span class="line">            <span class="keyword">return</span> linked;</span><br><span class="line">        &#125;</span><br><span class="line">        preNode = curNode;</span><br><span class="line">        curNode = curNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The specified node does not exist in the linked list.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> linked;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Linked_t *<span class="title function_">deleteNode</span><span class="params">(Linked_t *linked, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (linked == <span class="literal">NULL</span> || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> linked;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">        Linked_t *newHead = linked-&gt;next;</span><br><span class="line">        linked-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(linked);</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        Linked_t *preNode = linked, *curNode = preNode-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (curNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span> (cnt == index) &#123;</span><br><span class="line">                Linked_t *curNext = curNode-&gt;next;</span><br><span class="line">                curNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="built_in">free</span>(curNode);</span><br><span class="line">                preNode-&gt;next = curNext;</span><br><span class="line">                <span class="keyword">return</span> linked;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                preNnode = curNode;</span><br><span class="line">                curNode = curNode-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The specified index is illegal.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> linked;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getLinkedLength</span><span class="params">(Linked_t *linked)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (linked != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        linked = linked-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeLinked</span><span class="params">(Linked_t *linked)</span> &#123;</span><br><span class="line">    Linked_t *curNode = linked;</span><br><span class="line">    Linked_t *tmpNode = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (curNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        tmpNode = curNode-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(curNode);</span><br><span class="line">        curNode = tmpNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printLinked</span><span class="params">(Linked_t *linked)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Linked List: &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (linked) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, linked-&gt;data);</span><br><span class="line">        linked = linked-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Linked_t *linked = createNode(<span class="number">10</span>);</span><br><span class="line">    printLinked(linked);</span><br><span class="line"></span><br><span class="line">    linked = insertTailNode(linked, <span class="number">20</span>);</span><br><span class="line">    printLinked(linked);</span><br><span class="line"></span><br><span class="line">    linked = insertTailNode(linked, <span class="number">30</span>);</span><br><span class="line">    printLinked(linked);</span><br><span class="line"></span><br><span class="line">    linked = insertNode(linked, linked, <span class="number">5</span>);</span><br><span class="line">    printLinked(linked);</span><br><span class="line"></span><br><span class="line">    linked = insertNode(linked, linked-&gt;next, <span class="number">15</span>);</span><br><span class="line">    printLinked(linked);</span><br><span class="line"></span><br><span class="line">    linked = insertNode(linked, <span class="literal">NULL</span>, <span class="number">40</span>);</span><br><span class="line">    printLinked(linked);</span><br><span class="line"></span><br><span class="line">    linked = deleteNode(linked, <span class="number">0</span>);</span><br><span class="line">    printLinked(linked);</span><br><span class="line"></span><br><span class="line">    linked = deleteNode(linked, <span class="number">2</span>);</span><br><span class="line">    printLinked(linked);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> length = getLinkedLength(linked);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Linked List Length: %d\n&quot;</span>, length);</span><br><span class="line"></span><br><span class="line">    freeLinked(linked);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Linked List: 10</span><br><span class="line">Linked List: 10 20</span><br><span class="line">Linked List: 10 20 30</span><br><span class="line">Linked List: 5 10 20 30</span><br><span class="line">Linked List: 5 15 10 20 30</span><br><span class="line">Linked List: 5 15 10 20 30 40</span><br><span class="line">Linked List: 15 10 20 30 40</span><br><span class="line">Linked List: 15 10 30 40</span><br><span class="line">Linked List Length: 4</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之链表（数组实现）</title>
    <url>/posts/231007174854.html</url>
    <content><![CDATA[<p>线性表是一组 <strong> 按线性顺序排列的、具有相同特征的数据元素的有限序列</strong>，其中的数据元素之间存在一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的（这句话只适用大部分线性表，而不是全部，如循环链表把最后一个数据元素的尾指针指向了首位结点）。线性表可以用于表示一串有序的数据，例如数组、链表、栈和队列等都是线性表的实现方式。</p>
<p>线性表中的「单链表」的实现，包括单链表的顺序存储（数组实现）和单链表的链式存储。这篇文章主要介绍单链表的顺序存储（数组实现）。</p>
<span id="more"></span>

<h2 id="数组和链表的特点"><a href="# 数组和链表的特点" class="headerlink" title="数组和链表的特点"></a>数组和链表的特点 </h2><p> 首先介绍一下数组和链表的特点。</p>
<p>数组：创建数组时会在内存空间中划分出一块连续的内存，然后数据进入时会将数据按顺序存储在这块连续的内存中。因为数组在存储数据时是按顺序存储的，存储数据的内存也是连续的。所以，<strong>数组的特点就是寻址读取数据容易，插入和删除比较困难 / 费时</strong>。</p>
<p>链表：链表不同于数组，不会先划分出一块连续的内存，链表中的数据并不是连续的，链表在存储数据的内存中有两块区域，一块区域用来存储数据，一块区域用来记录下一个数据保存在哪里。虽然链表是线性表，但是并不会按线性的顺序存储数据。所以，<strong>链表在插入和删除时比较容易，在读取数据时比较麻烦</strong>。</p>
<blockquote>
<p>这里的容易，即意味着时间复杂度低；麻烦，即意味着时间复杂度高。</p>
</blockquote>
<h2 id="链表的顺序存储（数组实现）"><a href="# 链表的顺序存储（数组实现）" class="headerlink" title="链表的顺序存储（数组实现）"></a>链表的顺序存储（数组实现）</h2><p>链表的 API 主要包括：</p>
<ul>
<li>创建并初始化链表</li>
<li>查找链表中的元素</li>
<li>向链表中插入元素</li>
<li>删除链表中的元素</li>
<li>获取链表的长度</li>
</ul>
<h3 id="链表结构定义"><a href="# 链表结构定义" class="headerlink" title="链表结构定义"></a>链表结构定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE (100)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data[MAX_SIZE];  <span class="comment">// 存储元素的数组</span></span><br><span class="line">    <span class="type">int</span> length;  <span class="comment">// 链表的长度</span></span><br><span class="line">&#125; ArrayList;</span><br></pre></td></tr></table></figure>

<p>这段代码定义了一个名为 <code>ArrayList</code> 的结构体，用来表示一个数组实现的链表。</p>
<p>该结构体包含两个成员变量：</p>
<ol>
<li><code>int data[MAX_SIZE]</code>：一个整型数组，用来存储链表中的元素。</li>
<li><code>int length</code>：一个整型变量，表示链表的长度。</li>
</ol>
<p>通过使用这个结构体，我们可以创建一个顺序存储结构的链表，其中元素按照顺序存储在数组中，并且可以通过索引来访问和修改链表中的元素。</p>
<h3 id="创建并初始化链表"><a href="# 创建并初始化链表" class="headerlink" title="创建并初始化链表"></a>创建并初始化链表 </h3><p> 使用动态申请内存空间的方式创建并初始化一个链表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ArrayList *<span class="title function_">initArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    ArrayList *<span class="built_in">list</span> = (ArrayList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArrayList));</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">list</span>-&gt;data, <span class="number">0</span>, MAX_SIZE * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">list</span>-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// printf(&quot;ArrayList size is %d bytes, data size is %d bytes.\n&quot;, sizeof(list), sizeof(list-&gt;data));</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查找链表中的元素"><a href="# 查找链表中的元素" class="headerlink" title="查找链表中的元素"></a>查找链表中的元素 </h3><p> 在链表中查找目标元素第一次出现时的索引，不存在则返回 -1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findArrayList</span><span class="params">(ArrayList *<span class="built_in">list</span>, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">/* 查找成功的平均比较次数为(n+1)/2 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>-&gt;length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;data[i] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;  <span class="comment">// 返回元素在链表中的索引</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 没有找到元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么查找成功的平均比较次数为 $\frac {n+1}{2}$ 呢？</p>
</blockquote>
<p>假设链表的长度为 $n$，若元素在链表中存在，在最坏情况下，需要比较 $n$ 次才能找到元素；在最好情况下，只需要比较 $1$ 次就能找到元素。因此，平均比较次数为 $\frac {n+1}{2}$。</p>
<h3 id="向链表中插入元素"><a href="# 向链表中插入元素" class="headerlink" title="向链表中插入元素"></a>向链表中插入元素 </h3><p> 向链表中指定的索引位置插入一个元素，可以在有效数据的最前面和最后面插入元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">insertArrayList</span><span class="params">(ArrayList *<span class="built_in">list</span>, <span class="type">int</span> index, <span class="type">int</span> element)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;length == MAX_SIZE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;List is full! Unable to insert element.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="built_in">list</span>-&gt;length) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid index! Unable to insert element.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">list</span>-&gt;length - <span class="number">1</span>; i &gt;= index; i--) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;data[i + <span class="number">1</span>] = <span class="built_in">list</span>-&gt;data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;data[index] = element;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length++;  <span class="comment">// 更新链表的长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除链表中的元素"><a href="# 删除链表中的元素" class="headerlink" title="删除链表中的元素"></a>删除链表中的元素 </h3><p> 删除链表中指定索引位置的元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deleteArrayList</span><span class="params">(ArrayList *<span class="built_in">list</span>, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;List is empty! Unable to delete element.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">list</span>-&gt;length) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid index! Unable to delete element.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; <span class="built_in">list</span>-&gt;length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;data[i] = <span class="built_in">list</span>-&gt;data[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length--;  <span class="comment">// 更新链表的长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取链表的长度"><a href="# 获取链表的长度" class="headerlink" title="获取链表的长度"></a>获取链表的长度 </h3><p> 获取链表中有效数据元素的长度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getArrayListLength</span><span class="params">(ArrayList *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>-&gt;length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="释放链表空间"><a href="# 释放链表空间" class="headerlink" title="释放链表空间"></a>释放链表空间</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freeArrayList</span><span class="params">(ArrayList *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表的数组实现完整代码"><a href="# 链表的数组实现完整代码" class="headerlink" title="链表的数组实现完整代码"></a>链表的数组实现完整代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE (100)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data[MAX_SIZE];  <span class="comment">// 存储元素的数组</span></span><br><span class="line">    <span class="type">int</span> length;  <span class="comment">// 链表的长度</span></span><br><span class="line">&#125; ArrayList;</span><br><span class="line"></span><br><span class="line">ArrayList *<span class="title function_">initArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    ArrayList *<span class="built_in">list</span> = (ArrayList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArrayList));</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">list</span>-&gt;data, <span class="number">0</span>, MAX_SIZE * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">list</span>-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ArrayList size is %d bytes, data size is %d bytes.\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="built_in">list</span>), <span class="keyword">sizeof</span>(<span class="built_in">list</span>-&gt;data));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findArrayList</span><span class="params">(ArrayList *<span class="built_in">list</span>, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>-&gt;length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;data[i] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;  <span class="comment">// 返回元素在链表中的索引</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 没有找到元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertArrayList</span><span class="params">(ArrayList *<span class="built_in">list</span>, <span class="type">int</span> index, <span class="type">int</span> element)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;length == MAX_SIZE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;List is full! Unable to insert element.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="built_in">list</span>-&gt;length) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid index! Unable to insert element.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">list</span>-&gt;length - <span class="number">1</span>; i &gt;= index; i--) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;data[i + <span class="number">1</span>] = <span class="built_in">list</span>-&gt;data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;data[index] = element;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length++;  <span class="comment">// 更新链表的长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteArrayList</span><span class="params">(ArrayList *<span class="built_in">list</span>, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;List is empty! Unable to delete element.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">list</span>-&gt;length) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid index! Unable to delete element.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; <span class="built_in">list</span>-&gt;length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;data[i] = <span class="built_in">list</span>-&gt;data[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length--;  <span class="comment">// 更新链表的长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getArrayListLength</span><span class="params">(ArrayList *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>-&gt;length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printArrayList</span><span class="params">(ArrayList *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>-&gt;length; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">list</span>-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeArrayList</span><span class="params">(ArrayList *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    ArrayList *<span class="built_in">list</span> = initArrayList();</span><br><span class="line"></span><br><span class="line">    insertArrayList(<span class="built_in">list</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    insertArrayList(<span class="built_in">list</span>, <span class="number">1</span>, <span class="number">20</span>);</span><br><span class="line">    insertArrayList(<span class="built_in">list</span>, <span class="number">2</span>, <span class="number">30</span>);</span><br><span class="line">    printArrayList(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    insertArrayList(<span class="built_in">list</span>, <span class="number">2</span>, <span class="number">40</span>);</span><br><span class="line">    insertArrayList(<span class="built_in">list</span>, <span class="number">0</span>, <span class="number">15</span>);</span><br><span class="line">    printArrayList(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Length of list: %d\n&quot;</span>, getArrayListLength(<span class="built_in">list</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> index = findArrayList(<span class="built_in">list</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">if</span> (index != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Element 20 is found at index %d\n&quot;</span>, index);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Element 20 is not found\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deleteArrayList(<span class="built_in">list</span>, <span class="number">1</span>);</span><br><span class="line">    printArrayList(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Length of list: %d\n&quot;</span>, getArrayListLength(<span class="built_in">list</span>));</span><br><span class="line"></span><br><span class="line">    freeArrayList(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ArrayList size is 8 bytes, data size is 400 bytes.</span><br><span class="line">10 20 30</span><br><span class="line">15 10 20 40 30</span><br><span class="line">Length of list: 5</span><br><span class="line">Element 20 is found at index 2</span><br><span class="line">15 20 40 30</span><br><span class="line">Length of list: 4</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之单调栈</title>
    <url>/posts/231127185207.html</url>
    <content><![CDATA[<p>何为单调栈？顾名思义，单调栈即满足单调性的栈结构，可以是单调递增或单调递减。在单调栈中，栈顶元素是栈内最大（或最小）的元素，而栈底元素是栈内最小（或最大）的元素。</p>
<p><strong>单调栈在解决一些与区间相关的问题时非常有用</strong>。它可以帮助我们快速找到每个元素左边或右边第一个比它大或小的元素：通过维护一个单调递增栈，我们可以找到每个元素右边第一个比它小的元素；通过维护一个单调递减栈，我们可以找到每个元素右边第一个比它大的元素。</p>
<span id="more"></span>

<h2 id="单调栈"><a href="# 单调栈" class="headerlink" title="单调栈"></a>单调栈 </h2><p> 单调栈（monotonic stack）是一种特殊的栈数据结构，常用于解决与区间相关的问题。它的特点是栈内元素具有单调性，可以是单调递增或单调递减。</p>
<blockquote>
<p>这里的「单调」为广义上的单调，即为非严格单调性，包括「等于」的情况。</p>
</blockquote>
<h3 id="基本操作"><a href="# 基本操作" class="headerlink" title="基本操作"></a>基本操作 </h3><p> 单调栈支持以下操作：</p>
<ul>
<li>入栈（push）：将元素压入栈顶。</li>
<li>出栈（pop）：将栈顶元素弹出。</li>
<li>获取栈顶元素（top）：返回栈顶元素的值，但不弹出栈顶元素。</li>
<li>判断栈是否为空（isEmpty）：返回栈是否为空的布尔值。</li>
</ul>
<h3 id="应用场景"><a href="# 应用场景" class="headerlink" title="应用场景"></a>应用场景 </h3><p><strong> 单调栈在解决一些与区间相关的问题时非常有用</strong>，例如：</p>
<ul>
<li>寻找每个元素右边第一个比它大（或小）的元素。</li>
<li>寻找数组中的下一个更大（或更小）元素。</li>
<li>寻找数组中的最大矩形面积（矩阵是以数组中的值为高度、宽度指定）。</li>
</ul>
<h3 id="算法思想"><a href="# 算法思想" class="headerlink" title="算法思想"></a>算法思想 </h3><p> 单调栈的基本思想是维护一个单调递增或单调递减的栈。具体操作如下：</p>
<ul>
<li>对于每个元素，如果栈为空或当前元素大于（或小于）栈顶元素，则将当前元素入栈。</li>
<li>如果当前元素小于（或大于）栈顶元素，说明找到了栈顶元素的右边第一个小于（或大于）它的元素。此时，可以对栈进行出栈操作，直到栈为空或新元素大于（或小于）栈顶元素。</li>
<li>继续将当前元素入栈。</li>
</ul>
<h3 id="维护单调栈示例过程"><a href="# 维护单调栈示例过程" class="headerlink" title="维护单调栈示例过程"></a>维护单调栈示例过程 </h3><p> 对于数组 <code>[2,1,5,6,2,3]</code>，我们维护一个单调递增栈（栈底元素最小、栈顶元素最大）的过程如下：</p>
<p>第一步，栈为空，入栈新元素 <code>2</code>，此时单调递增栈（左侧为栈底、右侧为栈顶）的状态为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">monoStack: [2]</span><br></pre></td></tr></table></figure>

<p>第二步，栈不为空，新元素 <code>1</code> 小于栈顶元素 <code>2</code>，弹出元素 <code>2</code> 后，栈为空，入栈新元素 <code>1</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">monoStack: [1]</span><br></pre></td></tr></table></figure>

<p>第三步，栈不为空，新元素 <code>5</code> 大于栈顶元素 <code>1</code>，入栈新元素 <code>5</code>；栈不为空，新元素 <code>6</code> 大于栈顶元素 <code>5</code>，入栈新元素 <code>6</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">monoStack: [1, 5, 6]</span><br></pre></td></tr></table></figure>

<p>第四步，栈不为空，新元素 <code>2</code> 小于栈顶元素 <code>6</code>，栈顶元素 <code>6</code> 出栈；栈不为空，新元素 <code>2</code> 小于栈顶元素 <code>5</code>，栈顶元素 <code>5</code> 出栈：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">monoStack: [1]</span><br></pre></td></tr></table></figure>

<p>第五步，栈不为空，新元素 <code>2</code> 大于栈顶元素 <code>1</code>，新元素入栈后满足单调性，新元素 <code>2</code> 入栈：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">monoStack: [1, 2]</span><br></pre></td></tr></table></figure>

<p>第六步，栈不为空，新元素 <code>3</code> 大于栈顶元素 <code>2</code>，新元素入栈后满足单调性，新元素 <code>3</code> 入栈：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">monoStack: [1, 2, 3]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由第二步可知，元素 <code>2</code> 右侧第一个比它小的元素是元素 <code>1</code>；由第四步可知，元素 <code>5</code> 和元素 <code>6</code> 右侧第一个比它小的元素都是元素 <code>2</code>；由最后一步可知，元素 <code>1,2,3</code> 右侧没有比它小的元素。</p>
</blockquote>
<h3 id="伪代码"><a href="# 伪代码" class="headerlink" title="伪代码"></a>伪代码 </h3><h4 id="单调递增栈"><a href="# 单调递增栈" class="headerlink" title="单调递增栈"></a> 单调递增栈 </h4><p> 单调递增栈的栈顶元素最大，新插入的元素要不小于栈顶元素，否则只能把栈顶元素一个一个地弹出栈，直到满足为止。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// insert x</span></span><br><span class="line"><span class="keyword">while</span> (!monoStack.empty() &amp;&amp; x &lt; monoStack.top()) &#123;</span><br><span class="line">    monoStack.pop()</span><br><span class="line">&#125;</span><br><span class="line">monoStack.push(x)</span><br></pre></td></tr></table></figure>

<h4 id="单调递减栈"><a href="# 单调递减栈" class="headerlink" title="单调递减栈"></a>单调递减栈 </h4><p> 单调递减栈的栈顶元素最小，新插入的元素要不大于栈顶元素，否则只能把栈顶元素一个一个地弹出栈，直到满足为止。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// insert x</span></span><br><span class="line"><span class="keyword">while</span> (!monoStack.empty() &amp;&amp; x &gt; monoStack.top()) &#123;</span><br><span class="line">    monoStack.pop()</span><br><span class="line">&#125;</span><br><span class="line">monoStack.push(x)</span><br></pre></td></tr></table></figure>

<h3 id="复杂度"><a href="# 复杂度" class="headerlink" title="复杂度"></a>复杂度 </h3><p> 每个元素最多只会进栈、出栈一次，故时间复杂度为 <code>O(n)</code>，空间复杂度为 <code>O(n)</code>，<code>n</code> 为元素数量。</p>
<h2 id="单调栈应用场景实现"><a href="# 单调栈应用场景实现" class="headerlink" title="单调栈应用场景实现"></a>单调栈应用场景实现 </h2><p> 题目：寻找数组中每个元素右边比它小的第一个元素。</p>
<h3 id="实现代码"><a href="# 实现代码" class="headerlink" title="实现代码"></a>实现代码 </h3><p> 这可以使用单调递增栈找到每个元素右边第一个比它小的元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">findNextSmaller</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> n, <span class="type">int</span> res[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> monoStack[n], size = <span class="number">0</span>; <span class="comment">// 使用数组模拟栈结构</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        res[i] = <span class="number">-1</span>; <span class="comment">// 初始化结果数组，-1 表示右侧没有比我小的元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt; nums[monoStack[size - <span class="number">1</span>]]) &#123;  <span class="comment">// monoStack.top()</span></span><br><span class="line">            res[monoStack[--size]] = nums[i];  <span class="comment">// monoStack.pop()</span></span><br><span class="line">        &#125;</span><br><span class="line">        monoStack[size++] = i;  <span class="comment">// monoStack.push(x)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> nums[] = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(nums) / <span class="keyword">sizeof</span>(nums[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> res[n];</span><br><span class="line"></span><br><span class="line">    findNextSmaller(nums, n, res);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d next smaller: %d\n&quot;</span>, nums[i], res[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试结果"><a href="# 测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 next smaller: 1</span><br><span class="line">1 next smaller: -1</span><br><span class="line">5 next smaller: 2</span><br><span class="line">6 next smaller: 2</span><br><span class="line">2 next smaller: -1</span><br><span class="line">3 next smaller: -1</span><br></pre></td></tr></table></figure>

<p>这个结果与上面的“维护单调栈示例过程”中的举例的结果一致。</p>
<h3 id="代码分析"><a href="# 代码分析" class="headerlink" title="代码分析"></a>代码分析 </h3><p> 在代码实现中，我们并没有直接在单调栈 <code>monoStack</code> 中存储数组元素的值，而是存储了数组元素对应的索引：</p>
<ol>
<li>这方便了通过索引向结果数组 <code>res</code> 的对应位置，填充右边第一个比它小的值；</li>
<li>因为原始数组 <code>nums</code> 的索引对应的值不会改变，我们依然可以通过 <code>monoStack</code> 中维护的索引，获取对应的值，保证栈的单调性。</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>单调栈</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之堆栈（链表实现）</title>
    <url>/posts/231016184406.html</url>
    <content><![CDATA[<p>堆栈提供了一种后进先出（LIFO, last-in first-out）存储结构。在 <a href="https://pursue26.github.io/posts/231016161508.html"> 数据结构之堆栈（数组实现）</a>中，我们介绍了数组实现的堆栈，这篇文章将介绍通过链表的方式实现堆栈这种数据结构。</p>
<span id="more"></span>

<h2 id="堆栈的实现方式"><a href="# 堆栈的实现方式" class="headerlink" title="堆栈的实现方式"></a>堆栈的实现方式 </h2><p> 在 C 语言中，可以使用以下方法来实现堆栈（stack）数据结构：</p>
<ol>
<li><p>使用数组：可以使用一个固定大小的数组来表示堆栈。堆栈有两个重要的指针：一个是指向栈顶的指针，另一个是指向栈底的指针。在数组中，栈顶指针指向最新添加的元素，栈底指针指向最旧的元素。可以使用数组的索引来实现栈的推入 (push) 和弹出 (pop) 操作。</p>
</li>
<li><p>使用链表：可以使用链表来表示堆栈。链表中的每个节点包含一个元素和一个指向下一个节点的指针。栈顶指针指向链表的第一个节点，栈底指针指向链表的最后一个节点。入栈操作将创建一个新节点，并将其插入链表的开头；出栈操作将删除链表的第一个节点。</p>
</li>
</ol>
<blockquote>
<p>链表实现堆栈时，<strong>采用头插法</strong>，即在链表头结点前插入新节点、删除节点。这样做，方便 push 和 pop 操作；如果在链表的最后插入新节点，那么在 pop 操作时，更新栈顶的节点指针将会很麻烦 &amp; 费时。</p>
</blockquote>
<h2 id="链表实现堆栈的优点"><a href="# 链表实现堆栈的优点" class="headerlink" title="链表实现堆栈的优点"></a>链表实现堆栈的优点 </h2><p> 链表实现堆栈相比于数组实现堆栈有以下几个优点：</p>
<ol>
<li>动态大小：链表实现的堆栈可以根据需要动态调整大小，而数组实现的堆栈需要预先指定大小。这意味着链表实现的堆栈可以根据实际需求进行扩展或缩小，而不会浪费内存或导致栈溢出。</li>
<li>内存管理：链表实现的堆栈只使用必要的内存空间，而数组实现的堆栈在创建时需要一定大小的连续内存空间。这意味着链表实现的堆栈可以更好地处理内存管理，避免浪费内存或导致内存溢出。</li>
</ol>
<p>总的来说，链表实现的堆栈更加灵活和动态，适用于需要频繁插入和删除操作的场景，而数组实现的堆栈更适用于事先知道栈大小且不需要频繁调整大小的场景。</p>
<h2 id="链表实现堆栈"><a href="# 链表实现堆栈" class="headerlink" title="链表实现堆栈"></a>链表实现堆栈 </h2><h3 id="定义并初始化堆栈结构"><a href="# 定义并初始化堆栈结构" class="headerlink" title="定义并初始化堆栈结构"></a> 定义并初始化堆栈结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;  <span class="comment">// 堆栈的数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span>  <span class="comment">// 下一个弹出的数据的存储地址</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;  <span class="comment">// 数据量大小</span></span><br><span class="line">    <span class="type">int</span> max;   <span class="comment">// 最大容量</span></span><br><span class="line">    Node *top;  <span class="comment">// 堆栈的头指针</span></span><br><span class="line">&#125; Stack;</span><br></pre></td></tr></table></figure>

<p>在这里，我们使用一个结构体实现具有先进先出的堆栈结构，其中的两个成员标记这堆栈中的数据量和最大存储数据量大小，另一个成员标记着栈顶地址。</p>
<ul>
<li>这里的栈顶地址，即为链表的头结点地址，所有这个成员的数据类型为链表结构：<ul>
<li>链表结构中需要包含存放的数据和指向下一个数据的地址。</li>
</ul>
</li>
</ul>
<p>其中，成员 <code>size</code> 和成员 <code>max</code> 主要用于执行堆栈是否为空和堆栈是否已满操作，<code>top</code>指针主要用于执行堆栈的入栈、出栈和栈顶查询等操作。</p>
<h3 id="初始化堆栈"><a href="# 初始化堆栈" class="headerlink" title="初始化堆栈"></a>初始化堆栈</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EXCEPTION_VALUE (-1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> max_size = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">Stack *<span class="title function_">initStack</span><span class="params">(<span class="type">int</span> max_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    Stack *<span class="built_in">stack</span> = (Stack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    <span class="built_in">stack</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;max = max_size;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断堆栈是否为空"><a href="# 判断堆栈是否为空" class="headerlink" title="判断堆栈是否为空"></a>判断堆栈是否为空</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断堆栈是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断堆栈是否已满"><a href="# 判断堆栈是否已满" class="headerlink" title="判断堆栈是否已满"></a>判断堆栈是否已满</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断堆栈是否已满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;size &gt;= <span class="built_in">stack</span>-&gt;max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="入栈操作"><a href="# 入栈操作" class="headerlink" title="入栈操作"></a>入栈操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元素入栈</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">push</span><span class="params">(Stack *<span class="built_in">stack</span>, <span class="type">int</span> element)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is full\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node *node = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        node-&gt;data = element;</span><br><span class="line">        node-&gt;next = <span class="built_in">stack</span>-&gt;top;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;size++;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;top = node;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="出栈操作"><a href="# 出栈操作" class="headerlink" title="出栈操作"></a>出栈操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元素出栈</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> topVal = <span class="built_in">stack</span>-&gt;top-&gt;data;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;top = <span class="built_in">stack</span>-&gt;top-&gt;next;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;size--;</span><br><span class="line">        <span class="keyword">return</span> topVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了区分栈空时的返回值与正常出栈的数据，需要定义异常值为不会出现在正常数据中的值；或者修改函数的返回值为指针类型，返回值不为空时对应着有效数据。</p>
<h3 id="获取栈顶元素"><a href="# 获取栈顶元素" class="headerlink" title="获取栈顶元素"></a>获取栈顶元素</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取栈顶元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="打印堆栈数据"><a href="# 打印堆栈数据" class="headerlink" title="打印堆栈数据"></a>打印堆栈数据</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印堆栈中的元素, 从栈顶打印到栈底</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printStack</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack: &quot;</span>);</span><br><span class="line">        Node *head = <span class="built_in">stack</span>-&gt;top;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, head-&gt;data);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表实现堆栈完整代码"><a href="# 链表实现堆栈完整代码" class="headerlink" title="链表实现堆栈完整代码"></a>链表实现堆栈完整代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCEPTION_VALUE (-1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    Node *top;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line">Stack *<span class="title function_">initStack</span><span class="params">(<span class="type">int</span> max_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    Stack *<span class="built_in">stack</span> = (Stack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    <span class="built_in">stack</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;max = max_size;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;size &gt;= <span class="built_in">stack</span>-&gt;max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">push</span><span class="params">(Stack *<span class="built_in">stack</span>, <span class="type">int</span> element)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is full\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node *node = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        node-&gt;data = element;</span><br><span class="line">        node-&gt;next = <span class="built_in">stack</span>-&gt;top;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;size++;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;top = node;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> topVal = <span class="built_in">stack</span>-&gt;top-&gt;data;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;top = <span class="built_in">stack</span>-&gt;top-&gt;next;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;size--;</span><br><span class="line">        <span class="keyword">return</span> topVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printStack</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack: &quot;</span>);</span><br><span class="line">        Node *head = <span class="built_in">stack</span>-&gt;top;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, head-&gt;data);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> *argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    Stack *stack1 = <span class="literal">NULL</span>;</span><br><span class="line">    stack1 = initStack(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    printStack(stack1);</span><br><span class="line">    push(stack1, <span class="number">1</span>);</span><br><span class="line">    push(stack1, <span class="number">2</span>);</span><br><span class="line">    push(stack1, <span class="number">3</span>);</span><br><span class="line">    printStack(stack1);</span><br><span class="line">    push(stack1, <span class="number">4</span>);</span><br><span class="line">    printStack(stack1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Pop element: %d\n&quot;</span>, pop(stack1));</span><br><span class="line">    printStack(stack1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Top element: %d\n&quot;</span>, peek(stack1));</span><br><span class="line">    printStack(stack1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stack is empty</span><br><span class="line">Stack: 3 2 1</span><br><span class="line">Stack is full</span><br><span class="line">Stack: 3 2 1</span><br><span class="line">Pop element: 3</span><br><span class="line">Stack: 2 1</span><br><span class="line">Top element: 2</span><br><span class="line">Stack: 2 1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>堆栈</category>
      </categories>
      <tags>
        <tag>堆栈</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法之 Dijkstra 单源最短路径（实现部分）</title>
    <url>/posts/231121152713.html</url>
    <content><![CDATA[<p>在文章 <a href="https://pursue26.github.io/posts/231117095232.html"> 数据结构算法之 Dijkstra 单源最短路径（原理部分）</a>中，给出了 Dijkstra 算法求单源最短路径的图文步骤，本文将给出该算法的代码实现。</p>
<span id="more"></span>

<h2 id="Dijkstra 算法步骤"><a href="#Dijkstra 算法步骤" class="headerlink" title="Dijkstra 算法步骤"></a>Dijkstra 算法步骤 </h2><p> 回顾一下 <a href="https://pursue26.github.io/posts/231117095232.html"> 数据结构算法之 Dijkstra 单源最短路径（原理部分）</a>中给出的 Dijkstra 算法的具体步骤：</p>
<ol>
<li>创建一个距离数组<code>dist[]</code>，用于存储源节点到各个节点的最短路径长度。初始时，将源节点的距离设为 0，与源节点直接相连的节点的距离设为边的权重，其他节点的距离设为无穷大。</li>
<li>创建一个标记数组<code>visited[]</code>，用于标记是否已经访问过该节点。初始时，将源节点标记为已访问，其他节点标记为未访问。</li>
<li>以源节点为基准，遍历所有与其相邻的、未访问过的节点，计算「源节点」到这些相邻节点的距离，并从未访问的节点中选择距离「源节点」最近的节点，作为基准节点。</li>
<li>以这个基准节点为中间节点，更新从源节点经过中间节点到达其它节点的距离到 <code>dist[]</code> 数组中，并将这个基准节点标记为已访问。<ul>
<li>更新的方式是：如果「从新的中间节点」到「该节点」的距离小于原本到它的距离，则更新它的值（你要从这个节点走才更近了哦），并将这个中间节点作为它的前驱节点。</li>
</ul>
</li>
<li>重复步骤 3 和步骤 4，直到所有节点都被访问过。</li>
<li>最终，<code>dist[]</code>数组中存储的就是源节点到其他所有节点的最短路径长度。</li>
</ol>
<blockquote>
<p>步骤三中的「相邻」节点包括直接与源节点相邻、通过已访问的节点间接与源节点相邻这两大类。换句话说，也就是 <code>dist[]</code> 数组中只要不是无穷大，就与源节点直接或间接相邻。</p>
</blockquote>
<h2 id="Dijkstra 算法实现"><a href="#Dijkstra 算法实现" class="headerlink" title="Dijkstra 算法实现"></a>Dijkstra 算法实现 </h2><h3 id="定义图结构"><a href="# 定义图结构" class="headerlink" title="定义图结构"></a> 定义图结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">graph</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> vexs[MAX];        <span class="comment">// 顶点集合</span></span><br><span class="line">    <span class="type">int</span> vexnum;            <span class="comment">// 顶点数</span></span><br><span class="line">    <span class="type">int</span> edgenum;           <span class="comment">// 边数</span></span><br><span class="line">    <span class="type">int</span> matrix[MAX][MAX];  <span class="comment">// 邻接矩阵</span></span><br><span class="line">&#125; Graph;</span><br></pre></td></tr></table></figure>

<p><code>Graph</code> 是图的邻接矩阵对应的结构体：</p>
<ul>
<li><code>vexs</code> 用于保存顶点的集合，<code>vexnum</code> 是顶点数量，<code>edgenum</code> 是边数；</li>
<li><code>matrix</code> 用于保存邻接点信息的二维数组，<code>matrix[i][j]</code> 表示顶点 <code>vexs[i]</code> 和顶点 <code>vexs[j]</code> 之间的边的权重，若 <code>matrix[i][j] = INF</code>，则表示这两个顶点之间没有边（不是邻接点）。</li>
</ul>
<h3 id="定义边结构"><a href="# 定义边结构" class="headerlink" title="定义边结构"></a>定义边结构 </h3><p> 实际中，一般给出的信息都是哪两个顶点之间有边，边的权重是多少，所有我们给出一个结构体用于存储边的数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 边的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">edgeData</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> start;  <span class="comment">// 边的起点</span></span><br><span class="line">    <span class="type">char</span> end;    <span class="comment">// 边的终点</span></span><br><span class="line">    <span class="type">int</span> weight;  <span class="comment">// 边的权重</span></span><br><span class="line">&#125; EData;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在编码中，图结构体变量的数据将会从边结构体变量的数据中获取。</p>
</blockquote>
<h3 id="获取顶点的索引"><a href="# 获取顶点的索引" class="headerlink" title="获取顶点的索引"></a>获取顶点的索引 </h3><p> 这里的顶点是字符型（而非整数型），所以需要获取字符型顶点对应的索引——它在顶点集合中的位置。这样，才方便后续将邻接点存储在图结构的成员 <code>matrix</code> 中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取顶点在顶点集合中的索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getIndexOfVex</span><span class="params">(Graph *pGraph, <span class="type">char</span> vex)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pGraph-&gt;vexnum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pGraph-&gt;vexs[i] == vex) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构建图数据"><a href="# 构建图数据" class="headerlink" title="构建图数据"></a>构建图数据 </h3><p> 就像上面说的，图结构体变量的数据将会从边结构体变量的数据中获取。所以，我们在这里实现了从给定的边数据来初始化图数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建图</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">createGraph</span><span class="params">(Graph *pGraph, <span class="type">char</span> vexs[], <span class="type">int</span> vexnum, EData edges[], <span class="type">int</span> edgenum)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化顶点数、边数、顶点集合</span></span><br><span class="line">    pGraph-&gt;vexnum = vexnum;</span><br><span class="line">    pGraph-&gt;edgenum = edgenum;</span><br><span class="line">    <span class="built_in">memcpy</span>(pGraph-&gt;vexs, vexs, vexnum * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pGraph-&gt;vexnum; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; pGraph-&gt;vexnum; j++) &#123;</span><br><span class="line">            pGraph-&gt;matrix[i][j] = (i == j ? <span class="number">0</span> : INF);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加边数据到图中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pGraph-&gt;edgenum; i++) &#123;</span><br><span class="line">        <span class="comment">// 这里要保证顶点的索引有效</span></span><br><span class="line">        <span class="type">int</span> start = getIndexOfVex(pGraph, edges[i].start);</span><br><span class="line">        <span class="type">int</span> end = getIndexOfVex(pGraph, edges[i].end);</span><br><span class="line">        <span class="type">int</span> weight = edges[i].weight;</span><br><span class="line">        pGraph-&gt;matrix[start][end] = weight;</span><br><span class="line">        pGraph-&gt;matrix[end][start] = pGraph-&gt;matrix[start][end];  <span class="comment">// 无向图加这行，有向图不加这行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于无向图，要多加一行代码 <code>pGraph-&gt;matrix[end][start] = pGraph-&gt;matrix[start][end]</code> 哦。</p>
</blockquote>
<h3 id="Dijkstra 算法"><a href="#Dijkstra 算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dijkstra 算法，找到源顶点到各顶点的最短路径</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dijkstra</span><span class="params">(Graph *pGraph, <span class="type">char</span> start, <span class="type">int</span> dist[], <span class="type">int</span> prev[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">int</span> visited[MAX]; <span class="comment">// 标记顶点是否已被访问</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> startIdx = getIndexOfVex(pGraph, start);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤一 &amp; 二：初始化访问数组、距离数组、路径数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pGraph-&gt;vexnum; i++) &#123;</span><br><span class="line">        visited[i] = <span class="number">0</span>; <span class="comment">// 顶点未被访问</span></span><br><span class="line">        dist[i] = pGraph-&gt;matrix[startIdx][i]; <span class="comment">// 初始化源顶点到各顶点的距离</span></span><br><span class="line">        prev[i] = (dist[i] != INF ? startIdx : <span class="number">-1</span>); <span class="comment">// 如果源顶点到该顶点有边，则设置前驱顶点为源顶点</span></span><br><span class="line">    &#125;</span><br><span class="line">    visited[startIdx] = <span class="number">1</span>; <span class="comment">// 源顶点已被访问</span></span><br><span class="line">    prev[startIdx] = <span class="number">-1</span>;  <span class="comment">// 源顶点没有前驱顶点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤五：遍历 N-1 次，每次找到一个顶点的最短路径</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; pGraph-&gt;vexnum; i++) &#123;</span><br><span class="line">        <span class="type">int</span> min = INF;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 步骤三：找到未被访问的顶点中距离最小的顶点 k</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; pGraph-&gt;vexnum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[j] &amp;&amp; dist[j] &lt; min) &#123;</span><br><span class="line">                min = dist[j];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤四：更新 dist 数组和 prev 数组</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; pGraph-&gt;vexnum; j++) &#123;</span><br><span class="line">            <span class="type">int</span> distk2j = min + pGraph-&gt;matrix[k][j]; <span class="comment">// 溢出风险, 所以定义的 INF 为一半的最大值</span></span><br><span class="line">            <span class="comment">// 如果「从新的中间节点」到「该节点」的距离小于原本到它的距离，则更新它的值</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[j] &amp;&amp; distk2j &lt; dist[j]) &#123;</span><br><span class="line">                dist[j] = distk2j;</span><br><span class="line">                prev[j] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[k] = <span class="number">1</span>; <span class="comment">// 将基准节点标记为已访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一次遍历可以访问一个顶点，源节点在初始化时被访问；所以，遍历 N-1 次后，所有顶点就都被访问过了。</p>
</blockquote>
<h3 id="打印最短路径"><a href="# 打印最短路径" class="headerlink" title="打印最短路径"></a>打印最短路径</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印给定起点和终点的最短路径</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printPath</span><span class="params">(Graph *pGraph, <span class="type">char</span> start, <span class="type">char</span> end, <span class="type">int</span> dist[], <span class="type">int</span> prev[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> startIdx = getIndexOfVex(pGraph, start);</span><br><span class="line">    <span class="type">int</span> endIdx = getIndexOfVex(pGraph, end);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = endIdx, count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> path[MAX];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逆序将路径顶点存入 path 数组</span></span><br><span class="line">    <span class="keyword">while</span> (i != startIdx) &#123;</span><br><span class="line">        path[count++] = pGraph-&gt;vexs[i];</span><br><span class="line">        i = prev[i];  <span class="comment">// 顶点 i 的前驱顶点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印路径顶点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c -&gt; %c: %c&quot;</span>, pGraph-&gt;vexs[startIdx], pGraph-&gt;vexs[endIdx], pGraph-&gt;vexs[startIdx]);</span><br><span class="line">    <span class="keyword">for</span> (i = count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %c&quot;</span>, path[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;, minDist: %d\n&quot;</span>, dist[endIdx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dijkstra 算法测试"><a href="#Dijkstra 算法测试" class="headerlink" title="Dijkstra 算法测试"></a>Dijkstra 算法测试 </h2><h3 id="测试代码"><a href="# 测试代码" class="headerlink" title="测试代码"></a> 测试代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX (100)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF ((~(0x1U <span class="string">&lt;&lt; 31)) &gt;</span>&gt; 1) <span class="comment">// 最大值 0X7FFFFFFF 的一半</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">graph</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> vexs[MAX];        <span class="comment">// 顶点集合</span></span><br><span class="line">    <span class="type">int</span> vexnum;            <span class="comment">// 顶点数</span></span><br><span class="line">    <span class="type">int</span> edgenum;           <span class="comment">// 边数</span></span><br><span class="line">    <span class="type">int</span> matrix[MAX][MAX];  <span class="comment">// 邻接矩阵</span></span><br><span class="line">&#125; Graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">edgeData</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> start;  <span class="comment">// 边的起点</span></span><br><span class="line">    <span class="type">char</span> end;    <span class="comment">// 边的终点</span></span><br><span class="line">    <span class="type">int</span> weight;  <span class="comment">// 边的权重</span></span><br><span class="line">&#125; EData;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getIndexOfVex</span><span class="params">(Graph *pGraph, <span class="type">char</span> vex)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">createGraph</span><span class="params">(Graph *pGraph, <span class="type">char</span> vexs[], <span class="type">int</span> vexnum, EData edges[], <span class="type">int</span> edgenum)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dijkstra</span><span class="params">(Graph *pGraph, <span class="type">char</span> start, <span class="type">int</span> dist[], <span class="type">int</span> prev[])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">printPath</span><span class="params">(Graph *pGraph, <span class="type">char</span> start, <span class="type">char</span> end, <span class="type">int</span> dist[], <span class="type">int</span> prev[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> vexs[] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> vexnum = <span class="keyword">sizeof</span>(vexs) / <span class="keyword">sizeof</span>(vexs[<span class="number">0</span>]);</span><br><span class="line">    EData edges[] = &#123;</span><br><span class="line">        &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="number">5</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="number">8</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">15</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="number">10</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> edgenum = <span class="keyword">sizeof</span>(edges) / <span class="keyword">sizeof</span>(edges[<span class="number">0</span>]);</span><br><span class="line">    Graph graph;</span><br><span class="line">    <span class="type">int</span> dist[MAX]; <span class="comment">// 存储最短路径长度</span></span><br><span class="line">    <span class="type">int</span> prev[MAX]; <span class="comment">// 存储前驱节点</span></span><br><span class="line"></span><br><span class="line">    createGraph(&amp;graph, vexs, vexnum, edges, edgenum);</span><br><span class="line">    dijkstra(&amp;graph, <span class="string">&#x27;A&#x27;</span>, dist, prev);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vexnum; i++) &#123;</span><br><span class="line">        printPath(&amp;graph, <span class="string">&#x27;A&#x27;</span>, vexs[i], dist, prev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个数加上无穷大会溢出，所以定义的 INF 为最大值的一半，防止溢出风险。</p>
</blockquote>
<h3 id="测试结果"><a href="# 测试结果" class="headerlink" title="测试结果"></a>测试结果 </h3><p> 这是测试用例中构建的图：<br><img src="/images/algorithm/dijkstra-n.png" alt=""></p>
<p>测试结果，打印从起点到终点的最短路径上的节点和最短距离：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A -&gt; A: A, minDist: 0</span><br><span class="line">A -&gt; B: A B, minDist: 2</span><br><span class="line">A -&gt; C: A C, minDist: 6</span><br><span class="line">A -&gt; D: A B D, minDist: 7</span><br><span class="line">A -&gt; E: A B D E, minDist: 17</span><br><span class="line">A -&gt; F: A B D F, minDist: 22</span><br><span class="line">A -&gt; G: A B D E G, minDist: 19</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://www.cnblogs.com/skywang12345/p/3711512.html">https://www.cnblogs.com/skywang12345/p/3711512.html</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>图算法</category>
      </categories>
      <tags>
        <tag>Dijkstra算法</tag>
        <tag>单源最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法之 Floyd 多源最短路径</title>
    <url>/posts/231116150205.html</url>
    <content><![CDATA[<p>Floyd-Warshall 算法，中文亦称弗洛伊德算法或佛洛依德算法，是一种利用动态规划的思想解决多源（任意两点间）最短路径的算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。 Floyd-Warshall 算法的时间复杂度为 $O(|V|^{3})$，空间复杂度为 $O(|V|^{2})$，其中 $V$ 是点集（来自维基百科的定义）。</p>
<span id="more"></span>

<blockquote>
<ol>
<li>「负权」指的是图中存在具有负权值的边，负权边表示从一个顶点到另一个顶点的距离是负值。Floyd-Warshall 算法可以正确处理包含负权边的图的最短路径问题。</li>
<li>「闭包」是指图中的传递关系。在有向图中，如果存在一条路径从顶点 A 到顶点 B，那么就说顶点 A 可以到达顶点 B。传递闭包就是将所有可以通过路径到达的顶点对进行标记，形成一个闭包集合。Floyd-Warshall 算法可以用来计算有向图的传递闭包，即找出所有顶点对之间是否存在路径。</li>
<li>「多源」指的是任意两点间的最短距离均可求出，「单源」指的是只能求一个顶点到其他点的最短距离，而不能求任意两点的最短距离。</li>
</ol>
</blockquote>
<h2 id="Floyd 基本思想"><a href="#Floyd 基本思想" class="headerlink" title="Floyd 基本思想"></a>Floyd 基本思想 </h2><p>Floyd 算法的基本思想是通过<strong> 中转节点来逐步优化路径长度 </strong>。该算法维护一个二维矩阵<code>D</code>，其中<code>D[i][j]</code> 表示节点 <code>i</code> 到节点 <code>j</code> 的最短路径长度。算法的核心是通过遍历所有节点 <code>k</code>，将节点<code>k</code> 作为中转节点，更新矩阵 <code>D</code> 的值。</p>
<h2 id="Floyd 具体步骤"><a href="#Floyd 具体步骤" class="headerlink" title="Floyd 具体步骤"></a>Floyd 具体步骤</h2><h3 id="Floyd 步骤描述"><a href="#Floyd 步骤描述" class="headerlink" title="Floyd 步骤描述"></a>Floyd 步骤描述</h3><p>Floyd 算法的具体步骤如下：</p>
<ol>
<li>初始化矩阵 <code>D</code>，使得<code>D[i][j]</code> 表示节点 <code>i</code> 到节点 <code>j</code> 的直接距离，如果 <code>i</code> 和<code>j</code>之间没有直接边相连，则 <code>D[i][j]</code> 为无穷大，如果 <code>i</code> 和<code>j</code>相同，则 <code>D[i][j]</code> 为<code>0</code>，否则为直接相连的边的权值。</li>
<li>对于每个节点 <code>k</code>，遍历所有的节点<code>i</code> 和节点 <code>j</code>，如果<code>D[i][k] + D[k][j]</code> 的值小于 <code>D[i][j]</code>，则更新<code>D[i][j]</code> 为<code>D[i][k] + D[k][j]</code>。</li>
<li>重复步骤 2，直到遍历完所有节点<code>k</code>。</li>
<li>最终得到的矩阵 <code>D</code> 即为所有节点对之间的最短路径长度。</li>
</ol>
<p>步骤二利用的是动态规划的思想，其状态转移方程为：<code>D[i][j] = min(D[i][j], D[i][k] + D[k][j])</code>；步骤一中则给出了如何初始化矩阵 <code>D</code> 和<code>D[i][j]</code>的定义。</p>
<h3 id="Floyd 复杂度"><a href="#Floyd 复杂度" class="headerlink" title="Floyd 复杂度"></a>Floyd 复杂度</h3><p>Floyd 算法的时间复杂度为 $O(|V|^{3})$，空间复杂度为 $O(|V|^{2})$，其中 $V$ 是点集。它的优点是可以处理带有负权边的图，并且可以同时求解任意两个节点之间的最短路径。然而，由于其时间复杂度较高，当节点数量较大时，可能会导致算法的运行时间较长。</p>
<h2 id="Floyd 算法图解"><a href="#Floyd 算法图解" class="headerlink" title="Floyd 算法图解"></a>Floyd 算法图解 </h2><h3 id="初始化距离矩阵"><a href="# 初始化距离矩阵" class="headerlink" title="初始化距离矩阵"></a> 初始化距离矩阵 </h3><p><code>D[i][j]</code> 表示节点 <code>i</code> 到节点 <code>j</code> 的直接距离。初始化时，如果 <code>i</code> 和<code>j</code>之间没有直接边相连，则 <code>D[i][j]</code> 为无穷大，如果 <code>i</code> 和<code>j</code>相同，则 <code>D[i][j]</code> 为<code>0</code>，否则为直接相连的边的权值。</p>
<p>例如，节点 A 和节点 B 直接相连，权值为 2，节点 B 和节点 C 没有直接相连，权值为无穷大。</p>
<p><img src="/images/algorithm/floyd-init.png" alt="Floyd 距离矩阵初始化"></p>
<h3 id="更新距离矩阵"><a href="# 更新距离矩阵" class="headerlink" title="更新距离矩阵"></a>更新距离矩阵 </h3><p> 对于每个节点 <code>k</code>，遍历所有的节点<code>i</code> 和节点 <code>j</code>，如果<code>D[i][k] + D[k][j]</code> 的值小于 <code>D[i][j]</code>，则更新<code>D[i][j]</code> 为<code>D[i][k] + D[k][j]</code>。</p>
<p><img src="/images/algorithm/floyd-update.png" alt="Floyd 距离矩阵更新"></p>
<p>例如，当遍历节点 A 时：</p>
<ul>
<li>A 和 B 直接相连、A 和 C 直接相连、B 和 C 没有直接相连，因此可以通过中转节点 A 更新节点 B 和节点 C 的距离为 2+3=5。</li>
<li>A 和 C 直接相连、A 和 D 直接相连、C 和 D 也直接相连，因此也可以通过中转节点 A 更新节点 C 和节点 D 的距离，但是更新的值不小于 C 和 D 直接相连的值，所有不进行更新。</li>
</ul>
<h2 id="Floyd 算法实现"><a href="#Floyd 算法实现" class="headerlink" title="Floyd 算法实现"></a>Floyd 算法实现 </h2><h3 id="Floyd 算法编码"><a href="#Floyd 算法编码" class="headerlink" title="Floyd 算法编码"></a>Floyd 算法编码</h3><p> 假设任意两点的间的距离，存储在邻接矩阵 <code>graph</code> 中，如果两点之间不直接相连，则该位置的值为无穷大 <code>inf</code>，否则为相应的距离值。</p>
<blockquote>
<p>当然，也可以通过数组直接存储直接相连的边的信息，如 <code>[[nodeA, nodeB, distAB], ..., [nodeC, nodeZ, distCZ]]</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf (INT_MAX)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> n (4)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">floydWarshall</span><span class="params">(<span class="type">int</span> graph[n][n])</span> &#123;</span><br><span class="line">    <span class="type">int</span> dist[n][n];</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤一：初始化结果矩阵，使其等于输入图的邻接矩阵 </span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dist[i][j] = graph[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤二 &amp; 三：对每个节点 k 进行遍历，作为中转节点</span></span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        <span class="comment">// 遍历所有节点对(i, j)</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 加入这个判断，防止后面的加法运算溢出</span></span><br><span class="line">                <span class="keyword">if</span> (dist[i][k] == inf || dist[k][j] == inf) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果通过节点 k 可以缩短路径长度，则更新 dist[i][j] 的值</span></span><br><span class="line">                <span class="keyword">if</span> (dist[i][k] + dist[k][j] &lt; dist[i][j]) &#123;</span><br><span class="line">                    dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤四：打印最短路径矩阵</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 最短路径矩阵为：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[i][j] == inf) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;inf &quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, dist[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> graph[n][n] = &#123;&#123;<span class="number">0</span>, <span class="number">5</span>, inf, <span class="number">10</span>&#125;,</span><br><span class="line">                       &#123;inf, <span class="number">0</span>, <span class="number">3</span>, inf&#125;,</span><br><span class="line">                       &#123;inf, inf, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                       &#123;inf, inf, inf, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    floydWarshall(graph);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该代码实现了 Floyd 算法，最终输出的结果是最短路径矩阵，显示了所有节点对之间的最短路径长度。</p>
<blockquote>
<p>注意处理 <code>inf + inf</code> 和 <code>x + inf</code> 相加会造成的数据溢出。</p>
</blockquote>
<h3 id="程序运行结果"><a href="# 程序运行结果" class="headerlink" title="程序运行结果"></a>程序运行结果 </h3><p> 无向图 <code>graph</code> 中直接相连的节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0]---5---[1]</span><br><span class="line"> |         |</span><br><span class="line"> 10        3</span><br><span class="line"> |         |</span><br><span class="line">[3]---1---[2]</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最短路径矩阵为：</span><br><span class="line">0 5 8 9</span><br><span class="line">inf 0 3 4</span><br><span class="line">inf inf 0 1</span><br><span class="line">inf inf inf 0</span><br></pre></td></tr></table></figure>

<h3 id="Floyd 算法优化"><a href="#Floyd 算法优化" class="headerlink" title="Floyd 算法优化"></a>Floyd 算法优化 </h3><p> 对于无向图，节点对 <code>(i, j)</code> 和节点对 <code>(j, i)</code>具有相同的权值（距离）。当遍历每一个中转节点时，<code>D[i][j]</code>的值的更新，只跟三个位置有关，即 <code>i, j, k</code>；而此时 <code>k</code> 固定，在 <code>i, j</code> 的双重循环下，会产生重复操作，因此我们可以只遍历矩阵右上三角部分即可，即 <code>j</code> 从 <code>i + 1</code> 开始遍历。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; n; j++) &#123;  <span class="comment">// 去掉重复的计算 </span></span><br><span class="line">            <span class="keyword">if</span> (dist[i][k] == inf || dist[k][j] == inf) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dist[i][k] + dist[k][j] &lt; dist[i][j]) &#123;</span><br><span class="line">                dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line">                dist[j][i] = dist[i][j];  <span class="comment">// 一并更新反向节点(j, i) 的距离</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Floyd 算法，俗称插点法，不就一个点 <code>k</code> 一个点 <code>k&#39;</code> 地插进去，作为中转节点，更新节点对之间的距离嘛</strong>！</p>
<blockquote>
<p>参考资料 &amp; 图源：<a href="https://www.cnblogs.com/bigsai/p/15213511.html">https://www.cnblogs.com/bigsai/p/15213511.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>图算法</category>
      </categories>
      <tags>
        <tag>Floyd算法</tag>
        <tag>多源最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法之二分查找</title>
    <url>/posts/231124181658.html</url>
    <content><![CDATA[<p>二分查找算法是一种在有序数组中查找特定元素的常用算法，它的时间复杂度为 <code>O(log n)</code>；由于每次查找都将数组规模减半，因此算法的效率非常高。本文记录了二分查找的常见场景，给出在升序数组中：</p>
<ul>
<li>查找给定目标值的索引；</li>
<li>查找大于等于目标值的最小索引、查找大于目标值的最小索引；</li>
<li>查找小于等于目标值的最大索引、查找小于目标值的最大索引。</li>
</ul>
<span id="more"></span>

<h2 id="二分查找难点"><a href="# 二分查找难点" class="headerlink" title="二分查找难点"></a>二分查找难点 </h2><p> 二分查找最难把握的就是：</p>
<ol>
<li><code>while</code> 循环的条件到底要不要加等于号：</li>
<li>不同的 <code>if</code> 判断下，要不要加、减一。</li>
</ol>
<blockquote>
<p>记住，在 <code>while</code> 条件不加「等号」时，<code>l</code> 和 <code>r</code> 只有一个加（或减）一；在 <code>while</code> 条件加「等号」时，<code>l</code> 和 <code>r</code> 都有加一（或减）一。然后，再梳理清楚其它细节即可。</p>
</blockquote>
<h2 id="查找目标值的索引"><a href="# 查找目标值的索引" class="headerlink" title="查找目标值的索引"></a>查找目标值的索引 </h2><p> 例如，升序数组为 <code>[1, 3, 5, 7, 12, 12, 12, 13, 16]</code>，目标值为 <code>12</code>，那么可能返回索引 <code>4, 5, 6</code> 中的一个。若目标值不存在，则返回 <code>-1</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分查找给定目标值的索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> target, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123; <span class="comment">// 等于</span></span><br><span class="line">        <span class="type">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>; <span class="comment">// 右值减一</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查找大于等于目标值的最小索引（下限）"><a href="# 查找大于等于目标值的最小索引（下限）" class="headerlink" title="查找大于等于目标值的最小索引（下限）"></a>查找大于等于目标值的最小索引（下限）</h2><p>例如，升序数组为 <code>[1, 3, 5, 7, 12, 12, 12, 13, 16]</code>，目标值为 <code>12</code>，那么应该返回索引 <code>4</code>。若数组中不存在大于等于目标值的数，则返回 <code>-1</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找大于等于目标值的最小索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findGreateEq</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> target, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123; <span class="comment">// 不加等于</span></span><br><span class="line">        <span class="type">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid; <span class="comment">// 右值不减</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[l] &gt;= target ? l : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为查找的是「<strong>大于等于 </strong> 目标值的最小索引」，所以在 <code>mid</code> 位置：</p>
<ul>
<li>小于目标值时，最小索引应该落在区间 <code>[mid + 1, r]</code>，所以 <code>l</code> 更新为 <code>l = mid + 1</code>。</li>
<li><strong>大于等于 </strong> 目标值时，最小索引应该落在区间 <code>[l, mid]</code>，所以 <code>r</code> 更新为 <code>r = mid</code>，而不是 <code>r = mid - 1</code>；</li>
</ul>
<h2 id="查找大于目标值的最小索引"><a href="# 查找大于目标值的最小索引" class="headerlink" title="查找大于目标值的最小索引"></a>查找大于目标值的最小索引 </h2><p> 例如，升序数组为 <code>[1, 3, 5, 7, 12, 12, 12, 13, 16]</code>，目标值为 <code>12</code>，那么应该返回索引 <code>7</code>。若数组中不存在大于目标值的数，则返回 <code>-1</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找大于目标值的最小索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findGreate</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> target, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123; <span class="comment">// 不加等于</span></span><br><span class="line">        <span class="type">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt;= target) &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid; <span class="comment">// 右值不减</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[l] &gt; target ? l : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为查找的是「<strong>大于 </strong> 目标值的最小索引」，所以在 <code>mid</code> 位置：</p>
<ul>
<li>小于等于目标值时，最小索引应该落在区间 <code>[mid + 1, r]</code>，所以 <code>l</code> 更新为 <code>l = mid + 1</code>。</li>
<li><strong>大于 </strong> 目标值时，最小索引应该落在区间 <code>[l, mid]</code>，所以 <code>r</code> 更新为 <code>r = mid</code>，而不是 <code>r = mid - 1</code>；</li>
</ul>
<h2 id="查找小于等于目标值的最大索引（上限）"><a href="# 查找小于等于目标值的最大索引（上限）" class="headerlink" title="查找小于等于目标值的最大索引（上限）"></a>查找小于等于目标值的最大索引（上限）</h2><p>例如，升序数组为 <code>[1, 3, 5, 7, 12, 12, 12, 13, 16]</code>，目标值为 <code>12</code>，那么应该返回索引 <code>6</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找小于等于目标值的最大索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findLessEq</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> target, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;  <span class="comment">// 不加等于</span></span><br><span class="line">        <span class="comment">// 加一是为了向上取整，防止 while 死循环</span></span><br><span class="line">        <span class="type">int</span> mid = l + ((r + <span class="number">1</span> - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt;= target) &#123;</span><br><span class="line">            l = mid; <span class="comment">// 左值不加</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[r] &lt;= target ? r : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为查找的是「<strong>小于等于 </strong> 目标值的最大索引」，所以在 <code>mid</code> 位置：</p>
<ul>
<li><strong>小于等于 </strong> 目标值时，最大索引应该落在区间 <code>[mid, r]</code>，所以 <code>l</code> 更新为 <code>l = mid</code>，而不是 <code>l = mid + 1</code>；</li>
<li>大于目标值时，最大索引应该落在区间 <code>[l, mid - 1]</code>，所以 <code>r</code> 更新为 <code>r = mid - 1</code>。</li>
</ul>
<h2 id="查找小于目标值的最大索引"><a href="# 查找小于目标值的最大索引" class="headerlink" title="查找小于目标值的最大索引"></a>查找小于目标值的最大索引 </h2><p> 例如，升序数组为 <code>[1, 3, 5, 7, 12, 12, 12, 13, 16]</code>，目标值为 <code>12</code>，那么应该返回索引 <code>3</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找小于目标值的最大索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findLess</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> target, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;  <span class="comment">// 不加等于</span></span><br><span class="line">        <span class="comment">// 加一是为了向上取整，防止 while 死循环</span></span><br><span class="line">        <span class="type">int</span> mid = l + ((r + <span class="number">1</span> - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">            l = mid; <span class="comment">// 左值不加</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[r] &lt; target ? r : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为查找的是「<strong>小于 </strong> 目标值的最大索引」，所以在 <code>mid</code> 位置：</p>
<ul>
<li><strong>小于 </strong> 目标值时，最大索引应该落在区间 <code>[mid, r]</code>，所以 <code>l</code> 更新为 <code>l = mid</code>，而不是 <code>l = mid + 1</code>；</li>
<li>大于等于目标值时，最大索引应该落在区间 <code>[l, mid - 1]</code>，所以 <code>r</code> 更新为 <code>r = mid - 1</code>。</li>
</ul>
<h2 id="功能测试"><a href="# 功能测试" class="headerlink" title="功能测试"></a>功能测试 </h2><h3 id="测试代码"><a href="# 测试代码" class="headerlink" title="测试代码"></a> 测试代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr1[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">16</span>&#125;;</span><br><span class="line">    <span class="type">int</span> arr2[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">17</span>&#125;;</span><br><span class="line">    <span class="type">int</span> size1 = <span class="keyword">sizeof</span>(arr1) / <span class="keyword">sizeof</span>(arr1[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> size2 = <span class="keyword">sizeof</span>(arr2) / <span class="keyword">sizeof</span>(arr2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;t\tidx\tgeqIdx\tgIdx\tleqIdx\tlIdx\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size2; i++) &#123;</span><br><span class="line">        <span class="type">int</span> target = arr2[i];</span><br><span class="line">        <span class="type">int</span> targetIdx = binarySearch(arr1, target, <span class="number">0</span>, size1 - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> greateEqIdx = findGreateEq(arr1, target, <span class="number">0</span>, size1 - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> greateIdx = findGreate(arr1, target, <span class="number">0</span>, size1 - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> lessEqIdx = findLessEq(arr1, target, <span class="number">0</span>, size1 - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> lessIdx = findLess(arr1, target, <span class="number">0</span>, size1 - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t%d\t%d\t%d\t%d\t%d\n&quot;</span>, target, targetIdx, greateEqIdx, greateIdx, lessEqIdx, lessIdx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试结果"><a href="# 测试结果" class="headerlink" title="测试结果"></a>测试结果 </h3><p> 上述测试代码的测试结果如下，可以发现结果是正确的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t       idx     geqIdx  gIdx    leqIdx  lIdx</span><br><span class="line">0       -1      0       0       -1      -1</span><br><span class="line">1       0       0       1       0       -1</span><br><span class="line">3       1       1       2       1       0</span><br><span class="line">5       2       2       3       2       1</span><br><span class="line">7       3       3       4       3       2</span><br><span class="line">11      -1      4       4       3       3</span><br><span class="line">12      4       4       7       6       3</span><br><span class="line">13      7       7       8       7       6</span><br><span class="line">16      8       8       -1      8       7</span><br><span class="line">17      -1      -1      -1      8       8</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法之堆排序</title>
    <url>/posts/231107171607.html</url>
    <content><![CDATA[<p>堆排序是一种基于二叉堆数据结构的排序算法。它的主要思想是将待排序的序列构建成一个大顶堆（或小顶堆），然后 <strong> 依次取出堆顶元素，将其与堆中最后一个元素交换，并调整堆，使得剩余元素仍满足堆的性质</strong>。重复这个过程，直到堆中只剩下一个待调整元素，即可得到一个有序序列。</p>
<p>上面说，大顶堆依次将堆顶（当前最大）元素与堆中最后一个元素交换。因此，基于大顶堆的堆排序后的结果是一个升序序列，基于小顶堆的堆排序后的结果是一个降序序列。</p>
<span id="more"></span>

<blockquote>
<p>上面调整堆的堆化过程，是将「剩余的元素」重新构造成一个堆（通过交换的方式放在堆尾的元素不再参与堆化调整）。</p>
</blockquote>
<h2 id="堆排序步骤"><a href="# 堆排序步骤" class="headerlink" title="堆排序步骤"></a>堆排序步骤 </h2><p> 按文章开头的描述，堆排序的过程可以分为两个主要步骤：<strong>构建堆和调整堆</strong>。下面以大顶堆的堆排序来进行描述。</p>
<ol>
<li><p>构建堆：<br>首先，将待排序的序列构建成一个初始堆。可以 <strong> 从最后一个非叶子节点开始，依次向前遍历 </strong>，对每个节点进行调整，使得该节点的值大于其子节点的值。这个过程称为堆化，可以使用<strong> 下沉操作 </strong> 来实现。</p>
</li>
<li><p>调整堆：<br>将堆顶元素与堆中最后一个元素交换位置，<strong>并将堆的大小减一 </strong>。然后对堆顶元素进行<strong> 下沉操作</strong>，使得剩余元素仍满足堆的性质。重复这个过程，直到堆中只剩下一个元素，即可得到一个有序序列。</p>
</li>
</ol>
<p>堆排序在实际应用中具有较高的效率和稳定性，尤其适用于大规模数据的排序。</p>
<blockquote>
<p>堆化的两个主要操作是下沉（弹出堆顶元素时使用）和上浮（往堆中添加新元素时使用）操作，可以参考 <a href="https://pursue26.github.io/posts/231018102559.html"> 数据结构之堆基础与堆结构（数组实现）</a>。</p>
</blockquote>
<h2 id="堆排序复杂度"><a href="# 堆排序复杂度" class="headerlink" title="堆排序复杂度"></a>堆排序复杂度 </h2><p> 堆排序的时间复杂度为 <code>O(nlogn)</code>，其中 <code>n</code> 是待排序序列的长度。由于堆排序只需要常数的辅助空间，因此它是一种原地排序算法，空间复杂度为 <code>O(1)</code>。但 <strong> 堆排序是不稳定的排序算法，即相同元素的顺序可能会发生改变</strong>。</p>
<h2 id="堆排序实现"><a href="# 堆排序实现" class="headerlink" title="堆排序实现"></a>堆排序实现 </h2><h3 id="从无序序列构建堆"><a href="# 从无序序列构建堆" class="headerlink" title="从无序序列构建堆"></a> 从无序序列构建堆 </h3><p> 对于给定的长度为 $n$ 的无序序列进行堆排序的第一个过程是：构建堆——将无序序列构建成一个二叉堆数据结构。</p>
<p>上面说「从最后一个非叶子节点开始，依次向前遍历」，最后一个非叶子节点的数组索引（从 $0$ 开始）为 $n/2 - 1$。</p>
<p>为了完成从无序序列构建堆的这一过程。我们首先给出堆化中的下沉操作。<strong>假设，我们现在已经有一个满足堆属性的数组，当我们修改了数组某一个索引位置的值时，就需要重新对这个位置，以及之前的所有位置都进行堆化调整</strong>。</p>
<p>例如，对于下面的大顶堆：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    60</span><br><span class="line">   /  \</span><br><span class="line">  30  40</span><br><span class="line"> / \</span><br><span class="line">25 28</span><br></pre></td></tr></table></figure>

<p>如果把索引 1 位置的值 30 修改为 70，那么索引 1 和 索引 0 都需要进行堆化调整。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 调整索引 1 位置</span><br><span class="line">        60</span><br><span class="line">       /  \</span><br><span class="line">      70  40</span><br><span class="line">     / \</span><br><span class="line">    25 28</span><br><span class="line"></span><br><span class="line">// 调整索引 0 位置</span><br><span class="line">        70</span><br><span class="line">       /  \</span><br><span class="line">      60  40</span><br><span class="line">     / \</span><br><span class="line">    25 28</span><br></pre></td></tr></table></figure>

<p>如果把索引 1 位置的值 30 修改为 15，那么索引 1 和 索引 0 也都需要进行堆化调整。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 调整索引 1 位置</span><br><span class="line">        60</span><br><span class="line">       /  \</span><br><span class="line">      28  40</span><br><span class="line">     / \</span><br><span class="line">    25 15</span><br><span class="line"></span><br><span class="line">// 调整索引 0 位置（满足堆属性，随即退出）</span><br><span class="line">        60</span><br><span class="line">       /  \</span><br><span class="line">      28  40</span><br><span class="line">     / \</span><br><span class="line">    25 15</span><br></pre></td></tr></table></figure>

<p>对于给定的长度为 <code>n</code> 的数组（满足堆属性），当修改了索引 <code>i</code> 位置的值时，堆化调整以索引 <code>i</code> 为根节点的子树，使这棵以索引 <code>i</code> 为根节点的树重新满足堆属性（但不再能保证整个数组满足堆属性，若需要整棵树都满足堆属性，还需要按顺序对以索引 <code>i-1</code> 到以索引 <code>0</code>为根的子树进行堆化调整）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下沉操作，使以索引 i 为根节点的子树满足堆属性</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="type">int</span> largest = i;  <span class="comment">// 初始化根节点为最大值</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;  <span class="comment">// 左子节点</span></span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;  <span class="comment">// 右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子节点大于根节点，则更新最大值</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果右子节点大于根节点，则更新最大值</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果最大值不是根节点，则进行交换，并递归调整子堆</span></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="type">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[largest];</span><br><span class="line">        arr[largest] = temp;</span><br><span class="line"></span><br><span class="line">        heapify(arr, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在开始从最后一个非叶子节点，依次向前遍历进行下沉堆化。每遍历一个节点，都会使得以这个节点为根节点的树满足堆属性，那么当遍历完索引为 <code>0</code> 的位置后，整个数组将满足堆属性，构成一棵二叉堆。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建堆（从最后一个非叶子节点开始，依次向前遍历进行下沉堆化）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    heapify(arr, n, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调整堆"><a href="# 调整堆" class="headerlink" title="调整堆"></a>调整堆 </h3><p> 将堆顶元素与堆中最后一个元素交换位置，<strong>并将堆的大小减一 </strong>。然后对堆顶元素进行<strong> 下沉操作</strong>，使得剩余元素仍满足堆的性质。重复这个过程，直到堆中只剩下一个元素，即可得到一个有序序列。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 依次取出堆顶元素，并调整这个更小的堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="type">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">    arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">    arr[i] = temp;</span><br><span class="line">    heapify(arr, i, <span class="number">0</span>);  <span class="comment">// 将堆的大小减小为 i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆排序完整代码"><a href="# 堆排序完整代码" class="headerlink" title="堆排序完整代码"></a>堆排序完整代码 </h2><h3 id="堆排序代码"><a href="# 堆排序代码" class="headerlink" title="堆排序代码"></a> 堆排序代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> i)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(arr, n, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">        heapify(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序测试代码"><a href="# 堆排序测试代码" class="headerlink" title="堆排序测试代码"></a>堆排序测试代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> i)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 原始数组：&quot;</span>);</span><br><span class="line">    printArray(arr, n);</span><br><span class="line"></span><br><span class="line">    heapSort(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 排序后数组：&quot;</span>);</span><br><span class="line">    printArray(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试结果"><a href="# 测试结果" class="headerlink" title="测试结果"></a>测试结果 </h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 原始数组：12 11 13 5 6 7</span><br><span class="line">排序后数组：5 6 7 11 12 13</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>堆排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法之 Dijkstra 单源最短路径（原理部分）</title>
    <url>/posts/231117095232.html</url>
    <content><![CDATA[<p>戴克斯特拉算法（Dijkstra’s algorithm），又称迪杰斯特拉算法、Dijkstra 算法，是由荷兰计算机科学家艾兹赫尔·戴克斯特拉在 1956 年发现的算法。戴克斯特拉算法使用类似广度优先搜索的方法解决赋权图的 <strong> 单源 </strong> 最短路径问题。它可以应用于有向图和无向图，常被应用于网络路由、交通规划等领域。但对于带有负权边的图，Dijkstra 算法无法正确计算最短路径，需要使用其他算法，如 Bellman-Ford 算法。</p>
<span id="more"></span>

<h2 id="Dijkstra 基本思想"><a href="#Dijkstra 基本思想" class="headerlink" title="Dijkstra 基本思想"></a>Dijkstra 基本思想</h2><p>Dijkstra 算法可以计算从图中的一个节点出发到其他所有节点的最短路径。它的基本思想是从源节点开始，通过选择当前距离源节点最近的未访问节点，不断更新和调整节点的最短路径和距离值，直到找到所有节点的最短路径为止。</p>
<blockquote>
<p>Dijkstra 算法属于贪心策略（算法执行完后，才能得到全局最优解）。</p>
</blockquote>
<h2 id="Dijkstra 具体步骤"><a href="#Dijkstra 具体步骤" class="headerlink" title="Dijkstra 具体步骤"></a>Dijkstra 具体步骤</h2><h3 id="Dijkstra 步骤描述"><a href="#Dijkstra 步骤描述" class="headerlink" title="Dijkstra 步骤描述"></a>Dijkstra 步骤描述</h3><p>Dijkstra 算法的具体步骤如下：</p>
<ol>
<li>创建一个距离数组<code>dist[]</code>，用于存储源节点到各个节点的最短路径长度。初始时，将源节点的距离设为 0，与源节点直接相连的节点的距离设为边的权重，其他节点的距离设为无穷大。</li>
<li>创建一个标记数组<code>visited[]</code>，用于标记是否已经访问过该节点。初始时，将源节点标记为已访问，其他节点标记为未访问。</li>
<li>以源节点为基准，遍历所有与其相邻的、未访问过的节点，计算「源节点」到这些相邻节点的距离，并从未访问的节点中选择距离「源节点」最近的节点，作为基准节点。</li>
<li>以这个基准节点为中间节点，更新从源节点经过中间节点到达其它节点的距离到 <code>dist[]</code> 数组中，并将这个基准节点标记为已访问。<ul>
<li>更新的方式是：如果「从新的中间节点」到「该节点」的距离小于原本到它的距离，则更新它的值（你要从这个节点走才更近了哦），并将这个中间节点作为它的前驱节点。</li>
</ul>
</li>
<li>重复步骤 3 和步骤 4，直到所有节点都被访问过。</li>
<li>最终，<code>dist[]</code>数组中存储的就是源节点到其他所有节点的最短路径长度。</li>
</ol>
<blockquote>
<p>步骤三中的「相邻」节点包括直接与源节点相邻、通过已访问的节点间接与源节点相邻这两大类。换句话说，也就是 <code>dist[]</code> 数组中只要不是无穷大，就与源节点直接或间接相邻。</p>
</blockquote>
<h3 id="Dijkstra 复杂度"><a href="#Dijkstra 复杂度" class="headerlink" title="Dijkstra 复杂度"></a>Dijkstra 复杂度</h3><p>Dijkstra 算法的时间复杂度为 $O(|V|^{2})$，空间复杂度为 $O(|V|^{2})$，主要为二维邻接矩阵、一维的距离矩阵、访问矩阵、前驱矩阵，其中 $V$ 是点集。</p>
<h2 id="Dijkstra 算法图解"><a href="#Dijkstra 算法图解" class="headerlink" title="Dijkstra 算法图解"></a>Dijkstra 算法图解 </h2><p> 假设有下面这个图：<br><img src="../images/algorithm/dijkstra-0.png" alt=""></p>
<p>Dijkstra 算法将会寻找出图中节点 <code>0</code> 到所有其他节点的最短路径。</p>
<h3 id="初始化 dist 数组"><a href="# 初始化 dist 数组" class="headerlink" title="初始化 dist 数组"></a>初始化 dist 数组 </h3><p> 创建一个距离数组<code>dist[]</code>，用于存储源节点到各个节点的最短路径长度。初始时，源节点到自己的距离为 0，与源节点直接相连的节点的距离设为边的权重，到其它节点的距离还没有确定，所以先标记为无穷大。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node:   [0, 1, 2, 3, 4, 5, 6]</span><br><span class="line">dist:   [0, 2, 6, ∞, ∞, ∞, ∞]</span><br></pre></td></tr></table></figure>

<h3 id="初始化 visited 数组"><a href="# 初始化 visited 数组" class="headerlink" title="初始化 visited 数组"></a>初始化 visited 数组 </h3><p> 创建一个标记数组<code>visited[]</code>，用于标记是否已经访问过该节点。初始时，将源节点标记为已访问，其他节点标记为未访问。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node:   [0, 1, 2, 3, 4, 5, 6]</span><br><span class="line">dist:   [0, 2, 6, ∞, ∞, ∞, ∞]</span><br><span class="line">visted: [1, 0, 0, 0, 0, 0, 0]</span><br></pre></td></tr></table></figure>

<h3 id="初始化 prev 数组"><a href="# 初始化 prev 数组" class="headerlink" title="初始化 prev 数组"></a>初始化 prev 数组 </h3><p> 创建一个前驱数组<code>prev[]</code>，用于存储到达该节点的最短路径上的倒数第二个节点（通过哪个节点到达的该节点）。初始时，与源节点直接相连的节点的前驱节点就是源节点，其它节点的前驱节点无法确定，先标记为无效节点（源节点到源节点的路径，没有倒数第二个节点，也标记为无效节点）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node:   [0, 1, 2, 3, 4, 5, 6]</span><br><span class="line">dist:   [0, 2, 6, ∞, ∞, ∞, ∞]</span><br><span class="line">visted: [1, 0, 0, 0, 0, 0, 0]</span><br><span class="line">prev:  [-1, 0, 0,-1,-1,-1,-1]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>记住，当所有节点都被标记为已访问（被添加到路径中）时，算法的计算过程就完成了。</p>
</blockquote>
<h3 id="遍历相邻节点"><a href="# 遍历相邻节点" class="headerlink" title="遍历相邻节点"></a>遍历相邻节点 </h3><p> 我们选择了从节点 <code>0</code> 出发，可以直接将它标记为「已访问」，并在图中给它加上红色的边框：<br><img src="../images/algorithm/dijkstra-1.png" alt=""></p>
<hr>
<p>以源节点 <code>0</code> 为基准，遍历所有与其相邻的、未访问过的节点（节点 <code>1</code> 和 <code>2</code>），计算源节点到这些相邻节点的距离，并更新 <code>dist[]</code> 数组中的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node:   [0, 1, 2, 3, 4, 5, 6]</span><br><span class="line">dist:   [0, 2, 6, ∞, ∞, ∞, ∞]</span><br><span class="line">visted: [1, 0, 0, 0, 0, 0, 0]</span><br><span class="line">prev:  [-1, 0, 0,-1,-1,-1,-1]</span><br></pre></td></tr></table></figure>
<p>从表格中可以看出，当前：</p>
<ul>
<li>从源节点 <code>0</code> 到节点 <code>1</code> 的最短距离为 2（通过源节点 <code>0</code> 到达节点 <code>1</code>）；</li>
<li>从源节点 <code>0</code> 到节点 <code>2</code> 的最短距离为 6（通过源节点 <code>0</code> 到达节点 <code>1</code>）。</li>
</ul>
<p>然后，我们 <strong> 从未访问的节点（节点 <code>1</code> 和节点 <code>2</code>）中选择距离源节点最近的节点（节点 <code>1</code>），作为下一个基准节点，并将其标记为已访问</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node:   [0, 1, 2, 3, 4, 5, 6]</span><br><span class="line">dist:   [0, 2, 6, ∞, ∞, ∞, ∞]</span><br><span class="line">visted: [1, 1, 0, 0, 0, 0, 0]</span><br><span class="line">prev:  [-1, 0, 0,-1,-1,-1,-1]</span><br></pre></td></tr></table></figure>
<p>因此，节点 <code>1</code> 标记为已访问（节点 <code>2</code> 不标记为已访问），并更新节点 <code>1</code> 的上一个节点为节点 <code>0</code>。</p>
<p>图中给已访问的节点 <code>1</code> 加上红色的边框，上一个节点 <code>0</code> 到该节点 <code>1</code> 的路径（边）被染红：<br><img src="../images/algorithm/dijkstra-2.png" alt=""></p>
<p>然后，节点 <code>1</code> 将作为下一个基准节点，重复上述遍历相邻节点的操作。</p>
<hr>
<p>以节点 <code>1</code> 为基准，遍历所有与其相邻的、未访问过的节点（节点 <code>3</code>），计算源节点到这些相邻节点的距离，并更新 <code>dist[]</code> 数组中的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node:   [0, 1, 2, 3, 4, 5, 6]</span><br><span class="line">dist:   [0, 2, 6, 7, ∞, ∞, ∞]</span><br><span class="line">visted: [1, 1, 0, 0, 0, 0, 0]</span><br><span class="line">prev:  [-1, 0, 0,-1,-1,-1,-1]</span><br></pre></td></tr></table></figure>
<p>从表格中可以看出，当前：</p>
<ul>
<li>从源节点 <code>0</code> 到节点 <code>3</code> 的最短距离为 7（通过中间节点 <code>1</code> 到达节点 <code>3</code>）。</li>
<li>从源节点 <code>0</code> 到节点 <code>2</code> 的最短距离为 6（通过源节点 <code>0</code> 到达节点 <code>2</code>）。</li>
</ul>
<blockquote>
<p>注意，往轮遍历中未被标记为已访问的节点（这里是节点 <code>2</code>）也需要参与距离比较、也可作为下一个基准节点哦！</p>
</blockquote>
<p>然后，我们 <strong> 从未访问的节点（节点 <code>2</code> 和节点 <code>3</code>）中选择距离源节点 <code>0</code> 最近的节点（节点 <code>2</code>），作为下一个基准节点，并将其标记为已访问</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node:   [0, 1, 2, 3, 4, 5, 6]</span><br><span class="line">dist:   [0, 2, 6, 7, ∞, ∞, ∞]</span><br><span class="line">visted: [1, 1, 1, 0, 0, 0, 0]</span><br><span class="line">prev:  [-1, 0, 0,-1,-1,-1,-1]</span><br></pre></td></tr></table></figure>
<p>因此，节点 <code>2</code> 标记为已访问（节点 <code>3</code> 不标记为已访问），并更新节点 <code>2</code> 的上一个节点为节点 <code>0</code>。</p>
<p>图中给已访问的节点 <code>2</code> 加上红色的边框，上一个节点 <code>0</code> 到该节点 <code>2</code> 的路径（边）被染红：<br><img src="../images/algorithm/dijkstra-3.png" alt=""></p>
<p>然后，节点 <code>2</code> 将作为下一个基准节点，重复上述遍历相邻节点的操作。</p>
<hr>
<p>以节点 <code>2</code> 为基准，遍历所有与其相邻的、未访问过的节点（节点 <code>3</code>），计算源节点到这些相邻节点的距离，并更新 <code>dist[]</code> 数组中的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node:   [0, 1, 2, 3, 4, 5, 6]</span><br><span class="line">dist:   [0, 2, 6, 7, ∞, ∞, ∞]</span><br><span class="line">visted: [1, 1, 1, 0, 0, 0, 0]</span><br><span class="line">prev:  [-1, 0, 0,-1,-1,-1,-1]</span><br></pre></td></tr></table></figure>
<p>从表格中可以看出，当前：</p>
<ul>
<li>从源节点 <code>0</code> 到节点 <code>3</code> 的最短距离为 14（通过中间节点 <code>2</code> 到达节点 <code>3</code>）。</li>
<li>从源节点 <code>0</code> 到节点 <code>3</code> 的最短距离为 7（通过另一个中间节点 <code>1</code> 到达节点 <code>3</code>）。</li>
</ul>
<p>然后，我们 <strong> 从未访问的节点（节点 <code>3</code>）中选择距离源节点 <code>0</code> 最近的节点（节点 <code>3</code>），作为下一个基准节点，并将其标记为已访问</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node:   [0, 1, 2, 3, 4, 5, 6]</span><br><span class="line">dist:   [0, 2, 6, 7, ∞, ∞, ∞]</span><br><span class="line">visted: [1, 1, 1, 1, 0, 0, 0]</span><br><span class="line">prev:  [-1, 0, 0, 1,-1,-1,-1]</span><br></pre></td></tr></table></figure>
<p>因此，节点 <code>3</code> 标记为已访问，并更新节点 <code>3</code> 的 <strong> 上一个节点为节点 <code>1</code></strong>（而不是节点 <code>2</code>）。</p>
<p>图中给已访问的节点 <code>3</code> 加上红色的边框，上一个节点 <code>1</code> 到该节点 <code>3</code> 的路径（边）被染红：<br><img src="../images/algorithm/dijkstra-4.png" alt=""></p>
<p>然后，节点 <code>3</code> 将作为下一个基准节点，重复上述遍历相邻节点的操作。</p>
<hr>
<p>经过多次选择新的基准节点，并进行遍历相邻接点的操作后，所有节点都被标记为已访问（被添加到路径中），算法的计算过程就完成了。现在，<code>dist[]</code>数组中存储的就是源节点到其他所有节点的最短路径长度。</p>
<p>最终的表格为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node:   [0,  1,  2,  3,  4,  5,  6]</span><br><span class="line">dist:   [0,  2,  6,  7, 17, 22, 19]</span><br><span class="line">visted: [1,  1,  1,  1,  1,  1,  1]</span><br><span class="line">prev:  [-1,  0,  0,  1,  3,  3,  4]</span><br></pre></td></tr></table></figure>

<p>最终表格对应的可视化图：<br><img src="../images/algorithm/dijkstra-n.png" alt=""></p>
<p>从表格或图中可以看出：</p>
<ul>
<li>源节点 <code>0</code> 到节点 <code>1, 2, 3, 4, 5, 6</code> 的最短距离分别为 <code>2, 6, 7, 17, 22, 19</code>；</li>
<li>源节点 <code>0</code> 到节点 <code>6</code> 的最短路径为 <code>0-&gt;1-&gt;3-&gt;4-&gt;6</code>，这可以通过表格中的 <code>prev[]</code> 数组得出最短路径：节点 <code>6</code> 的上一个节点为 <code>4</code>，节点 <code>4</code> 的上一个节点为 <code>3</code>，节点 <code>3</code> 的上一个节点为 <code>1</code>，节点 <code>1</code> 的上一个节点为 <code>0</code>。</li>
</ul>
<blockquote>
<p>参考资料 &amp; 图源：</p>
<ol>
<li><a href="https://www.freecodecamp.org/chinese/news/dijkstras-shortest-path-algorithm-visual-introduction/">https://www.freecodecamp.org/chinese/news/dijkstras-shortest-path-algorithm-visual-introduction/</a></li>
<li><a href="https://b23.tv/XWF7K0p">https://b23.tv/XWF7K0p</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>图算法</category>
      </categories>
      <tags>
        <tag>Dijkstra算法</tag>
        <tag>单源最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之队列（链表实现）</title>
    <url>/posts/231017105123.html</url>
    <content><![CDATA[<p>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，在表的后端（rear）进行插入操作。与堆栈一样，队列也是一种操作受限制的线性表，进行插入操作的端称为队尾，进行删除操作的端称为队头。数据的入队和出队遵循先进先出（FIFO, First-In First-Out）的原则。</p>
<span id="more"></span>

<p>这篇文章主要介绍通过链表实现队列，但会首先介绍一下队列的几种实现方式和各自的特点、适用场景。</p>
<h2 id="队列的实现方式"><a href="# 队列的实现方式" class="headerlink" title="队列的实现方式"></a>队列的实现方式 </h2><p> 在 C 语言中，FIFO 队列的实现方式有以下几种：</p>
<ol>
<li><p>数组实现：使用一个固定大小的数组作为队列的存储空间，使用两个指针 front 和 rear 分别指向队列的头部和尾部，通过不断移动指针和调整数组元素的位置来实现入队和出队操作。</p>
</li>
<li><p>链表实现：使用链表作为队列的存储结构，通过定义一个链表节点结构体来存储队列元素的值和指向下一个节点的指针。通过调整链表节点的指针关系来实现入队和出队操作。</p>
</li>
<li><p>循环队列实现：使用一个固定大小的数组作为队列的存储空间，同时使用两个指针 front 和 rear 分别指向队列的头部和尾部。当 rear 指针到达数组末尾时，再次从数组头部开始存储元素，实现循环利用数组空间的效果。</p>
</li>
</ol>
<h2 id="不同实现方式适用的场景"><a href="# 不同实现方式适用的场景" class="headerlink" title="不同实现方式适用的场景"></a>不同实现方式适用的场景 </h2><p> 数组实现队列、链表实现队列和循环队列实现，都有各自的特点和适用场景，以下是不同实现方式的一些适用场景：</p>
<ol>
<li><p>数组实现适用于以下场景：</p>
<ul>
<li>队列大小固定，不需要频繁进行大小调整。</li>
<li>元素个数相对较少，不会造成数组空间的浪费。</li>
<li>需要快速随机访问队列元素。</li>
</ul>
</li>
<li><p>链表实现适用于以下场景：</p>
<ul>
<li>队列大小不确定，会频繁进行大小调整。</li>
<li>元素个数可能非常大，链表能够动态分配内存。</li>
<li>需要频繁进行插入和删除操作。</li>
</ul>
</li>
<li><p>循环队列实现适用于以下场景：</p>
<ul>
<li>队列大小固定，不需要频繁进行大小调整。</li>
<li>队列元素个数可能会超过数组大小，但是可以接受覆盖旧元素的方式。</li>
<li>需要快速入队和出队操作。</li>
</ul>
</li>
</ol>
<p>根据实际需求和对性能的要求，可以选择适合的实现方式。例如，如果队列大小固定且元素个数不会超过数组大小，可以选择数组实现；如果队列大小不确定且需要频繁进行插入和删除操作，可以选择链表实现；如果队列大小固定但元素个数可能超过数组大小且需要快速入队和出队操作，可以选择循环队列实现。</p>
<h2 id="链表实现队列"><a href="# 链表实现队列" class="headerlink" title="链表实现队列"></a>链表实现队列 </h2><h3 id="定义基于链表的队列结构"><a href="# 定义基于链表的队列结构" class="headerlink" title="定义基于链表的队列结构"></a> 定义基于链表的队列结构 </h3><p><strong> 为了体现队列中数据的复杂性</strong>，这里不再使用基本数据类型（如整形、字符型）作为队列中的数据，而是使用了二叉树结构，即在队列中保存的数据是一个二叉树节点，节点中包含节点值、节点的左子树指针和节点的右子树指针。</p>
<img src="../images/data-structure/fifo-queue-struct.png" alt="FIFO 队列数据结构" width="80%" height="80%">

<p>首先，定义二叉树的结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagTreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagTreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagTreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode_t;</span><br></pre></td></tr></table></figure>

<p>然后，定义链表的结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Define the structure for a node in the queue</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagLinkedNode</span> &#123;</span></span><br><span class="line">    TreeNode_t *data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagLinkedNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LinkedNode_t;</span><br></pre></td></tr></table></figure>

<p>在这里，链表中的成员就是：用于存储二叉树节点数据的结构体和指向下一个链表节点的指针。</p>
<p>最后，定义队列的结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Define the structure for the queue</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagQueue</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    LinkedNode_t *front;</span><br><span class="line">    LinkedNode_t *rear;</span><br><span class="line">&#125; Queue_t;</span><br></pre></td></tr></table></figure>

<p>在这里，队列中的成员就是：队头指针和队尾指针，以及一个记录队列中数据数量的成员变量和一个标记队列可以容纳的最大数据量的成员变量。</p>
<h3 id="队列的创建与初始化"><a href="# 队列的创建与初始化" class="headerlink" title="队列的创建与初始化"></a>队列的创建与初始化 </h3><p> 首先，创建一个空队列（队列中还没有存储数据），并初始化成员变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function to create an empty queue</span></span><br><span class="line">Queue_t *<span class="title function_">createQueue</span><span class="params">(<span class="type">int</span> max_size)</span> &#123;</span><br><span class="line">    Queue_t *<span class="built_in">queue</span> = (Queue_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue_t));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;max = max_size;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，对于空队列，后续入队操作会有数据存储到队列中，数据需要必要的存储空间来存储。在这里，我们创建并初始化一段空间用于存储数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function to create a new node</span></span><br><span class="line">LinkedNode_t *<span class="title function_">createNode</span><span class="params">(TreeNode_t *data)</span> &#123;</span><br><span class="line">    LinkedNode_t *newNode = (LinkedNode_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkedNode_t));</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断队列是否为空"><a href="# 判断队列是否为空" class="headerlink" title="判断队列是否为空"></a>判断队列是否为空</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function to check if the queue is empty</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Queue_t *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，也可以使用 <code>(!queue-&gt;front) &amp;&amp; (queue-&gt;front == queue-&gt;rear)</code> 判断队列是否为空。 </p>
<h3 id="判断队列是否已满"><a href="# 判断队列是否已满" class="headerlink" title="判断队列是否已满"></a>判断队列是否已满</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function to check if the queue is full</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Queue_t *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;size &gt;= <span class="built_in">queue</span>-&gt;max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="入队操作"><a href="# 入队操作" class="headerlink" title="入队操作"></a>入队操作 </h3><p> 入队操作，即在队列的尾部插入一个数据。</p>
<ul>
<li>如果队列已满，则无法继续执行入队操作；</li>
<li>如果队列为空，则队列的头指针（front）和尾指针（rear）都指向新插入的数据的存放地址；</li>
<li>否则，链接并更新队列的尾指针（rear）为新插入的数据的存放地址。</li>
</ul>
<p>入队操作后需要更新队列的大小。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function to enqueue an element into the queue</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enQueue</span><span class="params">(Queue_t *<span class="built_in">queue</span>, TreeNode_t *data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;queue is full.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LinkedNode_t *newNode = createNode(data);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">            <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">queue</span>-&gt;rear-&gt;next = newNode;  <span class="comment">// 尾指针链接新数据</span></span><br><span class="line">            <span class="built_in">queue</span>-&gt;rear = newNode;  <span class="comment">// 尾指针指向新数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;size += <span class="number">1</span>;  <span class="comment">// 更新队列大小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="出队操作"><a href="# 出队操作" class="headerlink" title="出队操作"></a>出队操作 </h3><p> 出队操作，即在队列的头部删除一个数据。出队操作需要依次执行以下操作：</p>
<ol>
<li>获取头指针地址 &amp; 数据；</li>
<li>更新队列头指针；</li>
<li>更新队列大小；</li>
<li>释放原头指针内存空间；</li>
<li>返回数据。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function to dequeue an element from the queue</span></span><br><span class="line">TreeNode_t *<span class="title function_">deQueue</span><span class="params">(Queue_t* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedNode_t *node = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">    TreeNode_t *data = node-&gt;data;</span><br><span class="line">    <span class="comment">// 根据当前队列中节点的数量，决定是否同步更新队列的尾指针</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;front-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips：出队操作在在更新队列头指针时，需要根据当前队列中节点的数量，决定是否同步更新队列的尾指针。</p>
</blockquote>
<blockquote>
<p>释放 <code>node</code> 内存空间后，不会造成 <code>data</code> 数据无法访问吗？<br>不会。这是因为，在释放节点之前，我们先将数据指针 <code>node-&gt;data</code> 保存到一个新的变量 <code>data</code> 中，然后释放节点，最后返回保存的数据指针。这样可以确保返回的数据指针依然有效。</p>
</blockquote>
<h3 id="打印队列数据"><a href="# 打印队列数据" class="headerlink" title="打印队列数据"></a>打印队列数据</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function to print all elements from the queue</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(Queue_t* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Queue is empty\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Queue: &quot;</span>);</span><br><span class="line">        LinkedNode_t *node = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;data-&gt;val);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="释放队列"><a href="# 释放队列" class="headerlink" title="释放队列"></a>释放队列</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function to free all memory from the queue</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeQueue</span><span class="params">(Queue_t* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>) &#123;</span><br><span class="line">        LinkedNode_t *node = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">        <span class="keyword">while</span> (node) &#123;</span><br><span class="line">            LinkedNode_t *temp = node;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放队列内存空间时，需要依次释放队列中的每一个节点的空间，最后再释放队列结构本身的数据空间。</p>
<h2 id="链表实现队列完整代码"><a href="# 链表实现队列完整代码" class="headerlink" title="链表实现队列完整代码"></a>链表实现队列完整代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagTreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagTreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagTreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagLinkedNode</span> &#123;</span></span><br><span class="line">    TreeNode_t *data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagLinkedNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LinkedNode_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagQueue</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    LinkedNode_t *front;</span><br><span class="line">    LinkedNode_t *rear;</span><br><span class="line">&#125; Queue_t;</span><br><span class="line"></span><br><span class="line">Queue_t *<span class="title function_">createQueue</span><span class="params">(<span class="type">int</span> max_size)</span> &#123;</span><br><span class="line">    Queue_t *<span class="built_in">queue</span> = (Queue_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue_t));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;max = max_size;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LinkedNode_t *<span class="title function_">createNode</span><span class="params">(TreeNode_t *data)</span> &#123;</span><br><span class="line">    LinkedNode_t *newNode = (LinkedNode_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkedNode_t));</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Queue_t *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Queue_t *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;size &gt;= <span class="built_in">queue</span>-&gt;max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enQueue</span><span class="params">(Queue_t *<span class="built_in">queue</span>, TreeNode_t *data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;queue is full.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LinkedNode_t *newNode = createNode(data);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">            <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">queue</span>-&gt;rear-&gt;next = newNode;  <span class="comment">// 尾指针链接新数据</span></span><br><span class="line">            <span class="built_in">queue</span>-&gt;rear = newNode;  <span class="comment">// 尾指针指向新数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;size += <span class="number">1</span>;  <span class="comment">// 更新队列大小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode_t *<span class="title function_">deQueue</span><span class="params">(Queue_t* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedNode_t *node = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">    TreeNode_t *data = node-&gt;data;</span><br><span class="line">    <span class="comment">// 根据当前队列中节点的数量，决定是否同步更新队列的尾指针</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;front-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(Queue_t* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Queue is empty\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Queue: &quot;</span>);</span><br><span class="line">        LinkedNode_t *node = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;data-&gt;val);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeQueue</span><span class="params">(Queue_t* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>) &#123;</span><br><span class="line">        LinkedNode_t *node = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">        <span class="keyword">while</span> (node) &#123;</span><br><span class="line">            LinkedNode_t *temp = node;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    Queue_t *<span class="built_in">queue</span> = createQueue(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一些测试用的树节点</span></span><br><span class="line">    TreeNode_t *node = (TreeNode_t *)<span class="built_in">malloc</span>(<span class="number">4</span> * <span class="keyword">sizeof</span>(TreeNode_t));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        node[i].val = <span class="number">10</span> + i;</span><br><span class="line">        node[i].left = <span class="literal">NULL</span>;</span><br><span class="line">        node[i].right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printQueue(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    enQueue(<span class="built_in">queue</span>, &amp;node[<span class="number">0</span>]);</span><br><span class="line">    enQueue(<span class="built_in">queue</span>, &amp;node[<span class="number">1</span>]);</span><br><span class="line">    enQueue(<span class="built_in">queue</span>, &amp;node[<span class="number">2</span>]);</span><br><span class="line">    printQueue(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    enQueue(<span class="built_in">queue</span>, &amp;node[<span class="number">3</span>]);</span><br><span class="line">    printQueue(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    TreeNode_t *data1 = deQueue(<span class="built_in">queue</span>);</span><br><span class="line">    TreeNode_t *data2 = deQueue(<span class="built_in">queue</span>);</span><br><span class="line">    TreeNode_t *data3 = deQueue(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Dequeued data: %d %d %d\n&quot;</span>, data1-&gt;val, data2-&gt;val, data3-&gt;val); <span class="comment">// 实际工程中要先判非空再取数据</span></span><br><span class="line">    printQueue(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    freeQueue(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Queue is empty</span><br><span class="line">Queue: 10 11 12</span><br><span class="line">queue is full.</span><br><span class="line">Queue: 10 11 12</span><br><span class="line">Dequeued data: 10 11 12</span><br><span class="line">Queue is empty</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>队列</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>模运算（求余运算）</title>
    <url>/posts/231010144856.html</url>
    <content><![CDATA[<p>两数相加、两数相乘怎么求余数，负数求余数到底等于多少，如何高效求余数？这篇文章将记录这些知识，方便后续查阅。</p>
<span id="more"></span>

<h2 id="正数求余"><a href="# 正数求余" class="headerlink" title="正数求余"></a>正数求余 </h2><p> 自然数对正数求余是指将一个自然数除以另一个正整数后得到的余数。</p>
<p>例如，对于自然数 $a$ 和正整数 $m$，求 $a/m$ 的余数，可以用符号「%」表示，即 $a \% m$。</p>
<p>假设 $a=km+r, (a&gt;=0, m&gt;0)$，那么 $a/m$ 等于 $k, (k&gt;=0)$，$a \% m$ 等于 $r, (0&lt;=r&lt;m)$。</p>
<h2 id="两数相加求余"><a href="# 两数相加求余" class="headerlink" title="两数相加求余"></a>两数相加求余 </h2><p> 结论：一般地，两个整数相加后求余数，有如下等式：</p>
<p>$$<br>\begin{cases}<br>(a + b) \% m \\<br>= ((a \% m) + (b \% m)) \% m \\<br>\end{cases}<br>$$</p>
<p>证明：根据 <strong> 带余除法</strong>，任意整数 $a$ 都可以表示为 $a=km+r$，这里 $r$ 相当于 $a \% m$。那么设 $a=k_{1}m+r_{1}, b=k_{2}m+r_{2}$，则有</p>
<p>$$<br>\begin{cases}<br>(a + b) \% m \\<br>= ((k_{1} + k_{2})m + r_{1} + r_{2}) \% m \\<br>= (r_{1} + r_{2}) \% m \\<br>= ((a \% m) + (b \% m)) \% m \\<br>\end{cases}<br>$$</p>
<p>证毕。</p>
<h2 id="两数相乘求余"><a href="# 两数相乘求余" class="headerlink" title="两数相乘求余"></a>两数相乘求余 </h2><p> 结论：一般地，两个整数相乘后求余数，有如下等式：</p>
<p>$$<br>(a \times b) \% m = ((a \% m) \times (b \% m)) \% m<br>$$</p>
<p>证明：根据 <strong> 带余除法</strong>，任意整数 $a$ 都可以表示为 $a=km+r$，这里 $r$ 相当于 $a \% m$。那么设 $a=k_{1}m+r_{1}, b=k_{2}m+r_{2}$，则有</p>
<p>$$<br>\begin{cases}<br>(a \times b) \% m \\<br>= ((k_{1}k_{2})m^{2} + (k_{1}r_{2} + k_{2}r_{1})m + r_{1}r_{2}) \% m \\<br>= (r_{1}r_{2}) \% m \\<br>= ((a \% m) \times (b \% m)) \% m \\<br>\end{cases}<br>$$</p>
<p>证毕。</p>
<h2 id="负数求余"><a href="# 负数求余" class="headerlink" title="负数求余"></a>负数求余 </h2><h3 id="不同语言的负数求余"><a href="# 不同语言的负数求余" class="headerlink" title="不同语言的负数求余"></a> 不同语言的负数求余</h3><ol>
<li>一个负数对一个正数求余数：</li>
</ol>
<ul>
<li>C、C++ 和 Java 的结果是商尽可能大（在坐标轴上尽可能靠右），余数的正负号与被除数的正负号保持一致，即为负数。</li>
<li>Python、Google 计算器和百度计算器的结果是商尽可能小（在坐标轴上尽可能靠左），余数的正负号与除数的正负号保持一致，为正数。</li>
</ul>
<table>
<thead>
<tr>
<th>语言</th>
<th>语句</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>C/C++</td>
<td><code>cout &lt;&lt; (-7) % 3;</code></td>
<td>-1</td>
</tr>
<tr>
<td>Java（1.6）</td>
<td><code>System.out.println((-7) % 3);</code></td>
<td>-1</td>
</tr>
<tr>
<td>Python 2.6</td>
<td><code>(-7) % 3</code></td>
<td>2</td>
</tr>
<tr>
<td>百度计算器</td>
<td><code>(-7) mod 3</code></td>
<td>2</td>
</tr>
<tr>
<td>Google 计算器</td>
<td><code>(-7) mod 3</code></td>
<td>2</td>
</tr>
</tbody></table>
<ol start="2">
<li>一个正数对一个负数求余数：</li>
</ol>
<ul>
<li>C、C++ 和 Java 的结果是商尽可能大（在坐标轴上尽可能靠右），余数的正负号与被除数的正负号保持一致，即为正数。</li>
<li>Python、Google 计算器和百度计算器的结果是商尽可能小（在坐标轴上尽可能靠左），余数的正负号与除数的正负号保持一致，为负数。</li>
</ul>
<table>
<thead>
<tr>
<th>语言</th>
<th>语句</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>C/C++</td>
<td><code>cout &lt;&lt; 7 % (-3);</code></td>
<td>1</td>
</tr>
<tr>
<td>Java (1.6)</td>
<td><code>System.out.println(7 % (-3));</code></td>
<td>1</td>
</tr>
<tr>
<td>Python 2.6</td>
<td><code>7 % (-3)</code></td>
<td>-2</td>
</tr>
<tr>
<td>百度计算器</td>
<td><code>7 mod (-3)</code></td>
<td>-2</td>
</tr>
<tr>
<td>Google 计算器</td>
<td><code>7 mod (-3)</code></td>
<td>-2</td>
</tr>
</tbody></table>
<ol start="3">
<li>一个负数对一个负数求余数：</li>
</ol>
<ul>
<li>C、C++ 和 Java 以及 Python、Google 计算器和百度计算器的结果都是商尽可能小（在坐标轴上尽可能靠左），余数为负数。</li>
</ul>
<table>
<thead>
<tr>
<th>语言</th>
<th>语句</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>C/C++</td>
<td><code>cout &lt;&lt; -7 % (-3);</code></td>
<td>-1</td>
</tr>
<tr>
<td>Java (1.6)</td>
<td><code>System.out.println(-7 % (-3));</code></td>
<td>-1</td>
</tr>
<tr>
<td>Python 2.6</td>
<td><code>-7 % (-3)</code></td>
<td>-1</td>
</tr>
<tr>
<td>百度计算器</td>
<td><code>-7 mod (-3)</code></td>
<td>-1</td>
</tr>
<tr>
<td>Google 计算器</td>
<td><code>-7 mod (-3)</code></td>
<td>-1</td>
</tr>
</tbody></table>
<h3 id="总结"><a href="# 总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>在被除数与除数 <strong> 正负号相同时 </strong>，所有语言<strong> 都期望商尽可能小 </strong>（<del> 余数的正负号与被除数、除数的正负号一致</del>）。</li>
<li>在被除数与除数 <strong> 正负号相反时</strong>：</li>
</ol>
<ul>
<li>对于 C、C++ 和 Java，<strong>期望商尽可能大 </strong>（<del> 余数的正负号与 <strong> 被除数 </strong> 的正负号保持一致</del>）；</li>
<li>对于 Python、Google 计算器和百度计算器，<strong>还是期望商尽可能小 </strong>（<del> 余数的正负号与 <strong> 除数 </strong> 的正负号保持一致</del>）。</li>
</ul>
<h2 id="位运算求余数"><a href="# 位运算求余数" class="headerlink" title="位运算求余数"></a>位运算求余数 </h2><p> 对于自然数 $a$ 和正整数 $m$，在某些情况下，当 $m=2^n$ 时，有如下替换公式：</p>
<p>$$<br>a \% m = a \&amp; (m - 1)<br>$$</p>
<p>即:</p>
<p>$$<br>a \% 2^{n} = a \&amp; (2^{n} - 1)<br>$$</p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://leetcode.cn/problems/movement-of-robots/solutions/2304680/nao-jin-ji-zhuan-wan-pai-xu-tong-ji-pyth-we55/?envType=daily-question&envId=2023-10-10">灵茶山艾府 Leetcode2731 移动机器人题解</a></li>
<li><a href="http://ceeji.net/blog/mod-in-real/">实数范围内的求模（求余）运算：负数求余究竟怎么求</a></li>
<li><a href="https://blog.csdn.net/lonyw/article/details/80519652">使用位操作（&amp; 运算）代替求余操作</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>模运算</tag>
      </tags>
  </entry>
  <entry>
    <title>编译之 GCC 编译过程分解</title>
    <url>/posts/240207180410.html</url>
    <content><![CDATA[<p>GCC（GNU Compiler Collection）是一个开源的编程语言编译器集合，支持多种编程语言，包括 C、C++、Objective-C、Fortran、Ada 等。它是许多开发者和程序员首选的编译器，因为它的功能强大、稳定，并且跨平台。</p>
<p>这篇文章主要介绍 GCC (GNU Compiler Collection)，以及使用 GCC 编译 C 代码的分解过程。</p>
<span id="more"></span>

<h1 id="C-include"><a href="#C-include" class="headerlink" title="C include"></a>C include</h1><p>在 C 语言程序中，会引用各种 <code>#include</code> 头文件（.h），它是如何被引用的？</p>
<p>当我们 <code>#include</code> 头文件时，如 <code>#include &lt;stdio.h&gt;</code>，其实是告诉了 C 预处理器（C preprocessor, cpp）去指定路径 <code>/usr/include/</code> 查找特定的头文件，并将其直接插入到代码中的 <code>#include</code> 位置。</p>
<h1 id="GCC 编译分解"><a href="#GCC 编译分解" class="headerlink" title="GCC 编译分解"></a>GCC 编译分解 </h1><p> 我么以下面的程序分解 GCC 编译的过程，文件名 <code>hw.c</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* header files go up here */</span></span><br><span class="line"><span class="comment">/* note that C comments are enclosed within a slash and</span></span><br><span class="line"><span class="comment">a star, and may wrap over lines */</span></span><br><span class="line"><span class="comment">// two slashes work too (and may be preferred)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// main returns an integer</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">/* printf is our output function;</span></span><br><span class="line"><span class="comment">    by default, writes to standard out */</span></span><br><span class="line">    <span class="comment">/* printf returns an integer, but we ignore that */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* return 0 to indicate all went well */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GCC 并不是一个真正的编译器，而是一个称为「编译器驱动（compiler driver）」的程序，因此它协调了编译的许多步骤（一般为四到五步），如下图。</p>
<img src="../images/compiler-tool/gcc.png" alt="GCC 编译过程分解" width="100%" height="100%">

<h2 id="预处理"><a href="# 预处理" class="headerlink" title="预处理"></a>预处理 </h2><p> 预处理指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o hw.i -E hw.c</span><br></pre></td></tr></table></figure>

<p>预处理某些指令，如 <code>#define</code>、<code>#include</code>、注释，并将其 <strong> 直接 </strong> 插入到代码中。例如，下面的代码段是对 <code>hw.c</code> 进行预处理后产生的可读文件 <code>hw.i</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略最前面的 N 行...</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">funlockfile</span> <span class="params">(FILE *__stream)</span> __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span>;</span><br><span class="line"># <span class="number">885</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __uflow (FILE *);</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __overflow (FILE *, <span class="type">int</span>);</span><br><span class="line"># <span class="number">902</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"># <span class="number">6</span> <span class="string">&quot;hw.c&quot;</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="number">7</span> <span class="string">&quot;hw.c&quot;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译"><a href="# 编译" class="headerlink" title="编译"></a>编译 </h2><p> 编译指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o hw.s -S hw.c</span><br><span class="line">gcc -o hw.s -S hw.i # 这个也行</span><br></pre></td></tr></table></figure>

<p>编译过后的文件称为汇编文件（代码）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        .file   &quot;hw.c&quot;</span><br><span class="line">        .text</span><br><span class="line">        .section        .rodata</span><br><span class="line">.LC0:</span><br><span class="line">        .string &quot;hello, world&quot;</span><br><span class="line">        .text</span><br><span class="line">        .globl  main</span><br><span class="line">        .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">        .cfi_startproc</span><br><span class="line">        endbr64</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        .cfi_def_cfa_offset 16</span><br><span class="line">        .cfi_offset 6, -16</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        .cfi_def_cfa_register 6</span><br><span class="line">        subq    $16, %rsp</span><br><span class="line">        movl    %edi, -4(%rbp)</span><br><span class="line">        movq    %rsi, -16(%rbp)</span><br><span class="line">        leaq    .LC0(%rip), %rax</span><br><span class="line">        movq    %rax, %rdi</span><br><span class="line">        call    puts@PLT</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        leave</span><br><span class="line">        .cfi_def_cfa 7, 8</span><br><span class="line">        ret</span><br><span class="line">        .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">        .size   main, .-main</span><br><span class="line">        .ident  &quot;GCC: (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0&quot;</span><br><span class="line">        .section        .note.GNU-stack,&quot;&quot;,@progbits</span><br><span class="line">        .section        .note.gnu.property,&quot;a&quot;</span><br><span class="line">        .align 8</span><br><span class="line">        .long   1f - 0f</span><br><span class="line">        .long   4f - 1f</span><br><span class="line">        .long   5</span><br><span class="line">0:</span><br><span class="line">        .string &quot;GNU&quot;</span><br><span class="line">1:</span><br><span class="line">        .align 8</span><br><span class="line">        .long   0xc0000002</span><br><span class="line">        .long   3f - 2f</span><br><span class="line">2:</span><br><span class="line">        .long   0x3</span><br><span class="line">3:</span><br><span class="line">        .align 8</span><br><span class="line">4:</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>chatGPT 这样说：</p>
<p>这段汇编代码是一个简单的 C 程序的汇编代码示例。下面是对代码中的一些关键部分的解释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.file   &quot;hw.c&quot;</span><br></pre></td></tr></table></figure>
<p>这一行指定了源文件的名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        .section        .rodata</span><br><span class="line">.LC0:</span><br><span class="line">        .string &quot;hello, world&quot;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个只读数据段（.rodata），并在其中定义了一个字符串常量（hello, world）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        .globl  main</span><br><span class="line">        .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br></pre></td></tr></table></figure>
<p>这里定义了一个全局符号（main），表示这是程序的入口点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pushq   %rbp</span><br><span class="line">movq    %rsp, %rbp</span><br></pre></td></tr></table></figure>
<p>这是函数开头的标准操作，用于保存和设置栈帧。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leaq    .LC0(%rip), %rax</span><br><span class="line">movq    %rax, %rdi</span><br><span class="line">call    puts@PLT</span><br></pre></td></tr></table></figure>
<p>这里将字符串常量的地址加载到寄存器 rax 中，并将其作为参数传递给 puts 函数，以便在屏幕上打印出来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl    $0, %eax</span><br><span class="line">leave</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>这些指令用于返回程序的退出码，并清理栈帧。</p>
<p>这些是这段汇编代码的主要部分。它基本上是将字符串”hello, world”打印到屏幕上，然后退出程序。</p>
<h2 id="汇编"><a href="# 汇编" class="headerlink" title="汇编"></a>汇编 </h2><p> 汇编指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o hw.o -c hw.s</span><br><span class="line">gcc -o hw.o -c hw.c # 这个也行</span><br></pre></td></tr></table></figure>

<p>汇编文件汇编后的文件类型是一个二进制文件，编译过程中生成目标文件，该目标文件打开是一个乱码。</p>
<h2 id="链接"><a href="# 链接" class="headerlink" title="链接"></a>链接 </h2><p> 链接指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o hw hw.o</span><br><span class="line">gcc -o hw.o hw.c # 这个也行</span><br></pre></td></tr></table></figure>

<p>组合所有目标代码，并转换为可执行文件。使用 <code>file hw</code> 可查看关于可执行文件的描述。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">root@Standard-PC-i440FX-PIIX-1996:/home/xxx# file hw</span><br><span class="line">hw: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, \</span><br><span class="line">interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=190dc558406e49249a5b73b4b7513b4ab8e13385, for GNU/Linux 3.2.0, not stripped</span><br></pre></td></tr></table></figure>

<p>chatGPT 说，这是一个关于一个可执行文件的描述。让我来解释一下各个部分的含义：</p>
<ul>
<li><code>ELF</code>：代表可执行和可链接格式 (Executable and Linkable Format)，是一种用于执行文件和目标文件的标准文件格式。</li>
<li><code>64-bit LSB</code>：代表这是一个 64 位的可执行文件。</li>
<li><code>pie</code>：代表这是一个位置无关可执行文件 (Position Independent Executable)，这意味着它可以在内存中的任何位置加载并执行。</li>
<li><code>x86-64</code>：代表这是一个 x86-64 架构的可执行文件，也就是 64 位的 x86 架构。</li>
<li><code>version 1 (SYSV)</code>：代表这个可执行文件遵循 System V ABI 的第一个版本。</li>
<li><code>dynamically linked</code>：代表这个可执行文件是动态链接的，它依赖于其他共享库文件来运行。</li>
<li><code>interpreter /lib64/ld-linux-x86-64.so.2</code>：代表在运行该可执行文件时，系统将使用 <code>/lib64/ld-linux-x86-64.so.2</code> 这个动态链接器来加载和解释它。</li>
<li><code>BuildID[sha1]=190...</code>：代表这个可执行文件的构建标识符，它是通过计算文件内容的 SHA-1 哈希来生成的，可以用于唯一标识该文件。</li>
<li><code>for GNU/Linux 3.2.0</code>：代表这个可执行文件是为 GNU/Linux 操作系统的 3.2.0 版本编译的。</li>
<li><code>not stripped</code>：代表这个可执行文件没有被去除符号信息，也就是说，它保留了调试和符号表等信息，可以用于调试和分析。</li>
</ul>
<h1 id="GCC 参数总结"><a href="#GCC 参数总结" class="headerlink" title="GCC 参数总结"></a>GCC 参数总结</h1><table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>-std=&lt;standard&gt;</td>
<td>假设输入源文件符合 &lt;standard&gt;，如 c99。</td>
</tr>
<tr>
<td>-E</td>
<td>只预处理，不编译、汇编或链接。</td>
</tr>
<tr>
<td>-S</td>
<td>只编译，不汇编或链接。</td>
</tr>
<tr>
<td>-c</td>
<td>编译和汇编，但不链接。</td>
</tr>
<tr>
<td>-o &lt;file&gt;</td>
<td>将输出放入 &lt;file&gt; 中。</td>
</tr>
<tr>
<td>-O&lt;digit&gt;</td>
<td>打开优化，等级为 1~3，等级过高优化效果越好，但编译时间越长。</td>
</tr>
<tr>
<td>-Wall</td>
<td>给出更好的警告。</td>
</tr>
<tr>
<td>-g</td>
<td>启用 gdb 调试。</td>
</tr>
<tr>
<td>-pie</td>
<td>创建一个动态链接的位置无关可执行文件。</td>
</tr>
<tr>
<td>-shared</td>
<td>创建一个共享库。</td>
</tr>
</tbody></table>
<h1 id="多个文件一起编译"><a href="# 多个文件一起编译" class="headerlink" title="多个文件一起编译"></a>多个文件一起编译 </h1><p> 第一次生成可以使用以下命令，进行一起编译、链接，生成 hw 可执行文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c hw.c helper.c</span><br><span class="line">gcc -o hw hw.o helper.o</span><br></pre></td></tr></table></figure>

<p>后续如果修改部分文件的代码，则 <strong> 仅对修改的源文件编译生成目标文件</strong>，最后一起对目标文件进行链接，更快（特别是大项目）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c hw.c  # 修改过的文件</span><br><span class="line">gcc -o hw hw.o helper.o</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考资料：<br>1：<a href="https://blog.csdn.net/weixin_39258979/article/details/101023337">https://blog.csdn.net/weixin_39258979/article/details/101023337</a><br>2：<a href="https://pages.cs.wisc.edu/~remzi/OSTEP/lab-tutorial.pdf">Operating Systems: Three Easy Pieces</a><br>3：<a href="https://www.cnblogs.com/bobwuming/articles/14931042.html">https://www.cnblogs.com/bobwuming/articles/14931042.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>编译工具</category>
        <category>GCC</category>
      </categories>
      <tags>
        <tag>编译工具</tag>
        <tag>GCC</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机中的寄存器</title>
    <url>/posts/231210181853.html</url>
    <content><![CDATA[<p>在计算机中，寄存器是一种 <strong> 小型而快速的存储器件 </strong>，用于存储处理器需要<strong> 快速访问 </strong> 的数据。它们是计算机体系结构中的关键组成部分，对于计算机的性能和功能至关重要。</p>
<blockquote>
<p>计算机体系结构：CPU + 内存 + 外设。其中，CPU 内部包括控制器、寄存器、cache 和 MMU 等。</p>
</blockquote>
<span id="more"></span>

<h1 id="什么是寄存器？"><a href="# 什么是寄存器？" class="headerlink" title="什么是寄存器？"></a>什么是寄存器？</h1><p>在计算机中，寄存器是一种 <strong> 小型而快速的存储器件 </strong>，用于存储处理器需要<strong> 快速访问 </strong> 的数据。它们是计算机体系结构中的一部分，<strong>通常被集成在处理器芯片中</strong>。寄存器是计算机中最快的存储器件之一，它们的访问速度比主存储器和辅助存储器要快得多。</p>
<p><strong>寄存器通常被用于存储处理器需要快速访问的数据</strong>，如程序计数器、指令寄存器、状态寄存器、通用寄存器等。它们还可以用于存储函数调用时的参数和返回值，以及存储中间计算结果等。</p>
<h1 id="寄存器的作用"><a href="# 寄存器的作用" class="headerlink" title="寄存器的作用"></a>寄存器的作用 </h1><p> 寄存器在计算机中有许多重要的作用。以下是其中的一些：</p>
<h2 id="提高计算机的性能"><a href="# 提高计算机的性能" class="headerlink" title="提高计算机的性能"></a>提高计算机的性能 </h2><p> 寄存器是计算机中最快的存储器件之一，它们的访问速度比主存储器和辅助存储器要快得多。因此，<strong>将需要快速访问的数据存储在寄存器中可以大大提高计算机的性能</strong>。</p>
<h2 id="存储处理器需要快速访问的数据"><a href="# 存储处理器需要快速访问的数据" class="headerlink" title="存储处理器需要快速访问的数据"></a>存储处理器需要快速访问的数据 </h2><p> 处理器需要快速访问的数据通常存储在寄存器中，如程序计数器、指令寄存器、状态寄存器、通用寄存器等。这些数据对于处理器的运行至关重要，因此它们需要快速访问。</p>
<h2 id="存储函数调用时的参数和返回值"><a href="# 存储函数调用时的参数和返回值" class="headerlink" title="存储函数调用时的参数和返回值"></a>存储函数调用时的参数和返回值 </h2><p> 在<strong>函数调用时，参数和返回值通常存储在寄存器中 </strong>。这是因为寄存器的访问速度比主存储器要快得多，可以<strong> 提高函数调用的效率</strong>。</p>
<h2 id="存储中间计算结果"><a href="# 存储中间计算结果" class="headerlink" title="存储中间计算结果"></a>存储中间计算结果 </h2><p> 在计算机中，一些中间计算结果需要被存储下来以便后续使用。这些中间计算结果通常存储在寄存器中，因为寄存器的访问速度比主存储器要快得多。</p>
<h1 id="寄存器的种类"><a href="# 寄存器的种类" class="headerlink" title="寄存器的种类"></a>寄存器的种类 </h1><h2 id="程序计数器（PC）"><a href="# 程序计数器（PC）" class="headerlink" title="程序计数器（PC）"></a> 程序计数器（PC）</h2><p>程序计数器是一种特殊的寄存器，用于存储下一条要执行的指令的内存地址。当处理器执行程序时，它会不断地从程序计数器中读取指令并执行它们。</p>
<h2 id="指令寄存器（IR）"><a href="# 指令寄存器（IR）" class="headerlink" title="指令寄存器（IR）"></a>指令寄存器（IR）</h2><p>指令寄存器是一种特殊的寄存器，用于存储当前正在执行的指令。<strong>处理器从指令寄存器中读取指令并执行它们</strong>。</p>
<blockquote>
<p>（个人理解）程序计数器和指令寄存器共同完成对下一条指令的执行。首先，CPU 通过程序计数器获取下一条将要执行的指令的内存地址；然后，CPU 通过这个内存地址，从内存中读取指令数据，并将其二进制表示存储在指令寄存器中；最后，控制器解析并执行指令寄存器中的指令。</p>
</blockquote>
<h2 id="状态寄存器（SR）"><a href="# 状态寄存器（SR）" class="headerlink" title="状态寄存器（SR）"></a>状态寄存器（SR）</h2><p>状态寄存器是一种特殊的寄存器，用于存储处理器的状态信息。状态寄存器中的不同「位」表示了处理器的不同状态，如进位标志、零标志、负数标志等。</p>
<h2 id="通用寄存器"><a href="# 通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器 </h2><p> 通用寄存器是一种通用的寄存器，<strong>用于存储处理器需要快速访问的数据</strong>。它们可以用于存储函数调用时的参数和返回值，以及存储中间计算结果等。</p>
<h3 id="累加器（ACC）"><a href="# 累加器（ACC）" class="headerlink" title="累加器（ACC）"></a>累加器（ACC）</h3><p>累加器是一种比较特殊的通用寄存器，用于存储算术和逻辑操作的结果。</p>
<h3 id="数据寄存器（DR）"><a href="# 数据寄存器（DR）" class="headerlink" title="数据寄存器（DR）"></a>数据寄存器（DR）</h3><p>数据寄存器是一种通用寄存器，用于存储计算机中的数据。它可以用于暂时存储从内存中读取的数据，或者存储需要写入内存的数据。</p>
<h2 id="地址寄存器（AR）"><a href="# 地址寄存器（AR）" class="headerlink" title="地址寄存器（AR）"></a>地址寄存器（AR）</h2><p>地址寄存器是一种特殊的寄存器，用于存储内存地址。它通常用于指示将要读取或写入数据的内存位置。</p>
<h2 id="堆栈指针寄存器（SP）"><a href="# 堆栈指针寄存器（SP）" class="headerlink" title="堆栈指针寄存器（SP）"></a>堆栈指针寄存器（SP）</h2><p>堆栈指针寄存器是一种特殊的寄存器，用于指示栈顶的位置。栈是一种常用的数据结构，用于存储临时数据、函数调用的参数和返回地址等。</p>
<h2 id="基址寄存器（BR）"><a href="# 基址寄存器（BR）" class="headerlink" title="基址寄存器（BR）"></a>基址寄存器（BR）</h2><p>基址寄存器是一种特殊的寄存器，用于存储数据段的基地址。它通常与偏移寄存器配合使用，用于计算实际内存地址。</p>
<h2 id="偏移寄存器（OR）"><a href="# 偏移寄存器（OR）" class="headerlink" title="偏移寄存器（OR）"></a>偏移寄存器（OR）</h2><p>偏移寄存器是一种特殊的寄存器，用于存储相对于基址的偏移量。它通常与基址寄存器配合使用，用于计算实际内存地址。</p>
<blockquote>
<p>通用寄存器和特殊寄存器的区别：通用寄存器用于存储数据和中间结果，具有灵活的使用方式；而特殊寄存器具有特定的用途，功能固定，不能直接访问或修改其内容。</p>
</blockquote>
<h1 id="寄存器分类总结"><a href="# 寄存器分类总结" class="headerlink" title="寄存器分类总结"></a>寄存器分类总结</h1><table>
<thead>
<tr>
<th>寄存器名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>程序计数器（PC）</td>
<td>存储下一条要执行的指令的内存地址</td>
</tr>
<tr>
<td>指令寄存器（IR）</td>
<td>存储当前正在执行的指令</td>
</tr>
<tr>
<td>状态寄存器（SR）</td>
<td>存储计算机的运行状态和控制信息</td>
</tr>
<tr>
<td>累加器（ACC）</td>
<td>存储算术和逻辑操作的结果</td>
</tr>
<tr>
<td>数据寄存器（DR）</td>
<td>存储计算机中的数据</td>
</tr>
<tr>
<td>地址寄存器（AR）</td>
<td>存储内存地址</td>
</tr>
<tr>
<td>堆栈指针寄存器（SP）</td>
<td>指示栈顶位置</td>
</tr>
<tr>
<td>基址寄存器（BR）</td>
<td>存储数据段的基地址</td>
</tr>
<tr>
<td>偏移寄存器（OR）</td>
<td>存储相对于基址的偏移量</td>
</tr>
</tbody></table>
<blockquote>
<p>参考资料：<a href="https://blog.csdn.net/weixin_73567058/article/details/130185612">https://blog.csdn.net/weixin_73567058/article/details/130185612</a></p>
</blockquote>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>寄存器</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法之快速排序</title>
    <url>/posts/231108163339.html</url>
    <content><![CDATA[<p>快速排序是一种常用的排序算法，它基于分治的思想，通过将数组划分为较小的子数组，然后递归地排序这些子数组来达到排序整个数组的目的。</p>
<p>快速排序的基本思想是从数组中选择一个基准元素，然后通过一趟排序将数组分成两部分，以基准元素为轴，使得左边的元素都小于等于基准元素，右边的元素都大于基准元素。然后对这两部分分别进行递归排序，最终将整个数组排序。</p>
<span id="more"></span>

<h2 id="快速排序步骤"><a href="# 快速排序步骤" class="headerlink" title="快速排序步骤"></a>快速排序步骤 </h2><p> 快速排序具体步骤如下：</p>
<ol>
<li>选择一个基准元素 <code>pivot</code>，可以是数组的第一个元素或最后一个元素；</li>
<li>设置两个指针，一个指向数组的起始位置 <code>left</code>，一个指向数组的结束位置 <code>right</code>；</li>
<li>从 <code>left</code> 指针开始向右遍历，找到下一个大于 <code>pivot</code> 的元素，记其索引为 <code>i</code>；</li>
<li>从 <code>right</code> 指针开始向左遍历，找到下一个小于等于 <code>pivot</code> 的元素，记其索引为 <code>j</code>；</li>
<li>如果 <code>i&lt;j</code>，交换 <code>i</code> 和 <code>j</code> 处的元素；</li>
<li>重复步骤 3-5，直到 <code>left</code> 指针和 <code>right</code> 指针相遇；</li>
<li>将基准元素 <code>pivot</code> 与指针相遇处的元素交换。</li>
<li>递归地对基准元素左边的子数组和右边的子数组进行快速排序。</li>
</ol>
<h2 id="快速排序复杂度"><a href="# 快速排序复杂度" class="headerlink" title="快速排序复杂度"></a>快速排序复杂度 </h2><p> 快速排序的时间复杂度为 $O(n \times logn)$，其中 $n$ 为数组的长度。它是一种 <strong> 原地排序算法，不需要额外的存储空间</strong>，但是在最坏情况下可能会出现时间复杂度为 $O(n^2)$ 的情况，需要进行优化。</p>
<h2 id="快速排序实现"><a href="# 快速排序实现" class="headerlink" title="快速排序实现"></a>快速排序实现 </h2><h3 id="交换两个元素"><a href="# 交换两个元素" class="headerlink" title="交换两个元素"></a> 交换两个元素</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="划分数组为两部分"><a href="# 划分数组为两部分" class="headerlink" title="划分数组为两部分"></a>划分数组为两部分 </h3><p> 通过一趟排序将数组分成两部分，以基准元素为轴，使得左边的元素都小于等于基准元素，右边的元素都大于基准元素，最后返回基准元素在数组中的索引。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[left];</span><br><span class="line">    <span class="type">int</span> i = left + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到下一个大于 pivot 的元素</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j &amp;&amp; arr[i] &lt;= pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到下一个小于等于 pivot 的元素</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= i &amp;&amp; arr[j] &gt; pivot) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不是在对方遍历过的区间找到的, 就交换并自增自减指针</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            swap(&amp;arr[i++], &amp;arr[j--]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(&amp;arr[left], &amp;arr[j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的倒数第二行代码中，为什么基准元素是与索引为 <code>j</code> 的元素进行交换呢？</p>
<p>这是因为，我们选择了区间 $[left, right]$ 的 <strong> 左边界 </strong> 的元素作为了基准元素。划分后，<strong>左边都是小于等于基准元素的元素</strong>，而索引 <code>j</code> 右边都是大于基准元素的元素，所以基准元素是与索引为 <code>j</code> 的元素进行交换。</p>
<p>同样地，如果我们选择区间 $[left, right]$ 右边界的元素作为了基准元素，那么代码就该这样写了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> pivot = arr[right];</span><br><span class="line"><span class="type">int</span> i = left;</span><br><span class="line"><span class="type">int</span> j = right - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">swap(&amp;arr[right], &amp;arr[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> i;</span><br></pre></td></tr></table></figure>

<h3 id="递归实现快速排序"><a href="# 递归实现快速排序" class="headerlink" title="递归实现快速排序"></a>递归实现快速排序 </h3><p> 递归地对基准元素左边的子数组和右边的子数组进行快速排序。快速排序接口的入参为 <code>left=0</code> 和 <code>right=n-1</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> pivot = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, pivot - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, pivot + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速排序测试"><a href="# 快速排序测试" class="headerlink" title="快速排序测试"></a>快速排序测试 </h2><h3 id="快速排序代码"><a href="# 快速排序代码" class="headerlink" title="快速排序代码"></a> 快速排序代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[left];</span><br><span class="line">    <span class="type">int</span> i = left + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到下一个大于 pivot 的元素</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j &amp;&amp; arr[i] &lt;= pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到下一个小于等于 pivot 的元素</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= i &amp;&amp; arr[j] &gt; pivot) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不是在对方遍历过的区间找到的, 就交换并自增自减指针</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            swap(&amp;arr[i++], &amp;arr[j--]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(&amp;arr[left], &amp;arr[j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> pivot = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, pivot - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, pivot + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序测试代码"><a href="# 快速排序测试代码" class="headerlink" title="快速排序测试代码"></a>快速排序测试代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    quickSort(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After quickSort: &quot;</span>);</span><br><span class="line">    printArray(arr, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试结果"><a href="# 测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">After quickSort: 1 1 2 3 3 4 5 5 5 6 9</span><br></pre></td></tr></table></figure>

<h2 id="进阶 1：基准元素的选择"><a href="# 进阶 1：基准元素的选择" class="headerlink" title="进阶 1：基准元素的选择"></a>进阶 1：基准元素的选择 </h2><h3 id="首尾基准元素"><a href="# 首尾基准元素" class="headerlink" title="首尾基准元素"></a> 首尾基准元素 </h3><p> 上文说，基准元素可以是「数组的第一个元素或最后一个元素」，这其实是非常不可取的，<strong>在某些情况下可能导致最差的性能</strong>。因为：</p>
<ol>
<li>假如，初始数组就已经是一个升序数组：我们每次都选择第一元素作为基准元素，那么右指针 <code>j</code> 会向左遍历整个数组，但不会进行任何交换操作。这一轮划分操作的时间复杂度为 <code>O(n)</code>，整个排序过程的时间复杂度为 <code>O(n^2)</code>。</li>
<li>同样地，初始数组就已经是一个降序数组：我们每次都选择最后一个元素作为基准元素，那么左指针 <code>i</code> 会向右遍历整个数组，但不会进行任何交换操作。这一轮划分操作的时间复杂度为 <code>O(n)</code>，整个排序过程的时间复杂度为 <code>O(n^2)</code>。</li>
</ol>
<h3 id="随机基准元素"><a href="# 随机基准元素" class="headerlink" title="随机基准元素"></a>随机基准元素 </h3><p> 随机基准元素，避免了上述问题，可谓是一种再好不过的基准元素的选择办法。但是，<strong>随机数的产生是有时间成本的，不一定会使得快速排序的更快</strong>。</p>
<h3 id="三数中值基准元素"><a href="# 三数中值基准元素" class="headerlink" title="三数中值基准元素"></a>三数中值基准元素 </h3><p><strong> 三数中值是一种常用的基准元素选择方式 </strong>。它通过比较数组的第一个、中间和最后一个元素，<strong> 选择它们的中位数作为基准元素</strong>。这种方式可以在一定程度上避免最差情况的发生，并提高算法的性能。</p>
<p>如何选出三数的中位数在数组中的对应索引呢？多轮比较！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getMedianIdx</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> min = (arr[left] &lt; arr[mid]) ? left : mid;</span><br><span class="line">    min = (arr[min] &lt; arr[right]) ? min : right;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max = (arr[left] &gt; arr[mid]) ? left : mid;</span><br><span class="line">    max = (arr[max] &gt; arr[right]) ? max : right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (min == left) &#123;</span><br><span class="line">        <span class="keyword">return</span> max == right ? mid : right;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (min == right) &#123;</span><br><span class="line">        <span class="keyword">return</span> max == left ? mid : left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> max == right ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进阶 2：何时停止进行交换"><a href="# 进阶 2：何时停止进行交换" class="headerlink" title="进阶 2：何时停止进行交换"></a>进阶 2：何时停止进行交换 </h2><p> 上文的划分代码中，当左指针等于基准元素的时候并没有停止（<code>while (i &lt;= j &amp;&amp; arr[i] &lt;= pivot) &#123;i++;&#125;</code>），当右指针等于基准元素的时候却停止了（<code>while (j &gt;= i &amp;&amp; arr[j] &gt; pivot) &#123;j--;&#125;</code>）。那么左、右指针是否应该停止呢？</p>
<p>假设，未排序的初始数组的所有元素都相同，那么试想一下左、右指针指向的元素等于基准元素时的情况：</p>
<ol>
<li><strong>左、右指针都不停止</strong>：那么先执行 <code>while</code> 循环的那个指针会一直移动，直到与另一个指针相遇（另一个指针一步也没移动）。这一轮移动划分的时间复杂度为 <code>O(n)</code>，最后基准元素的位置还是在某一侧。下一次移动还是同样的情况，每次划分的数组的长度都是减少 1（另一个数组长度为 0）。整个排序过程的时间复杂度为 <code>O(n^2)</code>。</li>
<li><strong>左、右指针都停止</strong>：那么两个指针会交换着各自指向的元素，来到数组中间，并将基准元素放在中间，结束本轮划分。下次划分时，左右子数组的长度都会减半。整个排序过程的时间复杂度为 <code>O(nlogn)</code>。</li>
<li><strong>一个指针不停止、一个指针停止</strong>：等价于「左、右指针都不停止」的情况，因为情况 1 中，另一个指针就没有机会移动（就相当于停止啊）。</li>
</ol>
<p>综上，<strong>当指针指向的元素等于基准元素时，应该停止</strong>。</p>
<h2 id="优化后的快速排序代码"><a href="# 优化后的快速排序代码" class="headerlink" title="优化后的快速排序代码"></a>优化后的快速排序代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 arr[left], arr[mid], arr[right] 三数中值的索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getMedianIdx</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> min = (arr[left] &lt; arr[mid]) ? left : mid;</span><br><span class="line">    min = (arr[min] &lt; arr[right]) ? min : right;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max = (arr[left] &gt; arr[mid]) ? left : mid;</span><br><span class="line">    max = (arr[max] &gt; arr[right]) ? max : right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (min == left) &#123;</span><br><span class="line">        <span class="keyword">return</span> max == right ? mid : right;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (min == right) &#123;</span><br><span class="line">        <span class="keyword">return</span> max == left ? mid : left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> max == right ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 将选中的基准元素与数组末尾元素交换,  并指定基准元素为「数组末尾元素」</span></span><br><span class="line">    <span class="type">int</span> pivotIdx = getMedianIdx(arr, left, right);</span><br><span class="line">    swap(&amp;arr[right], &amp;arr[pivotIdx]);</span><br><span class="line">    <span class="type">int</span> pivot = arr[right];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = left, j = right - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j &amp;&amp; arr[i] &lt; pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= i &amp;&amp; arr[j] &gt; pivot) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            swap(&amp;arr[i++], &amp;arr[j--]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(&amp;arr[right], &amp;arr[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> pivot = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, pivot - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, pivot + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>最后留一个问题：快速排序为什么叫「快速」排序？</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法之归并排序</title>
    <url>/posts/231218181635.html</url>
    <content><![CDATA[<p>归并排序（Merge Sort）是一种分治算法，它 <strong> 将一个待排序的数组分成两个子数组，然后递归地对子数组进行排序 </strong>，最后将两个有序的子数组<strong> 合并 </strong> 成一个有序的数组。</p>
<p>例如，对于两个有序的子数组 A 和 B，我们借助一个 <em> 长度等于原数组 </em> 的临时数组 C，并为每个数组维护一个指针。通过指针的滑动比较，将 A 和 B 中较小的值填充到 C 中，完成一次合并（不同批次的归并过程，填充了临时数组 C 中的不同范围），最后再将数组 C 中的数据拷贝回原始数组，即可完成排序。</p>
<p>归并排序是经典的分治（divide-and-conquer）策略，它将问题分为一些小的问题，然后递归求解；而治的阶段则将分的阶段解得的各个答案修补到一起。</p>
<span id="more"></span>

<h1 id="归并排序实现"><a href="# 归并排序实现" class="headerlink" title="归并排序实现"></a>归并排序实现 </h1><h2 id="归并排序"><a href="# 归并排序" class="headerlink" title="归并排序"></a> 归并排序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> tempArr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        mergeSort(arr, tempArr, left, mid);        <span class="comment">// 归</span></span><br><span class="line">        mergeSort(arr, tempArr, mid + <span class="number">1</span>, right);   <span class="comment">// 归</span></span><br><span class="line">        merge(arr, tempArr, left, mid + <span class="number">1</span>, right); <span class="comment">// 并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并过程"><a href="# 并过程" class="headerlink" title="并过程"></a>并过程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* leftPos = start of left half, rightPos = start of right half, rightEnd = end of right half */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> tempArr[], <span class="type">int</span> leftPos, <span class="type">int</span> rightPos, <span class="type">int</span> rightEnd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> leftEnd = rightPos - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> leftPtr = leftPos, rightPtr = rightPos, tempPtr = leftPos; <span class="comment">// 三个指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个有序的子数组 A 和 B，填充到临时数组 C 中</span></span><br><span class="line">    <span class="keyword">while</span> (leftPtr &lt;= leftEnd &amp;&amp; rightPtr &lt;= rightEnd) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[leftPtr] &lt;= arr[rightPtr]) &#123;</span><br><span class="line">            tempArr[tempPtr++] = arr[leftPtr++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tempArr[tempPtr++] = arr[rightPtr++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (leftPtr &lt;= leftEnd) &#123;</span><br><span class="line">        tempArr[tempPtr++] = arr[leftPtr++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (rightPtr &lt;= rightEnd) &#123;</span><br><span class="line">        tempArr[tempPtr++] = arr[rightPtr++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将临时数组 C 拷贝回原始数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = leftPos; i &lt; rightEnd + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        arr[i] = tempArr[i]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果在 <code>merge()</code> 的每次递归调用内部申请临时数组，那么在任一时刻就可能有 <code>logN</code> 个临时数组处在活动期，这对于小内存的机器是致命的；且频繁的分配空间并释放空间的时间占用也会很多。所以，最好在 <code>mergeSort()</code> 开始之前申请好临时数组，并在排序完成后释放。</p>
</blockquote>
<h2 id="归并排序测试"><a href="# 归并排序测试" class="headerlink" title="归并排序测试"></a>归并排序测试</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> *tempArr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    mergeSort(arr, tempArr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After mergeSort: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); <span class="comment">// After mergeSort: 1 1 2 3 3 4 5 5 5 6 9</span></span><br><span class="line">    <span class="built_in">free</span>(tempArr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="归并排序分析"><a href="# 归并排序分析" class="headerlink" title="归并排序分析"></a>归并排序分析 </h1><h2 id="时空复杂度"><a href="# 时空复杂度" class="headerlink" title="时空复杂度"></a> 时空复杂度</h2><ul>
<li>最坏时间复杂度：<code>O(NlogN)</code>；</li>
<li>空间复杂度：<code>O(N)</code>，在「并」的过程中需要一个临时数组。</li>
</ul>
<h2 id="时间复杂度分析"><a href="# 时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析 </h2><p> 假设 $N$ 是 $2$ 的幂，从而我们总可以将原数组（假设长度为 $2^{k}$）分裂成大小相同的两部分（大小为 $2^{k-1}$）。</p>
<ul>
<li>对于 $N=1$，归并排序所用时间是常数，记为 $T(1) = 1$；</li>
<li>否则，对 $N$ 个数归并排序的用时，等于完成两个大小为 $\frac{N}{2}$ 的递归排序所用的时间，再加上合并的时间（它是线性的），记为 $T(N) = 2 \times T(\frac{N}{2}) + N$。</li>
</ul>
<p><strong>求解 $T(N)$ 方法一，用 $N$ 去除递推关系式的两边</strong>：</p>
<p>因为 $T(N) = 2 \times T(N/2) + N$，两边同时除以 $N$，有 $\frac{T(N)}{N} = \frac{T(N/2)}{N/2} + 1$，持续下去：</p>
<p>$\frac{T(N/2)}{N/2} = \frac{T(N/4)}{N/4} + 1$</p>
<p>$\frac{T(N/4)}{N/4} = \frac{T(N/8)}{N/8} + 1$</p>
<p>$\frac{T(N/8)}{N/8} = \frac{T(N/16)}{N/16} + 1$</p>
<p>$\frac{T(N/2^{k-1})}{N/2^{k-1}} = \frac{T(1)}{1} + 1$</p>
<p>上面系列等式的左边之和等于右边之和，化简有：$\frac{T(N)}{N} = \frac{T(1)}{1} + logN$</p>
<p>因此，$T(N) = N \times log(N) + N = O(N \times logN)$</p>
<p><strong>求解 $T(N)$ 方法二，在右边连续地代入递归关系</strong>：</p>
<p>$T(N) = 2 \times T(\frac{N}{2}) + N$<br>$= 2 \times (2 \times T(\frac{N}{4}) + \frac{N}{2}) + N = 2^2 \times T(\frac{N}{2^2}) + 2N$<br>$= 2^2 \times (2 \times T(\frac{N}{8}) + \frac{N}{4}) + 2N = 2^3 \times T(\frac{N}{2^3}) + 3N$<br>$= …$<br>$= 2^k \times T(\frac{N}{2^k}) + k \times N$</p>
<p>利用 $k = logN$，可以得到 $T(N) = N \times T(1) + log(N) \times N = O(N \times logN)$</p>
<h2 id="排序效率分析"><a href="# 排序效率分析" class="headerlink" title="排序效率分析"></a>排序效率分析 </h2><p> 虽然归并排序的运行时间是 $O(N \times logN)$，但它很难用于主存排序，主要问题在于：</p>
<ol>
<li>合并两个排序的表需要线性附加内存；</li>
<li>在整个算法中还要花费时间将数据拷贝到临时数组，再拷贝回原始数组的一些附加工作，其结果严重放慢了排序的速度。</li>
</ol>
<p>参考资料：<a href="https://awesome-programming-books.github.io/algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9AC%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89.pdf">数据结构与算法分析：C 语言描述（第 2 版）</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>计网之 OSI 模型</title>
    <url>/posts/231011192359.html</url>
    <content><![CDATA[<p>这篇文章主要介绍 OSI（Open System Interconnect）参考模型，以及 message、segment、datagram、packet、frame、bit 等概念。</p>
<span id="more"></span>

<h2 id="计算机网络各层代表设备"><a href="# 计算机网络各层代表设备" class="headerlink" title="计算机网络各层代表设备"></a>计算机网络各层代表设备</h2><ul>
<li>物理层：网卡、网线、光纤、atm 线缆等</li>
<li>数据链路层：二层交换机</li>
<li>网络层：路由器、三层交换机、防火墙</li>
<li>传输层：代表协议，如 TCP &amp; UDP</li>
<li>应用层：各种协议，如 HTTP &amp; SMTP &amp; FTP</li>
</ul>
<h2 id="OSI 模型中各层单位"><a href="#OSI 模型中各层单位" class="headerlink" title="OSI 模型中各层单位"></a>OSI 模型中各层单位 </h2><p> 在计算机网络中，有许多不同的概念用于描述数据在不同层次的传输和封装。以下是这些概念的简要介绍：</p>
<table>
<thead>
<tr>
<th>数据单元</th>
<th>层次</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>message</td>
<td>应用层</td>
<td>在应用层发送和接收的数据单元，它可以是任意大小的数据块</td>
</tr>
<tr>
<td>segment</td>
<td>传输层</td>
<td>在传输层（如 TCP）中使用的数据单元，segment 包含了源端口号和目的端口号，并提供可靠的、有序的数据传输</td>
</tr>
<tr>
<td>datagram</td>
<td>网络层</td>
<td>在网络层（如 IP）中使用的数据单元，datagram 包含了源 IP 和目的 IP，并提供不可靠的、无序的数据传输</td>
</tr>
<tr>
<td>packet</td>
<td>网络层通用</td>
<td>在网络层中使用的通用术语，用于表示在网络中传输的数据单元，可以指代 segment 或 datagram</td>
</tr>
<tr>
<td>frame</td>
<td>数据链路层</td>
<td>在数据链路层中使用的数据单元，frame 包含了物理地址（如 MAC 地址）和错误检测码，用于在物理网络中传输数据</td>
</tr>
<tr>
<td>bit</td>
<td>物理层</td>
<td>是计算机网络中最小的数据单位，用于表示二进制的 0 或 1</td>
</tr>
</tbody></table>
<h2 id="OSI 模型中各层的服务对象"><a href="#OSI 模型中各层的服务对象" class="headerlink" title="OSI 模型中各层的服务对象"></a>OSI 模型中各层的服务对象 </h2><p> 不同层之间是在为谁提供服务呢？</p>
<p>应用层为应用程序提供服务，传输层为应用层提供端到端的数据传输服务，网络层为传输层提供网络间的数据传输服务，数据链路层为网络层提供主机到主机的数据传输服务。</p>
<ol>
<li>应用层为应用程序提供服务。</li>
<li>传输层主要为进程提供端到端的通信服务。<ul>
<li>传输层使用端口号来标识不同的进程，将应用层的数据划分为较小的数据单元（segment），并通过网络传输到目的地。</li>
<li>传输层可以提供可靠的数据传输，保证数据的完整性和顺序性。</li>
<li>此外，传输层还负责多个进程间的数据分发和复用，可以同时为多个进程提供服务。</li>
</ul>
</li>
<li>网络层主要为主机提供服务。<ul>
<li>网络层负责将传输层的数据单元（segment）打包成网络层的数据单元（datagram），并通过网络进行传输。</li>
<li>网络层使用 IP 地址来标识主机和网络，通过路由选择算法将数据传输到目的地，实现主机间的通信。</li>
</ul>
</li>
<li>数据链路层主要为同一链路上的主机（或设备）提供服务。<ul>
<li>数据链路层负责将网络层的数据单元（datagram）打包成数据链路层的数据单元（frame），并通过物理链路进行传输。</li>
<li>数据链路层使用 MAC 地址来标识主机或设备，通过帧的发送和接收来实现同一链路上的通信。</li>
</ul>
</li>
</ol>
<p>总结成表格如下：</p>
<table>
<thead>
<tr>
<th>层级</th>
<th>功能</th>
<th>提供服务的对象</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>为应用程序提供服务</td>
<td>应用程序</td>
</tr>
<tr>
<td>传输层</td>
<td>为进程提供端到端的通信服务，划分数据单元，保证数据传输可靠性和顺序性，数据分发和复用</td>
<td>进程</td>
</tr>
<tr>
<td>网络层</td>
<td>为主机提供服务，将传输层的数据单元打包成网络层的数据单元，通过网络进行传输，寻址和路由选择，实现主机间通信</td>
<td>主机</td>
</tr>
<tr>
<td>数据链路层</td>
<td>为同一链路上的主机或设备提供服务，将网络层的数据单元打包成数据链路层的数据单元，通过物理链路进行传输，帧的封装和解封装，帧的传输和错误检测，介质访问控制</td>
<td>同一链路上的主机或设备</td>
</tr>
<tr>
<td>物理层</td>
<td>通过物理链路进行数据传输，数据的编码和解码，数据的传输和接收</td>
<td>物理链路上的设备和传输介质等</td>
</tr>
</tbody></table>
<h2 id="OSI-vs-TCP-IP 模型"><a href="#OSI-vs-TCP-IP 模型" class="headerlink" title="OSI vs. TCP/IP 模型"></a>OSI vs. TCP/IP 模型</h2><p><img src="../images/computer-network/OSI-TCP-model.png" alt="OSI vs. TCP/IP 模型"></p>
<h2 id="OSI 模型数据封装与解封装过程"><a href="#OSI 模型数据封装与解封装过程" class="headerlink" title="OSI 模型数据封装与解封装过程"></a>OSI 模型数据封装与解封装过程</h2><p><img src="../images/computer-network/OSI-data-encapsulation-unpacking.png" alt="OSI 模型数据封装与解封装过程"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>OSI模型</tag>
      </tags>
  </entry>
  <entry>
    <title>计网之 ACL 访问控制列表</title>
    <url>/posts/240306203742.html</url>
    <content><![CDATA[<p>访问控制列表 ACL（Access Control List）是一系列用于识别报文流的规则集合。这里的规则是指描述报文匹配条件的判断语句，匹配条件可以是报文的源地址、目的地址、端口号等。设备依据 ACL 规则识别出特定的报文，并根据预先设定的策略对其进行处理，从而可以实现堆网络访问行为的控制、限制网络流量、提高网络性能、防止网络攻击等。</p>
<span id="more"></span>

<h1 id="ACL 应用场景"><a href="#ACL 应用场景" class="headerlink" title="ACL 应用场景"></a>ACL 应用场景 </h1><h2 id="允许或拒接流量通过"><a href="# 允许或拒接流量通过" class="headerlink" title="允许或拒接流量通过"></a> 允许或拒接流量通过</h2><p>ACL 可以通过定义规则来允许（permit）或拒绝（deny）流量的通过。例如，下图允许主机 A 和 B 访问互联网、不允许访问服务器，主机 C 和 D 与其相反。</p>
<img src="../images/computer-network/acl-1.png" alt="ACL 允许或拒接流量通过" width="80%" height="80%">

<p>我们可以使用如下 basic ACL 规则实现，并对接口 G0/0/0 和 G0/0/1 出方向上的报文进行过滤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[RTA]acl basic 2000                                                             </span><br><span class="line">[RTA-acl-ipv4-basic-2000]rule permit source 192.168.1.0 0.0.0.255               </span><br><span class="line">[RTA-acl-ipv4-basic-2000]rule deny source 192.168.2.0 0.0.0.255                 </span><br><span class="line">[RTA]interface GigabitEthernet 0/0/0                                            </span><br><span class="line">[RTA-GigabitEthernet0/0/0]packet-filter 2000 outbound                           </span><br><span class="line">[RTA]interface GigabitEthernet 0/0/1                                            </span><br><span class="line">[RTA-GigabitEthernet0/0/1]packet-filter 2000 outbound                           </span><br></pre></td></tr></table></figure>

<h2 id="匹配后执行特定行为"><a href="# 匹配后执行特定行为" class="headerlink" title="匹配后执行特定行为"></a>匹配后执行特定行为</h2><p>ACL 可以根据需求来定义过滤的条件以及匹配条件后所执行的动作。例如，下图对主机 C 和 D 在入方向（inbound）进行匹配，并对匹配到的感兴趣流量进行加密之后再转发。</p>
<img src="../images/computer-network/acl-2.png" alt="ACL 匹配后执行特定行为" width="80%" height="80%">

<h1 id="ACL 分类"><a href="#ACL 分类" class="headerlink" title="ACL 分类"></a>ACL 分类 </h1><p> 根据不同的划分规则，ACL 可以有不同的分类。最常见的三种分类是基本 ACL、高级 ACL 和二层 ACL，其中高级 ACL 可以定义比基本 ACL 更准确、更丰富、更灵活的规则。</p>
<table>
<thead>
<tr>
<th><div style="width: 100px">ACL 类型</div></th>
<th><div style="width: 100px">编号范围</div></th>
<th>规则制定依据</th>
</tr>
</thead>
<tbody><tr>
<td>基本 ACL</td>
<td>2000-2999</td>
<td>报文的源 IP 地址</td>
</tr>
<tr>
<td>高级 ACL</td>
<td>3000-3999</td>
<td>报文的源 / 目的 IP 地址、源 / 目的端口号以及协议类型等信息</td>
</tr>
<tr>
<td>二层 ACL</td>
<td>4000-4999</td>
<td>报文的源 / 目的 MAC 地址、链路层协议类型等二层信息</td>
</tr>
</tbody></table>
<h1 id="ACL 规则"><a href="#ACL 规则" class="headerlink" title="ACL 规则"></a>ACL 规则</h1><img src="../images/computer-network/acl-3.png" alt="根据 ACL 规则过滤流量" width="80%" height="80%">

<p>一个 ACL 由多条 deny 或 permit 语句组成。设备逐条匹配规则，<strong>找到匹配的规则后执行对应动作，不再继续匹配后续规则</strong>。</p>
<blockquote>
<p>本示例中，RTA 收到了来自两个网络的报文。默认情况下，RTA 会依据 ACL 的配置顺序来匹配这些报文。网络 172.16.0.0/24 发送的数据流量将被 RTA 上配置的 ACL2000 的规则 15 匹配，因此会被拒绝；而来自网络 172.17.0.0/24 的报文不能匹配访问控制列表中的任何规则，因此 RTA 对报文不做任何处理，而是正常转发。</p>
</blockquote>
<p>需要注意的是，ACL 中定义的这些 <strong> 规则可能存在重复或矛盾</strong>，规则的匹配顺序决定了规则的优先级，ACL 通过设置规则的优先级（这里是 ACL ID 越小优先级越高）来处理规则之间重复或矛盾的情形。</p>
<p>ACL 的规则匹配顺序有以下两种：</p>
<ul>
<li><strong>配置顺序</strong>：按照规则编号由小到大进行匹配。默认情况按编号步长为 5 添加规则，用户也可指定编号添加规则，若指定的编号已经存在对应的规则，则替换它。</li>
<li><strong>自动排序</strong>：按照「深度优先」原则由深到浅进行匹配，各类 ACL 的「深度优先」排序法则如表所示。</li>
</ul>
<table>
<thead>
<tr>
<th>ACL 类型</th>
<th>排序原则</th>
</tr>
</thead>
<tbody><tr>
<td>基本 ACL</td>
<td>a. 先判断规则的匹配条件中是否包含 VPN 实例，包含者优先 <br> b. 如果 VPN 实例的包含情况相同，再比较源 IPv4 (IPv6) 地址范围，较小者优先 <br> c. 如果源 IPv4 (IPv6) 地址范围也相同，再比较配置的先后次序，先配置者优先</td>
</tr>
<tr>
<td>高级 ACL</td>
<td>a. 先判断规则的匹配条件中是否包含 VPN 实例，包含者优先 <br> b. 如果 VPN 实例的包含情况相同，再比较协议范围，指定有 IPv4 (IPv6) 承载的协议类型者优先 <br> c. 如果协议范围也相同，再比较源 IPv4 (IPv6) 地址范围，较小者优先 <br> d. 如果源 IPv4 地址范围也相同，再比较目的 IPv4 (IPv6) 地址范围，较小者优先 <br> e. 如果目的 IPv4 (IPv6) 地址范围也相同，再比较四层端口号的覆盖范围，较小者优先 <br> f. 如果四层端口号的覆盖范围无法比较，再比较配置的先后次序，先配置者优先</td>
</tr>
<tr>
<td>二层 ACL</td>
<td>a. 先比较源 MAC 地址范围，较小者优先 <br> b. 如果源 MAC 地址范围相同，再比较目的 MAC 地址范围，较小者优先 <br> c. 如果目的 MAC 地址范围也相同，再比较配置的先后次序，先配置者优先</td>
</tr>
</tbody></table>
<blockquote>
<p>比较 IPv4 地址范围，就是比较通配符掩码（反向掩码）中 “0” 位的多少，”0” 位越多，范围越小。比较 IPv6 地址范围，就是比较地址前缀长度，前缀越长，范围越小。比较 MAC 地址范围，就是比较掩码中 “1” 位的多少，”1” 位越多，范围越小。</p>
</blockquote>
<h1 id="高级 ACL"><a href="# 高级 ACL" class="headerlink" title="高级 ACL"></a>高级 ACL</h1><p>高级 ACL 可以定义比基本 ACL 更准确、更丰富、更灵活的规则。假设下图中，我们要求主机 A 不可以访问 SFTP 服务器的 FTP 服务，主机 B 不可以访问私有服务器。</p>
<img src="../images/computer-network/acl-4.png" alt="高级 ACL 规则" width="80%" height="80%">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[RTA]acl advanced 3000                                                          </span><br><span class="line">[RTA-acl-ipv4-adv-3000]rule deny tcp source 192.168.1.0 0.0.0.255 destination 17</span><br><span class="line">2.16.10.1 0.0.0.0 destination-port eq 21                                        </span><br><span class="line">[RTA-acl-ipv4-adv-3000]rule deny tcp source 192.168.2.0 0.0.0.255 destination 17</span><br><span class="line">2.16.10.2 0.0.0.0                                                               </span><br><span class="line">[RTA-acl-ipv4-adv-3000]rule permit ip                                           </span><br><span class="line">[RTA]interface GigabitEthernet 0/0/0                                            </span><br><span class="line">[RTA-GigabitEthernet0/0/0]packet-filter 3000 outbound                           </span><br></pre></td></tr></table></figure>

<p>上述进行了高级 ACL 的配置：</p>
<ul>
<li>rule 5 拒绝了主机 A 访问 SFTP 服务器的 FTP 服务，但 telnet 服务（目的端口为 23）和 ping（ICMP 协议）访问不受限制；</li>
<li>rule 10 拒接了主机 B 访问私有服务器的所有 tcp 流量；</li>
<li>rule 15 作为最低优先级，允许了任意 ip 协议。</li>
<li>最后，在流量的出方向进行包过滤。</li>
</ul>
<p>tcp 流量有握手机制，假如我们 <strong> 仅在</strong>RTA 的 G0/0/0 方向限制 SFTP 服务器或私有服务器的流量进入（inbound），这会影响到 tcp 握手的建立，导致主机 A 的 tcp 流量无法连接到服务器。</p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://www.bilibili.com/video/BV1zy4y1t7Fj/">https://www.bilibili.com/video/BV1zy4y1t7Fj/</a></li>
<li><a href="https://www.h3c.com/cn/d_201905/1181948_30005_0.htm">https://www.h3c.com/cn/d_201905/1181948_30005_0.htm</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>访问控制列表</category>
      </categories>
      <tags>
        <tag>ACL</tag>
        <tag>访问控制列表</tag>
      </tags>
  </entry>
  <entry>
    <title>计网之 VXLAN 网络虚拟化技术</title>
    <url>/posts/231221200716.html</url>
    <content><![CDATA[<p>本文介绍 VLAN 和 VXLAN 网络虚拟化技术，并同时给出了 <code>Access</code>、<code>Trunk</code> 和 <code>Hybrid</code> 端口的区别，以及它们对 VLAN 报文的处理方式。</p>
<span id="more"></span>

<h1 id="VLAN- 封装"><a href="#VLAN- 封装" class="headerlink" title="VLAN 封装"></a>VLAN 封装 </h1><p> 要使网络设备能够分辨不同的 VLAN 报文，需要在报文中添加标识 VLAN 的字段。由于 <strong> 二层交换机工作在数据链路层</strong>，只能对报文的数据链路层封装进行识别。因此，如果添加识别字段，也需要添加到数据链路层封装中。</p>
<p>IEEE 802.1Q 协议规定，在以太网报文的目的 MAC 地址和源 MAC 地址之后、协议类型字段之前 <strong> 加入 4 个字节的 VLAN Tag，用以标识 VLAN 的相关信息</strong>。</p>
<img src="../images/computer-network/vlan-tag.png" alt="VLAN 数据帧" width="80%" height="80%">

<ul>
<li><code>TPID</code> 用来表示报文是否带有 VLAN Tag，长度为 16 bits，缺省情况下，<code>TPID</code> 取值为 <code>0x8100</code>，表示数据帧中包括 VLAN Tag，但各设备厂商可以自定义该字段的值。</li>
<li><code>VID</code> 用来表示该报文所属 VLAN 的编号，长度为 12 bits，取值范围可为 <code>[0, 4095]</code>。由于 <code>0</code> 和 <code>4095</code> 为协议保留取值，所以 <code>VID</code> 的实际取值范围为 <code>[1, 4094]</code>。</li>
</ul>
<p>网络设备根据报文是否携带 VLAN Tag 以及携带的 VLAN Tag 信息，来对报文进行处理，<strong>利用 <code>VID</code> 来识别报文所属的 VLAN</strong>。</p>
<blockquote>
<p>因为 <code>VID</code> 的实际取值范围为 <code>[1, 4094]</code>，所以最多可以划分 4094 个不同的 VLAN 网络。</p>
</blockquote>
<h1 id="基于端口的 VLAN"><a href="# 基于端口的 VLAN" class="headerlink" title="基于端口的 VLAN"></a>基于端口的 VLAN</h1><p>基于端口划分 VLAN 是最简单、最有效的 VLAN 划分方法。它按照设备端口来定义 VLAN 成员，将指定端口加入到指定 VLAN 中之后，该端口就可以转发该 VLAN 的报文。</p>
<h2 id="Access-amp-Trunk-amp-Hybird 端口区别"><a href="#Access-amp-Trunk-amp-Hybird 端口区别" class="headerlink" title="Access&amp;Trunk&amp;Hybird 端口区别"></a>Access&amp;Trunk&amp;Hybird 端口区别 </h2><p> 端口的链路类型分为三种，端口的链路类型决定了端口能否加入多个 VLAN。不同链路类型的端口在转发报文时对 VLAN Tag 的处理方式不同。</p>
<ul>
<li><p><code>Access</code> 端口：只能发送一个 VLAN 的报文，不带 VLAN Tag。</p>
<ul>
<li>一般用于和不能识别 VLAN Tag 的用户终端设备相连，或者不需要区分不同 VLAN 成员时使用。</li>
</ul>
</li>
<li><p><code>Trunk</code> 端口：可以发送多个 VLAN 的报文，缺省 VLAN 的报文不带 VLAN Tag，其他 VLAN 的报文必须带 VLAN Tag。</p>
<ul>
<li>通常用于网络传输设备之间的互连。</li>
</ul>
</li>
<li><p><code>Hybrid</code> 端口：可以发送多个 VLAN 的报文，并可根据需要配置某些 VLAN 的报文带 VLAN Tag，某些 VLAN 的报文不带 VLAN Tag。</p>
<ul>
<li>在一些应用场景下，需要使用 <code>Hybrid</code> 端口的功能。比如在 1:2 VLAN 映射中，服务提供商网络的多个 VLAN 的报文在进入用户网络前，需要剥离外层 VLAN Tag，此时 <code>Trunk</code> 端口不能实现该功能，因为 <code>Trunk</code> 端口只能使该端口缺省 VLAN 的报文不带 VLAN Tag 通过。</li>
</ul>
</li>
</ul>
<h2 id="端口缺省 -VLAN"><a href="# 端口缺省 -VLAN" class="headerlink" title="端口缺省 VLAN"></a>端口缺省 VLAN</h2><p>端口缺省 VLAN 简称为 PVID（Port VLAN ID）。当端口收到 <code>Untagged</code> 报文时，会认为该报文所属的 VLAN 为 PVID。</p>
<ul>
<li><code>Access</code> 端口的 PVID 就是它所在的 VLAN。</li>
<li><code>Trunk</code> 端口和 <code>Hybrid</code> 端口可以允许多个 VLAN 通过，能够配置端口 PVID。</li>
</ul>
<h2 id="端口对报文的处理方式"><a href="# 端口对报文的处理方式" class="headerlink" title="端口对报文的处理方式"></a>端口对报文的处理方式 </h2><p> 端口对报文的接收和发送的处理有几种不同情况。</p>
<p><strong><code>Access</code> 端口</strong>：</p>
<ul>
<li>接收：<ul>
<li>接收的报文不带 TAG：为报文添加端口 PVID 的 Tag；</li>
<li>接收的报文带 TAG：当报文的 VLAN ID 与端口的 PVID 相同（不同）时，接收（丢弃）该报文。</li>
</ul>
</li>
<li>发送：去掉 TAG，发送该报文。</li>
</ul>
<p><strong><code>Trunk</code> 端口</strong>：</p>
<ul>
<li>接收：<ul>
<li>接收的报文不带 TAG：当端口的 PVID 在（不在）端口允许通过的 VLAN ID 列表里时，接收该报文，给报文添加 PVID 的 Tag（丢弃该报文）。</li>
<li>接收的报文带 TAG：当报文的 VLAN ID 在（不在）端口允许通过的 VLAN ID 列表里时，接收（丢弃）该报文。</li>
</ul>
</li>
<li>发送：当报文的 VLAN ID 与端口的 PVID 相同（不同），且是该端口允许通过的 VLAN ID 时：去掉 Tag（保持原有 Tag），发送该报文。</li>
</ul>
<p><strong><code>Hybird</code> 端口</strong>：</p>
<ul>
<li>接收：<ul>
<li>接收的报文不带 TAG：当端口的 PVID 在（不在）端口允许通过的 VLAN ID 列表里时，接收该报文，给报文添加 PVID 的 Tag（丢弃该报文）。</li>
<li>接收的报文带 TAG：当报文的 VLAN ID 在（不在）端口允许通过的 VLAN ID 列表里时，接收（丢弃）该报文。</li>
</ul>
</li>
<li>发送：当报文的 VLAN ID 是端口允许通过的 VLAN ID 时，发送该报文，并可以配置端口在发送该 VLAN 的报文时是否携带 Tag。</li>
</ul>
<h1 id="VXLAN"><a href="#VXLAN" class="headerlink" title="VXLAN"></a>VXLAN</h1><h2 id="VXLAN- 简介"><a href="#VXLAN- 简介" class="headerlink" title="VXLAN 简介"></a>VXLAN 简介 </h2><p>VXLAN（Virtual eXtensible LAN，可扩展虚拟局域网络）是一种基于 IP 网络构建逻辑拓扑、采用 MAC in UDP 封装的<strong> 二层 VPN 技术 </strong>。VXLAN 可以基于已有的服务提供商或企业 IP 网络，为分散的物理站点提供二层和三层互联，并能为不同用户提供业务隔离服务。VXLAN 主要应用于数据中心网络，能够创建<strong> 更多 </strong> 的虚拟网络。</p>
<h2 id="VXLAN- 技术价值"><a href="#VXLAN- 技术价值" class="headerlink" title="VXLAN 技术价值"></a>VXLAN 技术价值</h2><ul>
<li><p>VXLAN 支持大量租户：支持多达 1600 万个相互隔离的二层网络，解决了传统二层网络 VLAN 资源不足问题。</p>
</li>
<li><p>VXLAN 网络易于维护：基于 IP 网络构建大二层网络，将原始二层数据帧封装成 VXLAN 报文，在 IP 网络中透传，充分利用现有 IP 网络技术，部署和维护更容易。</p>
</li>
<li><p>VXLAN 网络保证虚拟机动态迁移：采用 MAC in UDP 的封装方法，保证虚拟机迁移前后的 IP 和 MAC 不变。</p>
</li>
</ul>
<h2 id="VXLAN- 网络模型"><a href="#VXLAN- 网络模型" class="headerlink" title="VXLAN 网络模型"></a>VXLAN 网络模型</h2><p>VXLAN 技术将已有的三层物理网络作为 Underlay 网络，在其上构建出虚拟的二层网络，即 Overlay 网络。Overlay 网络通过封装技术、利用 Underlay 网络提供的三层转发路径，实现租户二层报文跨越三层网络在不同站点间传递。</p>
<p>对于租户来说，Underlay 网络是透明的，同一租户的不同站点就像工作在一个局域网中。Underlay 网络既可以是 IPv4 网络，也可以是 IPv6 网络。</p>
<p><img src="https://pic1.zhimg.com/80/v2-cd8549811c9630cb8e385fca11f53718_720w.webp" alt="VXLAN 网络模型示意图"></p>
<ul>
<li><p>VTEP（VXLAN Tunnel End Point，VXLAN 隧道端点）：VXLAN 的边缘设备。VXLAN 的相关处理都在 VTEP 上进行，例如识别以太网数据帧所属的 VXLAN、基于 VXLAN 对数据帧进行二层转发、封装 / 解封装报文等。VTEP 可以是网络设备（比如交换机），也可以是一台机器（比如虚拟化集群中的宿主机）。</p>
</li>
<li><p>VNI（VXLAN Network Identifier，VXLAN 网络标识符）：VNI 是每个 VXLAN 段的标识，是个 24 位整数，一共有 $2^{24} = 16777216$，一般每个 VNI 对应一个租户，也就是说使用 VXLAN 搭建的公有云可以理论上可以支撑千万级别的租户。</p>
</li>
<li><p>Tunnel（VXLAN 隧道）：两个 VTEP 之间的点到点逻辑隧道，负责在 IP 网络中转发 VXLAN 报文。VTEP 为数据帧封装 VXLAN 头、UDP 头和 IP 头后，通过 VXLAN 隧道将封装后的报文转发给远端 VTEP，远端 VTEP 对其进行解封装。</p>
</li>
</ul>
<p>上图所示为 VXLAN 的工作模型，它创建在原来的 IP 网络（三层）上，只要是三层可达（能够通过 IP 相互通信）的网络就能部署 VXLAN。在 VXLAN 网络的每个端点都有一个 VTEP 设备，负责 VXLAN 协议报文的解包和封包。</p>
<p>物理网络上可以创建多个 VXLAN 网络，可以将这些 VXLAN 网络看成一个隧道，不同节点上的虚拟机 / 容器能够通过隧道直连。通过 VNI 标识不同的 VXLAN 网络，使得不同的 VXLAN 可以相互隔离。</p>
<h2 id="VXLAN- 封装"><a href="#VXLAN- 封装" class="headerlink" title="VXLAN 封装"></a>VXLAN 封装</h2><p>MAC in UDP 封装：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Eth-Layer(14) + IP-Layer(20/40) + UDP-Layer(8) + VXLAN-Layer(8) + </span><br><span class="line">Eth-Layer(14/18) +  IP-Layer(20/40) + L4-Layer(8/20) + Payload // 封装三层报文</span><br><span class="line"></span><br><span class="line">Eth-Layer(14) + IP-Layer(20/40) + UDP-Layer(8) + VXLAN-Layer(8) + </span><br><span class="line">Eth-Layer(14/18) + Payload // 封装二层报文</span><br></pre></td></tr></table></figure>

<img src="../images/computer-network/vxlan-format.png" alt="VXLAN 数据帧格式" width="80%" height="80%">

<ul>
<li><p>VXLAN Header：在原始二层帧的前面添加 8 字节的 VXLAN 的头部，其中最主要的是 <code>VNID</code>，占用 3 个字节（即 24 bit），类似 VLAN ID，可以具有 $2^{24}$ 个网段。</p>
</li>
<li><p>UDP Header：在 VXLAN 和原始二层帧的前面使用 8 字节 UDP 头部进行封装（MAC IN UDP），<strong>目的端口号缺省使用 4789 作为 VXLAN 的默认目的端口号</strong>，源端口按流随机分配（通过 MAC、IP、四层端口号进行 hash 操作）， 这样可以更好的做 ECMP。</p>
</li>
</ul>
<blockquote>
<p>在上面「添加的二层封装」之后，再添加底层网络的 IP 头部（20 字节 / 40 字节）和 MAC 头部（<code>Access</code> 端口为 14 字节、<code>Trunk</code> 端口为 18 字节），这里的 IP 和 MAC 是宿主机的 IP 地址和 MAC 地址。</p>
</blockquote>
<p>VXLAN 封装的报文示例：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">5c dd 70 b4 b6 5e 48 73 97 2b eb 7b 08 00 45 00 01 4c 06 ac 00 00</span><br><span class="line">ff 11 03 22 0a 14 06 1e 50 50 50 51 c9 56 12 b5 01 38 00 00 08 00</span><br><span class="line">00 00 00 00 0a 00 00 00 67 a5 ab 3f 00 00 67 a5 ab 3e 08 00 45 00 </span><br><span class="line">01 1a 00 00 00 00 40 11 15 6c 32 00 00 02 32 00 00 66 04 27 08 0f </span><br><span class="line">01 06 f6 bb 00 02 00 04 83 dc 89 76 00 00 00 00 00 00 00 01 00 00 </span><br><span class="line">00 00 01 bd 0d 28 00 00 00 00 00 04 47 90 00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 93 1c 05 cc 22 14 31 5c 49 78 69 60 a0 00 </span><br><span class="line">00 00 10 11 12 13 69 d7 15 de 00 b2 1a 1b 1c 1d 1e 1f 20 21 22 23 </span><br><span class="line">24 25 26 27 28 29 2a 2b 2c 2d 2e 2f 30 31 32 33 34 35 36 37 38 39 </span><br><span class="line">3a 3b 3c 3d 3e 3f 40 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f </span><br><span class="line">50 51 52 53 54 55 56 57 58 59 5a 5b 5c 5d 5e 5f 60 61 62 63 64 65 </span><br><span class="line">66 67 68 69 6a 6b 6c 6d 6e 6f 70 71 72 73 74 75 76 77 78 79 7a 7b </span><br><span class="line">7c 7d 7e 7f 80 81 82 83 84 85 86 87 88 89 8a 8b 8c 8d 8e 8f 90 91 </span><br><span class="line">92 93 94 95 96 97 98 99 9a 9b 9c 9d 9e 9f a0 a1 a2 a3 a4 a5 a6 a7 </span><br><span class="line">a8 a9 aa ab ac ad ae af b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 ba bb bc bd </span><br><span class="line">be bf c0 c1 c2 c3 c4 c5 c6 c7 c8 c9 ca cb 86 d4</span><br></pre></td></tr></table></figure>

<img src="../images/computer-network/vxlan-packet.png" alt="VXLAN 报文" width="80%" height="80%">
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>VXLAN</tag>
      </tags>
  </entry>
  <entry>
    <title>计网之路由表、转发表与快速转发工作原理</title>
    <url>/posts/240130190208.html</url>
    <content><![CDATA[<p>本文介绍路由表（Routing Information Base, RIB）、转发表（Forwarding Information Base, FIB）和快速转发（Fast Forwarding）的相关概念和工作原理。</p>
<span id="more"></span>

<h1 id="相关概念"><a href="# 相关概念" class="headerlink" title="相关概念"></a>相关概念 </h1><h2 id="路由表"><a href="# 路由表" class="headerlink" title="路由表"></a> 路由表 </h2><p> 路由表（Routing Information Base, RIB）：路由表是网络设备（如路由器）中存储的一张表格，<strong>记录了网络中各个目的地的网络地址、下一跳地址 </strong> 以及其他相关信息。路由表中的每一条路由记录都包含了目的地址（Destination/Mask）和相应的下一跳（NextHop）信息，<strong>用于确定数据的转发路径</strong>。例如，发往目的地 <code>10.20.1.10</code> 的数据将会匹配到 <code>10.20.1.0/24</code> 这条路由，其下一跳地址是 <code>10.20.1.11</code>，数据将从出口接口 <code>GE0/0/0</code> 转发出去。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[MSR]display ip routing-table                                                   </span><br><span class="line">                                                                                </span><br><span class="line">Destinations : 8 Routes : 8                                                     </span><br><span class="line">                                                                                </span><br><span class="line">Destination/Mask   Proto   Pre Cost        NextHop         Interface            </span><br><span class="line">0.0.0.0/32         Direct  0   0           127.0.0.1       InLoop0              </span><br><span class="line">10.20.1.0/24       Direct  0   0           10.20.1.11      GE0/0/0              </span><br><span class="line">10.20.1.11/32      Direct  0   0           127.0.0.1       InLoop0              </span><br><span class="line">10.20.1.255/32     Direct  0   0           10.20.1.11      GE0/0/0              </span><br><span class="line">127.0.0.0/8        Direct  0   0           127.0.0.1       InLoop0              </span><br><span class="line">127.0.0.1/32       Direct  0   0           127.0.0.1       InLoop0              </span><br><span class="line">127.255.255.255/32 Direct  0   0           127.0.0.1       InLoop0              </span><br><span class="line">255.255.255.255/32 Direct  0   0           127.0.0.1       InLoop0              </span><br><span class="line">[MSR]</span><br><span class="line"></span><br><span class="line">[MSR]dis interface brief                                                        </span><br><span class="line">Brief information on interfaces in route mode:                                  </span><br><span class="line">Link: ADM - administratively down; Stby - standby                               </span><br><span class="line">Protocol: (s) - spoofing                                                        </span><br><span class="line">Interface                         Link Protocol Primary IP        Description   </span><br><span class="line"></span><br><span class="line">GE0/0/0                           UP   UP       10.20.1.11</span><br></pre></td></tr></table></figure>

<h2 id="转发表"><a href="# 转发表" class="headerlink" title="转发表"></a>转发表 </h2><p> 转发表（Forwarding Information Base, FIB）：转发表是路由器或交换机中的一个数据结构，用于存储 <strong> 从路由表中提取的转发信息 </strong>。FIB 中的记录是根据路由表中的路由信息进行<strong> 提取和优化的，以方便快速转发数据包</strong>。FIB 中的每一条记录都包含了目的地址和相应的出口接口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[MSR]display fib                                                                </span><br><span class="line">Route destination count: 8                                                      </span><br><span class="line">Directly-connected host count: 0                                                </span><br><span class="line">Entries issued to hardware: 6                                                   </span><br><span class="line">                                                                                </span><br><span class="line">Flag:                                                                           </span><br><span class="line">  U:Usable    G:Gateway   H:Host   B:Blackhole   D:Dynamic   S:Static           </span><br><span class="line">  R:Relay     F:FRR</span><br><span class="line">  # 依次是可用路由、网关路由、主机路由、黑洞路由、动态理由、静态路由              </span><br><span class="line">  # 迭代路由、快速重路由                                                         </span><br><span class="line">                   下一跳地址    路由标志   转发接口 / LSP 索引号                 </span><br><span class="line">Destination/Mask   Nexthop         Flag     OutInterface/Token       Label      </span><br><span class="line">0.0.0.0/32         127.0.0.1       UH       InLoop0                  Null       </span><br><span class="line">10.20.1.0/24       10.20.1.11      U        GE0/0/0                  Null       </span><br><span class="line">10.20.1.11/32      127.0.0.1       UH       InLoop0                  Null       </span><br><span class="line">10.20.1.255/32     10.20.1.11      UBH      GE0/0/0                  Null       </span><br><span class="line">127.0.0.0/8        127.0.0.1       U        InLoop0                  Null       </span><br><span class="line">127.0.0.1/32       127.0.0.1       UH       InLoop0                  Null       </span><br><span class="line">127.255.255.255/32 127.0.0.1       UH       InLoop0                  Null       </span><br><span class="line">255.255.255.255/32 127.0.0.1       UH       InLoop0                  Null       </span><br><span class="line">[MSR]</span><br></pre></td></tr></table></figure>

<h2 id="快速转发表"><a href="# 快速转发表" class="headerlink" title="快速转发表"></a>快速转发表 </h2><p> 快速转发表（Fast Forwarding Table）：快速转发表是 <strong> 在 FIB 的基础上进行进一步优化 </strong> 的数据结构。它是网络设备中的 <strong> 一个高速缓存 </strong>，用于存储<strong> 最常用 </strong> 的转发信息。快速转发表中的记录是经过优化和加速的，<strong>以提高数据包的转发速度</strong>。快速转发表中的每一条记录都包含了目的地地址和相应的出口接口。</p>
<blockquote>
<p>转发表和快速转发表都是基于路由表的衍生物，用于加速数据包的转发过程。</p>
</blockquote>
<h2 id="路由转发分组"><a href="# 路由转发分组" class="headerlink" title="路由转发分组"></a>路由转发分组 </h2><p> 路由转发分组：路由转发分组是指网络设备（如路由器）根据接收到的数据包的目的地址，通过查询 <del> 路由表 </del>FIB 表，选择合适的出口接口将数据包转发到下一跳<strong> 的过程 </strong>。<del> 路由表</del>FIB 表是路由转发分组的基础和依据。</p>
<h1 id="路由表工作原理"><a href="# 路由表工作原理" class="headerlink" title="路由表工作原理"></a>路由表工作原理 </h1><p> 在一张路由表中，当存在多个路由项可同时匹配目的地址时，路由查找进程会 <strong> 选择掩码（Mask）最长的路由项用于转发</strong>，即最长匹配原则。因为掩码越长，所处的网段范围就越小，网段的范围越小，就越能快速的定位到 PC 机的具体位置，从而加快转发效率。</p>
<p>例子：在运行了 RIP (Routing Information Protocol，一种用于路由选择的动态路由协议) 的 MSR 路由器上看到如下路由信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;MSR&gt;display ip routing-table 6.6.6.6</span><br><span class="line"></span><br><span class="line">Routing Table: Public</span><br><span class="line"></span><br><span class="line">Summary Count: 2</span><br><span class="line"></span><br><span class="line">Destination/Mask Proto Pre Cost  NextHop  Interface</span><br><span class="line"></span><br><span class="line">6.6.6.0/24       RIP   100   1  100.1.1.1  GE0/0</span><br><span class="line">6.0.0.0/8       Static 60    0  100.1.1.1  GE0/0</span><br><span class="line">&lt;MSR&gt;</span><br></pre></td></tr></table></figure>

<p>此时路由器收到一个目的地址为 <code>6.6.6.6</code> 的数据包，那么（A）。</p>
<ul>
<li>A. 该数据包将优先匹配路由表中的 RIP 路由，因为其掩码 Mask 最长。</li>
<li>B. 该数据包将优先匹配路由表中的 RIP 路由，因为其优先级 Pre 高。</li>
<li>C. 该数据包将优先匹配路由表中的静态路由，因为其花费 Cost 小。</li>
<li>D. 该数据包将优先匹配路由表中的静态路由，因为其掩码 Mask 最短。</li>
</ul>
<p>尽管如此，路由表中 <strong> 路由项数量越多 </strong>，所需查找及匹配的次数就越多，其<strong> 转发效率就会降低</strong>。为了实现控制平面与转发平面完全分离，就需要系统构建一张专注于数据报文转发的表，即转发表。</p>
<h1 id="转发表 -1"><a href="# 转发表 -1" class="headerlink" title="转发表"></a>转发表 </h1><h2 id="转发表生成方式"><a href="# 转发表生成方式" class="headerlink" title="转发表生成方式"></a> 转发表生成方式</h2><p>FIB 表的生成有 2 种方式，一种是源于路由表项，另外一种是通过 ARP 解析获得。</p>
<h3 id="源于路由表项"><a href="# 源于路由表项" class="headerlink" title="源于路由表项"></a>源于路由表项 </h3><p> 第一种方式，当开始计算路由信息的时候，因为在一个网络拓扑结构中，可能会运行多个路由协议，而不同路由协议所计算出的路径可能会不同。</p>
<p>当出现这种情况时，路由器会 <strong> 选择较高路由优先级的路由协议所发现的路由 </strong> 作为最优路由，即比较路由的优先级将其选出，置为 Active（活跃）状态；而其他路由作为备份路由，置为 Inactive（非活跃）状态。<strong>系统会再把 Active 状态的路由表项导入至 FIB 表中，作为系统转发的依据</strong>。</p>
<h3 id="通过 ARP 解析"><a href="# 通过 ARP 解析" class="headerlink" title="通过 ARP 解析"></a>通过 ARP 解析 </h3><p> 第二种方式，通过 ARP 解析，得到 MAC 地址与目的 IP 地址的映射关系。为了将这个映射关系添加到 FIB 表中，主机需要将目标 IP 地址与对应的 MAC 地址加入到本地网段内的主机路由信息中。最后将主机路由信息添加到 FIB 表中。</p>
<h2 id="转发表工作原理"><a href="# 转发表工作原理" class="headerlink" title="转发表工作原理"></a>转发表工作原理 </h2><p> 在 FIB 表生成过程中，需要注意的一点是，<strong>FIB 表与路由表是同步更新的 </strong>。系统的控制平面会发现<em> 新的 </em> 路由信息，根据路由信息更新到自己的路由表中，生成新的 Active 状态的路由表项，再更新至 FIB 表。</p>
<p>路由表属于控制平面，FIB 表属于转发平面，这样便做到了 <strong> 控制平面与转发平面的分离</strong>。如果原路由表中处于 Active 状态的路由表项失效，系统也会删除相关 FIB 表项。</p>
<p>由于 FIB 表 <strong> 全是 </strong> 处于 Active 状态的路由，所以 FIB 表项的 <strong> 数量远远小于 </strong> 路由表项。基于这种特性，在设计的时候，<strong>系统可以将 FIB 表项加载到硬件中，从而加快数据转发速度 </strong>。例如，在某些高端交换机启动后，FIB 表被系统加载到接口业务板的硬件中，<strong> 数据报文再通过硬件转发，不需要再通过 CPU 转发</strong>，可以大大降低转发时延。</p>
<blockquote>
<p>控制平面与转发平面的物理（或逻辑）分离，使得主控板上的 CPU 不负责报文转发，专注于系统的控制；而业务板则专注于数据报文转发。如果主控板损坏，业务板仍然能够转发报文。</p>
</blockquote>
<h1 id="快速转发"><a href="# 快速转发" class="headerlink" title="快速转发"></a>快速转发 </h1><p> 路由器常规转发报文的流程：</p>
<p>路由器接收到一个报文后，将它从接口存储器拷贝至 CPU 中，CPU 会根据报文的目的地址寻找 FIB 表中与之匹配的转发项，最终确定一条最佳的路径。与此同时，再将报文按照数据链路层上使用的协议进行封装，最后，封装后的链路层帧通过 DMA（Direct Memory Access，直接内存访问）拷贝至输出队列中进行报文转发。这一个过程经过了 2 次系统总线，每一个报文都要重复这个过程。</p>
<p>路由器性能因素：</p>
<p>衡量路由器性能因素之一是报文的转发效率，报文的转发效率越高，性能就越强。所以，需要再用到快速转发表来进行转发，<strong>快速转发表采用高速缓存来处理报文，使用基于数据流的技术来处理</strong>。</p>
<p>什么是基于数据流？</p>
<p>数据流是指在计算机系统中，数据在各个组件（如程序、模块、子系统等）之间传输和处理的过程。在数据流中，数据经过一系列处理后，输出到下一个组件或者最终输出到终端用户。例如，访问 HTTP 服务的一次操作。</p>
<p>在计算机网络中，一般 <strong> 用一个五元组来描述一个数据流，源 IP 地址、源端口号、目的 IP 地址、目的端口号、协议号 </strong>。当一个数据流的第一个报文通过查找 FIB 表转发后，在高速缓存中生成相应的转发信息，该数据流<strong> 后续报文的转发 </strong> 就可以通过直接查找高速缓存来实现。</p>
<p>例如，<strong>当一个主机需要访问服务器时，主机发出的第一个报文到达路由器的接口后，路由器会查找快速转发表实现快速转发。但由于这个报文是第一个报文，快速转发表中并没有这条数据流的转发信息高速缓存，所以系统无法进行快速转发。便会退而求其次，将报文移交至普通的 FIB 表，由 CPU 负责在 FIB 表中查找相关转发项，然后进行封装，再从接口转发出去。与此同时，系统记录报文中的五元组信息，再高速缓存中会生成相应的快速转发信息</strong>。</p>
<p>系统会根据五元组信息生成相应的快速转发信息缓存。与此同时，也会记录转发时的 <strong> 封装信息及接口信息 </strong>。在当后续报文来到后，系统会查看报文中的五元组，如果命中了快速转发缓存，则会根据缓存中的封装信息<strong> 直接进行 </strong> 二层数据帧的封装。然后，在中断中直接送到出接口发送。这样，<strong>就不需要上报 CPU 进行查表操作，也不需要内存访问操作，更不用占用系统总线资源</strong>。</p>
<p>快速转发技术就在很大程度上缩减了 IP 报文的排队流程，也减少了报文的转发时间。</p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://blog.csdn.net/qq_42603841/article/details/134569517">https://blog.csdn.net/qq_42603841/article/details/134569517</a></li>
<li><a href="https://blog.csdn.net/lynnucas/article/details/78814365">https://blog.csdn.net/lynnucas/article/details/78814365</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>路由转发</category>
      </categories>
      <tags>
        <tag>路由表</tag>
        <tag>转发表</tag>
        <tag>快速转发</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之 pthread 多线程</title>
    <url>/posts/230911151334.html</url>
    <content><![CDATA[<h2 id="多线程"><a href="# 多线程" class="headerlink" title="多线程"></a>多线程 </h2><h3 id="进程与线程"><a href="# 进程与线程" class="headerlink" title="进程与线程"></a> 进程与线程 </h3><p><strong> 进程</strong>：是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单元，是应用程序运行的载体。进程一般由程序、数据集合和进程控制块三部分组成：</p>
<ul>
<li><p>程序：描述进程的功能，控制进程的指令集（写论文的目的和手段）</p>
</li>
<li><p>数据集：程序在执行时所需要的数据和工作区（写论文的材料）</p>
</li>
<li><p>进程控制块：跟踪每个进程的状态，操作系统会为进程保留进程列表（写作者）</p>
</li>
</ul>
<p><strong>线程 </strong>：线程是程序执行中的一个单一的<strong> 顺序控制流程</strong>，是程序执行流的最小单元，是处理器调度和分派的基本单位。</p>
<ul>
<li><p>一个进程至少有一个线程，一个进程也可以有多个线程。（一个父亲可以有一个、多个孩子）</p>
</li>
<li><p>各个线程之间共享程序的内存空间，即所在进程的内存空间。（多个孩子共享一个家庭空间）</p>
</li>
<li><p>一个标准的线程由线程 ID、当前指令指针 PC、寄存器和堆栈组成。（每个孩子有其自身的成长轨迹）</p>
</li>
</ul>
<span id="more"></span>

<p><strong>进程与线程的区别</strong>：</p>
<ul>
<li><p>线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位。</p>
</li>
<li><p>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线。</p>
</li>
<li><p>进程之间相互独立，但 <strong> 同一进程下的各个线程之间共享程序的内存空间 </strong>（代码段、数据集、堆等）以及一些<strong> 进程级的资源</strong>（如打开文件和信号等），某进程内的线程在其他进程中不可见。</p>
</li>
<li><p><strong>线程上下文切换比进程上下文切换要快得多</strong>。</p>
</li>
</ul>
<h3 id="上下文切换"><a href="# 上下文切换" class="headerlink" title="上下文切换"></a>上下文切换 </h3><h4 id="时间片"><a href="# 时间片" class="headerlink" title="时间片"></a> 时间片 </h4><p> 多任务系统往往需要同时执行多道作业。作业数往往大于机器的 CPU 数，然而一颗 CPU 同时只能执行一项任务，如何让用户感觉这些任务正在同时进行呢? 操作系统的设计者巧妙地利用了 <strong> 时间片轮转的方式</strong>。</p>
<p><strong>时间片是 CPU 分配给各个任务（线程）的时间</strong>。</p>
<blockquote>
<p>思考：单核 CPU 为何也支持多线程呢？</p>
<p>虽然单核 CPU 只有一个物理处理单元，但它可以 <strong> 通过时间分片的方式支持多线程</strong>。在单核 CPU 中，操作系统通过时间片轮转算法将 CPU 时间划分为多个时间片段，每个时间片段分配给一个线程执行。当一个线程的时间片用完后，操作系统会暂停该线程的执行，并切换到下一个线程继续执行。这种切换是非常快速的，以至于我们感觉多个线程在同时执行。</p>
<p>需要注意的是，在单核 CPU 上并发执行的多线程是通过时间片轮转调度实现的，每个线程在任意给定的时间点上 <strong> 只能有一个 </strong> 线程在执行。而在多核 CPU 上，可以实现真正的并行执行，每个核心可以同时执行一个线程，从而提高并发性能。</p>
</blockquote>
<h4 id="上下文切换 -1"><a href="# 上下文切换 -1" class="headerlink" title="上下文切换"></a>上下文切换 </h4><p><strong> 线程上下文 </strong>：是指某一时间点 CPU <strong> 寄存器和程序计数器的内容</strong>，CPU 通过时间片分配算法来循环执行任务（线程），因为时间片非常短，所以 CPU 通过不停地切换线程执行。</p>
<p>换言之，单 CPU 这么频繁，多核 CPU 一定程度上可以减少上下文切换。</p>
<p><strong>上下文切换 </strong>：CPU 切换前把当前任务的状态保存下来（以便下次切换回这个任务时可以再次加载这个任务的状态），然后加载下一任务的状态并执行。<strong> 任务的状态保存及再加载</strong>，这段过程就叫做上下文切换。</p>
<h3 id="多线程编程"><a href="# 多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h3><ul>
<li><p>多进程模式：启动多个进程，每个进程虽然只有一个线程，但是多个进程可以一块执行多个任务。</p>
</li>
<li><p><strong>多线程模式</strong>：启动一个进程，在一个进程内启动多个线程，多个线程一起执行多个任务。</p>
</li>
<li><p>多进程 + 多线程模式：启动多个进程，每个进程再启动多个线程，这样同时执行的任务就更多了。</p>
</li>
</ul>
<p>其实创建线程之后，线程并不是始终保持一个状态的，其状态大概如下：</p>
<ol>
<li>New 创建</li>
<li>Runnable 就绪，等待调度</li>
<li>Running 运行</li>
<li>Blocked 阻塞，阻塞可能在 Wait / Locked / Sleeping 阶段</li>
<li>Dead 消亡</li>
</ol>
<p>线程有着不同的状态，也有不同的类型。大致可分为：</p>
<ul>
<li><p>主线程：主线程是程序启动时自动创建的线程，它负责执行程序的主要逻辑。主线程通常负责处理用户交互、调度其他线程的创建和管理等任务。</p>
</li>
<li><p>子线程：子线程是由主线程创建的额外线程，用于执行并发任务。子线程可以并行地执行任务，从而提高程序的效率和响应性。</p>
</li>
<li><p>守护线程（后台线程）：守护线程是一种特殊类型的线程，它在后台运行，<strong>不会阻止程序的退出</strong>。当所有的非守护线程都退出时，守护线程也会自动结束。守护线程通常用于执行一些后台任务，如日志记录、定时任务等。</p>
</li>
<li><p>前台线程：前台线程是与守护线程相对的概念，它是指 <strong> 会阻止程序退出的线程</strong>。当所有的前台线程都退出时，程序才会结束。</p>
</li>
</ul>
<h3 id="pthread 多线程"><a href="#pthread 多线程" class="headerlink" title="pthread 多线程"></a>pthread 多线程</h3><p>POSIX 线程（Pthreads）是一套标准的线程 API，用于多线程编程。该库定义了一组 C 语言函数，允许程序员创建和管理多个线程，并提供同步和互斥机制，以确保线程之间的正确协调。</p>
<p>Pthreads 库是 POSIX 标准的一部分，其全称是“Portable Operating System Interface”，旨在为 Unix-like 操作系统（如 Linux、FreeBSD、Mac OS X 等）提供一致的接口。由于该标准的广泛接受和实现，因此 Pthreads 库现在在许多不同的平台上都可用。</p>
<p>Pthreads 库的一个优点是它允许程序员创建轻量级线程（LWP），这些线程比进程更轻量级，因此在创建和销毁它们时所需的开销较小。此外，由于它是标准的 POSIX 接口，因此 Pthreads 库可在不同的操作系统上重用，从而提高了代码的可移植性。</p>
<p>pthread 库需要头文件：<code>pthread.h</code></p>
<p>gcc 编译链接参数：<code>lpthread</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc ./demo.c -o demo -lpthread</span><br></pre></td></tr></table></figure>

<h4 id="创建线程相关"><a href="# 创建线程相关" class="headerlink" title="创建线程相关"></a>创建线程相关 </h4><h5 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create"></a>pthread_create</h5><p><code>pthread_create</code> 是一个用于创建线程的函数，它的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pthread_t 类型的原型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="type">pthread_t</span>;</span><br></pre></td></tr></table></figure>

<p>该函数接收四个参数，分别是：</p>
<ol>
<li><p><code>thread</code>：一个指向线程标识符的指针，由函数创建并返回。</p>
</li>
<li><p><code>attr</code>：一个指向线程属性的指针，用于设置线程的属性。如果不需要设置属性，传入 <code>NULL</code> 即可。</p>
</li>
<li><p><code>start_routine</code>：线程执行的函数指针，该函数接受一个 <code>void *</code> 类型的参数，并返回一个 <code>void *</code> 类型的值。</p>
</li>
<li><p><code>arg</code>：传递给线程执行函数的参数，如果有多个参数，可以传递一个指向参数结构体的指针。</p>
</li>
</ol>
<p>当调用 <code>pthread_create</code> 函数时，它会创建一个新的线程，并将其标识符存储在 <code>thread</code> 指针中。新线程的执行将从 <code>start_routine</code> 函数开始，<code>arg</code>参数将作为 <code>start_routine</code> 的参数传递给它。</p>
<p>创建线程时，可以选择使用默认线程属性，也可以使用 <code>pthread_attr_t</code> 结构体来设置一些属性，例如线程的调度策略、栈大小、优先级等等。如果不需要设置属性，可以将 <code>attr</code> 参数设置为<code>NULL</code>。</p>
<p><code>pthread_create</code>函数成功时返回 0，否则返回一个错误码。如果返回非零错误码，可以使用 <code>perror</code> 函数或 <code>strerror</code> 函数打印出错误信息。</p>
<h5 id="pthread-self"><a href="#pthread-self" class="headerlink" title="pthread_self"></a>pthread_self</h5><p><code>pthread_self</code>函数返回调用它的线程的线程 ID：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<h5 id="pthread-equal"><a href="#pthread-equal" class="headerlink" title="pthread_equal"></a>pthread_equal</h5><p><code>pthread_equal</code>函数通过线程 ID 比较线程是否相等，如果两个线程相等，返回非 0 值，如果不相等，返回 0：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br></pre></td></tr></table></figure>

<h5 id="pthread-detach"><a href="#pthread-detach" class="headerlink" title="pthread_detach"></a>pthread_detach</h5><p><code>pthread_detach</code> 函数用于将指定的线程分离出去，所谓分离出去就是指 <strong> 主线程再不需要 </strong> 通过 <code>pthread_join</code> 等方式，等待该线程的结束并回收其线程控制块（TCB）的资源，<strong>被分离的线程结束后由操作系统负责其资源的回收</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>thread</code> 参数是要分离的线程的标识符，返回值为 0 表示成功，非 0 值表示出错。</p>
<p>需要注意的是，如果一个线程被分离了，就不能再对它调用 <code>pthread_join</code> 函数，否则会出错。因此，在调用 <code>pthread_detach</code> 函数之前，必须确保不会再调用 <code>pthread_join</code> 函数。</p>
<p>一般来说，主线程是要负责创建出来的子线程的资源回收工作的：</p>
<ul>
<li><p>如果主线程先于子线程退出，并且子线程没有设置为分离状态，那么子线程结束后其资源是无法得到回收的，会造成资源浪费和系统臃肿。</p>
</li>
<li><p>如果主线程先于子线程退出，但是子线程是分离状态，那么子线程退出的时候操作系统会自动回收其资源。</p>
</li>
</ul>
<p>分离线程并不是分离了之后，就跟主线程没有一点关系了。主线程退出了，分离线程还是一样退出，只是分离线程的资源是由系统回收的。</p>
<h4 id="终止线程相关"><a href="# 终止线程相关" class="headerlink" title="终止线程相关"></a>终止线程相关 </h4><p> 终止线程的三种方式：</p>
<ol>
<li><p>线程从启动例程返回，返回值就是线程的退出码；</p>
</li>
<li><p>线程可以被同一进程中的其他线程取消（通过<code>pthread_cancel()</code>）；</p>
</li>
<li><p>线程自身调用 <code>pthread_ exit()</code> 函数终止。</p>
</li>
</ol>
<h5 id="pthread-cancel"><a href="#pthread-cancel" class="headerlink" title="pthread_cancel"></a>pthread_cancel</h5><p><code>pthread_cancel</code> 函数是一个用于取消 POSIX 线程的函数。该函数向目标线程发送一个取消请求，如果该线程允许取消，则会在处理该请求时终止该线程的执行。</p>
<blockquote>
<p>线程可以设置为允许取消（默认情况下）或者禁止取消。如果线程允许取消，它将在收到取消请求后 <strong> 尽快取消</strong>，并执行一些清理工作；如果线程禁止取消，它将继续运行，直到完成其任务或者显式地调用 <code>pthread_exit</code> 函数。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure>

<p><code>pthread_cancel</code> 函数有以下两种用法：</p>
<ol>
<li><p><code>int pthread_cancel(pthread_t thread);</code> 此用法向线程 ID 为 <code>thread</code> 的线程发送取消请求。如果请求成功发送，则返回 0。如果线程 ID 无效或请求无法发送，则返回一个非零错误码。</p>
</li>
<li><p><code>void pthread_testcancel(void);</code> 此用法可以在线程执行期间调用，用于测试是否有取消请求已经发送给该线程。如果是，则在线程执行期间发生取消动作，该线程的执行将立即停止。</p>
</li>
</ol>
<p>需要注意的是，<code>pthread_cancel</code> 函数并不保证能够成功地取消目标线程的执行。当目标线程正在执行某些不可取消的操作（例如某些系统调用）时，取消请求可能会被暂时挂起，直到目标线程离开这些操作为止。另外，使用 <code>pthread_cancel</code> 函数需要注意线程同步问题，避免出现死锁等问题。</p>
<p>总的来说，<code>pthread_cancel</code> 函数可以用于线程的优雅终止，但是需要谨慎使用，避免出现意外的问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread is running...\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 在循环中调用 pthread_testcancel 函数检查是否有取消请求</span></span><br><span class="line">        pthread_testcancel();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread_id;</span><br><span class="line">    <span class="comment">// 创建一个线程并启动它</span></span><br><span class="line">    pthread_create(&amp;thread_id, <span class="literal">NULL</span>, &amp;thread_func, <span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 在主线程中调用 pthread_cancel 函数向子线程发送取消请求</span></span><br><span class="line">    pthread_cancel(thread_id);</span><br><span class="line">    <span class="comment">// 等待子线程结束</span></span><br><span class="line">    pthread_join(thread_id, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread has been canceled.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">root@fw:~/w26/ccodes# ./demo</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread has been canceled.</span><br><span class="line">root@fw:~/w26/ccodes#</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，首先创建了一个子线程并启动它，在子线程的循环中不断输出信息，同时在循环中调用 <code>pthread_testcancel</code> 函数检查是否有取消请求。在主线程中等待 5 秒钟后，调用 <code>pthread_cancel</code> 函数向子线程发送取消请求，然后等待子线程结束并输出一条信息表示子线程已经被成功取消。</p>
<p><strong>调用与不调用 <code>pthread_testcancel()</code> 的区别</strong>：</p>
<ol>
<li><p>调用 <code>pthread_testcancel</code> 函数可以让线程在循环或其他 <em> 可取消的操作中 </em> 主动检查是否有取消请求，并在检测到取消请求时 <em> 及时终止 </em> 线程的执行。这样可以增加线程的可靠性，<strong>确保线程在可以取消的时候及时响应取消请求</strong>。</p>
</li>
<li><p>如果不调用 <code>pthread_testcancel</code> 函数，线程可能会在某些不可取消的操作中被阻塞（例如在 <code>sleep</code> 等待时），无法及时响应取消请求，导致取消请求被暂时挂起。</p>
</li>
<li><p>因此，为了保证线程能够及时响应取消请求，通常建议在线程的循环或其他可取消的操作中调用 <code>pthread_testcancel</code> 函数，以便让线程在合适的时机进行取消。但是需要注意的是，在使用 <code>pthread_testcancel</code> 函数时，必须确保线程的同步操作是线程安全的，否则可能会导致程序出现不可预期的错误。</p>
</li>
<li><p>当然，在某些情况下，如果线程不会进入可取消的状态，或者线程在处理临界区时不能被取消，那么调用 <code>pthread_testcancel</code> 函数可能会导致线程被错误地取消。在这种情况下，可以通过设置线程的取消状态为 <code>PTHREAD_CANCEL_DISABLE</code> 来禁用取消操作，以避免意外的取消。</p>
</li>
</ol>
<p>总之，调用 <code>pthread_testcancel</code> 函数可以让线程更加及时地、可靠地响应取消请求，从而增加程序的安全性和稳定性，但需要注意线程同步的问题，以避免出现错误。</p>
<h5 id="pthread-exit"><a href="#pthread-exit" class="headerlink" title="pthread_exit"></a>pthread_exit</h5><p><code>pthread_exit()</code>是一个线程终止函数，它允许一个线程在它的 <strong> 任意位置退出</strong>。该函数接受一个参数，表示线程的返回值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure>

<p>调用 <code>pthread_exit()</code> 函数会立即终止当前线程的执行，并将传递的参数作为线程的返回值。如果该线程被其他线程等待，那么该返回值可以被其他线程获取。</p>
<blockquote>
<p>注意：指针 <code>retval</code> 指向的内容不能为函数中局部变量，因为一旦线程函数终止，它们将不再存在。</p>
</blockquote>
<p><code>pthread_exit()</code>函数通常在以下情况下使用：</p>
<ol>
<li><p>在线程执行完任务后，主动结束自己的执行。</p>
</li>
<li><p>当线程执行出现错误时，使用该函数退出线程。</p>
</li>
<li><p>在主线程中调用 <code>pthread_exit()</code> 函数来结束整个程序的执行。</p>
</li>
</ol>
<blockquote>
<p>注意：如果在主线程中调用了<code>pthread_exit(NULL)</code>，则主线程退出，而不是退出进程，因此如果子线程存在，会继续执行。</p>
<p>需要注意的是，当一个线程调用 <code>pthread_exit()</code> 函数后，该线程会 <strong> 立即终止，不会再执行任何其他操作 </strong>。因此，如果线程需要进行一些清理工作，比如释放内存、关闭文件等，就需要在调用<code>pthread_exit()</code> 函数之前完成这些操作。</p>
</blockquote>
<h4 id="等待线程结束"><a href="# 等待线程结束" class="headerlink" title="等待线程结束"></a>等待线程结束 </h4><h5 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join"></a>pthread_join</h5><p><code>pthread_join</code> 函数用于 <strong> 等待一个指定线程结束，并回收其占用的资源</strong>。它的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>thread</code>：要等待的线程的标识符，即线程创建时返回的 <code>pthread_t</code> 类型的值。该参数指定了需要等待的线程。</p>
</li>
<li><p><code>retval</code>：用于存储线程的返回值的指针。该参数是一个 <strong> 指向指针的指针，因为线程的返回值的类型可能是不确定的，可能是一个整型、浮点型或者指针等类型 </strong>。在<code>pthread_join</code> 函数返回时，线程的返回值将会被存储在 <code>retval</code> 所指向的内存空间中。</p>
</li>
</ol>
<p>需要注意的是，<code>retval</code>参数是可选的，如果不需要获取线程的返回值，可以将其设置为 <code>NULL</code>。另外，如果线程没有返回值，或者<strong> 在线程函数中没有显式地调用 <code>pthread_exit</code> 函数退出线程 </strong>，那么<code>retval</code> 参数将被忽略。</p>
<p>该函数会阻塞当前线程，直到指定的线程 <code>thread</code> 结束执行。具体来说，当我们调用 <code>pthread_join</code> 函数时，如果指定的线程 <code>thread</code> 还在运行中，当前线程就会被阻塞，等待该线程结束；如果线程 <code>thread</code> 已经结束了，那么 <code>pthread_join</code> 函数会立即返回，并将线程的返回值存储在 <code>retval</code> 中。此外，<code>pthread_join</code>函数会自动回收线程占用的资源，避免了资源泄露的问题。</p>
<p>以下是一个简单的示例代码，用于演示如何使用 <code>pthread_join</code> 函数等待线程结束并获取其返回值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *num = (<span class="type">int</span> *)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread is running, parameter is %d\n&quot;</span>, *num);</span><br><span class="line">    <span class="type">int</span> *res = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *res = (*num) * (*num);</span><br><span class="line">    pthread_exit((<span class="type">void</span> *)res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="type">int</span> parameter = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *result;</span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, thread_func, &amp;parameter);</span><br><span class="line">    pthread_join(thread, (<span class="type">void</span> **)&amp;result);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread returned: %d\n&quot;</span>, *result);</span><br><span class="line">    <span class="built_in">free</span>(result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果在线程函数中不调用 <code>pthread_exit</code> 函数退出线程，而是直接返回，那么该线程的返回值将是一个未定义的值，可能会导致程序出现不可预料的错误。因此，<strong>在编写多线程程序时，一定要记得在线程函数中调用 <code>pthread_exit</code> 函数退出线程</strong>。</p>
<h4 id="多线程示例"><a href="# 多线程示例" class="headerlink" title="多线程示例"></a>多线程示例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">my_thread_func</span><span class="params">(<span class="type">void</span> *pointer)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// sleep(1);</span></span><br><span class="line">        <span class="type">int</span> id = *(<span class="type">int</span> *)pointer;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread %d running, i=%d\r\n&quot;</span>, id, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(pointer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> threadId[<span class="number">5</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *arg = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*arg));</span><br><span class="line">        *arg = i;  <span class="comment">// 注意一</span></span><br><span class="line">        pthread_create(&amp;threadId[i], <span class="literal">NULL</span>, my_thread_func, (<span class="type">void</span> *)(arg));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(threadId[i], (<span class="type">void</span> **)(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread end\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于线程之间是异步执行的，因此在输出语句中的 <code>id</code> 值可能会和线程实际运行的顺序不一致，<strong>无法保证顺序执行</strong>。如果需要保证顺序执行，可以使用互斥锁来同步线程之间的执行顺序。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">root@fw:~/w26/ccodes# ./demo</span><br><span class="line">thread 0 running, k=0</span><br><span class="line">thread 2 running, k=0</span><br><span class="line">thread 2 running, k=1</span><br><span class="line">thread 0 running, k=1</span><br><span class="line">thread 1 running, k=0</span><br><span class="line">thread 1 running, k=1</span><br><span class="line">thread 2 running, k=2</span><br><span class="line">thread 1 running, k=2</span><br><span class="line">thread 3 running, k=0</span><br><span class="line">thread 3 running, k=1</span><br><span class="line">thread 3 running, k=2</span><br><span class="line">thread 4 running, k=0</span><br><span class="line">thread 4 running, k=1</span><br><span class="line">thread 4 running, k=2</span><br><span class="line">thread 0 running, k=2</span><br><span class="line">main thread end</span><br><span class="line">root@fw:~/w26/ccodes#</span><br></pre></td></tr></table></figure>

<p>对于注意一的解释：在 <code>main</code> 函数中循环创建 5 个线程时，每个线程的 <code>my_thread_func</code> 函数都被传递了指向 <code>i</code> 的指针，而 <code>i</code> 是一个 <em> 自动变量 </em>，其生命周期仅在循环内部。<strong> 由于线程的创建和调度是异步的</strong>，因此当线程实际运行时，<code>i</code> 可能已经被更新成另一个值，这会导致线程使用了错误的数据。</p>
<p>使用 <code>malloc</code> 申请临时变量来保存自动变量 <code>i</code> 的值，每个线程函数都被传递了一个指向分配的临时变量的指针，该变量保存了正确的 <code>i</code> 值。在线程函数中，使用 <code>*(int *)pointer</code> 获取 <code>i</code> 的值，并在使用完后释放该临时变量的内存空间。</p>
<blockquote>
<p>何为自动变量？</p>
</blockquote>
<p>在 C 和 C++ 等编程语言中，当在函数或代码块内部声明一个变量时，该变量默认为自动变量。自动变量具有以下特点：</p>
<ol>
<li><p>作用域：自动变量的作用域仅限于声明它的代码块内部。这意味着在声明的代码块外部是无法访问到该变量的。</p>
</li>
<li><p>存储方式：自动变量通常存储在栈（stack）上。当进入声明变量的代码块时，该变量会在栈上分配存储空间，当代码块执行完毕时，变量会自动释放所占用的栈空间。</p>
</li>
<li><p>初始化：自动变量在声明时可以选择是否进行初始化。如果未初始化，则其值是不确定的。</p>
</li>
</ol>
<p>自动变量适用于那些在局部范围内使用的临时数据和临时存储需求较小的变量。与全局变量和静态变量相比，自动变量具有更短的生命周期和更小的作用域，能够更有效地管理内存和避免命名冲突。</p>
<h4 id="多线程同步示例"><a href="# 多线程同步示例" class="headerlink" title="多线程同步示例"></a>多线程同步示例 </h4><p> 保证线程内顺序执行，可以使用互斥锁来同步线程之间的执行顺序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">my_thread_func</span><span class="params">(<span class="type">void</span> *pointer)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// sleep(1);</span></span><br><span class="line">        <span class="type">int</span> i = *(<span class="type">int</span> *)(pointer);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread %d running, k=%d\r\n&quot;</span>, i, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(pointer);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> threadId[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *arg = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*arg));</span><br><span class="line">        *arg = i;  <span class="comment">// 注意一</span></span><br><span class="line">        pthread_create(&amp;threadId[i], <span class="literal">NULL</span>, my_thread_func, (<span class="type">void</span> *)(arg));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(threadId[i], (<span class="type">void</span> **)(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread end\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">root@fw:~/w26/ccodes# ./demo</span><br><span class="line">thread 1 running, k=0</span><br><span class="line">thread 1 running, k=1</span><br><span class="line">thread 1 running, k=2</span><br><span class="line">thread 3 running, k=0</span><br><span class="line">thread 3 running, k=1</span><br><span class="line">thread 3 running, k=2</span><br><span class="line">thread 2 running, k=0</span><br><span class="line">thread 2 running, k=1</span><br><span class="line">thread 2 running, k=2</span><br><span class="line">thread 0 running, k=0</span><br><span class="line">thread 0 running, k=1</span><br><span class="line">thread 0 running, k=2</span><br><span class="line">thread 4 running, k=0</span><br><span class="line">thread 4 running, k=1</span><br><span class="line">thread 4 running, k=2</span><br><span class="line">main thread end</span><br><span class="line">root@fw:~/w26/ccodes#</span><br></pre></td></tr></table></figure>

<p>在修改后的代码中，我们使用 <code>pthread_mutex_t</code> 类型定义了一个互斥锁，并在 <code>main</code> 函数中初始化了它。在 <code>my_thread_func</code> 函数中，我们在循环前加锁（某一个线程获取了锁），循环结束后解锁（该线程释放了锁，此时其它线程可以获取锁了），以保证线程的顺序执行（先获取到锁的线程，会执行完锁之间的内容，不再会出现上面未加锁的示例中，执行到一半，便去执行其它线程的内容）。最后在 <code>main</code> 函数结束前销毁互斥锁。</p>
<hr>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>进程与线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 学习笔记</title>
    <url>/posts/230909171809.html</url>
    <content><![CDATA[<h2 id="1- 什么是 Docker？"><a href="#1- 什么是 Docker？" class="headerlink" title="1. 什么是 Docker？"></a>1. 什么是 Docker？</h2><p>Docker 是一个开源的容器化平台，用于构建、打包和部署应用程序。它允许开发人员将应用程序和它们的依赖项打包成一个轻量级、可移植的容器，然后在任何支持 Docker 的环境中运行。</p>
<h3 id="1-1-Docker 的核心概念"><a href="#1-1-Docker 的核心概念" class="headerlink" title="1.1 Docker 的核心概念"></a>1.1 Docker 的核心概念 </h3><p> 在深入学习 Docker 之前，了解以下几个核心概念是很重要的：</p>
<ul>
<li><p><strong>容器（Container）</strong>：一个 <strong> 独立 </strong> 运行的沙箱（sandboxed）应用程序实例，包含应用程序及其所有依赖项。容器是 Docker 的基本构建块，有以下特点：</p>
<ul>
<li><p>利用 <a href="https://medium.com/@saschagrunert/demystifying-containers-part-i-kernel-space-2c53d6979504">kernel namespaces and cgroups</a> 实现隔离 / 独立。</p>
</li>
<li><p>是一个可运行的镜像的实例，可以使用 DockerAPI 或 CLI 创建、开始、停止、移动、删除一个容器。</p>
</li>
<li><p>可以运行在本地机器上、虚拟机上或者部署在云上。</p>
</li>
<li><p>可移植的（能运行在任何操作系统上）。</p>
</li>
<li><p>与其它容器隔离并运行自己的软件、二进制文件和配置。</p>
</li>
</ul>
</li>
<li><p><strong>镜像（Image）</strong>：一个只读的模板，用于创建容器。镜像包含了运行应用程序所需的一切，例如代码、运行时环境、库和依赖项。</p>
</li>
<li><p><strong>仓库（Repository）</strong>：用于存储和组织 Docker 镜像的地方。可以将仓库看作是镜像的集合。</p>
</li>
<li><p><strong>Dockerfile</strong>：一个文本文件，包含了一系列命令和指令，用于从头开始构建 Docker 镜像。</p>
</li>
</ul>
<span id="more"></span>

<h3 id="1-2-Dcoker-registry"><a href="#1-2-Dcoker-registry" class="headerlink" title="1.2 Dcoker registry"></a>1.2 Dcoker registry</h3><p>Docker Registry 是用于 <strong> 存储、管理和分发 Docker 镜像的中央仓库</strong>。它允许用户将自己创建的镜像上传到仓库，或者从仓库中拉取他人创建的镜像。在 Docker 中，默认使用 Docker 官方的公共注册服务器，称为 Docker Hub。此外，还可以在本地或私有云环境中搭建自己的 Docker Registry。</p>
<p>以下是 Docker Registry 的一些重要概念：</p>
<ol>
<li><p>镜像（Image）：Docker 镜像是一个包含了应用程序、运行时环境、库和依赖的只读模板。镜像是构建和运行容器的基础。在 Docker Registry 中，镜像被存储和管理。</p>
</li>
<li><p>仓库（Repository）：仓库是包含多个镜像的集合。仓库可以用于组织和管理镜像。每个镜像都有一个唯一的标签（tag），用于标识不同版本或变体的镜像。</p>
</li>
<li><p>注册服务器（Registry Server）：注册服务器是存储和分发镜像的服务器。Docker Hub 是 Docker 官方提供的公共注册服务器。除了 Docker Hub，还可以搭建私有的注册服务器，例如 Docker 官方提供的开源项目 Docker Registry 或第三方的解决方案。</p>
</li>
<li><p>仓库名称（Repository Name）：仓库名称用于唯一标识一个仓库。它由用户名（如果是私有仓库还包括域名）、斜杠和仓库名称组成，例如 <code>username/repository</code> 或<code>domain.com/username/repository</code>。</p>
</li>
<li><p>标签（Tag）：标签用于标识仓库中的镜像的不同版本或变体。通过标签，可以区分不同的镜像，并拉取特定的版本。</p>
</li>
</ol>
<p>常见的 Docker Registry 操作包括：</p>
<ul>
<li><p>拉取镜像（Pull Image）：从注册服务器上拉取镜像到本地，以供使用或进一步构建容器。</p>
</li>
<li><p>推送镜像（Push Image）：将本地创建的镜像推送到注册服务器，以便其他人可以访问和使用。</p>
</li>
<li><p>搜索镜像（Search Image）：在注册服务器上搜索和浏览可用的镜像，以找到感兴趣的镜像。</p>
</li>
<li><p>删除镜像（Delete Image）：从注册服务器上删除不再需要的镜像，释放存储空间。</p>
</li>
</ul>
<p>使用 Docker Registry，你可以方便地共享和分发镜像，构建自己的镜像仓库，并进行版本控制和管理。无论是使用公共注册服务器还是搭建私有的注册服务器，Docker Registry 都是 Docker 生态系统中重要的组成部分之一。</p>
<blockquote>
<p>什么叫分发镜像？<br>分发镜像是指将 Docker 镜像从一个地方复制到另一个地方，以便其他用户可以访问和使用该镜像。</p>
<p>分发镜像的过程一般包括以下步骤：1）Dockerfile 构建镜像；2）打标签；3）推送到 Registry；4）拉取镜像。</p>
<p>分发镜像的好处包括：1）共享性；2）可移植性；3）版本控制：使用标签来管理镜像的不同版本，可以轻松回退到先前的版本或升级到新的版本。</p>
</blockquote>
<h2 id="2-Docker 的安装和配置"><a href="#2-Docker 的安装和配置" class="headerlink" title="2. Docker 的安装和配置"></a>2. Docker 的安装和配置 </h2><h3 id="2-1- 安装 Docker"><a href="#2-1- 安装 Docker" class="headerlink" title="2.1 安装 Docker"></a>2.1 安装 Docker</h3><p> 首先，需要安装 Docker 引擎。以下是在常见操作系统上安装 Docker 的步骤：</p>
<p><strong>Ubuntu</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install docker.io</span></span><br></pre></td></tr></table></figure>

<p><strong>Windows</strong></p>
<ol>
<li>前往 <a href="https://www.docker.com/products/docker-desktop">Docker 官方网站</a> 下载 Docker Desktop。</li>
<li>双击安装包并按照指示完成安装。可能需要更新 WSL，<strong>需要把 Windows 的更新计划打开</strong>，否则可能无法更新 WSL。</li>
</ol>
<h3 id="2-2- 配置 Docker"><a href="#2-2- 配置 Docker" class="headerlink" title="2.2 配置 Docker"></a>2.2 配置 Docker</h3><p>安装完成后，你可能需要进行一些配置。例如，你可以设置 Docker 镜像加速器以加快下载速度。以下是一个示例：</p>
<ol>
<li>打开 Docker 配置文件：</li>
</ol>
<ul>
<li><strong>Ubuntu</strong>：<code>/etc/docker/daemon.json</code></li>
<li><strong>MacOS</strong> / <strong>Windows</strong>：Docker Desktop 应用程序 &gt; Preferences &gt; Docker Engine</li>
</ul>
<ol start="2">
<li>如果文件不存在，创建它。然后，将以下内容添加到配置文件中：</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;https://your-mirror.example.com&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;insecure-registries&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>保存配置文件并重启 Docker 服务：</li>
</ol>
<ul>
<li><strong>Ubuntu</strong>：<ul>
<li><code>sudo systemctl daemon-reload</code></li>
<li><code>sudo systemctl restart docker</code></li>
</ul>
</li>
<li><strong>MacOS</strong> / <strong>Windows</strong>：在 Docker Desktop 应用程序中点击重启按钮。</li>
</ul>
<h2 id="3- 使用 Docker"><a href="#3- 使用 Docker" class="headerlink" title="3. 使用 Docker"></a>3. 使用 Docker</h2><h3 id="3-1- 运行容器"><a href="#3-1- 运行容器" class="headerlink" title="3.1 运行容器"></a>3.1 运行容器 </h3><p> 要运行一个容器，首先需要一个 Docker 镜像。可以从 Docker 仓库中获取现有的镜像，或者自己创建一个。以下是一个运行基于 Ubuntu 的容器的示例：</p>
<ol>
<li>拉取 Ubuntu 镜像：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker pull ubuntu</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>运行容器：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -it ubuntu /bin/bash</span></span><br></pre></td></tr></table></figure>

<p>这将以交互式终端的方式在 Ubuntu 容器中运行一个 bash shell。你可以在容器中执行任意命令。</p>
<ol start="3">
<li>退出容器：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">exit</span></span></span><br></pre></td></tr></table></figure>

<h3 id="3-2- 构建自定义镜像"><a href="#3-2- 构建自定义镜像" class="headerlink" title="3.2 构建自定义镜像"></a>3.2 构建自定义镜像 </h3><p> 使用 Dockerfile 可以构建自定义的 Docker 镜像。以下是一个简单的示例：</p>
<ol>
<li><p>创建一个新目录，例如 <code>myapp</code>，并在其中创建一个名为<code>Dockerfile</code> 的文件。</p>
</li>
<li><p>在 <code>Dockerfile</code> 中添加以下内容：</p>
</li>
</ol>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用较小的基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 维护者信息</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=<span class="string">&quot;Your Name &lt;your.email@example.com&gt;&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Vim 编辑器</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get install -y vim &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get clean &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装所需的软件包, 将多个 RUN 指令合并为一个（减小 image 的体积）</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install --no-cache-dir --upgrade pip setuptools wheel &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    pip install --no-cache-dir \</span></span><br><span class="line"><span class="language-bash">    langchain==0.0.162 \</span></span><br><span class="line"><span class="language-bash">    openai \</span></span><br><span class="line"><span class="language-bash">    fastapi \</span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地项目文件复制到容器中</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./ /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> ENV_VARIABLE_NAME=value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;/app/src/main.py&quot;</span>, <span class="string">&quot;--extra-arg&quot;</span>, <span class="string">&quot;value&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>以上示例使用了 python 作为基础镜像，并在容器中安装了一些软件包，设置了工作目录，复制了本地文件，并设置了环境变量和默认运行命令。</p>
<ol start="3">
<li>在 <code>Dockerfile</code> 所在的目录中打开终端，并构建镜像：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker build -t aigc/plugins:v1.0.0 .</span></span><br></pre></td></tr></table></figure>

<p>这将使用 <code>Dockerfile</code> 创建一个名为 <code>aigc/plugins</code> 的镜像，版本号为<code>v1.0.0</code>。</p>
<ol start="4">
<li>运行容器：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --restart=always -d --name aigc_plugins -p 8385:8385 \</span></span><br><span class="line"><span class="language-bash">    -v /home/aigc/mount/plugins/data/store:/app/store \</span></span><br><span class="line"><span class="language-bash">    -v /home/aigc/mount/plugins/data/cfg:/app/cfg aigc/plugins:v1.0.0 python /app/src/main.py \</span></span><br><span class="line"><span class="language-bash">    --ip 0.0.0.0 --port 8385 --url http://0.0.0.0:8383/v1/completions</span></span><br></pre></td></tr></table></figure>

<p>现在你可以在自定义镜像的容器中运行你的应用程序。</p>
<ol start="5">
<li>进入容器：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> -it aigc_plugins bash</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>删除容器：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">rm</span> -f aigc_plugins</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">rm</span> -f &lt;container-id&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>查看容器运行的日志，并保存到文件中：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker logs -f aigc_plugins | <span class="built_in">tee</span> -a aigc_plugins_logs.txt</span></span><br></pre></td></tr></table></figure>

<ol start="8">
<li>打包保存镜像：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker save -o aigc_plugins.tar aigc/plugins:v1.0.0</span></span><br></pre></td></tr></table></figure>

<ol start="9">
<li>加载本地镜像包：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker load -i aigc_plugins.tar</span></span><br></pre></td></tr></table></figure>

<h2 id="4-Docker-Volumes 与 Mount"><a href="#4-Docker-Volumes 与 Mount" class="headerlink" title="4. Docker Volumes 与 Mount"></a>4. Docker Volumes 与 Mount</h2><p>Docker Volumes（卷）是 Docker 中用于 <strong> 持久化数据 </strong> 的一种机制，它允许将主机上的目录或文件与容器内的路径进行映射，从而实现数据在容器和主机之间的共享和持久化存储。</p>
<h3 id="4-1- 创建 -Volume"><a href="#4-1- 创建 -Volume" class="headerlink" title="4.1 创建 Volume"></a>4.1 创建 Volume</h3><p>使用 <code>docker volume create</code> 命令可以创建一个新的 Volume。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume create my-volume</span></span><br></pre></td></tr></table></figure>

<p>上述命令将创建一个名为 <code>my-volume</code> 的新 Volume。Docker 会在宿主机的默认 Volume 存储位置上创建一个目录，用于保存 Volume 的数据。</p>
<blockquote>
<p>Where is Docker storing my data when I use a volume?</p>
</blockquote>
<p>使用 <code>docker volume inspect</code> 命令查看 Volume 存储位置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume inspect my-volume</span></span><br></pre></td></tr></table></figure>

<p>接着，你将看到如下信息：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;CreatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021-06-01T16:18:36Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Labels&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Mountpoint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/volumes/my-volume/_data&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my-volume&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p>Mountpoint 是数据在磁盘上的实际位置。请注意，在大多数机器上，您需要具有根访问权限才能从主机访问此目录。但是，这就是它所在的位置。</p>
</blockquote>
<h3 id="4-2- 容器中使用 -Volume"><a href="#4-2- 容器中使用 -Volume" class="headerlink" title="4.2 容器中使用 Volume"></a>4.2 容器中使用 Volume</h3><p>在运行容器时，可以使用 <code>-v</code> 或 <code>--mount</code> 参数将 Volume 挂载到容器内的路径上。</p>
<h4 id="4-2-1-v 参数卷挂载"><a href="#4-2-1-v 参数卷挂载" class="headerlink" title="4.2.1 -v 参数卷挂载"></a>4.2.1 -v 参数卷挂载</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d -v my-volume:/path/in/container my-image</span></span><br></pre></td></tr></table></figure>

<p>上述命令将创建一个基于 <code>my-image</code> 镜像的容器，并将名为 <code>my-volume</code> 的 Volume 挂载到容器内的 <code>/path/in/container</code> 路径上。</p>
<h4 id="4-2-2-–mount 参数卷挂载"><a href="#4-2-2-–mount 参数卷挂载" class="headerlink" title="4.2.2 –mount 参数卷挂载"></a>4.2.2 –mount 参数卷挂载 </h4><p> 使用 <code>--mount</code> 参数可以更细粒度地配置容器中的 Volume 挂载。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d --mount <span class="built_in">type</span>=volume,<span class="built_in">source</span>=my-volume,target=/path/in/container my-image</span></span><br></pre></td></tr></table></figure>

<p>在上述命令中，我们使用了 <code>--mount</code> 参数来指定挂载的类型和配置。<code>type=volume</code> 表示挂载类型为 Volume，<code>source=my-volume</code> 指定了要挂载的 Volume 的名称为 <code>my-volume</code>，<code>target=/path/in/container</code> 指定了挂载到容器内的路径为 <code>/path/in/container</code>。</p>
<p>除了指定挂载类型、Volume 名称和路径外，<code>--mount</code> 参数还可以接受其他选项，例如读写权限、文件系统类型等。下面是一个更详细的示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d --mount <span class="built_in">type</span>=volume,<span class="built_in">source</span>=my-volume,target=/path/in/container,ro,volume-opt=option=value my-image</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们添加了一些额外的选项。<code>ro</code> 表示将 Volume 挂载为只读（read-only），<code>volume-opt=option=value</code> 表示指定了额外的 Volume 选项。你可以根据需要使用适当的选项来满足挂载的要求。</p>
<p>使用 <code>--mount</code> 参数进行 Volume 挂载可以提供更多的灵活性和配置选项，例如指定挂载类型、读写权限、Volume 选项等。这使得我们能够更好地控制容器与 Volume 之间的数据交互。</p>
<h3 id="4-3- 挂载主机目录作为 -Volume"><a href="#4-3- 挂载主机目录作为 -Volume" class="headerlink" title="4.3 挂载主机目录作为 Volume"></a>4.3 挂载主机目录作为 Volume</h3><p>除了使用命名 Volume，还可以直接将主机上的目录或文件挂载为 Volume，即 <strong> 绑定挂载（Bind mounts）</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d -v /path/on/host:/path/in/container my-image</span></span><br></pre></td></tr></table></figure>

<p>上述命令将主机上的 <code>/path/on/host</code> 目录挂载到容器内的 <code>/path/in/container</code> 路径上。</p>
<blockquote>
<p>绑定挂载（Bind mounts）允许将主机文件系统上的特定路径直接挂载到容器内的路径上。<br>卷挂载（Volume mounts）通过使用 Docker 卷 (Volume) 将容器内的路径与主机上的路径进行关联。</p>
</blockquote>
<h3 id="4-4- 查看 -Volume"><a href="#4-4- 查看 -Volume" class="headerlink" title="4.4 查看 Volume"></a>4.4 查看 Volume</h3><p>使用 <code>docker volume ls</code> 命令可以列出所有已创建的 Volumes。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume <span class="built_in">ls</span></span></span><br></pre></td></tr></table></figure>

<p>上述命令将显示所有已创建的 Volumes 的列表，包括它们的名称和所在的路径。</p>
<h3 id="4-5- 删除 -Volume"><a href="#4-5- 删除 -Volume" class="headerlink" title="4.5 删除 Volume"></a>4.5 删除 Volume</h3><p>要删除一个不再需要的 Volume，可以使用 <code>docker volume rm</code> 命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume <span class="built_in">rm</span> my-volume</span></span><br></pre></td></tr></table></figure>

<p>上述命令将删除名为 <code>my-volume</code> 的 Volume。请注意，只有在没有任何容器使用该 Volume 时，才能成功删除。</p>
<h3 id="4-6-Volume-Mounts-Vs-Bind-Mounts"><a href="#4-6-Volume-Mounts-Vs-Bind-Mounts" class="headerlink" title="4.6 Volume Mounts Vs Bind Mounts"></a>4.6 Volume Mounts Vs Bind Mounts</h3><h4 id="4-6-1-Volume-Mounts 的特性"><a href="#4-6-1-Volume-Mounts 的特性" class="headerlink" title="4.6.1 Volume Mounts 的特性"></a>4.6.1 Volume Mounts 的特性 </h4><p> 卷挂载通过使用 Docker 卷 (Volume) 将容器内的路径与主机上的路径进行关联。Docker 卷是一种特殊的目录，用于存储容器中的数据。卷挂载具有以下特点：</p>
<ul>
<li><p><strong>主机位置</strong>：Docker 选择卷的主机位置，通常在宿主机上的特定目录中。</p>
</li>
<li><p><strong>数据持久化</strong>：Volume 提供了一种持久化存储数据的方式。即使容器被删除或重新创建，Volume 中的数据仍然保持不变。</p>
</li>
<li><p><strong>容器间数据共享</strong>：多个容器可以共享同一个 Volume，使得它们可以轻松地共享数据。</p>
</li>
<li><p><strong>与主机文件系统交互</strong>：通过将主机上的目录挂载为 Volume，容器可以访问主机的文件系统，方便与容器之外的环境交互。</p>
</li>
<li><p><strong>备份和迁移</strong>：使用 Volumes 可以方便地备份和迁移容器的数据，通过备份或迁移 Volume，可以快速复制或迁移整个容器的数据。</p>
</li>
<li><p><strong>卷驱动程序支持</strong>：卷挂载支持使用不同的卷驱动程序，例如本地主机文件系统、网络存储或其他存储后端。</p>
</li>
</ul>
<h4 id="4-6-2-Bind-Mounts 的特性"><a href="#4-6-2-Bind-Mounts 的特性" class="headerlink" title="4.6.2 Bind Mounts 的特性"></a>4.6.2 Bind Mounts 的特性 </h4><p> 绑定挂载允许将主机文件系统上的特定路径直接挂载到容器内的路径上。绑定挂载具有以下特点：</p>
<ul>
<li><p><strong>主机位置</strong>：您可以自行选择要挂载的主机路径，它可以是任何主机上的目录或文件。</p>
</li>
<li><p><strong>与主机文件系统实时同步</strong>：容器中的更改会实时反映在绑定挂载的主机路径上，反之亦然。</p>
</li>
<li><p><strong>灵活性</strong>：绑定挂载允许容器与宿主机之间进行更紧密的交互，方便开发人员对文件进行编辑、调试或测试。</p>
</li>
<li><p><strong>支持权限和访问控制</strong>：绑定挂载可以继承主机文件系统的权限设置，以控制容器对文件的读写权限。</p>
</li>
</ul>
<h4 id="4-6-3- 选择使用卷挂载还是绑定挂载"><a href="#4-6-3- 选择使用卷挂载还是绑定挂载" class="headerlink" title="4.6.3 选择使用卷挂载还是绑定挂载"></a>4.6.3 选择使用卷挂载还是绑定挂载</h4><table>
<thead>
<tr>
<th></th>
<th>命名卷 (Named Volumes)</th>
<th>绑定挂载 (Bind Mounts)</th>
</tr>
</thead>
<tbody><tr>
<td>主机位置</td>
<td>由 Docker 选择</td>
<td>由您决定</td>
</tr>
<tr>
<td>挂载示例 (使用 <code>--mount</code>)</td>
<td><code>type=volume,src=my-volume,target=/usr/local/data</code></td>
<td><code>type=bind,src=/path/to/data,target=/usr/local/data</code></td>
</tr>
<tr>
<td>容器内容填充新卷</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>支持卷驱动程序</td>
<td>是</td>
<td>否</td>
</tr>
</tbody></table>
<p>在选择使用卷挂载还是绑定挂载时，可以根据具体需求和场景来进行决策：</p>
<ul>
<li><p>如果需要数据持久性、跨容器共享和卷驱动程序支持，则应选择卷挂载。</p>
</li>
<li><p>如果需要与主机文件系统实时同步、灵活的文件访问和交互，则应选择绑定挂载。</p>
</li>
</ul>
<p>在实际应用中，根据不同的需求，卷挂载和绑定挂载可以结合使用，以满足容器与主机之间数据共享和交互的需求。</p>
<blockquote>
<p>容器内容填充新卷是指在使用卷挂载（Volume Mounts）时，如果目标卷是新创建的并且为空（即没有初始数据），<strong>容器启动时会将容器内的内容填充到新创建的卷中</strong>。</p>
<p>这意味着，如果使用一个新的、空的卷挂载到容器内的路径上，并且容器内的路径中有预先存在的数据，那么在容器启动时，这些数据会被复制到新的卷中，以便卷中具有与容器内部相同的初始数据。这样可以确保在容器重新创建或迁移时，新创建的卷具有与原始容器相同的初始状态。</p>
</blockquote>
<h2 id="5-Container-networking"><a href="#5-Container-networking" class="headerlink" title="5. Container networking"></a>5. Container networking</h2><blockquote>
<p>请记住，默认情况下，容器是独立运行的，对同一台机器上的其他进程或容器一无所知。那么，如何让一个容器与另一个容器通信呢？答案是网络（network）。如果将两个容器放在同一个网络上，它们就可以相互通信。</p>
</blockquote>
<h3 id="5-1- 容器网络特性"><a href="#5-1- 容器网络特性" class="headerlink" title="5.1 容器网络特性"></a>5.1 容器网络特性 </h3><p> 容器网络是 Docker 中一个重要的概念，它允许 <strong> 在容器之间建立网络连接和通信</strong>。通过容器网络，可以实现容器间的数据传输、服务发现和跨主机的容器通信等功能。以下是容器网络的一些关键点和特性：</p>
<ul>
<li><p><strong>网络命名空间 (Network Namespace)</strong>：每个容器都有自己独立的网络命名空间，使得容器可以拥有自己的网络栈，包括网络接口、IP 地址和路由表等。这样可以实现容器之间的网络隔离，避免网络冲突和干扰。</p>
</li>
<li><p><strong>虚拟以太网桥 (Virtual Ethernet Bridge)</strong>：Docker 使用虚拟以太网桥来连接容器和宿主机的网络。每个宿主机上的 Docker 守护进程会创建一个名为 docker0 的桥接接口，<strong>通过该接口与容器的网络命名空间相连</strong>。</p>
</li>
<li><p><strong>网络驱动程序 (Network Drivers)</strong>：Docker 提供了多种网络驱动程序，用于实现不同的网络功能和配置选项。默认情况下，Docker 使用桥接网络驱动程序 (Bridge Network Driver)，但还支持其他驱动程序，如 Overlay、Host、Macvlan 等，以满足不同的网络需求。</p>
</li>
<li><p><strong>容器间通信 </strong>：容器可以通过使用网络连接和端口来实现相互通信。<strong> 可以使用容器的 IP 地址、端口号或容器名称来访问其他容器上的服务</strong>。容器网络还支持多个容器共享同一个网络端口的负载均衡和服务发现功能。</p>
</li>
<li><p><strong>跨主机容器通信</strong>：通过使用网络驱动程序中的 Overlay 网络模式，可以在多个主机上创建一个虚拟网络，使得不同主机上的容器可以直接通信。这为构建分布式应用和容器编排平台（如 Docker Swarm 和 Kubernetes）提供了基础。</p>
</li>
<li><p><strong>外部网络访问</strong>：容器可以通过端口映射 (Port Mapping) 的方式将容器内部的服务暴露给外部网络。通过将容器的特定端口映射到宿主机上的端口，可以使得外部网络能够访问容器中的应用程序或服务。</p>
</li>
</ul>
<p>容器网络是 Docker 中实现容器间通信和与外部网络交互的重要机制。通过灵活配置和管理容器网络，可以构建具有高可用性、可伸缩性和弹性的容器化应用程序。</p>
<h3 id="5-2- 容器网络实践命令"><a href="#5-2- 容器网络实践命令" class="headerlink" title="5.2 容器网络实践命令"></a>5.2 容器网络实践命令 </h3><h4 id="5-2-1- 创建自定义容器网络"><a href="#5-2-1- 创建自定义容器网络" class="headerlink" title="5.2.1 创建自定义容器网络"></a>5.2.1 创建自定义容器网络</h4><p> 使用 <code>docker network create</code> 命令可以创建自定义的 Docker 网络。例如，创建一个名为 <code>my-network</code> 的自定义网络：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker network create my-network</span></span><br></pre></td></tr></table></figure>

<p>这将在 Docker 中创建一个新的网络，供容器使用。</p>
<h4 id="5-2-2- 运行容器并连接到网络"><a href="#5-2-2- 运行容器并连接到网络" class="headerlink" title="5.2.2 运行容器并连接到网络"></a>5.2.2 运行容器并连接到网络 </h4><p> 在创建容器时，可以使用 <code>--network</code> 参数将容器连接到指定的网络。例如，将一个容器连接到 <code>my-network</code> 网络：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --network my-network my-image</span></span><br></pre></td></tr></table></figure>

<p>这将在启动容器时将其连接到 <code>my-network</code> 网络，使得容器可以与该网络中的其他容器进行通信。</p>
<h4 id="5-2-3- 查看容器网络信息"><a href="#5-2-3- 查看容器网络信息" class="headerlink" title="5.2.3 查看容器网络信息"></a>5.2.3 查看容器网络信息 </h4><p> 使用 <code>docker network inspect</code> 命令可以查看特定网络的详细信息。例如，查看名为 <code>my-network</code> 的网络信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker network inspect my-network</span></span><br></pre></td></tr></table></figure>

<p> 这将显示与 <code>my-network</code> 相关的网络配置和容器列表等信息。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my-network&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;000f5e28bfcafa18622593e04dba1bc70c1bc9480a055c0a0bb2b8ec13039138&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Created&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-06-01T22:51:27.366486209-04:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bridge&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;EnableIPv6&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;IPAM&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;default&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Config&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;Subnet&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.18.0.0/16&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;Gateway&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.18.0.1&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Internal&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Attachable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Ingress&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ConfigFrom&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Network&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ConfigOnly&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Containers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Labels&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h4 id="5-2-4- 容器间通信"><a href="#5-2-4- 容器间通信" class="headerlink" title="5.2.4 容器间通信"></a>5.2.4 容器间通信 </h4><p> 容器可以通过使用容器名称或 IP 地址进行互相通信。例如，通过容器名称进行通信：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --name container1 --network my-network my-image</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --name container2 --network my-network my-image</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>container1</code> 和 <code>container2</code> 这两个容器可以通过彼此的名称进行通信。例如，通过 <code>ping</code> 命令测试容器之间的连通性：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> container1 ping container2</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>container1</code> 容器使用 <code>ping container2</code> 的命令来 ping <code>container2</code> 容器。由于容器名称在容器网络中被解析为相应容器的 IP 地址，因此可以直接使用容器名称来实现容器间的通信。</p>
<blockquote>
<p>通过使用容器名称进行通信，可以减少对容器 IP 地址的依赖，提高容器间通信的灵活性。注意，容器名称必须在同一网络中才能相互解析，因此需要将容器都连接到同一个网络中。</p>
</blockquote>
<h4 id="5-2-5- 端口映射"><a href="#5-2-5- 端口映射" class="headerlink" title="5.2.5 端口映射"></a>5.2.5 端口映射 </h4><p> 使用 <code>-p</code> 参数可以将容器内的端口映射到宿主机上，以使得外部网络可以访问容器中的服务。例如，将容器的 8080 端口映射到宿主机的 80 端口：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -p 80:8080 my-image</span></span><br></pre></td></tr></table></figure>

<p>这将使得宿主机上的 80 端口转发到容器内的 8080 端口，从而允许外部网络通过宿主机的 80 端口访问容器中的服务。</p>
<p>以上是一些与容器网络相关的实践命令和示例。通过灵活运用这些命令，可以有效管理和配置容器网络，实现容器间的通信和与外部网络的交互。</p>
<h2 id="6-Docker-Compose"><a href="#6-Docker-Compose" class="headerlink" title="6. Docker Compose"></a>6. Docker Compose</h2><p>Docker Compose 是一个用于定义和运行 <strong> 多个容器 </strong> 的工具。它使用一个 <code>docker-compose.yml</code> 文件来配置应用程序的服务、网络和卷。以下是一个示例：</p>
<ol>
<li>创建一个名为 <code>docker-compose.yml</code> 的文件，并在其中定义服务：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.9&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">aigc/plugins:v1.0.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">aigc_plugins</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my_network</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">python</span> <span class="string">/app/src/main.py</span> </span><br><span class="line">        <span class="string">--ip</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> </span><br><span class="line">        <span class="string">--port</span> <span class="number">8385</span> </span><br><span class="line">        <span class="string">--url</span> <span class="string">http://0.0.0.0:8383/v1/completions</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8385</span><span class="string">:8385</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/aigc/mount/plugins/data/store:/app/store</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/aigc/mount/plugins/data/cfg:/app/cfg</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">cpus:</span> <span class="string">&quot;0.5&quot;</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">1024M</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">my_network:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">plugins_net</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure>

<p>以上示例定义了一个名为 <code>plugins</code> 的服务，使用当前目录中的 <code>Dockerfile</code> 构建镜像。它将主机的 <code>8385</code> 端口映射到容器的 <code>8385</code> 端口，并将本地的 <code>./</code> 目录挂载到容器的 <code>/app</code> 目录，还设置了一个环境变量。</p>
<ol start="2">
<li>在包含 <code>docker-compose.yml</code> 文件的目录中打开终端，并运行服务：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker-compose up</span></span><br></pre></td></tr></table></figure>

<p>Docker Compose 将自动构建镜像并运行服务。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter10.2 经典同步问题</title>
    <url>/posts/240205182643.html</url>
    <content><![CDATA[<p>本文介绍经典同步问题，包括读者 - 写者问题（涉及读者优先、写者优先的信号量方式实现与管程方式实现），以及哲学家就餐问题。</p>
<span id="more"></span>

<h1 id="读者 - 写者问题"><a href="# 读者 - 写者问题" class="headerlink" title="读者 - 写者问题"></a>读者 - 写者问题 </h1><p> 读者 - 写者问题的 <strong> 动机：对共享数据的访问</strong>，即读者想要读取共享空间中的数据，而写者想要往共享空间中写入数据，这就需要合理安排读者和写者的访问时机，否则就会出现数据错误问题。</p>
<p>这其中有两种不同角色的使用者：</p>
<ul>
<li>读者：不修改数据、仅仅读取数据；</li>
<li>写者：读取数据并写入（修改）数据。</li>
</ul>
<p>问题的约束（对共享数据访问的前提条件）：</p>
<ol>
<li>允许同一时刻有多个读者，但在任意时刻最多只有一个写者；</li>
<li>当没有写者时，读者才能访问数据；</li>
<li>当没有读者和写者时，写者才能访问数据；</li>
<li>在任何时候只有一个线程可以操作共享变量。</li>
</ol>
<p>涉及的共享数据、变量有哪些？</p>
<ul>
<li>共享数据集；</li>
<li>读者计数器 <code>ReaderCount</code>（初始化为 0）；</li>
<li>写者访问控制信号量 <code>WriteMutex</code>（初始化为 1）——在任意时刻最多只有一个写者，故初始化值必须为 1。</li>
<li>读者计数器访问控制信号量 <code>CountMutex</code>（初始化为 1）——这里初始化为 1，可以实现多个读者同时读取共享数据集，原因是 <code>WriteMutex</code> 和 <code>CountMutex</code> <strong>一个数对共享数据执行写入的互斥访问，另一个是对读者计数器的互斥访问，而不是对读取共享数据集的互斥访问</strong>，所以可以实现多个读者同时读取共享数据集。（具体看后续代码实现）</li>
</ul>
<h2 id="信号量方式实现读者优先"><a href="# 信号量方式实现读者优先" class="headerlink" title="信号量方式实现读者优先"></a>信号量方式实现读者优先 </h2><h3 id="何为读者优先"><a href="# 何为读者优先" class="headerlink" title="何为读者优先"></a> 何为读者优先 </h3><p> 何为读者优先？</p>
<p>只要有一个读者处于活跃状态（正在读取共享数据），后来的读者都会被接纳（允许其读取数据），即使这些读者是在正在等待的写者之后到来的，也会优先让这些读者读取数据。如果读者源源不断的出现，那么写者始终处于阻塞状态。</p>
<h3 id="共享变量定义"><a href="# 共享变量定义" class="headerlink" title="共享变量定义"></a>共享变量定义 </h3><p> 定义并初始化上述共享变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ReaderCount = <span class="number">0</span>; <span class="comment">// 读者计数器</span></span><br><span class="line"><span class="type">sem_t</span> WriteMutex; <span class="comment">// 写者访问控制信号量</span></span><br><span class="line"><span class="type">sem_t</span> CountMutex;  <span class="comment">// 读者计数器访问控制信号量，是! 计数器!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line">sem_init(&amp;WriteMutex, <span class="number">0</span>, <span class="number">1</span>);  <span class="comment">// 第二个参数是用于控制信号量的线程间共享</span></span><br><span class="line">sem_init(&amp;CountMutex, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="写者线程处理"><a href="# 写者线程处理" class="headerlink" title="写者线程处理"></a>写者线程处理</h3><p>Writer 写者线程处理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">writer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    sem_wait(&amp;WriteMutex);</span><br><span class="line">    write();  <span class="comment">// 写操作</span></span><br><span class="line">    sem_post(&amp;WriteMutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li>在写者线程中，当 <code>WriteMutex</code> 信号量为 1 时，执行 P 操作后 <code>WriteMutex &gt;=0</code>，不会触发等待；</li>
<li>若此时再来一个写者，执行 P 操作后，<code>WriteMutex &lt; 0</code>，会进行等待。直到持有信号量的写者，执行 V 操作后，唤醒一个等待的写者线程。</li>
</ul>
<h3 id="读者线程处理"><a href="# 读者线程处理" class="headerlink" title="读者线程处理"></a>读者线程处理</h3><p>Reader 读者线程处理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">reader</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    sem_wait(&amp;CountMutex);</span><br><span class="line">    <span class="keyword">if</span> (ReaderCount == <span class="number">0</span>) &#123;</span><br><span class="line">        sem_wait(&amp;WriteMutex);</span><br><span class="line">    &#125;</span><br><span class="line">    ReaderCount++;</span><br><span class="line">    sem_post(&amp;CountMutex);</span><br><span class="line"></span><br><span class="line">    read();  <span class="comment">// 读操作</span></span><br><span class="line"></span><br><span class="line">    sem_wait(&amp;CountMutex);</span><br><span class="line">    ReaderCount--;</span><br><span class="line">    <span class="keyword">if</span> (ReaderCount == <span class="number">0</span>) &#123;</span><br><span class="line">        sem_post(&amp;WriteMutex);</span><br><span class="line">    &#125;</span><br><span class="line">    sem_post(&amp;CountMutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li>在读者线程中，首先通过 <code>sem_wait(&amp;CountMutex)</code> 等待，获取读者计数器访问控制信号量，如果 <code>ReaderCount</code> 的值为 0，<strong>意味着第一个读者进入</strong>，需要通过 <code>sem_wait(&amp;WriteMutex)</code> 获取写者访问控制信号量（这样，如果后续来了写者线程，就会进入等待），避免写者同时存在。</li>
<li>接下来，释放读者计数器访问控制信号量 <code>sem_post(&amp;CountMutex)</code>（以使得后续读者能够进入），进行读操作。</li>
<li>最后，再次获取读者计数器访问控制信号量，减少读者计数器 <code>ReaderCount</code>，如果 <code>ReaderCount</code> 的值为 0，<strong>意味着没有读者了</strong>，需要通过 <code>sem_post(&amp;WriteMutex)</code> 释放写者访问控制信号量。</li>
</ul>
<p>为什么一个读者线程中，涉及了两对关于 <code>CountMutex</code> 的 <code>sem_wait</code> 等待和 <code>sem_post</code> 释放呢？</p>
<p>这是因为，读者计数器 <code>ReaderCount</code> 是一个共享变量，在一个读者进入或退出时，需要修改 <code>ReaderCount</code> 的值，这要保证对该变量的互斥访问，防止数据错误。</p>
<h2 id="管程方式实现写者优先"><a href="# 管程方式实现写者优先" class="headerlink" title="管程方式实现写者优先"></a>管程方式实现写者优先 </h2><h3 id="何为写者优先"><a href="# 何为写者优先" class="headerlink" title="何为写者优先"></a> 何为写者优先 </h3><p> 何为写者优先？</p>
<p>只要有一个写者处于活跃状态，后来的写者都会被接纳，即使这些写者是在正在等待的读者之后到来的，也会优先让这些写者写入数据。如果写者源源不断的出现，那么读者始终处于阻塞状态。</p>
<h3 id="伪代码"><a href="# 伪代码" class="headerlink" title="伪代码"></a>伪代码 </h3><p> 读者写者问题的写者优先可以抽象为两个方法：</p>
<ul>
<li>读者线程：等待没有写者 -&gt; 读取数据集 -&gt; 检查：唤醒等待的写者；</li>
<li>写者线程：等待没有读者、写者 -&gt; 往数据集写入数据 -&gt; 检查：唤醒等待的读者或写者。</li>
</ul>
<img src="../images/os-kernel/chapter10/writer-priority-monitor.png" alt="管程方式实现写者优先" width="80%" height="80%">

<h3 id="管程方式实现"><a href="# 管程方式实现" class="headerlink" title="管程方式实现"></a>管程方式实现 </h3><h4 id="共享变量定义 -1"><a href="# 共享变量定义 -1" class="headerlink" title="共享变量定义"></a> 共享变量定义</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> AR = <span class="number">0</span>;  <span class="comment">// active reader</span></span><br><span class="line"><span class="type">int</span> AW = <span class="number">0</span>;  <span class="comment">// active writer</span></span><br><span class="line"><span class="type">int</span> WR = <span class="number">0</span>;  <span class="comment">// waiting reader</span></span><br><span class="line"><span class="type">int</span> WW = <span class="number">0</span>;  <span class="comment">// waiting writer</span></span><br><span class="line"></span><br><span class="line">Condition okToRead;</span><br><span class="line">Condition okToWrite;</span><br><span class="line">Lock lock;</span><br></pre></td></tr></table></figure>

<h4 id="读者线程实现"><a href="# 读者线程实现" class="headerlink" title="读者线程实现"></a>读者线程实现</h4><img src="../images/os-kernel/chapter10/writer-priority-reader-thread.png" alt="读者线程实现" width="80%" height="80%">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读者读取数据（就像上面的伪代码）：等待没有写者 -&gt; 读取数据集 -&gt; 检查：唤醒等待的写者 -&gt; 退出</span></span><br><span class="line"><span class="function">Public <span class="title">Database::Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// wait until no writers;</span></span><br><span class="line">    <span class="built_in">StartRead</span>();</span><br><span class="line">    read database;</span><br><span class="line">    <span class="comment">// check out - wake up waiting writers;</span></span><br><span class="line">    <span class="built_in">DoneRead</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管程方式实现：等待没有写者后，读者开始读取</span></span><br><span class="line"><span class="function">Private <span class="title">Database::StartRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.<span class="built_in">Acquire</span>();</span><br><span class="line">    <span class="keyword">while</span> (AW + WW &gt; <span class="number">0</span>) &#123;  <span class="comment">/* 体现写者优先的细节 1 */</span></span><br><span class="line">        WR++;</span><br><span class="line">        okToRead.<span class="built_in">wait</span>(&amp;lock);</span><br><span class="line">        WR--</span><br><span class="line">    &#125;</span><br><span class="line">    AR++;</span><br><span class="line">    lock.<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管程方式实现：读者退出</span></span><br><span class="line"><span class="function">Private <span class="title">Database::DoneRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.<span class="built_in">Acquire</span>();</span><br><span class="line">    AR--;</span><br><span class="line">    <span class="comment">// 在没有活跃的读者时，才有可能唤醒写者</span></span><br><span class="line">    <span class="keyword">if</span> (AR == <span class="number">0</span> &amp;&amp; WW &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        okToWrite.<span class="built_in">signal</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    lock.<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>体现写者优先的细节 1：只要有写者，别管是活跃的、还是等待的，写者就得等待。</li>
</ul>
<p>在 <code>DoneRead()</code> 中，为什么有活跃的读者时，不能唤醒写者？不是写者优先吗？</p>
<p>因为，有活跃的读者，表明读者正在读取数据，这时若唤醒写者写入（修改数据），会出现数据错误。虽然是写者优先，但优先的前提是写者 <strong> 正在占据</strong> database，这时后来的读者、写者，才会优先写者。</p>
<h4 id="写者线程实现"><a href="# 写者线程实现" class="headerlink" title="写者线程实现"></a>写者线程实现</h4><img src="../images/os-kernel/chapter10/writer-priority-writer-thread.png" alt="读者线程实现" width="80%" height="80%">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写者写入数据（就像上面的伪代码）：等待没有读者、写者 -&gt; 往数据集写入数据 -&gt; 检查：唤醒等待的读者或写者</span></span><br><span class="line"><span class="function">Public <span class="title">Database::Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// wait until no readers/writers;</span></span><br><span class="line">    <span class="built_in">StartWrite</span>();</span><br><span class="line">    write database;</span><br><span class="line">    <span class="comment">// check out - wake up waiting a write/all readers;</span></span><br><span class="line">    <span class="built_in">DoneWrite</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管程方式实现：等待没有写者后，读者开始读取</span></span><br><span class="line"><span class="function">Private <span class="title">Database::StartWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.<span class="built_in">Acquire</span>();</span><br><span class="line">    <span class="comment">// 有活跃的写者或活跃的读者，新写者必须等待</span></span><br><span class="line">    <span class="keyword">while</span> (AW + AR &gt; <span class="number">0</span>) &#123;  <span class="comment">/* 体现写者优先的细节 2 */</span></span><br><span class="line">        WW++;</span><br><span class="line">        okToWrite.<span class="built_in">wait</span>(&amp;lock);</span><br><span class="line">        WW--</span><br><span class="line">    &#125;</span><br><span class="line">    AW++;</span><br><span class="line">    lock.<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管程方式实现：读者退出</span></span><br><span class="line"><span class="function">Private <span class="title">Database::DoneWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.<span class="built_in">Acquire</span>();</span><br><span class="line">    AW--;</span><br><span class="line">    <span class="comment">// 有等待的写者则优先唤醒写者，没有则唤醒所有读者</span></span><br><span class="line">    <span class="keyword">if</span> (WW &gt; <span class="number">0</span>) &#123;  <span class="comment">/* 体现写者优先的细节 3 */</span></span><br><span class="line">        okToWrite.<span class="built_in">signal</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (WR &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        okToRead.<span class="built_in">broadcast</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    lock.<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>体现写者优先的细节 2：有活跃的写者（和活跃的读者）时，新的写者需要等待。</li>
<li>体现写者优先的细节 3：优先检查并唤醒等待的写者，而不是等待的读者。</li>
</ul>
<h1 id="哲学家就餐问题"><a href="# 哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题 </h1><h2 id="问题描述"><a href="# 问题描述" class="headerlink" title="问题描述"></a> 问题描述 </h2><p> 问题的设定是：</p>
<p>有一圆桌上放着 N 个餐盘和 N 个叉子，N 个哲学家坐在 <strong> 圆桌 </strong> 旁边的椅子上，每个哲学家需要同时拿起他左、右两边的叉子才能进餐，吃完后放下叉子继续思考。如果一个哲学家拿起了左边的叉子，但右边的叉子被其他哲学家占用，那么他就必须等待其他哲学家放下叉子后才能继续。</p>
<blockquote>
<p>哲学家就餐问题是一个经典的并发问题，用来探讨在共享资源的情况下，多个进程或线程之间如何协调和竞争资源的使用。</p>
</blockquote>
<h2 id="关键挑战"><a href="# 关键挑战" class="headerlink" title="关键挑战"></a>关键挑战 </h2><p> 哲学家就餐问题的挑战在于如何 <strong> 避免死锁 </strong>（当所有哲学家都拿起了左边的叉子，但无法再拿起右边的叉子时）和<strong> 饥饿</strong>（某个哲学家无法获得两个叉子而一直等待）的情况发生。</p>
<h2 id="问题思考"><a href="# 问题思考" class="headerlink" title="问题思考"></a>问题思考 </h2><p> 共享资源：N 个餐盘和 N 个叉子。</p>
<p>涉及的动作：思考、拿起某一个叉子、进餐、放下某一个叉子。</p>
<p>成功进餐：只要相邻的叉子，被同一个哲学家拿去，那么这个哲学家就可以成功进餐。</p>
<p>失败进餐：当所有哲学家都拿起了左边的叉子，导致无法拿起右边的叉子。</p>
<p>哲学家饿死：N-1 个哲学家进餐很多、很多次后，才能轮到那一个哲学家进餐，虽然有机会进餐，但是大概率在拿到这个机会前就被饿死了。</p>
<h2 id="各种实现思考"><a href="# 各种实现思考" class="headerlink" title="各种实现思考"></a>各种实现思考 </h2><h3 id="直观实现（错误）"><a href="# 直观实现（错误）" class="headerlink" title="直观实现（错误）"></a> 直观实现（错误）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N (5)  <span class="comment">// 哲学家个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span> &#123;  <span class="comment">// 哲学家编号：0-4</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        think();                 <span class="comment">// 哲学家在思考</span></span><br><span class="line">        take_fork(i);            <span class="comment">// 去拿左边的叉子</span></span><br><span class="line">        take_fork((i + <span class="number">1</span>) % N);  <span class="comment">// 去拿右边的叉子</span></span><br><span class="line">        eat();                   <span class="comment">// 进餐</span></span><br><span class="line">        put_fork(i);             <span class="comment">// 放下左边的叉子</span></span><br><span class="line">        put_fork((i + <span class="number">1</span>) % N);   <span class="comment">// 放下右边的叉子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：不正确，可能导致死锁。对于 1 个哲学家没问题，但如果 5 个哲学家同时拿起了左边的叉子，大家都准备拿取右边的叉子，拿不到，出现死锁。</p>
<h3 id="稍作改进实现（错误）"><a href="# 稍作改进实现（错误）" class="headerlink" title="稍作改进实现（错误）"></a>稍作改进实现（错误）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        think();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            take_fork(i);</span><br><span class="line">            <span class="keyword">if</span> (fork((i + <span class="number">1</span>) % N)) &#123;  <span class="comment">// 右边的叉子还在吗</span></span><br><span class="line">                take_fork((i + <span class="number">1</span>) % N);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                put_fork(i);       <span class="comment">// 放下左边的叉子</span></span><br><span class="line">                wait_some_time();  <span class="comment">// 等待一会儿</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        eat();</span><br><span class="line">        put_fork(i);</span><br><span class="line">        put_fork((i + <span class="number">1</span>) % N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：不正确，可能一直循环。大家同时拿起左边的叉子，又因为拿不到右边的叉子，又同时放下，如此循环。</p>
<h3 id="等待随机时间实现（可行）"><a href="# 等待随机时间实现（可行）" class="headerlink" title="等待随机时间实现（可行）"></a>等待随机时间实现（可行）</h3><p>将 <code>wait_some_time()</code> 替换为 <code>wait_random_time()</code>。可行，但由于时间随机，存在很多不确定性（如多次长时间等待，可能会出现饿死情况），不够完美。</p>
<h3 id="简单互斥访问实现（可行）"><a href="# 简单互斥访问实现（可行）" class="headerlink" title="简单互斥访问实现（可行）"></a>简单互斥访问实现（可行）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;  <span class="comment">// 互斥信号量，初值为 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        think();</span><br><span class="line">        P(mutex);  <span class="comment">// 进入临界区</span></span><br><span class="line">        take_fork(i);</span><br><span class="line">        take_fork((i + <span class="number">1</span>) % N);</span><br><span class="line">        eat();</span><br><span class="line">        put_fork(i);</span><br><span class="line">        put_fork((i + <span class="number">1</span>) % N);</span><br><span class="line">        V(mutex);  <span class="comment">// 退出临界区</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：正确，但每次仅允许一个人进餐。虽然解决了死锁，但存在缺点：</p>
<ol>
<li>它将就餐（而不是叉子）看成是必须互斥访问的临界资源，由此造成了叉子资源的浪费；</li>
<li>从理论上讲，最多应允许 N%2 个不相邻的哲学家同时进餐。</li>
</ol>
<h2 id="正确实现"><a href="# 正确实现" class="headerlink" title="正确实现"></a>正确实现 </h2><h3 id="思考"><a href="# 思考" class="headerlink" title="思考"></a> 思考 </h3><p> 思路一：如果你是一个哲学家，你会怎么来解决这个问题？</p>
<p>指导原则：要么不拿，要么就拿两把叉子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S1: 思考中...</span><br><span class="line">S2: 进入饥饿状态</span><br><span class="line">S3: 如果左邻居或右邻居正在进餐，则等待，否则转向 S4</span><br><span class="line">S4: 拿起两把叉子</span><br><span class="line">S5: 进餐...</span><br><span class="line">S6: 放下左边的叉子</span><br><span class="line">S7: 放下右边的叉子</span><br><span class="line">S8: 新的循环又开始了，转向 S1</span><br></pre></td></tr></table></figure>

<p>思路二：计算机怎么解决这个问题？</p>
<p>指导原则：不能浪费 CPU 时间、进程间相互通信。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S1: 思考中...</span><br><span class="line">S2: 进入饥饿状态</span><br><span class="line">S3: 如果左邻居或右邻居正在进餐，进程进入阻塞状态，否则转向 S4</span><br><span class="line">S4: 拿起两把叉子</span><br><span class="line">S5: 进餐...</span><br><span class="line">S6: 放下左边的叉子，看看左邻居现在能否进餐（饥饿状态，两把叉子都在），若能则唤醒之</span><br><span class="line">S7: 放下右边的叉子，看看右邻居现在能否进餐（饥饿状态，两把叉子都在），若能则唤醒之</span><br><span class="line">S8: 新的循环又开始了，转向 S1</span><br></pre></td></tr></table></figure>

<p>思路三：你应该怎么编写程序？</p>
<ol>
<li>必须有数据结构：用于描述每个哲学家当前状态</li>
<li>该状态是一个临界资源，对它的访问应该是互斥地进行</li>
<li>一个哲学家吃饱后，可能要唤醒邻居，存在同步关系</li>
</ol>
<blockquote>
<p>这里我们将「哲学家」看做了互斥访问的资源，而不像上面错误的实现中是将「叉子」看做了互斥访问的资源。</p>
</blockquote>
<h3 id="实现（可运行）"><a href="# 实现（可运行）" class="headerlink" title="实现（可运行）"></a>实现（可运行）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N (5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT(i) (((i) + N - 1) % N)  <span class="comment">// 左邻居</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT(i) (((i) + 1) % N)     <span class="comment">// 右邻居</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EAT_MAX_NR (10)  <span class="comment">// 每个哲学家允许的最大进餐次数，控制线程退出</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">philo_state</span> &#123;</span> THINKING = <span class="number">0</span>, HUNGARY, EATING &#125; philo_state_en;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> sem_mutex;      <span class="comment">// 互斥信号量，初值为 1</span></span><br><span class="line"><span class="type">int</span> state[N];         <span class="comment">// 哲学家状态</span></span><br><span class="line"><span class="type">sem_t</span> sem_sync[N];    <span class="comment">// 同步信号量，初值为 0</span></span><br><span class="line"><span class="type">pthread_t</span> thread[N];  <span class="comment">// 哲学家对应的线程</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> eatNr[N];  <span class="comment">// 哲学家进餐次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 哲学家思考，随机思考一段时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">think</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;philo-%d, think start at %ld\r\n&quot;</span>, i, clock());</span><br><span class="line">    sleep(<span class="number">1</span> + rand() % <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;philo-%d, think end at %ld\r\n&quot;</span>, i, clock());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 哲学家就餐，吃一会儿 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eat</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;philo-%d, eat start at %ld\r\n&quot;</span>, i, clock());</span><br><span class="line">    sleep(<span class="number">1</span> + rand() % <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;philo-%d, eat end at %ld\r\n&quot;</span>, i, clock());</span><br><span class="line">    eatNr[i]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检查当前哲学家是否可以进餐 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_take_lr_forks</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (state[i] == HUNGARY &amp;&amp; state[LEFT(i)] != EATING &amp;&amp; state[RIGHT(i)] != EATING) &#123;</span><br><span class="line">        state[i] = EATING;</span><br><span class="line">        <span class="comment">// 若能拿到叉子，执行 V 操作，后续就不会阻塞</span></span><br><span class="line">        sem_post(&amp;sem_sync[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 尝试拿叉子（不一定能达到） */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">take_forks</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    sem_wait(&amp;sem_mutex);</span><br><span class="line">    state[i] = HUNGARY;</span><br><span class="line">    test_take_lr_forks(i);</span><br><span class="line">    sem_post(&amp;sem_mutex);</span><br><span class="line">    <span class="comment">// 如果没拿到叉子，就会在这里阻塞，如果拿到了叉子，这里不会阻塞</span></span><br><span class="line">    sem_wait(&amp;sem_sync[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 就餐完毕，尝试唤醒邻居就餐 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">put_forks</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    sem_wait(&amp;sem_mutex);</span><br><span class="line">    state[i] = THINKING;</span><br><span class="line">    test_take_lr_forks(LEFT(i));</span><br><span class="line">    test_take_lr_forks(RIGHT(i));</span><br><span class="line">    sem_post(&amp;sem_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 哲学家线程：思考 - 拿叉子 - 就餐 - 放叉子 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread #%lu, phiol-%d in place\r\n&quot;</span>, pthread_self(), i);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        think(i);</span><br><span class="line">        take_forks(i);</span><br><span class="line">        eat(i);</span><br><span class="line">        put_forks(i);</span><br><span class="line">        <span class="keyword">if</span> (eatNr[i] &gt;= EAT_MAX_NR) &#123;  <span class="comment">// 控制线程退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="comment">/* 初始化 */</span></span><br><span class="line">    sem_init(&amp;sem_mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        state[i] = THINKING;</span><br><span class="line">        eatNr[i] = <span class="number">0</span>;</span><br><span class="line">        sem_init(&amp;sem_sync[i], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建线程，并绑定线程函数 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        pthread_create(&amp;thread[i], <span class="literal">NULL</span>, (<span class="type">void</span>* (*)(<span class="type">void</span>*))philosopher, (<span class="type">void</span>*)(<span class="type">uintptr_t</span>)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待线程结束 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        pthread_join(thread[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 销毁信号量 */</span></span><br><span class="line">    sem_destroy(&amp;sem_mutex);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        sem_destroy(&amp;sem_sync[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结果分析"><a href="# 结果分析" class="headerlink" title="结果分析"></a>结果分析 </h3><p> 持续打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread #140511761397312, phiol-0 in place</span><br><span class="line">philo-0, think start at 1572</span><br><span class="line">Thread #140511753004608, phiol-1 in place</span><br><span class="line">philo-1, think start at 1621</span><br><span class="line">Thread #140511727826496, phiol-4 in place</span><br><span class="line">philo-4, think start at 1754</span><br><span class="line">Thread #140511744611904, phiol-2 in place</span><br><span class="line">philo-2, think start at 1791</span><br><span class="line">Thread #140511736219200, phiol-3 in place</span><br><span class="line">philo-3, think start at 2068</span><br><span class="line">philo-2, think end at 2092</span><br><span class="line">philo-2, eat start at 2111</span><br><span class="line">philo-1, think end at 2131</span><br><span class="line">philo-2, eat end at 2164</span><br><span class="line">philo-2, think start at 2184</span><br><span class="line">philo-1, eat start at 2194</span><br><span class="line">philo-4, think end at 2219</span><br><span class="line">philo-4, eat start at 2245</span><br><span class="line">philo-0, think end at 2280</span><br><span class="line">philo-3, think end at 2332</span><br><span class="line">philo-2, think end at 2366</span><br><span class="line">philo-1, eat end at 2423</span><br><span class="line">philo-1, think start at 2472</span><br><span class="line">philo-2, eat start at 2513</span><br><span class="line">philo-1, think end at 2561</span><br><span class="line">philo-4, eat end at 2602</span><br><span class="line">philo-4, think start at 2626</span><br><span class="line">philo-0, eat start at 2657</span><br><span class="line">philo-2, eat end at 2699</span><br><span class="line">philo-2, think start at 2719</span><br><span class="line">philo-3, eat start at 2750</span><br><span class="line">philo-0, eat end at 2795</span><br><span class="line">philo-0, think start at 2841</span><br><span class="line">philo-1, eat start at 2882</span><br><span class="line">philo-1, eat end at 2942</span><br><span class="line">philo-1, think start at 2977</span><br><span class="line">philo-4, think end at 3003</span><br><span class="line">philo-0, think end at 3038</span><br><span class="line">philo-0, eat start at 3053</span><br><span class="line">philo-1, think end at 3072</span><br><span class="line">philo-3, eat end at 3100</span><br><span class="line">philo-3, think start at 3114</span><br><span class="line">philo-2, think end at 3140</span><br><span class="line">philo-2, eat start at 3157</span><br><span class="line">philo-0, eat end at 3184</span><br><span class="line">philo-0, think start at 3222</span><br><span class="line">philo-4, eat start at 3258</span><br></pre></td></tr></table></figure>

<p>从上面的打印可以看出：每个哲学家都在思考、进餐，而且保证了同时最多只有 5%2 个哲学家在同时进餐，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2: 2111-2164  // 2 进餐</span><br><span class="line">1: 2194-2423  // 1 进餐</span><br><span class="line">4: 2245-2602  // 4,1 同时进餐</span><br><span class="line">2: 2513-2699  // 2,4 同时进餐</span><br><span class="line">0: 2657-2795  // 0,2 同时进餐</span><br><span class="line">3: 2750-3100  // 3,0 同时进餐</span><br><span class="line">1: 2882-2942  // 1,3 同时进餐</span><br><span class="line">0: 3053-3184  // 0,3 同时进餐（哲学家 3 吃的有点久啊~）</span><br></pre></td></tr></table></figure>

<p>最后，当每个哲学家进餐达到 10 次后，其线程退出，等全部退出后，销毁信号量，程序结束。</p>
<blockquote>
<p>参考资料：<br>1：<a href="https://blog.csdn.net/weixin_53407527/article/details/125207305">https://blog.csdn.net/weixin_53407527/article/details/125207305</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>经典同步问题</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>经典同步问题</tag>
        <tag>读者写者问题</tag>
        <tag>哲学家就餐问题</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter9 同步与互斥</title>
    <url>/posts/240104202828.html</url>
    <content><![CDATA[<p>本文介绍同步与互斥，主要包括相关背景，竞态条件、原子操作、临界区 &amp; 互斥 &amp; 死锁 &amp; 饥饿等相关概念，临界区的属性以及如何实现临界区的互斥访问等。</p>
<span id="more"></span>

<h1 id="背景"><a href="# 背景" class="headerlink" title="背景"></a>背景 </h1><p> 第一章到第八章内容，到目前为止：</p>
<ul>
<li>多道程序设计：现代操作系统的重要特性。</li>
<li>并行很有用（为什么？）提示——多个并发实体：CPU、I/O、用户等。</li>
<li>进程 &amp; 线程：操作系统抽象出来用于支持多道程序设计。</li>
<li>CPU 调度：实现多道程序设计的机制。</li>
<li>调度算法：选择进程 &amp; 线程不同的策略。</li>
</ul>
<p><strong>独立线程</strong>：</p>
<ul>
<li>不和其它线程共享资源或状态；</li>
<li>确定性：输入状态决定结果；</li>
<li>可重现：能够重现起始条件、I/O；</li>
<li>调度顺序不重要。</li>
</ul>
<p><strong>合作线程</strong>：</p>
<ul>
<li>在多个线程中共享状态；</li>
<li>不确定性；</li>
<li>不可重现；</li>
</ul>
<p>不确定性和不可重现意味着 BUG 可能是间歇性发生的。</p>
<p>虽然如此，但进程 &amp; 线程、计算机、设备需要合作。</p>
<p><strong>合作的优点</strong>：</p>
<ol>
<li>共享资源：<ul>
<li>一台电脑，多个用户；</li>
<li>一个银行存款余额，多台 ATM 机；</li>
<li>嵌入式系统（机器人控制：手臂和手的协调）。</li>
</ul>
</li>
<li>加速：<ul>
<li>I/O 操作和计算可以重叠；</li>
<li>多处理器：将程序分成多个部分并行执行。</li>
</ul>
</li>
<li>模块化：<ul>
<li>将大程序分解成小程序——以编译为例，gcc 会调用 cpp, cc1, cc2, as, ld；</li>
<li>使系统易于扩展。</li>
</ul>
</li>
</ol>
<p><strong>程序调用 <code>fork()</code> 创建新进程的过程</strong>：</p>
<ul>
<li>操作系统需要分配新的进程 ID，并保证其唯一性。</li>
<li>在内核中，<code>fork()</code>系统调用会运行 <code>new_pid = next_pid++</code>：<ul>
<li><code>LOAD next_pid Reg1</code></li>
<li><code>STORE Reg1 new_pid</code> ——&gt; 假设发生了上下文切换，转去执行另一个程序的 <code>fork()</code> 操作</li>
<li><code>INC Reg1</code></li>
<li><code>STORE Reg1 next_pid</code></li>
</ul>
</li>
<li>假设有两个进程并发执行该过程：<ul>
<li>正常情况下，如果 <code>next_pid</code> 的值为 <code>100</code>，那么其中一个进程将获得<code>new_pid=100</code> 的新进程 ID，另一个进程将获得 <code>new_pid=101</code> 的新进程 ID，同时 <code>next_pid</code> 的值将增加到<code>102</code>。</li>
<li><strong>但是，由于可能在自增操作之前发生了上下文切换 </strong>，最终导致两个进程都获得了<code>new_pid=100</code> 的新进程 ID，而 <code>next_pid</code> 的值也变成了<code>101</code>。</li>
</ul>
</li>
</ul>
<p>多线程程序具有不确定性和不可重现的特点，但 <strong> 无论多个线程的指令序列怎么交替执行，程序都必须正常工作</strong>。</p>
<p>因此，我们必须要有一些新的机制来保证能够 <strong> 达到最终确定的结果</strong>，后面会引入同步互斥机制来解决这种不确定性的问题。</p>
<h1 id="一些概念"><a href="# 一些概念" class="headerlink" title="一些概念"></a>一些概念 </h1><h2 id="竞态条件（Race-Condition）"><a href="# 竞态条件（Race-Condition）" class="headerlink" title="竞态条件（Race Condition）"></a> 竞态条件（Race Condition）</h2><p>竞态条件是指在多个线程或进程并发执行的情况下，<strong>对共享资源的访问顺序不确定</strong>，从而导致程序的行为出现不可预测的结果。</p>
<ul>
<li>系统缺陷：结果依赖于并发执行（或者时间）的顺序、时间。<ul>
<li>不确定性</li>
<li>不可重现</li>
</ul>
</li>
<li>怎么样避免竞态？</li>
</ul>
<h2 id="原子操作（Atomic-Operator）"><a href="# 原子操作（Atomic-Operator）" class="headerlink" title="原子操作（Atomic Operator）"></a>原子操作（Atomic Operator）</h2><p>原子操作是指在并发环境下，<strong>不能被中断的一系列操作，要么全部执行成功，要么全部不执行</strong>。原子操作能够保证在多线程或多进程同时访问共享资源时的数据一致性。</p>
<p>原子操作的特点包括：</p>
<ol>
<li>不可中断性：原子操作在执行期间不能被其他线程或进程中断，保证了操作的完整性。</li>
<li>互斥性：原子操作在同一时间只能被一个线程或进程执行，避免了竞态条件的发生。</li>
<li>原子性：原子操作要么全部执行成功，要么全部不执行，不会出现部分执行的情况。</li>
</ol>
<blockquote>
<p>原子操作通常是由硬件提供的特殊指令或者操作系统提供的原子操作函数来实现的。</p>
</blockquote>
<p>实际上的操作往往不是原子的：</p>
<ul>
<li>有些看上去是原子操作，实际上不是；</li>
<li>连 <code>i++</code> 这样的简单语句，实际上是由三条指令构成的。</li>
</ul>
<h2 id="临界区 -amp- 互斥 -amp- 死锁 -amp- 饥饿"><a href="# 临界区 -amp- 互斥 -amp- 死锁 -amp- 饥饿" class="headerlink" title="临界区 &amp; 互斥 &amp; 死锁 &amp; 饥饿"></a>临界区 &amp; 互斥 &amp; 死锁 &amp; 饥饿 </h2><p><strong> 临界区（Critical Section）</strong>是指进程中的一段需要访问共享资源，并且当另一个进程处于相应代码区域时便不会被执行的代码区域。</p>
<p><strong>互斥（Mutual Exclusion）</strong>是指当一个进程处于临界区并访问共享资源时，没有其他进程会处于临界区并访问任何相同的共享资源。</p>
<p><strong>死锁（Dead Lock）</strong>是指两个或以上进程，在相互等待完成特定任务，而最终没法将自身任务进行下去，形成循环等待。</p>
<p><strong>饥饿（Starvation）</strong>是指一个可执行的进程，被调度器持续忽略，以至于虽然处于可执行状态却不能被执行。</p>
<h1 id="临界区（Critical-Section）"><a href="# 临界区（Critical-Section）" class="headerlink" title="临界区（Critical Section）"></a>临界区（Critical Section）</h1><h2 id="临界区的属性"><a href="# 临界区的属性" class="headerlink" title="临界区的属性"></a>临界区的属性 </h2><p> 要设计实现临界区，临界区必须满足以下属性：</p>
<ul>
<li><strong>互斥</strong>：同一时间临界区中最多存在一个线程。</li>
<li><strong>前进（Progress）</strong>：如果一个线程想要进入临界区，那么它最终会成功。</li>
<li><strong>有限等待</strong>：如果一个线程 <code>thread</code> 处于入口区，那么在 <code>thread</code> 的请求被接受前，其它线程进入临界区的时间是有限制的（否则线程 <code>thread</code> 可能会饥饿）。</li>
<li><strong>无忙等待（可选）</strong>：如果一个进程在等待进入临界区，那么在它可以进入之前会被挂起。</li>
</ul>
<h2 id="临界区的实现方法"><a href="# 临界区的实现方法" class="headerlink" title="临界区的实现方法"></a>临界区的实现方法 </h2><p> 实现临界区的互斥访问的方法：</p>
<ul>
<li>禁用硬件中断；</li>
<li>基于软件方法；</li>
<li>更高级的抽象方法。</li>
</ul>
<h1 id="禁用硬件中断（方法一）"><a href="# 禁用硬件中断（方法一）" class="headerlink" title="禁用硬件中断（方法一）"></a>禁用硬件中断（方法一）</h1><p>中断是指在程序执行过程中，由硬件或软件触发的一种特殊事件，<strong>它会打断当前正在执行的程序</strong>，并跳转到预定义的中断处理程序中执行。</p>
<p>上面说，中断会打断当前正在执行的程序，也正是因为这个中断，才导致了进程 / 线程的上下文切换——执行其它进程 / 线程。如果没有这个中断，是不是就可以让一个进程 / 线程顺利地执行完临界区代码呢？是的！</p>
<h2 id="方法"><a href="# 方法" class="headerlink" title="方法"></a>方法 </h2><p> 禁用硬件中断，实现临界区的互斥访问：</p>
<ul>
<li>没有中断机制，也就没有上下文切换，因此没有并发。<ul>
<li>硬件将中断处理 延迟到 中断被启用之后。</li>
<li>大多数现代计算机体系结构都提供指令来完成这一操作。</li>
</ul>
</li>
<li>进入临界区：禁用中断。</li>
<li>离开临界区：启用中断。</li>
</ul>
<h2 id="特点"><a href="# 特点" class="headerlink" title="特点"></a>特点 </h2><p> 禁用硬件中断确实可以解决多个进程 / 线程同时访问临界区共享资源，但它有一些缺点：</p>
<ul>
<li>一旦中断被禁用，线程就无法被停止：<ul>
<li>整个系统都会为你停下来！</li>
<li>可能导致其它线程处于饥饿状态！</li>
</ul>
</li>
<li>要是临界区可以任意长，会怎么样？<ul>
<li>将无法限制响应中断所需的时间（可能存在硬件影响，如如无法及时响应网卡中断、输入设备中断）。</li>
</ul>
</li>
<li>要小心使用：<ul>
<li>适用于临界区很小的情况。</li>
</ul>
</li>
<li>在多 CPU 的情况下，禁用硬件中断无法解决互斥问题：<ul>
<li>每个 CPU 都有自己的中断控制器，禁用一个 CPU 的中断不会影响在其它 CPU 上的进程 / 线程产生中断，因此无法实现对临界区的互斥控制。</li>
</ul>
</li>
</ul>
<h1 id="基于软件的解决方案（方法二）"><a href="# 基于软件的解决方案（方法二）" class="headerlink" title="基于软件的解决方案（方法二）"></a>基于软件的解决方案（方法二）</h1><p>对于两个线程 $T_{0}, T_{1}$ 的临界区的互斥访问：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* T_i 的通常结构 */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">/* enter section, 进入区域 */</span></span><br><span class="line">        <span class="comment">/* critical section, 临界区域 */</span></span><br><span class="line">    <span class="comment">/* exit section, 离开区域 */</span></span><br><span class="line">        <span class="comment">/* reminder section, 提醒区域 */</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h2 id="单标志法（失败）"><a href="# 单标志法（失败）" class="headerlink" title="单标志法（失败）"></a>单标志法（失败）</h2><p>使用一个共享变量 <code>turn</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 声明并初始化共享变量 */</span></span><br><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Thread T_i (i = 0, j = 1) */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">/* enter section */</span></span><br><span class="line">    <span class="keyword">while</span> (turn != i);</span><br><span class="line">        <span class="comment">/* critical section */</span></span><br><span class="line">    <span class="comment">/* exit section */</span></span><br><span class="line">    turn = j;</span><br><span class="line">    <span class="comment">/* reminder section */</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<ul>
<li>该代码尝试实现 <strong> 两个 </strong> 线程对临界区的互斥访问；</li>
<li>该代码中 <code>turn</code> 的值只能是 <code>0/1</code>——线程 $T_{0}/T_{1}$ 会在执行完临界区代码后，将 <code>turn</code> 设置为 <code>1/0</code>；</li>
<li>如果 <code>turn</code> 的值不是自己（<code>while (turn != i)</code>），则会一直忙等待，等待另一个线程将 <code>turn</code> 值设置为它的对方（<code>turn=j</code>）。</li>
</ul>
<p>存在的问题（是否满足临界区属性）：</p>
<ul>
<li><strong>满足互斥访问，但有时不满足前进</strong>（满足「忙则等待」，但不满足「空闲则入」）：如果线程 $T_{0}$ 在访问了一次临界区后（此时 <code>turn=1</code>），下次能访问临界区的只能是线程 $T_{1}$，如果 $T_{1}$ 一直不访问临界区（不去设置 <code>turn=0</code>），那么 $T_{0}$ 便无法再次访问临界区。</li>
</ul>
<p>因此，该设计满足互斥访问，但 <strong> 只能在两个进程交替的访问临界区 </strong> 的情况下满足前进。</p>
<h2 id="双标志先检查（失败）"><a href="# 双标志先检查（失败）" class="headerlink" title="双标志先检查（失败）"></a>双标志先检查（失败）</h2><p>使用一个共享数组变量 <code>flag[2]</code>，先检查是否可以进入临界区：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 声明并初始化共享变量 */</span></span><br><span class="line"><span class="type">int</span> flag[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Thread T_i (i = 0, j = 1) */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">/* enter section */</span></span><br><span class="line">    <span class="keyword">while</span> (flag[j] == <span class="number">1</span>);</span><br><span class="line">    flag[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* critical section */</span></span><br><span class="line">    <span class="comment">/* exit section */</span></span><br><span class="line">    flag[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* reminder section */</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<ul>
<li>该代码尝试实现 <strong> 两个 </strong> 线程对临界区的互斥访问；</li>
<li>该代码中 <code>flag[]</code> 数组的每个位置值只能是 <code>0/1</code>——线程 $T_{i}$ 会在执行临界区代码前（后），将 <code>flag[i]</code> 的标志设置为 <code>1</code>（<code>0</code>）；</li>
<li>进入临界区前，如果对方的标志是真，则会一直忙等待，等待另一个线程将它的标志设置为假。</li>
</ul>
<p>存在的问题（是否满足临界区属性）：</p>
<ul>
<li><strong>不满足互斥访问</strong>（不满足「忙则等待」）：初始化时，两个线程的 <code>flag</code> 都被置为 <code>0</code>；然后向下执行 <code>while</code>，都会发现对方的 <code>flag</code> 不为 <code>1</code>，则会进入临界区，无法实现对临界区的互斥访问。</li>
</ul>
<h2 id="双标志后检查（失败）"><a href="# 双标志后检查（失败）" class="headerlink" title="双标志后检查（失败）"></a>双标志后检查（失败）</h2><p>使用一个共享数组变量 <code>flag[2]</code>，先置位标志，后检查是否可以进入临界区：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 声明并初始化共享变量 */</span></span><br><span class="line"><span class="type">int</span> flag[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Thread T_i (i = 0, j = 1) */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">/* enter section */</span></span><br><span class="line">    flag[i] = <span class="number">1</span>;  <span class="comment">// 先置位标志</span></span><br><span class="line">    <span class="keyword">while</span> (flag[j] == <span class="number">1</span>);</span><br><span class="line">        <span class="comment">/* critical section */</span></span><br><span class="line">    <span class="comment">/* exit section */</span></span><br><span class="line">    flag[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* reminder section */</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<ul>
<li>该代码尝试实现 <strong> 两个 </strong> 线程对临界区的互斥访问；</li>
<li>该代码中 <code>flag[]</code> 数组的每个位置值只能是 <code>0/1</code>——线程 $T_{i}$ 会在 enter section 前将 <code>flag[i]</code> 的标志设置为 <code>1</code>、在执行完 critical section 代码后，将 <code>flag[i]</code> 的标志设置为 <code>0</code>；</li>
<li><strong>先置位标志，后尝试进入临界区</strong>：如果对方的标志是真，则会一直忙等待，等待另一个线程将它的标志设置为假。</li>
</ul>
<p>存在的问题（是否满足临界区属性）：</p>
<ul>
<li><strong>满足互斥访问，但存在死锁 </strong>（满足「忙则等待」，但不满足「空闲则入」）：初始化时，两个线程的 <code>flag</code> 都被置为 <code>0</code>，并向下执行。当线程 $T_{0}$ 将其 <code>flag[0]</code> 设置为 <code>1</code> 后，发生了上下文切换；然后，线程 $T_{1}$ 也会将其 <code>flag[1]</code> 设置为 <code>1</code>；至此，不管哪个线程执行 enter section 代码，都会等待，从而发生死锁。</li>
</ul>
<h2 id="Peterson 算法（成功）"><a href="#Peterson 算法（成功）" class="headerlink" title="Peterson 算法（成功）"></a>Peterson 算法（成功）</h2><p>算法思想：在双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。而 Peterson 算法，在双方都争着想进入临界区时，让进程尝试“孔融让梨”，主动让对方先使用临界区。</p>
<p>Peterson 算法是满足进程 $T_{i}$ 和 $T_{j}$ 之间互斥的经典的基于软件的解决方法（1981 年）。</p>
<p>它使用两个共享数据项（Use two shared data items）：</p>
<ul>
<li><code>int turn</code> 指示该谁进入临界区</li>
<li><code>bool flag[]</code> 指示进程是否准备好进入临界区</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 声明并初始化共享变量 */</span></span><br><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>] = &#123;<span class="literal">false</span>, <span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Thread T_i (i = 0, j = 1) */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">/* enter section */</span></span><br><span class="line">    flag[i] = <span class="literal">true</span>;  <span class="comment">// 我想进入临界区</span></span><br><span class="line">    turn = j;  <span class="comment">// 孔融让梨</span></span><br><span class="line">    <span class="keyword">while</span> (flag[j] &amp;&amp; turn == j);</span><br><span class="line">        <span class="comment">/* critical section */</span></span><br><span class="line">    <span class="comment">/* exit section */</span></span><br><span class="line">    flag[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/* reminder section */</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<ul>
<li>该代码尝试实现 <strong> 两个 </strong> 线程对临界区的互斥访问；</li>
<li>如果自己想进入临界区，便将标志置为真 <code>flag[i] = true</code>、并谦让着让对方先进入 <code>turn=j</code>，然后自己做好忙等待的心理准备——但是会检查两个共享数据项，如果对方想进入临界区（<code>flag[j] == true</code>），这时自己便忙等待；否则，自己可以成功进入临界区。</li>
</ul>
<p>可以证明（用反证法），Peterson 算法能够满足互斥、前进、有限等待三种特性。</p>
<h2 id="Dekker 算法（成功）"><a href="#Dekker 算法（成功）" class="headerlink" title="Dekker 算法（成功）"></a>Dekker 算法（成功）</h2><p>Dekker 算法是第一个针对双线程的基于软件的解决方法（1965 年）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 声明并初始化共享变量 */</span></span><br><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>] = &#123;<span class="literal">false</span>, <span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Thread T_i (i = 0, j = 1) */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">/* enter section */</span></span><br><span class="line">    flag[i] = <span class="literal">true</span>;  <span class="comment">// 我想进入临界区</span></span><br><span class="line">    <span class="keyword">while</span> (flag[j] == <span class="literal">true</span>) &#123;  <span class="comment">// 对方想进入临界区</span></span><br><span class="line">        <span class="keyword">if</span> (turn != i) &#123;  <span class="comment">// 没有轮到我</span></span><br><span class="line">            flag[i] = flase;  <span class="comment">// 孔融让梨，放弃进入临界区</span></span><br><span class="line">            <span class="keyword">while</span> (turn != i); <span class="comment">// 等待，直到把资格给到自己</span></span><br><span class="line">            flag[i] = <span class="literal">true</span>;  <span class="comment">// 你退出我则示意想要进入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">/* critical section */</span></span><br><span class="line">    <span class="comment">/* exit section */</span></span><br><span class="line">    turn = j;  <span class="comment">// 轮到你了</span></span><br><span class="line">    flag[i] = <span class="literal">false</span>;  <span class="comment">// 我不想进入临界区了</span></span><br><span class="line">    <span class="comment">/* reminder section */</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<ul>
<li>该代码尝试实现 <strong> 两个 </strong> 线程对临界区的互斥访问；</li>
<li><code>flag</code> 为真，表示想进入临界区（只是想，不代表能进入）；<code>turn</code> 为自己，表示自己可以进入临界区（对方不可以）；</li>
<li>假设只有 <code>flag[]</code> 共享变量：那就像「双标志后检查」一样，会发生死锁；<code>turn</code> 的使用，解决了死锁的问题。</li>
</ul>
<p>可以证明，Dekker 算法能够满足互斥、前进、有限等待三种特性。</p>
<h2 id="Eisenberg-and-McGuire 算法（N 进程）"><a href="#Eisenberg-and-McGuire 算法（N 进程）" class="headerlink" title="Eisenberg and McGuire 算法（N 进程）"></a>Eisenberg and McGuire 算法（N 进程）</h2><p>有机会再补充。</p>
<h2 id="Bakery 算法（N 进程）"><a href="#Bakery 算法（N 进程）" class="headerlink" title="Bakery 算法（N 进程）"></a>Bakery 算法（N 进程）</h2><p>解决 N 个进程的临界区互斥访问：</p>
<ul>
<li>进入临界区之前，进程接收一个数字，得到的数字最小的进入临界区；</li>
<li>如果进程 $P_{i}$ 和 $P_{j}$ 收到相同的数字，那么如果 $i &lt; j$，则 $P_{i}$ 先进入临界区，否则 $P_{j}$ 先进入临界区；</li>
<li>编号方案总是按照枚举的增加顺序生成数字。</li>
</ul>
<h2 id="总结"><a href="# 总结" class="headerlink" title="总结"></a>总结 </h2><p> 这些算法有以下特点：</p>
<ul>
<li>复杂：需要两个进程的共享数据项；</li>
<li>需要忙等待：浪费 CPU 时间；</li>
<li>没有硬件保证的情况下，无真正的软件解决方案。<ul>
<li>Peterson 算法需要原子的 <code>LOAD</code> 和<code>STORE</code>指令。</li>
</ul>
</li>
</ul>
<h1 id="更高级的抽象（方法三）"><a href="# 更高级的抽象（方法三）" class="headerlink" title="更高级的抽象（方法三）"></a>更高级的抽象（方法三）</h1><h2 id="一些解决方案"><a href="# 一些解决方案" class="headerlink" title="一些解决方案"></a>一些解决方案 </h2><p> 硬件提供一些原语：</p>
<ul>
<li>像中断禁用、原子操作指令等（大多数现代体系结构都这样）。</li>
</ul>
<p>操作系统提供更高级的编程抽象来简化并行编程：</p>
<ul>
<li>例如，锁、信号量；</li>
<li>从硬件原语中构建。</li>
</ul>
<p>锁是一个抽象数据结构，用于控制并发访问共享资源的机制：</p>
<ul>
<li>它具有一个二进制状态：锁定（locked）和解锁（unlocked）；</li>
<li>两种方法：<ul>
<li><code>Lock::Acquire()</code>：锁被释放前一直等待，然后得到锁；</li>
<li><code>Lock::Release()</code>：锁释放，唤醒任何等待的进程。</li>
</ul>
</li>
</ul>
<p>使用锁来编写临界区：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">lock_next_pid-&gt;<span class="built_in">Acquire</span>();</span><br><span class="line">new_pid = next_pid++;</span><br><span class="line">lock_next_pid-&gt;<span class="built_in">Release</span>();</span><br></pre></td></tr></table></figure>

<p>前面（背景小节）的例子变得简单起来，<code>lock_next_pid-&gt;Acquire()</code> 加锁后，临界区中的代码 <code>next_pid++</code>，在同一时间（从读、执行加一再到写回内存），只有一个进程对其操作，确保对 <code>next_pid</code> 的操作是原子的。</p>
<p>大多数现代体系结构都提供特殊的原子操作指令：</p>
<ul>
<li>通过特殊的内存访问电路；</li>
<li>针对单处理器和多处理器。</li>
</ul>
<h2 id="Test-And-Set 指令"><a href="#Test-And-Set 指令" class="headerlink" title="Test-And-Set 指令"></a>Test-And-Set 指令 </h2><p><strong> 测试和置位（Test-And-Set, TAS）指令 </strong> 把给定的内存地址设置为 1，然后返回之前的旧值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">TestAndSet</span><span class="params">(<span class="type">bool</span> *target)</span> &#123;</span><br><span class="line">    <span class="type">bool</span> rv = *target;</span><br><span class="line">    *target = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>还有一个 Compare And Swap (CAS) 指令。</p>
</blockquote>
<h2 id="Exchange 指令"><a href="#Exchange 指令" class="headerlink" title="Exchange 指令"></a>Exchange 指令</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Exchange</span><span class="params">(<span class="type">bool</span> *<span class="type">bool</span> *b)</span> &#123;</span><br><span class="line">    <span class="type">bool</span> tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Test-And-Set 和 Exchange 在硬件上实现为一个原子操作，执行期间不会被其他处理器打断。</p>
</blockquote>
<h2 id="基于 TAS 指令实现自旋锁（spinlock）"><a href="# 基于 TAS 指令实现自旋锁（spinlock）" class="headerlink" title="基于 TAS 指令实现自旋锁（spinlock）"></a>基于 TAS 指令实现自旋锁（spinlock）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Lock::<span class="built_in">Acquire</span>() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">TestAndSet</span>(value)) &#123;</span><br><span class="line">        ; <span class="comment">// spin 自旋锁，忙等待</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Lock::<span class="built_in">Release</span>() &#123;</span><br><span class="line">    value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Lock::Acquire()</code> 代码分析：</p>
<ul>
<li>如果锁被释放，那么 TAS 指令读取 0 并将值设置为 1（即锁被设置为忙，并且需要等待完成）；</li>
<li>如果锁处于忙等待，那么 TAS 指令读取 1 并将值设置为 1（即不改变锁的状态，并且需要循环 TAS 指令）。</li>
</ul>
<blockquote>
<p>上面方法，线程在等待的时候是忙等待，消耗 CPU 时间，自旋锁采用这种设计（因为它适用于持有锁的时间很短的情况下）。</p>
</blockquote>
<h2 id="无忙等待锁"><a href="# 无忙等待锁" class="headerlink" title="无忙等待锁"></a>无忙等待锁 </h2><p> 无忙等待锁，使处于忙等的进程睡眠，在临界区执行完的进程会将睡眠的进程唤醒。</p>
<img src="../images/os-kernel/chapter9/with-or-without-busy-waiting.png" alt="有无忙等待" width="80%" height="80%">

<p>如果临界区执行时间短，选择忙等方式（如自旋锁）；如果临界区执行时间长，选择无忙等待方式（如互斥锁、信号量、条件变量）。</p>
<h2 id="基于 Exchange 指令实现自旋锁（spinlock）"><a href="# 基于 Exchange 指令实现自旋锁（spinlock）" class="headerlink" title="基于 Exchange 指令实现自旋锁（spinlock）"></a>基于 Exchange 指令实现自旋锁（spinlock）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 声明并初始化共享变量 */</span></span><br><span class="line"><span class="type">int</span> lock = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Thread T_i (i = 0, j = 1) */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">/* enter section */</span></span><br><span class="line">    key = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (key == <span class="number">1</span>) &#123;</span><br><span class="line">        Exchange(lock, key);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">/* critical section */</span></span><br><span class="line">    <span class="comment">/* exit section */</span></span><br><span class="line">    lock = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* reminder section */</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<ul>
<li>当 <code>key==1, lock==1</code> 时，交换两数后，不会影响两数的值，即无法退出循环、无法获取锁；</li>
<li>当 <code>key==1, lock==0</code> 时，交换两数后，有 <code>key==0, lock==1</code>，即立即获取锁、退出循环。</li>
</ul>
<h2 id="原子操作的特征"><a href="# 原子操作的特征" class="headerlink" title="原子操作的特征"></a>原子操作的特征 </h2><p> 优点：</p>
<ul>
<li>适用于单处理器或者共享主存的多处理器中 <strong> 任意数量的进程同步</strong>；</li>
<li>简单并且容易证明；</li>
<li>支持多临界区。</li>
</ul>
<p>缺点：</p>
<ul>
<li>忙等待消耗处理器时间；</li>
<li>可能导致饥饿（如进程离开临界区时，有多个等待进程的情况）；</li>
<li><strong>死锁</strong>：拥有临界区的低优先级进程，遇到上下文中断，高优先级进程获得处理器，并请求访问临界区，这时会忙等待，高优先级进程向进入临界区，低优先级进程由于无法占用处理器，导致无法退出临界区（解决方案：优先级反转）。</li>
</ul>
<h1 id="总结 -1"><a href="# 总结 -1" class="headerlink" title="总结"></a>总结 </h1><p> 锁是更高等级的编程抽象：</p>
<ul>
<li>互斥可以使用锁来实现</li>
<li>通常需要一定等级的硬件支持（比如原子操作指令）</li>
</ul>
<p>常用的三种实现方法：</p>
<ul>
<li>禁用中断（仅限于单处理器）</li>
<li>软件方法（复杂）</li>
<li>原子操作指令（单处理器或多处理器均可）</li>
</ul>
<p>可选的实现内容:</p>
<ul>
<li>有忙等待</li>
<li>无忙等待</li>
</ul>
<blockquote>
<p>参考资料：<br>1：<a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a><br>2：<a href="https://blog.csdn.net/weixin_53407527/article/details/125088864">https://blog.csdn.net/weixin_53407527/article/details/125088864</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>同步与互斥</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>同步与互斥</tag>
        <tag>临界区</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之二叉搜索树</title>
    <url>/posts/231020174358.html</url>
    <content><![CDATA[<p>二叉搜索树（Binary Search Tree，BST）是一种常见的数据结构，它具有以下特点：</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值。</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值。</li>
<li>它的左、右子树也分别为二叉搜索树。</li>
</ul>
<p>由于 BST 的特点，二叉搜索树的查找、插入和删除效率都很高（BST 足够「平衡」情况下）。</p>
<span id="more"></span>

<h2 id="二叉搜索树操作"><a href="# 二叉搜索树操作" class="headerlink" title="二叉搜索树操作"></a>二叉搜索树操作 </h2><p> 二叉搜索树是什么样子的呢？百闻不如一见，直接上图：</p>
<p><img src="../images/data-structure/BST-Tree1.png" alt=""></p>
<h2 id="插入一个节点"><a href="# 插入一个节点" class="headerlink" title="插入一个节点"></a>插入一个节点 </h2><p> 如果我们插入一个节点，它的值为 9，我们应该插在哪里呢？看图~</p>
<p><img src="../images/data-structure/BST-Tree2.png" alt=""></p>
<p>我们插入值 9 的过程大概是这样的：</p>
<ol>
<li>9 &gt; 根节点 7 吗？大于，则转向看右子树；</li>
<li>9 &gt; 根节点 10 吗？小于，则转向看左子树；</li>
<li>左子树为空，则将 9 插入在这里。</li>
</ol>
<p>看看，这是不是跟有序数组的二分查找算法的思想一样呢，根据值的大小关系，决定下次搜索的区域（但 BST 的判断不一定每次都会排除 50% 的区域，这要看 BST 是否足够「平衡」）！</p>
<h2 id="搜索一个节点"><a href="# 搜索一个节点" class="headerlink" title="搜索一个节点"></a>搜索一个节点</h2><p><img src="../images/data-structure/BST-Searching.png" alt=""></p>
<p>搜索一个节点的过程跟上面插入一个节点的过程类似：</p>
<ol>
<li>5 == 根节点 7 吗？不等于；大于吗？小于，则转向左子树搜索；</li>
<li>5 == 根节点 2 吗？不等于；大于吗？大于，则转向右子树搜索；</li>
<li>5 == 根节点 5 吗？等于，搜索成功。</li>
</ol>
<h2 id="遍历二叉搜索树"><a href="# 遍历二叉搜索树" class="headerlink" title="遍历二叉搜索树"></a>遍历二叉搜索树 </h2><p> 我们知道，二叉树的遍历有前序遍历、中序遍历和后续遍历以及层序遍历。它们有不同的特点：</p>
<ul>
<li>前序遍历：先遍历根节点，再遍历左右子树；</li>
<li>中序遍历：先遍历左子树，中间遍历根节点，最后遍历右子树；</li>
<li>后续遍历：先遍历左子树和右子树，最后遍历根节点；</li>
<li>层序遍历：从上到下、从左到右，按层遍历二叉树中的每一个节点。</li>
</ul>
<p>结合二叉搜索树的特点：左子树上所有结点的值均小于它的根结点的值 &amp; 右子树上所有结点的值均大于它的根结点的值。设想一下，如果我们先获取左子树的值，再获取根节点的值，最后再获取右子树的值，并将它们按获取顺序保存到数组中，那么这个数组是不是按升序排序的数组呢？</p>
<p>没错，<strong>二叉搜索树的中序遍历的结果是一个按升序排序的有序数组</strong>，所以二叉搜索树又称二叉排序树。</p>
<p>二叉搜索树的中序遍历过程图。<br><img src="../images/data-structure/BST-in-order-traversing.png" alt=""></p>
<h2 id="删除一个节点"><a href="# 删除一个节点" class="headerlink" title="删除一个节点"></a>删除一个节点 </h2><p> 删除节点也很容易，根据二叉搜索树的特点，我们删除一个节点后，只需要将这个节点的左子树的最大值（或者是右子树的最小值）拿过来，放到这个被删除的节点这里即可。这样，删除一个节点后，这棵树依然是一棵二叉搜索树。</p>
<p><img src="../images/data-structure/BST-delete-node.png" alt=""></p>
<p>上图的 BST 删除一个节点中，Fig. 1 -&gt; Fig. 2 使用了左子树的最大值，Fig. 1 -&gt; Fig. 3 使用了右子树的最小值。</p>
<h2 id="二叉搜索树接口实现"><a href="# 二叉搜索树接口实现" class="headerlink" title="二叉搜索树接口实现"></a>二叉搜索树接口实现 </h2><h3 id="定义 -BST- 结构"><a href="# 定义 -BST- 结构" class="headerlink" title="定义 BST 结构"></a> 定义 BST 结构</h3><p>BST 结构定义与普通二叉树结构定义没有区别。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode_t;</span><br></pre></td></tr></table></figure>

<h3 id="创建一个节点"><a href="# 创建一个节点" class="headerlink" title="创建一个节点"></a>创建一个节点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode_t* <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    TreeNode_t *newNode = (TreeNode_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode_t));</span><br><span class="line">    newNode-&gt;val = val;</span><br><span class="line">    newNode-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入一个节点（迭代实现）"><a href="# 插入一个节点（迭代实现）" class="headerlink" title="插入一个节点（迭代实现）"></a>插入一个节点（迭代实现）</h3><p>给定一棵 BST，插入一个节点的过程为：</p>
<ol>
<li>判断根节点是否为空：<ul>
<li>为空，则创建一个节点，并返回该节点。</li>
</ul>
</li>
<li>根节点不为空，则判断插入的节点值与根节点的大小关系：<ul>
<li>相等，则不需插入，直接返回根节点。</li>
<li>小于，则需要确定根节点是否有左子树：<ul>
<li>无左子树，则创建一个节点并将其作为根节点的左子树，插入节点结束。</li>
<li>有左子树，更新根节点为左孩子节点，继续执行步骤 2；</li>
</ul>
</li>
<li>大于，则需要确定根节点是否有右子树：<ul>
<li>无右子树，则创建一个节点并将其作为根节点的右子树，插入节点结束。</li>
<li>有右子树，更新根节点为右孩子节点，继续执行步骤 2；</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode_t* <span class="title function_">insertNode</span><span class="params">(TreeNode_t* root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> createNode(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode_t *curNode = root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curNode-&gt;val == val) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; curNode-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curNode-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                curNode-&gt;left = createNode(val);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curNode = curNode-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (curNode-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                curNode-&gt;right = createNode(val);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curNode = curNode-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入一个节点（递归实现）"><a href="# 插入一个节点（递归实现）" class="headerlink" title="插入一个节点（递归实现）"></a>插入一个节点（递归实现）</h3><p>通过插入节点的迭代实现可以看出，插入的过程本质上是插入的值与不同子树的根节点做大小比较的过程，并在合适的位置插入新节点。因此，我们也可以递归地实现插入节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode_t* <span class="title function_">insertNode</span><span class="params">(TreeNode_t* root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> createNode(val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;left = insertNode(root-&gt;left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;right = insertNode(root-&gt;right, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="搜索一个节点（迭代实现）"><a href="# 搜索一个节点（迭代实现）" class="headerlink" title="搜索一个节点（迭代实现）"></a>搜索一个节点（迭代实现）</h3><p>给定一棵 BST，搜素一个节点的过程为：</p>
<ol>
<li>判断根节点是否为空：<ul>
<li>为空，则搜索失败，返回 <code>NULL</code>。</li>
<li>不为空，判断值是否相等：<ul>
<li>相等，则搜索成功，返回当前节点。</li>
<li>不相等，则判断搜索值与根节点值的大小关系，更新根节点，并重复步骤 1。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode_t* <span class="title function_">searchNode</span><span class="params">(TreeNode_t* root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    TreeNode_t *curNode = root;</span><br><span class="line">    <span class="keyword">while</span> (curNode &amp;&amp; (val != curNode-&gt;val)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val &lt; curNode-&gt;val) &#123;</span><br><span class="line">            curNode = curNode-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curNode = curNode-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="搜索一个节点（递归实现）"><a href="# 搜索一个节点（递归实现）" class="headerlink" title="搜索一个节点（递归实现）"></a>搜索一个节点（递归实现）</h3><p>同样地，搜索一个节点也有递归实现方式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode_t* <span class="title function_">searchNode</span><span class="params">(TreeNode_t* root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span> || val == root-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> searchNode(root-&gt;left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchNode(root-&gt;right, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历 -BST"><a href="# 中序遍历 -BST" class="headerlink" title="中序遍历 BST"></a>中序遍历 BST</h3><p>就像上面说的，二叉搜索树的中序遍历的结果是一个按升序排序的有序数组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inOrderTraversal</span><span class="params">(TreeNode_t* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        inOrderTraversal(root-&gt;left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;val);</span><br><span class="line">        inOrderTraversal(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历也是递归实现？！二叉树的每一棵子树还是一棵二叉树，所以二叉树的很多操作都可以用递归的方式实现。</p>
<h3 id="查找 -BST- 的最小节点"><a href="# 查找 -BST- 的最小节点" class="headerlink" title="查找 BST 的最小节点"></a>查找 BST 的最小节点 </h3><p> 给定一棵 BST 或它的子树，有时需要查找它的最小节点（比如后面的删除一个节点时，就会用到这个函数哦）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode_t* <span class="title function_">findMinNode</span><span class="params">(TreeNode_t* root)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (root-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = root-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查找 -BST- 的最大节点"><a href="# 查找 -BST- 的最大节点" class="headerlink" title="查找 BST 的最大节点"></a>查找 BST 的最大节点 </h3><p> 给定一棵 BST 或它的子树，有时需要查找它的最大节点（比如后面的删除一个节点时，也可能用到这个函数哦）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode_t* <span class="title function_">findMaxNode</span><span class="params">(TreeNode_t* root)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (root-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查找前驱节点"><a href="# 查找前驱节点" class="headerlink" title="查找前驱节点"></a>查找前驱节点 </h3><p> 在 BST 中，一个节点的 <strong> 前驱节点定义为比该节点小的所有节点中的最大节点</strong>。换句话说，它是在中序遍历顺序中位于该节点之前的节点。</p>
<p>如何确定前驱节点呢？</p>
<ul>
<li>如果一个节点有左子树，那么左子树的最大值就是前驱节点；</li>
<li>如果一个节点没有左子树，那么它的前驱节点就是离它最近的拥有右子树的祖先节点；<ul>
<li><strong>确定方法 </strong>：从根节点搜，只要值比该节点的值小，它就<strong> 可能 </strong> 是前驱节点。通过在满足条件的情况下，不断更新这个节点（离它越来越近），最后就是前驱节点啦。</li>
</ul>
</li>
<li>如果一个节点既没有左子树也没有右子树，那么它没有前驱节点。</li>
</ul>
<blockquote>
<p>什么叫「离它最近的拥有右子树的祖先节点」呢？<br>举个例子，上面的那张图中，节点 5 没有右子树，离它最近的拥有右子树的节点是节点 2，节点 2 是节点 5 的祖先节点，所以 5 的前驱节点是 2。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode_t* <span class="title function_">predecessorNode</span><span class="params">(TreeNode_t* root, TreeNode_t* node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果节点有左子树，则前驱节点为左子树中的最右节点</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">        <span class="keyword">return</span> findMaxNode(node-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果节点没有左子树，则前驱节点为离它最近的拥有右子树的祖先节点</span></span><br><span class="line">    TreeNode_t* predecessor = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; node-&gt;val) &#123;</span><br><span class="line">            predecessor = root;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &gt; node-&gt;val) &#123;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> predecessor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数一为 BST 的根节点，参数二为 BST 的某一节点，即想要查找参数二的前驱节点，参数二也可以传入根节点哦。</p>
</blockquote>
<h3 id="查找后驱节点"><a href="# 查找后驱节点" class="headerlink" title="查找后驱节点"></a>查找后驱节点 </h3><p> 在 BST 中，一个节点的 <strong> 后驱节点定义为比该节点大的所有节点中的最小节点</strong>。换句话说，它是在中序遍历顺序中位于该节点之后的节点。</p>
<p>如何确定后驱节点呢？</p>
<ul>
<li>如果一个节点有右子树，那么右子树的最小值就是后驱节点；</li>
<li>如果一个节点没有右子树，那么它的后驱节点就是离它最近的拥有左子树的祖先节点；</li>
<li>如果一个节点既没有右子树也没有左子树，那么它没有后驱节点。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode_t* <span class="title function_">successorNode</span><span class="params">(TreeNode_t* root, TreeNode_t* node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果节点有右子树，则后驱节点为右子树中的最左节点</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">        <span class="keyword">return</span> findMinNode(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果节点没有右子树，则后驱节点为离它最近的拥有左子树的祖先节点</span></span><br><span class="line">    TreeNode_t* successor = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; node-&gt;val) &#123;</span><br><span class="line">            successor = root;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; node-&gt;val) &#123;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> successor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除一个节点（递归实现）"><a href="# 删除一个节点（递归实现）" class="headerlink" title="删除一个节点（递归实现）"></a>删除一个节点（递归实现）</h3><p>给定一棵 BST，删除一个节点的思路为：</p>
<ul>
<li>若待删除的值小于根节点的值，则在左子树中查找并删除；</li>
<li>若待删除的值大于根节点的值，则在右子树中查找并删除；</li>
<li>若待删除的值等于根节点的值，要看它有没有左、右子树：<ul>
<li>无左子树和右子树：直接删除；</li>
<li>仅有左子树，则只需更新根节点的地址为其左孩子的地址，并释放原根节点空间即可。</li>
<li>仅有右子树，则只需更新根节点的地址为其右孩子的地址，并释放原根节点空间即可。</li>
<li>既有左子树、又有右子树：<ul>
<li>找左子树的最大值节点, 将根节点的值替换它的值，并删除它（又一次调用删除一个节点的函数）；或者找右子树的最小值节点, 将根节点的值替换它的值，并删除它。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode_t* <span class="title function_">deleteNode</span><span class="params">(TreeNode_t* root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;left = deleteNode(root-&gt;left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找到要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有子节点的情况</span></span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            root = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 只有右子节点的情况</span></span><br><span class="line">            TreeNode_t* temp = root;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 只有左子节点的情况</span></span><br><span class="line">            TreeNode_t* temp = root;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 有两个子节点的情况</span></span><br><span class="line">            <span class="comment">// 找左子树的最大值, 替换并删除它; 或者找右子树的最小值, 替换并删除它</span></span><br><span class="line">            TreeNode_t* temp = findMinNode(root-&gt;right);</span><br><span class="line">            root-&gt;val = temp-&gt;val;</span><br><span class="line">            root-&gt;right = deleteNode(root-&gt;right, temp-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="销毁 -BST"><a href="# 销毁 -BST" class="headerlink" title="销毁 BST"></a>销毁 BST</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">destroyBST</span><span class="params">(TreeNode_t* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        destroyBST(root-&gt;left);</span><br><span class="line">        destroyBST(root-&gt;right);</span><br><span class="line">        <span class="built_in">free</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在销毁二叉搜索树后，我们要将根节点指针 <code>root</code> 设为 <code>NULL</code>，以防止在后续操作中误用已被释放的内存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">destroyBST(root);</span><br><span class="line">root = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<h2 id="BST- 完整代码测试"><a href="#BST- 完整代码测试" class="headerlink" title="BST 完整代码测试"></a>BST 完整代码测试 </h2><h3 id="完整代码"><a href="# 完整代码" class="headerlink" title="完整代码"></a> 完整代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode_t;</span><br><span class="line"></span><br><span class="line">TreeNode_t* <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    TreeNode_t *newNode = (TreeNode_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode_t));</span><br><span class="line">    newNode-&gt;val = val;</span><br><span class="line">    newNode-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode_t* <span class="title function_">insertNode</span><span class="params">(TreeNode_t* root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> createNode(val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;left = insertNode(root-&gt;left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;right = insertNode(root-&gt;right, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode_t* <span class="title function_">searchNode</span><span class="params">(TreeNode_t* root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span> || val == root-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> searchNode(root-&gt;left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchNode(root-&gt;right, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrderTraversal</span><span class="params">(TreeNode_t* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        inOrderTraversal(root-&gt;left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;val);</span><br><span class="line">        inOrderTraversal(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode_t* <span class="title function_">findMinNode</span><span class="params">(TreeNode_t* root)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (root-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = root-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode_t* <span class="title function_">findMaxNode</span><span class="params">(TreeNode_t* root)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (root-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode_t* <span class="title function_">predecessorNode</span><span class="params">(TreeNode_t* root, TreeNode_t* node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果节点有左子树，则前驱节点为左子树中的最右节点</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">        <span class="keyword">return</span> findMaxNode(node-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果节点没有左子树，则前驱节点为离它最近的拥有右子树的祖先节点</span></span><br><span class="line">    TreeNode_t* predecessor = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; node-&gt;val) &#123;</span><br><span class="line">            predecessor = root;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &gt; node-&gt;val) &#123;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> predecessor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode_t* <span class="title function_">successorNode</span><span class="params">(TreeNode_t* root, TreeNode_t* node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果节点有右子树，则后驱节点为右子树中的最左节点</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">        <span class="keyword">return</span> findMinNode(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果节点没有右子树，则后驱节点为离它最近的拥有左子树的祖先节点</span></span><br><span class="line">    TreeNode_t* successor = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; node-&gt;val) &#123;</span><br><span class="line">            successor = root;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; node-&gt;val) &#123;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> successor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode_t* <span class="title function_">deleteNode</span><span class="params">(TreeNode_t* root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;left = deleteNode(root-&gt;left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找到要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有子节点的情况</span></span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            root = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 只有右子节点的情况</span></span><br><span class="line">            TreeNode_t* temp = root;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 只有左子节点的情况</span></span><br><span class="line">            TreeNode_t* temp = root;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 有两个子节点的情况</span></span><br><span class="line">            <span class="comment">// 找左子树的最大值, 替换并删除它; 或者找右子树的最小值, 替换并删除它</span></span><br><span class="line">            TreeNode_t* temp = findMinNode(root-&gt;right);</span><br><span class="line">            root-&gt;val = temp-&gt;val;</span><br><span class="line">            root-&gt;right = deleteNode(root-&gt;right, temp-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyBST</span><span class="params">(TreeNode_t* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        destroyBST(root-&gt;left);</span><br><span class="line">        destroyBST(root-&gt;right);</span><br><span class="line">        <span class="built_in">free</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试代码"><a href="# 测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 规范化地打印二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printBinaryTree</span><span class="params">(TreeNode_t* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">    printBinaryTree(root-&gt;left);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; &lt;- %d -&gt; &quot;</span>, root-&gt;val);</span><br><span class="line">    printBinaryTree(root-&gt;right);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argv, <span class="type">char</span> *argc[])</span> &#123;</span><br><span class="line">    TreeNode_t* root = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试插入节点和搜索节点</span></span><br><span class="line">    root = insertNode(root, <span class="number">5</span>);</span><br><span class="line">    root = insertNode(root, <span class="number">3</span>);</span><br><span class="line">    root = insertNode(root, <span class="number">7</span>);</span><br><span class="line">    root = insertNode(root, <span class="number">2</span>);</span><br><span class="line">    root = insertNode(root, <span class="number">4</span>);</span><br><span class="line">    root = insertNode(root, <span class="number">6</span>);</span><br><span class="line">    root = insertNode(root, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    TreeNode_t* result = searchNode(root, <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Node found: %d\n&quot;</span>, result-&gt;val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Node not found\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = searchNode(root, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Node found: %d\n&quot;</span>, result-&gt;val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Node not found\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试中序遍历</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In-order traversal: &quot;</span>);</span><br><span class="line">    inOrderTraversal(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试查找最小值节点和最大值节点</span></span><br><span class="line">    TreeNode_t* minNode = findMinNode(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Minimum value: %d\n&quot;</span>, minNode-&gt;val);</span><br><span class="line"></span><br><span class="line">    TreeNode_t* maxNode = findMaxNode(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Maximum value: %d\n&quot;</span>, maxNode-&gt;val);</span><br><span class="line"></span><br><span class="line">    printBinaryTree(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试前驱节点和后继节点</span></span><br><span class="line">    TreeNode_t* node = searchNode(root, <span class="number">4</span>);</span><br><span class="line">    TreeNode_t* predecessor = predecessorNode(root, node);</span><br><span class="line">    <span class="keyword">if</span> (predecessor != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Predecessor of %d: %d\n&quot;</span>, node-&gt;val, predecessor-&gt;val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No predecessor for %d\n&quot;</span>, node-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node = searchNode(root, <span class="number">7</span>);</span><br><span class="line">    TreeNode_t* successor = successorNode(root, node);</span><br><span class="line">    <span class="keyword">if</span> (successor != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Successor of %d: %d\n&quot;</span>, node-&gt;val, successor-&gt;val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No successor for %d\n&quot;</span>, node-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试删除节点</span></span><br><span class="line">    root = deleteNode(root, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次中序遍历，检查删除是否成功</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In-order traversal after deletion: &quot;</span>);</span><br><span class="line">    inOrderTraversal(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁二叉搜索树</span></span><br><span class="line">    destroyBST(root);</span><br><span class="line">    root = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试结果"><a href="# 测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Node found: 6</span><br><span class="line">Node not found</span><br><span class="line">In-order traversal: 2 3 4 5 6 7 8</span><br><span class="line">Minimum value: 2</span><br><span class="line">Maximum value: 8</span><br><span class="line">(((&lt;- 2 -&gt;) &lt;- 3 -&gt; (&lt;- 4 -&gt;)) &lt;- 5 -&gt; ((&lt;- 6 -&gt;) &lt;- 7 -&gt; (&lt;- 8 -&gt;)))</span><br><span class="line">Predecessor of 4: 3</span><br><span class="line">Successor of 7: 8</span><br><span class="line">In-order traversal after deletion: 2 4 5 6 7 8</span><br></pre></td></tr></table></figure>

<blockquote>
<p>插入和搜索的迭代实现方式也验证了，没有问题。</p>
</blockquote>
<p>建立的这棵树是这样子的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       5</span><br><span class="line">     /   \</span><br><span class="line">    /     \</span><br><span class="line">   3       7</span><br><span class="line"> /   \   /   \</span><br><span class="line">2     4 6     8</span><br></pre></td></tr></table></figure>

<p>节点 4 的前驱节点是 3，节点 7 的后驱节点是 8，没有问题！</p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://github.com/kodecocodes/swift-algorithm-club/blob/master/Binary%20Search%20Tree/README.markdown">BST in swift-algorithm-club</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉搜索树</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之堆基础与堆结构（数组实现）</title>
    <url>/posts/231018102559.html</url>
    <content><![CDATA[<p>堆（Heap）是一类特殊的数据结构，是最高效的优先级队列。堆是用 <strong> 数组实现 </strong> 的<strong>完全 </strong> 二叉树，所以它没有使用父指针或者子指针，省内存。</p>
<span id="more"></span>

<blockquote>
<p>完全二叉树的形式是指除了最后一层之外，其他所有层的结点都是满的，而最后一层的所有结点都靠左边。</p>
</blockquote>
<h2 id="堆属性"><a href="# 堆属性" class="headerlink" title="堆属性"></a>堆属性 </h2><p><strong> 堆属性 </strong>：在最大堆中，父结点的值比每一个子结点的值都要大（可以等于）。在最小堆中，父结点的值比每一个子结点的值都要小（可以等于）。这就是所谓的「堆属性」，并且这个属性对堆中的<strong> 每一个结点 </strong> 都成立。</p>
<p>在一个最大堆中，最小元素一定在叶子结点中，但不能确定是哪一个；在一个最小堆中，最大元素一定在叶子结点中，但不能确定是哪一个。</p>
<p>下面是一个堆数据的二叉树模式图和紧凑数组模式图。<br>二叉树模式图：<br><img src="/images/data-structure/heap-tree-format-data.png" alt="堆的二叉树模式图"><br>紧凑数组模式图：<br><img src="/images/data-structure/heap-array-format-data.png" alt="堆的紧凑数组模式图"></p>
<blockquote>
<p>堆的根结点存放的是最大或者最小元素，但是 <strong> 其他结点的排序顺序是未知的，只是满足堆属性而已</strong>。</p>
</blockquote>
<h2 id="堆与普通树的区别"><a href="# 堆与普通树的区别" class="headerlink" title="堆与普通树的区别"></a>堆与普通树的区别</h2><ol>
<li><p><strong>结点顺序</strong>：在最大堆中，任一根结点都不小于其左、右子结点的值，而在二叉搜索树中，根结点一定大于其左结点的值，也一定小于其右结点的值。</p>
</li>
<li><p><strong>内存占用</strong>：普通树占用的内存比其存储的数据要多，因为要为每个结点对象及其左、右子结点指针分配内存，而堆仅仅使用一个数组存储数据，不需要指针。</p>
</li>
<li><p><strong>平衡</strong>：二叉搜索树时间复杂度为 <code>O(log n)</code> 的前提是树尽可能是平衡的。而堆中平衡不是问题，只要满足堆属性即可保证 <code>O(log n)</code> 的性能。</p>
</li>
<li><p><strong>搜索 </strong>：二叉搜索树中搜索很快，即二分查找 <code>O(log n)</code>。但是，在堆中搜索很慢，即遍历数组 <code>O(n)</code>，在堆中搜索不是第一优先级，因为<strong> 使用堆的目的是将最大（或者最小）的结点放在最前面，从而快速的进行相关插入、删除操作</strong>。</p>
</li>
</ol>
<h2 id="堆中父我子节点映射关系"><a href="# 堆中父我子节点映射关系" class="headerlink" title="堆中父我子节点映射关系"></a>堆中父我子节点映射关系 </h2><p><strong> 父我子结点映射关系</strong>：对于数组中索引为 $i$ 的结点（我），其父结点索引和左、右子结点在数组中的索引位置为如下：</p>
<p>$$<br>\begin{cases}<br>my(i) = i; \\<br>parent(i) = floor(\frac{i-1}{2}); \\<br>left(i) = 2i+1; \\<br>right(i) = 2i + 2 = left(i) + 1; \\<br>\end{cases}<br>$$</p>
<blockquote>
<p>所有结点的索引一定不能越界，即 $i \in [0, n-1]$。</p>
</blockquote>
<h2 id="堆数组元素大小关系"><a href="# 堆数组元素大小关系" class="headerlink" title="堆数组元素大小关系"></a>堆数组元素大小关系 </h2><p><strong> 数组关系</strong>：根据堆属性可知，在最大堆中有 $array[parent(i)] &gt;= array[i]$ ，在最小堆中有 $array[parent(i)] &lt;= array[i]$。</p>
<h2 id="堆的二叉树模式的高度"><a href="# 堆的二叉树模式的高度" class="headerlink" title="堆的二叉树模式的高度"></a>堆的二叉树模式的高度 </h2><p> 堆的形状一定是一棵 <strong> 完全 </strong> 二叉树。在堆中，在当前层级所有的结点都已经填满之前不允许开始下一层的填充。</p>
<p>一个有 $n$ 个结点的堆，其高度为 $h=floor(log_{2}{n})$。堆的前 $h-1$ 层结点数量为 $2^{h}-1$。堆的最后一层若填满的话，最后一层包含 $2^h$ 个结点，整个堆共有 $n=2^{h+1}-1$ 个结点。</p>
<p>叶结点总是位于数组的 $[floor(n/2), n-1]$ 区间，那么 <strong> 最后一个非叶子结点</strong>（最后一个内部结点）索引即 $floor(n/2)-1$。</p>
<blockquote>
<p>堆的高度从 0 层开始，空堆的高度为 -1，高度为 $h$ 的堆有 $h + 1$ 层（0 到 h 层）。</p>
</blockquote>
<h2 id="堆化（heapify）"><a href="# 堆化（heapify）" class="headerlink" title="堆化（heapify）"></a>堆化（heapify）</h2><p>「堆化」的目的是在堆进行插入或删除操作后，为了确保堆仍然是一个有效的最大堆或最小堆（仍然满足堆属性），需要进行一些必要的操作（上浮和下沉操作），这个过程就叫做堆化。</p>
<ol>
<li><code>shiftUp()</code>: If the element is greater (max-heap) or smaller (min-heap) than its parent, it needs to be swapped with the parent. This makes it move up the tree.</li>
<li><code>shiftDown()</code>. If the element is smaller (max-heap) or greater (min-heap) than its children, it needs to move down the tree.</li>
</ol>
<blockquote>
<p>上浮或下沉是一个递归过程，需要 <code>O(log n)</code> 时间。因为每次上浮或下沉都会选择一个子树、而抛弃另一个子树（上浮或下沉的次数最多为树的高度）。</p>
</blockquote>
<p>为什么在插入或删除时，会有上浮和下沉过程？</p>
<p>这是因为，删除操作时，会 pop 出堆顶的元素，<strong>并将堆数组的最后一个索引的元素填充到堆顶</strong>，这个操作会使得堆不再满足堆属性；而在插入操作时，会先将数据存储在堆数组的最后一个索引后面，插入的数据大小未知，也会导致堆不再满足堆属性。因此，在插入或删除操作执行后，需要进行堆化这一过程。</p>
<h2 id="数组实现堆数据结构"><a href="# 数组实现堆数据结构" class="headerlink" title="数组实现堆数据结构"></a>数组实现堆数据结构 </h2><h3 id="堆结构定义"><a href="# 堆结构定义" class="headerlink" title="堆结构定义"></a> 堆结构定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Heap</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *<span class="built_in">array</span>;     <span class="comment">// 堆的数组</span></span><br><span class="line">    <span class="type">int</span> size;       <span class="comment">// 堆的当前大小</span></span><br><span class="line">    <span class="type">int</span> capacity;   <span class="comment">// 堆的容量</span></span><br><span class="line">&#125; Heap_t;</span><br></pre></td></tr></table></figure>

<p>堆结构与之前的栈的结构类似，包括堆的最大容量、堆的当前大小（数据量）、存储数据的空间（数组）。</p>
<blockquote>
<p>这里，堆的数据成员使用一个指针，可以在创建不同的堆时，根据需要申请堆的容量；如果使用一个数组变量（如 <code>int array[MAX_CAPACITY]</code>），则在创建不同的堆时，无法修改堆的最大容量。<br>这里，堆的数据成员使用一个 <code>int *</code> 类型的指针，如果我们堆中存放的数据是复杂的组合数据，简单地修改数据成员的指针类型即可。</p>
</blockquote>
<h3 id="堆的初始化"><a href="# 堆的初始化" class="headerlink" title="堆的初始化"></a>堆的初始化 </h3><p> 堆的初始化，包括申请堆本身的内存空间和数据成员的内存空间两部分，以及对基本成员做初始化操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化堆</span></span><br><span class="line">Heap_t* <span class="title function_">initHeap</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Heap_t *heap = (Heap_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Heap_t));</span><br><span class="line">    heap-&gt;<span class="built_in">array</span> = (<span class="type">int</span> *)<span class="built_in">malloc</span>(capacity * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    heap-&gt;size = <span class="number">0</span>;</span><br><span class="line">    heap-&gt;capacity = capacity;</span><br><span class="line">    <span class="keyword">return</span> heap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取父节点索引"><a href="# 获取父节点索引" class="headerlink" title="获取父节点索引"></a>获取父节点索引 </h3><p> 根据上述的理论基础，我们知道当前节点 $i$ 的父节点的索引为 $parent(i) = floor(\frac{i-1}{2})$。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取节点的父节点索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getParentIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (index - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取左子节点索引"><a href="# 获取左子节点索引" class="headerlink" title="获取左子节点索引"></a>获取左子节点索引 </h3><p> 根据上述的理论基础，我们知道当前节点 $i$ 的左子节点的索引为 $left(i) = 2i+1$。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取节点的左子节点索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getLeftChildIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取右子节点索引"><a href="# 获取右子节点索引" class="headerlink" title="获取右子节点索引"></a>获取右子节点索引 </h3><p> 根据上述的理论基础，我们知道当前节点 $i$ 的右子节点的索引为 $right(i) = 2i+2$。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取节点的右子节点索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getRightChildIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (index &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆化之上浮操作"><a href="# 堆化之上浮操作" class="headerlink" title="堆化之上浮操作"></a>堆化之上浮操作 </h3><p> 在插入操作时，会先将数据存储在堆数组的最后一个索引后面，而插入的数据大小未知，会导致堆不再满足堆属性，需要进行堆化中的上浮操作，使堆数组重新满足堆属性。</p>
<p>首先，封装一个实现交换数组中两个位置的值的函数。这里，使用了异或运算的自反性，而没有使用临时变量的方式交换两个数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *<span class="built_in">array</span>, <span class="type">int</span> idx1, <span class="type">int</span> idx2)</span> &#123;</span><br><span class="line">    <span class="built_in">array</span>[idx1] = <span class="built_in">array</span>[idx1] ^ <span class="built_in">array</span>[idx2];</span><br><span class="line">    <span class="built_in">array</span>[idx2] = <span class="built_in">array</span>[idx1] ^ <span class="built_in">array</span>[idx2];</span><br><span class="line">    <span class="built_in">array</span>[idx1] = <span class="built_in">array</span>[idx1] ^ <span class="built_in">array</span>[idx2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在最大堆的堆化上浮操作中，如果当前索引对应的节点的值比其父节点的值大，则应该将两个节点进行交换，<strong>直到不满足当前节点比其父节点大或当前节点达到堆顶为止</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上浮操作，将节点移动到正确的位置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">siftUp</span><span class="params">(Heap_t *heap, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *<span class="built_in">array</span> = heap-&gt;<span class="built_in">array</span>;</span><br><span class="line">    <span class="type">int</span> parentIndex = getParentIndex(index);</span><br><span class="line">    <span class="keyword">while</span> ((index &gt; <span class="number">0</span>) &amp;&amp; (<span class="built_in">array</span>[index] &gt; <span class="built_in">array</span>[parentIndex])) &#123;</span><br><span class="line">        swap(<span class="built_in">array</span>, parentIndex, index);</span><br><span class="line">        index = parentIndex;  <span class="comment">// 交换节点后, 更新当前节点的位置</span></span><br><span class="line">        parentIndex = getParentIndex(index);  <span class="comment">// 重新获取父节点位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆化之下沉操作（迭代方式）"><a href="# 堆化之下沉操作（迭代方式）" class="headerlink" title="堆化之下沉操作（迭代方式）"></a>堆化之下沉操作（迭代方式）</h3><p>在删除操作时，会 pop 出堆顶的元素，并将堆数组的最后一个索引的元素填充到堆顶，这个操作会使得堆不再满足堆属性，需要进行堆化中的下沉操作 —— 将这个数放到合适它的位置，使堆数组重新满足堆属性。</p>
<p>在最大堆的堆化下沉操作中，当前索引对应的节点的值要跟它的左右孩子节点做比较，并跟两者中较大的孩子做位置替换，<strong>直到无需跟左右孩子节点替换（值比它俩都大）为止</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下沉操作，将节点移动到正确的位置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">siftDown</span><span class="params">(Heap_t *heap, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *<span class="built_in">array</span> = heap-&gt;<span class="built_in">array</span>;</span><br><span class="line">    <span class="type">int</span> size = heap-&gt;size;</span><br><span class="line">    <span class="type">int</span> leftChildIndex, rightChildIndex, maxIndex;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; size) &#123;</span><br><span class="line">        leftChildIndex = getLeftChildIndex(index);</span><br><span class="line">        rightChildIndex = getRightChildIndex(index);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接下来的两个判断为找出具有更大值的孩子的索引</span></span><br><span class="line">        maxIndex = index;</span><br><span class="line">        <span class="keyword">if</span> (leftChildIndex &lt; size &amp;&amp; <span class="built_in">array</span>[leftChildIndex] &gt; <span class="built_in">array</span>[maxIndex]) &#123;</span><br><span class="line">            maxIndex = leftChildIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightChildIndex &lt; size &amp;&amp; <span class="built_in">array</span>[rightChildIndex] &gt; <span class="built_in">array</span>[maxIndex]) &#123;</span><br><span class="line">            maxIndex = rightChildIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (maxIndex != index) &#123;</span><br><span class="line">            swap(<span class="built_in">array</span>, maxIndex, index);</span><br><span class="line">            index = maxIndex;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>while 循环处的条件其实为 true 也行, 代码里那么写是防止首次进入 while 循环时，便是非法的索引，这样可以少一次循环处理。</p>
</blockquote>
<h3 id="堆化之下沉操作（递归方式）"><a href="# 堆化之下沉操作（递归方式）" class="headerlink" title="堆化之下沉操作（递归方式）"></a>堆化之下沉操作（递归方式）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">siftDown</span><span class="params">(Heap_t* heap, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxIndex = index;</span><br><span class="line">    <span class="type">int</span> leftChildIndex = getLeftChildIndex(index);</span><br><span class="line">    <span class="type">int</span> rightChildIndex = getRightChildIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来的两个判断为找出具有更大值的孩子的索引</span></span><br><span class="line">    <span class="keyword">if</span> (leftChildIndex &lt; heap-&gt;size &amp;&amp; heap-&gt;<span class="built_in">array</span>[leftChildIndex] &gt; heap-&gt;<span class="built_in">array</span>[maxIndex]) &#123;</span><br><span class="line">        maxIndex = leftChildIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rightChildIndex &lt; heap-&gt;size &amp;&amp; heap-&gt;<span class="built_in">array</span>[rightChildIndex] &gt; heap-&gt;<span class="built_in">array</span>[maxIndex]) &#123;</span><br><span class="line">        maxIndex = rightChildIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index != maxIndex) &#123;</span><br><span class="line">        swap(heap-&gt;<span class="built_in">array</span>, maxIndex, index);</span><br><span class="line">        siftDown(heap, maxIndex);  <span class="comment">// 递归方式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取堆顶元素"><a href="# 获取堆顶元素" class="headerlink" title="获取堆顶元素"></a>获取堆顶元素</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取堆顶元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(Heap_t *heap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Heap is empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap-&gt;<span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入数据"><a href="# 插入数据" class="headerlink" title="插入数据"></a>插入数据 </h3><p> 在插入操作时，会 <strong> 先将数据存储在堆数组的最后一个索引后面 </strong>，而插入的数据大小未知，会导致堆不再满足堆属性，需要<strong> 进行堆化中的上浮操作</strong>，使堆数组重新满足堆属性。</p>
<p>下面的动画演示了插入 <code>2,7,26,25,19,17,1,90,3,36</code> 数据（创建堆并维持堆属性）的过程。<br><img src="/images/data-structure/heap-push.gif" alt="堆插入数据"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Heap_t *heap, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;size &gt;= heap-&gt;capacity) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Heap is full!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    heap-&gt;<span class="built_in">array</span>[heap-&gt;size] = value;  <span class="comment">// 存储在堆数组的最后一个索引后面</span></span><br><span class="line">    siftUp(heap, heap-&gt;size);  <span class="comment">// 进行堆化中的上浮操作</span></span><br><span class="line">    heap-&gt;size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果不希望遇到堆满的情况（希望在堆满时依然可以插入数据），则可以在堆满时进行动态扩容，并修改堆的容量。</p>
</blockquote>
<h3 id="删除堆顶数据"><a href="# 删除堆顶数据" class="headerlink" title="删除堆顶数据"></a>删除堆顶数据 </h3><p> 在删除操作时，会 pop 出堆顶的元素，并 <strong> 将堆数组的最后一个索引的元素填充到堆顶 </strong>，这个操作会使得堆不再满足堆属性，需要<strong> 进行堆化中的下沉操作</strong> —— 将这个数放到合适它的位置，使堆数组重新满足堆属性。</p>
<p>下面的动画演示了删除堆顶数据的过程。<br><img src="/images/data-structure/heap-pop.gif" alt="删除堆顶数据过程"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除堆顶元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Heap_t *heap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Heap is empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> top = heap-&gt;<span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    heap-&gt;<span class="built_in">array</span>[<span class="number">0</span>] = heap-&gt;<span class="built_in">array</span>[heap-&gt;size - <span class="number">1</span>];</span><br><span class="line">    heap-&gt;size--;</span><br><span class="line">    siftDown(heap, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除堆顶后的紧凑型数组模式图是这样的：<br><img src="/images/data-structure/heap-pop-after.png" alt="删除堆顶数据后"></p>
<h3 id="打印堆数据"><a href="# 打印堆数据" class="headerlink" title="打印堆数据"></a>打印堆数据</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印堆元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printHeap</span><span class="params">(Heap_t *heap)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Heap: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; heap-&gt;size; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, heap-&gt;<span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="销毁堆"><a href="# 销毁堆" class="headerlink" title="销毁堆"></a>销毁堆</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 销毁堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyHeap</span><span class="params">(Heap_t *heap)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(heap-&gt;<span class="built_in">array</span>);</span><br><span class="line">    <span class="built_in">free</span>(heap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆操作的时间复杂度"><a href="# 堆操作的时间复杂度" class="headerlink" title="堆操作的时间复杂度"></a>堆操作的时间复杂度 </h2><p> 堆的时间复杂度如下：</p>
<ul>
<li>插入元素到堆：<code>O(log n)</code></li>
<li>删除堆顶元素：<code>O(log n)</code></li>
<li>获取堆顶元素：<code>O(1)</code></li>
<li>「Floyd 上浮方式」构建堆：<code>O(n)</code></li>
<li>堆排序：<code>O(n*log n)</code></li>
<li>上浮操作：<code>O(n*log n)</code></li>
<li>下沉操作：<code>O(n*log n)</code></li>
</ul>
<blockquote>
<p>为什么构建堆的过程的时间复杂度为 <code>O(n)</code> 呢？</p>
</blockquote>
<h2 id="数组实现堆完整代码"><a href="# 数组实现堆完整代码" class="headerlink" title="数组实现堆完整代码"></a>数组实现堆完整代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *<span class="built_in">array</span>;     <span class="comment">// 堆的数组</span></span><br><span class="line">    <span class="type">int</span> size;       <span class="comment">// 堆的当前大小</span></span><br><span class="line">    <span class="type">int</span> capacity;   <span class="comment">// 堆的容量</span></span><br><span class="line">&#125; Heap_t;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *<span class="built_in">array</span>, <span class="type">int</span> idx1, <span class="type">int</span> idx2)</span> &#123;</span><br><span class="line">    <span class="built_in">array</span>[idx1] = <span class="built_in">array</span>[idx1] ^ <span class="built_in">array</span>[idx2];</span><br><span class="line">    <span class="built_in">array</span>[idx2] = <span class="built_in">array</span>[idx1] ^ <span class="built_in">array</span>[idx2];</span><br><span class="line">    <span class="built_in">array</span>[idx1] = <span class="built_in">array</span>[idx1] ^ <span class="built_in">array</span>[idx2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Heap_t* <span class="title function_">initHeap</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Heap_t *heap = (Heap_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Heap_t));</span><br><span class="line">    heap-&gt;<span class="built_in">array</span> = (<span class="type">int</span> *)<span class="built_in">malloc</span>(capacity * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    heap-&gt;size = <span class="number">0</span>;</span><br><span class="line">    heap-&gt;capacity = capacity;</span><br><span class="line">    <span class="keyword">return</span> heap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getParentIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (index - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getLeftChildIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getRightChildIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (index &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">siftUp</span><span class="params">(Heap_t *heap, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *<span class="built_in">array</span> = heap-&gt;<span class="built_in">array</span>;</span><br><span class="line">    <span class="type">int</span> parentIndex = getParentIndex(index);</span><br><span class="line">    <span class="keyword">while</span> ((index &gt; <span class="number">0</span>) &amp;&amp; (<span class="built_in">array</span>[index] &gt; <span class="built_in">array</span>[parentIndex])) &#123;</span><br><span class="line">        swap(<span class="built_in">array</span>, parentIndex, index);</span><br><span class="line">        index = parentIndex;  <span class="comment">// 交换节点后, 更新当前节点的位置</span></span><br><span class="line">        parentIndex = getParentIndex(index);  <span class="comment">// 重新获取父节点位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">siftDown</span><span class="params">(Heap_t* heap, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxIndex = index;</span><br><span class="line">    <span class="type">int</span> leftChildIndex = getLeftChildIndex(index);</span><br><span class="line">    <span class="type">int</span> rightChildIndex = getRightChildIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来的两个判断为找出具有更大值的孩子的索引</span></span><br><span class="line">    <span class="keyword">if</span> (leftChildIndex &lt; heap-&gt;size &amp;&amp; heap-&gt;<span class="built_in">array</span>[leftChildIndex] &gt; heap-&gt;<span class="built_in">array</span>[maxIndex]) &#123;</span><br><span class="line">        maxIndex = leftChildIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rightChildIndex &lt; heap-&gt;size &amp;&amp; heap-&gt;<span class="built_in">array</span>[rightChildIndex] &gt; heap-&gt;<span class="built_in">array</span>[maxIndex]) &#123;</span><br><span class="line">        maxIndex = rightChildIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index != maxIndex) &#123;</span><br><span class="line">        swap(heap-&gt;<span class="built_in">array</span>, maxIndex, index);</span><br><span class="line">        siftDown(heap, maxIndex);  <span class="comment">// 递归方式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(Heap_t *heap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Heap is empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap-&gt;<span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Heap_t *heap, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;size &gt;= heap-&gt;capacity) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Heap is full!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    heap-&gt;<span class="built_in">array</span>[heap-&gt;size] = value;  <span class="comment">// 存储在堆数组的最后一个索引后面</span></span><br><span class="line">    siftUp(heap, heap-&gt;size);  <span class="comment">// 进行堆化中的上浮操作</span></span><br><span class="line">    heap-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Heap_t *heap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Heap is empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> top = heap-&gt;<span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    heap-&gt;<span class="built_in">array</span>[<span class="number">0</span>] = heap-&gt;<span class="built_in">array</span>[heap-&gt;size - <span class="number">1</span>];</span><br><span class="line">    heap-&gt;size--;</span><br><span class="line">    siftDown(heap, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printHeap</span><span class="params">(Heap_t *heap)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Heap: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; heap-&gt;size; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, heap-&gt;<span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyHeap</span><span class="params">(Heap_t *heap)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(heap-&gt;<span class="built_in">array</span>);</span><br><span class="line">    <span class="built_in">free</span>(heap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">10</span>, capacity = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> nums[] = &#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">26</span>,<span class="number">25</span>,<span class="number">19</span>,<span class="number">17</span>,<span class="number">1</span>,<span class="number">90</span>,<span class="number">3</span>,<span class="number">36</span>&#125;;</span><br><span class="line">    Heap_t *heap = initHeap(capacity);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        push(heap, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printHeap(heap);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Heap top: %d\n&quot;</span>, peek(heap));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Heap pop: %d\n&quot;</span>, pop(heap));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Heap top: %d\n&quot;</span>, peek(heap));</span><br><span class="line">    printHeap(heap);</span><br><span class="line">    destroyHeap(heap);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Heap: 90 36 17 25 26 7 1 2 3 19</span><br><span class="line">Heap top: 90</span><br><span class="line">Heap pop: 90</span><br><span class="line">Heap top: 36</span><br><span class="line">Heap: 36 26 17 25 19 7 1 2 3</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://github.com/kodecocodes/swift-algorithm-club/tree/master/Heap">Heap in swift-algorithm-club</a></li>
<li><a href="https://visualgo.net/zh/heap">堆的动画制作网站</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之字典树</title>
    <url>/posts/230925185057.html</url>
    <content><![CDATA[<h2 id="什么是字典树"><a href="# 什么是字典树" class="headerlink" title="什么是字典树"></a>什么是字典树 </h2><p> 字典树，是一种 <strong> 以空间换时间 </strong> 的数据结构，又称 Trie 树、前缀树，是一种树形结构，典型应用是统计、排序和保存大量字符串（但不仅限于字符串）。所以经常被搜索引擎系统用于文本词频统计。它的优点是可以 <strong> 利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高</strong>。</p>
<span id="more"></span>

<img src="../images/data-structure/trie-demo.png" alt="字典树示意图" width="80%" height="80%">

<blockquote>
<p>可能大部分情况你很难直观或者有接触的体验，可能对前缀这个玩意没啥概念，可能做题遇到前缀问题也是暴力匹配蒙混过关，<strong>如果字符串比较少，使用哈希表等结构可能也能蒙混过关，但如果字符串比较长、相同前缀较多，那么使用字典树可以大大减少内存的使用和效率 </strong>。<br> 一个字典树的应用场景：在 Google 搜索框输入部分单词下面会有一些神关联的搜索内容，你有时候都很神奇是怎么做到的，这其实就是字典树的一个思想。</p>
</blockquote>
<h2 id="字典树的性质"><a href="# 字典树的性质" class="headerlink" title="字典树的性质"></a>字典树的性质 </h2><p> 字典树是一种高效的数据结构，用于 <strong> 存储和快速检索字符串集合</strong>。它具有以下性质：</p>
<ol>
<li>字典树的 <strong> 根节点不包含任何字符</strong>，每个节点都代表一个字符，从根节点到叶节点的路径组成一个字符串。</li>
<li>每个节点可以包含 <strong> 多个子节点</strong>，每个子节点代表一个字符，节点之间的连接表示字符之间的关系。</li>
<li>每个节点的子节点通过不同的字符来标识，不同节点之间的路径上的字符不会重复。</li>
<li>字典树中的每个节点都可以 <strong> 存储一个附加值</strong>，用于表示该节点所代表的字符串的一些信息。</li>
<li>字典树可以 <strong> 高效地插入和查找字符串</strong>。插入操作将一个字符串的字符逐个添加到字典树中，查找操作根据给定的前缀或完整字符串，在字典树中检索相应的字符串。</li>
<li>字典树可以用于 <strong> 前缀匹配</strong>，例如，可以快速找到所有具有相同前缀的字符串。</li>
<li>字典树的 <strong> 空间复杂度相对较高</strong>，因为它需要为每个字符创建一个节点，但它可以通过压缩节点来减少空间占用。</li>
</ol>
<h2 id="设计实现字典树"><a href="# 设计实现字典树" class="headerlink" title="设计实现字典树"></a>设计实现字典树 </h2><p> 上面已经介绍了什么是字典树，那么我们开始设计一个字典树吧！</p>
<p>对于字典树，可能不同的场景或者需求设计上有一些细致的区别，但整体来说一般的字典树有创建、插入、查询（指定字符串）、查询（指定前缀）操作。</p>
<p>以 <a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">LeetCode 实现字典树 </a> 为例，实现字符集是 26 个英文小写字母的字典树的创建、插入、查询操作。</p>
<ul>
<li><code>trieCreate()</code> 初始化字典树对象。</li>
<li><code>void trieInsert(Trie *obj, char *word)</code> 向字典树中插入字符串<code>word</code>。</li>
<li><code>bool trieSearch(Trie *obj, char *word)</code> 搜索字符串 <code>word</code> 是否在字典树中。</li>
<li><code>bool trieStartsWith(Trie *obj, char *prefix)</code> 搜索字符串的前缀 <code>prefix</code> 是否在字典树中。</li>
</ul>
<h3 id="定义字典树类"><a href="# 定义字典树类" class="headerlink" title="定义字典树类"></a>定义字典树类 </h3><p> 字典树中的每一个节点，都是一个 <code>Trie</code> 类，而这个节点标识的字符可以是字符集中的任意一个字符。简单地，可以使用一个 <code>Trie</code> 类型数组（长度为字符集大小）来标识所有子节点。同时，为了表示该节点是否是某一个字符串的结束字符，可以添加一个布尔类型的结束标记 <code>isEnd</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUMS (26)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> *<span class="title">children</span>[<span class="title">NUMS</span>];</span>  <span class="comment">// 子节点指针数组，用于存储子节点的指针</span></span><br><span class="line">    <span class="type">bool</span> isEnd;  <span class="comment">// 表示当前节点是否为一个单词的结束节点</span></span><br><span class="line">    <span class="type">char</span> padding[<span class="number">7</span>];  <span class="comment">// 用于字节对齐的占位</span></span><br><span class="line">&#125; Trie;</span><br></pre></td></tr></table></figure>

<h3 id="字典树创建（初始化）"><a href="# 字典树创建（初始化）" class="headerlink" title="字典树创建（初始化）"></a>字典树创建（初始化）</h3><p>字典树有一个根节点，且字典树的根节点不包含任何字符。所以，我们需要初始化一个 <code>Trie</code> 类，并置空所有的子节点地址，以表示根节点不包含任何字符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Trie* <span class="title function_">trieCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    Trie *node = (Trie *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Trie));</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to create a trie node\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;sizeof(Trie) = %d\n&quot;, sizeof(Trie));  // x64, 216</span></span><br><span class="line">    <span class="built_in">memset</span>(node-&gt;children, <span class="number">0</span>, <span class="keyword">sizeof</span>(Trie));</span><br><span class="line">    node-&gt;isEnd = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用 <code>trieCreate()</code> 函数创建了节点 <code>node</code>，它不包含任何字符。</p>
<h3 id="字典树插入字符串"><a href="# 字典树插入字符串" class="headerlink" title="字典树插入字符串"></a>字典树插入字符串 </h3><p> 插入字符串的过程是逐个字符地搜索并检查它们是否存在于字典树中。如果某个字符不存在，则需要在上一个字符对应的节点上创建一个新的子节点，并将该节点指向新的字符（新的节点）。这样，就能够正确地构建出整个字符串在字典树中的路径。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trieInsert</span><span class="params">(Trie *obj, <span class="type">char</span> *word)</span> &#123;</span><br><span class="line">    Trie* curr = obj;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; word[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> index = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;children[index] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Trie* child = trieCreate();</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;failed to create a new trie\r\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr-&gt;children[index] = child;</span><br><span class="line">            curr-&gt;children[index]-&gt;isEnd = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将当前节点更新为新节点</span></span><br><span class="line">        curr = curr-&gt;children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将最后一个字符所在的节点标记为字符串的结尾</span></span><br><span class="line">    curr-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从根节点开始遍历字符串的每一个字符，然后根据字符计算出在子节点数组中的索引位置：</p>
<ul>
<li>如果该位置为空，则创建一个新的节点，并将该位置指向新节点；</li>
<li>然后，<strong>将当前节点更新为新节点</strong>，继续下一个字符的判断；</li>
<li>最后，将最后一个字符所在的节点标记为字符串的结尾，表示该字符串已经插入到字典树中。</li>
</ul>
<h3 id="字典树查询字符串"><a href="# 字典树查询字符串" class="headerlink" title="字典树查询字符串"></a>字典树查询字符串 </h3><p> 查询字符串的过程是在字典树已经建立好的情况下进行的。类似于插入过程，也是逐个字符地搜索并检查它们是否存在于字典树中（但不需要创建新的子节点）。如果在查询的过程中发现某个节点为空（未被初始化），则说明该字符串在字典树中不存在。如果成功遍历到最后一个字符所对应的节点，并且该节点标记为结束字符，则表明该字符串在字典树中存在；反之，如果最后一个字符对应的节点不是结束字符，则表明该字符串在字典树中不存在。所以 <strong> 在查询过程中，我们需要注意判断节点是否为空以及最后一个字符对应节点的结束字符标记</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">trieSearch</span><span class="params">(Trie *obj, <span class="type">char</span> *word)</span> &#123;</span><br><span class="line">    Trie* curr = obj;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; word[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> index = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;children[index] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr-&gt;isEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从根节点开始遍历字符串的每一个字符：</p>
<ul>
<li>首先，根据字符计算出在子节点数组中的索引位置：<ul>
<li>如果对应位置的子节点为空，则表示字典树中没有该字符串；</li>
<li>如果对应位置的子节点非空，则将当前节点更新为新节点，继续后续字符的判断；</li>
</ul>
</li>
<li>最后，根据结束字符的状态，返回字符串是否存在。</li>
</ul>
<h3 id="字典树前缀查询"><a href="# 字典树前缀查询" class="headerlink" title="字典树前缀查询"></a>字典树前缀查询 </h3><p> 前缀查询的过程也是在字典树已经建立好的情况下进行的。与查询字符串的过程类似，我们仍然是逐个字符地搜索并检查它们是否存在于字典树中。不同之处在于，前缀查询不需要判断前缀字符串的最后一个字符是否是结束字符，只要能成功遍历到最后一个字符，就可以确认该前缀字符串存在于字典树中。</p>
<blockquote>
<p>因为字典树的特点是每个节点都存储了字符集中的每个字符的子节点，所以只要前缀字符串中的每个字符都在字典树中存在对应的子节点，就可以确定该前缀字符串存在于字典树中。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">trieStartsWith</span><span class="params">(Trie *obj, <span class="type">char</span> *prefix)</span> &#123;</span><br><span class="line">    Trie* curr = obj;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; prefix[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> index = prefix[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;children[index] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字典树释放"><a href="# 字典树释放" class="headerlink" title="字典树释放"></a>字典树释放 </h3><p> 字典树释放的过程需要释放 <strong> 每个 </strong> 节点的 <strong> 所有子节点 </strong> 的空间。如果某个节点的子节点不为空，则需要继续深入该子节点，释放它的子节点的空间，直到最底层的叶子节点。然后再回溯到上一层节点，继续释放它的其他子节点，直到所有节点的空间都被释放完毕。所以字典树的释放过程是一个递归地释放每个节点的所有子节点的过程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trieFree</span><span class="params">(Trie *obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUMS; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj-&gt;children[i]) &#123;</span><br><span class="line">            trieFree(obj-&gt;children[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完整字典树代码"><a href="# 完整字典树代码" class="headerlink" title="完整字典树代码"></a>完整字典树代码 </h3><p> 上面的代码汇总在一起就是完整的字典树的最基础的版本了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUMS (26)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> *<span class="title">children</span>[<span class="title">NUMS</span>];</span>  <span class="comment">// 子节点指针数组，用于存储子节点的指针</span></span><br><span class="line">    <span class="type">bool</span> isEnd;  <span class="comment">// 表示当前节点是否为一个单词的结束节点</span></span><br><span class="line">    <span class="type">char</span> padding[<span class="number">7</span>];  <span class="comment">// 用于字节对齐的占位</span></span><br><span class="line">&#125; Trie;</span><br><span class="line"></span><br><span class="line">Trie* <span class="title function_">trieCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    Trie *node = (Trie *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Trie));</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to create a trie node\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;sizeof(Trie) = %d\n&quot;, sizeof(Trie));  // x64, 216</span></span><br><span class="line">    <span class="built_in">memset</span>(node-&gt;children, <span class="number">0</span>, <span class="keyword">sizeof</span>(Trie));</span><br><span class="line">    node-&gt;isEnd = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trieInsert</span><span class="params">(Trie *obj, <span class="type">char</span> *word)</span> &#123;</span><br><span class="line">    Trie* curr = obj;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; word[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> index = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;children[index] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Trie* child = trieCreate();</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;failed to create a new trie\r\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr-&gt;children[index] = child;</span><br><span class="line">            curr-&gt;children[index]-&gt;isEnd = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    curr-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">trieSearch</span><span class="params">(Trie *obj, <span class="type">char</span> *word)</span> &#123;</span><br><span class="line">    Trie* curr = obj;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; word[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> index = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;children[index] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr-&gt;isEnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">trieStartsWith</span><span class="params">(Trie *obj, <span class="type">char</span> *prefix)</span> &#123;</span><br><span class="line">    Trie* curr = obj;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; prefix[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> index = prefix[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;children[index] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trieFree</span><span class="params">(Trie *obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUMS; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj-&gt;children[i]) &#123;</span><br><span class="line">            trieFree(obj-&gt;children[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    Trie *root = trieCreate();</span><br><span class="line"></span><br><span class="line">    trieInsert(root, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line">    trieInsert(root, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search apple: %s\n&quot;</span>, trieSearch(root, <span class="string">&quot;apple&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search banana: %s\n&quot;</span>, trieSearch(root, <span class="string">&quot;banana&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search car: %s\n&quot;</span>, trieSearch(root, <span class="string">&quot;car&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search prefix bana: %s\n&quot;</span>, trieStartsWith(root, <span class="string">&quot;bana&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    trieFree(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度"><a href="# 复杂度" class="headerlink" title="复杂度"></a>复杂度 </h3><p> 时间复杂度：初始化为 $O(1)$，其余操作为 $O(|S|)$，其中 $|S|$ 是每次插入或查询的字符串的长度。</p>
<p>空间复杂度：$O(|T| \times \Sigma)$，其中 $|T|$ 为所有插入字符串的长度之和，$\Sigma$ 为字符集的大小。</p>
<h2 id="为什么根节点不包含任何字符"><a href="# 为什么根节点不包含任何字符" class="headerlink" title="为什么根节点不包含任何字符"></a>为什么根节点不包含任何字符 </h2><p> 字典树的根节点不包含任何字符是为了保持数据结构的一致性和简洁性。每个节点代表一个字符，根节点是整个字典树的起始点，它并不代表具体的字符。</p>
<ul>
<li>如果根节点包含一个字符，那么在插入和搜索操作时就需要额外的处理逻辑。例如，在搜索一个字符串时，需要先判断根节点的字符是否匹配，然后再进入下一层的子节点进行匹配。这样的处理逻辑会增加代码的复杂性。</li>
<li>而将根节点作为一个特殊的节点，不包含任何字符，可以简化操作。在搜索一个字符串时，直接从根节点开始匹配 <strong> 下一层的子节点</strong>（<code>node-&gt;children[x]</code>）即可，不需要额外的判断逻辑。这样的设计使得字典树的实现更加简单和统一。</li>
</ul>
<h2 id="为什么字典树空间复杂度相对较高"><a href="# 为什么字典树空间复杂度相对较高" class="headerlink" title="为什么字典树空间复杂度相对较高"></a>为什么字典树空间复杂度相对较高 </h2><p> 字典树是一种以空间换时间的数据结构（空间复杂度相对较高）。这是因为 <strong> 它需要存储每个节点的子节点指针 </strong>，具体来说，字典树的空间复杂度与字典树中存储的字符串数量和字符串的平均长度相关。<strong> 每个节点都需要存储一个指向下一个字符节点的指针</strong>，而每个字符串的字符数量会决定树的深度。因此，当字典树中包含大量的字符串或者字符串的平均长度较长时，字典树的空间复杂度就相对较高。</p>
<h2 id="哈希表实现的字典树"><a href="# 哈希表实现的字典树" class="headerlink" title="哈希表实现的字典树"></a>哈希表实现的字典树 </h2><p> 字典树基础班很容易，但很可能会出现一些延伸。</p>
<p>对于上面是 26 个字符的，我们很容易用 ASCII 找到对应索引，如果字符可能性比较多，用数组可能浪费的空间比较大，那我们也可以用哈希表实现字典树。使用哈希表替代数组，其实逻辑是一样的，只需要判断时候用哈希表判断是否存在对应的 key 即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uthash/src/uthash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    +-----------------------+</span></span><br><span class="line"><span class="comment">    |         Trie          |</span></span><br><span class="line"><span class="comment">    +-----------------------+</span></span><br><span class="line"><span class="comment">    |   ch                  |</span></span><br><span class="line"><span class="comment">    |   isEnd               |      +-----------------------+</span></span><br><span class="line"><span class="comment">    |   children            | ---&gt; |         Trie          |</span></span><br><span class="line"><span class="comment">    |   hh                  |      +-----------------------+</span></span><br><span class="line"><span class="comment">    +-----------------------+</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> *<span class="title">children</span>;</span></span><br><span class="line">    UT_hash_handle hh;</span><br><span class="line">&#125; Trie;</span><br><span class="line"></span><br><span class="line">Trie* <span class="title function_">trieCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    Trie *node = (Trie *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Trie));</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to create a trie node\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;ch = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    node-&gt;isEnd = <span class="literal">false</span>;</span><br><span class="line">    node-&gt;children = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trieInsert</span><span class="params">(Trie *root, <span class="type">char</span> *word)</span> &#123;</span><br><span class="line">    Trie *curr = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; word[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        Trie *child = <span class="literal">NULL</span>;</span><br><span class="line">        HASH_FIND(hh, curr-&gt;children, &amp;word[i], <span class="keyword">sizeof</span>(<span class="type">char</span>), child);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            child = trieCreate();</span><br><span class="line">            child-&gt;ch = word[i];</span><br><span class="line">            HASH_ADD(hh, curr-&gt;children, ch, <span class="keyword">sizeof</span>(<span class="type">char</span>), child);</span><br><span class="line">        &#125;</span><br><span class="line">        curr = child;</span><br><span class="line">    &#125;</span><br><span class="line">    curr-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">trieSearch</span><span class="params">(Trie *root, <span class="type">char</span> *word)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trie *curr = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; word[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        Trie *child = <span class="literal">NULL</span>;</span><br><span class="line">        HASH_FIND(hh, curr-&gt;children, &amp;word[i], <span class="keyword">sizeof</span>(<span class="type">char</span>), child);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr-&gt;isEnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">trieStartsWith</span><span class="params">(Trie *root, <span class="type">char</span> *prefix)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trie *curr = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; prefix[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        Trie *child = <span class="literal">NULL</span>;</span><br><span class="line">        HASH_FIND(hh, curr-&gt;children, &amp;prefix[i], <span class="keyword">sizeof</span>(<span class="type">char</span>), child);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trieFree</span><span class="params">(Trie *root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Trie *curr, *tmp;</span><br><span class="line">    HASH_ITER(hh, root-&gt;children, curr, tmp) &#123;</span><br><span class="line">        trieFree(curr-&gt;children);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    Trie *root = trieCreate();</span><br><span class="line"></span><br><span class="line">    trieInsert(root, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line">    trieInsert(root, <span class="string">&quot;+861**01[]&#x27;;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search apple: %s\n&quot;</span>, trieSearch(root, <span class="string">&quot;apple&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search +861**01[]&#x27;;/: %s\n&quot;</span>, trieSearch(root, <span class="string">&quot;+861**01[]&#x27;;/&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search car: %s\n&quot;</span>, trieSearch(root, <span class="string">&quot;car&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search prefix app: %s\n&quot;</span>, trieStartsWith(root, <span class="string">&quot;app&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    trieFree(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面为程序运行的结果。可以看到，使用哈希表实现字典树，可以处理的字符种类不再是仅限于英文字母。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Search apple: Found</span><br><span class="line">Search +861**01[]&#x27;;/: Found</span><br><span class="line">Search car: Not Found</span><br><span class="line">Search prefix app: Found</span><br></pre></td></tr></table></figure>

<p>关于 <code>HASH_FIND</code>、<code>HASH_ADD</code> 和 <code>HASH_ITER</code> 的使用可以看 <a href="https://troydhanson.github.io/uthash/userguide.html#_general_macros"> 这里</a>。</p>
<blockquote>
<p>参考连接：<a href="https://segmentfault.com/a/1190000040801084">https://segmentfault.com/a/1190000040801084</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>字典树</category>
      </categories>
      <tags>
        <tag>字典树</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>项目之线程池原理与实现</title>
    <url>/posts/240303201855.html</url>
    <content><![CDATA[<p><strong>线程池（Thread Pool）</strong>是一种基于 <strong> 池化思想 </strong> 管理线程的工具，经常出现在多线程服务器中，如 MySQL。</p>
<p>线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。<strong>线程池维护多个线程，等待监督管理者（worker）分配可并发执行的任务</strong>。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。</p>
<span id="more"></span>

<h1 id="为什么选择线程池"><a href="# 为什么选择线程池" class="headerlink" title="为什么选择线程池"></a>为什么选择线程池 </h1><p> 创建线程可能是非常昂贵的。通常每个线程都会执行几乎相同的任务，包括创建线程、执行任务和销毁线程等。线程本身相当 heavy —— 创建或销毁线程会占用很多本来想要执行的任务时间。因此，<strong>重用线程是一个很好的选择</strong>。</p>
<p>线程池的另一个好处是它可以防止系统过载（overloaded），它允许 <strong> 限制线程数量、任务排队，并仅在线程可用时运行任务</strong>。</p>
<blockquote>
<p>线程池维持固定数量的线程，并等待执行特定任务。该线程池可以设计为根据您需要完成的工作量进行扩展，但我更喜欢 <strong> 指定固定数量的线程 </strong>。为了确定这个数量，通常可以考虑<strong> 使用系统上的核心 / 处理器数量加一</strong>。</p>
</blockquote>
<h1 id="线程池的好处"><a href="# 线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处 </h1><p> 使用线程池可以带来一系列好处：</p>
<ul>
<li>降低资源消耗（系统资源）：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。</li>
<li>提高线程的可管理性（系统资源）：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</li>
<li>提高响应速度（任务响应）：任务到达时，无需等待线程创建即可立即执行。</li>
</ul>
<h1 id="线程池解决的问题"><a href="# 线程池解决的问题" class="headerlink" title="线程池解决的问题"></a>线程池解决的问题 </h1><p> 线程池解决的核心问题就是资源管理问题。<strong>在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入</strong>。这种不确定性将带来以下若干问题：</p>
<ul>
<li>频繁申请 / 销毁资源和调度资源：将带来额外的消耗，可能会非常巨大。</li>
<li>对资源无限申请缺少抑制手段：易引发系统资源耗尽的风险。</li>
<li>系统无法合理管理内部的资源分布：会降低系统的稳定性。</li>
</ul>
<h1 id="线程池如何工作"><a href="# 线程池如何工作" class="headerlink" title="线程池如何工作"></a><a href="https://jenkov.com/tutorials/java-concurrency/thread-pools.html#how-a-thread-pool-works">线程池如何工作 </a></h1><p> 可以将任务传递到线程池，而不是为每个任务启动一个新线程来并发地执行。一旦池中有任何空闲线程（idle threads），任务就会分配给其中一个空闲线程并执行。在内部，任务被插入到阻塞队列（Blocking Queue）中，池中的线程将从该队列中出队。当一个新任务被插入队列时，其中一个空闲线程将成功地将其出队并执行它。池中的其余空闲线程将被阻塞，等待任务出队。</p>
<img src="../images/projects/c-thread-pool/thread-pool-1.png" alt="线程池如何工作" width="100%" height="100%">

<p>何为阻塞队列（Blocking Queue）？</p>
<img src="../images/projects/c-thread-pool/blocking-queue.png" alt="阻塞队列" width="100%" height="100%">

<h1 id="C-Thread-Pool"><a href="#C-Thread-Pool" class="headerlink" title="C-Thread-Pool"></a>C-Thread-Pool</h1><p>后续内容是对基于 C 语言实现的线程池的开源项目 <a href="https://github.com/Pithikos/C-Thread-Pool">C-Thread-Pool</a> 的学习。</p>
<h2 id="公共接口"><a href="# 公共接口" class="headerlink" title="公共接口"></a>公共接口</h2><table>
<thead>
<tr>
<th>Function example</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>thpool_init(4)</code></td>
<td>Will return a new threadpool with <code>4</code> threads.</td>
</tr>
<tr>
<td><code>thpool_add_work(thpool,func_p,arg_p)</code></td>
<td>Will add new work to the pool. Work is simply a function. You can pass a single argument to the function if you wish. If not, <code>NULL</code> should be passed.</td>
</tr>
<tr>
<td><code>thpool_wait(thpool)</code></td>
<td>Will wait for all jobs (both in queue and currently running) to finish.</td>
</tr>
<tr>
<td><code>thpool_destroy(thpool)</code></td>
<td>This will destroy the threadpool. If jobs are currently being executed, then it will wait for them to finish.</td>
</tr>
<tr>
<td><code>thpool_pause(thpool)</code></td>
<td>All threads in the threadpool will pause no matter if they are idle or executing work.</td>
</tr>
<tr>
<td><code>thpool_resume(thpool)</code></td>
<td>If the threadpool is paused, then all threads will resume from where they were.</td>
</tr>
<tr>
<td><code>thpool_num_threads_working(thpool)</code></td>
<td>Will return the number of currently working threads.</td>
</tr>
</tbody></table>
<h2 id="接口使用实例"><a href="# 接口使用实例" class="headerlink" title="接口使用实例"></a>接口使用实例</h2><p>We create a pool of 4 threads and then add 40 tasks to the pool (20 task1 functions and 20 task2 functions). task1 and task2 simply print which thread is running them.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">task1</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Task1, Thread #%u working on %d\n&quot;</span>, (<span class="type">int</span>)pthread_self(), (<span class="type">int</span>)(<span class="type">uintptr_t</span>)arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">task2</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Task2, Thread #%u working on %d\n&quot;</span>, (<span class="type">int</span>)pthread_self(), (<span class="type">int</span>)(<span class="type">uintptr_t</span>)arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Making threadpool with 4 threads&quot;</span>);</span><br><span class="line">    threadpool thpool = thpool_init(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Adding 40 tasks to threadpool&quot;</span>);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">        thpool_add_work(thpool, (<span class="type">void</span> (*)(<span class="type">void</span>*))(i % <span class="number">2</span> ? task1 : task2), (<span class="type">void</span>*)(<span class="type">uintptr_t</span>)i);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    thpool_wait(thpool);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Killing threadpool&quot;</span>);</span><br><span class="line">    thpool_destroy(thpool);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As soon as we add the tasks to the pool, the threads will run them. It can happen that you see a single thread running all the tasks (highly unlikely). It is up the OS to decide which thread will run what. So it is not an error of the thread pool but rather a decision of the OS.</p>
<h2 id="数据结构组织关系"><a href="# 数据结构组织关系" class="headerlink" title="数据结构组织关系"></a>数据结构组织关系</h2><img src="../images/projects/c-thread-pool/thread-pool-struct.png" alt="线程池数据结构组织关系" width="100%" height="100%">

<p><a href="https://github.com/Pithikos/C-Thread-Pool">C-Thread-Pool</a> 实现的线程池包括如下数据结构：</p>
<ul>
<li>线程池数据结构：包括申请创建的每个线程的地址、任务队列等；</li>
<li>线程数据结构：包括创建的线程、线程所属的线程池等；</li>
<li>任务队列数据结构：包括一个是否存在任务的信号量；</li>
<li>任务数据结构；</li>
<li>信号量数据结构。</li>
</ul>
<h2 id="二进制信号量接口"><a href="# 二进制信号量接口" class="headerlink" title="二进制信号量接口"></a>二进制信号量接口</h2><img src="../images/projects/c-thread-pool/thread-pool-bsem-method.png" alt="线程池的二进制信号量接口" width="100%" height="100%">

<h2 id="线程池接口"><a href="# 线程池接口" class="headerlink" title="线程池接口"></a>线程池接口</h2><img src="../images/projects/c-thread-pool/thread-pool-thpool-method.png" alt="线程池的线程池接口" width="100%" height="100%">

<h3 id="线程池初始化"><a href="# 线程池初始化" class="headerlink" title="线程池初始化"></a>线程池初始化 </h3><p> 流程图左一：<code>struct thpool_* thpool_init(int num_threads)</code></p>
<ol>
<li>分配线程池内存空间</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">thpool_</span> &#123;</span></span><br><span class="line">    thread** threads;                  <span class="comment">// 指向一组线程（指针数组）</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> num_threads_alive;    <span class="comment">// 当前活跃的线程数量</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> num_threads_working;  <span class="comment">// 当前工作中的线程数量</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> thcount_lock;      <span class="comment">// used for thread count etc</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> threads_all_idle;   <span class="comment">// signal to thpool_wait</span></span><br><span class="line">    jobqueue jobqueue;                 <span class="comment">// 作业队列</span></span><br><span class="line">&#125; thpool_;</span><br><span class="line"></span><br><span class="line">thpool_* thpool_p = (<span class="keyword">struct</span> thpool_*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> thpool_));</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>初始化任务队列</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">jobqueue_init(&amp;thpool_p-&gt;jobqueue);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建线程池中的二级指针 <code>thpool_p-&gt;threads</code>，它指向一个 <code>struct thread *</code> 类型指针的 <strong> 指针数组</strong>。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">thpool_p-&gt;threads = (<span class="keyword">struct</span> thread**)<span class="built_in">malloc</span>(num_threads * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> thread*));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>后续将在 <code>thread_init()</code> 函数中，为每个指向 <code>struct thread *</code> 的指针分配一段内存空间。正因为是在 <strong> 其它函数内部 </strong> 为这里申请的二级指针指向的指针数组中的每个指针分配一段内存空间，所以在 <code>thread_init()</code> 函数中使用了二级指针。<a href="https://pursue26.github.io/posts/240224193217.html#%E4%BE%8B%E5%AD%90%E4%BA%8C">看这里，为什么用二级指针</a></p>
</blockquote>
<ol start="4">
<li>初始化一组线程</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_threads; i++) &#123;</span><br><span class="line">    thread_init(thpool_p, &amp;thpool_p-&gt;threads[i], i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程池添加任务"><a href="# 线程池添加任务" class="headerlink" title="线程池添加任务"></a>线程池添加任务 </h3><p> 流程图左二：<code>int thpool_add_work(thpool_* thpool_p, void (*function_p)(void*), void* arg_p)</code></p>
<ol>
<li>为添加的任务分配一块内存空间</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">job</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job</span>* <span class="title">next</span>;</span>             <span class="comment">// 指向下一个 job</span></span><br><span class="line">    <span class="type">void</span> (*function)(<span class="type">void</span>* arg);  <span class="comment">// 调用的 job 的函数，作为线程入口函数</span></span><br><span class="line">    <span class="type">void</span>* arg;                    <span class="comment">// 调用的 job 的函数的参数，作为线程入口函数的参数</span></span><br><span class="line">&#125; job;</span><br><span class="line"></span><br><span class="line">job* newjob = (<span class="keyword">struct</span> job*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> job));</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>根据入参初始化函数指针和函数参数</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">newjob-&gt;function = function_p;</span><br><span class="line">newjob-&gt;arg = arg_p;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>将任务添加到指定的队列中</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">jobqueue_push(&amp;thpool_p-&gt;jobqueue, newjob);</span><br></pre></td></tr></table></figure>

<p>关注点：</p>
<ol>
<li><p>对于任务队列中 <strong> 没有任务时的处理 </strong>：<br> 不是采用轮询的方式，而是使用条件变量 <code>has_jobs-&gt;cond</code>，在入队 / 出队任务后，若仍有任务在队列中，则唤醒条件变量。</p>
</li>
<li><p>对于 <strong> 函数指针类型转换的处理 </strong>：<br> 自定义的函数原型可以与 api 的原型不一致。例如：这里 api 的函数指针原型为<code>void (*)(void*)</code>，而「接口使用实例」中的 task1 和 task2 的函数原型为<code>void* (*)(void*)</code>。</p>
</li>
</ol>
<h3 id="线程池等待"><a href="# 线程池等待" class="headerlink" title="线程池等待"></a>线程池等待 </h3><p> 流程图左三：<code>void thpool_wait(thpool_* thpool_p)</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;thpool_p-&gt;thcount_lock);</span><br><span class="line"><span class="keyword">while</span> (thpool_p-&gt;jobqueue.len || thpool_p-&gt;num_threads_working) &#123;</span><br><span class="line">    pthread_cond_wait(&amp;thpool_p-&gt;threads_all_idle, &amp;thpool_p-&gt;thcount_lock);</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;thpool_p-&gt;thcount_lock);</span><br></pre></td></tr></table></figure>

<p>这个函数的工作原理是：</p>
<ol>
<li>获取锁，避免多个线程同时访问共享资源（这里是指 <code>thpool_</code> 结构中的计数变量）；</li>
<li>当任务队列中有任务或有正在处理任务的工作线程时，继续等待：<ul>
<li>这个线程会等待在条件变量 <code>threads_all_idle</code> 上，同时释放 <code>thcount_lock</code> 互斥锁（以让其它线程有机会拿到锁），并阻塞在这个条件变量上。这样其它线程可以在条件满足时唤醒等待在 <code>threads_all_idle</code> 条件变量上的这个线程。</li>
<li>如果这个线程被其它线程唤醒后，这个线程会重新尝试获取 <code>thcount_lock</code> 互斥锁。一旦获取到互斥锁后，它会再次检查 while 条件，若条件成立，说明还有任务或工作线程。那么，这个线程会继续等待在条件变量上，等待被通知唤醒。</li>
</ul>
</li>
<li>直到所有任务都已经执行完毕且所有线程都是空闲的，释放锁。</li>
</ol>
<p>关注点：</p>
<ol>
<li>这个函数有何作用？用在哪里？<br>用在销毁线程池之前，<strong>安全地执行完 </strong> 所有正在执行、尚未执行的任务。</li>
</ol>
<h3 id="线程池销毁"><a href="# 线程池销毁" class="headerlink" title="线程池销毁"></a>线程池销毁 </h3><p> 流程图右一：<code>void thpool_destroy(thpool_* thpool_p)</code></p>
<ol>
<li>复位全局活跃标志</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">threads_keepalive = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>复位的目的是，通过这个标志结束每个活跃线程的轮询（详见 <code>thread_do</code> 函数），并等待被唤醒后退出。</p>
<ol start="2">
<li>通过条件变量 <code>bsem_p-&gt;cond</code> 的唤醒，线程退出</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Give one second to kill idle threads */</span></span><br><span class="line"><span class="type">double</span> TIMEOUT = <span class="number">1.0</span>;</span><br><span class="line"><span class="type">time_t</span> start, end;</span><br><span class="line"><span class="type">double</span> tpassed = <span class="number">0.0</span>;</span><br><span class="line">time(&amp;start);</span><br><span class="line"><span class="keyword">while</span> (tpassed &lt; TIMEOUT &amp;&amp; thpool_p-&gt;num_threads_alive) &#123;</span><br><span class="line">    bsem_post_all(thpool_p-&gt;jobqueue.has_jobs);</span><br><span class="line">    time(&amp;end);</span><br><span class="line">    tpassed = difftime(end, start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Poll remaining threads */</span></span><br><span class="line"><span class="keyword">while</span> (thpool_p-&gt;num_threads_alive) &#123;</span><br><span class="line">    bsem_post_all(thpool_p-&gt;jobqueue.has_jobs);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里被唤醒后，<code>thread_do</code> 函数中的 <code>bsem_wait</code> 将被唤醒，随之跳出轮询并线程退出。</p>
<ol start="3">
<li>销毁任务队列</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">jobqueue_destroy(&amp;thpool_p-&gt;jobqueue);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>其余堆上内存的释放</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; threads_total; n++) &#123;</span><br><span class="line">    thread_destroy(thpool_p-&gt;threads[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(thpool_p-&gt;threads);</span><br><span class="line"><span class="built_in">free</span>(thpool_p);</span><br></pre></td></tr></table></figure>

<p>关注点：</p>
<ol>
<li>对于 <strong> 线程释放的处理 </strong>：<br> 可以定义一个条件变量来唤醒所有线程，通过复位 <code>threads_keepalive</code> 标志，使得在 <code>thread_do</code> 中被唤醒的线程，跳过任务执行（if）和轮询（while），达到优雅地退出。</li>
<li>对于 <strong> 唤醒线程的处理方式 </strong>：<br> 超时时间内不断地、快速地唤醒所有活跃线程 + 固定时间轮询唤醒剩余活跃线程。为什么先后执行这两种方式，<strong>直接执行第二种方式不行吗</strong>？</li>
</ol>
<h3 id="线程池暂停与恢复"><a href="# 线程池暂停与恢复" class="headerlink" title="线程池暂停与恢复"></a>线程池暂停与恢复</h3><ol>
<li>注册信号并绑定线程暂停函数，实现在收到信号时暂停线程</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in function thread_do()</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">sigemptyset(&amp;act.sa_mask);</span><br><span class="line">act.sa_flags = SA_ONSTACK;</span><br><span class="line">act.sa_handler = thread_hold;</span><br><span class="line"><span class="keyword">if</span> (sigaction(SIGUSR1, &amp;act, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">    err(<span class="string">&quot;thread_do(): cannot handle SIGUSR1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">thread_hold</span><span class="params">(<span class="type">int</span> sig_id)</span> &#123;</span><br><span class="line">    (<span class="type">void</span>)sig_id;</span><br><span class="line">    threads_on_hold = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (threads_on_hold) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>流程图右二（上），暂停：<code>void thpool_pause(thpool_* thpool_p)</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; thpool_p-&gt;num_threads_alive; n++) &#123;</span><br><span class="line">    pthread_kill(thpool_p-&gt;threads[n]-&gt;pthread, SIGUSR1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数原型：<code>int pthread_kill(pthread_t thread, int sig)</code></p>
<p>函数描述：<code>pthread_kill()</code>函数向与调用者在同一进程中的线程 <code>thread</code> 发送信号 <code>sig</code>。该信号会<strong> 异步地 </strong> 被发送到 <code>thread</code> 线程中。发送成功返回 0，不成功返回非 0。</p>
<p>对「异步地」的理解：<code>pthread_kill()</code>函数向目标线程发送信号时，<strong>不会阻塞调用线程的执行 </strong>。换句话说，调用<code>pthread_kill()</code> 函数发送信号是一个异步操作，<strong>它会立即返回，而不会等待目标线程处理完信号后再继续执行</strong>。这意味着调用线程可以继续执行自己的任务，而不必等待目标线程对接收到的信号做出响应。</p>
<ol start="3">
<li>流程图右二（下），恢复：<code>void thpool_resume(thpool_* thpool_p)</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(<span class="type">void</span>)thpool_p;</span><br><span class="line">threads_on_hold = <span class="number">0</span>;  <span class="comment">// change its value here or thread_hold_on()</span></span><br></pre></td></tr></table></figure>

<p>关注点：</p>
<ol>
<li>线程池暂停与恢复函数是 <strong> 如何控制线程状态的 </strong>？<br> 每个线程会注册一个信号，并绑定线程暂停函数。当线程池发出暂停时，每一个线程都将会收到一个暂停信号，这将触发执行 <code>thread_hold</code> 函数，进入循环睡眠，实现线程的暂停；当线程池发出恢复时，将 <code>threads_on_hold</code> 复位，<code>thread_hold</code> 函数将退出循环睡眠，线程继续执行。</li>
</ol>
<h2 id="线程接口"><a href="# 线程接口" class="headerlink" title="线程接口"></a>线程接口 </h2><p> 所有的线程接口都被 <code>static</code> 关键字修饰。</p>
<img src="../images/projects/c-thread-pool/thread-pool-thread-method.png" alt="线程池的线程接口" width="100%" height="100%">

<h3 id="线程初始化"><a href="# 线程初始化" class="headerlink" title="线程初始化"></a>线程初始化 </h3><p> 流程图左一：<code>static int thread_init(thpool_* thpool_p, struct thread** thread_p, int id)</code></p>
<ol>
<li>为线程池中的线程分配内存空间</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*thread_p = (<span class="keyword">struct</span> thread*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> thread));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么用二级指针作为入参？参考「线程池初始化 -3」小节。</p>
</blockquote>
<ol start="2">
<li>指定线程所属的线程池</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(*thread_p)-&gt;thpool_p = thpool_p;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这一步有何作用？通过线程找到对应的线程池，多个线程可以互斥地改变对应线程池的共享计数资源（发生在<code>thread_do</code>）。</p>
</blockquote>
<ol start="3">
<li>创建线程，并指定 start_routine 函数指针</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建实际线程，并开始执行 thread_do 函数（Worker 函数，其内部执行 Job 函数）</span></span><br><span class="line"><span class="comment"> * int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment"> * (void* (*)(void*))是一个强制类型转换，将 thread_do 函数类型强转为 start_routine 的 void *(*) (void *)类型</span></span><br><span class="line"><span class="comment"> * pthread_detach 函数用于将指定的线程分离出去，主线程不再需要通过 pthread_join 方式回收资源，被分离的线程结束后由 OS 回收资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">pthread_create(&amp;((*thread_p)-&gt;pthread), <span class="literal">NULL</span>, (<span class="type">void</span>* (*)(<span class="type">void</span>*))thread_do, (*thread_p));</span><br><span class="line">pthread_detach((*thread_p)-&gt;pthread);</span><br></pre></td></tr></table></figure>

<h3 id="线程 worker"><a href="# 线程 worker" class="headerlink" title="线程 worker"></a>线程 worker</h3><p>这是核心代码，Worker 作为一个无休止的循环，唯一的被中断是调用 <code>thpool_destroy()</code> 或程序退出。它作为一个 Worker，在内部执行不断入队的 Job。</p>
<ol>
<li>获取线程所属的线程池</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">thpool_* thpool_p = thread_p-&gt;thpool_p;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>互斥地更新活跃线程数量</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;thpool_p-&gt;thcount_lock);</span><br><span class="line">thpool_p-&gt;num_threads_alive += <span class="number">1</span>;</span><br><span class="line">pthread_mutex_unlock(&amp;thpool_p-&gt;thcount_lock);</span><br></pre></td></tr></table></figure>

<p>在「线程初始化」中，每创建一个线程示例，都会执行对应的启动例程，即<code>thread_do</code>，这个线程运行起来，共享计数量加一。</p>
<ol start="3">
<li>进入轮询（poll），等待条件变量的唤醒通知</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (threads_keepalive) &#123;</span><br><span class="line">    bsem_wait(thpool_p-&gt;jobqueue.has_jobs);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>有任务被唤醒，执行 Job 任务</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (threads_keepalive) &#123;</span><br><span class="line">    job* job_p = jobqueue_pull(&amp;thpool_p-&gt;jobqueue);</span><br><span class="line">    job_p-&gt;function(job_p-&gt;arg);</span><br><span class="line">    <span class="built_in">free</span>(job_p);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>无任务被唤醒，即是被 <code>thpool_destroy()</code> 唤醒，if 不成立，while 不成立，退出轮询，活跃线程退出。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;thpool_p-&gt;thcount_lock);</span><br><span class="line">thpool_p-&gt;num_threads_alive--;</span><br><span class="line">pthread_mutex_unlock(&amp;thpool_p-&gt;thcount_lock);</span><br></pre></td></tr></table></figure>

<h2 id="队列接口"><a href="# 队列接口" class="headerlink" title="队列接口"></a>队列接口 </h2><p> 任务队列主要是为线程服务的。当有新任务到来时，<code>thpool_add_work</code> 调用 push 函数将新任务插入队尾；当线程检测到任务队列有任务时，及时将任务从队列中 pull 并执行它。</p>
<img src="../images/projects/c-thread-pool/thread-pool-queue-method.png" alt="线程池的任务队列接口" width="100%" height="100%">

<p>具体接口在这里就不再介绍了，直接看流程吧，挺详细的。核心就在 push&amp;pull 操作后，若队列中仍有剩余任务，则会通知唤醒等待在条件变量上的线程，从而使得线程可以执行队列中的任务；当队列为空时，不再通知唤醒线程，线程便会阻塞在条件变量上。</p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://nachtimwald.com/2019/04/12/thread-pool-in-c/">https://nachtimwald.com/2019/04/12/thread-pool-in-c/</a></li>
<li><a href="https://smartyue076.github.io/2023/06/10/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/">https://smartyue076.github.io/2023/06/10/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1849765">https://cloud.tencent.com/developer/article/1849765</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>项目</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>项目之确定性网络 CSQF</title>
    <url>/posts/231202180319.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，这个密码看着不太对，请再试试。" data-whm="抱歉，这个文章不能被校验，不过您还是能看看解密后的内容。">
  <script id="hbeData" type="hbeData" data-hmacdigest="f900294b10ea2c17ba8ad6e1cb9540716308e7bf4d2f8d919071c6c7b688ab15">296e0e11e5707115aade5aa86d82978cc8e0b187f577349bdaaf317eeb18ec71ab79204b18f543c45345a919b6c6480fc5b6b0b1d61b45697f17894ab703ed86effb66880f403bf18e2ee3355841c7133aed0638021c4781c33b284aee4a62103a40743c50ce7002f19ca3c1246e26bdc8495be3061037492b4a58483660627c45538bdf0193b73442be64f47dd8fbbd7d8544b36c52aa1033dc6db92fdbb2e171dc0851113db5c30a043a443e5a8e304e3597996bf59f5691be1fa6c3acd134d65b59d694d4a6f418a06533a1fb3f3cc5eda7648387e77391b930701ada7ccaae90959fea7a9748a59376297ee770ba0e7ac5c4dc98fadec8d9f3c377459d4f59554b2f7a2a49f2b1acdb1a55b260283fe1f00435d0461dd060176da754f805cccc7ff08d299baace8293cdce25ce7030d7479704e209ea6df6e8be0d0fbaa67735f2516f57531edf410f6c8b1106e7fc1b2a718d617a0b19944df408fbcefc83042b9d40ef05e1a21c8422164a44abbf089381b3c735c15eadd2887a0fd83513ae05ad80ac2c2c61d2f91dcfd550a0973f920395a3109c81cffd46834f929cd318abb3553db9de64b0c3a29891d9404842d66ee5e69217231e7ff7a44b5672a580a6ebe3cb13f75f5b372bc5bb2a286a46c6c3e18eea3a54cfde87c16b76ce007d6247251d0802e932e3e0316023ad7b3e91b99300aca5fca5826c35b150cc9dde9b6428fbabb38cfe2353fde7960dd0afc1d5072f36b84dc87fc96488ed94e222454576c48c580d2c6bd6c9d8da57020161f1e2e26dd4a595603fd60b78dd98b9c53dd00bc86488a20ecab0b76c70a0a337bf8eefdd6a74b1e5ed48aa73873ae3d25f87a2fa6a5a55808a855cda73426bfbf432580b4596a221edb67bf7a2b5cc198927de492dc5194f5efe8c68efa9a4699298412e5db91048a6db7b42acef51fe1013548ee87034636fc7db7c4b9c736016a7b1ca2bfaf37a9a98f591955468df65ddeef906f97df35f7fa21dbd9bc073417adb290756dbabdda2ef75249ed869e3323ddb394adf2c3a1dc5f92a0f012e71cfba6106a3cff032ae81d9d23a7fb33085097abe5fb4c5e0c28550291aab26cd726681ab0eb99699bf1508efdd3d83ff92cf17ba4351af4d793d7755ab937a71e89da1f24561f5499c4f1eddb7ed59a0ef1747871285451f138187706119450cf4f2b88423b51d14b6d0eb6ebdd02a8109710df98d10cdf9b3d46a919a7618baaae250c6152504637548920d413d5cd860df8630aa0b908d18f7dd2f365d2e5a150da92735b46143b29a6cacda987da4689ec0aca308c9fce87f7134010f3e3d42248ebcf551b1f155a94545f16cbde983aa52fb547f305d3c875b084bfedb8538f3fa8f3461d1bd7ed217c133025d6cd0ec19c504778eb173ff04c5341b75835cc3995ccf85b74a4d5e770357b169129c890dfb7ad391d92dd1a11571430d3cce57582abb9551193152eb50a949a0d1140de148aab44beef0b8539991d55a5b4bd55d7219d2d388112600ce1f73befce7dab356f915c500bd59b612875cc930b916aa212151f16a5397ef4e1aa72f5c9d9c303720a5a38c57a39bfcd5a7e9da805068cd78fb0534d4b9d614394d8f240908ac34423cfb78bafeb21d1addb401219570a2061a7f1a6b3d0fa86b2f7ac77721db3b9ba093892902172811c938c5867ef253281aeff2237f4a856b05f79779ad58351696d1b9d8ac17fc75f60aff85fb0ccd54e83cd1077f65c445dcc34f8962739982577b2cfb02aa1614951b62d675d6a2893616902b87c3f0f0fb9e302abf067a774be3e46ee210cca82a8b13895e84b93791fad16191b676ab04e10a1736ebfde211bd6e20b3321982d4ac98f048329d927c6f608490d29eb4fa529b7b8349a8d3f6f84ade9814e37f56a642d1ad1f59f4fdb3b3d0f96f62005d181ae047ed63ccff495100f8477485aefb26781b090e6b34043553fd7e548712f46d0615158717549905b8389d82391a9a3728d24c4f458c2bda657347382e4403874a6307afd0eb21e82d9b37440648e59bfbeab3806dc5891cd4d9ca2cda37a2aa02651de7e025f02ec5601ca8280b6b4441caa9fe0e98a8b232b2845becc96b16e5c4c0219dcdb80df3ab70b22b82941ac6e2d838fbe08c586123b0d1c9bcba3bf0189bcee1c7a3c5d36ab236e9fc16de7446899550b9fbdb092024fd28f394e3aed253dfc21f3841f34e97d936efd9ffb5afe7436ecd0555170105ac9cf6cb13943dbd682c043f452765a94b90ccc01863d355af27cdee4add33bd44c4d87b0520022fcf06794fb90c84877e1a391fdfff8397d5b2513399ddddba9c235daae6eef813ef70aff0565b02da023217700e180a2ed4a6acb611815805e54259f0901dc78f2cba3e99aa47450aec5d6d083b6e0b6c2bddba82d9d0b7503033d85d3632228e50d8fa9a19ab6be36b0b81fd394fc31d35c56ee15cfe1adcfce8e585d3ba2caa6c88262e02db56f98db80f63f8cb036f530810137e13dc0fa9dd637150e29c260107fa9c9b2393af1b15ddb31a228621f066728757619d3581e7e56750fab35aca0d58f5b8550d2535fa2753d6364262b1be51a6dc169066265bd6ae49f89f52a2274de8b2c3cf159027ea3a9bc4b910af4e0748a74a4cbf32e60f59637288a2bb8d6953d8e7305a888fa2c4538fa402a4df4ca04fef6cf8852b6affd186a177df6129adad82fb7a627bdb4b4098ccfc77d009d0352fcaf39604b845f5f70490f310a3fc307f00da71b4e31f6a45add3fe88660308539134eb591b47dacc91f3d3434885fb80c9fa2354cad7c83f399c682045ab8adcd9e7601dc964738c2373e6427670148d6fdb29c92040b0a18b40a98c44f5f72436c06168f503ee98704a66b8493423bc242c3ad31eeaf5146e53c233519abc88af8f9e08d3030c0d4bb4c8fc8bedaf872bb5edb2aec973d5ff9f02b7a1bb767899113414ab2e0d00e1da4080cfbc907a49201874a5b0a95447c12779cfac2dcd1980aee727b2bb34655abe8b9d95bce31b26d9e74226764f85faf8470580bdcffa21c900f26c6935d2c95dae0663fdd7ff714d06acbb0b8ad536fdc78520b41b0420c03ef8358a5b2663221ad4fa6d9beae02bb27120c361521cb58956432c861d378a967a8b8f7211152e358e3cfcf33ce50a4be3f9814486c7d4d8cc9d02d9756612e7d4d6533a72e8f2ef3fea5c0e872f057de0fc93110f6764684163196b36e05b9fe1cc6f2176c946afc3950a2333ca169f50681d58a1abf1c9f196ba55fa99040e5df792330d600069da3a6b415162ed5bc4463b27b32873d74f579c99254bc73aa71a0ff951929dbcc0ab1b1ecbf4979750d5bcd1a30560f0eed02982bcb236b7770679c326ecd2f98aa59d274ae569adf32162e6e0d0ed32559f98fd0cbe69e27e11e3a46cf9ab5e8a638c8135f714cec75aacf0f2198aa22012a0309d0cf0ae962b358e1538229f467c1e98cb337e3fcf54b5893fdf435f44c9e6eba13f1210b73bbda45dafc265e58de810e5ff968860988c9f6c8ffe4ed30ef65c3a805c814be003a4b59725130626a672743c0af9c232b85665efa5cbce36a6d20b3eec881cd92dd8dda41eee3e9f5e9add7e06467035a158f5c0929af5cae2ba902b98b1c1fbf0ff882870a05252e8cbc1d49cdc4a0be88b39ed4b7060fec75c4594a9ab47ea5aa4ebebc1f4ca5b4aaf69e9439c2960cec23f8e7fa4a32241ef20697d9ccfc46d86cf7a27689142681b9add4746815f2632e7ed7989cacb85577550fe02aaac5dec5914ac425e578e817ce682a651ead8c1d2d010029cb5891866399b04fe54573dfe177268fbb3441bfe6f097dbd386c4ec3310fc182e8c31b6723ec2874b2db171b5af6afa95bb2d1ac4ab4083b75e45cb81c6cab0c560784012516880b0c1d613d52fca0cd3f6252d2e1fa732b699ead4a1c28c0d7a32c5d904b968c7a2d96a5070b919282edeb26d0e7f335449fc6fbdf8ba9500a2b630b4b48398e33649640366f420f79a46fc87855167806f367e1df656f01bdee5a993185a2b77d1e78daa4b01df8f0d60e3be21a1ec02f4c401ea5f7aee4455ba24b94401f7aebd4591db776d2743127a97251d7dc1a0b25e61c2ea45664d2399a560423fd07169a432b8ccb1f72fd9afa7af11af05836c29dd7259b3fc35666795a03296d68259e9e5aacad711c2d475cfafb231c7e4378e6f6c1605b0ce4c6eb349f4edd8f507bd21b82415f0eefcd57032efeeb9fb9b3ccd68fafbf1e35c91ebee724df5cc9d6e5fcf589033ffb83241d4ce7cbc38233fec005611027d7daeb90a3444b12da21cd16823a55495e583afd4911a9518534e0089f9634394b293dd856abd4ec2aa6c62f405ebad3e4f5e47d55f1d54ea052e3245bd37bfb47419f8d12109a8bc99340b786baf8e51eea5573393ba40990545d9ec8739c85d41c11a281df2b051307a6fd68af78ae2f27a67e496d215b87579075800a5ba60aab2e2223700228e5b40841f7026ff0fb68ec6bac22bbef4701b7941781193cf70b11e1c5190c4eb106ec39ede287adf551bc7558e5d5e5f277d1bb92f881a2361fda4f7820f6858c44a1288673387404658702ffff214c98e277c69d3c15bfcac3278dc59da543a4f23a3aa4674ecf8d44f94e53c743a5340e8f1bf137f923674c7ecf38530e11c1b915b76c59fff92c08f428202c501950865016b7dbfe0f32b92557fd150b49f33815f1cc26ad30a8b913e6f4f06bba9e00bffca44e7d615322aca64bae0301d10a07f51c207ca82e7f28154606319b97586af618e18b7bdf17fbbb453cd4fd5184b41e58682b33125dc8b33ebf6977884c8d17fc7796c964b8fc8e63e77bd0a3fdc57dcd2a84acb174feba3640c1eeb97d4173d598dd29919df566df8398606536f3fdfc33e5de9b3f8ffaf65dfec3d0f0173d4ae42006c22ffab3addcfeb05b72bf35e904c626f99407700af50f84792e9b0ccd3610ff73f5f3f1058cf6f1651a94cc535dc31860e5c4449318ce65b2ba908add7b399cb2af266064e3da0f64c7b866fda395f496d9333ce633e71a2a142d5c431183772eb26dbcd8c874a2d295ec42d1089592a6a19db40bf177ca7aa10ac02c32e72990cb4350abe345fd02b38ad3ad5006c6645352c1cea5b322946f6dea9689c09d05398b644bf0bfb5947da4e826297a10965d382198854a473a091a147c310ccd77b0a98c174353150c73c9b9283309c74223e8bf75b0816679bc5b483ae82a5b7da819f63b5fe25664fce46e09a274e68b6f2fd639fe246b624f234bd41976235f3206e4d6b555734b2d927294e4c3fff55ab293d0d3b7fb089290cecff916016f439aa584c50e5235e9adb3fdcd24b80198157867ec50f10f7f600824398843d0a02f842530918e07925c091a2afd264d0ed59e96eef96de2a210facc8335e400c50d12d3102c786808234dc548bb26641b0bbdc09b32e665115c59d28d09e67fc9decb35c56b85dd2725ca04454f5b536dee5558ba3271efe7dd9faf65ed839e5de22a762fce41cfef95ff034f84b191cc3e6d1117760f73c60549c73e0b66bf7f730caeebd2740b4f8a50d4f74e40316556406947e7b4d370f05fe9c8d7518b4cfd1442f068257c455fa143e23f3589b570c870f07f0b9166d9fc53728c4f7638dc7b1258eb55ea3bfe9796401a4b6460352f653d3634f36594bd01cb89fafca0ffe76768ef9ca60a81da18cea44c0e194c603ad8984e7742b0ee82cd0962b9079bff0e90ce0676035c0c080e51bc763f267a355403efde94ee1ffeac7a7ec32caba230f9183bd3b36afaa32092c4c379a3b1a18574966b6600f38d46cdde0e8ecda99f38a4d774d3d34475c531bec9d9c7c3c1f7fb1dba58aac53571786ac20261b8ba5a62a0b9fbfe51318d81836e10269495a091a5a90d8268a951dd67fcfda2ab93c180c6fd123468bded137bb1d99648af074b22336d2bf0523efbe7f0b5d83b7a989ca3b3901227d39791b9f22e9e89bbda2a5b19280064821f4901bca4b8d762dd037dcd7ef046029a481488c6569852a0204bb900d4bd9fcbbc6dd1252639dfe3da99885d693a09bc84ed54d3e20a78823e4828b6ce78a1c19bd168244c72883be4e35f76eb4134cae2f27e67cc528318bdd6f854bca5c18e5a4acb8a44ba27b7efdd6faeefc2f4b890ce7c051feaf21c7e85601957c1d6718a668e67c9ab43dcea256f6a8b063faa006fed96ffa98f67b708e9eba5d585fbd081ea953002d1032bb0851da23a2b038f645ac58ecf256facbf7b64c450e35f86cae7f7f7e2058136881f97336246a5a8b2fb65cb668f51b7a061148f01b1f7630625d73a7e1d08a3da26739d259108c7f3faec2d1fd42ec04f09924683888921c604c39f473ab9f22ed68a916705aaf222d72237a36849d84cf574e34c3b5a58e797630749163fbb2e975c4c1109e22596d4da533bdf6c8e6a54d1117e955afab44017339dac9c873a873e49d5fccc494bc615f1166e4360d73879e1139ce4e5adcc6d1718dc787738848e67ace94c042db1fa2f9a76f24720937cb5175d588e3ce775a6740d4d24b43b0d1070ad878d1100ca30fd69d09d3919c63e790e74eac32dfba1b8ad1f2c9eaaee417955df5e593c8c52cdfeb946b16f7bcacb4ffb89244c07e2100774f6584d56a09f7651b761e4ca31682d649e5d37877aaf93eef6a3657ffd482731249e715c88f25449723a83be4573dc9d6684c153b5b698ff2cd0fd3216e3f2e23dd540d9bf2a8efd972086acc3c7ad0700997cef27d2a798c5f3e83d089cc2db6d59f6f1ad48bc8e31990e04ac36c4077d3335da3d8bd7de7786e61fa145bb9802d22c3b77c3788a62357ac894d7d351a65b5e68cf896b8301044bcd5d4f49a4ef35104b155bffa9c38926b1fce01170203dfafc976882eaa27acc11843988269d40c756b2841288769708e2d680a7b637bf8b5b43c7a3bc0c6a8f565a75cdaacc790573a57029e1fa014e3b9e8ba1696ec69d7b85221591f3e334a3053eff5a5e5fb2f74523965289a5cf0342ee27b7b10b25ea82310370d19c0d19aaf5e234faa0816abcb13cc2f095aedacce769bd240621d18dd5b4c67fbcf0ed28accdbc08bc53c303e40bea15a038b1407bf5e26173883dbaf5e9f7d8be45e7db1c5b59465cee137c5f63d500f91106c697e9d2daa652369176f7fbc555e7e80fe51dafd2ba62b82007db9eabfba41e1f0550124aa58ccca026faeac37b6ae1a6012877c05030a13688ee123b51f76ff7a527ccc5d45ef58b4eba4b971d3153ad7e23f7061aebb8f8f7f7fd7453f5d36524b2ed228dd75d6a1dc0ec9d71dc90a1565e68265aca6b253790b1afa07526390760e4eca9af6d0189d905e19de559104c3bec792c2260085c3f9348500bfc68b3fcb49d393de87019c33195a0cb05f4ef68f576410bb99dc5f505638f4e22e9d953c17aa07d566cf74d77805913ea4535e722221535f93e2d55c34a6342a66fc93b34675f6c95dda7b1174e5a8a57bed3d9448935d3189eb757cf5439fc04fe1ba5f437e3c8323f831d2b234f9d13ef34500da42c001228da06ddbe993377a0e0ae1a93c1a82335c036be5c11d2c6942e4e224e5e1947b0fc288efe424d18c43c7ed47f78dfcfb1c0f8dd03a2be6dd00c8dc416d8d85b7e9a2bd8731663c91515561aadfb23f5da558c11e321cbae93f243f2bf5e0d248ebf90dad8ab58ece9cddb7abcb4299e7ab572a2ae1c0d8a2e0a247ed19645c9e90aa46b85dba39ec4169bef04cb7fbe137c83065fef76d161499222ba96092ee6daff8def0e0331d709de8b5399c7e0343b84242d27cf44d9517ffee920071d0cd6ea8c2bc5f1c5829e65f4d7fa510855ac3301ed0d620cbcfac86df1008db0d686915cbd87c1f355fca3dc7ed1809ddf96eec891b304b8e9e29cef37ac8bcc4e0a2bf15ca239efb5740248c28878daa77ff8d0f2bf8122ebbdc1d14332616967d062360f2e64c279ed1d3910e88e7e098fc452ea99ac90094ad1acd48aa3bdc66bc05f1bb51baedf6032682d710376208ce11e5a282b9377cfb98d2bc7ffd21d310b028d87611baa75c64cf4c8205ec8d015c4a85a3a730f4b92a48f41d7c322d4038d30e7f8c609aa2345c0a46fdf8dfc0ce2f85ca480ef68c63ce4af967ba3053aac4582e61da0a977688584245c06e28ce01e827e234cd83d50c1f6b4446247c7e0725e95dcb48e9fad0da47b88d53ce676e2babf62b3f50bc5a5ba9e13e225f163f5510af63db80eed4b94482b5dc8fcbb9bd9eac6cf38fb43d3e5364bee807b8533efb6ba4102f313dc62e3dda1c616af4744003eb6b0582c207842e49142d1593e93c136cc2485219cd507e8187c042d4572214db92cafe175dc7bc8662aaf8a73429f0543c44740db6bdbb210b4acfbda74392957205d142c94f0ec7cbaca61bfce8a9f2daf04ec43a452662dfb75387028a5b9f79c19317e9acbbd4c06c25d80cedd2db6ba9929847f62ede08cec4e5249f15f7527a0a8577b4da724ebe2ada188c3e1a1b42a4f19a7aa85bb7d08c601c84b024de63563d1d2a7ff87fd27a7ef4fe9773a548cdfce621509c0ec89134975ebbf27b13030cc5bb1f92852c7502e73f5dd84a930330c0d4074bb337ecab1e60a049ace6145970fc7b3db3cf25eec03fbecaafc8f534c97550724becfbc92bbb81a56a78bc4de9dd0eb604a6d1be65bb7b571fe9ceefe84183697ae2c31182a8b84ef7260535d6e8b375a48fa7413fe39a57e3b652d6fa2200d14ef981e803bc87074a820a2bff7a604e8cb8bf3b3227ed0ec4a15bc4a31c200aec04ea777d9a87970da488b25b238a6c03111639f26ae7399162688eb58ae02ed2cd0a6f55da3fdd0f26e7da253e62e58f4417d5d08a2e39ac98ea04c191f93f70643f649c7b4de37ea2623ab47c9a55eb9f6d35ac01ceb40e845f88600359019046f44fa53e358669052facd3947723aba3f54cfccf85ad24cee5be34a574792050d616ca20e9424287528a75bc501d4625cb71bca6ae8fac2ea9697e1e72d7f9440a9bcd41a2c9fad7634d06c0bad794cc3056b085bdaf4c073a18aac3511799689d63dd92471b910cd3986a1db23d70561fa737875fb4abc4aefd3d694af046774da622334b5d85037dcc0a42e53cd5e9fe75638f5727e0348d0c590f7aaa420709513a3e5d92f3587a2b9a9412ddb66f969710d920a8b8a83d2d5afcaadfd5c0055c2570b3ca49cd499a30662b56fccf88c4d4a9ecf5ae1c5bc487fa4439099376e60793ce23b8d8adc64752731643db6182c7018dee212285503db7422b1512a28e5634b0f2a9f3b490ad651bc81cdb53f932f39a8792c19f68a806bacf1f7e6aa2283e0c01340bdaa6e94dbc6fc9232930f6083fff440a4ed0819de6195df8f38a81fc8d1e66f0beee5e1bd1867816884489434c59243be046fca860e580be1f7f14169d354a944e7c30e50d488ebc3d60aea51463c35adcc188c55e4cf485f35d3f73915bc2ae74453817b583d18c6b6bd16af7a0a10e81e0bc9667ae335205f9c730af071263d7445e3fcd4a2c8cdcd8a257873d892cc64350c9b4437ed2dfd6ace15e5775c939073cdd53ebb0aed3ccbdb39b393bf5cd5bc8d252d1afd6c550d51bc6027db219aa3b62e36f178ea7ecd02a41b83e62e45e79fb2a608813fabdaa3e443623ca0e0685718ea331d68de18d1d0070edeb9499dc501fb4b124adc0461ce5d2edd288fde4c23045a434ed2a0e358e847bdb830eac54dfea046ce9b219188588086f4ce85ca3a2d279547efa448941aebb378c6a50fb20223eed9070ae9e5d04eebb9e1e30de2863abd45ef41a907527a9989cd685bcddca113872f0e163138d09fc36be0a5bef2a71432dfca13241e1fe0302b97f255cdc084c33914dfe9c3374f2a9d7d7cecb98582485c08c71ca043af487e9caf9b0e361dbea69f42befda27c297c9180a0b60c11814028c7a120694afb8782fa8645d4622f935bea0c51c73b75f919b58081b9dc568d132edf39308e791e333b9660b373d54d639b147d7dc950313b375edb87e59b28deeb15d9c450deab61e6fd5a12dca37ab7d5c0ea84a3b0d417d628413b6b2af1050a2107aa875a9f19fd74186739fa0320ab913601497db4c8c6f860f22ce2433942613dc1b5a23292bb7ccd535d7d66815cbabe1a3501c7a80254a0a298e3c96cf6ebd343489660f998eab8d550ca162fe46f8dd59bc842ccf5fd15304a6585d6a3158b84ac42f40154e79d49ca811fe9aa5ed6630c39e48666bcc6b4cbcd022ee81822afcb5219f3822d3813b095d2cbc8bf3427035462f741cdcc4834d4226a0cac355f4b841f88a2bf4fd763e5a142da3d4954ec9a835cd0df077fc1d165b77f7206f5c113edcbd65b316d2f6b6cb9eec02475739015dee3bcb2deb69f3cf4f1e72d21664d246bc67abda9e8915cc5310ae633e6cd7a37335fc4a53d55633b10c56b7c5866f78ffdf259dd98f93353f39ee6f66236351621de386478adf2d4f2c3606b911b6796f31226c0f496548379b9f4614643ae48c6d85694e54cdebb288b4769febe4e358e90ae7f7b0e883b7a8424f3b6fd9f5dd12ef852f1ee4ccb1348cc670e9d286636413003c1f5e803483bf0e768b1252e68475ba174032e71d4683a9816cf27d114310016d773bcfd87bab8d7db6e27ce380ea79acc69fc56299f30a4f6e5eefee2f7ac3fa5cd189ecff506ad7bd741cc175ace205f669e18e360ad33a5913a353a803fbd061ef4481bf55cc299c6160b3b532d1750212df32903fa8107a2e24d656cbd0a671bd22d5f4bd627b855de7aaff0111f211b5e49f170304f6941496ef583a00048b92436e9373cdcba99c4b0bc2cae1cc5de974850f3b58978b9dbd69f562ce413111589a873ef09a7fa4937db3e2ecf0f8204d1ad091076dff70e689a05161e8408f8b7e08f6637ee0cfd4072f158fcbb4d74ab0d8011913f886150da550084b4537841af10e1a9815346d35d0b6e2a70e2753296f43a93af6a31ff77b6f770fa3d202c77b5b9916542a4d231489a0de1b51000d76cc41ebbe139d4d007c2ff4844a35c90dcd15170d7f5eb9b622b000fe068a0415f6bf5bdae55b9a940c844052d13291d127011884da20bc00bd60f1c1136e40de9b9fb4cacc7a6d36691d79a6c166a64cc8d10de5c5c897a21bca2859f8467c3cfcba820ba858b5ce4635c39f5edc970688f91bc6ce14100acd5ac5fecbad4d539c7a827ac9bfd9bc1ae7234b0700a08f7484efe22b7043623da889aa2f12103e9270bb70811c340e24ac07fc690cb29e5ea7ac25629593a3175a697dd2f616c991395a8049e4b8fa8e6ef27e1adf053dcefe79505a6b18e364a680197f6f7ae1bcecffd43357ff598feda87a94da5a3304d1248fffc28fe0d8010f5badcc17e313a356725e0d7c37cb7b43fdb2dbf857fe14f5ff798d5d5550bb29d03dafa4d1e11d2bd1b5f3737e0623a58824a6a0ba8d22b24c363a95429d7519be4ce5ec29f14ec29da878a51efde70e9097579f2c67696c49e0d1acfedc41c95e542667d3f49bbd775d44d74a79d014ed552cf5110fa5b7d9065abc87cac2ea0cbdb79f898a671fdd672f1346d1d5fcfcbc93702ce6ec1f36f2744449c889334478bbbfe189eee90a5db07226cb72e09de044e1d26fe4f0aca77ed751be11e4b1144106da6109ab33637f2b70a3fea553ce6a5172c967190e77a3ae434233dc9b084d4721d5d2f023df695ad6c575c8f2999023fd9116013302d7114fe070c4bfcbed7192ab8b701e0feaea264b5fc4b56af1957b107ea50f6df30c25dceafc6078f651a9fae9e6340bc4d9b35bcaf998cfdfc48547510913ba68228f8da297c84cce7fc10b55230aae05c0e907b49fa2d3588e57a38085f9a4c892b9617751c9030db9e2ca744b480a3a089097b58a7da6ec465d2e50414f4d9b38dbed21f8ef52d29a883adede11a71a9c6c7eccb4b5073ccd527d2fd2b79120beaf8d3bb8f2847faaab72c9747a7964970eea076c0c3a04a9e847297bb7227bb81a4aa4bb042b1898c2b14dfb8d981fe2982fd3b848c578686733747b4063e5732fd18c5cab22a7b6db4eb1037d50728dd44c66f06a266e2514b6874c9f41ace6a1a1ae1b4ead2a5b4296b48a6f534ec9c4927a1cd8cab540acad15288bdd11dc86c5061013a0a4f70aab0b4058d0d3b22b0b67ff6da49a2aba284a7b6d8bc0394dbcdcc086fc3f09490f147e21e79b94797c99bbd610eab9dcc70e2c1378c6f0d1b690e5da15ca1ac4a3299d705f1901180ad960e10e499cb0bd837d7dbf90d3fdcd9987f9082e6c72c572997e29f24ba15495db6be58238ac21238714ada8344afd68f432474388c3dd273bdc75096df083fdebc8ded95855bd3724e4d89aff1668f7514dc01afe3887d7050f48996a530f9c88ea5d8eac5ccfde167be531ee61cef2aa99ee9ad59e6996b8405aee4f4e6d5380ae751c7c2fac0e5b322157a6591b00efe8561305156480607630151a65af4634dd244362f62360b9bfff3af5bda36bb7c00ab96f10a93bc797dce52c5a941f8f613e90fd9fbc74e458eb81d4ec948341b0545c448555e590552f11bc7559466cfb28413c318dc0317e9d8cc7aa8b2ce7ef1100cd38d1b04cc69740f0378b9ab793dbf8f09daf7941e3911cc4cfd5a9822da4ca8b85e613ea3d2abdbca7e345170a0aa17d84502a936ce46e0e807fa044f761e3097a1d2e47e533a044610e4636ce30553f0d7c0a317a7c06ad5656aaa1ff584dd9ca6c842194ef3d2bf7de2f2e30ea5f06cf0f6533cc45fc9b8cf4c651993c21656c2f9cdaa2a314819f5ca05077653e446313e912ed97c65019956e0376d954589433e551f40cb40298b34832b6abeafef2f12d978e411322a323271de1e4952162c303b460c7b5ac4b6f7b494b208c77256a06dfad43a752af6120f9dab39fce3c80331059771e545e75a2fe0e19155f59e7d96b92e7cb8d66035c81bf0e63d0d839439b1df084a0c900b277af84555333687d090f5a26589286efc4166bed41aed3eccb006977985b7d0b5b58795f03ecee90a436f7edb36571c77891875a3f490f1325be6fd2494302174b787c7f88680e2238b966c22a22bb91749568eae58637c7b7e379343d10258991bc41b7290caeda6b748e203f4c2b93eedf097eb8bd557fb62e11e10f103c678282605892b95887d27c3ebce739ded2c42cbdd81e16eaad288a5a9b3362c2dead83225eb126fbef904891513e54c14694db1574718a5be6120203ca75b370ee9956a70879c5159a8f5dd377bcda3ce33d25947fca92fef01d38ecce807f784a6066b5ffbcb8b511491e0bd85a84e6e344c5b733485f9ae175a9c2bdfe5957533722704fb6aa5d8549aa9d4e5f1ecf784fb346922ae8c195c841ca2adda0733bfd4ccb00538314215a4444cae78ed334bf3d8c0c67c21bc3e59c1718a863f339038be8bfb2821e2dc241cf39c6524b8407b95dd9cd7b0f75809eb7ae6e1e85c3af00d448384b3f5855097e51123e1c50113f78e9335869da4822995e29c78cf1da53d09ed7489af6371750e38146e75d73c9f9c611630f6d915989f6be16935c0ff1e90ad1f02ff1146ed8a5ae176fbf0b14f4801f4da626707e0486570e93bf77133a110834ef39a5b636f5a6ca3eb913ca1dd5e53825525d4ec5490f73c90b263657bfb185ee3ec7a6238c5875eaf8625b383066c08d97e7239f2d9ff97d7af1ba0e744b15089d66984bd594f4ecaa852a52f1fd855c0296201c3089a0f925a8e771fdb28fbcc1205bed912bef65eb4b843a9b59adc731b2eb94116ab3cf52f85e42902f1d1071c783b527536c534fa17e1fcd68e764be82cd42d37ad66940eeca8d3fc3bf5f72ce2e6ffca719329e42d79787136741015992b4f7ee6a74bb5719122a95c90c5269ef9b8859411d87ce1a5553363ab41c7df1685e6b4f935f90ae97dcd5dd1e00dae344e9ebb33e451089db9de3d11707e501fb9287484a1c1789067b63f66edc7a53afabc67aa198c018edf4762d58d84049684815bbb24f07c6a643901c6acb14ca8fff48608f9d5d13b0b2c31f3f911234fbb6e1f4450a709a3a77611d80885bb8594dd7e80fa2c6478c0ad4d9f0bdb0fe8043995024cbb0a9587b2abde2627afa52892b3ddde1e88afe63740d8fe41544673856b3c731d85116ec326e82746ba07b7723b9c1e68623dccd50eb2213c81a7db859766c62204ed5fb73ed47f2b56f16e420f22cad5baaf1979e4a0d0c458b60c600096a15fd92c6b3383a07d2df9adf836f40cd2f840f8ed66f89220925931097a7c8e1fe56e0a4c891b6950211362a239ed76b6eba6a98c2d325a9542f5009d81ec1725ab3a85f5104f3f884641ec021a3156f8b9349bbf521881da9855f61d53fb7d368dd7632ef0f233f7bf167b5e36caf40dd82537e4a2a6f1c60738d53dd54a6719fcfe21d513626bf503c7ea001f3dee2e589115f70602837c2a1cc8cd6cce69922f716fad018cbf8eec239d829ed6f58c6f62336bc01b2549eb146992c1b62b2fa39047e16fe54a9066bc442d83224edab821cf0fabd684fcdd4493a16e1fa60108d5028c1f9d3a42a4858e11b1d09d1ed3c59b83a78ef10b6429bba6ede51c27b787fce07ba8fdeb58739f90276e49efe5d7ffc65ea76ac03e733bfd7173cffed5b75ad9b9abb0893a170de51018558563d905a2167d8fd097a499b76d258500837e90b0ad9ad7fca8356d878912ab24511dfe5f01c874a1218ba9b29a2a7250f904f11e7203fb73a13de15b1dc7f3c13553c47390c1ea6ec03f5e94a11bdb37fb7d4c612e460abbaeef8763126125ad345d8deb50949c8878bac7caac71852293d0ef7179deb7a5cec67330bad206938e3135ca314c6773b21f36a3dfd7d5fbe5cbfaf48066925fc5a9db00eb83e14c60325edb91b06775d9d291e68ef56e146237fcf2aba82e71e9cd8e84e7c5cf58b289a7700e358e8be6d0f7a861a3c4fffde1c40b4eef72554c2f73c520aa9f1b45b9e5c3f798aa85847dffe77cc98919fa0010eea5124757c0246adbd6dbd7f3423a36e42b1ed3615c19d86cf7ea7a0bbabee00e7151da02c435d31ed3ec08043dede269e23db44c82a4164d94b3b1daee1a15059ec20a0365a41185a418c4981c2773bef083a30476d5843c9004765947ea96c65a76f34b21b248f5524ab68ce83fd236faf61f2b09bcfa4c4df37148332f18e1c3ad5ef82ba03169fee361697c41430cc71583ee3f9c3eb4918c8457c8dbaf9e69cf82df7304312b8614ea07e9ab9ee185eef54426ab7749eda8baf4f0688606a212482760981696de2af42877474100a4ba6a15e7cddf32d06c2dfec2c05feddcccac19bcd9b49e299c0ea2609db6009f1386ecbcf28e956f3836f1bcf31baeb531ac334ba0984b5cf9f7f1710ca85a141c1bc26f2f263fc76535e05ed60189a6c51379a9705e1a92300643fbaf40b5654908f0a107b799c48e63b9d63d83faa9d74dd433f4cc288f928b067c5e358a186c6f0630a25d602a8fef244e937d5c48d396cd93b387ba6dee410898773bc8191a7c50269c8cd0667184912362705de5ed6456478a09b281fb5dda196721578cc55f2465cc4126fa61a90f09dc70db46a20d6f1b56622676f43c298fee8d3216d33c2da7764a4c52da8d6edc5171ccf84947718989bc91233020afc859013e22cb9787c35fe1179971ef5e56f62bda67cf657fbe4e30cb7d9281b5bd92f67383dd5f02dd16220417f80ab16e6b88b0a13e58a5cf57d5d9b9571a6dd319618faf58d5d7a49679e2c6a79fc8cbda00935876ee3db0f8754f4c5e9efcb037f6425049ade5dca2a8b18c61f2ba41aaefc4e6961e7e571545ae233c7f13e3cb7110282da88443f5e41b6ca49e9102aded701ef62f2f499bc8734f2f8c7649e69b5e2a19804f3f3fcd0b1555dac4472396a8e451c1491ae50a31d9cdb6e93d8bd4d7f7340e5d5c4e392a58a870e34bf0114b0b115bf71378f8bffa78e6140d26caedcd6d565c3f4bad89983de70c5087f4bb9d77357a98dc1af2490f11d698d4d110dbb98d6dfe036d966bf994abf48b924f27695fd7ab4171eac0ccb10678247eb62717e07b0502d32b87fa0d4ebbc6b84978e7c2882b54f588ede4b59d3f95a05b344b3058ea91b8c7a72e8bcfa8ba060dfe6f8a141207741b018a1c61c6772df8f8d4204402ed881dd8a971385df3c75158a153d3c0dc95c3a005984cf272cb05ee358fdce0b114937cdaec7cc52da11a16b44e02405d810eb6958e7945d6051a8c927fcae38930159b1cf2d9e956ec253c8352892c0ef0bbd3fb62dade97feb936f60e0d00536a19368895aba161f933666e94546e0d45ff19c9fb4957e5b3e640815863fd14b8295cd7fa854749152863d4fafad6fd9df6626ed2a072776db183db84c70dd07c7f2fca4ca71d5cc73263c09695af61460a13fc27a2c0063689965dab51ea41e49fd7802c4defca14ae879b5046824a2b974cab405983ca87f605f49e6b6385772638eb07d6868f64d1fe4e6711c4f7868aee483096637f72f0ca974d82ac72d8937845f192dc4763fd3b5c162531149cb52e8268851ddf3e724510a3da68a56798902412c26834224e98c8b086bdcb51f2e87603e13f96b1ca93a51151ad92f91bdd8844e4afde66475eaaf090dbf2c1a23a8a6a00645990e7006fd370805413a47bdb4651d3b0057bb41e44ba151f63f58becf7c909a86255cbeb26f2da7bc24f7f57ec55acd3adcf6a0e8e68525ac577b523c0c2f8e8b861abfdc9ecb89acb6459e02902780a2de2cf231ae4fb4e7c03dbb6a8a007aa71c4ac452e45e361830d2cdfca1b312830502714db1fcb1417a8cbf9690ffb4ea410fdb0f59509aa491c997eefb6e1036e2a1d306ec356191593e7314a2483f96fd7721dc1364ee65c7039cd000ddfad250b3dd7b76b6b132905bfa690ebc1ea9b111b92f6c37d35b89113575350c5cc89066dbd95940e12d4f5aeabcb79a711c551c9a2d9b5785b3ccd3635b6ee7d7a0c5650b8bd386e115f64556cb25677b0cf5b04e67703bcdb81fddaf6ebb9738b9d8d322b81bdb6d6497b497d9e46b7f8a023133b74c29c345f2597ef7110230a31c5f33ec5ee858af30e19742771d0635bb05fd23071a0d2629eae6c442bd251dd4c957a19fa61352a9771c347380ccd32874ea0b08c0245bb2cec82193f80eadb401a1605c1f60750e26ff3c12c4d55df97a65e25948bfdff228a20a3a80adc2cf6252c312b11f2823e800e1391ff00d6e33795fd0e71c983baafa372c5fdae9839401a91c5c4f5945adbd96e851d4df440a1db193d882900b53f357d902b07be77946678f2aaa10fdb94cdfaef66b4ba258d0df59bb3cf83aa23f50e17291a6e324ce7f64925afe552d9f500e36126456d12cc1cee4c60a665b1ad147de2f6d5dff7239fdc20e941a512740882537b978990c06706fb974345474d1b273cd32a972a2c64f7f9940524a8b63c00e4af6e150256c0f91bdb4b6b4670417e040338d4b7e61b1263e2c1e69a0f2d140782984c03875d49c38a6df3a8d16e572a8e6470ccfdf0a8167f3afec6a624e4f0b82cdea3178b4282eeda678ed3b6945f2b5ae09f1e69e343427dced539cfc89c80783087b2b798caa2b3a02c94650fcd5e2c3705a9dcef2dfda78aad4d88c8e5e8ddb863f77163b54c8b8fb42efb7c518c5e6a46e31b561b52a7c088532e7e586917bf80129ad5431e62f6376a666c9f37f3ebcd772482ed779093f195064af363c08e3e559eb4ccf0589e346299d40f7132e846862e3fefa70a93481ee878cc4a90cc3c238931ef91dcef79dc3489c7cd98cb8e3058e940c82c0e1f708d5444a83020b1ac97feedf912784d1577648e254a3056d3818be02a175807a12c201cdbf471b70596d37a26177b21f148e8dcf86a020c0cca8a240d09ff1a2de5c00305f80583999e5f340f5b39af2f59c7e83f0677f21300f63e8d17dc6dd3eb47848acae7a79892857b3748c34674623cdc7617a1ddea9e89f36a46612b0a3deb2689a4eff7a5bb6dd74e4e3b8bffbfc5704fa150afff717e91fe3ff54840eda09492c1a27b4522f8087cf4228f94952b212dced6aa69525da24b63500e57385d61c6ba905d18a071c74b7e94797870ed69c6b77611a1b9e6c8dbcba32f6436ff41b35a21d8a02c1a5107df12b534ea3ce30e708a9be80805b1e1ed882b0a1f1f940715bf2d0b3f22a2380ffb3df0ed08a5009ddff8d4400b76cf511170f1056ab3928f3053b7a18add3c32d4175680f2de540c67701d7b2bffd3065757beaa5882ea47da2c0de09ee54de4f2ecdb7c50c12c55287f3ed7e863a257cc287798a5c683d08065c1bdfe95491499da9a5242fbe66856b2f3c4bf777a90fc739880a68af10714eeaf8c2bf21cf4ad9534da4313fb918b97ce56149215437dab01ef3418a584e839352bf4c00836578f1513dce55a66333e97757284cbde6043ebbbed86e12e990cdab4abad5d946c9b9422d20901974077c73ac0c6761df635e5f21a427ff511fd33d03e21de9c4584362b937978e53cfd7c3c4b9ba97bfb2f34e3f9af2d6740b519285ca4f3e24ec833a29f6553666e6d4a423f33eaf8814c53406f8ca78a2cb5f82959a18b10283b3de57706096a604a2d6b096f47de6f4446925978ef78c257e753183b2d926c4552c7fd9ecf7d298d5587b3b3896dd3523eb8b7a0c0f453766897ee538ea68a5d5eb569ac5a734dded4c5531df48439a031e7b8ef138d882a9e00b70b8a95f59b66a5ee7b44b5855ccd3ae761c357ddc3ddf07125d3aad040d0faeca2c2840f05c16cb2083f827ebaf26c8ca8f7b5424016992f406419c86ca61458c0274e696f5c15294c3febf8552567d38e5b2563cc7f0fcf4ffad1e7fb6b4fb52b8317af4bbb6cec50d04345ac9e389f19f0fe92966977908aea6b5c0ddd69ba82c1ab53daa44d4fefedfa226a1d52910820a8fed7206157a8fef8d6b748dcb0dc8542b8705cde71988a663562b2a954c85deb2159b05a0174a83c3cb64f52bca236aebc5d17727d7a4681a8ac2ec18a5d3a4c83030ed4ee48e6b3136824ab6e0bd2cb4e0ecfa07bb249cd80596890883e8162444f95de20835b3b9e8d82bbbcd3f32f7a4958fdae91d391967427a738c15f7ee068a1ac79735bad1ae0ee93ab6f34192a7c679302f8ae7df91fc207be8b0df5830e3b9b95f000af1e5d7312c9e2fce14617fb653babefd34e31be533bd4b3b304a24f0a7ed4303ad173dc4f7daa8cd9c493b2fd9795053c812a3349319223eb78029d3a66357e774ae0f33ec781892578a118741fd2fed44c19aa25b776874eb321fa5e764a898d7633f930d3bc91673800ef14ef07fd11e319dfcf86c3aafbbf5677276c44432aacba43c0069ad6b2a97e8b6efbfefb1154ecd23a4c3de8f60c1d6277328795c92ddbdf0596705857cf298cb0cae9bf66bef50719dcea3fb24bdc8e8b45d8f154f2a92a915931a4e051a1f2fee679810c846ec639fe35cb7b96b758d0a194013d2ba55ba9ed596cc3f08a54ee34ca3b105093870f58ec379cc1fda079c43bedd9bab84bcca9dcb30729883d8fa17601b03f889a63393939142973c0f1507d1c25b4c6d26e99698824f7ef35aa6f981d1100898183d0517adb0ff933383498cea6229dc78ba7f63da21780b5fa355cbd6238f557e1be3d26de9df7501e6497c4e8e153386f89907885cdb395fe7b92624cced62ceaa6526baa95eefc6d49eeec8ccae4b22f52bc8737910e3d087218b0d173da3fee8f107bc90b564a9eb8bf3fb6e6fcb73491d3e1a627f2e83f4d566ef1166b480c4b715abc3fb37e3dde22187ea2b531610299d5820375fd26cce6f853a2cdad286731ce3310b6fbfa6e356163b97f9934d780874fa94bb75cd93d329879a1aad4aafb836b68d44a94d25dd831636e960c1d271ff6d2f3b0f81a8a9c26dba4036458ef81a4934f245a4ebe904c3208d25ee640bea61df91e5f0d5ab3eb8e63be9433620a6fadfe456b8011a7a83505daa49a582c61c32311f69e8945104ddb96d73042bb383a8f6789725b6713ab045e98200d5756d2068276436cd315e8ba0d5321a7db299dbe7c865012098939bf8f9cfcf8a0a5502c893e86254ba981183a9ed8781cb2c2bd690d66c75c78086c18b3c0e707c53d9fa66624d67277a92f01f3b042b335e34d0c8c2b427faa6bee8c9efd701f0f90a49a1bc0920da981911df7352788ef747f8302f2b75da16a8e3cfe80e2b7689fa261e094d2e182e751ae00ca3489cd03d67971d38624f7b9abaf4ea154255f093347c7ab5520ae51ab0ab271be5d788f87363ee6d2857a7e8a603c739a8e0b600755f0172b0336c2a3de2c327ef789a1891f081b2d85be761788bfb9bf8ba5cea0d2751d1b65a8e2682ad68a1410c93ae1770978c323fab263072210eed3130b7857a39d9101f1b54bfea837a057bfde74cf139300bf0694f71c9d215f0c9495a94985e76d79f04451b3ebd1be7f7d65e8e9a7d48e16390136e46bfff612484ee5c54d9f7f17b2cd31dfb9cc1baf70f948f079b004cc7415a3d17c584471426c09dc7e72a81ab45688dd9db1cc81b5ba4ed26e272c6b16795e6c465a76f0082b4241ec3383d046eb9be5592d4e68d8bbd18fc449eae83c14e2d179264cf1e0c6cac9a1e51d522ec0eb24184f7d355332c6302b53bc9d50af32605719a69637a6b9ae218cb95f191b2eb97386e4bacb45edca7d8cd2855fbb41b2735b35cc884c20b0446a6e78a69344fa1b513e06c095d9f5c55482920a40d0fb35811e24e1eba9019c48839cde200c296060f41272687c7c97153047f8897575244212e2788d040675a73379c61762b0e46dfd7f1743f5e36ea6f03ea8dec0cecc03a9ed15447f411a1877a3bbafeaa7adf7ac3456b0520cc754760388ddceb94973e93b8be526dd945f38199f01f2fa25fc94b48e9cc77e92856c1555b9740fdd04ed4cc7927aed449bbba676ac93e8fd0a332a4e78880682a7975588a43c2e80a84994665bdffcd6069daf0055453788c69f407ac4446d55d8b6763d1f8b28985ca20d3f6caf0a73a8b6c63b16c5d9375a9c4de69845cd093ba30966519bd6bc76432af49f2176cffcf8c297c5dd1d06a138b13febea69a1100c3b1ce39d94b1b6d9d463056402e1ce5bcf94a1b8188d6442422185f6136ad0579095095fc992fada0348d54c033fc4033459c68763162ae3159bab044226ab7ee8d6f91a677c1ecc97c0ad3208da1369a9ab77b180c2f8058510955f6ed374bf02937b7cd4ec07decab1eb2ef23a3bd5dd5808f54347f7662a074124d980ec90ceaa2862e9cd152445258391c86f262dd2deda2e9af09d3920bad59187b9c7abf1f8c0ad4561e7a1ef43e06d45901411ba49c51b493c123fe0367dc87915e52ff7b1d079dbff7b31f5cda9dd11259cb59c725f90a7f62af04668b8b441bad9229d7cf3a4473dfd56e78f359d42963caf453a4b12cc66acc4fada61242901995c14eaf9fa53e1712982eb62ecfd36f1f64bd25426d5d14e951bdab0229729befb75e5137e8960b0b43dce25dc9eb061530867c16e54e12bc76c88b513fc991c493fc0d203098b7a2fdb6a1dfe5822e1fcebdaca45adcea4134a35ae2fd4f10539147cef0f3825ce435b0001004140ac49eeec13b46ea926227a910aebf502eaa17b51b9169e61a52af6f4dcaf29b50a622b4c9a094826fda5559b01e97d9933a25af1de680c895a60b100424ffd6e8f67408670a526daddcc8a618f3bfc26fd7ceedf5d7c717f0c0607a7b6b337bde382f2230d803ecf40fa108bb66a830a59c07623dd3d1067be49e9a36449f0df763627378d701950b2350f794e695090d14599b32773e904a50b13d1820d94765186c1cc89c73637d53d276767ec1a98528a66c2094817b4a0d3da47ead5c85a44061d20a63e4183a7c31ee7c1d6439618a1940f77f398d7353711dd6e0649903b3e8f9565cbe11d6551554cb35ae5071bfb82bf77fc1d9c249409ab3c9233e4eced60cb8c7cd4d53f9bdab928f1aec7af88cd39d4c22e027e8da615391e86162381bde86277ae2368b39748a8beaeb1f3e6bc6b4f8a176b9c89eecbbc826a5e5be041df5a036bb61176debef24ca32d85a11c30ec2cc889f7e21bcd77389bcec2dbf4683f667ead290463105e60df5130134f036a882dd492a390ac4e3453bd028f8b4b5049b3686cd12ef894a55392469dfdbf7ba5fca9d67074a3bb98e79dccbf73b92dccec5cf6a7a05ced9b080dce7c33e0befb6e838c0af4cf81e1e738ad77dabc76e63cfd753c3614a450a5f6de06ec311de2c8e692fd50b5e21e88a18964e7bd2b8fe8ba4007e4dcf99bd5391f3affe7055baf7173df5ad26320aff12a9f17b084033ae53d4577928a2f1ee592a569c75ec95ba2c21adf9338190bd681eaba8fb872366d201f18055170634c21b68a49252bd2127950f270158a117e50f3a75da06a3c3b5dba038dd7f0115250ae9dba8ac1185301f60374527bf09d2994a3eaa04a75e089b704920775ca5a3adef9258fe654676af1b9223998705bf8449f37e081a7eebc49f72fc5e2ed4fb65c782eced3ded984b7abaa68abfd4ea977c4a9ed03130e7c9a56c87c9b920206e9edc1ed6ccd405078e98701ec9cffb3a480104404e4000d7d7399a95db634fe55541dd8e5b99469df7a7c64cab0507caf1f8db22fb520b856e375da8aa9ee2e2205155cd927d8c2c29cf08f32893f371f95c15c2f31727c88cfdb470ce1862e8b3d2a9fe1d7c2789764b8a69894af6c3a8f99fabec2d1d5ddfde5235498de7f56838209aac9a7ba5b6c95884f7f38e2de5ccbe27ccdf83c7451a5f5c300ce22e92b12d13ba87eec68b3312b83e7d68ce86f85d3cf9e3b4e4c24e3264f04b4742c420d5b7f38cd5a2d1a25db8c297a14908668a669d72e42123a9bc71195d4c8125c0ffe8bd39bffbf384368f39129bde8848d716fcb07e0acef154d2409fc5430d92c9621bef2645eaf297d3a58869c285173409e1231201caf7c660ad5bfc8fd027efb157ccc0341202c64d2129cb723818f5695bd2ff95e3b969932ce730447e96e0aa0a3ce2608be497e23948f0144c07fd8b35306d46e37bf5b5c9ba18918975e37e85c0c73bc7bc114a31d6e76c85f5057659fa1dda2253c35eda79ed435f24a0f667cacfb69b9ac4d86f40fcda2d140b6f418ae96a39c2bab669a32de3608569b89c939ba0280fc6f1598b8add79e1798ef13b30a50ff1b8c87bf50097b549b50e55362cd27b814365c613e6b5089d59d0bab97029d190a0370524a6a4d2256b5ece3de256e730a4cfa683e87d67b03311dfec4726c769b4fb0c20c79e118d3f3830305689ec87339586565ae535ab8b90a7b6278d46a354d31350c9cb181ee49daaf26c652c2052220705eb9955f304e3c0b9709e72dd459459bcbb9ff2f612f943fc4f66e1c982b54b3ccabd5f0b1f467ce909c7bd0626062057c5a913205389c5fd447139db30f19fa4cfb4d35dac1cebaedf5926046b810948df3def23be8ef6a23af2869f07e091a8633a419f1f4a857aed7a15626b13c5ab59edc3b943e4a104abfe147dff450697fade71dfd9c75bf8be21e992ac8fc8246603c3e9c6ab5df95e465702ecf50ab96d0a39071546059d3431b7a94612791c787952451a58003c9e05b8048577eb4f4a9f8ff3e9bba2a56b06fa7218e0333f3e45fdce3d2ca6c60135c6d2e84e18104ceeac7f03168620a248ddaf81941a80290014c63ba3a9edec2c3f2dc0a093113c412c99e41634801a95c74bfa495b4fa6734689ede88474bd1476287f946963515f1e08b5f73cb9144e7af66faea89e6feff8f9d94e5726e4bd502a4e96ee2eb38d5ddc3bfe0d52562cb6d7866f3c740314d14dcfbc4a1ff7c5f7d6ebaa540de9288ad60a7e73b008f69cc6d5504445def318bac6ed1df24de8245de9e2a5d70ce26ed6d98ae75a61e4245220f7fc8d37fda82fd48e837c1d61dbfb8a9866a766afa9fe0c94d7b1042ee230a604a9df99e72ec1c358f140b9306dee0825bc16be4f95a9a3e22d482319f3bd9876cc9b936309306bb23f621cddb82d44c9e75ff3e4694ef3075a2436972f95918062969bee3648c7d8eaf4702c72877bc420bedc25f7a28f8527acb23db0c6596c73c053c233b76d8815421d378d6abd891515fb3e6e957181c9c362b6f83de335618f48bd8c0742954f040d2c2fda06067ec70a3ad1b756cb80daa17a38d404345b009c6795bfeeb1ad3fafc11e7d483f0ede1b9d4ba746363335ef37e0a2afbead03e6b8424c3d68eaccda78c16772c27943f0c831415599b9348bb59a6b3737e2752287eecf0ba6b540ca47343ecfd1276a5e8d5eb85ca13cd6cef88e01a2a57173f1a472d358af1dff6299f0d18e3ccf92c4387191706e5e6eafc7161ec62e8a6631fecae9b0710e2f1e4f18cc6b55d4fce1390224c8d6b58f35db1536a1a6267d23a52fa6f369f323f2f8811af5f11d50047c82fc5bc993be4201e308da5c3e7d1c9836ed23aa051490c4e8d2426535a7300adcc7ee3e64b135e57f0654814b318f2a0be4795862dd4873019b9f020893fbbfff4069e95cd546f76755070b630ff895865c88dae271d9c2fa9827092261117045cbacb865a36ed906e226bd2d77da7e9cf1fe905a3273687d1f710d7b056dbbdc914aa3edfd41fc5dbaf872fddcc962bdfccae85512585cfa742e27e46def4589115143717ec7a8b1564bb47614815d09b68a5f826056d6b0e9e44840e64538b51b289693decce979fe23de39d2328fe23b63457f532b99c1eae12c789c568eece9c5984c22b0ebc04186dc311fd6638c04b923f0c4feea3dc8fcfd3599162a886bb038ea50dce84c28f2d34d9c5bc67046399696170e728099e752523f5919f0b05dd25d0251a226f806cf5a15a3439f60328308723ecfcbc6828be6b0c4c457b289dc59cc9569c94b0d3d1ceca2df74a8c6758cc7698de93f657402c1cae6862d2b1cdbf81c7db1f6bf56f2747100e095822978ccb5095cb4ea72c8762ec96c1592e48ea049b41a57bc73c0315014920d3d453ba05dd28f9d7c512286aa06e2a07791d891082580caef34cfd7a3e1d873e9829ff0eca9642cb81322817a792a14d15fcf655dca7fcc85a2bb7fe062f99575b42055468f489d4b9a0ea661cef633be41d8a24d34645aa26535987ea531f12916c254a2242b84653d9431943bed79824e5873b926405971b464df41fdc4110e75b266649c555b97b00225c1b44a1da1bb918cfea968740cf595aaa7434de5a50f9fca36187c97f1796ad9842e8658760277b8344746ee3040626ef5c7d705f37e20d6905679137e59211d894c49b0da364861ee91c02d48ebe57917a6cbf7c4fc6c0aa39d25920d5a394a01a72a885f144f3caec1349e8d523c5359cb2a7c0cba1b875c2e60b9461e306c3ccaca00b8b5a97764b1100a6a2f7afe06647387005d6c5449d2bb3eb60811ae402235b25b0b9c85350cec9bba0aa3c0cad1b6136f0044014eee8448ecb492984d9f10fb258fcccb293b145b9a0c3f6e7cd9d8ea39c1e42cf128a44a838b9480a4bd23d431bed1ee5820599153acefb2c3bfcad6c5ced4a289366c8eeddcc1760a0a7a2728d2dcf3e6dc9c5246be3c382644a0b29b1a72e04f2a13cd8c65e477c1309754941437f9a80135d129ab0999d674e038ccc4a0d34b23a4f115c4f86230568c66d40ec759cc03ac607761da4a80318e1f950373581ce77e8907baaeeda7a46cddfcd0a38981bab068449c6d32a551752c6257110d1ca0e382fdd14501f1f95adf79cc36234e41acbd3ab4d77135933d495992f7f7773c5246704c2ff53aff78c3081827bae9d2879734d9ef37528be7383e1aa1aadcc03292002c266c71b3e539e08a14e43dec10bc85fe7e22e0dd6cb078a02822470501d07d208f2b5d21b94d524f86a1f5f9abc43db80be50ece4c2dba6559177b3b695237a28a1cc8074fe54e231163eaa0f7f6cc77c30b5c94fe258a6339bd8eb0d9b6dc108033c78c4e274d7faf19f22f8ac576fb470968b210a63d70e75e4db0d6c8b1a6edff64cea142065c6be218baaa5202eef66fba6173c7799e0524c35604031d8389c84f8b5e04d3d6429855a9243f172cab270346a427c85aea3cf1ca63a6087087e09895cc5131bea149e31013af39b0ac998f8d05fa58f5b718ce95511a1ad13387dee25f09e7f1dc68a72f35c377f3528dedc41f3b2f4a471338a750aa85f1534d83eeecba03608cb364ec215cb39672637de71e32f963d6c13f4989a193e52c32506d77adf64547e14265c4766ae08b3505c9fc057e0cb11e4975dca2b778e866dafc12edc1b39a4220d9156f43e7932516ed538dec3d0f66e8e1cb839e63b4d595e473acf415b22ba90dce903690e89cee9f8d29532a83a9d90d219ef1b47af47416dc6ef6da4b878b2060967c21660983f234e7aeca1c5cd43153a79a5d483b2c97ea7345563dc295479747bb9d310eb9fcb4cb408ac204c75ae3ec750b8180afcd0fc6df0cc28ecf0bdf33f77360940e585364306ab0299df817140989f0a6981ee5ae167ed8c12f5bd34a54cbf68efe1d5154e5721c7ca46280758e1120c41361e1195825a95279d9421e3a4b1a8fb05c0bcf4300aaf24f54586a6ac490870dd3897930144d896bc6dd7e7b24c2586a558aa85ee18f149237d2bef677cfa26d75a54e6fd84a28e8a98b01e1734416e27633b65a90f78f181087a1643069143946faef63d384f81baa40d43e46282bead92b5b6ec77b8523dfb1a5e6999d0b15c6614be53d545fca74494f7028ce811fa0361754215b63ed376541c87462704959916202585b50fcbd3b5b5acf203e81c68e818f88d7fbc053e14b328c23dc9b7acc7577158c2eeb273b439de7b9f9124a851b0a47085d165be7a2d49b3ecf94acfb6fe054747f690f8db729a7ac8f9a4fdde4aa3c187ae8a31f35ef6a66b66b6f9e76ed819075222ed595eb3ddd3b1bff1554f38150c855c55ba106bc26ded3b9138085043a4856fdff68b5969ca6cf3f1f134421192d09aef8d83fb1ad3dc77511ca71daab3ef0a107527caec274577403a071b03b513652782045240fd14245d916a5e412f488254e9781fc1cb0dee61ebdab3c68fc77e8b50a14de8417b8fa79de7e156d930bb5aa92b878159f535f1b5fe96cecb947672d688199dd39e9184774ae213dc5aac0306cf68d971fe00620bca7d6d8861680f485f1d515b78e320cb20e6e221e38868e43f3751d09f35745edc170a7985bb97ec8bc95da96956554c0255aa4c5d2632a2e2fb6e79c1b176ac393ec79cfd4c716fe35e28ab812e62e99b1f4d19301cbc8b5a69c08a18e7e980983a647a15e5d35ef8136d9f7cc31e817689faa531208b1d3257157550e473d590005a8ee30c405cc785926123b153a957a7e4a623de759412271eaaf61dd64a1e12d4467855a2a51f9d71ac63daedd8f5822c00e9e627180300812d7fbe88f11bda7ac71977b819cdabc0d50c89595644dc8479d054a08b53e7f5566a2c655a1fe720d873155fea0023038fe955b7d9d919cbd4b48aca54876372dbedea86bb5ad28cf69d345487bf5faf336a54cbcb1ac3ae9900386688fc141570087c723eef3b7cad0c1610c0fbe18227794bbb8d9207a1492a11b1c397615639948f615bc9ea9911047fe73f0adcdd92dc79446dab1a546cca36fd5985e0226825ccd2d4f68f3329f74510ee7e734ba21477574e2da004bcebfb118694532b6836f3de07cb43ba9f74d93bcb5f7fe7112f7f381160a84e8054e1824799080596e055d583a576d934051255f94c05aae5477619be48661e461175435e922738d7c11efc78d9ea8c2666f3bd5fec70a59b78c1c762fc212fb9dbe174c57925bbfb5594bd272b090fbb9637aad716af3c59f72b911fb18706d77358c8ef60ab01b8cf929c49cebf731c4687f45f1b55542414feddb892f43bf7bafc4985d9d14006cce2e63ae33fd9c8b8b8227c0ffac061d14b55f7a1206e714094b826469e64524fa0a417e9a73669dbe1bc16f926fa93e888b0b1de102eb6be5c6d1b9a6d1ae24ec08f0c7fc7c623e0b2952a3391210ab9b34c743a96b5ec71af8db6e1f9c6e38b967b88172c03e4d53423d232682f717852e56b5389dbb0611ae73aacb52852f24b41f4b602bbfd7580996d994fa032d2e4c2d746bc86f55d84019e3343bc443b5e467e402e24dc9c93f77f8adffe8fb3e8bed1ea8f68ee6f85c1a0178223804555d86e009cf25e6465e6fb80a73a4d39f1473f35a176a480c42948fd995ee0cfa5797311382615f80344c5dcd8b9aceb9fb5d906b634847088dfb40b2253e1005c29a8aadc3c4a3f1ea15ff42a956623387d1132c32a3f4d41e263e3047c5afcae36aab05f13d0c78e9aa326cbf29ace50045ed1b5c9d9794ce644a8618795b3aa9fe0cc95e0ac48e06a89e53a19221db34d6643d17841e37c3f0cbe6a769b19331e92120a4eef5603bdfe2b7eb7fc2b168cf4af69896e22201bd702bf6b72f7800cac7bfc6a70b97cda136ff5556871d8444efd6a061ba3d8273fd4856ff8dab925fa205decd5bda774a27e206b05e0809bf95498852684cf1c2bb4c695393d65557cfe7f79bff30f4b76ba7aae7de10410fa3efd04741fecc194f053b0b07b1689447455bdd1d5fd084466d218e3c0d11bc9567c6d762ab096f23cba43a35fbae3ae15ad51d71a8a8eabeb468b302eb775fabe1b57265877ebebc3a8dfbbc4082ecdf82cbb724abbde327b45d9122f2f5aa03b11a5cc47dc14e9a5aa9182603309e3761d60a3d511a48a4b6f159a7daaaf07eac1fcdbe9b9bff2d7333d7533ab5c5b0ebcfe485ff37655302d42f764412aca33ed9552c2f92b48dc2cee91cceeef468d906409f3aa89d58da6f5343b716da839d0e7b09d21c900793614b63f6a0a8703ff4b5a1db2c66ea6375d5bf85684f01373dc27c44f4b52573bf62b32a40caee88800c689ca8bdfc029d9f4a43000949af969ff1e575431759209dad497b8dbec97f06c2c04b9f6a0fd2946ec93caca218faef52f36668b2b4fcdac0c0c3dd9aeedc95f834b52f8b4461f2510a5a1db932aa4661dd198b8e241d97b8ecde4c5c22e115c2f3ae9b0fd8e4a10685cd81362e5e3553e0e01491eac7b59fc224bcf850c28e0b5f2c88a8515add60b52a0ad73aaf2dd754ff60b1a40270129b333ffbe2a91e489573c26fb8a2bef92fe98e7c412edbd1187367a9202e4b61aaa0ae867e7a2a5b6634e907eb4f18f5a6502116dcf2a50c28356daaf34af560ef789d97c0b7bc3dcd3279756a27957591fcadf7519a9fba8d01b7cdd8e3b2c625ae9d99bd68af2fc53e3e2b776ddf35694ea0974cda598829ad387c0f51901e9b2c286685d48ae3d0da130d284e5ad3fa543ea5f74a8d0612e0a29fdcb8383a28ff4edbd3f3720cfd53b4baadcc7387ce5dc9eb16aa05949617cd699cb940a959694f6e29dc3a918c9a995e11a38603114d3ab2322aaf91724545cd591efdfbaeacbf89ae4477f7a190942eb89cbda90bf630dcafc75efee8bc8ad504a69f9d640d9938fc03ac987f9ab543cc0d87a489111d63f734dbc293e0dc4bde95ff398e3cd0e67ec08379556d548f02db8a4e85c0cfb41f8d8bd3dd01f997e48e46f51ef6f973f34d48392edbbf11ada7674aa623b127960649a09deef489fca677ab87f7d60a58d3fa1e8ae554b9c215972205d72844abd90413f3d766f3f06ccebc0418281d40d0e8c46e39369170dfce08b7570af42ae70304172187630055b2c9bf34acad19c5631af75e9422f2984702b7db64d445cf943a181c438fc9970457a6a9b5d909c2f1f86416731f21a5310b7a181f0751434b326fbc1284ac05f622de69cda92abb48ba6213818d87f972a8334ddebbc82909be8d42b5374e1eaf71961943eb5b7009ec8e151f3caf5d6cf4d5d5c06a147de312c9fafd60e766ca6d3b77af499f05447e00c4138ba2087cea44481b1bc879a812c6a878b64dabb18abd9ff3e0b759290d68289b4dc568a109f974ba051e93878c83adf1b3ecbe906a778f2774d01edcfbd5b11e968e5a10a1006555a99319c8d606288a61aa56d9f9e5c7aad68b84b5dc7d75bc9b007b506396f6cdb7f29c84c2cdee81269ca58f8311ff72f3c7d1a39aea347e72496e8aa2499c492b0189200724e9073194cb15a19d45f7a44fb1525537ce5ea21aba4bd88233f8fe3bfb47713b36664ee078909d75cf433c812c0be755613f8127ef32c12a38fe7c2db954652bbc4c3dee73cbd9170f1fb2b92b56e1846b95c938bf13d0ab0d56ff63979bc801fce339566f0516646d454be0ef143189c04630e0a5bf09e68fb48e75649a161683a6d03af555301d58ce970282f3acd21e506e13a340efd4d6d9527026a2d6a61d1800713a729920df40dfdf7cd4ee3e3295eb9dafae530f16bc79fc714da63db48e8bf6a73b0ed9554a8da6093da8ab7f4d99c650f1cd6f181df0667ad970b8d84637c31c52d0cddf334e91a3cc3200a59219f5e157923733faa97a47d6f4eea24596078b6fae9a3c92f932608a5271b47fc29f905dc9d2126703b0f01307ccb1ff5d7dd0b047b02f3a187c1ea144ca126c8b74f4e909d750ec934b04112d8d0135cf7c97575c9672d4d0581043ed962936608dce9ef857a0c72e4bffa7a1183b4747e44774c087d5892d9c5de2cbf1306df3d24aa85144b787a1c548c7236c40a5625165152b5c42e9f76604784ea38cfaed9c3dbb9f69cb4ea18b06733e8fcec164f3ba92b2994474b604303ed1941d98f79a3b54e0511f15ee8fffaae357007ad69e766dac457acca29ad5a3cdbf6bb415450550c36d235ffb7439c2c1eed1df1c024b31fde8bd03175eeea8f67cf35979f53735ea50fca67382210f1d8f169c994c5fc6ff6b634509418e9f580b0dc517814404effbd2fef08c9d58fa7c17b94bb93b96769e2fa047321a83543d3ec4b44d2b4c1a75e05965f188af846d24229b8608c2241415ec6c908bcba318479e17d6c197bbce34f649459ce1a21499d823a04cb7d686b474d7f870f63423547aa914226c0e2782ff3494fd73d8904e6d3083b044321d40a79d21a638106d04351ef5a7c4c365f6d9c2c4b42fe83f476bd350bafd35ceeed1d79c3d258129108c850c23b3c3ea3815f4b50734e56f11dd054a979faa204b2253a23093590d40582c9d88e9b165b77bf6abf148d02bdb23f69fc0b3b9bd7fd03ee2f121a2461fe0022b670abe8c03ddb7a5c641c71434747900034fedbd64d8815e657a6cf3992d1a9abdda681e29d0142fd87dd0f89f0cd6b010f90d61da44f6e45dd0a2d0c5d37e541b7140071582933c58b0cbea0e0014f993ebc8b7a857b0e9bb24c38a39f14a4906a34979557502bcbe4cc98cdc31836d7e5c96a391fe96c17c824a050b5e9c8968572b2efe4de0a674dc58ded4d1b70f39dc0ebacf5c6e86e15520db0efc10e0c08275bc5dd2e84319fd12f19f289259911c065b3693f98a39c98caa6136fc9408388f5ed372db3e6f6f22fcb64cf0de864e99d926ed721d962ca60ba2a7c10f58f1f89a49fd7a6361c8e514aecd681076d3143fb296a7a838bd59f95cb1ad1aa5912df65d2fa08eaf32736e100fa15d3361b9fbf90cdca9c33a5806d7b34e958975ee3a689047cd52b0fde624e5f48b41150b3be9b7d8bcf406d65d8977543004c14507181100d10c277d0dd2e4104b8e3745999ddacd1d3a8e854c9c7e562dca4a7a52dba579aa8084cd299d1ed528615c1f9b2d97c1e8a35bf60863f2f3aa0ca78672d21008bf68c55a1dbf2fb38f95c8fc26332c1e2f8425256c14c9c64ae28bb9a3e2df328c821d0b4f133e318b8964d3e546d4a7303ab459162138c9f45b2e42122ac16d335a0fe3b8eb8e90995762ddbe403b0a5a1c98104539b95e278de504db8561dd9bb052986aa48b5b0516f4d749b58d643eb7daaba445fa185ac4cc0000effbe2183bb5303f6f6a22054a1de215ce04bbe83e7c4f30ba9e4bb19906dfc0d49f4e81ec813badd36e7f0cf77aa4e186b159a8c8ab7a69644c73ed25c0d80d9f9a449c4954cb683404f30a1e3bc872cd90026f5b4cf9d0aa7e9f0927c24a2630556661e9c589c8d82973a85293837a468095694cc9927e5a4860a26b4b8b4123c59b244e0d5aa57b6412ac01bff7e6a56b92c01e4a39c2954f0482ea1f611ab3b8d593839f303cf9b8bccfc234322cc883bbf1fd9eab69a4d4fa79c07f34d64616147d728ad542de97a7b963f078adbdec32e6a241633f8843aea632c075378b921039f29c6435cce3f47a8c63d807d7531a171f6f2fd13bb7adea03b4af0fe669a7291d46c745bf9f6d0f225e82e222208c630fe83ba3ab2cb8aa53fb90e3ffc5f78567286440733e91d235958516ec480a2670e519bb448fcc4591b80dc60e6aa3e268343a3227179528faf2cb8af94749b9b384083cc599d8f97c1b772ad74efb65fffc03866b38352e76a0dc39cb411627634b84143eb7abb664ecf13191193b6e74d95e48d299c152840770a1dcae279363ffc7ce5ca429f76b5bb2614794d5f98e744f225f920d8f9dd2ea5dc86cad7425530bb0b7bd769157fe390707f09e51592020743142b0ec6fdd41d6898ca0d7edb2a773eef74c16c1a3ed137eb5856c1a14b4e7232872a4b68651a8b8605fa158869a79c4bdc646de8411c6213d2625488c391d49c3771fdaeb1fea23f3b67a47cdbb3d123b4652109da52eaf5419f1a0907e709374a1894d8bb971218f84175444420fe53f06c1cc9e67ea07c110df5bb093dbcf488bab60136b61a2971b7467f474f779dcd080fc5ee1bea805faa664051f9367f6e08892b2a694d42986b2b4f3bb97566c8fea7a6f4f38fb44621c939a3fa5e3b54d02e36e81c16582a8c82a39c7658a7aa89bedf59199b9b0f51cc2e309fbac7f2838a90490e9211c5aea2f581ed4b9f6b934a5dfc5420b6976c2f012fd603f83abae0b358c0b9a63847b4ffb2daf3285f60b60d541c0b4d86c3dad8962cff0367b2a0796783f2cf715c4b5c5b865282ae33e8397f283c1258d065bdc1a6c0d54ecbabcbf856ee43b33c2450d02cb2fabd08d31552c96a17e65b83066a535ad4e781aca29c1b6269491f7f21e37679a516fe4028fd4c4ab206edc021c1bb8e28b50af30cc902dcc325c83a81fcc60c6983f398fdfa5dcaa65b1945e5e285ed8b5933e2ea508b5711f2541509d30b4f76d45e690fbcdaca869bf897a3041615cac7c2f08d95d042e92cd0b424ab63f6e1717e136bde6cecacc2bfb3b2ed1f36ff2a6f7aeec803597574552bc2a66ed66f9fad40ea3ae9458c24061adfc560a8a5aa798b68365f3caa96b8777309897fd699dcffff2444820f34d5b11b544dfd0d528968a4ecaedd11d715ab80090fb66c770a709edf4198e020842e31dbdf53fc14ca082923a971bbcd6e52dfc519c8228589b544aae35c5ce3e84c256d6e58e74025242904ad8b93ed0c9c7de138d27ff74e4b3e3f5da10e199bdda12f577bbbedfdeea07621c716a8acb4cfd384dbf57be89d63528f1519ba03902f69b9f093dc2ee7e25a2f6351d76d18a5fa818be33a832a0f8c99f35150586ae615caa425a85c3dde499e6a070df29e18c1483e42eea9c60c7176b2400427b53a66e5041510f49be2e2de9d1cfa89394a3e938cf34d4f68d1399a7336b16908adc25a5f8917bb0c45828f8a7be7d87ccd70df8511e56826f97ba821b628bc8f759b6d94eba9aa3efb431c2de1b12ab29ff78e321cc43e879a9a785af73914108b74775fd3256cf6c7049c1d6828efc8467cd7a4577f4f774058d40710564adc762b406899ccdd9ee4c4a1ddc967238603f6d963fef76eb5efe5ffb44d27ea80c8a885afa8330fc7d33fac5fb6960d7ce3b62e73913a13870a5f0b222dfb243f5bda0829801e5d21b202a458eca1dacdda83fabb400d48f8037bafdc5a5498d2a2d95695c3a5ed50cfda3848fa806d4c6d4992319567f572030c887fcccbb368984f5f60dc4665f98eace64bf0f460acfa5f3e08bae957659849ab773ee45335f3cba79f028b6d45d644fcc74176c42f29106b3ad4247b88f04d43eea4403101900a13964257902804eae355ebbe242186be26fafd96938b247899cfa497e499f41d7fe974c60675905819690dfd043025727593c2dd21a293049299b183e4e15996111444c5e0589f3bf44e6a26531b1cd8cb91f85f579c107138224e8492466b56b81dda64a93e079cc14622d0f790af37e166e1c2335ea4baafea527ff0b6563b117815516d92ac322872014c18a97e56d9783c94c8bf8439bf762582ddf40e19a24a49a7f67ce0ed929f924584e54de56f36cbb84c780c9024ddbd43c673006e3e9edbc29480b8d9d661fe63bf6df7116cdd41286adb96bded411f5380b0928be41686d96fa524a4f0684b3189a7cb0fe315f5465841f1e82d7963b2edcc5f52d7f195692a98cc6e43e46da0032b3d575e6460822b55dfe4002320ddd4ab7dfbebebfe4056dc6a3bc6e7b80176315e32adcd75e8bd4763d34cc638c88cc2dae5fc0a7ed302768fd702844bf91da036f89874f490de20ce8a6ef74710688bd5ce7570be38c804d0c400a798caf47be569b5a2ac0d01249f9ebb19d07b82f1f446c518bb413039ea81997405c26195aa35a369bc1b0a4eee19da20df4dd318126d4fa42148b41438a724f0c711324b058a2a48fdb56457e994b81035b905a65884a6348e298317cbd8a62a1a6db186707ab62a12f9bc83b2de122d0ebc4c01630816254fd3837057c015e3cbfafbd26af63389d87234444efc9d568d031c11cae88b62cca7e467da6a8e6aec5b325a202383927086aa3478f6a15a39c4d76e4853eb5decb438960bb971e8593acf75a31f13bdabd7fbeca1d56bf2cb74ab91772aaf916e341a96bb21283f4eeb8d6366c9df62625f361fed37a1ef56fa37656b774f56823974b3322b7fe43e4ef5161ce616c62979b5be8597c07aafdd5747f31028fa719df7721847ae639458db4a76d15e0c8b1e51d674433d9532d7ddd544d8f93926c9c1608d290f521d776ccd28a78a4de53fff38184ed6cf350850a8eec119040f4961fc1318493cf7e82e5194511d93feecefd01a1cfaf8eb550c498a40c18c0b35f72d5c6572f7e6c0bcd3c8a9b21ce7b95ba790572260bfac85a1e7e40e3d550d5b4370c3366c9ab481882f367e8d5005c8fc87ae9703b60e1655cfc5e85c7b337da19d37bc6c15b1e032398b7adc55fc16235466f72ab968c7f68db95f2a7cf128cf2cf3a9daee500dd6ba0dd146a7ad4671d4d3692bbc048c38866f6426c0c2dc3df646408f2858d6278b599e5a619d679909b1cbcaa6ee9bd4b639570fa56d22866af2c54bbf70c0fb76c3909eb194d8bc2d2790256e67a76c266081ba5570bf84dfd0f0e5b79b28124a7060a2f8ebe484d860a28a0a06a0d652887438d014be99cf111e2ca7e2aa84e2df7d4d03c3ec7237947fcbf72f701478f7a13ad84712fb3bf340d0d54b0b42afe891ae48b0e31fb8b7c7452d496f784639febc81e3fa58629b46fc080bfc1b4368a132b8ba978c24c223821c12c85ccd7dc36769bac4869a603d876dc672ce5f50b7b9ceefbbc0484549bffc18ec35b2b2659bae35299697404b0cf3cda598c74ba6559d570ac5813b72a747a4697cbe1de8bbf234c78ad0d35071443365f3f5d345a0bd0c18934535be97341c28ebc7fb98dddf793f0902a9a5b5bfd711cabba96225a080ce7fbc95ae9a0eaa43de2da8d2b6dbb3cf5d828210f504a7497dbd55f4321feab5c452a73dab89165cde7dbb761223622715c2ac37ee5048b9fc4d0ce8c343d7f3305637bb0d89725b7751f6f1ba22a0e486b97c0ef2f088601bf2286a7efbaa1f1a941dcb49265200d91983e1bff892072fdd5e21cdaeb03d34bd8a25004ad868fe0804b031af7eb99ef3fc3cbb5ab46c25641da23ac8b4140c95c8876e7a1c59dbe29d56c84f4c5786a8597761217f7b485809e056656e6cde184e519a62ed5c04d32e508060108a7288917af87923e1170fc766a6e32dd544bd07c99d1499c46bdbd0afcb34b35586951577a67b10ae66312a5567ee055dcb8b30c33b1951174f18837eaa17fb6d355c17db8bb5bd6ff08a4eb25506b75c9f776c8b5ef11307ad37148d03bf36cde7c67e9561c8901d8e60a94cfa6c4b7fd8386f2164c5972bb8e299baf11b9c3facbf701e74dea47ce09a4cc79a98879435ad2eaa4f4d1339c0c5469861b2b1887991cce75786d75e8403b9de68dd11d49ac1092a49ebcf5bfa07b4e3308d137ac94d5609079751c61872b8d475c3afa3e0410b8b145a1252b7a0eebfc6430de6a2d976cf8d0b8f03f6fc7fe560f9dec68d4d5788555db4bf37a22ba2beedce40d3dd8fd7a8ff3b0eee42076540c3985c0f8cd026ef8903b73bce21307e115c42154cd91de9ced7d9e456d1863d149505192c13808e46d1c47ccb74d43ba14e970ce2b953622696fc92da2bb164592aaed4548101321a0195c2f07f093a4698b678ca23731d74e107993050fdd6b21553b2699bbbd91b50beb2e5b86b0ed92400cd279dec4f73fa620ea27efac9a5a2210e978bc636cf6b5a09b6e59e4524c3fee4ae247ef3623fd9ac046ce710cbc5bfd3cee4892b98d749ebfe16f07496c378298cd5e6aba0ea016d931c9731317565240469f13365f5085195e77bac8f45e1a131529425e83f91cb06b40e834adc9c7414c7ddb2b9bf615bc6983c00c994d5181be6ba262c0984ceb6892bc26f3cf15c7b6ffd122183460bf74182304efcb60d2377fa616423e32e4e1555e72ed32d3cca1bc16a6182b11329d10f1298c103c948d91ceb2bffed086dc223fe099c01f14865104ce830c53c8bb474b6bad3feed78c1c92f93ab3be14b251cf827e72b24676cf45e27c96e9e379234a6d2b3c79e2a5fcacaa24a0c9368b49b7408e1acf39162914d4a10e452721d44f7aa57a8ecc57ec379453d4db9e40a38df7e72ea83200c2ff5a80793396fe51dc28bd374e9d5affbf4145cbfb7cb00d18574940a4901399415a7502f2ee26fa9556e2a8bd8aff0a49d92172670b80bb679d81294868ea6789b56eaee6a102d8c9c2e07f9b2b588d4cae2cda1abd1d78ab5d2e4f775d674d9c8d71aa25d6fa765bddbff52c4b19cd22df5ef4a7b12babec328788fd705e03ac7a9d8c702bd3d6018692eee2ebc2e99a9c53af19cbc01bdf54d5ca45d1324b0febf8f109f742d6993b850c2130fe8d57c87bea082c7bdc5c455f9d930b98aac13145ca29ac8677a52a8a5c37a6cdf06863258ab9e365bd67db6ae113bb87e7e8f5aa34a739b6b65dcca2fad4aadaa2a09d0d685060a55f5df7c78ef42c9c37aa2268f725c23040115bd41a02c4457905a01320eb5ccd7d8e0e9ed55f1f599cc5262ec848b431318103bbe096f36b363e1485bc80676a24b7bbbf75eabd9a3d8e8584adf9fd8d5cf3f55fe16697696094d136073fbaaaa6e7bab06eea99acbfd48af23b984833db1b52b1dac0b92e339a441c9bd4e6d24f3f20977dbf13f3e68f538d65d9aceb3656f75acf93f898b6b1712cfbda1eb37b1fc564dfdafbf8ea49145ee00d924699ee38e54b983445e2f9610f1991736674fcc77840eac71e86726887d1c53f5f196e4a6cff88bd294904bc20822724c9ceaaedcd82fb913838438788ad6320f2633c9be32bbc0da8cc117ef9141ea8a7deb460e070d980e90a75ced5fbeb49898246329b93ce86518f3fe13a03d3a4123c3b5c9f4e57473cd1c7738ffddbb5250de74b1a491c5daba6fc47b20bc96e1b3a06c9ce1f0ec61f6f5fc8577bb30992b4a00512df27c1d574646f76caa014af0421643b678f06c43ac07829c3e7b197336f1cb1b104462f0e76325b459f4c17032cb2d47f2c2c524ff35648de23d1cb9555443235fb51869ac1f5b08f99e7578a2a7f0322915275122aae9c02af977e2c7d5ac319fc07f4ded6781499a02de309c0fd2f622164d27e5143e3b3dbebf37bbe8bce2a9d0c0da778f7e9a2417b509aa23d297f2c963c04c1bf80ea75bd848d3bedd8776ab1232d29f47200e3d6c3514201dfc65bb25d8ef50f93fb988d13c0cd23e6f1c23bb9668d1b4c324973a2b3f1166f252fec23fe559526d074d49f96763f97b4cef6599f42c27b08c6f4ba7183ffa3ca01fffdffc69e410b07e24168deb98a6aebb2a109b09589842b3a60f5dc5bd26a729a32e8ce31117ae875c1119cc94a1cb97e2eeb30aa10cc7c56babf2be151c39abb651fef3ab86689b19eb8a93d3805364ee4c5ae77d47d86cf8ee7e38d2839b6341797663ebef762a84bd835d2d29ab2b6cd40927c88fb2c1c2aa8b5dff40d11c4cab56c353880c5f8e507dc50c31484fd3cce0f6edb0340bc117508dea753cf4d84799f30f5410fa2a8f9ebc24b74eae0093a9222f185f8c1c6f7f354bbab8b44c57439ae04e11f328645a11bb332da0a81a9cd3dfad30c2e0459f420257d36f82715c90f12c7d591955f2df0feb725ff642a84f429e1dfc34df6656fdf5b4d1635710e49b2a176544054b23ff100d72bbf07c3f3aa8e1a21d437318aeeca828f58f19cad79edb9dafffbf82b2093fc23ef856d4bf532ddf0a9c4fc6d0dd2211110188cc07c92c8ac4a292f02a66a988226c7de45ff3a82c73e73c1818ad739c157da06e5c025e5a2d060a6b509942d6d4b94f445240ac68c7befef250fc72e0cb077b5f5ab969941f3133d987938e48ff6c1e5f5017d3fd570e510384e3da0a33dd719f8e7c0fdc0b399db668e61ec4bab752a4a2edf526c5bbe137be0f1c8e0ae8a8afdab2f85b2e800fd713c3b5e43bfb4523fad080edf46ff59896d9f73ad67b96c61122c505f01f324a8067f8697cae25e66ba032ba18e70cda9e81d21e996d3ceef9d05fabfebfd716578fcf055a17b881955c748d1609ce9f783d4e4d0475bb4a1678233359b3f3d2b04f504231b7a636b8c2abd7ce798ed04551b8f665eab6778ed20c6edabb32f6dece15cbbf686a6260f0574eb9377c7aa0ebd1e718bd91562a9ae199c27f8d9fc51b87478a09fbf6b707f45eb0fdf59f7e17e1f3e1818b64d6a7e39c174d9bb40ca70fb1866f60e528e71f03623407558fe5b21009aca11bc955a19d612dc263ebf53d494e7ce8bbe6edbc7c4e5bb974a81621461bccab624511107108dd98659f8b612908d802b38dfe878ba3df61cf4b2b5a73696fb1fb75d4c51106451b27dc2ea830ebab0e037aac46780d0fa81d8a9794c10e9704aa859aae6b3db3574953be56e7345c33804da20e50c63324418dd9620f28b22d41196bdd8198d66c5b9d5419386d5e321b33880b37bd7f379ea757dc971da9e3d0dbd9f4df20caca5cfa64fb31d305bdcb642a93bc6d996c461db8bed63f31ab64f9b881dda1ebc4f79f42e5d012a4575aa1dafe7c724479de468ba6626c601d206c1e37141233067379a2a1472be1f51942e4b5a9e19d99acc540005baf088277416a3ac69d2d2dd3c4ea6756e928129c1c4cae8df3a3c6fec3194850c549f134b3b6a917a5ad071278a3b67f884d5a83342c07a800cd553b3bb5b0edcd6dcfebc8ab4f4246e97498cbe795ec39026382a731f3c3b5206027aaf096f88dd337c79b58e79ff0ab51682adfd52781254af976568fc6c2d6115ed0871fced1a746e63de79dd4da3155bea81865d044967697befe647466a1c5b04be7afbf0645596aeea49eee870b8fa25d5721f7ed8587ef6526a899555e2fea7d6492f08dafa28cc885bd544e91e0d69db379e2437b3c6325943f861aa7ac8939dea7cbcc1e6988643243f5ff30ae711c9459ce73eeb88793b4056b15e0839d91b9298a8e2e5add65844bce2f3fc43031650fb5e24a5f1b8a82980592b8ccb6da14a068d664ffe1d3e81eb5af98599381877f321abebacc1a7621eb28b89ebb92541ee416bcd1307b9953b2618661f042995b601b1ab495596506aa1e332a0ba90980b94e5c521c4c2ac5af00d4f0ce5a6d6dfac811df93759191743e49ebaac9eacd6bc90dedbae43ccd108f5d0afbcf25084fb21a78940582a8026b7d3ac0ec33ff67df21ed03302176bc34bf480270885be3d8347d09f38b40811c97cf35bf745946981fc361a1e208699594f7a45ddcba695ce4a3241f08313492b55fbacf2bb42c8d22906c04fa0beecfb59963efb319d671d27895fee9e95e69ad7a8fd152c9af24d012ba8f59e3a843e74ac18e9be17e21e55279885c90b4a618552c65eb53b0471930e691643dace0722718102f8f4ccd75a499a2e90cb82e205a3965bbbc6ed0a97defb26bca13cedededc44ba46c8d652c7c12a311d757a662575d91da724bdcf4a4fced5448f210da6a272ce2784d4e267b61d6c0973dc68e762d5ddc84d0e3c1be357aa61492d492709a23a780ba78105154f0277df4a16c1e0d98ea44f99b1deb17985827d49c02dada5885484f53e1963368f8a0a7a84b662c2c05a567ea891ed6929786054f848b18e4476fd79065ac6a7be094e3947ebbf6be1c83047bd71ca8b10e26c3371d5d0e2973dee5d343cc0b65c3e474279e8305108c1b5bfd2a918121a4dff588d17b45fb9e5ae355cbea49df4854320b84431089c761c44d90dd714ce5c8a71ee7440d67b20c21349eb5dd13df262a719815cda9afd40f2bf1bd99d9d579ec8c0f34e73508163c891d43bc81fe1d7d914ffed694aa559088f4299a5c18e0df75891f2a0fde78bd717726f9bc15eb53371e3cf302d793c9695a16602caf61c5531195bac5dd1e971bcfb8ff703106ab2cd043a2e82ac8ef080dc61be27ed59495342dc8d63ddab8b39100719990afa49c1a3480063e09d76f90178641101d9404a97f7f3cabf9fde956ee4f9172bc35d24bea9a909a6581a172ae3f3244fb0be20ab516432f41ce9fb6088e7251f2737ccf55b8332aeec5cb854d91a5a40f15eb5fb135389c2b93b63a3e27af57ac9f89637c07e2581e7853e0a092988ebaf4d97c0c4932ebe6822325675b837e9b8ee1bae8501cea6966e6fe67f6ca65f1f6a57bdc12c6e2b80e525a8bfc9bb299bec4ff6278f936a421b8fc365473d92584b2ee63b44d3614bb7de47068bcc02317b76f8304ba9511db7e6c3521cea6273e5b25a9dfe670079532b1d5d8ffe5ddb20375b067810eb69d4abd36ebd5326f40827388de2af019bf9219d3fb982fe727a5778afd75ca9d5960592fc7ae979754f060ab3b9c18d31835a1743107d7ade8a16a2dd5c6efecd2bad1fa98292bd0e4dcf36b696bc0410d13c93eb210162b4c75361686b37e5aa4de05ee653335b45dc1c46d3b3eade1f4df2f08fbd078a1eea25ba3e18251d16f5c9f9920a3a62f2d313efde399db75e926a56ad6147672a28ce41f76509d04782404336697fda4e78f266a1d178c637bac17ea9ade9b628e2ae97a7d883fcbd7a3be0235661750c7279f76299c3cd2d0f0d56b7d6bae8953d48f7fa8e690a3b08425aa1301dabdc1d9c9810780897235bba6702391e4791114bae74c95c56fc6deba09bff1a88f66235d39e1edd8c2a4843a9501a1238fc1818dddf978bb4ede0663a0255b7c993266967d1b111c64b691e9d202eac124e95f80eeeca3b9380bd0fc63f41830963ff29f059684224710cbebb92939cb79eeb33a7e65af942729cd753da5f7b9fdddcd95142724f43796dd59311da3492e992bcf884331a3c715a51a493e704fa620c686837fa9abfe2416b57583f1ff639df12f1051444cf0259a396883a851bb8817a31c20d675c5bdb97f4939fb3039f91c4a3743270498d01c4cae3f67b51289de2371b2a413105dd92587a8c232d9308e60ec22a9f320fb4656d41ff53c7d67612e130480b23d1a5286467591aad09919dd8ba6368aeea2eaa0c08b91fb2e4b21b6f8145f6ebb4835488385126135000c5614fcc7242b23624e299d3be3fef5e5d7d7dc8ab8cc3dae0b107c9ad653618ca7d3edde9ca80d40ab6d54f8faf4f07e3a8692886050a15d2f3fcbb7901a22c9624ca2599850b9103528b2f12073ac6bd2866a653689aa027060e4a6af0fdc1161dbd89089c8ce2564daf76ac6d79c3ede39660cd685d94627a1c10b776321b03eeb6bfa1d1f19e36aa91f8b1e0b815e3fe0d01ffa62b0fe8fba3d5b9da2b93aa6bab856a95e537d1b998f283db666a59bb4aa5f461d3005af42acc0b433f1a1397b9ce47781ebd892c08b344ac052062f98903ad4905adc1372c2c667e7f3b72ff14aa4eddc9d74719ec0378d2a221a15dde36fd70b2a850ecf085af0949a2083321c2e8ddeb936d3423767a279bed0a2abef360f50479cba784e39db9570abed3cb5b4ec395e82c853ddcce5b3a7d335a31e30c6867733a649a1ff908fe91d0ab2696d4d5083f23bb627cea9a5379eacaaa5b96db4419b94af15fbf3fab5984c75a5f6a11a4dc77cfd36468d0d7629effa7fa2f61f7f80da3cf6e45aff031757f2af522aa9137973e571669b5f183e0cd69f4363c0ccbbcd20d3cea3a537fe878167a4f34fce7ff1a35f795935cb9306c17bf17a690cb9e9bda0692d8d076e0dea5e28117b725e71d1e048dad6886cc7bea7e132806cbb7b2becc75df33a2033c382188f7b63ef44567e9475aeed3d5326290ae82907a82f8d2791bbd187bdd8bf392c8abe2cbdb683b7efe069a136545dc9c32dbd95006a1827e7db22efc058436f09f60f8817f7919d6a54ce167cb5b939e52587fdcc6fdeb84851ef5cb378d2125f0ab52f279ec8396c208b8cf84063f0b4ba6c810893b9c7760975d55017759e2b5f808ed846ffd31fd37df0cda23f5b28d51928703328ec717186d29d70daade4b662308923940286a6ebdbf277c2c105c05e5577fcb03b10695a425ee7474381c43a5643cdbd15c7915be34e870bdfcb2d989a55dd323716a9c0a7df3d94b530e787efef7fa273eb4525a38b31e27a47af0827bab9e10a4e852c7c67a47035c17d6b53b5728d84efdbe14fc189e77c96c383c03083d2d44a9cdebfe91d6fb5b890193b9f2a0529fd918bd27080b98da0a896d80e97fc99d3201d5532b195606b89e0e46dabde47f1125c3eff20c2b9294ab060406e9efe799f377ea560731ff23fc40bcf615d2b1dd458374e37ac395de4accceb144186ecc8aee0ff83d92e3afee0711fa5e9e29b2a373f18205db6c9b5b8a4720142bd37732a774ec99e1ba0f5ec56d9b6c2eda1b4c5d230690ba63a20f45fa3e5c9ec05144eaf18d2e8601562f12cf3966860dfd09ad87f7e340e6e461d28456e676a7982ab023605d8479dff41b0b4185b079617c6372fc45ba5ca5d1dcb5f7ac7eaac6405d42b7454e469b8bed1f4132300c4c354e6a97433591b77ae26fbac4b6ded10b056b508e4dbcbcf71bae7beebd03e295df779cb4336e24d7f5654e7a68bb56b5b8f0782eb24a82f7bde1c151d23b6562f6656c5d8d3112733a62fb2a26c12da3c8800a6566a6d57f3fb0b21d30b789c594684939cd6b291153e8bb3b696824d060ca1f021bf15d58cd0990caf7a1a837106dd49f29d05682de2c70ad1561466578b4e56a9c130078188a526514a0542e19c43314dbbba2f99af52a075b70d53176eb58a31aad5e84c04d40e230ddf0ed62063341d94cb449653ca90cc2f19ae8441f64201750ec95816bff226ee72c159e2df691c5dbbad2ee11ea491c95eba36118075c7ffd9f29260bfa681a3184b69406a8e357f845d828b2c58256e2922334cbc735b6eccd2d8e4d4492c852817a1a538253ff546f56401432a47e5366b89240316409327a8fc6d76202b3648617a5fd07e02b90b237a0ab10b6534976d595d044437ceb4c85d63fb7d717552eced38d542ac0240e97d6c00148016575bac7a375a4d9a394c2e9b0f97782ce5545dd34b791a7a6e6882b5fe37c6ad98fe0d914b25d04581e58d76b95eeff94e66a142de33b2b614b71638599f76c127ecb72608e776702226526ca36a50800236ec15876c72c78f35e75c3b5c18f294f0630fb54c529c46d5bce9b4de98d8f889c257cfc41a86fef5ccd9d1e6b5299ecb40ebe1192da4dcff3afb99328adaf3d347fd84397125fb58ef70e90fdc6d2777d405d459a92326018f73ebff4d852a02ec6f7a50d36ef078c8fbfe88c6f5140f1ce7b4646bd22c27603b87f27677449398c0d190aeac884ae380e4b3bb6d1e36a9e009e70faf97d62931e244f079df5a7484af55ac1a3921967a0f69705734fe18410e3c8c17f3769f7dba9dc54d777d80b85c93ecbca2b4a561529d72eb05e2d2d2ea623b1be0aab3d7caad2926aeedba04238f2b4011c86833ca28787f9588d134f247f0003501ea196be9d357eb0d3c13692c58fd3ab75e61d2a2618b53d11b5145a0fe8fc26c7a4e3252a3be53f5aa449cea81b275577c0b645dee92b210a4b3ec04e1795264f77b7fd67a7762be8dda928818bf586e8bd7222ee34e65415ec6977f5558784f80d2f77567d657c5c6cad5ba45455069067fc44d3f07ac2c747d66d78c3db47a8a9a892d7c556673229ea158dbe354e2bd8246252f9e441aef394ea24584add342f58e1d2c327ff2fa0afa724db626d53387292a426a435ab59b515da23e43ceb0738de35713a9b52bd7ba2c21d011468b9abd20a952948768af8663973ea6b34c2d1d407e13954862610be70fd9c86224622efc453f032423d9cfd781d0ec23241a09d936b6e23ff1c79eb14760f04362ccde43a7529ebbb357dc7f492e2229660a7c60b6beed5cf793b48382f36b1bde1468315ab90cf5935b78b889ec66172c3bf685f6995b78fe3b2e5a1150ba1ad17994e832411746c85969c9653371266e607b6b7a77bcac99f45451a49e3928e116ca2e881df4f1ee06570f4aa7a3d8d184155d7b3135d849570465617b62a5f9c46706b444b2bf2a180391c8c244176501fb5190a06cbfa15c6e6923ec13e4cd7f50c956214918b9cb552e2a564dcda9ff1abb571a2f1d04b0e47cca92f25f8512d62265bd75f599ec81d00ca75c84f78f23fbbd90bc2d8cc181e72842cd4fac63c98fd308b24d642dc92269f17a9b5034ef337e9976d6732881f34db2c66677455c92ce27096125c7f2a6a5307b407e9b381f67fec8d362e6d97ca9f5f3c79192a568a15efc92a2819e58a8cf79795bdf255c210290a989665ca9f664fc552d3f372c61627d4c7e413edbd6dcb4237be9b2c053e3ca76edb124574a8221abf066249422dee8e83db1718ceeb8ecb5094641b3b7be13b61bcce185116a4ca66e6c659073c80f5b0de8f811a69d9c22864371378a1e978aadcd3d26aae9928ee4e5f53be3d05529d6cf3af2069e13ada6e27ad77176f2d403c95a325bd37537c32f2591459f911ac13b3f8a659cf8953f7237f499185eb4f22129eb2f49cd14bbb1db7dfd44b4227ee3409f17b11ab99db8ce26fb753439b637933ce11da7b39f56a34a798db5b96211f54f898310edf0e12090fbdb6d794af3b50b94bdf26b7984511ebe89cb8d821f915ff8c295f3a2ca9ea37a1ca8f9cd001ac60730c18029252094eefa50e2a5b87364447c6bd0dacedd49e19dca51d0f42009356f8e7ffdc337bb61ab13245679f4f6697bdf197a55453f341a7d3cabcc00a10bea75653da68d0c1d93e2526da55ae0b56024357634843be4ec73b7d13ea625613778ea2b77cd75a9a5c42373c4a7ef81a4641c3c9edb653134ae37b682d77678ea5d6c69cad3bc3857d03cb6c2eec61f0cde9011a1cd522373478f4fa6ca443a33e991dbef92a1e307a161fc56e7d133d1be213433ea013c0b2aaba8c9b5f64b791d9f92697ddb1b561f2ba98bb007a507e402a4501390dca413f50bb1b423fbe7f3c28dc4b033dde5cee14314bc29902a27f968773cea8730d5b80d792359750c556c949662a7e4a5015c2161353e3d91af49769f38fdd9bc7451e41a14e09ff1a88819a36df1e1c45f58d54e4e3044d458329dc6cb32c44c12fa335000005a85a5c256a2e9f57fe4f349eb477006ad49c513df1b0c5130ca426965a8922f0bfab9575b16f9ff954733e6bce365d31b818f34842d62cb329d0db1dd08608d4a22d8ed81df7b41389b4baadafa09bf8729d0d9ad7a261bca11754db1572ca359b9c4fc0a8b50df82773829d0cb39ed6735f41a30f51a6b0e363b265355b60f7b172441b255227f39d4c3afc30da19ed652c38f23a464293426979e636400d52e33915a8f840cf19011432ddbb1046cd742ab9f66b1b25838187e20de3fcce8925eb5c9a06aa1a1317186f5b1283d1422177f5d49bb1ce3dbc3794417b809b98bf7564528e072e5c65670179e52a3a9e1ff327bb23fd8238a1d9ae657e06874e19994ebd3fd679dc3a91f33e93f3cbe2e32e545d4d5700afb0b337a754c4ed6ce769233ac2ae194c3a4e4f39f7883c3bb9cfaa4cdb4b1c25440bdcf511a3573d052becce95ddd8664ca6795d1495caafb39f98fadd65ef0cfbfa6336115ea182992bb782c6b07861bae0e349a353f2c05002db444bb69ae8bcbbf239457932e260cf2406696fcdeb0c3ba74d3c5a12d61e53ca50a908bf824f1a360dc1feed368cd18991e3697214ce3ef7f51b9b8c652ec5ed28c7d55f71b0f0cd860e28d3103bafbde9113c9f17e42a2904631a81b2a8625d861e6cade638b3cea5a16dbe754546c2bb06d40aae375565b45f459f0d2a9dad4d0b2b02dcf03f55ab15719c8b7f11ef7ae4e08f8b5ca84c4e8b11de1d53b3baf45b3457c31d6bcd8d1ef469e886399b0a8526036e7b06ba8bd65530fcec6945b1846d4f7b505ebd5a35e52ea17436f0d4f9dbd17600c096a6eaa75a734c3d631b4448fba6814904b8933ed8a56963f2205ffbfde2531ae8be821bf6c417731c007400b50c3cea7c8e9be123f9134578517f657c8cf70819dee9b99bbf6c8094f29505a9072ecb44308c4293a6ca51ac5b679803197625c9463ea58fbb33a1bf8d6f8ee218dca0a0fd16af4ccad1191d0fecbc4e8044c93063b4b739b5352bd919af2c8294e24467a3c72d1b11b95e0cefaca9002bf80c357f1ccfc251ca9030b0042e753c2707e1418799d408bd29389cb9e4c53a97a58b40e1924a0444d97b25b74cda73af8adf13a5c0057f221c36dcd498470e8be1ab41ec42446f9e1bce743cf0fcd27fe8c548f2b74eb43c8cb7e2d473a39d4b27eb286d74e4058b59995250aa62008938edb0f83fe4da6f32b1ac411898021f76644c30eaffe599f84377996787f0bbbf0711f51276e47ffd5c6a32d1ab79599ca70161910abed2df94848fea0bb83622651eb176f1fc8753bd727db469ff4766784ef6abf27dd3177ee2d05c392e055868be8f4202f7f0e47cc961337dc2b2904db51947d3dd76b84410a5502ef95850aafb25e98deed7204826b729ae2a8849be0873f3697c4ffdbfa994e710c2cb2f5dc74d90d24676f5194ab23b64978b43e11f7067c32d2006c6a9824123d44bf127e21553b72f33cd0cc7cfb873ee428257cad36b9fd3e1c76a41324b84724d5b1876584a11e6d6819cb10c69709e6914d28f876269eeacad83886c7624c368f2d01091e67e415801f28f6eb51b04dd9ad7dcb222375b6fdad11d721f50a3d2757155f7dce982234d0a3235f48df1a6e643e39a9d8204c0272558595a40fe0d21f25056e1567786f5d02d0961afa9d00d76ee4eb1d976f0571089c694c1e03ef9ef9acea95c25172c27ad5eb5f82fc78142b04e353c22063a2f273e952ba03524f8ad7625085ff731d2d9ebae33834470ba13e89783f290ec763538ecb968a3483751141a3ac5668f4618bc29477019690989d26d2d37f08d0cbab50dfc88a4aeeca4bfa01fee41c83bea9d22c25cd5c9cd07d55581bf804f20529befd6f50aa0eac5b38355b1c7fc5dc536b08d7889b8d04bb5c3d2a89e0ad01af40b279a6d1c91f2e4aa4b8ad6e3a8763ad431966a9f9df6c0c7d5264cbf35ee1f7b8379e9d74980738ef5683b2029d73da5ad3a69af0418a0c00aa47bde445866caad9e1e47c770e92a873de08977d98f4bc4dbaf00428727cdd5a5321296dca6fa580d30ef91a7748cae953532a73f03c76fe6abd039e99db032e968af11d65bc72d33d767376738f8fab5e0d6636fccf14e21db1b13cccfa1d5847598117a1d8ce154cadaf5b7e446a2640ebccd4650ce1fe7553567c4a9b5b3e8f4219fcad2d7a7e1a6dd996c78ea6082ed6c5f6deff66821b4275f482700f9127fdd41bb1522bf11bf3b1a727b40b315c392b020bf5b060321d25f022600ee638b1256a9a275808ca3b27f152d1d26ab8909efefe389ecbac90d473861eae7582191174a6ae5341fd83edb3da39bb74c8478f9ca31bb8598cc2d9a5b7371e838da11e382eae0c1d2f0482e7f0a68f6da88afcfa344cef7aa6e690f7b2a064853ebf9d0b212efb6425ca142ad1f8327d92fe17ac2d1d29537a78069fbe848941842744a1fd1c1e0200900f36117e419a8be904919d44ccb6d7dc170dfd577f6df070dfe1c9a09b0eacf075db9c147b2b6e4d41ea3c23f001e8f3db15f99e1f26be8fc0fac0056da846e8cb2c46f0370cf797be16c913072ded17cc3ae7f7e8de29691d57cf857afda0bcaa39b0f8eab5cdf656e18c2f1ef16d4a38a0470cfed6ad2b43ed86b532258bc8972328b12ce9009d1ea67c7128377ab65ddc2fa02f46431df2cdd9f8d306f083ae1d0ddfc59730345ae454e3e637aa1266e8061a1aff9b8bf45934a197dc36e5f4c83ccfe6d8c9bd3c91e3aa30905e2bbb97fbabbac8aac0cd1e1dfbe141b39226a0310b32de2c79b915797cb92b1e8c704067794ea2a08ad856f8a15cc6eaca715d0613e0993bcfc3231d30ea7f63200f6cd4aea9167f6c54f9df0c52ea638beb85adb5e8d84c44cf2ebe285264cbf7def9b8288f3b9c5dcc416f3f99bbcfc6eb4aeacaa0d211645528552c3eee7f4bb33c787e1d471355478cc4850a347fa5a1c31e5b871b8c7a256c23fa48eb9a590dec9552b2190613396fbbc0ee1254710ae5104e978d70ed9edefef521d4b8877c6131cd4da1d285951eb6570dd7b24774a25d6a28c9492571d1c30c14ebcf3e5e7090ee5e64671e9a2549cdae6479e6afaeaa3879f8d7c73c9374ed6363593c410a5f9caecc8e938286d44351fb41bd13b835361fa771d1d6b702b853be8bc675fc66f590b18a19b1c4d0afc7ce3d6a6cc8c1776a298bdfc6d9a766acf939e90de8aa779b545b8568a40501911e63cd64b573f6c532bdbed99636c3714642b4958ac888f4edc4a2295e5f3f37f5f845288a3fd023601e71c472244248dc6c9e8c9723019271807b4b945f7680d97a5663330ca495935a65d38c6f142d7dbf9cf3575546f7b65709ec9d5df0b1a04e1a0bf0e9fa6dc14f492971313c9f072e40c2f314707d3782afe050646d25514e713e482026cb852e52657f1389b827d91932ff22c19077cd2a414d953105fde8a40aff014f73308ce0978c53a4f8251b0da032c699badd4da810905b79af57a190b69700a45cc98be08d768a8164ad66762b1d741bca6e4cf6a40fd3f5478556b4a3da38e0003663e954e6c028652062eea1d7eb89b4cddd5aee8bc63d7aed8d0aec56b86786a3b7f1c87b8214592977106802d18740cea4227f57e3a3cc1dbfc677c25cf8ac1c79a43668891230c2ed20ce279f684228165c6dc9a3d86ee252f736f41075bc141ab0f1d0bf11f5d624115df0118f049c966853a2023edc5dbfa90241e61bbe423f159a30b54ded2f7e97857cf9e42947aa29c7c93662f215a547bea31491030f1b0d176e47d0603db8c8865b03ed4a2069c403d52b05a6da72cd16393bbf1adfae7797a122b082342c202d5bdda9f6a94ba1c468f75c1bab93b08aebddd778350cb476ae924f1710ca907df3e36392344c27b1f9b504571b67bac60192e47a701159389d856184db85d687dff127cbf0676f83ac935ca14be6492ada2954cc76a77363a640881696d5d21e498236d08cb845e14ca433a7ab1dc7f9490470ce2b923850b921383053318a9a9ec2533bdcbeda65e1a03738ddc1e87b8f27a66f7458f77495162a4e731ea087a2d8f8c465f1def0b30e691bf3fbfd9568d59038fb45f08ef4549c45048a4ae60f389e417ad6f2d2ba03fe03c4b146a1efb429fc57cf2c49a670a648b85dafc0819c354494f29ed5906565afbf18e0ed766763b9bbe2588e216587be0caf6c08b0f22ed84f7c219f3ada748295106a0a7e3649b78580e4d56102520eb9a0ce778117239d8ac5abdd03146e7ac7ed596cd02181a5e167775a6e6dc9410e74589a2f6d313d5b2e5c158ba86fdd2e1c10a53fe74c2c96720eb91f785be2a2ed5b08ca99362a7a8433ebb8b220ac58ac5858bb7ff855963757b0b2a127f0ddfae8c2a181168ce0e55debb34fa7a075121e0406b21f6c9eee9e3ba971aad8d169254f67147d3a5979ffa1eb125dd20b5796fcd9a12600d3475bf3759c019f36c9de7b918c806105504d1125adfc9fedb4962d84cdf596c1f95385ad210fe9d888f113dac36797251198f9b9621fc4673e77f9cacbfe5df6bd1f54bb6db005ab1a311981a6b15f179887539f5e0f885288cf338db40c0ba5f898f33d089b7654d7b0d601af90a1661fbd782d9b65f6f5491ae48d4f5446b4a98f6fa8ae9d8ac9d2a61e3ca74d5f80c215a9f18242640ac041688a27cfb9d44e718824e816c5887009486c1222c1d30dcfae4279beb52c71e45748532785bc9f18def6bf2219ba223f7e1d7b0e0ec2ba0619488413f3f807a41e81120f0b5bfe8d3ef6e289648d1f10a8aa6a2412e175b6c9c2d8ea30db3b5cc81cb1356140f797471847ca59485b57d277528a97840ca4fc8bd8ef46629890066a643af35689370821ab13b7cd0948d2696be1852b56fca2c4872b870e68e7e243ad4fbc131d336ff7d911af1fdcc37237287343a37a0ace750b0a931eb973468d76001756e8206f6f604cc4f11cb0bf7e31d06db20db0b4ba231c32354cc839b6216a519634a86413637305f9b8d518ed8367263940acb03bcdb05b9bddbe2f4eba598ca1c43afec8d04b42c146c07a7b8c4524c5150654bb7b6b5ebe8a5bb4139d872884f948801e363df52204ddaef0c1ebe1e87d634ef37cba19881dba1ce0cea5f00e7ea1ab47078022b7b3b157d87bd47479147329140cf804100331345c99409f90d4cd0039e5c0544e0c3cefbc7d0253a9dede322adea366673892bf94bc06594d1d5fcf039c7388f5b7192293974ebfdd6aaa40c3bcfed70e4d94344cb171d067b7ad0ad1d0aeb73649af392990c4f4f65676fd6d67e1e24d9401f9363703f4b3a4960633866f8b1fb1fa4661342a6598c8cd74e23c1b25b871211e549583e53b34925eca2e5bf597fffddb06d73f209cf73906d4fd0e4e5997499f9e84cf2dca4f78976557c3285cf65e06c0e3fe6675adccf6e886c8a7d4bf8f76893992f55eb0790cd4dc88b9bd0eddd3d2ee0ef04a5c5c353b7cdc0079fecb719fed4f72c8951dacac05685d19ca0f5356be1cbdd8a5cae7a42c9951318704d1aaa4ae88eb4752a1e03a0f90e05f5f027796f925b2ad78a5b3d3f6fd778903a6260f3ac729b20dc693663d0b43e6a56e0c73006c228c15c9526670cea66e13a232dc8b5564efa83fb8a0edede0d0fe467416961109f7c8b96cde55c3b573320b9395716e488a7eca039c6d01c96efc8312ed83c217ccdbc1322408e45ef096263338263e78df397c1dc97f2e9bc63f9689be65e1e90d2d72afa782e47aac3027bbac64770c72c64dea1fbcb6c996c8848b2e5177ccd31886a8bb46986c6526f484131b0f8a307a1d89b0ed7bde1a4cec101968edc2d61a90f84643a21b93e25a28cb89c94b7630776ad9eeb4a90f4e9c62f4b0178f66358f55ede5d177e98675a85f3d573420edcf4baaf6d53a604b7d93f836b3d9b6067eb915aa604541cd9f1ccab600e863125fd3b2b4a9dbb5c9e3f547931339e684a7865c345383d0c77b9fe217e0c551a0decba37963f50631905630ac4759469d01933c5113d3139b4c27d4e8257831f934b38120336a5ca97f27ac8e209d3654398be2cbd3388c6c3bcef4b3dfdb74ca742b677640682078f7d75ce0bae7016e1f93e86089c176ddef910f69c926f329c25b7949a01570c70fbe570840d407c4f4605460f4e0ca62fbc89d8c173ed3ceffef64281d94737b24b8c6ed362ade93d8e1a893c6192489b5518beea3753cadb01e47fcfca66fbaaf7bbdccd94123db25bf913a2a55fe3cb1c5cc0cbcc5dce29b92b605b4bc931e5f84ff0c851f6deccdf8399e1e032ec24a93df54ddd2625306e4a6a7a741a95aa763646234c5922e7cb3c0fe0d9c864de3228005e099294697cacca5250abaa0e65d4fa2bd2ee72137226a1d1460a70f91e3b71d6e71159f9dcd3dc25321f8a130724832db9fdd75fd3c0b12b2dd3530ecbdbc25791599587d6b91cdd798512ebee5c64a658947fa64cc0ba9e5b09404009fd083d58bb2e45b7c2367f086b3b512e6b193d28746c7527f8b8c9d6b61ad5f8fb5557d53bf8d05eb7825a5b48262c8f866c98eb5ab65ab680a36fb968136d1cfbcb76695aed2cddc5e5894f90c5dd7be3ab395b1c9bc750b6eac3b6530a6f753887ab2c5db6177f782487478733e572e8300b9a92beef3b12c6ab678e27f9c124ddcedbb9598ed3b596e780a2a2c89b1af1b21b0e241c2b396cb6ccb8e56f11dde5f6fc3e80ebd3227d758afa4f72b1df51a2130ade32b94d7e3d9a108746a80c6d4304961d2292c4781bca66c61ac7dcccf619cfde32230d06f90ab3a8d10130a8f829f350d479e68118d649e1e02120e86e1555f5604fd32e025baa034a33130932de2082dff6f0e68cfad8b040e1fdd4c758da9a66e07eae0aaa222abcde80eaa8f1351049bd239fbec302b1bc32c90087df43edb7a9277d0943e99dd78a956b1241118116c1e1f15bd8145570f8f7095b16d0e42a283184ec4ad5612430ddd2fa547301a39b46141668a1da311a587a3579a03c1b2d46600e17d7ffda887406bb71b59052b13034dcf79d60efda2ef40cd5056d4ca05a32e73ba5c3db96c1d541e0269224ecd4360efb34af9c68e7c013690b91635e8827667629be94a4a69dd4886c43fc53a776f48f44895038e15b7ee26441a1312cc5e95e65e61280423d79b2c03fea1b8e202616e43ce259945cf147aac14848c2617c676081f92e493ee13c18b2ae9c030b5dde8ede0ac655fbdab50c9a9daace3908e907af3e5529fc4cba89baf5e72417f05224cf63f8a2f377bde717c795efe4b345c1f3794f361652869db8bc656c474c94c25f312ac1268dabef67f00ea7a007c953081722a3edc3168333cca603957c0864ebda17453f90ef61c73e317f29162875f0502234ff9e49e37802ad5fc81d97171cb3f27fdabb1d09d0b7dde3d24deca2b71ddad63ecc119c9ea236fc469c63d53daa2f2c722e55b9c240df3574734bd0718cecbc096ee08e996ea637ee7746e1c7044088c370491163d7bb05c9be4f486a7c79ef93d46efca30bc0e5177563c9b82e0ae7043ce8b6dcfe1e11c55723ac93c244ecd144a7ad213eec265e6411d32656067b6a9641385b1f5a56a5b6db63725b345ebbdd3cb5c1bc939e7e28deba1c2ab8ae7591f3b005db3ca27d1f18a7814afc77144ea4c908cc0ce083c06834e93f83b6486ecd541b2c3436a63040cf98a3e8679614c0e080180dd21472ca7f775525863073ff13dbc93adbb9c5e80b3ca258a77a4ca04f182e12827a2541ae47700f073fc7f5ce34eaae47a532480ea6bc270054dc6798bc63f3bc0da953a6d8f4b64254c7dad0b9dde999fe476a289ec13aca0085e3f11908997fbfa39c2401625379e27d13bda86f97d073ce7bea249cf0c83ca3233c828125cab561ddd6188b19b1a66ee7c9c209d520a6ae5411e85747d1e1264d656238b82c8a38cc6ac48e49dcb8210574164888eeb298d91c81108341776f1ac0a292820618865507a502a1c2498d3afe3741d47e1be437bdc75b064dc7dff628eedffb542c4ad785d6f79ff0cb113e7993e0ae07a0cf7c5df891bc5f909797b4b43a3817819ee467e90bdd2aa2ba9916821b1fa9a8a37440f41f6440b59fa7292d834df93ecfe0342a429207849ed04132145595f5fa45f5abb56e060646982018a26ef6a260ec66c46a9f3acafe25e44a9ce1735eabf0abfd9dea3eff133d0e475a360f3033b134aa4b763d12985d5e9b9ef0129e095b7c71e0cc4b6d5757587f955d004fe39d4eb783f50da8dabadfd8020273ba89e29914d7520c30d19ff2f858d2286c70f9b89e5fc3432f25fc3f05b682a7b02f8baf665e8b67818f9c90d6f9b509445640630d6c1f3bfb82715b37a80e5c33610bcc08f4358777660c79044a4fbed5298e653c5fac37376ea4a6b1aaab9bdf04e565dde88faaf0682039b3bb7a93f333ac18ddb0c8949d3d20921cdd803d5e23754da2e527d33d62e51f313a159a5198d61ac8bea3bd743ebff55fbf3b12160b215e81969a0e09438cd8b7fe64a85e2e42860006c83b296b8b0437157dfec4194776245c79feec0d102773faa645d35761d785736d78f2be8634522774f87a7f14cd15d05eeb2b3c2524fdfdfa6ed472bc872565337dcaccb48a8e671c1d7557b5e167cb969b4893e4d98fe953b7bbc969a5229edf25f7728ed58b9e2e8404545e89e7212a2a8dcc317e57b605cd59f4faba96bb8bfd562e84e101930a52405b3f6b0eae738f20fcaa2fd1f812a55e3d92cb8bdc64ac97d915243df8efdfc47773b86c6ab475456e04e066914773daa0f7b23362da961d86ea85b48c59006fb9d2fb287a43e7780ae5d4b434a6cf702998a6278a277ed9b983bbfba5bb0491c74d178e90bda3acdbed5919b45da19b8f6b0884ad3b24f8838f492f15f441b69aedbe3a7e251ce4867b91f9974dc16352f433db6c2f7b2b0b94e75aa8dd577470567a1f4e2afcbfd792ed32193e386ae4a32c75de9db94333ed9bab874236cb648e24ec5f6fa7691c038e4e175f692c332c87d8a1d58457b8b7bd6ba7de89d763741c48967ac6275bf38ed00c3f097c38541fe90760a7fe9655a11b1b83df6cd72a8c0e0dff381a454f7e2823e62d1bdbbeba3ab6406a7557002d89742106e2e02ca4804f05184d8a06ea8101811aadfd4e4bd5337b3c7e02d929b8d7462e82edaafdeacc661b8573ca4dfe8fa934455651663bacc414d00e41cb79a7ab9b022eb61768e6299c36890cc1bcef774d8309dc26e71a4bbc642d7ff2fa4d9b309ce356c9da49b43498282795706da9052ff9044ca8f3e3cca9f62c5eef8ca4f4f8ac5c14f7aa06d26bdb447de7366e55d049ed1b14a82703a23cd98a2fab0dbe488f7827295f482cc84ff899680b4fab600abda5b668305e5619387bcb82c04325b85ba143695a0bc57b919fbdf19298678a837149cdc23a175fca1e9e4c12e59ea1e0a6db833c06502c4e42331cdb7b9de158cb54716957a9b91111bb79d2f4a9fca021ce1493831320a36acecb50c7381664d9973b3e42b65fdf0223aa64704da03d92ca89e9cdd0e544e9cf7258f08053c7e10a717ef0f9e6e5680e188346db844ff7b7f83342d3b90aa209906223d6a3a455674b9e1c4766e3db6b7e8f71f569b0a8345f0e4434d320f40711c6f2c86e121c74cf061333dded7209baa589929131562f9eb29f4545a97486a3b12e49aa1e7aacc8d21231a4d7d988b6795f9d61f640f1e09c8ee8e916467a45ce062b19e512579e8e93843091f455bc9f11927d7cdcc288d7ed8a11fc7a1ed231bcf16796d644acb38a700936091aa1210d4678dd81822c5342f984900998c1edc5fc6557468835378865dc28636579c60672efd1d46723abbdb6308659c630c66ebe1bacd16f494e0ee1d9c45822c4b7987794077c73673ac3773f92352b4ad246a77d18ebdcf5a02ebb80c48eef80f44211b2b8746d0b1ed13446d1dfc55d30acd0b982d4b08e96f7c845b5dccb27a74555fab1013cf91ce5d62de35257c720bceda2f77edb6a9950198fd8fb6838a902546e9af00bca535f4b64ec50342ba4c9c449f2c6b3ace945b8a9bded12cef0e9a2a272f8b5fd89d0a2084f43783266105879a10b55389d5e6f5f923256ec091bbbcee872e67e2fac334133566e9b62f8d206e2dfdd8feebc182dcb253d2ab2ee892a5cff4b6e277aa8918c950ca12c20520d29a8461ea9949d72633c2169032b425a9237779afc65c459d965244fc437a8dbec11b71b6ef4bdf979e808baec54b530007048cc9c018fa23d9a2de7d206195df095d51ec373ebead3231c53cbec33fa119cd96ea1b978db8a635ae7aea1e07246372a1c460d5c3147bd1fbfaf4f5cdd5dec0a325b6d4d07bfe0ea56b59f2e9300bb21fcc12fb351ce5fedd7c17822eb11067964be9ab77620e5b8ec8da228460a258b9f749d5bf00b1e941121318eb56611d30e1c9163077f976c2955ebeb643a4fd58154c64595b3480202ef6949375a9460f967601490f710f62a08162e2ef9bbd537d28c4cc24aeb0492c1f31b7e5be5d6d90b64c90136b829f1ce16c455254d4885965d6c060b51329530958291517fe6e77c6f4ac31bbe02195859e4ff77986ca62ce5e5a830836acdab94e243920b32e36839f1fc8b5362f9ff4434c3bf83b13bfd975c7e9c18d0dc779b3c365bfdd97621092f2ca35535cb11597fdd41f3193ccd1dfdbed7c4f4b244742063d078fa4225f35bcc0e9e6ad95ba1fc797d3acc2f1767a5d1269a858e084aa8aba9969b1dd73077d426d879877017bcc70857bda9db8e68aa48c5b4dc3a7cdeb2e55d4e3747c077f5d5758f60be220d772f4334f8c5d5b7dc98a2331ac7aecc91eafc302fc3e5a810e54a520361119a0ffe336091043882d97407e07cee94d5bdf333fafb684200103b96f080f0982e7550d0694d409a8b828acd3a10cc627638ba14541f27cfbcf4c7f1d167a8ff9178c0a4a9d1377bb6f000e50de15228d3e4a02eeb7e119d0058e7fb9dbe4d8cf8a1f2bb47f19dcd076ee9b81e417f7f1c32623064e024804e38868639e148a43d293561e588ded9afc9a6a65f89e9ef7f6503c69be395de5915215b93f3fe49cf8c828016dd0e7324ff39b90e736e30f7eac91cdae949e153d331b46e34341ee1589c4ba15122a1b45f9020c96c842d5974340b2f2d7cda0a09c4f865d0595ca2cfa295dc8ac4fdd28ef58a25383a329e1525ecaf44797ed62bf20f7edbcf58b50365af716fd1a37c07fd71888958859b8d41c669ce6195d80113eb1114f4f08fe7abf6a964d39bf07b4ea72db35190467ab23e8f9dddad1d1113e2ac653912212412ff0897eac2a3c75cbc1a0b9c1875413a0043111ad468d92af62e1ee4b93e7e4bc0809bb710343c0380ffefc7e5819fb15898f711ddd7d7b1363cf3919ebe4537efb1ca7a65b331386b96b0a735a4f9df9792fb6d91c417688c9d93ae1c5a667b11bfe1ba792f9cab20e99fa8afd882ea4b60405198dd99df5b65507468fb357b1604243371eacf948ba74c144eb5f8401a5d0faa788975aebef3b3c7ecbc838f8bd5a55e635937df1dd6970dd10625264e9540b897b5e301de44325edaba28d396861da4569c8169a6213c516d046c2fc7caa1f66ef36ce5e68b64dfd275ebfe0f20f89c47331ba9010c57de5fa94886ac7b8461d2a14bcce657758f9fbb6885d761139670e9d1eab9a222186dbf76dc67a369d563d59a10d426e5e6a86e50a96e7ef95ac1c0518b43bc839e7a9c746f7bc3b7e28cd1ed349f2f2e2220af819a65986be37633aa8cd3694379af3feccba246dc2f63de853171ae0108f872efd69b3e4d401a187bc3f40815f981f5ab3e86445bd2eff42c332be1598e22f3231b29509f5d81c8d01ebe4366bcf639c873a9e4cc4b228f2fd1e6ec2d3fb86e71011b39730d575543c6c7457591407f88c75055155bc76cb0cfe5bcb63f852fb18eec8b05d6047502fe6d765e1452f632e00fe4d2a3f11ad1f9b344dd01571599dc6b886f4a655c9341e175eaf992cd751d9f1ba988e46d53fdff93f22685035843a287e06eea181ca0e6078a22a1e2a25b99c6ee24cf46889bec4cf85a9ce3591b22eed003e09161df0feb78072746eca6b44277a4ca264e85f36d12dfdec98150721e0de0378a050034fdecb0bd1f070749ce7b505d1f68f1363e15b57f7d1149eb8b9c00c5d500ff24305bc35d58f94c88054b22d3a54f3af43080ca70ffa58b0336f14bdbb0f2dec1ab956e4ed427254922fd7e68af325b565f87f3c678bda7024b41e06193a2736988aa28f1727ef8571e401ecd1157b28e9b1ea7325be4e7b322d75a279c72ef82aaacdfe407f49ae340a83efd918a293472bd9b3a7d19ca0dc06d914d3a0b9e0b2926b19897c7f0f919de5be1eaa8ae056014eda04081b5a5c1be6409ddb8ca6cc6995c4baf5fab8c002d6f147830f56c80028ab0347919318af19f936044528f0613cace85433025ff29d827f134fd32bde0c4cd941afe0aa8e809c811b460890c3a46e2c9fa47acb589bc65a87d2ad9b63ef923cc897ec92cead4bb39237eb9aa79827df128781bfc1800b833d5b364f68722c84c1565df9e3a8eb95145aa05a53603520d4eb8a1b7374b66f085c8e94ed9978a780261f98451f01c7acc8a18a3cfaf833cf9b30f4131df809c71399d7e496fe2170adb2a4ea00a2e78d6e1fa8fe2aec00f6165d617f6267a856cd86aeeb513611c9688e868bb9e949d72e4a06291202b1e9d0283081831b27258676880d3f78ddba1111219cf840ea5d5f7358e28e32ae9b735585eca0c8368d27af87f337450465286fd7fab39baabd16b7326ae9a33d763cfec10e2f6dc9ee5118f3467c4272fa04993b54ae38f3093f9a52f342e7011dd3ca1a6d82ea6f30450bd3e9625c7e51f1e5cf8565e7b250bd2b68671c6443db32b75dd95e01518bda327d53140192e9dde80f83ff39b26dec58e382c2845a671660daaacde2b34e432cf559679a795fabf40d383425af5740db4536764af1c4b34af253492b5358465ea5efdf7b38ce9cbacef6517b0908f5b08f1878688a16452d941b504a0acfe5eba76ec6cabc9f44b69d73670807cd331874c5c3f5cf5db30085f8301b65ee02227cff5ac2c508e2e094ff5ea28357e046de685bab2a8dc6474c5f2389ad7ab4279f1d98ac390de924c34b59b45b5eee9fbb0ee0fd84e8c4260969e3acfeac2ff54a52ef28f295012261768b2ea3b90092674261fea41b8b9d6cb5b30b04ad2c48c97aceeead67f27927d9839db33c9bc02fe33509ed54497796cfb3d5a93a78cfbaf16fe20ddd9b29685300fed82230b1eb89f661db44ff3c86fa242713a03cdc7b8af938e910c6f21d8d9eaa1d47d6fb59ff6f1bb1d2c1fa8bb772c7af8342c166c33d796c8a8c12de2ba95715bb33f55d5547ccbb4f50d1a401754bf915afd1474bcecf85e2bdfb7938d6c3f69c782cfbd96925bbf15e8f2b82b910d9d08d35a80ae7c9953a2d27af1c876281e3c8e46a2a4857364849ea406193511dcaa42d55d05960e591c45f9723ab0c985274a2c53c7e145618184b507c654796ce3350c66f2bb71d202e1136246bfea6d3cc06986a78a1d9aa1362a97775f587fd36c4544299019dbc23c7671b2c36b9ca28e1bdfc814a03c74abad0f1117e851a3e8a07db9e1ed6bfee7983c36c82efd001442e8d6741b9ca43c0146c333774b87b499012b10b8c57ae1c2291dd1c72be6652642bc9e641d361679c7a1e4fffc47c83d307cc1ea04ebd255ad15e5ff36949938e5d449938a0002acece74726a2a8da8f026dfc251b6d3d784751a6d6efb2f58d785b890a9d3bf71edddaa050306a1c66236c4fb21c6f8b72cc6ed524cb35ca2bceb38ece2e463c124c064f27e46e7a8e1a34b3e4c341f9c3f865c1d69e00534837baf3735e1514ca033b75b19be482b00874e5ad3f2b2e71bd30801591f1e99e2ac5a018c0543ffe99ee7b84510000f792bf29f2fb98cfabb349b8b947ddd9ebe24b3c9da66706df2eb779eed8274177590b6fe54b78fcd7c722e35785f66e2ec208341b6d0f95956bcb1f6710b1f4f9899a6715850e5e2d4eafd6bd35cb8fae94a9b1b9ff9667265da2883556a3d9f9eb3b903c88cd30242812227919d322d81706b52fe3a553f5823c818de2544b6c109756afefc8d997e5c8fd1f83bb208a9b0b625a848ec014edfbfce6ad23323e5e78a3dff519ff7a998a8958113e775aaca5d70f265418213edd7ceee19a61af2140377e6d00f42ccb9212f8a9e820c34887c62633d512670ddd6102ef1a35e3a35ef03036a3876637354069fb6795bff50fc754723d6cf07861571c430a9d5c02f45fa1207a9f506e82f270af616a386cfdd762084c8197be58e8cdaae4cabaf3d976d83bdf145af20c83482882f3f88758ef49232e98071545222acd95995de44e8b9bf6eca6c2dd62914840b85750304a55099be8d73916e736ef599c4353c0de0a6a3eb3dffe66d1a851af77cd6583ffb1635eaec1902a14aea8fb5fa123e29295600144b31bebcbbcbb5d7e6b64f4828e1003971193684abb4ee9591d8cfe78730aab5a0328f390cb25453c5fa6e11b8a90049531fd2daac295113be932d75f0270cd47322200b531864c0c84d996c7d49bed6bacbfed135cff26de2e710a646f63299c94b942038580db29310a8779d10d7a21b022d8fa8ca2f184e41f327fce1e458ab4eee0fff75f2c5ff2974a4175037bc0004966e132f24fcf94168e8cc627d08c49ca6c7141763b48eaee92ce402e769701bb4ac78d7bea330004921020432ee42f39fa749227de738280d89a9019baf5bb44d52ff48496aa3c67b861888d88d882c4c435a4fc2b2fdfc4306ee0e775ea4ee42160f653d0eb3df64a8626fc78dfda86cbfe3b19240130a488ceadef842e54514415f34b768ba8c19958e27c455879d30306c22e91e95430e0e919e46ae2aeba8a97d849617b1d02854266df9d340540dad797e56f3ab117e47cf598ba7e7a662cd37c4680693fdee6e1c330dd16e8a5913eb10ad6797b06aa66c4755d3c3002c408369cc19e110ae3f835ca295b60c8b9aae69daa2c02c48a1cc010f5f371cc33b7dccd4922e2684c4e5ff7b5d10445fdb95c36f99b6e8bf36ebf589ace5c628f8d2960ae5d5b66c7f159a4256d748f9fbf2e11259c05e8cac676ea688ae521105f20469a95ff1064410604ba6abf73e3ac6e4bcc9230fe09e0ae1a5594feca396173e0c11083f62b3d03ce89e35f8d8a237b5bd112393763b1b3da9f6b3a9b6aa5adb8bc67a1e99833a618fc69f9f36ca3cf6da27c17d33c0913c877744062b1bdabfa6e1996c7fb942faa17b0b21b405d775e1d8b6f28a72e85c13abc9431fa7ad8d1b2258f273b2973ac1541aaf224153ce68e0f854b7ce30025cb1522c7745901151f4e807bcbfad34f1b925abfac5aa111841ceb601942a896aed13ac56b3bfbe516da04fb56fcd0aabca92889a929e7eb7cfa8411dc51e6bffe5fd93a80535fcbec1f6738cdcc4f909e547bbb7757206aaf480b0bb99bc3502bf491e1e264581717748e1d966a806e3d536e02d7bb9a38f5682686211b637b1841be5536e1e91c08e2f54f6d4b40e6afb0764e71b4aaf2410ec0793e15d33f39e3979f6e5da0631eb8392b350cc4ba7b5646fdbcd9aa386a2c0685d8ac5c53d9635c9ba66bc01f04bb2d38fb899c3b56178cb22175ffad2d3d2be5f94dd1611f773dfe7ccc38f398d51f65adbfdb7d73e072381fd369da818b907970e570c537729461586539726256d2b6e6cfc07649d07ea5397f39a593a9034c2cb59071d78ef2714bc8dd3757fc5cb071527666e81e5b40781437e202bf7d4122051554fe6ca37d6d8a9ac330d569b523829e1b0878ac5761597787caae4b9870acdacec18675a2067cb3fb0179bba5c4412d28109a2b121cd5025f7adec8e66ca3b1d07cd505e452db57ebadabfa3a826c8e2b808c837deecf677ce1e6b69729a8e8595c64d40f31a69a538b2c2ee56e910faee6c2e3518852dd49b9f142a0ba218de24d6050f2d8148ccea051224e21e19df7e65d59820fcbdd399f46fde0fc7c9792e7be38bb19d5d6b765c534abb793011084d7a7cd1da0ce5fa9e8e57ffc2525bde2945d63b64c8787fd76d3068cc5cbb8f9a7f5a90490846ca1a5013059abe7e029e1d74a8be3cfcd4f6cc9b45aed343ba6c057e2d96aa32e9ee78cc6da12cde70da1a9b6360aee1ff017fcd84b1471ca269110d301e592b071c16587458020e1779d905a1fa9668791c63e2d06d9bc676fa2cb9f670aa0c1573201d60ae53c977aa4a0c489a473b97b09fb6dfe0a6c9889f98cafbcc2d1e6447a880c31ea65b4e89097634b997f19790b5a5a5730216812b022eda69c850796e3c6a90f27a70e7aa5b3d486335fa67bbcd893ee11aaeb02f310e5c06439d6f7a31809feee5788f197b6dd5a3ec5a00855f18a3305fb261036268ef96b5f540d3ff1e59f699757e4321e428a8d5d8bdddccd189aaefb13b8b70a4a56f7fd1ba30ed3f2f1fb2321fa06873b18e34ce24835e3c312d9985d7ee09e1b02cd17e777de00848ad10903705a87ba9712f726d82c8e45ed8bed7eaa3ee9c3a5140c8bda1f64355e9333cf253c0aa566fa57e557d7c16430208349703c9fe785a01130326059020d402279a37e9f47a2deebe67ec4463b59faf4f9c106baa49d618cb517c3cbf19db82415ebe6ecc11b6df6191c7842e1352d9fda668bcbeac038c3819ee22a3f6636eeb1e1ed3747d593b4491a6666b7e023061ac0c614dda0d0b04258c455561f9cfdba4e7c916b0857c8c6c0617b756bab7abb9f49052f4a684867bf2545178cc9ed70ce375aa0c5027ced67e8007bbb203f3314092afa305416ed0ca8560e50192b7a01d67705171fb7cc5353f1ede38a5018a3ac577f23ad44c4fefccb4b799ab39188f85bac96d53c70747825f64dd5bf54faaadaab2bfe1f8d22e013d07b9b09ef5663b2ce6937b24300baa08fb93eb5a6791f9d0855269798be0d5e462d5c1c546efcfc6d99c3f35097fbc5fa2aa91f9baeadb0909e92422039846ed0b2a9778113ff3a51bc1ee15058047b129d67b8dcb98a165c3b643d632bc0d43a29cb553c51ede760599036c22580592f46fe69739fac6f06d18f76df6d3286d0d602b992b09bcd176d09eba210fd7788068e3e67e2099d07b29b57f546c1b09bbd3c988bf5216df31b8b64739c060b69331b6ccf483da0862cfc1c8c004b2ebd775cd8a255494c6d06120668bc6b21c64b52e9b75d115e991cee92aa1a262c6b71529c9c03a206e6cad6e220f3cd2ba28f5891209ae27ce466e25b0a84cab0f114ec9fef49585ed425e2c1f12f7d4d7902078077abd82dae54337bd6816a9040483ac6c57d03e921de0998742f6d632083a21c13bd7053671e58ccdf741f5a734c517026842b8446af2d28d2d594ebd4e72f62751b024c5aea5ea8d6d161976649dbbde7eb61d2da2551ad1056ec665621ae391ded7510e7a194c5982a8ba09e1fce1d26f28dc971e09d6aa3fd95d2019e53a46bda4777a6efb64b502c1e8db2db937deda61eed05a180132ca51258381e2a4f29567c081e7ca7ae5a023b7a6ae80874af2f1b84829574cd5ade154e4697d6855db5af676d7cd2edc7d3ee4853f774928b3908649ebe6576f5b847f3644abe7068b69c92034eeb455badb306d23ec08301502653139a46c820bd4c6223255eef00f217c0cf7b941f2b1914ab372d565917fcab8b3d97483b1c15745fd0b0842549a19eac9b18e673485b9c07290831a3198112924a5f5690a8a5522be658856be5ef49ccfa293f839ede8899a9571fb741af1dd5c1933f9ae8a05f4d7a86236a486dc8abba38b72801663bf0e186838b0543d57c05d631ba4248c201f46e96437c186d2cb870c18e5355a8c5a6bd0f5340492c059738a586b2960323e91eee4830b3bdca4b1bb701d27a79a6ab31f61596061f651012370b8032d4bea2440de3586d1a1328842a2360019e8cda07b12946fb432151b80d05988672ff5bb421511f863677cb1ae393dfa068e70d3b8c77f365d9a67ee7f1cc3df181fcccdfce06478bf349edbe589455f30aa2d4437fe84b3957ad36e3b0e8f2c856e5c6d8e24fe9ad56a3e59549392ca43d65490f5b8fad216d1cd54246bf0161b4c1d333eda7979f3316444b7321b5831719214895b07435f8bc0f3440cf6988d30c71027728de614a54e11538bf5cebbc982fe630a38895baead0c1497c24388ab25acb8590452edf5714c80b0e5de2eb9f1951e7a9d9f32476343d717ced7d1fd43cd73474b69d468daeccffda832f40241fd49c263d6710d10914ffdde5a7c9700406eacdb464ffe58908b3ebaf2782fd3acc85b1f26342b8ae4f2db56dc7760bd4ab8bd87a30090f406d420b06436f8f01c46616d4d4efb1f4bf9b03a6af731d07b36c936a5c846023ba4ef66d5e9a3f4cafbe055468bf071592d61018acac931fc328a6a004443e0281a3578e2ea01f7effccb25bfcd35f21fca27a5531f2bf0558dabb9e7cb5eb7d221d220819201395af5249eb73ac3f03598e0f706da0ced88ec3ce4976c39c21e4eb48ae9b2e105a03dfba835d1ea8d11649ebed1724f5b9706539a400f4bafde0768c97b789d643a542f86a1df81812f76a986f17861f1957bc8882a307dc1138e1be5e30ca09e769aaaa655bac5f408bb2fc9b1d5a60d6e4515953df807a934e0a6f7f60a32f99ba85ce9a16add713ece976aeffbcd12963832122169bab8bff452f41ba9089b93aca0ec730d95fbe3af230ca861d8adeb459d7f5cc1b62303d686c2222deb743f73e05538bee1d5fd99c4e9404136fc5b667b75bd656a9367810c546c7db81b5913523301b81046b52cfe59e0c2fe0d1e7b5b9ec552a1a032477b518dfa0254b256265cef4cd36e8d7a0356d317f81c3cbde012cd0e14e38816de53556f5c683bed2dbd9826ad91a4159db0273aa15c72cd4444e93b27141db664c7d8791ee64e2b4e651d494c084832b04a4958e82e6069f677172ca405bcc7d30dc91b02a9ecf4e4a810c7ccf4db3e70f2450c6cf4e6770d62fd0909d4c1024de677f9a7d197ddd07ada754c0b99af83cc8f6f35d842a71ec9a31db9733f49c5900f0d3f60b91653c88fcb7e6ca7e23f0929a71c95215dec262130bbbc968f8e88cb5656ac8adcab6fa831afcbfefa60661324dd0a2eded1b93d462c148509cc50ad7e49ddfa4d7401eb34f4c4c75f5aa4840d96138e650af2dcf18d1d47f8f82beca0ebcdeaa59b50fe9904c13721bdd7c029134d49e9d9713b377c5a81faf8085842b77972a6c8df50a3e4f66c3c1d7bf73508ca607cf816ace6679c2986aa1a0566e42b13d76fe501092985fb141c009dc8a0e3de6eaaf216a4c547b79f1813817d198e2c167cda9eebb22bc8767a5547f83531cf69177bb27c36c7e744da39bace236e2644b5bbd6ead4d32c5d9685bff3cb160231b22a4da8be41c583986287b872e61ea764270c7bae32f04efb01494925f042b862a64cac76a6d288fced67c50744efba4c4a815ce81bb5110f264463b4ecfaa8e51982dca03926fdfecc900d37fd31454acf5740e5cdd4399668bb9602a39b32d3147150d588bbce89b0aed3a5b369dbf5fd9c6bb826bbd5f56b6479d1472c3d1e5e4c88755e7ca35e2d484add381b753c8d70f5da08871bf803cb376e39c851f0d2ce882846486f93b5d7912fd0a94f01b0a84fa423c5f49e23bbba3cb9c571ce34958f5011b8b25f027008ec99743d383d74a2bfa16f76d5a0b56f01aa419cbcec1de4ebcc4f36cd1fccf8f100f7df0259411abefe866c80b325cc03e661dfe0c45787127d2d6c2bc658ee1584ea52cfcd9178f30adfd5d69ad80ef2f459eba6911003febfe91962ba69fbaa223cedb59d6dd94ab703e9718d5b7d2d1454a7d38556c980f054a4e2b9ba5abbdc68b41f4071515687bec28c8410a7efe5d0e57a90d4023e4e87b562da74ae1f72db1a4e9a752e5449b030ce031d94166d526106be48c53a907787c4367fc58227aba3ec67687fad902285dd6eeb0df344b0c7a3434ebd9da2f5043bf2ce0a3d2387f9842d137dfae9027491ea9185849b989c88b06c6390e4b3f45cbb63ca2de64c5b01ebe367ae8ac46d69b944e83eeb9db5b6a294350459dd48c0034dc7adc6b14ad8241fa57b6bf4f401cc2cfbdc66b2267dd2fa19c4894b6ad50f64d7cb7e25b36caeaa931e3436a0dbe37e809e1dc4f8b3eb2c0a9aaf40dc366ba3ebb9add10c0e6d1eb394598bd015a0bc4e7b425ac3d57f2bc53c45048b5fabe38ec0c546c02dbb1be0a934aea637d0568d75f70fd23286c70e0942c7d42a13247fda1b028f31b5faacdbedeb78e9b1e518d66dd1beb542a61439131dd6a70271c4cd6698f045b461fadb7639347c73255be8d5ffb2ea64a8c3238ee527207ecb8fa09c99068ca84a7397debec01e5a684775569a4abed4c545e2c95e2fa04c586d9eddfc540e3b88cbe695288d5bcb5e28319a203616a9ed05e0700fb7a22668dfb63e71d498a31bcf37dad89f276d7cb57543405a786e0c277ec8e4544df0f8b720e649da990b53c35b23af82677b26ce17fb05253b614196ef561c9d3de02d91d122b294c61c740896055c7463c16bad5a361dee15086c1797acf1d85e387ec34daea2c23d361b6e3593e96ecf494b37b32ffdada3b0c74e789c3691a2ca1761b3d7dbf99e448505ff206d2b19c56284ec570f405e1b62202adeae6572aded3960d5bd914f95e3a0f55a1b99f56e010d8cf585df9afa2e9ea3d90602001af3ea09f8c32d588a00a2d8fb5aa801b71b19e9323f455c9973fae82a0cdf30aa0c8b0ed959c08d15e2abb2f6aeafbade9ab54c778bd271cd869bc22b98ea48c60fca850039152b6ed52ab33d13414f74927e5afdfd5c95714a528241448523ee9cf8ea41995e66584b7286dc61896e6b7ffceb40e24b488ff74f4fa592405f53c3d011de49982542c21017424e609acb068233f9ded3c0abf30909beee907d6b803ef892127d38bf47ffb1582ad9d0c1df637e717fc9b1f6666d322dc7af0bee112cf3844baf2cbacf3484597defbbe91004d37aa025dee8e19f292e38cb2eaf2da3c697734c4df21c2169793841959b4f729ff24abfce8e70d9d5d8e568fb0c471ec5436f8696240ed29b12483f368e57a3d4498e38a40bcfc1668e12425b9417aa0f82c1d58ac9e429f44147fc04a36038f340fe272e0d8c8b0e92e5d6c1e45b63300cf8e3e46527013c263ef6bc435a6ff7e65a9a0640d44e361e6d72afd34364d1bb345bce5a91cbfef19d5b6eea8eae090b5b9bff189053ca6384cbfe9af3e9dc9099e8a42b4befa254eb3ffacf20ec264d2c555dc2fe9c5dbeb76d3387596346ac60fda1baf81408076aca3572599f4988a337cece013eda93c0f1ceeb76dae982682b516867b3e5f4a97dfaaa7f86e0236f892239675fbcc7dc0c25e95c005fe7a4f9932b5fd4bcf90f57f1c7ef9c4193f70b7e05368d8b941ee3fe2a8d5d0e0725e511cc8581f3525ed76ca48c354373c9c5461eae9d8defa7ff8b74a42fd210cfbc1bb1c17f0886e8189e7048ce217224902b6714431d5143bd89da350d341a76626dd5e1d8dbf05fdcbff3f73e44902b512af695f4725e41fe23705a17d34269d1449156846e9b028e8a31dd8c10ee43e5d20eaccd3f2fbfdbef5fc734d10802e21a25963ab530e64a84f4d01e264f1e19ecbbdea601b70af7c78f8e93b66394a3085fade0a3e379553f8b152cd1c30061754667d6deecc4be945e724a753c0b0aff7d77865ac64a3ea9ec4be5edef96e82da1dc6a72b7a77e1dfeda3c6d47042539c873bb56eaeae59a740f31b7d32eb48be39e14c0cdc3b873a87da91daec9b6449e4fdd673087ab926373701cc5e2292fe558f46d8d6fee161892b02b1f99712f76ef327ecb47ce6f8757e03839c193bfa5a98ff677bf0e7ebb521519bd4194f4b6c7723437ae6dc986e298f8b0b17c76a33aca55b0431b966f05a8558c39767d29d1d95873991c0c405d8c81fe90698bce54c3bb9656641f6ca42fd63ae3e1664c8afc86e66700c7d397b13e5099cec63503acb537e9b701bed3f21e42a617360106f6651deee5e5f6e57412e107d573b4ea97843a0f03f033ada075ee98067764dfeb113018d14f654304dc2aab3446586a6f4a8f90f34425694f96297dbbc27906b4fd572d45830fbe3dab8b0d4333bea8ff5e678c1c3846e2606311045572e5257aa0d6774f76f7edeb817b44631b129031dddd076c3afb9285c44a519ba9cd0e1b9ba6003aa55fa62d0e7b612483d1f3af0100b823d23fcae5d2ea4e6351ce68d9d718420f91b84080d084382fe4d8e5ff1b7ec5c2f9c1927a82496d76abdcdd5116a8a9f4a5c01dd1c2cecc068de7e69628e68a447cccf2f20445288d53672de10310d6a4bc36b66a99379a98efbc49cd2fe187f94ed3892355eac6790c72d4fead51a64dd755591d319675838ffb1c30856404853e826da20b006c1c39299d444372e2fa6a7350db67c5b60fb4532981bac2f703ce3ab9cea03ad1725dc07595ff9cbffb8c65ec39530292139d4c183c5e420bf965aaa21f8c322bdcb6a434ffd4d1608f3a4533d43188d74ec96222088117a84f3927157c4815364d96de5330270e3c6869d4d7d8fbd2051db2b3917efac0f6b625f7b1c0e03c3ffb7521993ebf5d1d7ea10ece0838377f6048e34a14998204511c75208b5e4560a4dd59eb9c308876e15a327d870cb9829c0392ebe5abb2c907e7381fe9dd9279f408b229ccad2f778e2c05247dc3a9cf78b954d481457346b934626ea7d75d4c1c301232f0520290ceb2d5233adf3b34c73828dcddfd42dfb1061eba06c93d999d768febc59bec44c790f88e2ed9e7a390de7d4c0000ff62956cb46d91b26201e19e617481e06a32ad6c0788309e7b53d94f86bb5edcc8e2d4303a3fff67714367d2b7ac737cc4862f0908900a2aba0ba3406152cdb20d26737601b819f7004aadf7feb0fe27068e95d16aa2601b25ff672ea77d0bf8da7fd07ce4694ae52f8ebbc31266a091d636b75915c5b44083be0191cddc1d21269a3fbbb2f24b465abb2156eb7bd6cbcccd3acfbc75affd8b82b6391dad1c349ff82350e0850a95d4b3fca96436eaab14fff8c07b8d094482ae4a067732a5f05a665a3f4fb5f140265e9d97df9645f4bf3061540c13e8d4b357dfab26c578a4fc07eb4ab102f0a6f6aa070e037aa47d82d25b424de55933d0848a9cf222d0a51a7d4227407162df2b500bcaa684cfaeacbda83b1ef3e6d19709e3d5d8cbba60d9f3f3dc9d512093b28eba105a143759839f4861f1c2a50cca8727d88ba45a35da120686b8085e14662a242fb5e364c191382e5740359d4b8c9d73ad785ce45ee2440536ccaac1fb8a7010249e20d1ad9c0fff105e2a9652ae4adbbe20dbed736f4fae3e7b960c7d04d622270e6f75538ed889eb51647c1b19c0c73bf796ad5ec7d1bbc2f6709c3e4e0b8c4e0fdb77bd03ef4a903656981add948470bbcf12b736424cfdbab6f3f83efb0f0390e26bea1f6e5983f2e13c4fe8afc9f790b3709e85dfdf5c8ae8f1a4bdc0dffa999b2a5c6adf52c9b30606a131502a781626c1b1743338368fcbafb7cf7979e5457d9bd4e460f101d4c454d156be6eabcb1163e1c6ee51f7aaf4a8b5f3301b7e2ddf1c1dde63369efa82c6f30fc531769e3cbf93d4f6a2de66f780db412ea0bfb11dd465c22b20d383e7ceec4d1ccb02080060bb2adbfb95486481e4f1f3719e87a0749bc1eef23c0941c2e61f314295ab28373b1d2b6983973279ebafab4330bf7abf59fe75f7d7d35b3e862a66cf55ab9e418ad41677344ba1eb911f82ce73959534e1cb3c830dbd7a0a1742d01dc6a3ead0511cea956e46054d5829b5b5d885d54900516785a1bab1cace5d2c25be0b454260e4a91ad9bfc90fa7b8c005ba7a3c9f98d17e835a632fdd34b6c47018e1b826a07c36a260fdd5bcc6222e3c0e1edea245fe452439459dbd870813edb3153b9b70a3d21ce5d4439e213bf5743c63ebaf5761bda7aff198bf626c394033635608f08470018b1c89b666b7eb39b2d6f68eb8c058d2789b9e6b4dde42d43a20bf66a9862d5e664f0fab3536648bf6f5db647bbf31ee7c8a4312982d551100dce32075e709459ae7647580404f7b0baab2448f62b23e31029bfe6ced3cf831ed6626eb1cbc7c9b9db419c901a61e0b512225ba9c3f4b89980621b61c2bfea3feb85c1adb95192a6f6f2b9813c5f923684e0afb12d7cd1d6733a73c4b5dc09b0522df6de41708537e0f479be39cd08235f85ff98ff2958f83c71dfa1ea7b8839bee60d90fc4c055fe68daf482e2a8a328c1455ddd871bc4295e2edbdabf513cee94bb5b2558b2c82bc0edc22b4a2c759132dd9fc007cc07cdf4b152c90452722e175b85436b8c3a5639d2a8f9966b819f4863cc559a48ce8009d90e09f4ce480470219902cdf5a7733c0ae38d12700d798c4c75cb24432537b4159f57b281e34907f334fdf7cb4e103863230528e0039596e65a382553a6a721e2fd18d8e1bf3f3e7e076d7411cfe7e706f1350bbaafa7a6e4e7ea04e50ab856aaf04e6a5e9c62f8f9f76454ea8519e9da3b00b878ef603f9d67b4af11dd2a202ac7476bd696a6cb5b7062105ab84586485213cf3a33d72c7b9239f95bc67c4f9eb46bd0f11112822239d70c82f1f69d873db41dc6a5ab470705a9dcd7b12996a517aed0a993342ddf0aadf3bfad3cca05bac0dae17cfc2594c3aac1f01ca0125eafbeaac1726089f6f27e1eb2b67645b3ced1e3ccf3785db98682e25f76ad2c31170a3e0108c9be79352f792e3dc3987427d6d430c2ae9a6e9a6cdea14f3f2d1632f167d9fcde4313ec60266b85ff8d53c9c9840ed9d7e8360421537a058848d18d5abd4669e40947423bbd3871d997a2b97d90b665526e86a0b45e4058bd4f6ac94c1e78afc1a4c8a4d4bcd51cdd52b5819bb8aaf870eca3fd476131d52812f8d6e57aa3ab185a492e1c415c47161b3d2ed3b69d002fa4830a06844ef19d5c8163e5937fd713d68e1883f973bb0ce19b272fc0904fc27ec423a5feaed50ecd8e4e88d1e3a39468840e1b49d69efa93f929f88a40e97edf79368012c5d1d7bcaa0b5c8e046c8e3e987a924151b6670978ec399408af9e98bd47a3097fc760c54603cc2b99cc699e35a46dcc1131e55648be795f048754ad684b6fdaaca6d4ba429f037dd8b62c6abc167028f55daa8f8170c2e81d5bf0f5d830ae5a5598fb82e34b012bf7890066e3410952e7763085efd63c43882b4beb6ae3864ae42a0566893cd2e052c156bb3eb8c0f272c19f1c8dcf5e3568d83595da35a02c1dd211ee9da5a045876ce97906b3cf7af9cea355a56d944c89be16957f2206f8eb750478adb49f787ab181f5e07e810ff6921cbc91e8e9578922ca9704d0b0b0f99e82464010944a36d3c63e13400587a06d5154b5e803f218f175fcd61f47954cd43ffd6691cf32a72be3dd0ed14d7063c471f3d05be5b7f9048c6bd0518a64ad0c558c23271a8587b01a3d34c92e83fe5caa7eb8a195acde7f549c7d58d2a76b07720760d825fceb8373af814c1c4bb786016312746367d18bd98512827aeb63a297bc09cbb14b7bf0daa85b2563dc76bdffebd9c6ac4b2d3f6f6f0c2c31b8778852f4a28f5fa9f1404dae7eb8124947df6d3ba70aba243e6779ef852d14c1933213a19e37b1855cbed54fa025823a5b2923398aa4f1c927a9233dbd4f9e76fd6b66d4c3459bd847f8603f4ec8e4bd9b88ecf21694cc4d919572d44f10bb4e76ff59ef28ea1568afe6748ab49bd9a89559c5a9c35ddb019ce31ab410024882a3e4e772c6ab66cc70b603f7f2d49731f5023710be2478b410f3f145b4376b75461aaa15b85e975f5f0d055ecd1482596a88e45604d9f8f11595b08df6fe1479c4d129f915c4f3ce1b3d4ffe4fb985792fac6afbc9cf97f39af51191b27bd899c0c3d3aee309743fd26099be7c5039e45d2463bc3cf9838722541d7775b4b8538cda05db8150b1c859d1c900420ebdfa959289711a1c8a13ec959cd5f151d1fbc3603594844148c9b84b3809346e702ce4ffa3934c72577b219cba73aeb1b1c7857e203f5e9e9db5ab9e9e3b9847ec13e41a5e1cfb5510985ad5ad070e5582fa2b5369e6acab1fdf62111513c69d7f4940cfc653d778269fb6d652d28efd3fa45c03a3e14ecbc383acee9fd7cb8ccf0c64e766d7d3b5811c9f3f23046fc03905379696b2161101e249c177e2bbcbd7d71dbb0eaf665dc977e3608ad43d1b11cb51111532462509fbee750bd5ff6cfe2e093db79fdcb048de5b599a658c8f439c2c5013df68c834435102c3ee4ee870e7d01687c918f847dda0ab7af5711e29868bea1dd413c4f9243078ba2a3a329b0ca40db5027220bc97ac72908f88b5e81343ae7b3606b3dd70cccf1faf148f486d91a5cf4c8db87b3220d94350e556a6117d5b24c72b378e7e0cbabcdeba265b217130152ea90e9745625bfcdfa109a3a16f4657a952b2f5c4741c67991600c14aaad931148d0da7af0974dfab8ad602b49288ce1b944c99ffcfffbf2980c384f821abdf921c66db8c0b69b7760a389f3a0d7915baa8cf2776020bf92a0399ceb89defa57cf6429bf9b87c633ff7fb32f92e7f2d3a1e9758e8ef57549c2789f7f74e053c62c363f483e731527d8b01f0dc251238f0b97787d1ab5f790a9ed235e32e720625eb70307b278adf38fbfc6a3f5e29ba5713c5d97642cd35a226eb33a8c74e2eab76fe0b2cc1c00c72886815d17ca57a51bbda09bdbbe67e6398e2655bfea37b85f53a17dc99168c193dcd4077f213d62cce5f12240512e8223ddadbf250948b3d9ad16984ca665135cf62030e7fe9acfffa32af873277c41948e3d9cb32160da022911f95d6e98873edc8d5a6e875749d338d24fe895a18e4a940c8fd170d2b97602e0d326dd488a2131bc77ed1bd4113ba4af784930cf0bfe5c4150758a4456bc165bb528af68c5d9c67f912b7d6b8685095a170810873a2d24961ac645b339f2636ed229dce358cf9f7d9abf18830f515e0ff8fad8f8ca0941143d969857ddab5ec3446b43179fd41fdd080cbd764f724ee4ed9798f2de9d643ce60d37e53e90bd577c7cb822b37af952f39e0bad4f7db956c2823c082ffb1ee3f30c33487f1db07afc131437a78ce46696448ea7c9240cf071c8b8e1ef6c9c747e037ac94db9aa948074226e6ff89814f11b301fb3d22b645fbea0e0fc3571b5e9dd8a10c3dc20dda14191c83815ea5930ee1a20f74483b2dcbaa7742375ae12a515e5fae439af66a44020065f8e1093ec13e65361d72b846358bff780d37f95df62a3572190a7a996f918860f0892073f692a474921a4e3c566fa1117d470516e00ec5314c677bcbc54a46b75c5c48bafddcede59f3888016c5f805fd4ff677a675b7bfe65ed178f93efa5df024483a0851e0a89d403f6f610438c4549c45a2c78af76c93414002b59e2218298e63e2c977359457b08c9bb27d3b59fe9302415d53f70335a20b186616a79e1e4a7f71b8fee64792da789af7430ea812e644833ebca8e84fb280af28dde640bb94f2affe7deb05074eefe5eb4741cd09cd8ebd79ed697a336efe03467282301171db4e1a41017d5ea21aff8594d34f5bf4b0f5b3ef769dbbdd00490cc45ced1087ca19201b547e20f3f8cff54958b13dac9d335520ac0345a3bb7a78a0471ea6fa7fba84f6bf637fc3ef8a7cce6a3e265d3f6379bb98b13d1f0b883439db25f7d915e719ffa17afd5f16e1d167fa7a2d083e4321d8a3acdc044d8db8c5a8a1c1331e2acb95cfb86b53d7f42b5134444c3d5e74aa8cd8f58b9651833760f1aad975d7e0f64815512cb548c95a0c173a7a18650c7e2d5538d644bbee0c63d6678e16852e12e9d5a56e3f82554b69a486242e6f0b8f5bb29973bc602c3a85a09d942f43d1e75694d738b59e3a3fee0046ad975ff8b98357bfce37310afbaf2196f4ff985b35a3aad13e139ca725268026db73a2f8b844312906e2db5f840a6242d24eed5057697348366aa1e586f6f6496c94597c4a6a6e9128d6f81fe1a99792a18bd0ff358ea7bf6496d28a6b0a64fd563e971f776e3ab81471962a87da80b8fbf59f2b7687ff304aced47fed27a15b3b5cb92f7a9c536cb0b1a44a2552e3e8285c58ded6953dbf8136fa4791d7a2c17ee2795d1c3ffa54ee96e2095474396904b5a1971be74213613c7c76b6d110f6a907c0b4cd25302e369e7bda28b8dbc75d3cdf4498301696f585f90bd75ecca2759601b578117b2386bc207fd727d81ed9aed2b5783600dad6bd09b050db181c498d44bf70c2f022e62a87b7ca37e81c165bf4256ed3e56422cb3a7a7815ced461836e39d2c0126b50ae15c32a65b09cdbd32bb28998a1aaed565ae2a9eb0acc519b50fa8d6894c5a01610bffc595794794d26b3621c5ba73999eb4688b337b3b9a2336da698a0f2b56610bb55b04111157f2dcab622eaa60e2834bbc98399c2cb1dc050fd774e0fa899ccdae682b030cc9d1a11b1eaf9ada3fa1a2215a791789c3bfab976c89a60061fdb44c9a6ac53e97d07fd7f5bb2affaeb1754144acb7f46ca9d6f3d44a4e054b65945cf8f9c2721ed482d4ed831a4740afd2a6940eff7cf6eaeb59f88514bfa53ed45f14d78b9952162d4cb417ee5f91ad3d90673298c0880e242e31a506d09650d7268bb7dbbe7c892f5dc4e451b48f95965fdf399053febb722d46a83a8b364b6ad6a4a0b770ae6ea419c2c5a5d11ddce5892a5b9029357366fe10ce005a083e5918407d50b77b0e86b2bedaa9f025f29ba6c173ccaaebaf3f0a034e8c7f1a9c8ce3de0524178b39e4da2e6dbcd1889e9c17d79c37c1859ed6fba98b173a09a100eec6d572698a279e6951fa86e38d28941f3cfeed69d4eecb1caf0fbab987763db01ef1d9ab6f5ded073332bd70df365ba3a543acb260c7f6f51d1842f386d2b45b42cd0ac8a65f2c832aa9e33548479990a69fee95e573b78d6368fede16649353c4a09de2aa0552f3f613a979d302bb55d21e040a078a263eb80da40de3708f9fe090f00e890516867d542d36c08758db30f0c9997b7e0b3e67dac46b5c99545bda8e3c3cb6e5854fb95c021e4f8a351fc79f5d4e9707dbc147be7cc44612726fe3ee8741a306257de2fb770740154a2abeb5845558432133ad6ad4a771395ff5c9aabb8e771a3ca33f9130f1d8e81d16230e63bd27f91a7620c485ed7b42597959318d5d6929c48f876536907d13885dd0489af8ab3097f1cf2396d1ed67fb271a60244a88ac8fb37c05dee41f7f4fbb3f38db05c0b755473f1f14d07b880b294edfb8a05c87c4c90bb0d373922d3f1f9862236b3047435b269e25cb157e944c3d3af1393202164d3e6c8468d92fb741b8de949956b266ee02827b82054bf4d43d3f28764da7710add4c0dcbfc85f1761b4eb67d2938a0bd83636d5bafb43d30576d31fb06d5e37e193b1924f73b497298fccb5a3eb5dcab09f9cd6e0f552ab9cf6059346b20a2f8cd1d92d70453e01100c26f8c7dd3ce85d78b006a3b9c76e1dbb5dff413c97d5d7a036e8a41ae2cf8f8d9b0799d68f691917aaa5b9f901bd124c73b0f5ce7984bd407fc95bdccd96ee9e745468003bc81672b74ca416f6480e71fdba788ece8b93e4b5f3f20609e9e5af8383e51eed99a85c4482800f4b92dd07aab07743aff315342609e134dc9b9656ee8d26bc07adc30041e47233a022539a9f275ebb37cd43b1e05d60059515aac9bf1e26fa676f86da9d11fa362fb6ad0ee2aa4215b0d511e76908bad913c01776faee0b298d46cbccb227b3f573ce015fa75063be6590a498ea70f1d3ab459b1ec42ea665094302f1e88ead215163cba5f266e3f3f507ee9f7dac614715374f9d7bc1fa27208fa8d8f27d14ef1ada8740abe6afc7dc998a0fbef11aa2d1c2cb5898ace96deef7e2d5e6c8620962067f6a1df5610d87460d1d514ae70d2bfd6c5dc19a174f2beec8ac39714c878669298975253f029dbaca6b872ebb5cc2fdb2edb636cdfc56616345495c90ee6b7b1b33dedcd5cdfe6a02dc100c94827c70a1265add8dc6725e641c82ccbd8888d43d26aeebdc6a4b3e81a7cdd9660200e690e9e721b2a263d3ec5401adb786d458671acabc5e5f1ac098d785197ad68b7650baf4c8cfe2cd454b1a6b3fa3b7453f2986cf560df3d14e40c2d8d72da86329cde71be696b2aa460426bcbcffaeca60a829a1f062106f8c76a98d0b6b9252b36e6740e8eae9e68c51e35af30fa9751e09e5644395aaa2dfb13f24c06616d5bda40e64fea18c9f94595a14707c432c7fc708a59869b04d52006faa5a4326adf0c8c006373c7678ec7b8b8e816178230d70a076f9dce4502ec14bd08340587026e7e66e462b5c225f75b86c73e9e17757332b28a0171c689c20b253e5e5150f043fbe4270b76a6bda4161bad2aa3505264aa31fc542cc76da670f958755435d44e352eca7bc24d572468873650f363de071b0db022c5a5cff98ce7c5e934a3e3be9737e07b73a32862575509ef695f22e2d8e31674c5c53840166ef968e46af63c3aa2ba692c7903a65821d9ed2c223d644af0531c3bdd0d204138109da99996a66772a8a014783f3d0b99ebac374cc75cb5d3f8e62dffe64aabc136b704df28e5e9d4b01e33ec8494188cd70c21b8eafe6fc0ef10efb1055d212f5c50d7b7e1013e59b9138bedc11c2cf5cbc44afda367ed7ab1f8fe1260023214dc0cf76b061a127e689db3e140e93abaea16cfcefd10496193df9cca1472c18f16595f51abdb3daff139bb9275260f1e1e5615b19a02e47c254f4c8839c24d31150d9981a82d7b0a3bef16276756ae5d540ad077d8ab9be02f7c370ba9586e2d2c3d464a9af66cb42d1b3371fc5b3bbfe4d7a29b4693c72bba10fe52e4a037a67322a598d26a14bfe1681de8fcd145f430be0edc435b05d33b5101fe79b4db549ba6d282b39f6686cf490872a73fe46a27bd414075ef75aa61e22d6d3a0c133f85cbb4cba85387af2eaa7c2af624c89fed67e5ff0450d4803ed5b29bee8a90bcd544a2a1677135207626f0ae757e7cb5db079000f85fd0663b9c6c4aae2925c85ccba026a74d43cff58b9db6795d61c8cabf05cacbf8815adbbbb1f645c8c2b95e2f8a612cc349cfb0c968fcd4b0ef277d6faeb76fc48a0552b1d415f73583c1f9090844477964f335000c5377fb25b2cc9a733ca966f17a2c2fae163f5b7268288e2ac1f22f2c9c435425b8df3b456eee086a2ef6c988496a2cc297499109fb629aa7dfdb0f87701c2509797dbf921bb028d2a18b5c8b94d0f68bcacdc6c7759e8db664c3b1956b827ef5db8456fdb5cfaf85fce483a3a25b67b426e55377ee1e422405e56015ca0ff1611e50aeddc1e85177d2ebd8787962b3a81524f5ea331dd50cc3860454f38551ae88f35dc3067902973f73d058cfcd6b280ca939a5ddf3085ac043385b59a404cfd77c307241757f39da7a081515a5c5db9f6cb143b715c014dd754cb44c71771b7308b0d49eaf17dac306098ca46b29fc2bbc85de1af25f591fa8ab6b8cbf0b98124f1d168f10b9d29a70db302bcbad35e7cec06964b619249786b45cbc69f87972526b986b13ec57cda57d10a19ecb035644ac4b4adbaa0c4aed2c9436b60f1b3eaf0f58ac2479f6202f5a0875ed1bef2ce046805b668dc40915a1f08aba1bd267ff0383635726159d83a8f3ac0cd85a73201cbe6d763c12a2456ab34902cce8b5045e5cebcc0033b4f1cd0822ad4cd8af0104498b11c501792a12599e49b199b04da3f36efcbba14177e1bed5924750b0e975235821448f4deef29752742daeca8a5572a841050b20bbddc8ddcc9631cdc5036f7917e0e0ef81352a9e8030da4fddd3b11302e1cb875792ad91daa6f474d1ceedd1f5af77b49f5d68a6b600be64420fc27ab2f5c4bf8c9b8e64a7c87ea719610e8b8575400365bea356f61808fdd2bbf94a53adb4e7f844f4af9b55963b2a4da82b7ae9bfd08b37a754f1e0605c09b8f1a6d76ea751fa7c8addec065d874101be37813d10739e39e6200f72713f6ba6c9af72c0c1a4672c640aa5c74d824999dd1b093b8c6e8f4698b847ade5a80acd6677e8a4143bbfbaf278624aa0b6dab93ab3f389d9cb8fa5a85c36bafe6b72bd22b60e1e5985f830ccdcb54e19e9982b4ea355be7afa3d74b9c88bfcc5c7965de9b5c5de076743fa322bcf67807a74a789f6350f717bf350347043f3632b568cc2e98d4ad953c1f5c33fd8505865cc09e6b3f30c69e6e15e958c571d819d0161a4c080bf3a96d687c14ae62029a359d309f4f20bff7ca0ede8e4d2c2b30286d3c1391ef1f4274093cf312a19135c8c47d4b356c9acdff989b8cff9f230f86295621d1e0cc177ca5c279c3d31b2bfa765926d6c2474903806c9d49262ac1ca11d214a63ceed97b73cca0d726733c3a65089493b43e3fb8ce8076b6040226b21683739cadcac7d455686230a51f80fbd6a1f1ad7e6b5b473e6198c35ab0416fec0dfb800495cd30038830205bacce3cb5759b21ca6025549666a991edc63a46edc45989e8587a5925319e37a01940737125de920fb57a357f8f52b2e69e65d3f59bcd81078a3d045b36a5c951d1784f48590dc75897dd71ebc7f38db84b5521d04d2f146502667ee5cc4fac24d1fd02745f30e165c7922556080d4b9814e8207e76af0d65263f470a6f1aff6831c3e92d1baf22f738a83115f9f266de84360ece6eb60bcba2c72dc5003fa52502571d9c040e804325e52a823c390461ff10170a90d3b381fd9224994987bf30dd7360bb34f3d548597e3336deb9151e7a2c9f2199f52555b86b1ac8ede244b9462ebae560c4e93d196c7160747bc27942da07476e47da431e953b75f8110024044197fec14d6921049a8f14d03c16306217f1a27fd7d0dfa90d9461c4371489ac6130e2963316474f690a5d1cbefbb1036f982de0cd00667a36bc0dd682de5b2c32fb39a8e30ba9b39ecbc01e9ea52e2c1280eafa3559edc98b4f9adf3427f48e793b611683ed89e9af4bab1c635c273ceb1cdba74c4ab84a7ff1db5eb693965a321551abe2b08c4da31ce5e89f2d783461c52b59097f5c456bae3f6b6e88a3b1f5557c7f7b942ee0f551153327e34c3544dc66b31599609fade3234811dd989b5e2e2b8559b02527ada9ca82db96d4a18923181566ee2b74c4912eefe9f4bf1c69d87d6ee4ed2f83a8493804f7b332ee34e6e7c1e0788188a219d5d6767936617eb04504cbfa1bcb8f5fd7bd5855631ffb867f1bd91ad7d07e4125d4ff86d29242f72c80e50b1e233660ff8bed799893ff4d07567ab38a61e522ddd0938cd64b51c21379529f03afdb38b261aa501c45e93fc609088297ccdd039fc3f782cdd3d773a7448444806f5b27be4211b2aa6f9deb19bdf7397b080e796212fecd89d71e46b8bded6c11c33b76b68af1f2d8b634669b6d5b47ef983792ac8d37c01cb48e598e3186d3543aebe0f311f6fca4b87bf03f51993e145b3c226dc6d2bb7c4ed8cdce7faaa355c97aba61faf51c3b968116012f638148efcea583fe7375a685d2b2cb0aa16cce0ec0fca5d71d89979f52dde8151da78979d1436a0b0e78d5831616f63040ed97176854c0074bfa5627c7e15ed71f232df4196d7e637fe5bfdd0850cd4a8c82aee249c6288f5f8566b9b98aaf91f6cdaeff857fa46c9ee78bcd8b84d0f792971b100ea93070b97d3f47fdf9a13bc0288fe2654b637d6566c34774c6135ef5b89c05c0bddca51fc73ffa9e96e9a5f41a61a81a84c78cca5f71ed785cc87b1f7e5b3e41cd24bf5101bb6dce491e8cb3acc36b3d6e9c088a37bd5ee73a2f04d603bfd898e3ae8bbf45c44472a5d2c112e97041f2a6703703442d308b953db9dfd8fe31301fcae089e773ba9cfa5a76376e9bf41e7776a01be87d0c7277eff8f4d9680d63275fd794528b8ff84b245a708a3a3112351ffb551cabd8d05d5f4e01fe1ad19303fbe079b65b6017a16d8e08dd891b11e68596a3e9e332b8ef9aa241b4a6421fb0b513ddd86ff27e5d46349db8b09def44643323765bffaf348c3d6410e058ff76022f3e78aeb7e974c6f99918ccf1d7401f50c7a56dd82e7cc4245d147270438f512f39e41689654cf17a8709979bbeca795ecf6c26c7947c11c196dafc0af0d21bfa0c0b9707632a2b31c427277531a10461c131f40ab596e1b9497f1e68cff522e72b227a0e5ce653029bfde46d62d3a612bb093d2c3e636e67f12bab94e299a1e01a2ce9958b75637766f6eeec117309a33329f03a4a9c8c4576bc43dc114aeb137697a304569fccd1602540ec252c8339425aa46cede1a8a4441de429b0fffe86e451d32125a9c459d5446c2c6c640b4ea7cbf863086cb7d7115b57a5f7729bf2f4b07ae20e4186425a7a469e080b7ea9d554b1a5c367366349c6ed9a145f3fd9b8b5eaaf2d586d4e6186da9e544316aa70f9c1c515f9e9d82f1708caa6d64579d003fff75974d58754c37f7b685c329f100af1ec5cb31053dfd0bc61690b0297398ee257864c4d2982e6d8989075b9e8c8c7f4545b2532f0818d79be1fa1355f513d615c977ee03150441b22d1189de1e91c000ec88a01560a997742e51df561dcf6b563f67b3c54402e48a94139dc53b0416ac2ffa5558d7b37ffac14a6fcea89937679302303867e48fc120b1c5fccf87fbb7f092c0fcbc2a974747daf4de63cb6dae2e72f4a457c71668e8d84cc72b03fcd9e3dd7360a9f4e251206d9157a0ae7b97d07abf09b5fe0d19b891f82e9247ce70ae7297bc82b9c32d9bf17f13eacdeda3491d95b9abea57e7a50c5e1cd53a0622a48623bff5c53666e44a45b0d4b46512e1712039bf0f39d1beb7de9c5a7ed53928f17ad648ada71d6529d36cb081ecd8644b1f7bfc6821cb7e92dbb83b7d8b0891c93f0c1564d9d0db997adfa52710f6bca8fef90d7f3e40ee8e447a7cb64d677d93720e324f460122add1da93fd1a6fa4884122993f1a01ba4b0aae622af901996d1ad1baae7df681d3547d56d87f6ffbd504dc19ca1f672bb4e4bbc8c64e6b772f1f6c0f44009108a9e6fb63d9ad789f9d135bb56fb8e0d0167ddc9e0e489abc2babe2f1541b18f7076e68533a31a25aacaf5d7af3d1269484bbacd7dc818137d8d4fb28f76020d42f7becdfdd5486e69d82b39864609c186ab599d017d96d767e704823c8b1838bc878b60cd15ba705953604c1e1ccd4f3ed9ad3183c5550509578001a3f2ad5f55ad6bb10fec0868b3b7e44803353c6697fa2a47fbe14bf4762b96675cfe755a8508f5f2016a162474fb939a9a9e907e2050bbf7420682a177053f302012d68e88743528d43dee7a6426f2af16027f62b75d7af226ad435f716c74d547362e8826ba20e77c243c5d768e35e0f7aa98d59c8e6c23abf1859119dc8675b4615367622854c821c28a4ccecfde49edb80a53fa8b53d56b262adf89d652d6ee11b22139cbd53734dafdd37a50d200dccb28fee99199c8eaf5e80b86dc21f803f9e7ac656f838926278b0ca610415f71f27883c9a33a1f6c6ae83083e662b794e4b96a933c6d4e7b5b0e6f80c841c5f5f385f43bd5911884a223d6928abf22ae18eb8d241dd663309a3269d637bffa797950781e784e6187079694c64c76c1828c7a7cedf5c12d63b236c18cb3e1ef939fb1cdb9f395d3a513a5f9f431b45c6850e32ee388d2415a0fba231b9ad6c721c68d6525a032cd782fa3d6f09775d2a60b5c3f4898e5e1a141845f80fe7481e144c07f4ec094a3aa78b7b5d0c47dba756600a5f6a6d5e012772e2cbd549fe50ad2b3b6d76420f94014f812e2a0f6848d5142eceea15ca044641f527351edc46abd9b4dc5d7c4d36a0e68cb93f1d535612a0cc75f358d9160285ae745cdb08cbdf531b08e52deec89604567f05108fab1b05f47398dfb5997e6d0786c27e9046515dfa71ebc1c7595cf70f2b9b0f272963b081893a43294f65c0fac840ef1525a3217bbea10dce05de1d02a7b74610f17fd1b17c6ceb4f8416ac76b16e7eeff2a79057a5bd1ca35ecf9e8ac331b98bb907d23ba212b7e800fe7e4cc0405ede85cb92802d51cec3d7f860137d433936abf1c06ab4adae2969eb86f6fce8443b3d4cb591639994cacbff5db13fca20c4371dbdb29df83f8094c56da4abed3f6f58db725202e3ce2544d7075dada320006a2e98f56c79b3c299028e4f96abbc8a1be7171bd1c852345a50f6cb30b7f23c86ae510d45f3c6f57f4c76d99db40a0b51d1dbe8df48314e977dbe7778fdf7465f9a32aadcdd220b116ef9feb8bfd478ca0f33ac512f71ba254103088eecbe96c6844bbc63c93b593cf033f1b9b47a50c779d3620e59296e3701dc9b852de84fff0ef443ce14f4fa84cb2bd28b44d67f846d66df6470a85cd6271b5fb5278c7aaf0bb1c29b3d49701b66c0d343f9da9b8c1ae0cf126a745189b346bce7205bc87e913a09395e87059df936d6868dded1dd1044a1c7392e146beccb61269815a162aafd41d4bc68d580180867db0097d43ba91c802f45bcb7a6e7e80fa06e4b1860e7f0cfb939b28dbb79173abdac5e1b8fc696336fcab0b8c375f74b95fd72540a26bd8a849c129f64b082411da2ffebd7eebd2ea4c320905ea7f70411ac388a6553a23a7dbc8e36b15033dbd0035f522052d4b09cbdaa2d50798b114c7d9398599ed45ab84218a85167e3ce3d3ff4631fd403a1e5619d7c03b1c6cb58cbd0ae43a6eb982e2acf7d47484dbb5d0eeb19fe2d9f007bd316fa34710584518b20ea9abfcd42d12cfde3696e71ec8bc748039f45dca1b9da38861425c384ac1b8b4900b10ab3060af5f48b3259277820c12bf3e0a7bcaf2b1486d0000951617f2f085753c3ee427b1bca870828fa23226e569440457546fb4b186a6006be6b7846ebcd0859c1516131303f7b5762f990db261cc77692302b03b0290b5dc733069cd43dc1063f59475e95e05af485010a639e6022b36296db16b2208045976b6daf08a795bc14a0e17495047509ad2e5bcc2de72f8c593e3031b8a0b423997e6fef5c6e4a7aa9ad8f403a701d3a0ca7ebe42c5686154d490e766251be1fb8dea8c3dc066226d3116ef843c47ee0b3664a4bc08db18e5c5e50313bd1defff24b4ad369c1b6e16758a49d046789fe887e9f1f7c6acd063179321b664999099ca08ca23d7c37f768561cff279067e57bd2c2f27124aa3e787a9ed9cb78e29e9d95407c8b05d760db72d94c9456bcffc2a0c56dc2e712c0926a24287bd93a3f9251fce6e0ed133d666ea318374ec203faffc1afb8cae9626ca63bbb2e18679ce70c821410ab8450d8c322f699d884f84d8595fdc86e7500c368b568b1d5385d76b2be5280adf974ea9a3790450c6e50651252988db6901e666756262695edecaa04b42865cc52548db0742c2dbbf8e44adbe0f44a9e7b62ff6989d0760fcc90b547970e5a4875c6827d670ad775e78b824b6337c9ed53662dec996915327de3db978f37be5d994bb8f430a0295266a5b88b7807951ee4a07c08539594abacbc900bad36800198429f116d2cf9ec2b424ee35efbe34a224d99e2bfd23223b3c81d7a8a6114ff60ef93ec5078bf833a8a9e73cf620003a2e0b0fe0f87a1cbbf4fad7a60d17482ad05ac326ab207fc1823861ed7137959a4eea72b349680630e94b5093ebfa9bb16557038261b334c308f7507f9e55c5792caa5ab974cb08b8246dd711ca08a25b318b789e23999a815930c4a68535e33ca95dd3d41bfb089e59aa862b1b8237124674bcc30e5402c9af4088c2d96329b9bec9cd3a7a73c59725e5ec72f1c30d1afd9d58b4d7997475299453036a36c9adca789f442763b6aeed9f0ba9506f522d33b447d2d4eb5efce6df82a7449bc52a00ab8a7f054a79180ba9fefe28f67d226410b5bbb3c3ecb9a425da9880adcf59b1bbca7a7ff631ba2919df2c19c9a86831ab7f8cda1ec774382bbfaf99092785210fdca2ab2315613fffa39089695fcc6b0ed84b86cb95a4baa4619d462d018cb93411712cc561a67ab5758757638c06c5a0ea0e7d2e5ee1d25dadf4177541c76cec9ccdb2082c3b104b7a3d0f37cd7a73d0e349425965069c356f504577cdf52e7b78b5ffef74467f11196947609a803df5be968ee40c0144865cc4687318f1defb80f12d4e1540d838b52f3e870e1641928cc6fb82dc612eeeed44e8fa6b94805200311b56230204272c5e041ec5750766bc298ae906c383c7b0ef771f1f91a5f3af8292ba7477151f3b97d384ee6563e9f881c99b5eeffcc6756925c780de248148520170dabb1ab6bd573f167da460373a51d78a48459017f5c733bcd0e0fa0af58851415a3aed8169e124cf6a6b78233d8a20f47a733587c74a75d5fc96537d3a0da3b4c65b04a7723deb75109c503eb0a92f552124ce55c9bf8b7064b7431870bafccf7c227b008b010fe637f5164d5aa8da03c28a49aed3484c19b3a25536fa31ab95ac3109a3112f77d3395d01efe66b2b4aaedcac4c519e38c7a369bd93665e088805f160ebd722633fbb765d48f2deb29cdbd158366cc6232565e684eadd8ea2b421b551eb292868bff72912517273f976c821c12709e392b7ac83345069c3361ae94380940527717b3e97f58b2b307c9bbcdc5486cd0701c6843d84ffba8b9b734686aad5ca7ebaa583ecd1d8f3803b4ded8e1c35ff81f378593fa450424e38e390b3461eba50d2ee6e61ddfaea7a5c772b6e2f58e266f1111eba81f0b3891d825ad96ae5c56871f9984bb6597a5e74a9a1163fce12a77aaa6ce61cdb0daa1602838e1595e48e98dc91dbab0b95066645adb51ccec1a04e7f241b09cb6acab243dd58d0fdb80b0727e0cd1091c05a85a77e457c41f949789d205444c8ad7d13cc4f026f5a320731f208ca3ea46370d9d1c823f17bdc6163eb84ee09e75187453f6460f54a8722f3229cd897f2440119b51b7b05d8efdbc24b58b6392a78768368b57825a3c0e1efe1086404596e974a22f8e0b4a3a39a0951022ade24f1a28a3ee0eec11104b4960e2e849807e7799f022f65ecfc41133e3d00151ae015e98ce60e7e428022d1a24da32544b52dee4b467869e5400425b27d876d843a5dfa61a35eebb67b4b70ec6f12112cba88b68280c890e51ed2dbee80f9e3111a8c223b22991ee8114c73bee6a8122e7790d4a62e61f32a6cfdacb098b4397f772d2cc6b7cd741f26b748c135a6967776d5d0e822b6d264d119cfdb2b55c5a9ad860fe1f8f37a8d65aaf6b04c7382e01d8f805fdebdf9928f05e78bda56dab13c7b61311916bb3d226ff1d58f908a71abf3ccfcae49dd77a2fe3b5e168146cb8d5537dd1470134651290d12799c1f569ddcc880730826b2fa0b4ab03e7d9f523dbd9e2742bdff4ffa512ae3cdc7d4021d2d527f76b55c0c5886595348796fe0867af5ee09f2fc2a6cef5d259e4bfff101ae6f4c0920ce009ae2929125356afd41a3815080066930e9a6173a108cf553b79f10a74f4faf6674b4645fb1314384e800382f8c6fc9e5b177a53e10c2fa607a2e8a165666c9725c0e1dd6e759c8b075eb902c8525001a571cfb5508221b7299104a81a672ac6099029f55c83aa8f9bb611b2d6c50933682bacb5f1b18bc0dd467f590b51d852315367840bd74183f268b8aaff059896482a79f43594454849ed129086a9df8d6854ad4e0e8198b5574ddc0a59748b0bf7447e16f15538d77833be0f70d3500fe895a35fc80849fd69d73ca7f58f41786658f0662feb4e4ec41c61b4e4bbe1c8619190175691a53e1a530d441e3957a1eb1c5f8753aa67234a9b4c2c009fe49bd2eac3e4f66dbe6bb2881f4d8ca62fd3e5ec099f240fbdd23fedf87dd2b8f843580bf215eed8a125021cac356c74c09e061a275e970f28038f9777e3d446c6c4a3a0290e11caa364be43fc9480336b100002ef7033a8aef5aecae2008efd49693defd743618d626de3adb1ab438cd64056b71660121537d65f1d5aff504eab5a7e99cdcf32c270fd652c96269825c03a8db08b30beb590fc6269481c377829d01f13a953dafcfd1378efead8cca30ea1f2dea821d9b05991ba44dce64921044740986cdcc5b5a78563d5b90600c32abbe211391105d0fbf2527f9da6bc51b567bc06afdcdad35c14e060e5e7dfd3e26aff3847af555cb38dddf4b1d58be9cd5b6dbd91409b3a2faa6b692d7b5d95c7547c743687a3e65e746a98267f6ad00c8fe07fc70a8a16ed7c2b667ea5d959eb3eeb6696afdc46757b6e3392684d7289b551a7153ab83082d638e9370872bf0ed683eb83ccad538c123b2339450ed935f6c1371a68efaa62ce5dd78f1e209aafa0f8576026c5032563edabc0db26966f16c0823eb5a39262b0e67e819397d0cf057f0bdfeb518e43dac10bc9220dfccc596309a5c6764813ca942489aee5d888df5c1755a2c604917393853616216fd41ac28ddf91d2fbc78c35beb2f300eae6da0e8762b479ab9da03cb01b835cb24d9eb436fdcc60a1eb01140f806323644604549ec13ac78bc231a82ed71858257698627c3319a199acd44f9553ee87171aca21e45ac397a961a760a603cdb02ff6c390411c8efbca7163829609be6c581f1d0c69934d020fa95b4e0be5ccec5101cea808d86c58a78a1c5cd489be791d62839e084d0de8a4ee986e405156d922287da8986a2d1ab23433d9d73c511d9bb62fbe7033af9d06d8a0978802814bd6b722efd7b1f57dd5ed51b40381399936cc71110e62c949bac738ca5372e73609c9ab6f37178ce0d8449af65acdceced3f1c53c6dfb9a1c0b9bfa6d70156ce2773d7ba7804d8832cacf3dca466316ac45f8434f281656e26b1f94e77e73d430049e2de07276ba7ca7740faa618e386b117384e15f19aaad6c78a18cf8e37c97a2ba10bc40923b0932a7973dac725df987bee15231eeaa2d34d80339a9ae3003155ef8c56a28518121c8be0c970b15176798305e5e2913f944be3299939a45b6ae045334a149eaaa7be97f5cf41135a9066e41fd779f198689b9eab5d7eb840ca2f0203629967c4d5734189ee67092cf765caab432984af2794410d149b6ed5c768f83fbfaeeb63fd46b84937ee3c9622552ccabe7e238eef9faa6482b075ec0b1d66192c6ba9f9e4169b8923eaccd5052fb3b753587fdd099ec1967ae1a52d13c41e14072293326573f6c35f96bea314d01695f1da14a5d3968b0d311cf46b705d9866e0862475dc1bdea19d12401ab6ba111166262c7c0a8a6bd170999b73e01f1a7785c0bd9a3d75174da654d1c2f0de7842d67a3415c4396a27af0af649de1606d582a3dc60ab40b27328a6dfa7a1dff4cff81f6af39bc8de4b61f6a73b367d2c56af7b34f2ba0885415b83e444859dc1d383fc301a930b5806b656fc595f56f5830e5b1f79eea3d14950c9ad4e46fd72e7dde0d794477644abe1fde9378ea75a590d5986173f9af630336100988d7b974071b170a632e5f7e8a342b4558d6bd20cdce227c69bc1e37e19810919da938e0c843d8f2c4d4557511cd7d6bc3e4c33f2625c51f7d2e61f1db77aa367163aec73ad0ed633d8516cc66223d3693fa99a4ff5566ddafe4bddf92a6ce53758d6bd7144990630fcd810e31718f4d12df0d251ebcb3602d1abc781132f5f10b100bab2b614211e90b87750d9a997c490b590367795d1b7441e88fef35612c655c39ceed99ad23b417b7d368088c6c04b03411b053ef04168bab38befdd3ce465a79d9be20c1e325468d029ac0350a11afc2c6f183024b0974d0f12d3c4d75300b6129a555047bda7c3d2a4e914377b3b324c24302ce1d47ec4ecf0fa83ec14753f85e3c98e343a5484e3ec1a65e2d1a2ea5dee313ff39bc7db74caef27d84f4c9949a6265764f3a89aa5f53b4e69c98a932719dd4e74d247b060109a79df70fa76060beff2cbd6336e6abdae3b39f49e96cc828f5c220f67582773a98b3c54959bba7d85321573747befe83643ea8d81fdb2d7d5e2cd3806b3dbbd6360f1e9bbcd98d5fbede6697174f1af155c43429335fc9b484a5d8f8b6e379eac816fe3250066a813e07531f1bc59dfae2af09e5e94183c82c537562e6e3808a24d47fc67377d02c629efeeb451cfad9182feed2e38f06c52b30042c82f0b34b2853fc4b2e89fd0b82bc502f9c4274b89d39d989dd13dc622c1fe518e1f8a43b7f82e01436902b8793a60ab3cc09a69acfca9f26b7e0fd5d4380ab6e9f694ba3d2f65df12dc339276571b018cd873b094ac32b660919c5e0a4b706e85fa75efe9b81798ff74cf9f6a5eaa4f4b0052798600db777bcc955a5c5405912a7faf036b24dc3cd9c4d65b4bc883ed8647cff30d4ae0f5fb5cb94853cfe2391087c537ef37266ea904da967f92c2246ac8a5e3916d5182658334723744dc00d1b0fe22584cfd01ecb031d1cee13a4067714cb96e247e2ef829cc89593f58ddec91b6b3cb98dd772cc5c91aa7d3ccf8b6d327aa36c0085774fc7dc4485746e2b71264a14b5da8756c6505204511110f6789cfa47324abaa4a8a55fc73bf64e9cbccfb025cde284202e796185fda68babe1ba3353f7d13c0dcdbb08e33750be59db629d920ab442c74815c8c8fd96ea057ea6cdbc42421220909529d2d5da4b83475f1029688cfcb34854104bc263466660097cf2258808ef60f238092b9d2e617d8b4457914007a0baa63204c60cbc57dc92ae03cd345e5bc09d06db67b0a1f647490b4ec1c34b76341cff90a9b0825beebc547b9d8d1c084d7bd7defdea19eaaef47f8d85b6ecddce7c70e5fd4b6ec39be419fe8b6a2a78d2a3cc4642c8d4a9e1708ca6ae80519899f2f1d2df1ffe2525fe6b4435138cb7bae96cce4b32cb5c27f9b7890546a78e1fad04767f913fd09703a544387c0ce39f862c545d87182737464eb61425ffe3dd1dab378eb81deab956298e87cff08b00e36248020cc0d2b2497a9408a62ad7654877a9196408e9fbce7d3b8b8c4395155dc25dd68ce19f7d7f18891fc6f6269bf45a7c10a9391425279db0daf22d6d102ce3aff6f993cfde88773311456499c18d8a46b624b5a353e3f3c14515e128bcb01334ea961d55c8788d17e4f41a92f7e1717e02c87403a91089349d97e9fc12c02fce32a51a4c179cc78b00aac9e11ea3efd3f6e263fa979ae71217c996edcbfad4d87008222209532a9f75b2758bc974147882f2e6840958b897d47f5a3a82de52dcf80068529baee91120df1798b598fce888971204b4224e417c3bd5af4b29283b7f29e405694e94d90fa44731dff5c18faaa4e887d2878700a464199a7448e14479411f5d547116e2c1ea0c5a96ee4a5fe9dcadbb946bad307b84463cfe9990121d3cb0d194348f15b4c08afc081b21485bc45c6c1736085807509cd8125142eeda7ec64ffbbdaa8359c62d1edb615339e87416d7d7082965f98c52305c739d8a31e2579e60ff41545b85086408e514fa7cd3f4d8c10ee2c3a23ae45df2e655b1c3e422e356076a3ab52bf4c50e104912d6f67d91e25a1e48aa6ca324139b5b7d5fc70e4864626b0a1bd664bb47bfae0a1a8210cf0ad868881e0539fcb0d5107f98a3d33c36053b5ca3b3df9495a7f76501e494d9bfcb28a3c3d5d901eeb1348c2a5c0e7a92d33a120abd1b77a4b9962c9c51884ce78d9f872e78e4c2358f91386242a44ee254f6c03e6f39687f23b5a59658b6df094d11ee079ee32d51d80079d91eda2bba6a25e2f24e544dfc0bd3378c53e6f3bb8056750bdfad5849a59c125949a767254ea56d4c4637d2712e3e1ba59fd30eb2b6b86494ebd927509b1a26b12a4d0cae43ccc19a851e165f8d354fbc8704803a09894d9c0e10f9f82667b0946ffea5c73a8c1dbc7890f69b15768a0e6c4374542f4c118ccf84d76b1a4f3d2a7a1cb6591c49f6976c4deb1ea2bd1fa6ce02598ccfdc9d931d024bc5f4adcf95a30546502d4fb77b29d81bbb45918b9c6debeb3a326437d40e9068f248a908463b2243948235818d4ff8499e2a026eb6f997cfa1d173501ba22c423be90b66e5ee0bb7a78f46ee7edcce5becf5c3b273caba5c8b3e940bed3a135d43b47dcbf58ca3e79e123face1cc196eb67d763e76b69f578fc5d00172b40f34a75aae13abbb689ba4d373d1dd694154e2f0a742641158c70b5a23b0d7a0d4e348208a13d79974616e42f67820c623624450ac77e538011d00fce76c825fb79ac5b249fd7ca80f1894dff577db373507a30b0c8cb36b094032a4fe9dac3775a484cfe80813959936b6272402b0b9a8062354fc2c968b5b8796da809e25a351e77679469fa5a2b734d8f3086ad073b17cfea1ae3e0af8824924bf9ee241595e08caf5f15fa26d6403461abf0ce6f3752b9e3326174acfa475eb5073c661070cdebc791c5be51ced26e35659035fbdd7838b1c2bdcf1849c1a55dfabf4c4f72d751b5a21c5bf68e68db722caea5f0e55cd6b50f9812dd7c9a28977b683356fa0db8861af7721b475dc67fdadac340377796e9e0a65f4119ed23e3bc6ffa0492179d1f7838c3257a6141d08d8b2a3d2cf076d3ad4c8385101b102daf019454d7ba07865cdde855100d1bf1d806be84c145ba1c43e3f51eddeadb58f70937042c3313d52b04df730d5820ac76992c63450d21a2924c84997ecce12223fc6c6f027d77e91e597aba2f57aaf19900f10d67b973c32423ee5fe1eb94f762768f2fc1fd6c3fe71e2d83cb307c23574fa5c4a984553d11314c2f652c88a5d4f189593de3e283abdcb1db1e176295d9e910ea68c548e779537ecf6c0a9cadefb4a3dc48555807a19740ccaaa8192d71d8bb97b556cba4d1b60191996b32f764767086be2aadcbb58b8246471c5960093460c93ebacb785964e082ec82e9ea1cd29a6ec3ead6d9106bfdda6252d68fbab45773be82e6b397cb54a8caac89d6f04f8ca13d232b71044309729f3a957185e152985db65aabbd2534351ae1e4f5081e4f7c96e09f184ee13427aa1aed96097a4109e43b91a5ec5be8678b8de5f31c1f8b8c4c05a3686dddcb39140bb1b50a87b99d60e67a52afac4d58b9c9ee1ecd16e8c75cdd087e68e501858048df97e787a87bf7c7568ed4eeaf39d1bf70fbb881004ecf9f8409025b083debf734521af60a46d3e4fdf307fb3f0813e4a46aef52c508df7fa3441d2592a78de91e4e574250d946f66a8801cb54a2e76a9173fffeb2eff8a1bb6f55ef8a4b8193e841f6a3b7676eb950e21fde4e8fc7ef630643653e19e69b99d94eb8eb75fad0693add2d371be822225cd85f8907fad3245ed91cb68a4ee2e345a513591b56eee4c01c68ce12de39a4ca1ca6178f80a971cf429d844ad48a40e6509e78603f367c62576534fa2dc7e3532aed526da4db15e215ed52a3a32a254e0ab0ef55f21fb42b4f739d7809fd6fcacca19c9de763712df397c7907b7d6dc342d8129219eb90ed8eec23c78f7ab2b9d454c449403a1157f9ae0c3c0dc85199f26f76ad4e52806d9def12de256161ce4578b06ecd0aa431fd45d701e38fd6871b71883877e7bb59f16869edfc3ca1f17143e3c6852097fb4f7c50a3d1bc94b0cd2c21903c2774fbdcb040ab686655cafc620b283c28cd3fcf6c65d85869c96c014775352220506b4435532f7e732dd6deecf5657d2775559bce3c30e108cde4b2b817c226acb706487a785599703190b62407a7b78dea1f5934562110cb798f3b731416c94113da3d679d9ae302950af3006f1612be34b3403bd10962b483edca96b5428ba0a27163250faf1b019fa2624357ae9341a8b72043bb5538894750f3f41c96724053f0850393eb286172ed8d7f2c6ff08fb7aae96da987e5ba23fe04456597294821f0b5a130d19bc216ddae82714782e4776f384080a509b30080f5332ef3f97c22d16a1d81a91abf63cd63a262a88fd111231261d5a236ee64b427838d8d6ef8994cf8bcb9097ab66a9106984e39a9c9fe7fa1d31a93ee44540d5bab329853312f35f19f6a22af12d973506370e702eeb04c54d8dbd31ed49e8bc937a7b7bcc8b3a18258317c8418fa41730c346ad07acf2a940f10880b40176f8e16a9de72f46a2a762802b446975b67401524ec30a80c0195f5b31bde49e884b268718450fbd14bc4097a0de60b764b2ae5712f3795a23374244c0b751c5e3d7b19b43c0db96e5a17ad63b5e03ee910273ab101c9a8adbf2ffc1d52b41777bd7bb3a8cace77c82ebd1ca2b54e9571f38743e51dbf2271f0c1d8c031f6e818c5285cfcbb29b7e6a33ed618fb4e9fe275b660152525e6ade473b05deffd3e4efba46533301a0ac02e3f24c834b8bf2f9409add1a4417bb9c280056bf26d4329e0910ee576b7d3682f85bd2121f415d342e493bc1a0af858a485d98a8729383d3f9a4f5866f81b2e80b496d31b91ad682a2fe6efad57256b932ba7d4e6bba818d8bc9dcb5db1914c6b83d77fa8bcff2087ee3138972d34b9ecabbe06cdc742647bdb2827350779dccf9c5b17acf8c35e1eb6299e56ae8397e661e08455b2213aa787df1157086f830a902dfe3d0e6204a6ed98d4692797be2abf25ca89ee69d1afcfdcadb83b116a345b4bff89b97b9e0d6220ed9d4a9a8b74f27424a51a9f260355826fda402fbef16d024ea6a53f919b8b2adb3a570e6afc5febddfd3a5a7c301bd3791e6514dfa4ae338e5b60fa15ed842a210e45929d3db222a0e72934a29fdb5d0c63c775c5bbf6793e4ea61689ae369a2b36f9c6ccbfdced89f2459514ec8f32fc38216a2a3c7899e8eafb0649a64de95289295cdfb6ca53fae86ce2b0a761337dcf2317da2b6653af18264efc38d74844b20b72c0630c38f3ae3cb238d0e1935121420f4c1618ad6b48d30a36f29f7a7d5ef05a5667600428948be3dff43090ff931318a07afd90e1d43c577999c13747ce7f53163d75bab6ad86ad74e5cea4a74919a42b8b08f83fa6fe512ab0516dfa748556700df2d3f357618b51269b01fd73762cfe6d10a9682b827a75f06d97489dbf9cc779eca0bea9beba4a7e1bf95c8c9266ff1ba5afbb17f1f234f8f4fe72983b9d38bb15ff0de1cf35374bca1f73da873ff90f5609da0f46a2fad7a1e5b0b1e63e43b572b4ebbb0f310cabbbf7ecfb679957856bc80373179aad75947fa19f6c066129203d4e54c860404cc9e012bd5c819bfaf2fe602b67afabc9d95527bbfb5b065d162e09844a0c9a4936a7289db1dda593f0a7e2a74a541b087355a69594d4edc1b3ff7962e15ee028149764ab01c38a7e101f480abe690324a3ad347f21fd1c4ee005c0a09177c843e4c7e1468612fa3cb960bb3e850b990065f97f02c111250bd6203a6d834cec29adb8b17adfacd0075032a0f853a34c0c916875b97fb8a1daeccfa3a24fad0f8806095da5e590a34b1292804731a3a89b0577cad1d5eb7333538b7e7469aba9a56d27d5013bc14d4878327f3052343d187e7907479b1e7eaae063021a524a4b0a0062885ecc4d72d2e79944829c1f77c21b6faf8ad88f50627631dd73fd876da020b155f05e850961e9dcf7fa95ae79de3856abd4aafc11720c599fd09b9c69a4e7cd089e55b327132c99d4e53d30cac494df7d950eb60a72f452ddc31bbf25ca86b2b121787ebb93aabe101359bf774737bdca637fb6d86c7a189ebdff6fceb15ac062a836e936385c24f44c9ae90a280ca837b71c22db8127945120de640eebbd733b5c373001217cd991f70af2f7214d7dc4111a47ce762c06652f4a6531256d09a0a3bcc8b946eac123410bf569c4c8014d274218290667c020cfaa11e80992157f739faa303a237787f0a28c4c01512afa8010aaa86d8c721d901f0e1679cf0c777474ef0f3e886cb5317db76df5295a7197352c28b6f65e0f532d63606bf25c6d1ce32574b6a29e62ebf47c09914d50fd552d9c755fbb718903b62a863e1fc0fce8ecefb642747f83131789b415eba08c0c8958ce8d45dcfbff90ab6bb09de0099abc4cb8b7d5f671dde1fbce6663ef6b30d964f1e12ca19d8bbeac2792045b423209bd0189018db5f6fd088a3bcd3226e339ac64fafa706acc2eacb72f2dc7d1adc0eee6edb6a8cd4810a497b663d473120aba7e8f3a3ef698c7badcfeb3fb18d6595ff81b55354ef4bea82c940349c78fd54e0c4ee7147aa0f8959174d08a8195bcb84a78bca0aac4f4878949200c147491d4caa045d6e393bcd34da4193fe82c9d9994d80ede28679c372c7b288cfa1924b44d3c75965759e2940478fef8eb1e6a907f12ad2d38368d4e8424c3eb8fa81e8e1e54eb1a92a76e46de9dd53b4e47aefd513bfeada162b46a2d66402f538b51ed235b5bc1fc13b032cff382cfdab518666877545cb6fe09071c542e913eee8e00e320f956177dd1c80b4226b9e7a083b2d0ada8a68bf5c8711a57c5b0db31dcfdf4e4c2930bbe1bd59717609e161136298d7f8dce029fd374eb9942d8fca4edb700130ca2f6455a7dd56782dbb95cf69d31984510a90e9481165d82410b5a5b2bfd95386959d6bcb57dca3d6479ef5e4d131572bc80e45ba29039c3f0302217078f15b772ba34b5c11b94fa7fae34c3d595347b791d3bb3d27161e0c345ef0546feed2849a95c07368dcb4f3b4e43531551f77924435969ec7dd175434aaa72230b13dc5843daadf283e46566a366fa3677e09e75c14c681fb92c39216ad766fb407ffd1e71f004c76912b07af88c2b910834330c6d96756110bd89f28a0f268d9e400d5c7e49f85bced17be79be5ccb5c1a0eed765ca69ce1ae1425028d1c75fad70bb198fabaeed3af661544b1f9c6548846e29c9555f0dffbf00ffce1153c8cd5da57912dd8bfbc72a6de7d59907b81fc83f2b523ea90de6620f6f5da6d66e5406a4019e5c71836941d2e9da7b56cfe9cee54510109506af792e608c38d21428512071ffa2480e5b639b219e5a8143c97bb62ebe4f73c3995f1f04f3b35f25f917022ebc01e17787b15a3d50eeb9e251f790750658d082c0af2192e90f43e7db6fe59c3004265a5a95108863918a96da11a356ef93aa90fef4bc5639697edea3ecd03521d48851f19f277b0c480f894248ce8f7f7adf308a347e4a42500a734eb738842ba9ebbd1d8e4367cc2194dd1032aa2809fe567134b3ad4e378b658257376462ca2df7de0ca255245284f86a7f9aaca37e4bc42a05ab40c8510f9116514b4f06ef293c056790d4f02b58d99187c792c92106eb00a1552d6b6b6d67d4e159c8240b2d8c28f0a27cd686c2d928769e8d34124e0a32868747c2259e522363aeb1119ff9c63066d06d32567b94ff487d4a5a4e1db1a11bde7312369bd091cc982c4b19620c4aded490c19d3f27d349376eed4b9369d33237571ae483be7f44e4a5655788a20b5e3d85ba7c58345fbdf273e942e896053ef287160336b29ce67a762e5f33a074b5d5562de20e78ba3fa1cfaed97fa55b2af450d46507ed26c9643f575eb8e4a7f8f77ddc5bf799cdb214f4ff437234c71f9b9cf785434dbcef6f4d78f3738189d0836222b45ac16562899398e9eb1d2ba2a2f92d0d3119ebeca647a072ce92040b96e9fa34e5347aa5d6e263e17211f93651d868918b09e34575309abadbc3d1d766edac656714abf93ce354718db6bdbe8610248fdc837b3caf160a364c388167d83f42922c7fa39d2d5366eb4057b00f7cbc95aafb18cee51333353d58d98a3a3fbe598fd498f3687f1590aaf7c51c4e1cc8e959badc8206a1fe51672e526f2bde0b7b345da3da4b0e4f5161c775b3090f953a17079bc7ecaab7f5bb7cb385a62bbbda089d547df5ca8e61ee3d397399b8ca7c4295f99db5a431d5dbe55a08516d63c3768cf20be9d71db1a8465b8eb0c125c3a32de6fd165e1913bec508a1ae6edb5fb49e59d5618f097b3cc1a5897f997e5b4778b2be027fb439d089630f2e728b430467e8139fc1e4534d8217953303366b4a37724fd0b9b44c20611530ece449c8b7b641615ae3229ef7731fbc7123f1eba8b78d34ae4d12c792aafe33965cacf1bd8350666b33f3a761bd460f55566adb2b3b597fc8d7acb12b96f30aa25692743ca18beed69f87c9c3e41973677d61e9b21ff19a326776b9eb7edccf836dfd70853830bb8776ec32ee12509f119240621eb4b682934587b415be500f580f2b4c46b7e2093cb2223e13d3e4a42c8035162763a017851a21992cb45bc36d355956e2b790d193c9fdc9f9e89b651ab39e25e867f909c44fc645c5a646d6d24719b3ff9816477282d5a6cd8f3f71abeb2b9cc1ba62b085263e8ef3b6087829dc48526850917a9fb24afdaa3cb24928b1724ea3bbededd9cbcfe8e701eb5629d19ff925223c76cb9be074be5d136f61798606e271ea1f823e89702e011ec2726f8a7cf0effd59f5c608d89932d2ab901beb2e3c55c1a74a98f619b54ae21089e493e9320e08dc2460d86072dee6c361232c15f703203930bbfb2799d2f52246a547b70d91c8dea24d2086f3ea34efd8e38a0f93ca9e1640f76f010d7b2c05eb79f4ab0b0aa6b236b5bf2173b652d984155cebfc3b6eadff840d2a92ac82340b3e1bd96008b833fde12ae1987fe10f12980b0a491c47cd2f9dbb95d6aca9e993d26ac912dcb195d0227a005da625acc0d161a33962f41e933eed928ee1ba56ccacd0d6b52b92b821bfbf24b640497ab7f709b3e0a89f393d1ac1ecd15c1369a4d04ca3c1a2848923c74a678445296f567bc7c3bc70818a8af567416e433eb424578f671d064364fd94e49f686c2dc36cabda92b5cd08d75a287a57145f1f441c530c6e38940fb296a292819bc71162525c83cbba93c994ae3f0a67e3c8521e289322260682fe4c34effac51d0409a2eed90c87b4988dc1d4c5e3f0ac8fc6ad07d02954a52af770c575d721c298e79e26bca347976bdedf281fb75a190fa33023dc6175f7d0d7e7415de60f34302b5fb87aa43c27338dac22e2af70f3838c0f771c555e0abf737ba747f01fcb3697e8c63f2022b597164dcb767aebfe88ff8a969906f6869efde6905d766c98c1e617c28658d0c841a31950d93d0ac2a1199063f4f7705089b40a27a765c4c3c2a63835a4cb01ab65710b70f675a3ce0095fddc0cf65f70818c22ce88571a23a9cc85755ded293c7e75f1336afa87d9e1f7173d9892abe2f30a00ead16dfe191cdfcc9b85ea4408ccd514d540751c1a9040331dad0bb8057d331c1d61c3a140af5ddd031cfa77ca975a61fa0919f2075741fe31e1b035ae41e35f5b056ad30e844e4aaf786356178ba6b25a6f8f025d8883cd49732abe694100cf9c54666b599ad05fd60a8c08b68a80af01f8120817873508746175fd89107c3ad00baa6a5076b721c6804eec3be65231184f3042f8a21c6d38de830baed8f306b3f2be39370f2477e2bb408a0ae73275ed1a377d602b8d5bac9dd42fbc9b98d00d0416a1cc9ca0f87e0c8b619ebd475611bfa3138645384be11644d322ea276520205507e9dcc10f3ac4ebc9390bebf3d3b317bcd5f0c8eb93965861782168a82d0b33f222f7f14cff16ca9ab9554b98a00b3efd53f073b76426ad542e3edf8e758e7e91fc6019fcdcb63d5934df3c866639cbea024bc766f806d11134df7520771c7b968cafb661c9ad250cffa1b97db8eed1001b057157e6fb06128fd5dd6a857aab3aba40c4a33b39d768607f3dd2d9281d120023e7a6735098c18d3139472c1e43c4f851db2e181ad85ba2ed04e212e641de9122443e029b8aa8cd8c7aee10df85a49f9a25373deb17f1d1d902845df37a50fa1b1e1932d24d3c2c6d9a67790b1381394211d428e231e9ab53a42dc7a76bc574913cbe40313193c97188482866b961a6126171c1c54a215eda4107b82744635366716a7a30e8c6e656439fad82da2aed9c5f065e47031ccb292fa9efceefafec774c289236f558577354b5d595bd4b824f8d82722fe66b3c09840b5da4f65e01d4b9e4f63a26322ba41cc2634102298581ddeaf6123c973b94a5baf57d9513146816fce39d617369cf4a82528e811e766aeecd0945a449dbb4f686bfa214741126bd4569093c9a18caa5479124d7ebb15ad58b6da34d5082f7c16991240a9b3bc14e5b6526ea41709f6481fddc0e84c684fec506ebd877eacecca41a9a266d12e96bcb168cbcedd4a982539d43c50af3a0c2882db5eab81b3be00bb0c35ee4d357f22528beb8bebff7c90126ce610afa4d2df0ad7cee9060276771fadff92698c770d3626bf066f5cfa9d3d8af6d10ddc6da28016f53d6e4d777b02ef1f5fe3c43da4977b11f455f935baa54d48d95de68e1fa75debf9bc68bb02ddc82254e62377f33d571fed6a5b1e002102c0f162b85cd725781b29ba245befb9609ac58f72261f20fb65eb4eeeadf23aca215d95402edf6361bdbb8a3d93a98eaa3388751d27249bec10777c2fb7bca0ed1221f86caa48713a2db1884ab1a59dbe9c1a117a2d4976442b13bd7bf16d2b2cbff2c8de4a5f9b3cd4a3164737f2162e053ab9bcc9b2db9cc2671ce3efd832ccb98f7dd8b7a0af0191feaeeb44001d8cef25157ffc6c6d1a28a1d11903ca45f1cf7ec659d40daa391a7e772096a53ead610067e6e2149ead1a2a8b59295caf130dd925e0ad763cdacd3203a711633dee092f40edf10b19e3e696ae1a461a81cf107e08e4d4ee1ddc126cfb5c861c71dc30399164ba660d74207e332c39c0aaf31113e1d12f0cd35c4e7a6024c1284b96fceb76c26bbb87bef10072835a6ebf4aef306c1aa616c81c26fd9ad14b2084d18a6c3d0de16242b50ec030210a0d18fb9cdca1c5e13dd824afc6c6ff908b6c2ca1ad721d52efad9f2c85fc3e90ddb98a0fb27ffbb0f5e64740d5f8e32cddbb530a43d06ddea6a93c27f231bda6d9cf28f18107ce20c320392bbd44519233f7671f2d18da42496f29dc4eeb303f6ae31a7505d2384c7d33feb9c684f109e08fb6fadd044b7a17cdf1054ab94d411120f532c670bdd9d36ff4ff1bdab5fa614e7c2c2f27413d1149a8c44337648f86cfc28d1d5fe914f2a1f96f1f5b5d95fad05759ac81b67fad034a7b6b861ed6d6f32f0f38cd6e3d08c70deeadd65d0d74364b4b0dc9340b97b2c907230761fe45ff72a9a536c370366b5ee0201e32968cb8e6a8b8815912b5240edeb783a20270ab30b245905e389b3ff11cb4bd4688248d3012e83d878452f94c8d05436874e772f8594543cd64f2035dfdc8aba2cc82b6563c3a21b8e47de73e8798f1539ad4e10fb94281ca16fa78d339833402b884169c87ef09596fa4719a6347dd6f3189403e61d148578d27c66b8d25c008187868814cac2e3c62d27627e48143f59962ae04ed73cfcf93845edac446534eaf413cedd54a9077a6d09a061bb9dd0ee4739eed1935a728bbdb7da131704185624cb17cd14420c5d00faef22a966d8560feb244af81d5c6897a3fc5bf5603e944fb3d4de77a7b5bb2d4515b86a8b00b54f2ad578bbf0c7739e2dc94efaad85be460ffeccde4934c32f0bc479b55aaf256bd92c9624219a43cce29d38b5b9fce98ffb7835032aa337de1fb9087fdd2aa573ca58da55dde54858473ef7b4ba89a15a1f34854cb2802f63ff1c3aff824cc584ff93018d66c092b3e3eddd2f8b3a0acef09155c94af7f667b5ff528c438a97fe126f9c070ea0f361e8410cc41ee2e720996f91e05c675fad0a417c6c7837418db3378d0a3f1c6dc63367428aa899222cc2597b573c25100ca1a1ce2889dfac3d280f94bacca5a42dfb85db191674835cdb01cd7dfa410892ba908c77439358bd03ce7b3e48c2929db1a9ad74687564918f226cf02c7d42a8fce638d8dd8383e806138926783e122aa432471d9fb88e1f755f91a12e723890396c0797283c660ceeb64280feee729b88ea2cb1c9a12e4b1ee9934c0ee9d525f62e89c3f886ae70d9af9cf26f2387a0809e72f3f2acdf597967c860e00735ce83c7f0690dd9d5776ba35c5601dfecf4c234e2afa4279a188a9dfc8cd2e44aca3d8bd475b8559742a25f7633652669568185a1d554f303ef78394ff9f57b657ed8b90bf052eddc6751de12c2ba09628a6ce31917b236c558e99d29869cd8c9aeca34fe1140a8d2f5b7e03bee6da926dc28278be031e452935f03fc2443361bb3f1f40267c2d4f7a7fa7599e4d37c61a1d5bd7040df13d84aa94d971fe46d22384400b13c87e66d544b07b7f8d860b813b962b9a2b040e78bb672feca800869160952a7a736d3e0046bf87b5b21ced2f024888fe34267651b06593265802e44e6a19f8d86a7aa040130e59570177721f14164c5095b62914618b2ada09f3ceac7f0647df08c69b77192a58ca2a4b00f82df05a77907dd92a1d50596711e2478363260dec38a063641f31906e5481fc66c9a47bcf8c3d064fd2a7491c1fef6139850f2d05b5974d90722f7a5eae24b573d0db5f85de8f78a02f962ea5c151317667f91a18c550041d9164a513a5dbb534366bb7ea21364eb9a5f214e3ad411a3a662510d5bc665ab381258d2bc39bdbfb67fa9eb46a486e44b3b3119f0ad7bd32a2f9567384d4ef96dc30ab1e031119ba8de0ce36e15dee975ccefe51cabf987db07d978ee2079fa4248cfa4bcab7a05b53afb1d9639c23ea1cc1f8c987d86ce7ad3b3ecfc4e40a09202e65963743d7435e98328fe85c70a7f81b8c7733933b9c1a3b53756dc91a8d3eb973ba91998187111125ca7c114caec8d31cb2905f4dbf3704f7dcdb0e34291ce03d802ea8aeb0e2ca975173fe1ca809474eb2cb4f8af6bddba1da79ccb25dd876fa14ecce261fa738d92af6492854e434bc71c6123bfe488b9f676fc64c034e58e2fb08c41b4b093a3d8170079e18ccd6e4de7020fae542357d8bf4f0cb5674ad088b11483803776bd72233ceea589de38e7b77e4573b77d2e0d8a80e01305aa63c8db2bcc74622bfdf1714b94172d85fd44300283f81d7dbd25b51881e4233218a1132743bbf5ecd7563da2e2417408bc548b849a02fa1f30a2f90448cc677aac6f44998c8a91ebdc7bf01e572904d372f0bfd023d75a1a6482ec78414fe2dee0f860c28838a0b642d364ed03a518eec1d90abead0581a6e420e624c1d47e5534d3428476b33b25f61c804fc1ac0da1dbc39efb14eee164218a47b8d41363fff2adb56ddc8e603cf309698e7c9bcc79d528bf70e8ba14062e9e9a7e831ecd72283e452d18bd357d4ec59445fe0a32f435b9ac2da5f90aca915164c1ab938755fe69489f97a221d5f780b4e9434ddc38ced46d6dd7e8dda17bada1a58763d8f776340ac859be1927113a38780b3157c72a7974b1679443e32592c1e2672229f88c77f895a9e73b5c83b7e5ce411c799bc12f6f4640367ffc24423379db6e7eda89b43662690d36d5e7ed146b5e8fb0bdc233a49599b070e3fe05687616823ac396d29d1e0edbbb00cc4f252389f50a89ce852b063285549e609a5c712dfdb19079703db4e4989f415224dd0f36fd900bba043e6edf424e2bdd928b315786ebbf469cfaa7d1ffaee58fb52e5ac03928b76214d6f148c51983821d290643df2e5f0f75730fb1db5e55477f8975cf982cfc784000ff7ca50beb43d6fa6d409ec6d802db9f19d1bb5e639e2dee4ebe5ec903cc3e6b6faa3bb6018b956235510353c6393e61b9ef3994ea2e8a1dbdfac6e438cd716289403ccad6600df1a95c9701d486c2a2c5a22efa4771de1427767fcf8d9db5284ce2eeec238a2e317c55fa56afb026cf7c23d84fa72b396f710231fdd25a2c896d2d31b634a3f50ebefa116413174647f63b127017fcb529a73a6e1c4b754fa695a104bb4dda3388ffe8ffe5d806a1e852f8101794d8c9cd029ef44692cb051af51b6e53815c4a578646f199765037940eedcac9529c3b57aa123114a8fb579fe43cc2c12453dea84cf21764cff35a459d6e3846db9018afa0c17a4ad3ab0641bb047c755d751b3cb059d88202d025414aaf31edd99df842ae8d12d0155e597db112da17f1186dfbd9ec5901e3f4ccbb81ac8922ff06f7d39176015718c141bc795f23224e9ad9aa850daec3d3512ba1a1b23866528e6d760448eaf4562b1f94c7b90047254a5a5519a1c6dbcf9576b17b54b370e58c5efc314a7399bd1ba68457e5f4e800cebebf515225afb4b525c49b2559102b02ac6ad0a47512a4ce9a146234862612ac5df7ff071ad33e26d1ccee5ca533f0e8b71809ca540c643655b14d350c78d167b3ed90c329e6932f2861b1e91a946ff044075240e296ba60f4ccdbb1ce405460d06c5c5e81d26ad890d735c3f758e7613422e7707f676819020b68ee35b661dcb5434b5b70a81d0f99dcd5834d91deaae748e7f0639bad9ebca4025aeb87abe8569b4a3ef9245c4c253381af8539d7d1389da24e4d37eb46b676a0a901fcf8009edd0b6393fbb9aad9c5ff2974453dab67a202fe8006a7a694cab904a40f552e688dfb2beb1a3e792f595e6d7e9a4d07f649d301fc35fe86e8ddbf85f1f88a9620f90169721f34eae257f1cc81a385cd73867ccd3a631478dc897209a95653dea1da977d8cbafd0835c835b5b2405d6e0857e6f412ccb502322cfd0be8379b99c803611096168a0107ea59c6860d8d6d246aca0a6a33e2a0c1232b40a4b0b01fa6850f1b175589707856d6170a979a2f82dc150a91661258125ac3fa1bd54a6ba74a9fe3f24a0b3cf45479583c792abe305bf5358316ac81a2d7064fcf7a545c9d46e1129eec69fb1c21850c7e583a131b33a33c6e5914bb709a605b62d9ae729c6e5077bf0b33a9b5afcd4e68fdd0a78df186818017edad2f14f43a0774efcc27604b644d9fc798232b0db9b4db27a5581b613becc83a6c952c74ab9df02f1c9667466dae7438651dbfe39471f33a0d9782bccd3b60eb3046b554ed93b4a135a39255fb3a8ab41f11991588f4c34115acfc5860ecdcc6f6b202b676341d1fd5832c2f6f61ef67270c24bfb928e722a499e58126d0924e7192c95161deec51349dc046cc26835580ca788019b31bf9a8c21fce3d1259eff0c02e277aa1197e7836beb7b8e26dc7a12b6d8c0884e7392919c00ceaad9a406abccafb13d11e9c373f4d8b50add20d395832f2a35422cf6a7f183965548a6c82edd8512f42440c073ecc595b5fa288d5f8e93791731e93d88acfbf3e04c1e3ac2da54e1a7173ee1a473293c893c251c508d7a3b4163b26b9860e38c521314d3d614f3d3e11d92899f32ef342cb45ea89e5cd79833cad6d85e29df03517136b1609830f7e92161d8de0f48f53c357b1875f9275518051e422bf00c82bd7a14c44df08623a42234eca1096e2b56ef46540fb7296b25623a3ec8e89308a7bee3e19de5e522c4646546e3a24e36482b43c3b625c5e226ae2ca9386731043d400af56d65b13ab2dc5a01ce47ddca15e6b7b1dd614e443bbe3e49fe51037316fcc091cf9ca362e9a67aeed11f771b13fc8bd38b4af4f3149157833f3e2cf6909d008f2b4f723fc6cb1f02fc2213dd56119d9245d78fd1d67333cdebda881e28695295c70a04c2c6f8298aaf7aec30bfcff110ca983a4f4ab61d1a83070d3179975b57d675abcbd813936add758d361e27b3d2f4609f89294ce0c7dc97bce16fff120c19351c922d9e6c6193e63b7b6b3c5d516fa1b85703eac95b9b5c94d2e729139403926c4e03ceae5167ad3d69ee6485f2db8a88dbff1cbc94fdac4ef0aa30bdb5fb6b0bce053d4e68b14a8c4d1c640c22264257a53278175fa66e622985392fd495a31e5dcd046ee5ec8d9fc1e92c035ec056dde3345c68cfb4601c1c37084dbaa6cf645a02eb060a75d2a67c1480f3410466100363e0153cb20d6da62f71a77242a263e4ddf509b8a3ca196ced17a614cc4fe9311eb939ba79f61aaf595d1fa205afe799324695e8f9ce6f6eee924d8a2b5c3eb4f86a5f4483c1445cccbcb0b8fc9818c681905ceecdbd4aab65807783770e6641f318dfb0956b5c3fcc32bfef1e016abed96ffd9525525e345867f99975f9db9c15a3960e69162aad087a968d05cb402a9ae1934ab2a77bc52d68f01435a4c05aff0097344790184fcfb087c25b522b905439644a8b3ae1c9210ce06ec7608285fc974f50ae855037af7921d81c7edf7ae9be89c1c9495bd1c057735fae3de581d076890cda48175d03c08522c7b6e2e7438c006bcb43e4fb9d217424d637639c97af3814d7796656113261ef8ced723356d81d0d03e2ba99625bbc77e87a6bd93bed7352f5496bd9a66e93e116026968049ee05eefad9abb18a6454ae2318f91eb5e77405b5fbd46c575bcf02e1860ae621d0357c0085a45f9c01ff0302bdd466bd2baebc3b1c0ccbe0c2c3c20a64ffc538df4ff33bd131f5342dffb31f3f3dacbd31d1c7013b28ac69a4c0faddb47ca02a4b2ffd2022158f90398528aea1835b3258c7c7a306920253c5bbe59be3f910e047a5c7a3eec44a2f11cdeb4cc4531356d2d24ee19389e43097eb9ea41a46f07fd97d1040d95f7adabed94433aee8cf9c53288ac006a58b131fb8ae44b3ad85d5a0c1e6f86c39e0e0b40e040c2b27d51b910208e21f32ca7a98cb8b174d3292f65943d1aa556fc7b0b13e6e58696ab9d346f7b91a50828e60879464c5d15bd0790f4c666e1527f60eab17e7dbcac16ed4fc5ff46903f589e55930246b9e2623dc104e90fea90c35523937c0fd40bc1e3b5f25d5428a4e9bb769bf5378b468fda3c5ad1d169efe0b95510a8e3187de9ef7147f1056f1001d62766fd0f1fa2113e56459a397bab2df62f43f2b7a11c2442997733b18799ae215aa3c6ff3bd95ac39ccf84d1c9170976b6292872f1584425969da7f998ebcdf26cdb34c3d26bb76407fbb1f647730c4e4414df4fae673803dfde35ab934cf067be54e2cdc44a5721d74c9d1838ce69b8e96e57f9f99fca60ec08a06e313e465c69152bc228b1e8a3bfacc315300bb41f8cdd5ce99dbdfecf9b3cd2d04704ce61b20358eb395f4b0915b76d1de8e27131b2403615f271681d4c95dfe537b1c31aea90439bfda92d4484db2106842cc50d57fafea8f0fefff34252fa035f995b7592f43fa1b0d93d6b30fa0a0899b7517fcac683cddc781f62ebdf96d59bacccaad2cab357bfd6c3378884dd75f88cf78dc0e23b9a1e38d48d409f1f139a9cf2fcb64e2b23745a7d507381167b34c67a8aadc5cdd5d5944be6f30477f7955e194ed2ad8eaf68c86ae30e5f80a2d22994b2dedce21aadf6daf8df9e495b9f376685c68e8c77df13d9f57b7d86cc4eedde071cf1e4e48bf89f671845140ee32e6b727f37ddad1e079de43f308421d126f9a3caeb5daddfddf9bab24c5aaef4992ecb055413dc522881d4204ac44661456ba2675128007e0a300f7a0e5d4d06d9b73ba6cd423e8e731049703e5ccb6691694e1ab09e467d09c8730e58863aa1474b12411e71398f1dd76eed3bdbbc147cb62321b756293b404825cc2ea3bee9d3ae8b7a4133ef83bd3d6a9c5700af71ec61f6dc0ab6e8b07640b87eae04272038b8560f79927f3ebcf75755915bfd57445965b92c696c7e14679ef0c622e7f3cea725baf68e4b51a4dad62a1e2cb3eb1749dea35d88c5fdba8bac24f5c064020e893ae0a0dc95655d83b07c440d02482675b67dd804dd9d2da6c4be80200505d754d5f78dbb9fd76a6f8979d81fb62e58aa8281f8e8e8af7974df58968caae3430a316eef34d77b2328266a53e6af78d1e15639844b27c1399ea8bc1b1691b2deb9aa180a50dcc6f61cbcc9c36e00b849cd2d41060af38fc9e6568bc9256168b068846fbf2a7d04e5561d74429abe955a1a0fb530dae5b3de8c56c6a4ab21b5504942a891b5e865549ad67413c2dfdfcabbe4e338d7ca349bde1242a651cd08b59525884ed7266fe44517b873c914dfd374a98aea918b3bb91c785dd719f855c39327914fb7512967437050419adb19dec024e24a569edc64ac6712e3ba4c91624d573e7d5fac9b89d36e9f7bac955cac7e92f7a1e6ea1d50c66e215839f5d47cba46b12e98b137e5b0423374057bc4d3fe15fd3bde36e294e008b0a006a8b5017f39e66dd69c8b435cec26fe279cdd83616ed52d374cfb2f151998fecd7e4a56f037e583c7aa178866bfdb04b61601c1974779989b3fe8ea6b4f80a7fdea7172457a5c61b06e8681c29e4db214f12d55ad3f457e4641a20efbaa1655d0aa369e6dc6dada9164c858c3d913ab5684d5a5a0bb5411498808252412a2fa6117acdd099bf2051fd5eceeb44426e62100163e19f8df762278d7d88dd8a80094783c8a79ddb4d2936545bb5e5d48f396a7799ba01503fc09cfa423db5bdaabc86ec8c0bd8be829a8b2b87be3071355fc450c61f519d6c0c414f23affea02e34a2286e82d3e7e6c6405a303375378d812e7125362c645d4ad4689293c909ca7b8a6fd481cc897fa2c1b595880d83c7e2a70265dc09ee75d17c54ae108ee59d3d8b40dea922298c5b3542f82a3435d5d45947d94865831dc6e152a9564e5cc541b3895a51e829de58966e4c63637cfcf82a0212802283ff20ec72dd859195069f713a26cf3b76793e96f5ae5977253de91dd046e87d7114840443fc22e4ebcb6aa1d7d0ce32fb1f34ae565b0bad06a90dbc7f77e87df8284354c7848dc6e2e840241be71507d339207432fcdc851578c68b141ca27f04ff85552662b0dd4dcef2cd5709a213fb52822c0b5d7057d4fa276656bfb048c6126d79926f72e39a13eef423010bddf637aedff3dff9433da64451b3eb49c2b2287859d52b4b96650932533e249bb22101c32f992e9e2e78a5f68c68c6b4cdad5d3cd90e3c250cef56e577901af9b5f5580938e2ae00ffdf2a9046053f6a1033c882ede06776660fc83fffc3ffe3857d73a650da3120a26fb865c010326caccc19e2ac81cab879d3f1f8936c635d415f9ea10f6e39fdb26181a470f8db11cd148f4d854c6237f48d595d94010914e1d52f2cb670cfc14868a622513a14a858d710efcc673e70c31abe157c84710a0b4ced64e4f926d90028e0b6abe996141c0035aa06ba20d498e69f54f7cfa273a8c0e430e48e745278d1df291da6ddefd82ab29c1112a0a82eeab84d60e5de94de100e16fe38a68218594c1d52147dd057fd804e28c7680b3e7038b1f08fc0d66a15b21b2c886d50cd4d1d0ab3eb75ba8dfbf14db5283653d9c49f0baad526f46d53fc31b905a1f346fc32d8e3fe7418cab5cc8118bcd54384208a7ac5a15580f3eef5a698b135879cbcc850da1e9ef5f8c9d49a4086a5ea16567e45bf0740bd8b18b638d067cba1ccba35afe94437f5b935368acb28b09d88b6982d775873a6610d6655f6666106a2021fbe40996b31532b196ed203b03df629de0bbc018b685df9c527ffc2941025702e05f226dfb65c7031a1ec70ac6548dba9f3e9a5a2c8b9b935845f6cc087fb46e49697079aee19408bcc8b63b7a62fc73f8b9e20e1ab57b8849d5bd98f72ec2fa4fbd3d07f916eba42c17ceee63af329aa7675686cb1a418e791c85a94f9930ac49480d7bbd3dcbb2e34ff158965474e2f8326f6a73b14688a5551cb9079d921468ef12bf4d754f107ddaeba1c4abd7b4d847ce7d430650bbb4a0687aae38d3ce7ca7519f06b97eec887c9d186060e399c32f4a46c334a7edcece64d6a76f6bdb1f18a1c732dbe765d411f925bb2979701945cb74605b9f059e7e2353fe733d25d74d86f9d3c90adcb004ccc147574468874ff842c66a156cb9a9c56c55f3ddbd069f12dc3e2bad6924db29af5df2238b6ebe727e9bd99444cfb450e805ce14ca4d8f682d6a8a1c2f250c449d4a3be9e392eccf17a6e5afd32bf935d02967cbf57217fc8c7ded1552864388e65e8c38d57c2d8f9252534f053088a4018a96a6774ef8c8bfae0302046b583865e3212e86c17c289de21c95ffdcb9a0818dbbee072f322b8a7b9ab802708e0f0bbfea902773efe50a0d12dc684b252acfa1c9266ece13813fd1131d1f47786f13763f1ee204040ac380f1bc6a4497f2e3e5bf335f0b370b56f655669dfd0b1dcc0ea89501930191b8dc37a4368ea60407a11086b8c8cdd6ed09663b380fbb1d6db7e9df3d6819e61022b5e75db2cb663302ec374b88af292876acf51f499a97c5e8464d3500d59793b344be42dbedbbd94addc2024f4df15113c17f20c8b8d4bd2918ca0011ee6b3cbf7e367820810db4241a77c4803e93afb4372467e14c256db730792033bb572f3db7c0f8906bf9856f9d271071a66799e2364edeb543b40d0bf541461c44c7a02aec729f7ab5481ae691e3b215f6cee8eb815815421175dd388443a2b1c227eb089de813c79ff078a7c54dfb23d6ca4eb345fdbd87a26a075d8de59151330e062d817534a445e15bfb73f7015f8e4374a34706478a82965523b7444bb2cb7bf44a0247fd4f0bd52d9c613e80632a9c1eb76df3c78a18a14d21e7047e941433de4e239dd0cb071298a33b4e9fe0899d67fbf7c87f0325ff6e6bf1d32fe932f0e0114002d177412460b23b3368616abb30f6e60502cbdb2a4a20dd57e3871584ef59340c1a26fc82b925a60dfdc71357bd414db6d1dc2ca5dbf116ed9c6f32fe428df2f27aefb818b047f56378531b5cce926800575a9761db2be36fd7c3639ae32150257ae63cf83c8c584bbaf4c5dd0d2469550ad36d6c0b62ce3568212483fa7553f809a70d9d0a0fb41a68e9caecc37ccd1733de23442c283905a85766ee6d75bf1f9db1a057ff66c7f8920fecb46c7ab48c8339870cf68b8f6b06cdc0a51d6dd602e3ebd8878006ca2b8c816e99cc0530d523bc5fdae7573676ab1516578b70466d77a4a9b170ac7b8a94e98bf5c29ef94a151325de6f70fc49a16eaaa94290b94f243c4e9fd1563b4dea08d23be71ff630baa55d1ab9c1e61ebcec6ebfd9fedbb5748f1c0df99914334b4b8a5cb035e6f7f748d11924223ec92995cd876aef9eb81fa830bd43cdbcdc79795a1426cf78e1753c1f5c12c457ccb2701a340a0205f32ed8e9bb5aecdb203ecc96fbe4bc8a4d231f4c92e77a542614a7200d79474f5bb5b6bb021f1b4d52f04987011c05630941e7f5ea4b0de3ba398c0aa14fdc3af5ff09ff655c906d6affad5aec84b51a86a5df9b2a01ae73c0f53bb69bd75655a8b6bf0f38c0e3d6ebaaafc1085dd7eb067aaa7f2162d748b1acdd7829a4311c21d81a1db7954c9c9b1fe88e294c6888116dc94ae3c1a7a7982d9e81194a0c9f95a1c0c22288e81590af3768121b1472e97ea086a14eb4b2c397acb4f35f7c7beea60b1f6a302ce24ceab8bb497e9292b3947b642192e347a909f2846c80db77253f2309fde96a2ff36eb045eac1041a3fadff080ff2a85c407ad136cce44e31bc0b36cda770da1fce23ef91ed8433abcd4dfdc729dabdbde745ca3ce81f4b704ad5fd7f7a17cb2224cf43ad3f8012dbfddbdb1aadecd38bdcf1697e55670218f20e01f1177ec0949e0932e224cbe70aa768f681dbaa6a6735cd673da53d2d044e8b48e7a6032844a4b2a0658e69d7ae37356e75281685a6192383167b47040a8edbf21b7e28837dd871c4cea97a3c131ad2b56350d9be89731079a1052bc0ef0f38918a1dab81583834c8b2bcc46319c83193ce638973b71096258b9deee6653aac4497f32ff86bd8a2c225becdba3a67c4eb1715d3395c48582f8c1c9b5faa703de7cfeb522a713fa464ecb2c35637b02aadfd47f6b326a72b4d3b5cfeebfa65eb34cfb2136a20a6000e3f2625ddb858c9fc804b6b8766e4da3d08d1cc92246366c0fe676203649be1d92ce741c8d774b407bd1cb48e683b37ffa14d744dc6c1a2048614c35c5f0da060b82a0e6829d29a6391db0b0119d35fce4658b6c3ab228ec599e29abcb17d66e49ab9931718455f4c34a8c904e651c2c6fb6a07245d779648a0d3fb79305b0ca0b146c9634e063fb1b6afa86bba3a5eff55dfef51a7eda40009b89e944b5f305da11a8fc98e9fc12f36fd1d7e2d7d9826746fbedefd2be04437ac308ad5f2ddbf10a7b3dd3f5fb8191b618e4d5bbca15fbd6965121ac9d3cc38e49533d0c6dd22ef8e4d28be058ebbf8cf6ba58e53923317d3e03d23b14608a267f8e988731bced645ada20563aa2a6e2f971d94c9c44eecd538d7b0c5ce144d5254c19c148f28e8fe729a14929ccda3ffb81b13d3ad8f23539e2aa10d320e579c67fb320b61032b2a241278f3ce1d329d586998d45260166a3a0286f80c677fe335db5a3446527871b419f9d98e0197ad84634b6ebb3ce90fc1cd0f15fa21a702233c4ff57e8f829c081761c4dc841d79a1b1f52acd393e072ce49569fb537b6b5f8bb7cf7ba91aaba646421bf1346f2a8090f7483df8b09cfe322e2ea987994da700a94d44613a21472dab02964e81ec568a4b96288fb5cbeedc3ef7ea5532560963f7adb273d8d1e9874c9fd6f9bc1efaab2824a1798c9b8174763d79fc11a2feefdf3ed6c1b8d05ce5374fdd77e31b6d6d3b8514c4e2cfcd570ee3f07dfce6449ad794f005e07b98bc12bae989bc237c3df3187be9ad0516e14ba0daa7da4d1d8b63474e1dad1c441546298bd3de218d7bc9a7d12f538199f349d9e53749510e8e02b912359ec19a906bcbfcf02c0ff50c44b9a275e994453dfac56bf8c237e86e74e5427b2e05701844e664c47557a383ec5c4831d58740e0d28e044843878ecc38c9b5784466bcac0af54de7f4c5fc776f44f709599af53206690ddbaed0216de79ea127c711fbd39c877f001378185c08772038071a4e2ea50beb76760988fd15f6d16520a22a6dfe55b5d5c6dcef996201f45248a743feedeaae71818d18ab94d52e758008546224e51da8a3727ed573a7c6d0421376279bcfc71e05a300c894c0c828f21d1686d0638320815ba553b67fccbb64b5a9bf722f510555a5fbd3a4694a09ed7469e0f9e2123b4b57fba11230cc3294e9c76ec8e8fb56593ad391908e06c528d77994d3fa01ee8f6c058e8104778f25bffdd9c505c267951fdda1aa69baef2c767271b1a8448a930ba8581258d3c603ead980ea71a0232b7d1063be47405cfafe4f6a415e8b0e29862b5538d543c29c4c2c548e414363f6a5e8d0e3ad93f577cc94fee1b8ec3fd33c4151cac7a3823c9f1a7ae7aa472d03c11eb5b046fdf06bdfa55430acdb56f91454279a9ad85210aca58476da73342f2173924e10a43ac5d8e9583a2b832e93934403f3e4a518ddf08340495e4a33bd972118734b35b284f55caa0302ef82f65b28b31668664dc3153952acfe78d8d4ffce833bbf706e128e2d30c423c1dc28d664b3bc2699e6a9b1b7c2b1b00de05e751c41aa1e824045764a2de4583641382baafac8b52cf0ca16d2eb3cc87e6d5eb486ed5a2ad67a45b4ba4b8ee81f16778fbcaf66a060681c0cb866b292b190afc519162216c43270fafdb6f9ed70c4f55eef576cbb32f11cb3b462b6d0bec818a2bc079ea991dfb08a017c664ee25a70588abbb476bb849425fdb7e761959a3a373f0e65a208e92d14a4f6e2f77d9de521467c37f73529ab46c2b03d7575d0b19db038cc7f2ef1e4157a480e3076a4d1c73ade48bd1f743a0984e0a59ec2603cb03fed6148d9262beb2a75cc7ad51f39ba3ff95194e908d85ccec31dd74b74138a425c1fdc2be38b43a1413a32ea02ba711620a85d4ff4f74223811d702c70c3afe8ecedb1542420ce3d7fe79518988daf69000839d242e5bf4ac652d3d635a01f05a34d87d9394a46426e66ba5f89fb70faf1670cdc100868c8a46c013582e8bbddec7bd275d95af2acc297b739081bafd3cf3f557f83010028ebc4ed0cc503741e752850d1ab6fd3ae37e4e15fba12e710eb43eb2837ac7992e0ccaccd9c224ab0fd1909d557c5650bbcc5e477979382702ba3e567f995aa89c96c7ce1310775cfa6d153ad6c4858245e95300bd50c7f115faa9d59c4f952aeb422a759f468a4408ac3e35fec322df22a4a23d594245f9dce8d185f06dd1a03e848be413d6d0a9999b94e33cc53f112802b614dbbc19c614626d2af93e086c6a21e696c15f7384599f4667dc4b445621c4c3ef524482b80be57e1221a08c3bf51ac8643ee72c60b1df4dcaef4860a897fa30c930d20f6885447edd261d225d264df8cda05400df5f1ed755ad8b2f15cc980671b20a0d28a73596c7e8861de93e17583d6c1179a88a16fcc4c4acb1423305d6277d328aceb2185abae18b90a401a6587cf5f74cf9b2ef6a5ce021578766eb212959a3c2418fbf3a7d819a1bbce02ed941d43a3a970a712aae99e37133daf3c6c7166f2867ba28e4c448e5009245fb413a119e8a055d1978ecfd88</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-xray">
      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好，这里需要密码。</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>项目</category>
        <category>确定性网络</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>确定性网络</tag>
        <tag>CSQF</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法之哈希表实现</title>
    <url>/posts/231227190828.html</url>
    <content><![CDATA[<p>本文实现一个简单的哈希表（散列表），包括常见的初始化创建表、查询操作、添加键值对、删除键值对和销毁哈希表等操作。在本次实现中，哈希桶使用双向链表数据结构。</p>
<span id="more"></span>

<h1 id="哈希表实现"><a href="# 哈希表实现" class="headerlink" title="哈希表实现"></a>哈希表实现 </h1><p> 首先，先抛出本次实现的哈希表的数据结构关系图，其中包括哈希表头结构、哈希表结构、双向链表头结构、双向链表结构、哈希节点结构、哈希桶结构、数据节点结构等。</p>
<img src="../images/data-structure/hash-table-struct.png" alt="哈希表结构" width="100%" height="100%">

<blockquote>
<p>图中，虚线箭头表示结构体使用了 <code>typedef</code> 起别名。</p>
</blockquote>
<h2 id="哈希表结构定义"><a href="# 哈希表结构定义" class="headerlink" title="哈希表结构定义"></a>哈希表结构定义 </h2><h3 id="双向链表结构"><a href="# 双向链表结构" class="headerlink" title="双向链表结构"></a> 双向链表结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双向链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagDL_NODE</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagDL_NODE</span> *<span class="title">pstNext</span>;</span> <span class="comment">// A pointer to the next element</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagDL_NODE</span> *<span class="title">pstPrev</span>;</span> <span class="comment">// A pointer to the prev element</span></span><br><span class="line">&#125; DL_NODE_S;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表头节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagDL_HEAD</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size; <span class="comment">// the element numbers in the double-linked</span></span><br><span class="line">    DL_NODE_S *pstFirst; <span class="comment">// the first element in the double-linked</span></span><br><span class="line">&#125; DL_HEAD_S;</span><br></pre></td></tr></table></figure>

<h3 id="哈希节点结构"><a href="# 哈希节点结构" class="headerlink" title="哈希节点结构"></a>哈希节点结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 哈希节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> DL_NODE_S HASH_NODE_S;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希桶头节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> DL_HEAD_S HASH_LIST_S;</span><br></pre></td></tr></table></figure>

<h3 id="哈希表结构"><a href="# 哈希表结构" class="headerlink" title="哈希表结构"></a>哈希表结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HASH_BUCKET_SIZE (10000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagHASH_TABLE</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulSize;</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*pfHash)</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *)</span>;</span><br><span class="line">    HASH_LIST_S *pstBucket; <span class="comment">// 每个哈希桶中始终存储着双向链表的头节点</span></span><br><span class="line">&#125; HASH_TABLE_S;</span><br></pre></td></tr></table></figure>

<h3 id="哈希表头结构"><a href="# 哈希表头结构" class="headerlink" title="哈希表头结构"></a>哈希表头结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 哈希表状态枚举结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">tagTL_STATE</span> &#123;</span></span><br><span class="line">    TBL_INITED,</span><br><span class="line">    TBL_USING</span><br><span class="line">&#125; TL_STATE_E;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表头节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagHASH_HEAD</span> &#123;</span></span><br><span class="line">    HASH_TABLE_S *pstTable;</span><br><span class="line">    <span class="comment">/* 其它成员，如哈希表创建时间、哈希表状态、锁等 */</span></span><br><span class="line">    TL_STATE_E eTblState;</span><br><span class="line">&#125; HASH_HEAD_S;</span><br></pre></td></tr></table></figure>

<h2 id="数据节点结构"><a href="# 数据节点结构" class="headerlink" title="数据节点结构"></a>数据节点结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagDATA</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 哈希节点，不可少，且要作为首位成员 */</span></span><br><span class="line">    HASH_NODE_S stHashNode;</span><br><span class="line">    <span class="comment">/* hash key */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> identifier;</span><br><span class="line">    <span class="type">char</span> age;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="comment">/* hash payload */</span></span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">&#125; DATA_S;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>数据节点结构的首位成员必须是 <code>HASH_NODE_S</code> 哈希节点（双链表节点）</strong>。这是因为，后续需要将 <code>DATA_S</code> 结构强转成 <code>HASH_NODE_S</code> 结构，并修改其 <code>pstNext</code> 和 <code>pstPrev</code> 指针，将「数据」地址存储在哈希表中。若不是首位成员，会把「数据」成员修改，造成数据错误。</p>
<p>首位成员必须是 <code>HASH_NODE_S</code> 哈希节点，使得哈希桶中仅存储了数据的首地址，而不会过多的存储数据信息。其次，这样设计，使得数据节点结构可以包含任何你想要的信息，而无需修改哈希表的各个函数接口。</p>
</blockquote>
<h2 id="哈希函数"><a href="# 哈希函数" class="headerlink" title="哈希函数"></a>哈希函数 </h2><p> 哈希函数的作用是将一个较大的输入空间映射到一个较小的输出空间。在哈希表中，输入空间是所有 <code>key</code>，输出空间是所有桶（数组索引）。换句话说，输入一个 <code>key</code>，我们可以通过哈希函数得到该 <code>key</code> 对应的键值对在数组中的存储位置。哈希函数应尽可能保证映射后的输出空间尽可能均匀、分散，以减少哈希冲突的发生。</p>
<p>在这里，我们简单地使用 <code>DATA_S</code> 节点的 <code>identifier</code> 模上哈希桶大小，作为哈希函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">hashFunc</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *pKey)</span> &#123;</span><br><span class="line">    <span class="type">const</span> DATA_S *pstKey = (<span class="type">const</span> DATA_S *)pKey;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstKey) &#123;</span><br><span class="line">        err(<span class="string">&quot;hashFunc(): null pointer\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">long</span>)(pstKey-&gt;identifier % HASH_BUCKET_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="哈希键比较函数"><a href="# 哈希键比较函数" class="headerlink" title="哈希键比较函数"></a>哈希键比较函数 </h2><p> 对于哈希表中的节点，在查询和删除操作时，需要将哈希表中遍历的节点的 key 与给定的数据的 key 进行比较，匹配成功返回 <code>0</code>，否则返回 <code>-1</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">hashKeyCmp</span><span class="params">(<span class="type">const</span> HASH_NODE_S *pstHashNode, <span class="type">const</span> <span class="type">void</span> *pKey)</span> &#123;</span><br><span class="line">    <span class="type">const</span> DATA_S *pstNode = (<span class="type">const</span> DATA_S *)pstHashNode;</span><br><span class="line">    <span class="type">const</span> DATA_S *pstKey = (<span class="type">const</span> DATA_S *)pKey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstNode || <span class="literal">NULL</span> == pstKey) &#123;</span><br><span class="line">        err(<span class="string">&quot;hashKeyCmp(): null pointer\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pstNode-&gt;identifier != pstKey-&gt;identifier || \</span><br><span class="line">        pstNode-&gt;age != pstKey-&gt;age || <span class="built_in">strcmp</span>(pstNode-&gt;name, pstKey-&gt;name) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双向链表节点删除函数"><a href="# 双向链表节点删除函数" class="headerlink" title="双向链表节点删除函数"></a>双向链表节点删除函数 </h2><p> 当需要删除哈希表中的节点时，需要从双向链表中移除指定的节点 <code>pstNode</code>：</p>
<ul>
<li>若 <code>pstNode</code> 不是头节点，则删除节点，并正确处理前、后节点的指向关系。</li>
<li>若 <code>pstNode</code> 是头节点，则删除节点、<strong>重新指定头节点为链表中的下一个节点</strong>，并正确处理前、后节点的指向关系。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">dlNodeDel</span><span class="params">(DL_HEAD_S *pstHead, DL_NODE_S *pstNode)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstNode || <span class="literal">NULL</span> == pstHead) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 前一个节点不为空，则 pstNode 不是头结点 */</span></span><br><span class="line">    <span class="keyword">if</span> (pstNode-&gt;pstPrev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 将前一个节点的下一个节点指针指向当前节点的下一个节点</span></span><br><span class="line">        pstNode-&gt;pstPrev-&gt;pstNext = pstNode-&gt;pstNext;</span><br><span class="line">        <span class="keyword">if</span> (pstNode-&gt;pstNext != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 将下一个节点的前一个节点指针指向当前节点的前一个节点</span></span><br><span class="line">            pstNode-&gt;pstNext-&gt;pstPrev = pstNode-&gt;pstPrev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 更新头节点为下一个节点，并将其上一个节点指向 NULL */</span></span><br><span class="line">        pstHead-&gt;pstFirst = pstNode-&gt;pstNext;</span><br><span class="line">        <span class="keyword">if</span> (pstNode-&gt;pstNext != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pstNode-&gt;pstNext-&gt;pstPrev = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pstHead-&gt;size--;  <span class="comment">// 删除节点后，更新节点数量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，这里仅仅是从双向链表中移除指定的节点，并没有释放对应的内存空间。</p>
</blockquote>
<h2 id="哈希表创建与初始化操作"><a href="# 哈希表创建与初始化操作" class="headerlink" title="哈希表创建与初始化操作"></a>哈希表创建与初始化操作 </h2><p> 哈希表创建主要包括申请哈希表本身的空间（即哈希表大小、哈希函数和哈希桶地址空间），以及为每个哈希桶位置分配双向链表头节点空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HASH_TABLE_S *<span class="title function_">hashCreate</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> size, <span class="type">unsigned</span> <span class="type">long</span> (*pfHash)(<span class="type">const</span> <span class="type">void</span> *))</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        err(<span class="string">&quot;hashCreate(): hash bucket size should be large zero\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HASH_TABLE_S *pstTable = (HASH_TABLE_S *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HASH_TABLE_S));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstTable) &#123;</span><br><span class="line">        err(<span class="string">&quot;hashCreate(): Could not allocate memory for hash table\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HASH_LIST_S *pstBucket = (HASH_LIST_S *)<span class="built_in">malloc</span>((size + <span class="number">1</span>) * <span class="keyword">sizeof</span>(HASH_LIST_S));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstBucket) &#123;</span><br><span class="line">        <span class="built_in">free</span>(pstTable);</span><br><span class="line">        err(<span class="string">&quot;hashCreate(): Could not allocate memory for hash bucket\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(pstBucket, <span class="number">0</span>, (size + <span class="number">1</span>) * <span class="keyword">sizeof</span>(HASH_LIST_S));</span><br><span class="line"></span><br><span class="line">    pstTable-&gt;ulSize = (size + <span class="number">1</span>);</span><br><span class="line">    pstTable-&gt;pfHash = pfHash;</span><br><span class="line">    pstTable-&gt;pstBucket = pstBucket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pstTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="哈希表添加操作"><a href="# 哈希表添加操作" class="headerlink" title="哈希表添加操作"></a>哈希表添加操作 </h2><p> 哈希表的添加键值对操作的过程为：</p>
<ol>
<li>各个指针地址为空判断；</li>
<li>通过哈希函数获取给定键的哈希索引；</li>
<li>通过哈希索引，获取对应的哈希桶；</li>
<li>在哈希桶的头节点前插入新增的节点，并更新头结点。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hashAdd</span><span class="params">(HASH_TABLE_S *pstTable, HASH_NODE_S *pstNode)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstTable || <span class="literal">NULL</span> == pstNode || <span class="literal">NULL</span> == pstTable-&gt;pfHash) &#123;</span><br><span class="line">        err(<span class="string">&quot;hashAdd(): null pointer\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 通过哈希函数获取指定桶的地址 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulIndex = pstTable-&gt;pfHash((<span class="type">const</span> <span class="type">void</span> *)pstNode);</span><br><span class="line">    DL_HEAD_S *pstBucket = (DL_HEAD_S *)(&amp;pstTable-&gt;pstBucket[ulIndex]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstBucket) &#123;</span><br><span class="line">        err(<span class="string">&quot;hashAdd(): null pointer of hash bucket head\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在头节点前插入节点 */</span></span><br><span class="line">    pstNode-&gt;pstPrev = <span class="literal">NULL</span>; <span class="comment">// 新节点的 prev 指向 NULL</span></span><br><span class="line">    pstNode-&gt;pstNext = pstBucket-&gt;pstFirst; <span class="comment">// 新节点的 next 指向头结点</span></span><br><span class="line">    <span class="keyword">if</span> (pstBucket-&gt;pstFirst != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pstBucket-&gt;pstFirst-&gt;pstPrev = pstNode; <span class="comment">// 原头结点的 prev 指向新节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新头节点为插入的节点，并更新 DL 节点数量 */</span></span><br><span class="line">    pstBucket-&gt;pstFirst = pstNode; </span><br><span class="line">    pstBucket-&gt;size++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，该 <strong> 哈希表添加操作并不会判断节点是否存在于对应的桶中，而是直接执行节点添加操作</strong>。用户在使用时，需要先检查节点是否存在，不存在才能执行添加操作。</p>
</blockquote>
<h2 id="哈希表查询操作"><a href="# 哈希表查询操作" class="headerlink" title="哈希表查询操作"></a>哈希表查询操作 </h2><p> 哈希表的查询键值对操作的过程为：</p>
<ol>
<li>各个指针地址为空判断；</li>
<li>通过哈希函数获取给定键的哈希索引；</li>
<li>通过哈希索引，获取对应的哈希桶；</li>
<li>获取哈希桶的头节点（双向链表的头节点）地址；</li>
<li>遍历双向链表中的每一个节点，并使用哈希比较函数与给定的键做比较：<ul>
<li>若匹配成功，则返回哈希节点的地址；</li>
<li>若匹配失败，则继续向后遍历。</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HASH_NODE_S *<span class="title function_">hashFind</span><span class="params">(HASH_TABLE_S *pstTable, <span class="type">const</span> <span class="type">void</span> *pKey, <span class="type">long</span> (*pfKeyCmp)(<span class="type">const</span> HASH_NODE_S *, <span class="type">const</span> <span class="type">void</span> *))</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstTable || <span class="literal">NULL</span> == pKey || <span class="literal">NULL</span> == pfKeyCmp || <span class="literal">NULL</span> == pstTable-&gt;pfHash) &#123;</span><br><span class="line">        err(<span class="string">&quot;hashFind(): null pointer\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 通过哈希函数获取指定桶的地址 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulIndex = pstTable-&gt;pfHash(pKey);</span><br><span class="line">    DL_HEAD_S *pstBucket = (DL_HEAD_S *)(&amp;pstTable-&gt;pstBucket[ulIndex]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstBucket) &#123;</span><br><span class="line">        err(<span class="string">&quot;hashFind(): null pointer of hash bucket head\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这里遍历链表需要 O(N)时间，可考虑优化为红黑树，使得时间为 O(logN) */</span></span><br><span class="line">    DL_NODE_S *pstNode = pstBucket-&gt;pstFirst;</span><br><span class="line">    <span class="keyword">while</span> (pstNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pfKeyCmp(pstNode, pKey) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pstNode;</span><br><span class="line">        &#125;</span><br><span class="line">        pstNode = pstNode-&gt;pstNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="哈希表删除操作"><a href="# 哈希表删除操作" class="headerlink" title="哈希表删除操作"></a>哈希表删除操作 </h2><p> 哈希表的删除键值对操作的过程为：</p>
<ol>
<li>各个指针地址为空判断；</li>
<li>通过哈希函数获取给定键的哈希索引；</li>
<li>通过哈希索引，获取对应的哈希桶；</li>
<li>获取哈希桶的头节点（双向链表的头节点）地址；</li>
<li>遍历双向链表中的每一个节点，并使用哈希比较函数与给定的键做比较：<ul>
<li>若匹配成功，则从双向链表中删除该节点；</li>
<li>若匹配失败，则继续向后遍历。</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hashDel</span><span class="params">(HASH_TABLE_S *pstTable, <span class="type">const</span> <span class="type">void</span> *pKey, <span class="type">long</span> (*pfKeyCmp)(<span class="type">const</span> HASH_NODE_S *, <span class="type">const</span> <span class="type">void</span> *))</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstTable || <span class="literal">NULL</span> == pKey || <span class="literal">NULL</span> == pfKeyCmp || <span class="literal">NULL</span> == pstTable-&gt;pfHash) &#123;</span><br><span class="line">        err(<span class="string">&quot;hashDel(): null pointer\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 通过哈希函数获取指定桶的地址 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulIndex = pstTable-&gt;pfHash(pKey);</span><br><span class="line">    DL_HEAD_S *pstBucket = (DL_HEAD_S *)(&amp;pstTable-&gt;pstBucket[ulIndex]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstBucket) &#123;</span><br><span class="line">        err(<span class="string">&quot;hashDel(): null pointer of hash bucket head\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这里遍历链表需要 O(N)时间，可考虑优化为红黑树，使得时间为 O(logN) */</span></span><br><span class="line">    DL_NODE_S *pstNode = pstBucket-&gt;pstFirst;</span><br><span class="line">    <span class="keyword">while</span> (pstNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pfKeyCmp(pstNode, pKey) == <span class="number">0</span>) &#123;</span><br><span class="line">            dlNodeDel((DL_HEAD_S *)pstBucket, (DL_NODE_S *)pstNode);</span><br><span class="line">            <span class="comment">/* 从哈希桶中移除 DL 节点，但不释放数据，它由用户决定 */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pstNode = pstNode-&gt;pstNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>哈希表删除节点操作，只会将节点从双向链表中移除，但 <strong> 不会释放对应的内存空间（释放或不释放节点的内存空间由用户决定）</strong>。</p>
</blockquote>
<h2 id="哈希表遍历打印操作"><a href="# 哈希表遍历打印操作" class="headerlink" title="哈希表遍历打印操作"></a>哈希表遍历打印操作 </h2><p> 哈希表的打印键值对操作的过程为：</p>
<ol>
<li>各个指针地址为空判断；</li>
<li>遍历哈希表中的每一个哈希桶：<ul>
<li>获取哈希桶的头节点（双向链表的头节点）地址；</li>
<li>遍历双向链表中的每一个节点，并打印数据内容。</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因不同数据的结构不同，这里使用宏定义定义指定节点的打印内容</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATA_PRINT_INFO(bucketId, pstNode) \</span></span><br><span class="line"><span class="meta">    do &#123; \</span></span><br><span class="line"><span class="meta">        DATA_S *pstData = (DATA_S *)(pstNode); \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">&quot;    bucket id = %lu, .identifier = %lu, .age = %d, .name = %s, .height = %dcm\n&quot;</span>, \</span></span><br><span class="line"><span class="meta">                (bucketId), pstData-&gt;identifier, pstData-&gt;age, pstData-&gt;name, pstData-&gt;height); \</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hashPrint</span><span class="params">(HASH_TABLE_S *pstTable)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstTable) &#123;</span><br><span class="line">        err(<span class="string">&quot;hashPrint(): null pointer\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 遍历哈希表中的每一个哈希桶的所有节点，并对节点执行特定操作 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; pstTable-&gt;ulSize; i++) &#123;</span><br><span class="line">        DL_HEAD_S *pstBucket = (DL_HEAD_S *)(&amp;pstTable-&gt;pstBucket[i]);</span><br><span class="line">        <span class="keyword">if</span> (pstBucket != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            DL_NODE_S *pstNode = pstBucket-&gt;pstFirst;</span><br><span class="line">            <span class="keyword">if</span> (pstBucket-&gt;size &gt; <span class="number">0</span> &amp;&amp; pstNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;No.%lu hash bucket has %lu nodes\n&quot;</span>, i, pstBucket-&gt;size);</span><br><span class="line">                <span class="keyword">while</span> (pstNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    DATA_PRINT_INFO(i, pstNode); <span class="comment">// 打印的内容</span></span><br><span class="line">                    pstNode = pstNode-&gt;pstNext;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="哈希表销毁操作"><a href="# 哈希表销毁操作" class="headerlink" title="哈希表销毁操作"></a>哈希表销毁操作 </h2><p> 哈希表的销毁所有键值对操作的过程为：</p>
<ol>
<li>各个指针地址为空判断；</li>
<li>遍历哈希表中的每一个哈希桶：<ul>
<li>获取哈希桶的头节点（双向链表的头节点）地址；</li>
<li>遍历双向链表中的每一个节点，从哈希表中移除节点，并释放对应的内存空间（可选）。</li>
</ul>
</li>
<li>释放所有哈希桶的内存空间，并释放哈希表内存空间。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 销毁操作是否释放数据的内存空间？这里定义了一个删除并释放的宏（用户可自行设计这个宏）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH_NODE_DEL_FREE(pstBucket, pstDelNode, bFree) \</span></span><br><span class="line"><span class="meta">    do &#123; \</span></span><br><span class="line"><span class="meta">        dlNodeDel((DL_HEAD_S *)(pstBucket), (DL_NODE_S *)(pstDelNode)); \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> ((bFree) &amp;&amp; (pstDelNode) != NULL) &#123; \</span></span><br><span class="line"><span class="meta">            free((DATA_S *)(pstDelNode)); \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hashDestroy</span><span class="params">(HASH_TABLE_S *pstTable, <span class="type">bool</span> bFree)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstTable) &#123;</span><br><span class="line">        err(<span class="string">&quot;hashDestroy(): null pointer\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 遍历哈希表中的每一个哈希桶的所有节点，并对节点执行特定操作 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; pstTable-&gt;ulSize; i++) &#123;</span><br><span class="line">        DL_HEAD_S *pstBucket = (DL_HEAD_S *)(&amp;pstTable-&gt;pstBucket[i]);</span><br><span class="line">        <span class="keyword">if</span> (pstBucket != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            DL_NODE_S *pstNode = pstBucket-&gt;pstFirst;</span><br><span class="line">            <span class="keyword">while</span> (pstNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                DL_NODE_S *pstDelNode = pstNode;</span><br><span class="line">                pstNode = pstNode-&gt;pstNext;</span><br><span class="line">                HASH_NODE_DEL_FREE(pstBucket, pstDelNode, bFree); <span class="comment">// 删除节点，按需释放数据内存</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(pstTable-&gt;pstBucket);</span><br><span class="line">    <span class="built_in">free</span>(pstTable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="哈希表测试"><a href="# 哈希表测试" class="headerlink" title="哈希表测试"></a>哈希表测试 </h1><h2 id="测试代码"><a href="# 测试代码" class="headerlink" title="测试代码"></a> 测试代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> err(str) fprintf(stderr, str)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    assert(HASH_BUCKET_SIZE &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    HASH_HEAD_S *hashHead = (HASH_HEAD_S *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HASH_HEAD_S));</span><br><span class="line">    assert(hashHead != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    hashHead-&gt;pstTable = hashCreate(HASH_BUCKET_SIZE, hashFunc);</span><br><span class="line">    hashHead-&gt;eTblState = TBL_USING;</span><br><span class="line">    assert(hashHead-&gt;pstTable != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    HASH_TABLE_S *pstTable = hashHead-&gt;pstTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建测试数据 */</span></span><br><span class="line">    DATA_S dataList[] = &#123;</span><br><span class="line">        &#123;.stHashNode = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">        .identifier = <span class="number">1</span>,</span><br><span class="line">        .age = <span class="number">18</span>,</span><br><span class="line">        .name = <span class="string">&quot;Bob&quot;</span>,</span><br><span class="line">        .height = <span class="number">178</span>&#125;,</span><br><span class="line">        &#123;.stHashNode = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">        .identifier = <span class="number">2</span>,</span><br><span class="line">        .age = <span class="number">20</span>,</span><br><span class="line">        .name = <span class="string">&quot;John&quot;</span>,</span><br><span class="line">        .height = <span class="number">181</span>&#125;,</span><br><span class="line">        &#123;.stHashNode = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">        .identifier = <span class="number">3</span>,</span><br><span class="line">        .age = <span class="number">18</span>,</span><br><span class="line">        .name = <span class="string">&quot;LiHua&quot;</span>,</span><br><span class="line">        .height = <span class="number">176</span>&#125;,</span><br><span class="line">        &#123;.stHashNode = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">        .identifier = <span class="number">2</span>,</span><br><span class="line">        .age = <span class="number">22</span>,</span><br><span class="line">        .name = <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">        .height = <span class="number">168</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> dataSize = <span class="keyword">sizeof</span>(dataList) / <span class="keyword">sizeof</span>(dataList[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    DATA_S **nodeList = (DATA_S **)<span class="built_in">malloc</span>(dataSize * <span class="keyword">sizeof</span>(DATA_S *));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加节点，无法确定节点是否重复时，应先执行查找操作 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dataSize; i++) &#123;</span><br><span class="line">        nodeList[i] = (DATA_S *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DATA_S));</span><br><span class="line">        <span class="built_in">memcpy</span>(nodeList[i], &amp;dataList[i], <span class="keyword">sizeof</span>(DATA_S));</span><br><span class="line">        <span class="comment">// 因 DATA_S 的靠前的成员，正好为 HASH_NODE_S 的所有成员；因此，强转 DATA_S，不会修改其它成员的信息</span></span><br><span class="line">        hashAdd(pstTable, (HASH_NODE_S *)nodeList[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印哈希表中的所有节点 */</span></span><br><span class="line">    hashPrint(pstTable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建查找数据 */</span></span><br><span class="line">    DATA_S keyList[] = &#123;</span><br><span class="line">        &#123;.stHashNode = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">        .identifier = <span class="number">3</span>,</span><br><span class="line">        .age = <span class="number">18</span>,</span><br><span class="line">        .name = <span class="string">&quot;LiHua&quot;</span>,</span><br><span class="line">        .height = <span class="number">176</span>&#125;,</span><br><span class="line">        &#123;.stHashNode = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">        .identifier = <span class="number">2</span>,</span><br><span class="line">        .age = <span class="number">22</span>,</span><br><span class="line">        .name = <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">        .height = <span class="number">168</span>&#125;,</span><br><span class="line">        &#123;.stHashNode = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">        .identifier = <span class="number">2</span>,</span><br><span class="line">        .age = <span class="number">22</span>,</span><br><span class="line">        .name = <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">        .height = <span class="number">168</span>&#125;,</span><br><span class="line">        &#123;.stHashNode = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">        .identifier = <span class="number">2</span>,</span><br><span class="line">        .age = <span class="number">20</span>,</span><br><span class="line">        .name = <span class="string">&quot;John&quot;</span>,</span><br><span class="line">        .height = <span class="number">181</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> keySize = <span class="keyword">sizeof</span>(keyList) / <span class="keyword">sizeof</span>(keyList[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    DATA_S *retNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查找节点 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; keySize; i++) &#123;</span><br><span class="line">        retNode = (DATA_S *)hashFind(pstTable, (<span class="type">const</span> <span class="type">void</span> *)&amp;keyList[i], hashKeyCmp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (retNode != <span class="literal">NULL</span>) &#123; <span class="comment">// 查找成功</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Found data: \n&quot;</span>);</span><br><span class="line">            DATA_PRINT_INFO(hashFunc(retNode), retNode);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 删除节点，并由用户手动释放数据空间 */</span></span><br><span class="line">            hashDel(pstTable, (<span class="type">const</span> <span class="type">void</span> *)retNode, hashKeyCmp);</span><br><span class="line">            <span class="comment">// free(retNode);  // note1</span></span><br><span class="line">            retNode = <span class="literal">NULL</span>; <span class="comment">// 因后续还要使用变量，这里释放后手动置 NULL</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 再次查找节点 */</span></span><br><span class="line">            retNode = (DATA_S *)hashFind(pstTable, (<span class="type">const</span> <span class="type">void</span> *)&amp;keyList[i], hashKeyCmp);</span><br><span class="line">            <span class="keyword">if</span> (retNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Data delete failed\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Data delete successful\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Data not found\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hashPrint(pstTable);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 销毁哈希表，并释放数据空间 */</span></span><br><span class="line">    hashDestroy(pstTable, <span class="literal">true</span>);  <span class="comment">// note2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; dataSize; i++) &#123;</span></span><br><span class="line"><span class="comment">        free(nodeList[i]);  // note3</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">free</span>(nodeList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：note1~3 选择一处释放即可，否则会出现重复释放，报错 <code>free(): double free detected in tcache 2</code>。</p>
<h2 id="测试结果"><a href="# 测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">No.1 hash bucket has 1 nodes</span><br><span class="line">    bucket id = 1, .identifier = 1, .age = 18, .name = Bob, .height = 178cm</span><br><span class="line">No.2 hash bucket has 2 nodes</span><br><span class="line">    bucket id = 2, .identifier = 2, .age = 22, .name = Alice, .height = 168cm</span><br><span class="line">    bucket id = 2, .identifier = 2, .age = 20, .name = John, .height = 181cm</span><br><span class="line">No.3 hash bucket has 1 nodes</span><br><span class="line">    bucket id = 3, .identifier = 3, .age = 18, .name = LiHua, .height = 176cm</span><br><span class="line">Found data:</span><br><span class="line">    bucket id = 3, .identifier = 3, .age = 18, .name = LiHua, .height = 176cm</span><br><span class="line">Data delete successful</span><br><span class="line">No.1 hash bucket has 1 nodes</span><br><span class="line">    bucket id = 1, .identifier = 1, .age = 18, .name = Bob, .height = 178cm</span><br><span class="line">No.2 hash bucket has 2 nodes</span><br><span class="line">    bucket id = 2, .identifier = 2, .age = 22, .name = Alice, .height = 168cm</span><br><span class="line">    bucket id = 2, .identifier = 2, .age = 20, .name = John, .height = 181cm</span><br><span class="line">Found data:</span><br><span class="line">    bucket id = 2, .identifier = 2, .age = 22, .name = Alice, .height = 168cm</span><br><span class="line">Data delete successful</span><br><span class="line">No.1 hash bucket has 1 nodes</span><br><span class="line">    bucket id = 1, .identifier = 1, .age = 18, .name = Bob, .height = 178cm</span><br><span class="line">No.2 hash bucket has 1 nodes</span><br><span class="line">    bucket id = 2, .identifier = 2, .age = 20, .name = John, .height = 181cm</span><br><span class="line">Data not found</span><br><span class="line">No.1 hash bucket has 1 nodes</span><br><span class="line">    bucket id = 1, .identifier = 1, .age = 18, .name = Bob, .height = 178cm</span><br><span class="line">No.2 hash bucket has 1 nodes</span><br><span class="line">    bucket id = 2, .identifier = 2, .age = 20, .name = John, .height = 181cm</span><br><span class="line">Found data:</span><br><span class="line">    bucket id = 2, .identifier = 2, .age = 20, .name = John, .height = 181cm</span><br><span class="line">Data delete successful</span><br><span class="line">No.1 hash bucket has 1 nodes</span><br><span class="line">    bucket id = 1, .identifier = 1, .age = 18, .name = Bob, .height = 178cm</span><br></pre></td></tr></table></figure>

<h1 id="哈希表实现完整代码"><a href="# 哈希表实现完整代码" class="headerlink" title="哈希表实现完整代码"></a>哈希表实现完整代码</h1><details>
  <summary>哈希表实现完整代码（点击展开）</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该代码未经过完备的测试验证 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> err(str) fprintf(stderr, str)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagDL_NODE</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagDL_NODE</span> *<span class="title">pstNext</span>;</span> <span class="comment">// A pointer to the next element</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagDL_NODE</span> *<span class="title">pstPrev</span>;</span> <span class="comment">// A pointer to the prev element</span></span><br><span class="line">&#125; DL_NODE_S;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表头节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagDL_HEAD</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size; <span class="comment">// the element numbers in the double-linked</span></span><br><span class="line">    DL_NODE_S *pstFirst; <span class="comment">// the first element in the double-linked</span></span><br><span class="line">&#125; DL_HEAD_S;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> DL_HEAD_S HASH_LIST_S;</span><br><span class="line"><span class="keyword">typedef</span> DL_NODE_S HASH_NODE_S;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagHASH_TABLE</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulSize;</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*pfHash)</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *)</span>;</span><br><span class="line">    HASH_LIST_S *pstBucket; <span class="comment">// 哈希桶中始终存储着双向链表的头节点</span></span><br><span class="line">&#125; HASH_TABLE_S;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表状态枚举结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">tagTL_STATE</span> &#123;</span></span><br><span class="line">    TBL_INITED,</span><br><span class="line">    TBL_USING</span><br><span class="line">&#125; TL_STATE_E;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表头节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagHASH_HEAD</span> &#123;</span></span><br><span class="line">    HASH_TABLE_S *pstTable;</span><br><span class="line">    <span class="comment">/* 其它成员，如哈希表创建时间、哈希表状态、锁等 */</span></span><br><span class="line">    TL_STATE_E eTblState;</span><br><span class="line">&#125; HASH_HEAD_S;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagDATA</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 哈希节点，不可少，且要作为首位成员 */</span></span><br><span class="line">    HASH_NODE_S stHashNode;</span><br><span class="line">    <span class="comment">/* hash key */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> identifier;</span><br><span class="line">    <span class="type">char</span> age;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="comment">/* hash payload */</span></span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">&#125; DATA_S;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH_BUCKET_SIZE (10000)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATA_PRINT_INFO(bucketId, pstNode) \</span></span><br><span class="line"><span class="meta">    do &#123; \</span></span><br><span class="line"><span class="meta">        DATA_S *pstData = (DATA_S *)(pstNode); \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">&quot;    bucket id = %lu, .identifier = %lu, .age = %d, .name = %s, .height = %dcm\n&quot;</span>, \</span></span><br><span class="line"><span class="meta">                (bucketId), pstData-&gt;identifier, pstData-&gt;age, pstData-&gt;name, pstData-&gt;height); \</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH_NODE_DEL_FREE(pstBucket, pstDelNode, bFree) \</span></span><br><span class="line"><span class="meta">    do &#123; \</span></span><br><span class="line"><span class="meta">        dlNodeDel((DL_HEAD_S *)(pstBucket), (DL_NODE_S *)(pstDelNode)); \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> ((bFree) &amp;&amp; (pstDelNode) != NULL) &#123; \</span></span><br><span class="line"><span class="meta">            free((DATA_S *)(pstDelNode)); \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">hashFunc</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *pKey)</span> &#123;</span><br><span class="line">    <span class="type">const</span> DATA_S *pstKey = (<span class="type">const</span> DATA_S *)pKey;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstKey) &#123;</span><br><span class="line">        err(<span class="string">&quot;hashFunc(): null pointer\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">long</span>)(pstKey-&gt;identifier % HASH_BUCKET_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">hashKeyCmp</span><span class="params">(<span class="type">const</span> HASH_NODE_S *pstHashNode, <span class="type">const</span> <span class="type">void</span> *pKey)</span> &#123;</span><br><span class="line">    <span class="type">const</span> DATA_S *pstNode = (<span class="type">const</span> DATA_S *)pstHashNode;</span><br><span class="line">    <span class="type">const</span> DATA_S *pstKey = (<span class="type">const</span> DATA_S *)pKey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstNode || <span class="literal">NULL</span> == pstKey) &#123;</span><br><span class="line">        err(<span class="string">&quot;hashKeyCmp(): null pointer\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pstNode-&gt;identifier != pstKey-&gt;identifier || \</span><br><span class="line">        pstNode-&gt;age != pstKey-&gt;age || <span class="built_in">strcmp</span>(pstNode-&gt;name, pstKey-&gt;name) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">dlNodeDel</span><span class="params">(DL_HEAD_S *pstHead, DL_NODE_S *pstNode)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstNode || <span class="literal">NULL</span> == pstHead) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 前一个节点不为空，则 pstNode 不是头结点 */</span></span><br><span class="line">    <span class="keyword">if</span> (pstNode-&gt;pstPrev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 将前一个节点的下一个节点指针指向当前节点的下一个节点</span></span><br><span class="line">        pstNode-&gt;pstPrev-&gt;pstNext = pstNode-&gt;pstNext;</span><br><span class="line">        <span class="keyword">if</span> (pstNode-&gt;pstNext != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 将下一个节点的前一个节点指针指向当前节点的前一个节点</span></span><br><span class="line">            pstNode-&gt;pstNext-&gt;pstPrev = pstNode-&gt;pstPrev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 更新头节点为下一个节点，并将其上一个节点指向 NULL */</span></span><br><span class="line">        pstHead-&gt;pstFirst = pstNode-&gt;pstNext;</span><br><span class="line">        <span class="keyword">if</span> (pstNode-&gt;pstNext != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pstNode-&gt;pstNext-&gt;pstPrev = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pstHead-&gt;size--;  <span class="comment">// 删除节点后，更新节点数量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HASH_TABLE_S *<span class="title function_">hashCreate</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> size, <span class="type">unsigned</span> <span class="type">long</span> (*pfHash)(<span class="type">const</span> <span class="type">void</span> *))</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        err(<span class="string">&quot;hashCreate(): hash bucket size should be large zero\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HASH_TABLE_S *pstTable = (HASH_TABLE_S *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HASH_TABLE_S));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstTable) &#123;</span><br><span class="line">        err(<span class="string">&quot;hashCreate(): Could not allocate memory for hash table\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HASH_LIST_S *pstBucket = (HASH_LIST_S *)<span class="built_in">malloc</span>((size + <span class="number">1</span>) * <span class="keyword">sizeof</span>(HASH_LIST_S));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstBucket) &#123;</span><br><span class="line">        <span class="built_in">free</span>(pstTable);</span><br><span class="line">        err(<span class="string">&quot;hashCreate(): Could not allocate memory for hash bucket\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(pstBucket, <span class="number">0</span>, (size + <span class="number">1</span>) * <span class="keyword">sizeof</span>(HASH_LIST_S));</span><br><span class="line"></span><br><span class="line">    pstTable-&gt;ulSize = (size + <span class="number">1</span>);</span><br><span class="line">    pstTable-&gt;pfHash = pfHash;</span><br><span class="line">    pstTable-&gt;pstBucket = pstBucket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pstTable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hashAdd</span><span class="params">(HASH_TABLE_S *pstTable, HASH_NODE_S *pstNode)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstTable || <span class="literal">NULL</span> == pstNode || <span class="literal">NULL</span> == pstTable-&gt;pfHash) &#123;</span><br><span class="line">        err(<span class="string">&quot;hashAdd(): null pointer\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 通过哈希函数获取指定桶的地址 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulIndex = pstTable-&gt;pfHash((<span class="type">const</span> <span class="type">void</span> *)pstNode);</span><br><span class="line">    DL_HEAD_S *pstBucket = (DL_HEAD_S *)(&amp;pstTable-&gt;pstBucket[ulIndex]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstBucket) &#123;</span><br><span class="line">        err(<span class="string">&quot;hashAdd(): null pointer of hash bucket head\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在头节点前插入节点 */</span></span><br><span class="line">    pstNode-&gt;pstPrev = <span class="literal">NULL</span>; <span class="comment">// 新节点的 prev 指向 NULL</span></span><br><span class="line">    pstNode-&gt;pstNext = pstBucket-&gt;pstFirst; <span class="comment">// 新节点的 next 指向头结点</span></span><br><span class="line">    <span class="keyword">if</span> (pstBucket-&gt;pstFirst != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pstBucket-&gt;pstFirst-&gt;pstPrev = pstNode; <span class="comment">// 原头结点的 prev 指向新节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新头节点为插入的节点，并更新 DL 节点数量 */</span></span><br><span class="line">    pstBucket-&gt;pstFirst = pstNode; </span><br><span class="line">    pstBucket-&gt;size++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HASH_NODE_S *<span class="title function_">hashFind</span><span class="params">(HASH_TABLE_S *pstTable, <span class="type">const</span> <span class="type">void</span> *pKey, <span class="type">long</span> (*pfKeyCmp)(<span class="type">const</span> HASH_NODE_S *, <span class="type">const</span> <span class="type">void</span> *))</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstTable || <span class="literal">NULL</span> == pKey || <span class="literal">NULL</span> == pfKeyCmp || <span class="literal">NULL</span> == pstTable-&gt;pfHash) &#123;</span><br><span class="line">        err(<span class="string">&quot;hashFind(): null pointer\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 通过哈希函数获取指定桶的地址 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulIndex = pstTable-&gt;pfHash(pKey);</span><br><span class="line">    DL_HEAD_S *pstBucket = (DL_HEAD_S *)(&amp;pstTable-&gt;pstBucket[ulIndex]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstBucket) &#123;</span><br><span class="line">        err(<span class="string">&quot;hashFind(): null pointer of hash bucket head\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这里遍历链表需要 O(N) 时间，可考虑优化为红黑树，使得时间为 O(logN) */</span></span><br><span class="line">    DL_NODE_S *pstNode = pstBucket-&gt;pstFirst;</span><br><span class="line">    <span class="keyword">while</span> (pstNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pfKeyCmp(pstNode, pKey) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pstNode;</span><br><span class="line">        &#125;</span><br><span class="line">        pstNode = pstNode-&gt;pstNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hashDel</span><span class="params">(HASH_TABLE_S *pstTable, <span class="type">const</span> <span class="type">void</span> *pKey, <span class="type">long</span> (*pfKeyCmp)(<span class="type">const</span> HASH_NODE_S *, <span class="type">const</span> <span class="type">void</span> *))</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstTable || <span class="literal">NULL</span> == pKey || <span class="literal">NULL</span> == pfKeyCmp || <span class="literal">NULL</span> == pstTable-&gt;pfHash) &#123;</span><br><span class="line">        err(<span class="string">&quot;hashDel(): null pointer\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 通过哈希函数获取指定桶的地址 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulIndex = pstTable-&gt;pfHash(pKey);</span><br><span class="line">    DL_HEAD_S *pstBucket = (DL_HEAD_S *)(&amp;pstTable-&gt;pstBucket[ulIndex]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstBucket) &#123;</span><br><span class="line">        err(<span class="string">&quot;hashDel(): null pointer of hash bucket head\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这里遍历链表需要 O(N)时间，可考虑优化为红黑树，使得时间为 O(logN) */</span></span><br><span class="line">    DL_NODE_S *pstNode = pstBucket-&gt;pstFirst;</span><br><span class="line">    <span class="keyword">while</span> (pstNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pfKeyCmp(pstNode, pKey) == <span class="number">0</span>) &#123;</span><br><span class="line">            dlNodeDel((DL_HEAD_S *)pstBucket, (DL_NODE_S *)pstNode);</span><br><span class="line">            <span class="comment">/* 从哈希桶中移除 DL 节点，但不释放数据，它由用户决定 */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pstNode = pstNode-&gt;pstNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hashPrint</span><span class="params">(HASH_TABLE_S *pstTable)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstTable) &#123;</span><br><span class="line">        err(<span class="string">&quot;hashPrint(): null pointer\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 遍历哈希表中的每一个哈希桶的所有节点，并对节点执行特定操作 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; pstTable-&gt;ulSize; i++) &#123;</span><br><span class="line">        DL_HEAD_S *pstBucket = (DL_HEAD_S *)(&amp;pstTable-&gt;pstBucket[i]);</span><br><span class="line">        <span class="keyword">if</span> (pstBucket != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            DL_NODE_S *pstNode = pstBucket-&gt;pstFirst;</span><br><span class="line">            <span class="keyword">if</span> (pstBucket-&gt;size &gt; <span class="number">0</span> &amp;&amp; pstNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;No.%lu hash bucket has %lu nodes\n&quot;</span>, i, pstBucket-&gt;size);</span><br><span class="line">                <span class="keyword">while</span> (pstNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    DATA_PRINT_INFO(i, pstNode); <span class="comment">// 打印的内容</span></span><br><span class="line">                    pstNode = pstNode-&gt;pstNext;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hashDestroy</span><span class="params">(HASH_TABLE_S *pstTable, <span class="type">bool</span> bFree)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstTable) &#123;</span><br><span class="line">        err(<span class="string">&quot;hashDestroy(): null pointer\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 遍历哈希表中的每一个哈希桶的所有节点，并对节点执行特定操作 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; pstTable-&gt;ulSize; i++) &#123;</span><br><span class="line">        DL_HEAD_S *pstBucket = (DL_HEAD_S *)(&amp;pstTable-&gt;pstBucket[i]);</span><br><span class="line">        <span class="keyword">if</span> (pstBucket != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            DL_NODE_S *pstNode = pstBucket-&gt;pstFirst;</span><br><span class="line">            <span class="keyword">while</span> (pstNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                DL_NODE_S *pstDelNode = pstNode;</span><br><span class="line">                pstNode = pstNode-&gt;pstNext;</span><br><span class="line">                HASH_NODE_DEL_FREE(pstBucket, pstDelNode, bFree); <span class="comment">// 删除节点，按需释放数据内存</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(pstTable-&gt;pstBucket);</span><br><span class="line">    <span class="built_in">free</span>(pstTable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    assert(HASH_BUCKET_SIZE &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    HASH_HEAD_S *hashHead = (HASH_HEAD_S *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HASH_HEAD_S));</span><br><span class="line">    assert(hashHead != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    hashHead-&gt;pstTable = hashCreate(HASH_BUCKET_SIZE, hashFunc);</span><br><span class="line">    hashHead-&gt;eTblState = TBL_USING;</span><br><span class="line">    assert(hashHead-&gt;pstTable != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    HASH_TABLE_S *pstTable = hashHead-&gt;pstTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建测试数据 */</span></span><br><span class="line">    DATA_S dataList[] = &#123;</span><br><span class="line">        &#123;.stHashNode = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">        .identifier = <span class="number">1</span>,</span><br><span class="line">        .age = <span class="number">18</span>,</span><br><span class="line">        .name = <span class="string">&quot;Bob&quot;</span>,</span><br><span class="line">        .height = <span class="number">178</span>&#125;,</span><br><span class="line">        &#123;.stHashNode = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">        .identifier = <span class="number">2</span>,</span><br><span class="line">        .age = <span class="number">20</span>,</span><br><span class="line">        .name = <span class="string">&quot;John&quot;</span>,</span><br><span class="line">        .height = <span class="number">181</span>&#125;,</span><br><span class="line">        &#123;.stHashNode = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">        .identifier = <span class="number">3</span>,</span><br><span class="line">        .age = <span class="number">18</span>,</span><br><span class="line">        .name = <span class="string">&quot;LiHua&quot;</span>,</span><br><span class="line">        .height = <span class="number">176</span>&#125;,</span><br><span class="line">        &#123;.stHashNode = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">        .identifier = <span class="number">2</span>,</span><br><span class="line">        .age = <span class="number">22</span>,</span><br><span class="line">        .name = <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">        .height = <span class="number">168</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> dataSize = <span class="keyword">sizeof</span>(dataList) / <span class="keyword">sizeof</span>(dataList[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    DATA_S **nodeList = (DATA_S **)<span class="built_in">malloc</span>(dataSize * <span class="keyword">sizeof</span>(DATA_S *));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加节点，无法确定节点是否重复时，应先执行查找操作 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dataSize; i++) &#123;</span><br><span class="line">        nodeList[i] = (DATA_S *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DATA_S));</span><br><span class="line">        <span class="built_in">memcpy</span>(nodeList[i], &amp;dataList[i], <span class="keyword">sizeof</span>(DATA_S));</span><br><span class="line">        <span class="comment">// 因 DATA_S 的靠前的成员，正好为 HASH_NODE_S 的所有成员；因此，强转 DATA_S，不会修改其它成员的信息</span></span><br><span class="line">        hashAdd(pstTable, (HASH_NODE_S *)nodeList[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印哈希表中的所有节点 */</span></span><br><span class="line">    hashPrint(pstTable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建查找数据 */</span></span><br><span class="line">    DATA_S keyList[] = &#123;</span><br><span class="line">        &#123;.stHashNode = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">        .identifier = <span class="number">3</span>,</span><br><span class="line">        .age = <span class="number">18</span>,</span><br><span class="line">        .name = <span class="string">&quot;LiHua&quot;</span>,</span><br><span class="line">        .height = <span class="number">176</span>&#125;,</span><br><span class="line">        &#123;.stHashNode = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">        .identifier = <span class="number">2</span>,</span><br><span class="line">        .age = <span class="number">22</span>,</span><br><span class="line">        .name = <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">        .height = <span class="number">168</span>&#125;,</span><br><span class="line">        &#123;.stHashNode = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">        .identifier = <span class="number">2</span>,</span><br><span class="line">        .age = <span class="number">22</span>,</span><br><span class="line">        .name = <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">        .height = <span class="number">168</span>&#125;,</span><br><span class="line">        &#123;.stHashNode = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">        .identifier = <span class="number">2</span>,</span><br><span class="line">        .age = <span class="number">20</span>,</span><br><span class="line">        .name = <span class="string">&quot;John&quot;</span>,</span><br><span class="line">        .height = <span class="number">181</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> keySize = <span class="keyword">sizeof</span>(keyList) / <span class="keyword">sizeof</span>(keyList[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    DATA_S *retNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查找节点 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; keySize; i++) &#123;</span><br><span class="line">        retNode = (DATA_S *)hashFind(pstTable, (<span class="type">const</span> <span class="type">void</span> *)&amp;keyList[i], hashKeyCmp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (retNode != <span class="literal">NULL</span>) &#123; <span class="comment">// 查找成功</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Found data: \n&quot;</span>);</span><br><span class="line">            DATA_PRINT_INFO(hashFunc(retNode), retNode);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 删除节点，并由用户手动释放数据空间 */</span></span><br><span class="line">            hashDel(pstTable, (<span class="type">const</span> <span class="type">void</span> *)retNode, hashKeyCmp);</span><br><span class="line">            <span class="comment">// free(retNode);  // note1</span></span><br><span class="line">            retNode = <span class="literal">NULL</span>; <span class="comment">// 因后续还要使用变量，这里释放后手动置 NULL</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 再次查找节点 */</span></span><br><span class="line">            retNode = (DATA_S *)hashFind(pstTable, (<span class="type">const</span> <span class="type">void</span> *)&amp;keyList[i], hashKeyCmp);</span><br><span class="line">            <span class="keyword">if</span> (retNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Data delete failed\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Data delete successful\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Data not found\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hashPrint(pstTable);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 销毁哈希表，并释放数据空间 */</span></span><br><span class="line">    hashDestroy(pstTable, <span class="literal">true</span>);  <span class="comment">// note2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; dataSize; i++) &#123;</span></span><br><span class="line"><span class="comment">        free(nodeList[i]);  // note3</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">free</span>(nodeList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>哈希表</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>双向链表</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式基础</title>
    <url>/posts/231213183051.html</url>
    <content><![CDATA[<p>正则表达式（Regular Expression）是表示搜索模式的字符串，常缩写成 Regex 或 Regexp。它常用于匹配、查找和替换文本中的字词。此外，我们可以测试文本是否符合我们设置的规则。</p>
<span id="more"></span>

<blockquote>
<p>本文建议在深色主题模式下阅读。</p>
</blockquote>
<h1 id="正则符号汇总"><a href="# 正则符号汇总" class="headerlink" title="正则符号汇总"></a>正则符号汇总</h1><ol>
<li><p>锚点：</p>
<ul>
<li><code>^</code>：匹配字符串或行的开头。</li>
<li><code>$</code>：匹配字符串或行的末尾。</li>
<li><code>\b</code>：匹配单词的开头或末尾。</li>
<li><code>\B</code>：匹配不在单词开头或末尾的位置。</li>
</ul>
</li>
<li><p>字符类：</p>
<ul>
<li><code>[abc]</code>：匹配不在集合中的任意字符。</li>
<li><code>[a-z]</code>：匹配两个字符之间的任意字符，包括它们本身。</li>
<li><code>.</code>：匹配除换行符外的任意字符。</li>
<li><code>\w</code>：匹配字母、数字或下划线字符。</li>
<li><code>\W</code>：匹配除字母、数字和下划线之外的任意字符。</li>
<li><code>\d</code>：匹配所有数字字符。</li>
<li><code>\D</code>：匹配除数字外的任意字符。</li>
<li><code>\s</code>：匹配所有空白字符。</li>
<li><code>\S</code>：匹配除空白字符以外的任意字符。</li>
</ul>
</li>
<li><p>标志：</p>
<ul>
<li><code>g</code>：确保表达式不会在检索到第一个匹配项时停止，即全局匹配。</li>
<li><code>i</code>：使表达式忽略大小写。</li>
<li><code>m</code>：如果不启用，<code>^</code> 和 <code>$</code> 只匹配首行字符串的开始和结束，而不会单独匹配每一行。</li>
</ul>
</li>
<li><p>量词与分支：</p>
<ul>
<li><code>*</code>：表达式匹配零个或多个。</li>
<li><code>+</code>：表达式匹配一个或多个。</li>
<li><code>&#123;1,3&#125;</code>：表达式匹配指定范围的位数，区间为左闭右闭。</li>
<li><code>&#123;1,&#125;</code>：表达式至少匹配的位数。</li>
<li><code>?</code>：使 <code>?</code> 前面的字符可选，即可以有或没有（零次或一次）。</li>
<li><code>|</code>：类似于「或」，用于匹配多种符合条件的表达式之一。</li>
</ul>
</li>
<li><p>组和引用：</p>
<ul>
<li><code>()</code>：使表达式分组。</li>
<li><code>\1</code>：引用表达式的分组，数字表示为第几个分组。</li>
<li><code>(?:)</code>：创建无法引用的非捕获分组。它不是捕获分组，所以不能使用 <code>\1</code> 这种反向引用操作。</li>
</ul>
</li>
<li><p>零宽断言：</p>
<ul>
<li><code>(?=)</code>：正向先行断言，就是断言后面的字符是否满足断言指定的模式，满足则匹配成功。</li>
<li><code>(?!)</code>：负向先行断言，就是断言后面的字符是否满足断言指定的模式，不满足则匹配成功。</li>
<li><code>(?&lt;=)</code>：正向后行断言，就是断言前面的字符是否满足断言指定的模式，满足则匹配成功。</li>
<li><code>(?&lt;!)</code>：负向后行断言，就是断言前面的字符是否满足断言指定的模式，不满足则匹配成功。</li>
</ul>
</li>
</ol>
<h1 id="锚点"><a href="# 锚点" class="headerlink" title="锚点"></a>锚点</h1><h2 id="（字符串或行的开头）"><a href="#（字符串或行的开头）" class="headerlink" title="^（字符串或行的开头）"></a><code>^</code>（字符串或行的开头）</h2><p><code>^</code>：匹配字符串或行的开头。</p>
<p>示例一：</p>
<ul>
<li>文本：<code><span style="background-color: green;"><b>an</b></span> answer or a question</code></li>
<li>正则：<code>/^\w+/g</code></li>
<li>解释：匹配字符串开头的单词（单词定义为包括字母、数字、下划线）。</li>
<li><a href="https://regex101.com/r/au5hjw/1">在线练习</a></li>
</ul>
<h2 id="（字符串或行的末尾）"><a href="#（字符串或行的末尾）" class="headerlink" title="$（字符串或行的末尾）"></a><code>$</code>（字符串或行的末尾）</h2><p><code>$</code>：匹配字符串或行的末尾。</p>
<p>示例一：</p>
<ul>
<li>文本：<code>an answer or a <span style="background-color: green;"><b>question</b></span></code></li>
<li>正则：<code>/\w+$/g</code></li>
<li>解释：匹配字符串末尾的单词。</li>
<li><a href="https://regex101.com/r/40n0TP/2">在线练习</a></li>
</ul>
<h2 id="b（单词边界）"><a href="#b（单词边界）" class="headerlink" title="\b（单词边界）"></a><code>\b</code>（单词边界）</h2><p><code>\b</code>：匹配单词的开头或末尾。</p>
<p>示例一：</p>
<ul>
<li>文本：<code>two ques<span style="background-color: green;"><b>tions</b></span> or three ques<span style="background-color: green;"><b>tions</b></span></code></li>
<li>正则：<code>/tions\b/g</code></li>
<li><a href="https://regex101.com/r/SoEUVG/1">在线练习</a></li>
</ul>
<p>示例二：</p>
<ul>
<li>文本：<code>two <span style="background-color: green;"><b>qu</b></span>estions or three <span style="background-color: green;"><b>qu</b></span>estions</code></li>
<li>正则：<code>/\bqu/g</code></li>
<li><a href="https://regex101.com/r/Vo5SW3/1">在线练习</a></li>
</ul>
<p>示例三：</p>
<ul>
<li>文本：<code>two questions or three questions</code></li>
<li>正则：<code>/\bes/g</code></li>
<li><a href="https://regex101.com/r/rrJlYO/1">在线练习</a></li>
</ul>
<h2 id="B（非单词边界）"><a href="#B（非单词边界）" class="headerlink" title="\B（非单词边界）"></a><code>\B</code>（非单词边界）</h2><p><code>\B</code>：匹配不在单词开头或末尾的位置。</p>
<p>示例一：</p>
<ul>
<li>文本：<code>an a<span style="background-color: green;"><b>n</b></span>swer or a question</code></li>
<li>正则：<code>/n\B/g</code></li>
<li>解释：匹配不是单词结尾的 <code>n</code>。</li>
<li><a href="https://regex101.com/r/D63vfX/1">在线练习</a></li>
</ul>
<p>示例二：</p>
<ul>
<li>文本：<code>a<span style="background-color: green;"><b>n</b></span> a<span style="background-color: green;"><b>n</b></span>swer or a questio<span style="background-color: green;"><b>n</b></span></code></li>
<li>正则：<code>/\Bn/g</code></li>
<li>解释：匹配不是单词开头的 <code>n</code>。</li>
<li><a href="https://regex101.com/r/JA4h9M/1">在线练习</a></li>
</ul>
<h1 id="字符类"><a href="# 字符类" class="headerlink" title="字符类"></a>字符类</h1><h2 id="abc-（字符集）"><a href="#abc-（字符集）" class="headerlink" title="[abc]（字符集）"></a><code>[abc]</code>（字符集）</h2><p><code>[abc]</code>：匹配集合中的任意字符。</p>
<p>示例一：</p>
<ul>
<li>文本：<code>car <span style="background-color: green;"><b>ber</b></span> bir <span style="background-color: green;"><b>bor</b></span> bd bood boedr bur</code></li>
<li>正则：<code>/b[oe]r/g</code></li>
<li>解释：匹配开头是 <code>b</code>、结尾是 <code>r</code>、中间 <strong> 一个 </strong> 字符是 <code>o</code> 或 <code>e</code> 的字符串。</li>
<li><a href="https://regex101.com/r/ppbzZl/1">在线练习</a></li>
</ul>
<h2 id="abc-（否定字符集）"><a href="#abc-（否定字符集）" class="headerlink" title="[^abc]（否定字符集）"></a><code>[^abc]</code>（否定字符集）</h2><p><code>[abc]</code>：匹配不在集合中的任意字符。</p>
<p>示例一：</p>
<ul>
<li>文本：<code>car ber <span style="background-color: green;"><b>bir</b></span> bor bd bood boedr <span style="background-color: green;"><b>bur</b></span></code></li>
<li>正则：<code>/b[^oe]r/g</code></li>
<li>解释：匹配开头是 <code>b</code>、结尾是 <code>r</code>、中间 <strong> 一个 </strong> 字符不是 <code>o</code> 或 <code>e</code> 的字符串。</li>
<li><a href="https://regex101.com/r/jB9a5c/1">在线练习</a></li>
</ul>
<h2 id="a-z-（范围）"><a href="#a-z-（范围）" class="headerlink" title="[a-z]（范围）"></a><code>[a-z]</code>（范围）</h2><p><code>[a-z]</code>：匹配两个字符之间的任意字符，包括它们本身。</p>
<p>示例一：</p>
<ul>
<li>文本：<code>a<span style="background-color: green;"><b>bcde</b></span>f <span style="background-color: green;"><b>b</b></span> <span style="background-color: green;"><b>ec</b></span> <span style="background-color: green;"><b>e</b></span>m<span style="background-color: green;"><b>c</b></span></code></li>
<li>正则：<code>/[b-e]/g</code></li>
<li><a href="https://regex101.com/r/Vje0dj/1">在线练习</a></li>
</ul>
<h2 id="（点）"><a href="#（点）" class="headerlink" title=".（点）"></a><code>.</code>（点）</h2><p><code>.</code>：匹配除换行符外的任意字符。</p>
<p>示例一：</p>
<ul>
<li>文本：<code><span style="background-color: green;"><b>hi012_-!?</b></span></code></li>
<li>正则：<code>/./g</code></li>
<li><a href="https://regex101.com/r/QUomQr/1">在线练习</a></li>
</ul>
<h2 id="w（单词）"><a href="#w（单词）" class="headerlink" title="\w（单词）"></a><code>\w</code>（单词）</h2><p><code>\w</code>：匹配字母、数字或下划线字符。</p>
<p>示例一：</p>
<ul>
<li>文本：<code><span style="background-color: green;"><b>hi</b></span> <span style="background-color: green;"><b>01</b></span>?<span style="background-color: green;"><b>2</b></span> <span style="background-color: green;"><b>_</b></span>-!?</code></li>
<li>正则：<code>/\w/g</code></li>
<li><a href="https://regex101.com/r/svsY7f/1">在线练习</a></li>
</ul>
<h2 id="W（非单词）"><a href="#W（非单词）" class="headerlink" title="\W（非单词）"></a><code>\W</code>（非单词）</h2><p><code>\W</code>：匹配除字母、数字和下划线之外的任意字符。</p>
<p>示例一：</p>
<ul>
<li>文本：<code>hELLo<span style="background-color: green;"><b> </b></span>01<span style="background-color: green;"><b>?</b></span>?<span style="background-color: green;"><b>2</b></span><span style="background-color: green;"><b> </b></span>_<span style="background-color: green;"><b>-!?</b></span></code></li>
<li>正则：<code>/\W/g</code></li>
<li><a href="https://regex101.com/r/yPU2XM/1">在线练习</a></li>
</ul>
<h2 id="d（数字）"><a href="#d（数字）" class="headerlink" title="\d（数字）"></a><code>\d</code>（数字）</h2><p><code>\d</code>：匹配所有数字字符。</p>
<p>示例一：</p>
<ul>
<li>文本：<code>+<span style="background-color: green;"><b>144</b></span>-(<span style="background-color: green;"><b>22</b></span>)-<span style="background-color: green;"><b>13</b></span>=<span style="background-color: green;"><b>0</b></span>x<span style="background-color: green;"><b>6</b></span>D</code></li>
<li>正则：<code>/\d/g</code></li>
<li><a href="https://regex101.com/r/hKAapH/1">在线练习</a></li>
</ul>
<h2 id="D（非数字）"><a href="#D（非数字）" class="headerlink" title="\D（非数字）"></a><code>\D</code>（非数字）</h2><p><code>\D</code>：匹配除数字外的任意字符。</p>
<p>示例一：</p>
<ul>
<li>文本：<code><span style="background-color: green;"><b>+</b></span>144<span style="background-color: green;"><b>-</b></span><span style="background-color: green;"><b>(</b></span>22<span style="background-color: green;"><b>)-</b></span>13<span style="background-color: green;"><b>=</b></span>0<span style="background-color: green;"><b>x</b></span>6<span style="background-color: green;"><b>D</b></span></code></li>
<li>正则：<code>/\D/g</code></li>
<li><a href="https://regex101.com/r/ByqKUX/1">在线练习</a></li>
</ul>
<h2 id="s（空白符）"><a href="#s（空白符）" class="headerlink" title="\s（空白符）"></a><code>\s</code>（空白符）</h2><p><code>\s</code>：匹配所有空白字符。</p>
<p>示例一：</p>
<ul>
<li>文本：<code>one<span style="background-color: green;"><b> </b></span>two<span style="background-color: green;"><b> </b></span>.</code></li>
<li>正则：<code>/\s/g</code></li>
<li><a href="https://regex101.com/r/8Eqf53/1">在线练习</a></li>
</ul>
<h2 id="S（非空白符）"><a href="#S（非空白符）" class="headerlink" title="\S（非空白符）"></a><code>\S</code>（非空白符）</h2><p><code>\S</code>：匹配除空白字符以外的任意字符。</p>
<p>示例一：</p>
<ul>
<li>文本：<code><span style="background-color: green;"><b>one</b></span> <span style="background-color: green;"><b>two</b></span> <span style="background-color: green;"><b>.</b></span></code></li>
<li>正则：<code>/\S/g</code></li>
<li><a href="https://regex101.com/r/cv2CF2/1">在线练习</a></li>
</ul>
<h1 id="标志"><a href="# 标志" class="headerlink" title="标志"></a>标志</h1><h2 id="g（全局匹配）"><a href="#g（全局匹配）" class="headerlink" title="g（全局匹配）"></a><code>g</code>（全局匹配）</h2><p><code>g</code>：确保表达式不会在检索到第一个匹配项时停止，即全局匹配。</p>
<p>示例一：</p>
<ul>
<li>文本：<code><span style="background-color: green;"><b>cat</b></span> dog&<span style="background-color: green;"><b>cat</b></span></code></li>
<li>正则：<code>/cat/g</code></li>
<li><a href="https://regex101.com/r/UGslHN/1">在线练习</a></li>
</ul>
<p>示例二：</p>
<ul>
<li>文本：<code><span style="background-color: green;"><b>cat</b></span> dog&cat</code></li>
<li>正则：<code>/cat/</code></li>
<li>解释：无全局标志下，则当检索到第一个匹配项时则停止。</li>
<li><a href="https://regex101.com/r/t8NQpt/1">在线练习</a></li>
</ul>
<h2 id="i（忽略大小写）"><a href="#i（忽略大小写）" class="headerlink" title="i（忽略大小写）"></a><code>i</code>（忽略大小写）</h2><p><code>i</code>：使表达式忽略大小写。</p>
<p>示例一：</p>
<ul>
<li>文本：<code><span style="background-color: green;"><b>CaT</b></span> dog&<span style="background-color: green;"><b>cat</b></span></code></li>
<li>正则：<code>/cat/gi</code></li>
<li><a href="https://regex101.com/r/xFgnHn/1">在线练习</a></li>
</ul>
<h2 id="m（多行）"><a href="#m（多行）" class="headerlink" title="m（多行）"></a><code>m</code>（多行）</h2><p><code>m</code>：如果不启用，<code>^</code> 和 <code>$</code> 只匹配首行字符串的开始和结束，而不会单独匹配每一行。</p>
<p>示例一：</p>
<ul>
<li><p>文本：</p>
  <p><code>
  <span style="background-color: green;"><b>a</b></span> black cat

<p>  a white cat<br>  </code></p></p>
</li>
<li><p>正则：<code>/^a/g</code></p>
</li>
<li><p>解释：全局匹配字符串开头是 <code>a</code> 的字符（不能匹配每行字符串开头是 <code>a</code> 的字符）。</p>
</li>
<li><p><a href="https://regex101.com/r/ww2ihx/1">在线练习</a></p>
</li>
</ul>
<p>示例二：</p>
<ul>
<li><p>文本：</p>
  <p><code>
  a white cat

<p>  a black c<span style="background-color: green;"><b>at</b></span><br>  </code></p></p>
</li>
<li><p>正则：<code>/at$/g</code></p>
</li>
<li><p>解释：全局匹配字符串结尾是 <code>at</code> 的字符（不能匹配每行字符串结尾是 <code>at</code> 的字符）。</p>
</li>
<li><p><a href="https://regex101.com/r/MHiK1b/1">在线练习</a></p>
</li>
</ul>
<p>示例三：</p>
<ul>
<li><p>文本：</p>
  <p><code>
  <span style="background-color: green;"><b>a</b></span> black cat

<p>  <span style="background-color: green;"><b>a</b></span> white cat<br>  </code></p></p>
</li>
<li><p>正则：<code>/^a/gm</code></p>
</li>
<li><p>解释：全局匹配整个字符串 <strong> 每行 </strong> 开头是 <code>a</code> 的字符。</p>
</li>
<li><p><a href="https://regex101.com/r/WqkZkE/1">在线练习</a></p>
</li>
</ul>
<p>示例四：</p>
<ul>
<li><p>文本：</p>
  <p><code>
  a black c<span style="background-color: green;"><b>at</b></span>

<p>  a white c<span style="background-color: green;"><b>at</b></span><br>  </code></p></p>
</li>
<li><p>正则：<code>/at$/gm</code></p>
</li>
<li><p>解释：全局匹配整个字符串 <strong> 每行 </strong> 结尾是 <code>at</code> 的字符。</p>
</li>
<li><p><a href="https://regex101.com/r/5HIKtS/1">在线练习</a></p>
</li>
</ul>
<h1 id="量词与分支"><a href="# 量词与分支" class="headerlink" title="量词与分支"></a>量词与分支</h1><h2 id="（至少匹配零个）"><a href="#（至少匹配零个）" class="headerlink" title="*（至少匹配零个）"></a><code>*</code>（至少匹配零个）</h2><p><code>*</code>：表达式匹配零个或多个。</p>
<p>示例一：</p>
<ul>
<li>文本：<code><span style="background-color: green;"><b>bp</b></span> <span style="background-color: green;"><b>bep</b></span> <span style="background-color: green;"><b>beep</b></span></code></li>
<li>正则：<code>/be*p/g</code></li>
<li><a href="https://regex101.com/r/eRmirK/1">在线练习</a></li>
</ul>
<h2 id="（至少匹配一个）"><a href="#（至少匹配一个）" class="headerlink" title="+（至少匹配一个）"></a><code>+</code>（至少匹配一个）</h2><p><code>+</code>：表达式匹配一个或多个。</p>
<p>示例一：</p>
<ul>
<li>文本：<code>bp <span style="background-color: green;"><b>bep</b></span> <span style="background-color: green;"><b>beep</b></span></code></li>
<li>正则：<code>/be+p/g</code></li>
<li><a href="https://regex101.com/r/e9lhy6/1">在线练习</a></li>
</ul>
<h2 id="1-3-（指定范围匹配）"><a href="#1-3-（指定范围匹配）" class="headerlink" title="{1,3}（指定范围匹配）"></a><code>&#123;1,3&#125;</code>（指定范围匹配）</h2><p><code>&#123;1,3&#125;</code>：表达式匹配指定范围的位数，区间为左闭右闭。</p>
<p>示例一：</p>
<ul>
<li>文本：<code>bp <span style="background-color: green;"><b>bep</b></span> <span style="background-color: green;"><b>beep</b></span></code></li>
<li>正则：<code>/be&#123;1,2&#125;p/g</code></li>
<li><a href="https://regex101.com/r/WAwFPS/1">在线练习</a></li>
</ul>
<h2 id="1-（至少匹配次数）"><a href="#1-（至少匹配次数）" class="headerlink" title="{1,}（至少匹配次数）"></a><code>&#123;1,&#125;</code>（至少匹配次数）</h2><p><code>&#123;1,&#125;</code>：表达式至少匹配的位数。</p>
<p>示例一：</p>
<ul>
<li>文本：<code>bp <span style="background-color: green;"><b>bep</b></span> <span style="background-color: green;"><b>beep</b></span> <span style="background-color: green;"><b>beeep</b></span></code></li>
<li>正则：<code>/be&#123;1,&#125;p/g</code></li>
<li><a href="https://regex101.com/r/O3raUe/1">在线练习</a></li>
</ul>
<h2 id="（指定字符可选）"><a href="#（指定字符可选）" class="headerlink" title="?（指定字符可选）"></a><code>?</code>（指定字符可选）</h2><p><code>?</code>：使 <code>?</code> 前面的字符可选，即可以有或没有（零次或一次）。</p>
<p>示例一：</p>
<ul>
<li>文本：<code><span style="background-color: green;"><b>color</b></span> <span style="background-color: green;"><b>colour</b></span></code></li>
<li>正则：<code>/colou?r/g</code></li>
<li>解释：单个字符可选。</li>
<li><a href="https://regex101.com/r/QLiuRQ/1">在线练习</a></li>
</ul>
<p>示例二：</p>
<ul>
<li>文本：<code><span style="background-color: green;"><b>color</b></span> colour <span style="background-color: green;"><b>cor</b></span></code></li>
<li>正则：<code>/co(lo)?r/g</code></li>
<li>解释：捕获组可选。</li>
<li><a href="https://regex101.com/r/uOGqyM/1">在线练习</a></li>
</ul>
<h2 id="（或分支）"><a href="#（或分支）" class="headerlink" title="|（或分支）"></a><code>|</code>（或分支）</h2><p><code>|</code>：类似于「或」，用于匹配多种符合条件的表达式之一。</p>
<p>示例一：</p>
<ul>
<li>文本：<code>fat, <span style="background-color: green;"><b>cat</b></span>, <span style="background-color: green;"><b>rat</b></span></code></li>
<li>正则：<code>/(c|r)at/g</code> 或者 <code>/[cr]at/g</code></li>
<li><a href="https://regex101.com/r/KWyvtQ/1">在线练习</a></li>
</ul>
<h1 id="组和引用"><a href="# 组和引用" class="headerlink" title="组和引用"></a>组和引用</h1><h2 id="（捕获分组）"><a href="#（捕获分组）" class="headerlink" title="()（捕获分组）"></a><code>()</code>（捕获分组）</h2><p><code>()</code>：使表达式分组。</p>
<p>示例一：</p>
<ul>
<li>文本：<code><span style="background-color: green;"><b>hahaha</b></span>, h, <span style="background-color: green;"><b>ha</b></span></code></li>
<li>正则：<code>/(ha)+/g</code></li>
<li><a href="https://regex101.com/r/uliqOL/1">在线练习</a></li>
</ul>
<h2 id="1（引用）"><a href="#1（引用）" class="headerlink" title="\1（引用）"></a><code>\1</code>（引用）</h2><p><code>\1</code>：引用表达式的分组，数字表示为第几个分组。</p>
<p>示例一：</p>
<ul>
<li>文本：<code><span style="background-color: green;"><b>hah</b></span>, haa, <span style="background-color: green;"><b>dad</b></span>, <span style="background-color: green;"><b>dad</b></span>a</code></li>
<li>正则：<code>/(\w)a\1/g</code></li>
<li>解释：捕获分组 <code>(\w)</code> 匹配一个字母字符（包括大小写字母、数字和下划线），第二个字符为 <code>a</code>，反向引用 <code>\1</code> 表示引用第一个捕获组中匹配到的内容。该正则匹配字符 <code>a</code> 左右两个字符相等的字符串。</li>
<li><a href="https://regex101.com/r/GJPlNY/1">在线练习</a></li>
</ul>
<p>示例二：</p>
<ul>
<li>文本：<code><span style="background-color: green;"><b>hah</b></span>, haa, <span style="background-color: green;"><b>dad</b></span>, <span style="background-color: green;"><b>woawo</b></span>, <span style="background-color: green;"><b>dad</b></span>a</code></li>
<li>正则：<code>/(\w+)a\1/g</code></li>
<li>解释：捕获分组 <code>(\w+)</code> 至少匹配一个字母字符，第二个字符为 <code>a</code>，反向引用 <code>\1</code> 表示引用第一个捕获组中匹配到的内容。</li>
<li><a href="https://regex101.com/r/iD6FFt/1">在线练习</a></li>
</ul>
<p>示例三：</p>
<ul>
<li>文本：<code>hah, haa, dad, <span style="background-color: green;"><b>wobwob</b></span>, <span style="background-color: green;"><b>dada</b></span></code></li>
<li>正则：<code>/(\w+)([ab])\1\2/g</code></li>
<li><a href="https://regex101.com/r/zz2jSm/1">在线练习</a></li>
</ul>
<h2 id="（非捕获组）"><a href="#（非捕获组）" class="headerlink" title="(?:)（非捕获组）"></a><code>(?:)</code>（非捕获组）</h2><p><code>(?:)</code>：创建无法引用的非捕获分组。它不是捕获分组，所以不能使用 <code>\1</code> 这种反向引用操作。</p>
<p>示例一：</p>
<ul>
<li>文本：<code><span style="background-color: green;"><b>hahaha</b></span>, <span style="background-color: green;"><b>ha</b></span>h, <span style="background-color: green;"><b>ha</b></span>a<span style="background-color: green;"><b>ha</b></span></code></li>
<li>正则：<code>/(?:ha)+/g</code></li>
<li>解释：匹配至少出现一次 <code>ha</code> 的字符串。</li>
<li><a href="https://regex101.com/r/DhG6uE/1">在线练习</a></li>
</ul>
<h1 id="零宽断言"><a href="# 零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h1><h2 id="（断言后面满足给定模式）"><a href="#（断言后面满足给定模式）" class="headerlink" title="(?=)（断言后面满足给定模式）"></a><code>(?=)</code>（断言后面满足给定模式）</h2><p><code>(?=)</code>：正向先行断言，就是断言后面的字符是否满足断言指定的模式，满足则匹配成功。</p>
<p>示例一：</p>
<ul>
<li>文本：<code>1st, <span style="background-color: green;"><b>2</b></span>nd, 3pc, <span style="background-color: green;"><b>4</b></span>nd</code></li>
<li>正则：<code>/\d(?=nd)/g</code></li>
<li>解释：匹配满足一个数字后面紧跟 <code>nd</code> 的那个数字。在 <code>1st</code> 中有数字 <code>1</code>，但是在正向先行断言时，检查到的第一个字符为 <code>s</code>，与断言中的 <code>n</code> 不匹配，这时会停止匹配。</li>
<li><a href="https://regex101.com/r/zO3SzT/1">在线练习</a></li>
</ul>
<blockquote>
<p>正向先行断言记忆：看后面的字符是不是（<code>?</code>）等于（<code>=</code>）断言中的模式，等于则匹配成功。</p>
</blockquote>
<h2 id="（断言后面不满足给定模式）"><a href="#（断言后面不满足给定模式）" class="headerlink" title="?!（断言后面不满足给定模式）"></a><code>?!</code>（断言后面不满足给定模式）</h2><p><code>(?!)</code>：负向先行断言，就是断言后面的字符是否满足断言指定的模式，不满足则匹配成功。</p>
<p>示例一：</p>
<ul>
<li>文本：<code><span style="background-color: green;"><b>1</b></span>st, 2nd, <span style="background-color: green;"><b>3</b></span>pc, <span style="background-color: green;"><b>4</b></span>ne</code></li>
<li>正则：<code>/\d(?!nd)/g</code></li>
<li>解释：匹配满足一个数字后面紧跟着的不是 <code>nd</code> 的那个数字。</li>
<li><a href="https://regex101.com/r/GeV0jm/1">在线练习</a></li>
</ul>
<blockquote>
<p>负向先行断言记忆：看后面的字符是不是（<code>?</code>）不等于（<code>!</code>）断言中的模式，不等于则匹配成功。</p>
</blockquote>
<h2 id="lt-（断言前面满足给定模式）"><a href="#lt-（断言前面满足给定模式）" class="headerlink" title="?&lt;=（断言前面满足给定模式）"></a><code>?&lt;=</code>（断言前面满足给定模式）</h2><p><code>(?&lt;=)</code>：正向后行断言，就是断言前面的字符是否满足断言指定的模式，满足则匹配成功。</p>
<p>示例一：</p>
<ul>
<li>文本：<code>#1, $2, %<span style="background-color: green;"><b>3</b></span></code></li>
<li>正则：<code>/(?&lt;=%)\d/g</code></li>
<li>解释：匹配满足一个数字前面紧跟 <code>%</code> 的那个数字。</li>
<li><a href="https://regex101.com/r/w4UOLX/1">在线练习</a></li>
</ul>
<blockquote>
<p>正向后行断言记忆：看前面（<code>&lt;</code>）的字符是不是（<code>?</code>）等于（<code>=</code>）断言中的模式，等于则匹配成功。</p>
</blockquote>
<h2 id="lt-（断言前面不满足给定模式）"><a href="#lt-（断言前面不满足给定模式）" class="headerlink" title="?&lt;!（断言前面不满足给定模式）"></a><code>?&lt;!</code>（断言前面不满足给定模式）</h2><p><code>(?&lt;!)</code>：负向后行断言，就是断言前面的字符是否满足断言指定的模式，不满足则匹配成功。</p>
<p>示例一：</p>
<ul>
<li>文本：<code>#<span style="background-color: green;"><b>1</b></span>, $<span style="background-color: green;"><b>2</b></span>, %3</code></li>
<li>正则：<code>/(?&lt;!%)\d/g</code></li>
<li>解释：匹配满足一个数字前面紧跟着的不是 <code>%</code> 的那个数字。</li>
<li><a href="https://regex101.com/r/d02Cw0/1">在线练习</a></li>
</ul>
<blockquote>
<p>负向后行断言记忆：看前面（<code>&lt;</code>）的字符是不是（<code>?</code>）不等于（<code>!</code>）断言中的模式，不等于则匹配成功。</p>
</blockquote>
<h1 id="示例：格式化定义"><a href="# 示例：格式化定义" class="headerlink" title="示例：格式化定义"></a>示例：格式化定义 </h1><p> 有时候我们写的代码会不规范，比如指针变量可以写成 <code>int* a;</code> 或者 <code>int * a;</code>，普通变量可以写成 <code>int   a;</code>。</p>
<p>如何写一个正则表达式，来匹配所有不规范，并格式化它呢？</p>
<p>要规范化的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">job</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job</span>*  <span class="title">prev</span>;</span>  <span class="comment">/* pointer to previous job   */</span></span><br><span class="line">    <span class="type">void</span>   (*function)(<span class="type">void</span>* arg);  <span class="comment">/* function pointer          */</span></span><br><span class="line">    <span class="type">void</span>*  arg;  <span class="comment">/* function&#x27;s argument       */</span></span><br><span class="line">    <span class="type">void</span> ** arg2;</span><br><span class="line">    <span class="type">void</span> *a;</span><br><span class="line">&#125; job;</span><br></pre></td></tr></table></figure>

<p>正则表达式：<code>/(?&lt;=\w)\s*(?&lt;!\/)\**\s+/gm</code></p>
<p><a href="https://regex101.com/r/zHSW7X/1">在线练习</a>，这个正则表达式的含义是：</p>
<ul>
<li><p><code>(?&lt;=\w)</code>：断言前面是一个单词字符。</p>
</li>
<li><p><code>\s*</code>：匹配零个或多个空白字符。</p>
</li>
<li><p><code>(?&lt;!\/)</code>：断言前面不是斜杠字符。</p>
</li>
<li><p><code>\**</code>：匹配零个或多个星号字符。</p>
</li>
<li><p><code>\s+</code>：匹配一个或多个空白字符。</p>
</li>
</ul>
<p>综合起来，这个正则表达式的作用是匹配在单词字符后面，按顺序地：可以有或没有空格、可以有或没有星号（不能是斜杠后面的星号）、至少一个空格。</p>
<p>结果图：</p>
<p><img src="../images/computer-basics/regex-example1.png" alt=""></p>
<p>格式化替换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">replace</span>(<span class="params"><span class="keyword">match</span></span>):</span><br><span class="line">    <span class="comment"># 保持最多一个空格，后面追加匹配到的 * 的个数</span></span><br><span class="line">    word = (<span class="string">&#x27; &#x27;</span> <span class="keyword">if</span> <span class="keyword">match</span>.group(<span class="number">0</span>).count(<span class="string">&#x27; &#x27;</span>) &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span>) + <span class="string">&#x27;*&#x27;</span> * <span class="keyword">match</span>.group(<span class="number">0</span>).count(<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> word</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">normalize</span>(<span class="params">declaration</span>):</span><br><span class="line">    pattern = <span class="string">r&#x27;(?&lt;=\w)\s*(?&lt;!\/)\**\s+&#x27;</span> <span class="comment"># 匹配不规范的定义</span></span><br><span class="line">    declaration = re.sub(pattern, replace, declaration)</span><br><span class="line">    <span class="keyword">return</span> declaration</span><br></pre></td></tr></table></figure>

<p>替换后结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">job</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job</span> *<span class="title">prev</span>;</span>  <span class="comment">/* pointer to previous job */</span></span><br><span class="line">    <span class="type">void</span> (*function)(<span class="type">void</span> *arg);  <span class="comment">/* function pointer */</span></span><br><span class="line">    <span class="type">void</span> *arg;  <span class="comment">/* function&#x27;s argument */</span></span><br><span class="line">    <span class="type">void</span> **arg2;</span><br><span class="line">    <span class="type">void</span> *a;</span><br><span class="line">&#125; job;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://regexlearn.com/zh-cn/cheatsheet">https://regexlearn.com/zh-cn/cheatsheet</a></li>
<li><a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md">https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md</a></li>
<li><a href="https://regex101.com">https://regex101.com</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
</search>
