<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C 语言之 main 函数参数</title>
    <url>/posts/230916171929.html</url>
    <content><![CDATA[<h2 id="指令行操作"><a href="# 指令行操作" class="headerlink" title="指令行操作"></a> 指令行操作 </h2><p>C 语言支持从 CLI（指令行）传入参数给 main() 函数，多个命令行参数之间用空格分隔，但是如果参数本身带有空格，那么就使用双引号或单引号。</p>
<p>C 语言的 main 函数是程序的入口函数，它可以有两种形式的参数：</p>
<span id="more"></span>

<ol>
<li><p> 无参数形式：main 函数的原型可以是 <code>int main(void)</code>。这表示不接受任何参数，程序执行时不需要从命令行传递参数给 main 函数。</p>
</li>
<li><p> 带参数形式：main 函数的原型可以是 <code>int main(int argc, char *argv[])</code>。其中，<code>argc</code> 表示命令行参数的个数，而 <code>argv</code> 是一个字符串指针数组，每个元素都是一个命令行参数的字符串。</p>
<ul>
<li><code>argc</code> 标识传入的参数个数。如果没有提供任何参数，<code>argc</code> 将被设置为 1；否则，<code>argc</code> 将被设置为传入的参数个数加 1。</li>
<li><code>argv[0]</code> 通常是程序的名称或路径的字符串。</li>
<li><code>argv[1]</code> 到 <code>argv[argc - 1]</code> 是命令行传递给程序的参数，以空格分隔。</li>
</ul>
</li>
</ol>
<p> 值得注意的是，也可以使用 <code>char **argv</code> 来代替 <code>char *argv[]</code> 形参，两者具有相同的类型含义。因为数组变量名 <code>argv</code> 就是指向 <code>argv[]</code> 数组的第一个元素的指针，同时又因为第一个元素的数值就是一个指针，所以此时的数组变量名 <code>argv</code> 的本质就是一个指针的指针（双重指针）。</p>
<p> 下面是一个例子，演示如何使用带参数的 main 函数来接收命令行参数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;number of params: %d\n&quot;</span>, argc);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;param-%d: %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 如果编译并运行这个程序，并在命令行中输入参数，例如 <code>./a.out arg1 arg2 3 arg4</code>，则输出如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">number of params: 5</span><br><span class="line">param-0: ./a.out</span><br><span class="line">param-1: arg1</span><br><span class="line">param-2: arg2</span><br><span class="line">param-3: 3</span><br><span class="line">param-4: arg4</span><br></pre></td></tr></table></figure>

<p> 参考链接：<a href="https://is-cloud.blog.csdn.net/article/details/105347737">https://is-cloud.blog.csdn.net/article/details/105347737</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>main函数参数</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之 const 关键字</title>
    <url>/posts/230913200729.html</url>
    <content><![CDATA[<p>宏定义 <code>#define</code> 和 <code>const</code> 关键字在 C 语言中有不同的用途：</p>
<ol>
<li><p><code>#define</code> 用于定义宏常量，它在编译前进行简单的文本替换，没有类型检查和作用域限制。宏常量的值可以是任意的表达式，包括函数调用和运算符操作，但容易导致代码的可读性和可维护性降低。</p>
</li>
<li><p><code>const</code> 关键字用于定义常量变量，具有类型检查和作用域限制的特性。常量变量的值在定义后不能被修改，提高了代码的可读性和可维护性。常量变量的作用域仅限于定义它的代码块内，其他代码块无法访问该常量。</p>
</li>
<li><p><code>const</code> 关键字还可以用于定义指向常量的指针、常量指针以及指向常量的常量指针。这些用法可以在编译阶段进行类型检查，避免了在运行时可能出现的错误。</p>
</li>
<li><p>编译器通常不会为 <em> 普通的</em> <code>const</code> 常量分配存储空间，而是将它们保存在符号表中，成为编译期间的常量。这样可以避免存储和读内存的操作，提高程序的执行效率。</p>
</li>
</ol>
<p>综上所述，虽然 <code>#define</code> 可以用于定义常量，但 <code>const</code> 关键字更加推荐，因为它提供了类型检查和作用域限制，提高了代码的可读性和可维护性，同时能够进行编译期间的优化。</p>
<span id="more"></span>

<h2 id="修饰常量变量（Constant-Variables）"><a href="# 修饰常量变量（Constant-Variables）" class="headerlink" title="修饰常量变量（Constant Variables）"></a>修饰常量变量（Constant Variables）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> var = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> var = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>这两种写法是等价的，都表示变量 <code>n</code> 的值不能被修改了。需要注意的是，用 <code>const</code> 修饰变量时，一定要给变量初始化，否则后续就不能赋值了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C program to demonstrate that constant variables can not be modified</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> var = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compilation error: assignment of read-only variable &#x27;var&#x27;</span></span><br><span class="line">    var = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修饰常量字符串"><a href="# 修饰常量字符串" class="headerlink" title="修饰常量字符串"></a>修饰常量字符串</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>字符指针指向的字符串是不能修改的 </strong>：在 C 语言中，字符串常量是以<strong> 只读方式 </strong> 存储的，编译器会将其 <strong> 存储在只读的数据段 </strong> 中。而使用 <code>const</code> 关键字修饰的指针变量，会告诉编译器不允许通过该指针修改指向的数据。</p>
<p>如果没有 <code>const</code> 的修饰，我们可能会在后面有意无意的写 <code>str[0]=&#39;x&#39;</code> 这样的语句，这样会导致对只读内存区域的赋值，然后程序会立刻异常终止。但是，有了 <code>const</code>，这个错误就能在程序被编译的时候被检查出来，这就是 <code>const</code> 的好处，让逻辑错误在编译期被发现。</p>
<h2 id="指针常量（Pointer-to-Constant）"><a href="# 指针常量（Pointer-to-Constant）" class="headerlink" title="指针常量（Pointer to Constant）"></a>指针常量（Pointer to Constant）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* ptr;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *ptr;</span><br></pre></td></tr></table></figure>

<p>这两种写法是等价的。指针常量可以更改指针 <code>ptr</code> 的地址，以指向任何其他同类型的变量，但不能更改指针 <code>ptr</code> 指向的对象的值。指针常量中的指针被存储在读写区域（read-write area），在本例中为堆栈，所指向的对象可能位于只读区域或读写区域。</p>
<blockquote>
<p>简言之：指针（的地址）可变；指针地址不变的前提下，其指向的内容不可变。</p>
</blockquote>
<p>变量 <code>i</code> 是变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C program to demonstrate that the pointer to point to any other integer variable, </span></span><br><span class="line"><span class="comment">// but the value of the object (entity) pointed can not be changed</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">/* ptr is pointer to constant */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* ptr = &amp;i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line">    <span class="comment">/* error: object pointed cannot be modified using the pointer ptr */</span></span><br><span class="line">    <span class="comment">/* error: assignment of read-only location &#x27;*ptr&#x27; */</span></span><br><span class="line">    *ptr = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    ptr = &amp;j; <span class="comment">/* valid */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量 <code>i</code> 本身就是常量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C program to demonstrate that the pointer to point to any other integer variable, </span></span><br><span class="line"><span class="comment">// but the value of the object (entity) pointed can not be changed</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* i is stored in read only area*/</span></span><br><span class="line">    <span class="type">int</span> <span class="type">const</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* pointer to integer constant. Here i</span></span><br><span class="line"><span class="comment">    is of type &quot;const int&quot;, and &amp;i is of</span></span><br><span class="line"><span class="comment">    type &quot;const int *&quot;. And ptr is of type</span></span><br><span class="line"><span class="comment">    &quot;const int *&quot;, types are matching no issue */</span></span><br><span class="line">    <span class="type">int</span> <span class="type">const</span>* ptr = &amp;i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* error: assignment of read-only location &#x27;*ptr&#x27; */</span></span><br><span class="line">    *ptr = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* valid. We call it up qualification. In</span></span><br><span class="line"><span class="comment">    C/C++, the type of &quot;int *&quot; is allowed to up</span></span><br><span class="line"><span class="comment">    qualify to the type &quot;const int *&quot;. The type of</span></span><br><span class="line"><span class="comment">    &amp;j is &quot;int *&quot; and is implicitly up qualified by</span></span><br><span class="line"><span class="comment">    the compiler to &quot;const int *&quot; */</span></span><br><span class="line"></span><br><span class="line">    ptr = &amp;j;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 C++ 中，不允许进行下限定（down qualification）操作，而在 C 中进行此操作可能会导致警告。下限定是指将已经限定了类型的变量赋值给没有限定类型的变量的情况。</p>
<p>在 C++ 和 C 中，上限定（up qualification）是允许的，不会引发警告或错误。上限定是指将没有限定类型的变量赋值给已经限定了类型的变量的情况。这意味着可以将一个没有限定类型的变量赋值给一个已经限定了类型的变量，而编译器会自动进行类型转换。上限定操作可以用于提升变量的类型精度或实现类型转换。例如，将一个整数赋值给一个浮点数变量，编译器会自动将整数转换为浮点数类型。</p>
</blockquote>
<p>下限定操作示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C program to demonstrate the down qualification</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="type">const</span> j = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ptr is pointing an integer object */</span></span><br><span class="line">    <span class="type">int</span>* ptr = &amp;i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The below assignment is invalid in C++, results in</span></span><br><span class="line"><span class="comment">    error In C, the compiler *may* throw a warning, but</span></span><br><span class="line"><span class="comment">    casting is implicitly allowed */</span></span><br><span class="line">    ptr = &amp;j;  <span class="comment">/* warning: assignment discards ‘const’ qualifier from pointer target type [-Wdiscarded-qualifiers] */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In C++, it is called &#x27;down qualification&#x27;. The type</span></span><br><span class="line"><span class="comment">    of expression &amp;j is &quot;const int *&quot; and the type of ptr</span></span><br><span class="line"><span class="comment">    is &quot;int *&quot;. The assignment &quot;ptr = &amp;j&quot; causes to</span></span><br><span class="line"><span class="comment">    implicitly remove const-ness from the expression &amp;j.</span></span><br><span class="line"><span class="comment">    C++ being more type restrictive, will not allow</span></span><br><span class="line"><span class="comment">    implicit down qualification. However, C++ allows</span></span><br><span class="line"><span class="comment">    implicit up qualification. The reason being, const</span></span><br><span class="line"><span class="comment">    qualified identifiers are bound to be placed in</span></span><br><span class="line"><span class="comment">    read-only memory (but not always). If C++ allows</span></span><br><span class="line"><span class="comment">    above kind of assignment (ptr = &amp;j), we can use &#x27;ptr&#x27;</span></span><br><span class="line"><span class="comment">    to modify value of j which is in read-only memory.</span></span><br><span class="line"><span class="comment">    The consequences are implementation dependent, the</span></span><br><span class="line"><span class="comment">    program may fail</span></span><br><span class="line"><span class="comment">    at runtime. So strict type checking helps clean code.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常量指针指向变量（Constant-Pointer-to-Variable）"><a href="# 常量指针指向变量（Constant-Pointer-to-Variable）" class="headerlink" title="常量指针指向变量（Constant Pointer to Variable）"></a>常量指针指向变量（Constant Pointer to Variable）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="type">const</span> ptr;</span><br></pre></td></tr></table></figure>

<p>上面的声明是一个指向整型变量的常量指针，这意味着我们可以改变该指针所指向的对象的值，但不能改变该指针指向另一个变量。</p>
<blockquote>
<p>简言之：指针（地址）是常量，不可变；指针指向的变量可变。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C program to demonstrate that the value of object pointed</span></span><br><span class="line"><span class="comment">// by pointer can be changed but the pointer can not point to another variable</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* constant pointer to integer */</span></span><br><span class="line">    <span class="type">int</span>* <span class="type">const</span> ptr = &amp;i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line"></span><br><span class="line">    *ptr = <span class="number">100</span>; <span class="comment">/* valid */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* error: assignment of read-only variable &#x27;ptr&#x27; */</span></span><br><span class="line">    ptr = &amp;j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常量指针指向常量（Constant-Pointer-to-Constant）"><a href="# 常量指针指向常量（Constant-Pointer-to-Constant）" class="headerlink" title="常量指针指向常量（Constant Pointer to Constant）"></a>常量指针指向常量（Constant Pointer to Constant）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> ptr;</span><br></pre></td></tr></table></figure>

<p>上面的声明是一个指向常量变量的常量指针，这意味着我们不能更改指针所指向的值，也不能将指针指向其他变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C program to demonstrate that value pointed by the</span></span><br><span class="line"><span class="comment">// pointer can not be changed as well as we cannot point the</span></span><br><span class="line"><span class="comment">// pointer to other variables</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* constant pointer to constant integer */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> ptr = &amp;i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line"></span><br><span class="line">    ptr = &amp;j; <span class="comment">/* error: assignment of read-only variable &#x27;ptr&#x27; */</span></span><br><span class="line">    *ptr = <span class="number">100</span>; <span class="comment">/* error: assignment of read-only location &#x27;*ptr&#x27; */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Type</th>
<th>Declaration</th>
<th>Pointer Value Change</th>
<th>Pointing Value Change</th>
</tr>
</thead>
<tbody><tr>
<td>Pointer to Variable</td>
<td><code>int *ptr</code></td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Pointer to Constant</td>
<td><code>const int *ptr</code></td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Pointer to Constant</td>
<td><code>int const *ptr</code></td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Constant Pointer to Variable</td>
<td><code>int* const ptr</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>Constant Pointer to Constant</td>
<td><code>const int* const ptr</code></td>
<td>No</td>
<td>No</td>
</tr>
</tbody></table>
<p>注：</p>
<ol>
<li><p>Pointer Value Change（指向的值的改变），如 <code>*ptr = 100</code></p>
</li>
<li><p>Pointing Value Change（指针的值的改变），如 <code>ptr = &amp;a</code></p>
</li>
<li><p>如果 <code>const</code> 在 <code>*</code> 的左边，那么 <code>const</code> 可以与类型互换位置，如 <code>const int *ptr</code> 等价于 <code>int const *ptr</code></p>
</li>
<li><p>被 <code>const</code> 修饰的变量，地址不可变还是值不可变，傻傻分不清？观察 <code>const</code> 靠近普通类型还是靠近指针类型：</p>
<ul>
<li>如果 <code>const</code> 靠近的是普通类型，那么常量变量的值不可变，指针地址可变，如 <code>const int *ptr</code>，<code>int const *ptr</code></li>
<li>如果 <code>const</code> 靠近的是指针类型，那么指针指向的基本类型的值可变，指针地址不可变，如 <code>int* const ptr</code></li>
</ul>
</li>
<li><p><strong>指针常量与常量指针记忆方法</strong>：只保留 <code>const</code> 和 <code>*</code>，从右往左读，如下：</p>
<ul>
<li><del>int</del> *<del>ptr</del>指针变量</li>
<li>const <del>int</del> *<del>ptr</del>指针常量</li>
<li><del>int</del> const *<del>ptr</del>指针常量</li>
<li><del>int</del>* const <del>ptr</del>常量指针</li>
<li>const <del>int</del>* const <del>ptr</del>常量指针指向常量变量</li>
</ul>
</li>
</ol>
<blockquote>
<p>参考链接：<a href="https://www.geeksforgeeks.org/const-qualifier-in-c/">https://www.geeksforgeeks.org/const-qualifier-in-c/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>const关键字</tag>
        <tag>下限定</tag>
        <tag>上限定</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之 typedef 实践</title>
    <url>/posts/230920172849.html</url>
    <content><![CDATA[<p>在 <a href="https://pursue26.github.io/posts/230918174223.html">C 语言之 typedef 自定义类型基础</a> 中介绍了 <code>typedef</code> 的使用，下面介绍一些 <code>typedef</code> 的实践。</p>
<span id="more"></span>

<h2 id="两大陷阱"><a href="# 两大陷阱" class="headerlink" title="两大陷阱"></a>两大陷阱 </h2><h3 id="不是简单的字符串替换"><a href="# 不是简单的字符串替换" class="headerlink" title="不是简单的字符串替换"></a> 不是简单的字符串替换</h3><p><code>typedef</code> 是定义了一种类型的新别名，不同于宏，它不是简单的字符串替换。</p>
<p>当 <code>const</code> 与 <code>typedef</code> 相结合时，如定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* PSTR;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mystrcmp</span><span class="params">(<span class="type">const</span> PSTR, <span class="type">const</span> PSTR)</span>;</span><br></pre></td></tr></table></figure>

<p><code>const PSTR</code> 实际上相当于指针常量 <code>const char*</code> 吗？</p>
<p>不是的，它实际上相当于 <code>char* const</code>。这是因为 <code>const</code> 给予了整个指针本身以常量性，也就是形成了常量指针。简单来说，记住当 <code>const</code> 和 <code>typedef</code> 一起出现时，<code>typedef</code> 不会是简单的字符串替换就行。</p>
<h3 id="与其它存储类关键字不共存"><a href="# 与其它存储类关键字不共存" class="headerlink" title="与其它存储类关键字不共存"></a>与其它存储类关键字不共存 </h3><p><code>typedef</code> 在语法上是一个<strong> 存储类关键字</strong>，虽然它并不真正影响对象的存储特性，但变量只能被一种储类的关键字修饰。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">static</span> <span class="type">int</span> SINT_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">auto</span> <span class="type">int</span> AINT_t;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">typedef</span> <span class="type">int</span> INT_t;</span><br></pre></td></tr></table></figure>

<p>上述代码中，有两个存储类关键字，会编译将失败，报错 error: multiple storage classes in declaration specifiers</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INT_t;</span><br><span class="line"><span class="type">static</span> INT_t a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>这种写法是合法的。</p>
<blockquote>
<p>其它存储类关键字有 <code>auto</code>、<code>extern</code>、<code>mutable</code>、<code>static</code>、<code>register</code> 等。</p>
</blockquote>
<h2 id="typedef、const 与 define 结合"><a href="#typedef、const 与 define 结合" class="headerlink" title="typedef、const 与 define 结合"></a>typedef、const 与 define 结合 </h2><p> 示例 1：通常讲，<code>typedef</code> 要比 <code>define</code> 要好，<strong>特别是在有指针的场合</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> pStr2 char*</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* pStr1;</span><br><span class="line"></span><br><span class="line">pStr1 s1, s2;  </span><br><span class="line">pStr2 s3, s4;</span><br></pre></td></tr></table></figure>

<p>在上述的变量定义中，<code>s1</code>、<code>s2</code>、<code>s3</code>都被定义为 <code>char *</code>，而<code>s4</code> 则定义成了 <code>char</code>，不是我们所预期的指针变量，根本原因就在于<code>define</code> 只是简单的字符串替换而 <code>typedef</code> 则是为一个类型起新名字。</p>
<p>示例 2：当 <code>const</code> 和<code>typedef</code>一起出现时，<code>typedef</code>不会是简单的字符串替换。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* pStr;</span><br><span class="line"><span class="type">char</span> s[<span class="number">4</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *p1 = s;</span><br><span class="line"><span class="type">const</span> pStr p2 = s; <span class="comment">// 实际为 char* const p2 = s;</span></span><br><span class="line"></span><br><span class="line">p1++;  <span class="comment">// 指针常量的指针可变</span></span><br><span class="line">p2++;  <span class="comment">// 编译报错, 常量指针的指针不可变</span></span><br><span class="line">*p1 = <span class="string">&#x27;m&#x27;</span>;  <span class="comment">// 编译报错, 指针常量的值不可变</span></span><br><span class="line"></span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">s[<span class="number">1</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s = %s, %c\r\n&quot;</span>, s, *p1, *p2);  <span class="comment">//dec, e, d</span></span><br><span class="line">*p2 = <span class="string">&#x27;m&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s = %s, %c\r\n&quot;</span>, s, *p1, *p2);  <span class="comment">//mec, e, m</span></span><br></pre></td></tr></table></figure>

<p>示例中，</p>
<ul>
<li><code>const char *p1</code>是限定数据类型为 <code>char *</code> 的指针变量可变，指针变量指向的对象不可变，所以 <code>p1++</code> 正确；</li>
<li><code>p2++</code>出错了，这个问题再一次提醒我们：<code>typedef</code>和 <code>define</code> 不同，它不是简单的文本替换；</li>
<li><code>const pStr p2</code>并不等于 <code>const char *p2</code>，<code>const pStr p2</code> 和<code>const long x</code>本质上没有区别，都是对变量进行只读限制，只不过此处变量 <code>p2</code> 的数据类型是我们自己定义的，而不是系统固有类型。因此，<code>const pStr p2</code>的含义是：限定数据类型为 <code>char *</code> 的指针变量 <code>p2</code> 为只读，因此 <code>p2++</code> 错误。</li>
</ul>
<h2 id="抑制劣质代码"><a href="# 抑制劣质代码" class="headerlink" title="抑制劣质代码"></a>抑制劣质代码 </h2><p> 人们常常使用 <code>typedef</code> 来编写更美观和可读的代码。所谓美观，意指 <code>typedef</code> 能隐藏笨拙的语法构造以及平台相关的数据类型，从而增强可移植性以及未来的可维护性。在编程中使用 <code>typedef</code> 目的一般有两个，一个是给变量一个易记且意义明确的新名字，另一个是简化一些比较复杂的类型声明。</p>
<h3 id="定义易于记忆的类型名"><a href="# 定义易于记忆的类型名" class="headerlink" title="定义易于记忆的类型名"></a>定义易于记忆的类型名</h3><p><code>typedef</code> 使用最多的地方是创建易于记忆的类型名，用它来归档程序员的意图。类型出现在所声明的变量名字中，位于 <code>typedef</code> 关键字右边。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure>

<p>此声明定义了一个 <code>int</code> 的同义字，名字为 <code>size</code>。注意 <code>typedef</code> 并不创建新的类型，它仅仅为现有类型添加一个同义字。因此，你可以在任何需要 <code>int</code> 的上下文中使用 <code>size</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">measure</span><span class="params">(size *pSize)</span>;</span><br><span class="line">size <span class="built_in">array</span>[<span class="number">4</span>];</span><br><span class="line">size len = file.getlength();</span><br></pre></td></tr></table></figure>

<p><code>typedef</code> 还可以掩饰复合类型，如指针和数组。例如，你不用像下面这样重复定义有 81 个字符元素的数组：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> line[<span class="number">81</span>];</span><br><span class="line"><span class="type">char</span> text[<span class="number">81</span>];</span><br></pre></td></tr></table></figure>

<p>定义一个 <code>typedef</code>，每当要用到相同类型和大小的数组时，可以这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> Line[<span class="number">81</span>];</span><br><span class="line">Line text, secondline;</span><br><span class="line">getline(text);</span><br></pre></td></tr></table></figure>

<p>同样，也可以像下面这样隐藏指针语法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">char</span> *<span class="type">pstr_t</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mystrcmp</span><span class="params">(<span class="type">pstr_t</span>, <span class="type">pstr_t</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>记住</strong>，不管什么时候，只要为指针声明 <code>typedef</code>，都要在最终的 <code>typedef</code> 名称中加一个 <code>const</code>，比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">char</span> *<span class="type">cpstr_t</span>;  <span class="comment">// 指针常量, 使得该指针可变, 而指针指向的对象不可变（只读）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* <span class="type">const</span> <span class="type">cpstr_t</span>;  <span class="comment">// 常量指针, 使得该指针不可变（只读）, 但指针指向的对象可变的</span></span><br></pre></td></tr></table></figure>

<h3 id="简化代码"><a href="# 简化代码" class="headerlink" title="简化代码"></a>简化代码 </h3><p> 上面讨论的 <code>typedef</code> 行为有点像 <code>define</code> 宏，用其实际类型替代同义字。不同点是 <code>typedef</code> 在编译时被解释，因此可以让编译器来应付超越预处理器能力的文本替换。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*PF)</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *)</span>;</span><br></pre></td></tr></table></figure>

<p>这个声明引入了 <code>PF</code> 类型作为函数指针的同义字，该函数有两个 <code>const char *</code> 类型的参数以及一个 <code>int</code> 类型的返回值。如果要使用下列形式的函数声明，那么上述这个 <code>typedef</code> 是不可或缺的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PF <span class="title function_">Register</span><span class="params">(PF pf)</span>;</span><br></pre></td></tr></table></figure>

<p><code>Register()</code> 的参数是一个 <code>PF</code> 类型的回调函数，返回某个函数的地址，其署名与先前注册的名字相同。下面我展示一下如果不用 <code>typedef</code>，我们是如何实现这个声明的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*Register (<span class="type">int</span> (*pf)(<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *))) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *); </span><br></pre></td></tr></table></figure>

<p>很少有程序员理解它是什么意思，更不用说这种费解的代码所带来的出错风险了。显然，这里使用 <code>typedef</code> 不是一种特权，而是一种必需。</p>
<p>持怀疑态度的人可能会问：“OK，还会有人写这样的代码吗？”，快速浏览一下揭示 <code>signal()</code> 函数的头文件 <code>&lt;csinal&gt;</code>，有一个同样接口的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// signal 原型</span></span><br><span class="line"><span class="type">void</span> (*signal(<span class="type">int</span> sig, <span class="type">void</span> (*func)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// typedef 优化后</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*pFun)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">pFun <span class="title function_">signal</span><span class="params">(<span class="type">int</span> sig, pFun func)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考链接：<a href="https://www.cnblogs.com/a-s-m/p/10995722.html">https://www.cnblogs.com/a-s-m/p/10995722.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>自定义类型</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之多维数组</title>
    <url>/posts/230922143003.html</url>
    <content><![CDATA[<p>本文章主要介绍 C 语言创建多维数组的方式及其排序，包括静态多维数组、<code>malloc</code> 动态申请多维数组、指针数组的多维数组和多维结构体数组的创建。</p>
<span id="more"></span>

<h2 id="排序接口"><a href="# 排序接口" class="headerlink" title="排序接口"></a>排序接口</h2><p><code>qsort</code> 函数是 C 语言标准库中的一个排序函数，用于对数组进行快速排序。它的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qsort</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *base, </span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> nmemb, </span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> size, </span></span><br><span class="line"><span class="params">    <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>base</code>：指向需要排序的数组的第一个元素的指针。</li>
<li><code>nmemb</code>：数组中元素的个数。</li>
<li><code>size</code>：每个元素的大小（以字节为单位）。</li>
<li><code>compar</code>：指向比较函数的指针，用于指定数组元素的比较规则。</li>
</ul>
<p><code>base</code> 指定了待排序数组的首地址，再结合 <code>nmemb * size</code> 可以确定要排序的数组的范围。</p>
<p>比较函数 <code>compar</code> 的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">compar</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>a</code> 和 <code>b</code>：指向待比较的两个元素的指针。</li>
</ul>
<p>比较函数 <code>compar</code> 必须返回一个整数值，表示 <code>a</code> 和 <code>b</code> 的大小关系：</p>
<ul>
<li>如果 <code>a</code> 小于 <code>b</code>，则返回一个负整数。</li>
<li>如果 <code>a</code> 等于 <code>b</code>，则返回零。</li>
<li>如果 <code>a</code> 大于 <code>b</code>，则返回一个正整数。</li>
</ul>
<p>通过传入不同的比较函数，<code>qsort</code> 函数可以实现对不同类型的数组进行排序。</p>
<h2 id="静态多维数组"><a href="# 静态多维数组" class="headerlink" title="静态多维数组"></a>静态多维数组 </h2><h3 id="多维数组创建"><a href="# 多维数组创建" class="headerlink" title="多维数组创建"></a> 多维数组创建</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> rows = <span class="number">3</span>, cols = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> arr[rows][cols];</span><br></pre></td></tr></table></figure>

<h3 id="多维数组排序"><a href="# 多维数组排序" class="headerlink" title="多维数组排序"></a>多维数组排序 </h3><p> 按照二维数组第 0 列升序排序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">int</span> *)a)[<span class="number">0</span>] - ((<span class="type">int</span> *)b)[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入 cmp 函数指针的 arr 是一个一维指针</span></span><br><span class="line">qsort(arr, rows, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), cmp);  <span class="comment">// 快速排序</span></span><br></pre></td></tr></table></figure>

<h2 id="malloc 动态申请多维数组"><a href="#malloc 动态申请多维数组" class="headerlink" title="malloc 动态申请多维数组"></a>malloc 动态申请多维数组 </h2><h3 id="多维数组创建 -1"><a href="# 多维数组创建 -1" class="headerlink" title="多维数组创建"></a> 多维数组创建</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> rows = <span class="number">3</span>, cols = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态申请二维数组</span></span><br><span class="line"><span class="type">int</span> **arr = (<span class="type">int</span> **)<span class="built_in">malloc</span>(rows * <span class="keyword">sizeof</span>(<span class="type">int</span> *));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">    arr[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(cols * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(arr);</span><br></pre></td></tr></table></figure>

<p>释放 <code>malloc</code> 申请的多维数组时，不能直接 <code>free(arr)</code>，因为 <code>malloc</code> 和 <code>free</code> 执行次数要一致。</p>
<h3 id="多维数组排序 -1"><a href="# 多维数组排序 -1" class="headerlink" title="多维数组排序"></a>多维数组排序 </h3><p> 按照二维数组第 0 列升序排序，若相等，则按第 1 列升序排序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span> &#123;</span><br><span class="line">    <span class="comment">// a 是一个指向二维数组首行的指针</span></span><br><span class="line">    <span class="comment">// 通过类型转换和解引用操作, ap 指向了 a 所指向的整型数组的首地址</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* ap = *(<span class="type">int</span> **)a;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* bp = *(<span class="type">int</span> **)b;</span><br><span class="line">    <span class="keyword">if</span> (ap[<span class="number">0</span>] == bp[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ap[<span class="number">1</span>] - bp[<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ap[<span class="number">0</span>] - bp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入 cmp 函数指针的 arr 是一个二维指针</span></span><br><span class="line">qsort(arr, rows, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), cmp);</span><br></pre></td></tr></table></figure>

<h2 id="malloc 动态申请多维结构体数组"><a href="#malloc 动态申请多维结构体数组" class="headerlink" title="malloc 动态申请多维结构体数组"></a>malloc 动态申请多维结构体数组 </h2><h3 id="多维结构体数组创建"><a href="# 多维结构体数组创建" class="headerlink" title="多维结构体数组创建"></a> 多维结构体数组创建</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> rows = <span class="number">3</span>, cols = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">&#125; Node_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态申请二维数组</span></span><br><span class="line">Node_t **arr = (Node_t **)<span class="built_in">malloc</span>(rows * <span class="keyword">sizeof</span>(Node_t *));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">    arr[i] = (Node_t *)<span class="built_in">malloc</span>(cols * <span class="keyword">sizeof</span>(Node_t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">    <span class="comment">// 如果结构体成员中有指针且申请了空间, 则需要先释放成员的空间再释放结构体的空间</span></span><br><span class="line">    <span class="built_in">free</span>(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(arr);</span><br></pre></td></tr></table></figure>

<h3 id="多维结构体数组排序"><a href="# 多维结构体数组排序" class="headerlink" title="多维结构体数组排序"></a>多维结构体数组排序 </h3><p> 按照二维数组第 0 列的结构体成员 <code>x</code> 降序排序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// return (Node_t *)a-&gt;x - (Node_t *)b-&gt;x;   // 错误写法</span></span><br><span class="line">    <span class="keyword">return</span> ((Node_t *)a)-&gt;x - ((Node_t *)b)-&gt;x;   <span class="comment">// 正确写法 1</span></span><br><span class="line">    <span class="comment">// return (*(Node_t *)b).x - (*(Node_t *)a).x;     // 正确写法 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">qsort(arr, rows, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), cmp);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-&gt;</code> 操作符的优先级高于 <code>()</code> 操作符。</li>
</ul>
<h2 id="指针数组的多维数组"><a href="# 指针数组的多维数组" class="headerlink" title="指针数组的多维数组"></a>指针数组的多维数组 </h2><p> 使用指针数组的多维数组：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> rows = <span class="number">3</span>, cols = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* arr[rows];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cols; i++) &#123;</span><br><span class="line">    arr[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式创建的多维数组实际上是一个指针数组，每个指针指向一个一维数组，可以在运行时动态分配每个一维数组的大小（方便创建每行元素个数不同的多维数组）。</p>
<h3 id="多维数组排序 -2"><a href="# 多维数组排序 -2" class="headerlink" title="多维数组排序"></a>多维数组排序 </h3><p> 按照二维数组第 0 列降序排序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* ap = *(<span class="type">int</span> **)a;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* bp = *(<span class="type">int</span> **)b;</span><br><span class="line">    <span class="keyword">return</span> bp[<span class="number">0</span>] - ap[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入 cmp 函数指针的 arr 是一个二维指针</span></span><br><span class="line">qsort(arr, rows, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), cmp);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>多维数组</tag>
        <tag>数组排序</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之 typedef 自定义类型基础</title>
    <url>/posts/230918174223.html</url>
    <content><![CDATA[<p><code>typedef</code> 关键字用于自定义数据类型的一个别名，或者称之为「定义了一种新的数据类型」。它可以有效简化定义一个复杂数据类型的代码实现。</p>
<span id="more"></span>

<h2 id="四个用途"><a href="# 四个用途" class="headerlink" title="四个用途"></a>四个用途 </h2><h3 id="定义一种类型的别名"><a href="# 定义一种类型的别名" class="headerlink" title="定义一种类型的别名"></a> 定义一种类型的别名 </h3><p> 定义一种类型的别名，而不只是简单的宏替换。例如，可以用作同时声明指针类型的 <strong> 多个对象</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* pa, pb;</span><br></pre></td></tr></table></figure>

<p>不符合意图，它只声明了一个指向字符变量的指针 <code>pa</code> 和一个字符变量<code>pb</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* PCHAR;</span><br><span class="line">PCHAR pa, pb;</span><br></pre></td></tr></table></figure>

<p>符合意图，同时声明了两个指向字符变量的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *pa, *pb;</span><br></pre></td></tr></table></figure>

<p>也符合意图，但相对来说没有用 <code>typedef</code> 的形式直观，尤其在需要大量指针的地方，<code>typedef</code> 的方式更省事。</p>
<h3 id="为结构体类型对象起别名"><a href="# 为结构体类型对象起别名" class="headerlink" title="为结构体类型对象起别名"></a>为结构体类型对象起别名</h3><p><code>typedef</code> 可以用在 <code>struct</code> 结构体中，为声明的 <code>struct</code> 结构体类型的对象起别名。</p>
<p><strong>声明 </strong> 结构体类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPOINT</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一般结构体变量的定义为 <code>struct struct_name obj_name</code>，如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPOINT</span> <span class="title">stCoor</span>;</span>  <span class="comment">// 定义一个结构体变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPOINT</span> *<span class="title">pstCoor</span> =</span> <span class="literal">NULL</span>; <span class="comment">// 定义一个结构体指针变量</span></span><br></pre></td></tr></table></figure>

<p><strong>定义 </strong> 结构体类型，而非定义结构体变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagPOINT</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125; stPOINT, *pstPOINT;</span><br></pre></td></tr></table></figure>

<p>使用 <code>typedef</code> 为 <code>struct</code> 声明的结构体类型起别名后，定义该结构体类型的变量时，可以不再书写 <code>struct</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">stPOINT stCoor;  <span class="comment">// 定义一个结构体变量</span></span><br><span class="line">pstPOINT pstCoor = <span class="literal">NULL</span>; <span class="comment">// 定义一个结构体指针变量</span></span><br><span class="line">stPOINT *pstCoor; <span class="comment">// 定义一个结构体指针变量</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面既有「声明」，又有「定义」，那声明结构体类型、定义结构体类型和定义结构体变量的区别：</p>
</blockquote>
<ul>
<li><p>声明结构体类型：只是指定了一个结构体的类型，它相当于一个模型，但其中并无具体数据，系统对之也 <strong> 不分配实际的内存单元</strong>。</p>
</li>
<li><p>定义结构体类型：使用 <code>typedef</code> 为 <code>struct</code> 声明的结构体类型起别名后，即定义了一个结构体类型，但此时 <strong> 未分配内存单元</strong>。</p>
</li>
<li><p>定义结构体变量：其中有具体的数据，也为变量分配内存单元。</p>
</li>
</ul>
<h3 id="定义与平台无关的类型"><a href="# 定义与平台无关的类型" class="headerlink" title="定义与平台无关的类型"></a>定义与平台无关的类型 </h3><p> 例如，定义一个叫 REAL 的浮点类型，在目标平台一上，让它表示最高精度的类型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> REAL;</span><br></pre></td></tr></table></figure>

<p>在不支持 <code>long double</code> 的平台二上，改为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> REAL;</span><br></pre></td></tr></table></figure>

<p>在连 <code>double</code> 都不支持的平台三上，改为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> REAL;</span><br></pre></td></tr></table></figure>

<p>也就是说，当跨平台时，只要修改 <code>typedef</code> 本身就行，不用对其他源码做任何修改。标准库就广泛使用了这个技巧，比如 <code>size_t</code>。</p>
<p>另外，因为 <code>typedef</code> 是定义了一种类型的新别名，不是简单的字符串替换，所以它比宏来得稳健（虽然有时候用宏也可以完成以上的用途）。</p>
<h3 id="为复杂的声明定义一个新的简单的别名"><a href="# 为复杂的声明定义一个新的简单的别名" class="headerlink" title="为复杂的声明定义一个新的简单的别名"></a>为复杂的声明定义一个新的简单的别名</h3><p><code>typedef</code> 为复杂的声明定义一个新的简单的别名的方法是：在原来的声明里逐步用别名替换一部分复杂声明，如此循环，把带变量名的部分留到最后替换，得到的就是原声明的最简化版。</p>
<p>示例一，原声明：<code>int *(*a[5])(int, char*)</code>，变量名为 <code>a</code>。</p>
<ol>
<li>直接用一个新别名 <code>pFun</code> 替换 <code>a</code> 就可以了，即 <code>typedef int *(*pFun)(int, char*)</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pFun a[<span class="number">5</span>];  <span class="comment">// 原声明的最简化版</span></span><br></pre></td></tr></table></figure>

<p>这里，变量 <code>a</code> 是一个数组，数组中的每个元素都是一个指向返回类型为 <code>int*</code>、参数为<code>(int, char*)</code> 的函数指针的指针。</p>
<p>示例二，原声明：<code>void (*b[10]) (void (*)())</code>，变量名为 <code>b</code>。</p>
<ol>
<li>先替换右边部分括号里的，即 <code>typedef void (*pFunParam)()</code>，其中 <code>pFunParam</code> 为别名一；</li>
<li>再替换左边的变量 <code>b</code>，即 <code>typedef void (*pFunx)(pFunParam)</code>，<code>pFunx</code> 为别名二；</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pFunx b[<span class="number">10</span>];  <span class="comment">// 原声明的最简化版</span></span><br></pre></td></tr></table></figure>

<p>这里，变量 <code>b</code> 是一个数组，数组中的每个元素都是一个指向「返回类型为<code>void</code>、参数为一个指向返回类型为<code>void</code>、没有任何参数的函数指针的指针」的指针。</p>
<p>示例三，原声明：<code>doube(*)() (*e)[9]</code>，变量名为 <code>e</code>。</p>
<ol>
<li>先替换左边部分，<code>pFuny</code> 为别名一：<code>typedef double(*pFuny)()</code></li>
<li>再替换右边的变量 <code>e</code>，<code>pFunParamy</code> 为别名二：<code>typedef pFuny (*pFunParamy)[9]</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pFunParamy e;  <span class="comment">// 原声明的最简化版</span></span><br></pre></td></tr></table></figure>

<p>这里，变量 <code>e</code> 是一个指针，<strong>指向 </strong> 一个有 9 个元素的指针数组，数组中的每个元素都是一个指向没有形参、返回值类型为 <code>double</code> 的函数指针。</p>
<blockquote>
<p>示例一与示例三是有差别的，前者是指针数组，后者是指针，只是指向的是一个指针数组。</p>
</blockquote>
<h2 id="右左原则"><a href="# 右左原则" class="headerlink" title="右左原则"></a>右左原则 </h2><p> 理解复杂声明可用的「右左法则」：从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*func)(<span class="type">int</span> *p);</span><br></pre></td></tr></table></figure>

<p>上面的示例中，</p>
<ol>
<li>首先，找到变量名 <code>func</code>，外面有一对圆括号，而且左边是一个<code>*</code> 号，这说明 <code>func</code> 是一个指针；</li>
<li>然后，跳出这个圆括号，先看右边，又遇到圆括号，这说明 <code>(*func)</code> 是一个函数，所以 <code>func</code> 是一个指向这类函数的指针，即函数指针，这类函数具有 <code>int*</code> 类型的形参，返回值类型是<code>int</code>。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*func[<span class="number">5</span>])(<span class="type">int</span> *);</span><br></pre></td></tr></table></figure>
<p>上面的示例中，</p>
<ol>
<li>首先，找到变量名 <code>func</code>，右边是一个<code>[]</code> 运算符，说明 <code>func</code> 是具有 5 个元素的数组；</li>
<li>然后，遇到圆括号了，调转阅读方向，<code>func</code>的左边有一个 <code>*</code>，说明<code>func</code> 的元素是指针（注意这里的 <code>*</code> 不是修饰 <code>func</code>，而是修饰<code>func[5]</code> 的，原因是 <code>[]</code> 运算符优先级比 <code>*</code> 高，<code>func</code>先跟 <code>[]</code> 结合）；</li>
<li>最后，跳出这个括号，看右边，又遇到圆括号，说明 <code>func</code> 数组的元素是函数类型的指针，它指向的函数具有 <code>int*</code> 类型的形参，返回值类型为<code>int</code>。</li>
</ol>
<p>也可以记住这 2 个模式：</p>
<ul>
<li><code>type (*)(....)</code> ——— 函数指针   </li>
<li><code>type (*)[]</code> ——— 数组指针</li>
</ul>
<h2 id="函数指针和数组指针示例"><a href="# 函数指针和数组指针示例" class="headerlink" title="函数指针和数组指针示例"></a>函数指针和数组指针示例 </h2><h3 id="函数指针"><a href="# 函数指针" class="headerlink" title="函数指针"></a> 函数指针 </h3><p> 函数指针是指向函数的指针变量，它可以存储函数的地址。通过函数指针可以在程序运行时动态地调用不同的函数。函数指针的声明方式为：<code>返回类型 (* 指针变量名)(参数列表)</code>。</p>
<p>以下是一个函数指针的示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*pFun)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>; <span class="comment">// 定义一个函数指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    pFun ptr = add; <span class="comment">// 指向 add 函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2 + 3 = %d\n&quot;</span>, ptr(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 调用 add 函数</span></span><br><span class="line"></span><br><span class="line">    ptr = subtract; <span class="comment">// 指向 subtract 函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;5 - 2 = %d\n&quot;</span>, ptr(<span class="number">5</span>, <span class="number">2</span>)); <span class="comment">// 调用 subtract 函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组指针"><a href="# 数组指针" class="headerlink" title="数组指针"></a>数组指针 </h3><p> 数组指针是指向数组的指针变量，它可以存储数组的地址。通过数组指针可以访问数组的元素。数组指针的声明方式为：<code>数据类型 (* 指针变量名)[数组长度]</code>。</p>
<p>以下是一个数组指针的示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*pArr)</span>[5]; <span class="comment">// 定义一个数组指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    pArr ptr = &amp;arr; <span class="comment">// 指向 arr 数组</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Array elements: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, (*ptr)[i]); <span class="comment">// 通过数组指针访问数组元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>自定义类型</tag>
        <tag>右左原则</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之 uthash 哈希表基础</title>
    <url>/posts/230922172626.html</url>
    <content><![CDATA[<p>由于 C 语言本身不存在哈希，但当需要使用哈希表的时候，自己构建又会异常复杂。因此，我们可以调用开源的第三方库 <code>uthash.h</code>，<strong>这只是一个头文件</strong>。我们需要做的就是将头文件通过 <code>#include &quot;uthash.h&quot;</code> 引入到自己的项目中。由于 <code>uthash</code> 仅是头文件，因此没有可链接的库代码。</p>
<span id="more"></span>

<h2 id="uthash 简介"><a href="#uthash 简介" class="headerlink" title="uthash 简介"></a>uthash 简介 </h2><p> 使用 <code>uthash</code> 添加、查找和删除通常是常数时间的操作，此哈希库的目标是简约、高效。它大约有 1000 行 C 代码，它会 <em> 自动内联</em>，因为它是作为宏实现的。</p>
<p><code>uthash</code> 还包括三个额外的头文件，主要提供链表、动态数组和动态字符串。</p>
<ul>
<li><code>utlist.h</code> 为 C 结构提供了链接列表宏。</li>
<li><code>utarray.h</code> 使用宏实现动态数组。</li>
<li><code>utstring.h</code> 实现基本的动态字符串。</li>
</ul>
<blockquote>
<p>内联是一种编译器优化，它将「函数调用」替换为「函数体的代码」。这样可以避免函数调用时所需的开销，从而提高性能。</p>
</blockquote>
<h2 id="uthash 的使用"><a href="#uthash 的使用" class="headerlink" title="uthash 的使用"></a>uthash 的使用 </h2><h3 id="初始化"><a href="# 初始化" class="headerlink" title="初始化"></a> 初始化 </h3><p> 这里我们将 <code>id</code> 作为一个索引值，也就是键 key，将 <code>name</code> 作为值 value，它可以是任意复杂结构。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uthash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;                    <span class="comment">/* key */</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    UT_hash_handle hh;         <span class="comment">/* makes this structure hashable */</span></span><br><span class="line">&#125; HashItem;</span><br><span class="line"></span><br><span class="line">HashItem *hashTbl = <span class="literal">NULL</span>;    <span class="comment">/* important! initialize to NULL */</span></span><br></pre></td></tr></table></figure>

<p>注意：结构中一定要包含 <code>UT_hash_handle hh</code>（<code>hh</code>不需要初始化）。它可以命名为任何名称，但是一般都命名为 <code>hh</code>。</p>
<h3 id="添加"><a href="# 添加" class="headerlink" title="添加"></a>添加</h3><ul>
<li><p><code>HASH_ADD_INT</code>：表示添加的键值为整型，参数为 <code>(head, keyfield_name, item_ptr)</code>；</p>
</li>
<li><p><code>HASH_ADD_STR</code>：表示添加的键值为字符串类型，参数为 <code>(head, keyfield_name, item_ptr)</code>；</p>
</li>
<li><p><code>HASH_ADD_PTR</code>：表示添加的键值为指针类型，参数为 <code>(head, keyfield_name, item_ptr)</code>；</p>
</li>
<li><p><code>HASH_ADD</code>：表示添加的键值可以是任意类型，参数为 <code>(hh_name, head, keyfield_name, key_len, item_ptr)</code>。</p>
</li>
</ul>
<p>这些常见的宏的参数可以看 <a href="https://troydhanson.github.io/uthash/userguide.html#_convenience_macros"> 这里 </a>，一般性的宏（如<code>HASH_ADD</code>）的参数可以看<a href="https://troydhanson.github.io/uthash/userguide.html#_general_macros"> 这里</a>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add_user</span><span class="params">(<span class="type">int</span> user_id, <span class="type">char</span> *name)</span> &#123;</span><br><span class="line">    HashItem *hashNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加前先进行重复性检查，因为当把两个相同 key 值的结构体添加到哈希表中时会报错 */</span></span><br><span class="line">    HASH_FIND_INT(hashTbl, &amp;user_id, hashNode);  <span class="comment">/* id already in the hash? */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 只有在哈希中不存在 ID 的情况下，才创建该项目并将其添加；否则，只修改已经存在的结构 */</span></span><br><span class="line">    <span class="keyword">if</span> (hashNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      hashNode = (HashItem *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashItem));</span><br><span class="line">      hashNode-&gt;id = user_id;</span><br><span class="line">      HASH_ADD_INT(hashTbl, id, hashNode);  <span class="comment">/* id: name of key field */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(hashNode-&gt;name, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>HASH_ADD_INT</code> 函数中，</p>
<ul>
<li>第一个参数 <code>hashTbl</code> 是哈希表；</li>
<li>第二个参数 <code>id</code> 是键字段的名称；</li>
<li>第三个参数 <code>hashNode</code> 是指向要添加的结构的指针。</li>
</ul>
<h3 id="将指向哈希指针的指针传递给函数（重要）"><a href="# 将指向哈希指针的指针传递给函数（重要）" class="headerlink" title="将指向哈希指针的指针传递给函数（重要）"></a>将指向哈希指针的指针传递给函数（重要）</h3><p>在上面的例子中 <code>hashTbl</code> 是一个全局变量，但是如果调用者想将哈希指针传递给函数 <code>add_user</code> 怎么办？乍一看，您似乎可以简单地将 <code>hashTbl</code> 作为参数传递，但这行不通。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_user</span><span class="params">(HashItem *obj, <span class="type">int</span> user_id, <span class="type">char</span> *name)</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  HASH_ADD_INT(obj, id, hashNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确地，你需要 <strong> 传递一个指向哈希指针的指针</strong>（a pointer to the hash pointer）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_user</span><span class="params">(HashItem **obj, <span class="type">int</span> user_id, <span class="type">char</span> *name)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  HASH_ADD_INT(*obj, id, hashNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>必须处理「指向哈希指针的指针」的原因很简单：散列宏会修改它（换句话说，它们修改指针地址本身，而不仅仅是它指向的内容）</strong>。</p>
<p>The reason it’s necessary to deal with a pointer to the hash pointer is simple: the hash macros modify it (in other words, they modify the <em>pointer itself</em> not just what it points to).</p>
<blockquote>
<p>假设哈希表 <code>hashTbl</code> 的指针（地址）是 <code>0x7fffd69b9a10</code>，那么通过运算符 <code>&amp;</code> 可以得到存放该地址的地址，假如为 <code>0x8defd69b9a26</code>，那么后续散列宏修改了哈希指针后，我们还可以通过地址 <code>0x8defd69b9a26</code> 指向的内容（哈希表的地址）来获取最新的哈希表地址。</p>
</blockquote>
<h3 id="查找"><a href="# 查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HashItem *<span class="title function_">find_user</span><span class="params">(<span class="type">int</span> user_id)</span> &#123;</span><br><span class="line">    HashItem *hashNode = <span class="literal">NULL</span>;</span><br><span class="line">    HASH_FIND_INT(hashTbl, &amp;user_id, hashNode);  <span class="comment">/* hashNode: output pointer */</span></span><br><span class="line">    <span class="keyword">return</span> hashNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>HASH_FIND_INT</code> 函数中，</p>
<ul>
<li>第一个参数 <code>hashTbl</code> 是哈希表；</li>
<li>第二个参数是 <code>user_id</code> 的地址（一定要传递地址）；</li>
<li>第三个参数 <code>hashNode</code> 是输出变量。</li>
</ul>
<p>当可以在哈希表中找到相应键值时，返回给定键的结构到 <code>hashNode</code>，当找不到时返回 <code>NULL</code> 到 <code>hashNode</code>。也就是说可以通过判断返回值是否为 <code>NULL</code> 来判断查找的键值是否存在于哈希表中。</p>
<h3 id="替换"><a href="# 替换" class="headerlink" title="替换"></a>替换</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">replace_user</span><span class="params">(HashItem *obj, HashItem *newHashNode)</span> &#123;</span><br><span class="line">    HashItem *oldHashNode = find_user(newHashNode-&gt;id);</span><br><span class="line">    <span class="keyword">if</span> (oldHashNode) &#123;</span><br><span class="line">        HASH_REPLACE_INT(hashTbl, id, newHashNode, oldHashNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>HASH_REPLACE</code> 宏等效于 <code>HASH_ADD</code> 宏，<code>HASH_REPLACE</code> 会尝试查找和删除项目，如果找到并删除了一个项目，它将返回该项目的指针作为输出参数。</p>
<h3 id="删除"><a href="# 删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delete_user</span><span class="params">(HashItem *hashNode)</span> &#123;</span><br><span class="line">    HASH_DEL(hashTbl, hashNode);  <span class="comment">/* user: pointer to delete */</span></span><br><span class="line">    <span class="built_in">free</span>(hashNode);             <span class="comment">/* optional; it&#x27;s up to you */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>要从哈希表中删除结构，必须具有指向它的指针（如果只有键值，应该先执行 <code>HASH_FIND</code> 以获取结构的指针）。</p>
</li>
<li><p>这里 <code>hashTbl</code> 是哈希表，<code>hashNode</code> 是指向我们要从哈希表中删除的结构的指针。删除结构只是将其从哈希表中删除，并非 <code>free</code>，何时释放结构的选择完全取决于自己，<code>uthash</code> 永远不会释放您的结构。</p>
</li>
</ol>
<h3 id="迭代删除"><a href="# 迭代删除" class="headerlink" title="迭代删除"></a>迭代删除 </h3><p> 上面的「删除」只能从哈希表中删除指定的一个结构，如果想将所有结构从哈希表中删除，可以使用迭代删除操作。</p>
<p><code>HASH_ITER</code> 宏是一个删除安全的迭代构造，它扩展为一个简单的 <code>for</code> 循环。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delete_all</span><span class="params">()</span> &#123;</span><br><span class="line">    HashItem *curr = <span class="literal">NULL</span>, *tmp = <span class="literal">NULL</span>;</span><br><span class="line">    HASH_ITER(hh, hashTbl, curr, tmp) &#123;</span><br><span class="line">        HASH_DEL(hashTbl, curr);  <span class="comment">/* delete; users advances to next */</span></span><br><span class="line">        <span class="built_in">free</span>(curr);               <span class="comment">/* optional- if you want to free  */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="一次性删除"><a href="# 一次性删除" class="headerlink" title="一次性删除"></a>一次性删除 </h4><p> 如果你只想删除所有的结构（哈希结点），而不释放它们的内存空间或进行任何逐个元素的清理操作，你可以使用单个操作更高效地完成这个任务。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HASH_CLEAR(hh, hashTbl);</span><br></pre></td></tr></table></figure>

<p>之后，列表头（这里是 <code>hashTbl</code>）将被设置为 <code>NULL</code>。</p>
<blockquote>
<p>在 uthash 中，ut 是 unordered tables，即无序表。</p>
<p>上面全大写的宏，为了方便，有些也被我叫成了函数。</p>
<p>上面的代码，未做充分的指针为空判断，实际使用指针前，要先进行不为空判断。</p>
</blockquote>
<h2 id="uthash 的实践"><a href="#uthash 的实践" class="headerlink" title="uthash 的实践"></a>uthash 的实践 </h2><p> 以 <a href="https://leetcode.cn/problems/two-sum/">LeetCode 两数之和 </a> 为例，介绍 <code>uthash.h</code> 哈希表的使用。</p>
<p>题目大意：从一个数组中找出两个索引不同的数，使得它们的和等于目标值，并返回这两个数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uthash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    UT_hash_handle hh;</span><br><span class="line">&#125; HashItem;</span><br><span class="line"></span><br><span class="line">HashItem *<span class="title function_">hashFindItem</span><span class="params">(HashItem **obj, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    HashItem *pEntry = <span class="literal">NULL</span>;</span><br><span class="line">    HASH_FIND_INT(*obj, &amp;key, pEntry);</span><br><span class="line">    <span class="keyword">return</span> pEntry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hashAddItem</span><span class="params">(HashItem **obj, <span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    HashItem *pEntry = hashFindItem(obj, key);</span><br><span class="line">    <span class="keyword">if</span> (pEntry == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pEntry = (HashItem *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashItem));</span><br><span class="line">        pEntry-&gt;key = key;</span><br><span class="line">        HASH_ADD_INT(*obj, key, pEntry);</span><br><span class="line">    &#125;</span><br><span class="line">    pEntry-&gt;val = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hashFree</span><span class="params">(HashItem **obj)</span> &#123;</span><br><span class="line">    HashItem *curr = <span class="literal">NULL</span>, *tmp = <span class="literal">NULL</span>;</span><br><span class="line">    HASH_ITER(hh, *obj, curr, tmp) &#123;</span><br><span class="line">        HASH_DEL(*obj, curr);  </span><br><span class="line">        <span class="built_in">free</span>(curr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *<span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    HashItem *hashTbl = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        <span class="comment">// 重要：传入的是指向哈希指针的指针</span></span><br><span class="line">        HashItem *hashNode = hashFindItem(&amp;hashTbl, nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (hashNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            hashAddItem(&amp;hashTbl, nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        HashItem *hashNode = hashFindItem(&amp;hashTbl, target - nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (hashNode &amp;&amp; hashNode-&gt;val != i) &#123;</span><br><span class="line">            *returnSize = <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> *ans = (<span class="type">int</span> *)<span class="built_in">malloc</span>((*returnSize) * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">            ans[<span class="number">0</span>] = i, ans[<span class="number">1</span>] = hashNode-&gt;val;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，我们定义了哈希表的查找、添加、释放接口，接口中的第一个参数均为指向哈希表指针的指针（二级指针），这是必须的。</p>
<ol>
<li>首先，在进行哈希操作前，先定义了一个哈希表 <code>hashTbl</code>，他是一个 <code>HashItem</code> 类型的指针；</li>
<li>然后，将数组中的键 - 值对（索引对应的值 - 索引）依次添加到哈希表中，并使用操作符 <code>&amp;</code> 获取指向哈希指针的指针；</li>
<li>最后，经过查找后，不再使用哈希表，这时通过释放接口，将哈希表中的所有哈希结点迭代地删除并释放对应的内存空间。</li>
</ol>
<p>如果哈希表的键值不是整形，而是字符类型呢，应该怎么使用呢？可以参考 <a href="https://pursue26.github.io/posts/230925185057.html#%20 哈希表实现的字典树"> 这里 </a> 的一个例子。</p>
<blockquote>
<p>源码地址：<a href="https://github.com/troydhanson/uthash">https://github.com/troydhanson/uthash</a></p>
</blockquote>
<blockquote>
<p>英文原版用户指导：<a href="https://troydhanson.github.io/uthash/userguide.html">https://troydhanson.github.io/uthash/userguide.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之大小端知识</title>
    <url>/posts/230918114841.html</url>
    <content><![CDATA[<h2 id="字节序"><a href="# 字节序" class="headerlink" title="字节序"></a>字节序 </h2><h3 id="主机字节序"><a href="# 主机字节序" class="headerlink" title="主机字节序"></a> 主机字节序 </h3><p> 在计算机中，数据在内存中的存储是以 byte 为单位的。字节序是由于 CPU 对大于一个字节的变量，在内存中的存放顺序不同而产生的。</p>
<p>不同的计算机体系结构使用不同的字节序，对于大于一个字节的变量表示，有如下两种方式：</p>
<ul>
<li><p>小端模式（Listen Endian, LE）：高位字节存储在高位地址，而低位字节存储在低位地址，与大端模式相反。</p>
</li>
<li><p>大端模式（Big Endian, BE）：高位字节存储在低位地址，而低位字节存储在高位地址。</p>
</li>
</ul>
<span id="more"></span>

<p><img src="/images/le-be-endian.png" alt="大小端模式"></p>
<p>在小端字节序主机系统中进行字节序转换时，需要将低地址的字节和高地址的字节进行交换即可得到大端字节序。</p>
<h3 id="网络字节序"><a href="# 网络字节序" class="headerlink" title="网络字节序"></a>网络字节序 </h3><p> 不同的机器主机字节序不相同，与 CPU 设计有关，数据的顺序是由 CPU 决定的，而与操作系统无关。我们把某个给定系统所用的字节序称为主机字节序（host byte order）。比如 x86 系列 CPU 都是 little-endian 的字节序。</p>
<p>网络字节序是 TCP/IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。网络字节序采用 big-endian 排序方式。</p>
<p>由于这个原因，为了确保数据在不同主机之间传输时能够被正确解释，需要在不同字节序之间进行转换，所以在网络通信中，一般需要将数据转换为网络字节序进行传输。</p>
<h2 id="主机字节序类型判断"><a href="# 主机字节序类型判断" class="headerlink" title="主机字节序类型判断"></a>主机字节序类型判断 </h2><p> 可以使用共用体（union）来判断当前 CPU 平台是大端字节序还是小端字节序。这是因为共用体的特点是：使用长度最大的数据类型作为共用体的大小。</p>
<ul>
<li><p>建立一个联合类型 <code>BYTE_ORDER_UN</code>，用于测试字节序，可以通过成员 <code>byte</code> 来访问 <code>value</code> 变量的高字节和低字节。</p>
</li>
<li><p>声明一个 <code>BYTE_ORDER_UN</code> 类型的变量 <code>unByteOrder</code>，将值 <code>0xabcd</code> 赋给成员变量 <code>value</code>。由于在类型 <code>BYTE_ORDER_UN</code> 中，<code>value</code> 和 <code>byte</code> 成员 <strong> 共享一块内存</strong>，所以可以通过 <code>byte</code> 的不同成员来访问 <code>value</code> 的高字节和低字节。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">byte_order</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> byte[<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span>)];</span><br><span class="line">&#125; BYTE_ORDER_UN;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    BYTE_ORDER_UN unByteOrder;</span><br><span class="line">    unByteOrder.value = <span class="number">0xabcd</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((unByteOrder.byte[<span class="number">0</span>] ==<span class="number">0xcd</span>) &amp;&amp; (unByteOrder.byte[<span class="number">1</span>] ==<span class="number">0xab</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Listen endian byte order, byte[0]: 0x%x, byte[1]: 0x%x\n&quot;</span>, \</span><br><span class="line">        unByteOrder.byte[<span class="number">0</span>], unByteOrder.byte[<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>((unByteOrder.byte[<span class="number">0</span>] ==<span class="number">0xab</span>) &amp;&amp; (unByteOrder.byte[<span class="number">1</span>] ==<span class="number">0xcd</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Big endian byte order, byte[0]: 0x%x, byte[1]: 0x%x\n&quot;</span>, \</span><br><span class="line">        unByteOrder.byte[<span class="number">0</span>], unByteOrder.byte[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主机系统为小端字节序的测试结果：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ gcc byteOrder.c -o byteOrder</span><br><span class="line">$ ./byteOrder</span><br><span class="line">Listen endian byte order, byte[0]: 0xcd, byte[1]: 0xab</span><br></pre></td></tr></table></figure>

<h2 id="主机字节序到网络字节序转换"><a href="# 主机字节序到网络字节序转换" class="headerlink" title="主机字节序到网络字节序转换"></a>主机字节序到网络字节序转换 </h2><p> 字节交换的作用是生成一个网络字节序的变量，<strong>其字节的顺序与主机类型和操作系统无关</strong>。进行网络字节序转换的时候，只要转换一次就可以了，不要进行多次的转换。如果进行多次字节序的转换，最后生成的网络字节序的值可能是错误的。例如：</p>
<ul>
<li><p>对于主机为小端字节序的系统，进行两次字节序转换的过程如下图所示，经过两次转换，最终的值与最初的主机字节序相同。</p>
</li>
<li><p>对于主机为大端字节序的系统，无论进行多少次字节序的转换，最终的值与最初的主机字节序相同。</p>
</li>
</ul>
<p><img src="/images/htos-conversion.png" alt="小端系统中的变量多次字节序转换"></p>
<p>下面的例子是对 16 位数值和 32 位数值进行字节序转换，每种类型的数值进行两次转换，最后打印结果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITS16 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITS32 32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">two_bytes_order</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> byte[<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">short</span>)];</span><br><span class="line">&#125; TWO_BYTES_ORDER_UN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">four_bytes_order</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> byte[<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span>)];</span><br><span class="line">&#125; FOUR_BYTES_ORDER_UN;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">showValue</span><span class="params">(<span class="type">void</span> *begin, <span class="type">int</span> flag)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ((flag) / <span class="number">8</span>); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%x (%p) &quot;</span>, *((<span class="type">unsigned</span> <span class="type">char</span> *)begin + i), (<span class="type">unsigned</span> <span class="type">char</span> *)begin + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    TWO_BYTES_ORDER_UN v16_orig, v16_turn1, v16_turn2;</span><br><span class="line">    FOUR_BYTES_ORDER_UN v32_orig, v32_turn1, v32_turn2;</span><br><span class="line"></span><br><span class="line">    v16_orig.value = <span class="number">0xabcd</span>;</span><br><span class="line">    v16_turn1.value = htons(v16_orig.value);</span><br><span class="line">    v16_turn2.value = htons(v16_turn1.value);</span><br><span class="line"></span><br><span class="line">    v32_orig.value = <span class="number">0x12345678</span>;</span><br><span class="line">    v32_turn1.value = htonl(v32_orig.value);</span><br><span class="line">    v32_turn2.value = htonl(v32_turn1.value);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;16 host to network byte order change:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\torig:    &quot;</span>);</span><br><span class="line">    showValue(v16_orig.byte, BITS16);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t1 times: &quot;</span>);</span><br><span class="line">    showValue(v16_turn1.byte, BITS16);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t2 times: &quot;</span>);</span><br><span class="line">    showValue(v16_turn2.byte, BITS16);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;32 host to network byte order change:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\torig:    &quot;</span>);</span><br><span class="line">    showValue(v32_orig.byte, BITS32);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t1 times: &quot;</span>);</span><br><span class="line">    showValue(v32_turn1.byte, BITS32);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t2 times: &quot;</span>);</span><br><span class="line">    showValue(v32_turn2.byte, BITS32);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小端模式到网络字节序转换的测试结果：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ gcc byteOrder2.c -o byteOrder2</span><br><span class="line">$ ./byteOrder2</span><br><span class="line">16 host to network byte order change:</span><br><span class="line">        orig:    cd (0x7ffcd6ad66de) ab (0x7ffcd6ad66df)</span><br><span class="line">        1 times: ab (0x7ffcd6ad66dc) cd (0x7ffcd6ad66dd)</span><br><span class="line">        2 times: cd (0x7ffcd6ad66da) ab (0x7ffcd6ad66db)</span><br><span class="line">32 host to network byte order change:</span><br><span class="line">        orig:    78 (0x7ffcd6ad66d0) 56 (0x7ffcd6ad66d1) 34 (0x7ffcd6ad66d2) 12 (0x7ffcd6ad66d3)</span><br><span class="line">        1 times: 12 (0x7ffcd6ad66c8) 34 (0x7ffcd6ad66c9) 56 (0x7ffcd6ad66ca) 78 (0x7ffcd6ad66cb)</span><br><span class="line">        2 times: 78 (0x7ffcd6ad66c0) 56 (0x7ffcd6ad66c1) 34 (0x7ffcd6ad66c2) 12 (0x7ffcd6ad66c3)</span><br></pre></td></tr></table></figure>

<p>16 位变量 0xabcd 在内存中的表示方式为 cd 在前，ab 在后；进行一次字节序转换后变为 ab 在前，cd 在后。在进行第一次转换后字节序发生了变化，而进行第二次字节序转换后与原始的排列方式一致。</p>
<h2 id="大小端的转换"><a href="# 大小端的转换" class="headerlink" title="大小端的转换"></a>大小端的转换 </h2><p> 上面的代码中 <code>htons</code> 和 <code>htonl</code>，分别给出了主机字节序到网络字节序的 <code>short</code> 和 <code>long</code> 类型的转换接口，那么这个接口是如何实现大小端转换的呢？</p>
<p><strong>通过位运算的方式来实现大小端的转换</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">little_endian_to_big_endian_4bytes</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((value &amp; <span class="number">0x000000ff</span>) &lt;&lt; <span class="number">24</span>) | </span><br><span class="line">           ((value &amp; <span class="number">0x0000ff00</span>) &lt;&lt; <span class="number">8</span>)  | </span><br><span class="line">           ((value &amp; <span class="number">0x00ff0000</span>) &gt;&gt; <span class="number">8</span>)  | </span><br><span class="line">           ((value &amp; <span class="number">0xff000000</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">little_endian_to_big_endian_2bytes</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((value &amp; <span class="number">0x00ff</span>) &lt;&lt; <span class="number">8</span>) | ((value &amp; <span class="number">0xff00</span>) &gt;&gt; <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> little_value4 = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> little_value2 = <span class="number">0xabcd</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> big_value4 = little_endian_to_big_endian_4bytes(little_value4);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> big_value2 = little_endian_to_big_endian_2bytes(little_value2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;LE2 value: 0x%04x\n&quot;</span>, little_value2);  <span class="comment">// LE2 value: 0xabcd</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;BE2 value: 0x%04x\n&quot;</span>, big_value2);  <span class="comment">// BE2 value: 0xcdab</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;LE4 value: 0x%08x\n&quot;</span>, little_value4);  <span class="comment">// LE4 value: 0x12345678</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;BE4 value: 0x%08x\n&quot;</span>, big_value4);  <span class="comment">// BE4 value: 0x78563412</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多变量存储在连续内存中的字节序转换"><a href="# 多变量存储在连续内存中的字节序转换" class="headerlink" title="多变量存储在连续内存中的字节序转换"></a>多变量存储在连续内存中的字节序转换 </h2><p> 示例 1：一个 2 字节变量存储在连续的内存中，与一个 4 字节变量存储在连续的内容中，从小端主机字节序转换为大端网络字节序后的结果一样吗？一样的！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">four_bytes_order</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> val1;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> val2;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> val3;</span><br><span class="line">&#125; FOUR_BYTES_ORDER_S;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITS16 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITS32 32</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">showValue</span><span class="params">(<span class="type">void</span> *begin, <span class="type">int</span> flag)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ((flag) / <span class="number">8</span>); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%x (%p) &quot;</span>, *((<span class="type">unsigned</span> <span class="type">char</span> *)begin + i), (<span class="type">unsigned</span> <span class="type">char</span> *)begin + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    FOUR_BYTES_ORDER_S sOrig, sTurn;</span><br><span class="line">    </span><br><span class="line">    sOrig.val1 = <span class="number">0x1234</span>;</span><br><span class="line">    sOrig.val2 = <span class="number">0x5678</span>;</span><br><span class="line">    sTurn.val1 = htons(sOrig.val1);</span><br><span class="line">    sTurn.val2 = htons(sOrig.val2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;16 + 16 host to network byte order change:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\thost:    &quot;</span>);</span><br><span class="line">    showValue(&amp;sOrig.val1, BITS32);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\tnetwork: &quot;</span>);</span><br><span class="line">    showValue(&amp;sTurn.val1, BITS32);</span><br><span class="line"></span><br><span class="line">    sOrig.val3 = <span class="number">0x12345678</span>;</span><br><span class="line">    sTurn.val3 = htonl(sOrig.val3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;32 host to network byte order change:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\thost:    &quot;</span>);</span><br><span class="line">    showValue(&amp;sOrig.val3, BITS32);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\tnetwork: &quot;</span>);</span><br><span class="line">    showValue(&amp;sTurn.val3, BITS32);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上述连续内存的两个 2 字节变量和一个 4 字节变量，转换成的网络字节序都是 <code>0x12345678</code>：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ gcc byteOrder2.c -o byteOrder3</span><br><span class="line">$ ./byteOrder3</span><br><span class="line">16 + 16 host to network byte order change:</span><br><span class="line">        host:    34 (0x7fffd69b9a10) 12 (0x7fffd69b9a11) 78 (0x7fffd69b9a12) 56 (0x7fffd69b9a13)</span><br><span class="line">        network: 12 (0x7fffd69b9a00) 34 (0x7fffd69b9a01) 56 (0x7fffd69b9a02) 78 (0x7fffd69b9a03)</span><br><span class="line">32 host to network byte order change:</span><br><span class="line">        host:    78 (0x7fffd69b9a18) 56 (0x7fffd69b9a19) 34 (0x7fffd69b9a1a) 12 (0x7fffd69b9a1b)</span><br><span class="line">        network: 12 (0x7fffd69b9a08) 34 (0x7fffd69b9a09) 56 (0x7fffd69b9a0a) 78 (0x7fffd69b9a0b)</span><br></pre></td></tr></table></figure>

<p>示例 2：一个变量 <code>0x12345678abcd9876</code>，分别以 <code>short + long + short</code> 和 <code>long + long</code> 变量存储在一个连续内容中，那么两种存储的小端主机字节序和大端网络字节序在内存中的存储的值顺序一致吗？一致的！</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">val_le = 0x12345678abcd9876</span><br><span class="line"></span><br><span class="line">short + long + short</span><br><span class="line">    a = 0x1234</span><br><span class="line">    b = 0x5678abcd</span><br><span class="line">    c = 0x9876</span><br><span class="line"></span><br><span class="line">分别给出其主机序和网络序：</span><br><span class="line">    内存低地址 -----------------------&gt; 内存高地址 </span><br><span class="line">    小端主机序：34 12 | cd ab 78 56 | 76 98</span><br><span class="line">    大端网络序：12 34 | 56 78 ab cd | 98 76</span><br><span class="line"></span><br><span class="line">long + long</span><br><span class="line">    d = 0x12345678</span><br><span class="line">    e = 0xabcd9876</span><br><span class="line"></span><br><span class="line"> 分别给出其主机序和网络序：</span><br><span class="line">    内存低地址 -----------------------&gt; 内存高地址</span><br><span class="line">    主机序：78 56 34 12 | 76 98 cd ab</span><br><span class="line">    网络序：12 34 56 78 | ab cd 98 76</span><br></pre></td></tr></table></figure>

<p>可以看出, 两种组合变量的主机序到网络序转换后的结果是一致的！</p>
<blockquote>
<p>参考：</p>
<ol>
<li><a href="https://blog.51cto.com/u_15249901/4893764">https://blog.51cto.com/u_15249901/4893764</a></li>
<li><a href="https://blog.csdn.net/Jmilk/article/details/106898871">https://blog.csdn.net/Jmilk/article/details/106898871</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>大小端</tag>
        <tag>字节序</tag>
        <tag>网络字节序</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之锁与原子操作基础</title>
    <url>/posts/230921094127.html</url>
    <content><![CDATA[<h2 id="常见锁介绍"><a href="# 常见锁介绍" class="headerlink" title="常见锁介绍"></a>常见锁介绍 </h2><p> 在 C 语言中，常见的用于解决多线程访问数据的锁包括互斥锁、读写锁、条件变量、自旋锁、屏蔽等。</p>
<span id="more"></span>

<ol>
<li><p>互斥锁（mutex）：互斥锁是一种 <strong> 最基本的锁机制 </strong>，用于<strong> 保护共享资源</strong>，防止多个线程同时访问和修改同一个资源。当一个线程持有了互斥锁后，其他线程需要等待该线程释放锁之后才能访问共享资源。</p>
</li>
<li><p>读写锁（read-write lock）：读写锁是一种 <strong> 特殊的锁机制 </strong>，它允许多个线程同时读取共享资源，但是<strong> 只允许一个线程写入共享资源</strong>。这种锁可以提高读取操作的并发度，同时保证写入操作的正确性和一致性。如果一个线程获取了写锁，其他线程就必须等待它释放锁后才能继续访问；如果一个线程获取了读锁，其他线程也可以获取读锁并访问资源。</p>
</li>
<li><p>条件变量（condition variable）：条件变量是一种 <strong> 用于线程之间通信的同步机制</strong>，它允许线程在某个条件成立时才能继续执行。通常与互斥锁一起使用，当条件变量不满足时，线程释放互斥锁并等待条件变量被激活（通过另一个线程来激活条件变量）；当条件变量满足时，通知线程重新获取互斥锁并继续执行。</p>
</li>
<li><p>自旋锁（spinlock）：自旋锁是一种 <strong> 忙等待锁机制 </strong>，当一个线程尝试获取锁时，如果锁已经被占用，它会一直循环等待直到锁被释放。<strong> 自旋锁适用于锁的持有时间很短的情况</strong>，因为长时间占用 CPU 会影响系统性能。</p>
</li>
<li><p>屏障（barrier）：屏障是一种 <strong> 用于多线程协同的同步机制 </strong>，它允许多个线程在某个点上等待，直到所有线程都到达该点后再继续执行。屏障通常用于<strong> 一组线程 </strong> 需要在某个点进行 <strong> 同步操作 </strong> 的情况，例如多线程排序算法。</p>
</li>
</ol>
<blockquote>
<p>需要根据具体的应用场景选择合适的锁。</p>
</blockquote>
<h2 id="互斥锁"><a href="# 互斥锁" class="headerlink" title="互斥锁"></a>互斥锁 </h2><p> 互斥锁原理：互斥锁属于 sleep-waiting 类型的锁。例如，在一个双核的机器上有两个线程（线程 A 和线程 B），它们分别运行在 Core0 和 Core1 上。假设线程 A 想要通过 <code>pthread_mutex_lock</code> 操作去得到一个临界区的锁，而此时这个锁正被线程 B 所持有，那么线程 A 就会被阻塞，Core0 会在此时进行上下文切换（Context Switch）将线程 A<strong>置于等待队列中</strong>，此时 Core0 就可以运行其它的任务而不必进行忙等待。</p>
<p>互斥锁的实现：通常使用了操作系统提供的原子操作或者硬件提供的锁机制，保证锁的正确性和高效性。</p>
<p>互斥锁有两种类型：递归锁和非递归锁。递归锁允许同一线程在不释放锁的情况下多次获取锁，而非递归锁不允许这种情况发生。</p>
<p>互斥锁使用场景：因互斥锁会引起线程的切换，效率较低；使用互斥锁会引起线程阻塞等待，不会一直占用着 CPU。因此，当锁的内容较多、切换不频繁时，建议使用互斥锁。</p>
<p>互斥锁使用笔记：互斥锁的使用非常简单，主要包括以下几个步骤：</p>
<ul>
<li>定义互斥锁变量，一般使用 <code>pthread_mutex_t</code> 类型；</li>
<li>在需要保护的代码段前调用 <code>pthread_mutex_lock</code> 函数获取锁；</li>
<li>在代码段执行完毕后调用 <code>pthread_mutex_unlock</code> 函数释放锁；</li>
<li>释放锁之后其他线程就可以获取锁并访问共享资源。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化互斥锁</span></span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在需要保护的代码块前加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="comment">// 访问共享资源</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 访问完毕后解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在使用完互斥锁后销毁</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br></pre></td></tr></table></figure>

<h2 id="读写锁"><a href="# 读写锁" class="headerlink" title="读写锁"></a>读写锁 </h2><p> 读写锁的实现：通常使用了计数器和互斥锁等机制，通过控制读写访问的次数和顺序来保证数据的正确性和一致性。</p>
<p>读写锁使用笔记：读写锁的使用也非常简单，主要包括以下几个步骤：</p>
<ul>
<li>定义读写锁变量，一般使用 <code>pthread_rwlock_t</code> 类型；</li>
<li>在需要读取共享资源的代码段前调用 <code>pthread_rwlock_rdlock</code> 函数获取读锁；</li>
<li>在需要写入共享资源的代码段前调用 <code>pthread_rwlock_wrlock</code> 函数获取写锁；</li>
<li>在代码段执行完毕后调用 <code>pthread_rwlock_unlock</code> 函数释放锁；</li>
<li>释放锁之后其他线程就可以获取锁并访问共享资源。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock = PTHREAD_RWLOCK_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化读写锁</span></span><br><span class="line">pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在需要读取共享资源的代码块前加读锁</span></span><br><span class="line">pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line"><span class="comment">// 读取共享资源</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 读取完毕后释放读锁</span></span><br><span class="line">pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在需要写入共享资源的代码块前加写锁</span></span><br><span class="line">pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line"><span class="comment">// 写入共享资源</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 写入完毕后释放写锁</span></span><br><span class="line">pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在使用完读写锁后销毁</span></span><br><span class="line">pthread_rwlock_destroy(&amp;rwlock);</span><br></pre></td></tr></table></figure>

<h2 id="自旋锁"><a href="# 自旋锁" class="headerlink" title="自旋锁"></a>自旋锁 </h2><p> 自旋锁原理：自旋锁属于 busy-waiting 类型的锁。例如，在一个双核的机器上有两个线程（线程 A 和线程 B），它们分别运行在 Core0 和 Core1 上。如果线程 A 是使用 <code>pthread_spin_lock</code> 操作去请求锁，那么线程 A 就会一直在 Core0 上进行忙等待并 <strong> 不停的进行 </strong> 锁请求，直到得到这个锁为止。自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就 <strong> 一直循环 </strong> 在那里看是否该自旋锁的保持者已经释放了锁。</p>
<p>自旋锁使用场景：</p>
<ul>
<li><p>自旋锁的作用是为了解决某项资源的 <strong> 互斥使用</strong>。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁。因此，如果锁的内容较少、阻塞的时间较短，使用自旋锁比较好。</p>
</li>
<li><p>自旋锁在未获得锁的情况下，一直运行（自旋），占用着 CPU，如果不能在很短的时间内获得锁，这无疑会使 CPU 效率降低。因此，要慎重使用自旋锁，<strong>自旋锁只有在内核可抢占式或 SMP 的情况下才真正需要</strong>。在单 CPU 且不可抢占式的内核下，自旋锁的操作为空操作。自旋锁适用于锁使用者保持锁时间比较短的情况下。</p>
</li>
</ul>
<p>自旋锁使用笔记：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义自旋锁</span></span><br><span class="line"><span class="type">pthread_spinlock_t</span> spinlock = PTHREAD_PROCESS_PRIVATE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化自旋锁</span></span><br><span class="line">pthread_spin_init(&amp;spinlock, PTHREAD_PROCESS_PRIVATE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁，如果锁已被其他线程占用，则该函数会一直循环忙等待直到获取到锁</span></span><br><span class="line">pthread_spin_lock(&amp;spinlock);</span><br><span class="line"><span class="comment">// 访问共享资源</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 解锁，使其他线程可以获取锁并访问共享资源</span></span><br><span class="line">pthread_spin_unlock(&amp;spinlock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁自旋锁</span></span><br><span class="line">pthread_spin_destroy(&amp;lock);</span><br></pre></td></tr></table></figure>

<h2 id="条件变量"><a href="# 条件变量" class="headerlink" title="条件变量"></a>条件变量 </h2><p> 条件变量（condition variable）：条件变量是一种 <strong> 用于线程之间通信的同步机制</strong>，它允许线程在某个条件成立时才能继续执行。通常与互斥锁一起使用，当条件变量不满足时，线程释放互斥锁并等待条件变量被激活（通过另一个线程来激活条件变量）；当条件变量满足时，通知线程重新获取互斥锁并继续执行。</p>
<p>条件变量使用笔记：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义互斥锁和定义条件变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化条件变量和自旋锁</span></span><br><span class="line">pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (条件不满足预期条件) &#123;</span><br><span class="line">    <span class="comment">// 等待条件变量通知</span></span><br><span class="line">    pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件满足，访问共享资源</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在使用完条件变量后销毁</span></span><br><span class="line">pthread_cond_destroy(&amp;cond);</span><br><span class="line"><span class="comment">// 在使用完互斥锁后销毁</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在其他线程中通知条件变量</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="comment">// 访问共享资源</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 解锁后再发送通知</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件满足，发送条件变量通知</span></span><br><span class="line">pthread_cond_signal(&amp;cond);</span><br></pre></td></tr></table></figure>

<h3 id="生产消费者同步示例代码"><a href="# 生产消费者同步示例代码" class="headerlink" title="生产消费者同步示例代码"></a>生产消费者同步示例代码 </h3><p> 一个生产者、消费者同步的多线程示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE (4)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> buffer[BUFFER_SIZE];</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 预期条件是 buffer 不能满（当 buffer 满时为条件不满足预期）</span></span><br><span class="line">        <span class="keyword">while</span> (count == BUFFER_SIZE) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        buffer[count++] = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Producer produced: %d\n&quot;</span>, i);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        pthread_cond_signal(&amp;cond);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 预期条件是 buffer 不能空（当 buffer 空时为条件不满足预期）</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> value = buffer[--count];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Consumer consumed: %d\n&quot;</span>, value);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        pthread_cond_signal(&amp;cond);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> producer_thread, consumer_thread;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;producer_thread, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;consumer_thread, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(producer_thread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(consumer_thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例代码中，有一个容量为 4 的缓冲区，生产者线程负责往缓冲区中添加数据，消费者线程负责从缓冲区中取出数据。使用互斥锁和条件变量来保证生产者和消费者的同步。</p>
<p>生产者线程通过加锁后检查缓冲区是否已满，如果已满则等待条件变量通知，否则将数据添加到缓冲区，并发送条件变量通知消费者线程。消费者线程通过加锁后检查缓冲区是否为空，如果为空则等待条件变量通知，否则从缓冲区中取出数据，并发送条件变量通知生产者线程。</p>
<blockquote>
<p>注意，生产者和消费者线程之间的同步是通过互斥锁和条件变量来实现的。互斥锁用于保护共享资源，条件变量用于线程间的通信和同步。</p>
</blockquote>
<p>一种可能的运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Producer produced (from buffer index: 0): 0</span><br><span class="line">Producer produced (from buffer index: 1): 1</span><br><span class="line">Consumer consumed (from buffer index: 1): 1</span><br><span class="line">Consumer consumed (from buffer index: 0): 0</span><br><span class="line">Producer produced (from buffer index: 0): 2</span><br><span class="line">Producer produced (from buffer index: 1): 3</span><br><span class="line">Producer produced (from buffer index: 2): 4</span><br><span class="line">Consumer consumed (from buffer index: 2): 4</span><br><span class="line">Consumer consumed (from buffer index: 1): 3</span><br><span class="line">Consumer consumed (from buffer index: 0): 2</span><br><span class="line">[root@localhost del]#</span><br><span class="line">[root@localhost del]# ./a.out</span><br><span class="line">Producer produced (from buffer index: 0): 0</span><br><span class="line">Producer produced (from buffer index: 1): 1</span><br><span class="line">Producer produced (from buffer index: 2): 2</span><br><span class="line">Producer produced (from buffer index: 3): 3</span><br><span class="line">Consumer consumed (from buffer index: 3): 3</span><br><span class="line">Consumer consumed (from buffer index: 2): 2</span><br><span class="line">Consumer consumed (from buffer index: 1): 1</span><br><span class="line">Consumer consumed (from buffer index: 0): 0</span><br><span class="line">Producer produced (from buffer index: 0): 4</span><br><span class="line">Consumer consumed (from buffer index: 0): 4</span><br><span class="line">[root@localhost del]#</span><br></pre></td></tr></table></figure>

<h2 id="屏障"><a href="# 屏障" class="headerlink" title="屏障"></a>屏障 </h2><p> 屏障（barrier）：屏障是一种 <strong> 用于多线程协同的同步机制 </strong>，它允许多个线程在某个点上等待，直到所有线程都到达该点后再继续执行。屏障通常用于<strong> 一组线程 </strong> 需要在某个点进行 <strong> 同步操作 </strong> 的情况，例如多线程排序算法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义屏障</span></span><br><span class="line"><span class="type">pthread_barrier_t</span> barrier;</span><br><span class="line"><span class="type">int</span> thread_nums = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化屏障</span></span><br><span class="line">pthread_barrier_init(&amp;barrier, <span class="literal">NULL</span>, thread_nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在每个线程中执行以下代码</span></span><br><span class="line">pthread_barrier_wait(&amp;barrier); <span class="comment">// 等待屏障</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有线程都到达屏障后，继续执行以下代码</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在使用完屏障后销毁</span></span><br><span class="line">pthread_barrier_destroy(&amp;barrier);</span><br></pre></td></tr></table></figure>

<h3 id="屏蔽实现线程同步示例代码"><a href="# 屏蔽实现线程同步示例代码" class="headerlink" title="屏蔽实现线程同步示例代码"></a>屏蔽实现线程同步示例代码 </h3><p> 下面是一个完整的示例代码，演示了如何使用 <code>pthread</code> 库中的屏障实现线程同步：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义屏障</span></span><br><span class="line"><span class="type">pthread_barrier_t</span> barrier;</span><br><span class="line"><span class="type">int</span> thread_nums = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 线程执行的一些操作...</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld operation\n&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待屏障</span></span><br><span class="line">    pthread_barrier_wait(&amp;barrier);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有线程都到达屏障后，继续执行以下代码</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld continues after the barrier\n&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程执行的其他操作...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[thread_nums];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化屏障</span></span><br><span class="line">    pthread_barrier_init(&amp;barrier, <span class="literal">NULL</span>, thread_nums);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; thread_nums; i++) &#123;</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, thread_func, (<span class="type">void</span>*)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_nums; i++) &#123;</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁屏障</span></span><br><span class="line">    pthread_barrier_destroy(&amp;barrier);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例代码中，我们定义了一个屏障 <code>pthread_barrier_t</code> 和一个线程数 <code>thread_nums</code>。在主函数中，</p>
<ul>
<li>首先调用 <code>pthread_barrier_init</code> 函数初始化屏障。</li>
<li>然后，创建指定数量的线程，并通过 <code>pthread_create</code> 函数将线程函数 <code>thread_func</code> 分配给每个线程。</li>
<li>在线程函数中，线程首先执行一些操作，然后调用 <code>pthread_barrier_wait</code> 函数等待屏障。<strong>当所有线程都到达屏障后，屏障解除，所有线程继续执行后续的代码</strong>。</li>
<li>最后，我们使用 <code>pthread_join</code> 等待所有线程结束，并使用 <code>pthread_barrier_destroy</code> 销毁屏障。</li>
</ul>
<h2 id="原子操作"><a href="# 原子操作" class="headerlink" title="原子操作"></a>原子操作 </h2><p> 所谓原子操作，就是该操作绝不会在执行完毕前被任何其他任务或事件打断，也就说，它是 <strong> 最小的执行单位</strong>，不可能有比它更小的执行单位。因此这里的原子实际是使用了物理学里的物质微粒的概念。</p>
<p>原子操作需要硬件的支持，因此是架构相关的，其 API 和原子类型的定义都定义在内核源码树的 <code>include/asm/atomic.h</code> 文件中，它们 <strong> 都使用汇编语言实现，因为 C 语言并不能实现这样的操作</strong>。</p>
<p>原子操作主要用于实现资源计数，很多引用计数（Reference Count, refcnt）就是通过原子操作实现的。</p>
<h2 id="总结分析"><a href="# 总结分析" class="headerlink" title="总结分析"></a>总结分析 </h2><p> 互斥锁（Mutex lock），sleep-waiting 类型的锁：与自旋锁相比它需要消耗大量的系统资源来建立锁；随后当线程被阻塞等待时，线程的调度状态被修改，并且线程被加入等待线程队列；最后当锁可用时，在获取锁之前，线程会被从等待队列取出并更改其调度状态；但是在线程被阻塞期间，它不消耗 CPU 资源。</p>
<p>互斥锁适用于那些可能会阻塞很长时间的场景：</p>
<ul>
<li>临界区有 IO 操作</li>
<li>临界区代码复杂或者循环量大</li>
<li>临界区竞争非常激烈</li>
<li>单核处理器</li>
</ul>
<p>自旋锁（Spin lock），busy-waiting 类型的锁：对于自旋锁来说，它只需要消耗很少的资源来建立锁；随后当线程被阻塞时，它就会一直重复检查看锁是否可用了，也就是说当自旋锁处于等待状态时它会一直消耗 CPU 时间。  </p>
<p>自旋锁适用于那些仅需要阻塞很短时间的场景。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>锁</tag>
        <tag>原子操作</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 笔记之函数 &amp; 包 &amp; 判断 &amp; 循环</title>
    <url>/posts/230909120145.html</url>
    <content><![CDATA[<h2 id="Go 语言学习笔记 -5：函数"><a href="#Go 语言学习笔记 -5：函数" class="headerlink" title="Go 语言学习笔记 -5：函数"></a>Go 语言学习笔记 -5：函数</h2><ol>
<li>函数声明语法：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functionname</span><span class="params">(parametername1 <span class="keyword">type</span>, parametername2 <span class="keyword">type</span>)</span></span> returntype &#123;  </span><br><span class="line">    <span class="comment">// 函数体（具体实现的功能）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>如果有连续若干个参数，它们的类型一致，那么我们无须一一罗列，只需在最后一个参数后添加该类型。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functionname</span><span class="params">(parametername1, parametername2 <span class="keyword">type</span>)</span></span> returntype &#123;  </span><br><span class="line">    <span class="comment">// 函数体（具体实现的功能）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Go 语言支持一个函数可以有 <strong> 多个返回值</strong>。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functionname</span><span class="params">(para1 type1, para2 type2)</span></span> (returntype1, returntype2, ...) &#123;</span><br><span class="line">    <span class="comment">// 函数体（具体实现的功能）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<ol start="4">
<li><strong>命名返回值 </strong>：从函数中可以返回一个命名值。一旦命名了返回值，可以认为<strong> 这些值在函数第一行就被声明为变量了</strong>，在函数 return 时不必再跟随命名值。如<code>area, perimeter</code>：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rectProps</span><span class="params">(length, width <span class="type">float64</span>)</span></span> (area, perimeter <span class="type">float64</span>) &#123;  </span><br><span class="line">    area = length * width</span><br><span class="line">    perimeter = (length + width) * <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// 不需要明确指定返回值，默认返回 area, perimeter 的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>空白符</strong>：<code>_</code> 在 Go 中被用作空白符，可以用作表示任何类型的任何值。</li>
</ol>
<p><code>area, _ := rectProps(10.8, 5.6) // 返回值周长被丢弃</code>。</p>
<hr>
<h2 id="Go 语言学习笔记 -6：包"><a href="#Go 语言学习笔记 -6：包" class="headerlink" title="Go 语言学习笔记 -6：包"></a>Go 语言学习笔记 -6：包</h2><ol>
<li><p><code>package packagename</code> 指定了某一源文件属于一个包，它应该放在每一个源文件的第一行。</p>
</li>
<li><p><code>main</code> 包和自定义包目录结构（属于某一个包的源文件都应该放置于一个单独命名的文件夹里，且应该用包名命名文件夹名）：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">    geometry  <span class="comment">// 自定义 main 包</span></span><br><span class="line">        geometry.<span class="keyword">go</span> <span class="comment">// main 函数</span></span><br><span class="line">        rectangle <span class="comment">// 自定义包，文件名为包名</span></span><br><span class="line">            rectprops.<span class="keyword">go</span> <span class="comment">// 属于 rectangle 包的源文件</span></span><br><span class="line">bin</span><br><span class="line">    <span class="comment">// 通过执行 go build geometry/geometry.go 编译得到 </span></span><br><span class="line">    geometry (Linux)</span><br><span class="line">    geometry.exe (Windows)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>导入自定义包：<code>import packagepath</code>，必须指定自定义包 <code>packagename</code> 相对于工作区 <code>src</code> 文件夹的相对路径，如：<code>import &quot;geometry/rectangle&quot;</code>。</p>
</li>
<li><p>导出名字：在 Go 中，任何 <strong> 以大写字母开头的变量或者函数都是被导出的名字，其它包只能访问被导出的函数和变量</strong>（即，如果想在包外访问一个函数，它应该首首字母大写）。</p>
</li>
<li><p><code>init</code> 函数：所有包都可以包含一个 <code>init</code> 函数，<code>init</code> 函数不应该有任何返回值类型和参数。</p>
</li>
</ol>
<ul>
<li><p>包的初始化顺序：1）首先初始化 <strong> 被导入的 </strong> 包；2）然后初始化 <strong> 包级别（package level）的变量 </strong>；3）紧接着<strong> 调用 <code>init</code> 函数</strong>，按照编译器解析它们的顺序进行调用。</p>
</li>
<li><p>如果一个包导入了另一个包，会先初始化 <strong> 被导入的 </strong> 包。</p>
</li>
<li><p>尽管一个包可能会被导入多次，但是它们只会被初始化一次。</p>
</li>
</ul>
<ol start="6">
<li>空白标识符导入包中的使用：导入了包，却不在代码中使用它，这在 Go 中是非法的，会抛出 <code>xxx.go:6: imported and not used: packagename_yyy</code>。</li>
</ol>
<ul>
<li><p>为了避免这种程序错误，通常会在函数外调用其中的一个函数，并将返回值赋给 <code>_</code> 变量，把这一操作称为 <code> 错误屏蔽器</code>。</p>
</li>
<li><p>同时，有时我们并不想使用导入的包中的任一函数或变量，只是为了 <strong> 确保它进行初始化</strong>，这种情况可以使用空白标识符 <code>_</code>，如 <code>import _ &quot;geometry/rectangle&quot;</code>。这样在不调用包中的函数或变量时，也不会报错。</p>
</li>
</ul>
<hr>
<h2 id="Go 语言学习笔记 -7：if-else"><a href="#Go 语言学习笔记 -7：if-else" class="headerlink" title="Go 语言学习笔记 -7：if-else"></a>Go 语言学习笔记 -7：if-else</h2><ol>
<li>即使 <code>if</code> 状态下仅有一条语句，也必须加 <code>&#123; &#125;</code></li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> condition &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>if</code> 还有另外一种形式，它包含一个 <code>statement</code> 可选语句部分，该组件在条件判断之前运行，语法为：<code>if statement; condition &#123;  &#125;</code>，其中 <code>statement</code> 的作用域仅在 <code>if-else</code> 范围内。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; <span class="comment">// num 的范围仅限于 if else 代码块</span></span><br><span class="line">  <span class="keyword">if</span> num:= <span class="number">10</span>; num % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">    fmt.Println(num, <span class="string">&quot;is even.&quot;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(num, <span class="string">&quot;is odd.&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>一个注意点</strong>：<code>else</code> 必须键入在 <code>&#125;</code> 后面，不能另取一行键入，因为 Go 语言默认在每条语句结束时插入一个分号，但 <code>if else</code> 是一个整体。</li>
</ol>
<h2 id="Go 语言学习笔记 -8：循环"><a href="#Go 语言学习笔记 -8：循环" class="headerlink" title="Go 语言学习笔记 -8：循环"></a>Go 语言学习笔记 -8：循环</h2><ol>
<li>Go 语言中唯一的循环语句是 <code>for</code>，没有 <code>while</code> 和 <code>do while</code> 循环。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> initialisation; condition; post &#123;  </span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>for</code> 循环的三个组成部分，即初始化，条件和 post 都是可选的（可有可无），如：<code>for ;i &lt;= 10; &#123;...&#125;</code>、<code>for &#123;...&#125;</code> 或 <code>for i &lt;= 10 &#123;... i += 2&#125;</code>，即 <code>;</code> 也是可以省略的。</li>
</ul>
<ol start="2">
<li><code>break</code> 为跳出循环，<code>continue</code> 为不执行后续语句，进入下一次循环。</li>
</ol>
<hr>
<h2 id="Go 语言学习笔记 -9：switch 语句"><a href="#Go 语言学习笔记 -9：switch 语句" class="headerlink" title="Go 语言学习笔记 -9：switch 语句"></a>Go 语言学习笔记 -9：switch 语句</h2><ol>
<li><code>switch</code>是一个条件语句，它可以被认为是替代多个 <code>if else</code> 子句的常用方式，<code>case</code> 不允许出现重复项。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    finger := <span class="number">4</span></span><br><span class="line">    <span class="keyword">switch</span> finger &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;Thumb&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;Index&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;Middle&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>, <span class="number">5</span>: <span class="comment">// 一个选项多个表达式</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;Ring or Pinky&quot;</span>)</span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">// 默认情况</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;incorrect finger number&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>先声明变量再使用</strong>：<code>switch varname := xxx; varname &#123;...&#125;</code>，此时的 <code>varname</code> 变量的作用域仅限于当前 <code>switch</code> 内。</p>
</li>
<li><p><strong>无表达式的 <code>switch</code></strong>：在 switch 语句中，表达式是可选的，可以被省略。如果省略表达式，则表示这个 switch 语句 <strong> 等同于 switch true</strong>，并且 <strong> 每个 case 表达式都被认定为有效，相应的代码块也会被执行</strong>。</p>
</li>
<li><p><strong>fallthrough</strong>：fallthrough 语句可以在已经执行完成的 case 之后，把控制权转移到下一个 case 的执行代码中，而不会跳出 switch。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> num := <span class="number">3</span>; &#123;</span><br><span class="line">        <span class="keyword">case</span> num == <span class="number">3</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;==&quot;</span>)</span><br><span class="line">            <span class="keyword">fallthrough</span></span><br><span class="line">        <span class="keyword">case</span> num &lt; <span class="number">10</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;yes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>switch 和 case 的表达式不一定是常量。</li>
</ol>
<blockquote>
<p>学习链接：<a href="https://studygolang.com/subject/2">https://studygolang.com/subject/2</a>，感谢如此优秀的教程！</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go函数</tag>
        <tag>Go判断</tag>
        <tag>Go循环</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 笔记之可变参数函数与 Map 集合</title>
    <url>/posts/230913161326.html</url>
    <content><![CDATA[<h2 id="Go 语言学习笔记 -12：可变参数函数"><a href="#Go 语言学习笔记 -12：可变参数函数" class="headerlink" title="Go 语言学习笔记 -12：可变参数函数"></a>Go 语言学习笔记 -12：可变参数函数</h2><ol>
<li><p>可变参数函数是一种 <strong> 参数个数可变 </strong> 的函数。如果函数最后一个参数的类型被记作 <code>...T</code> ，这时函数可以接受任意个 <code>T</code> 类型的参数作为最后一个参数。<strong>只有 </strong> 函数的最后一个参数才允许是可变的。</p>
</li>
<li><p>可变参数函数的 <strong> 工作原理 </strong> 是把可变参数转换为一个新的 <strong> 切片</strong>。</p>
</li>
<li><p>有一个可以直接将切片传入可变参数函数的语法糖，你可以在切片后加上 <code>...</code> 后缀。这样切片将直接传入函数，不再创建新的切片。</p>
</li>
</ol>
<span id="more"></span>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">find</span><span class="params">(num <span class="type">int</span>, nums ...<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    find(<span class="number">89</span>, <span class="number">88</span>, <span class="number">89</span>, <span class="number">90</span>) <span class="comment">// 语法正确，[88, 89, 90] 将被转换为一个新的切片传入 find 函数</span></span><br><span class="line">    find(<span class="number">89</span>) <span class="comment">// 语法正确, 一个长度和容量为 0 的 nil 切片将被传入 find 函数</span></span><br><span class="line">    nums := []<span class="type">int</span>&#123;<span class="number">87</span>, <span class="number">88</span>, <span class="number">89</span>&#125;</span><br><span class="line">    find(<span class="number">89</span>, nums) <span class="comment">// 语法错误，find 的可变参数要求为 int 型，不能传入 []int 切片</span></span><br><span class="line">    find(<span class="number">89</span>, nums...) <span class="comment">// 语法正确，切片直接传入函数，不再创建新的切片</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Go 语言学习笔记 -13：Maps"><a href="#Go 语言学习笔记 -13：Maps" class="headerlink" title="Go 语言学习笔记 -13：Maps"></a>Go 语言学习笔记 -13：Maps</h2><ol>
<li><p>map 是在 Go 中将值（value）与键（key）关联的 <strong> 内置类型</strong>。通过相应的键可以获取到值。</p>
</li>
<li><p>通过向 <code>make</code> 函数传入键和值的类型，可以创建 map。<code>make(map[type of key]type of value)</code> 是创建 map 的语法。如：<code>personSalary := make(map[string]int)</code>。</p>
</li>
<li><p>map 的零值是 <code>nil</code>。如果你想添加元素到 nil map 中，会触发运行时 <code>panic</code>。因此 <strong>map 必须使用 <code>make</code> 函数初始化</strong>。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> personSalary <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> personSalary == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;map is nil. Going to make one.&quot;</span>)</span><br><span class="line">        personSalary = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>) <span class="comment">// 使用 make 方法初始化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    personSalary[<span class="string">&quot;steve&quot;</span>] = <span class="number">12000</span> <span class="comment">// 给 map 添加新元素</span></span><br><span class="line">    personSalary[<span class="string">&quot;jamie&quot;</span>] = <span class="number">15000</span></span><br><span class="line">    personSalary[<span class="string">&quot;mike&quot;</span>] = <span class="number">9000</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;personSalary map contents:&quot;</span>, personSalary) <span class="comment">// map[steve:12000 jamie:15000 mike:9000]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在声明时初始化 map：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">personSalary := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> &#123;</span><br><span class="line">        <span class="string">&quot;steve&quot;</span>: <span class="number">12000</span>,</span><br><span class="line">        <span class="string">&quot;jamie&quot;</span>: <span class="number">15000</span>, <span class="comment">// 逗号不可缺</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>获取 map 中的元素：<code>map[key]</code>。如果获取一个不存在的元素，map 会返回 <strong> 该元素类型的零值</strong>（如：<code>[]T</code> 返回 <code>nil</code>，整形返回 <code>0</code>）。</p>
</li>
<li><p>如何判断某个 key 是否存在于 map 中：<code>value, ok := map[key]</code>，如果 ok 是 true，表示 key 存在，key 对应的值就是 value ，反之表示 key 不存在。</p>
</li>
<li><p>遍历 map 中所有的元素需要用 for range 循环：<code>for key, value := range personSalary &#123;//... &#125;</code>。当使用 for range 遍历 map 时，不保证每次执行程序获取的元素顺序相同。</p>
</li>
<li><p>删除 map 中的元素：<code>delete(map, key)</code>，无返回值。</p>
</li>
<li><p>获取 map 的长度：<code>len(map)</code>。</p>
</li>
<li><p>和 slices 类似，map 也是 <strong> 引用类型 </strong>：当 map 被赋值为一个新变量的时候，它们指向同一个内部数据结构。因此，<strong> 改变其中一个变量，就会影响到另一变量。当 map 作为函数参数传递时也会发生同样的情况，函数中对 map 的任何修改，对于外部的调用都是可见的</strong>。</p>
</li>
<li><p>map 之间不能使用 <code>==</code> 操作符判断，<code>==</code> 只能用来检查 map 是否为 nil。</p>
</li>
</ol>
<blockquote>
<p>学习链接：<a href="https://studygolang.com/subject/2">https://studygolang.com/subject/2</a>，感谢如此优秀的教程！</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go可变参数函数</tag>
        <tag>Go集合Map</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 笔记之变量与常量</title>
    <url>/posts/230907162612.html</url>
    <content><![CDATA[<h2 id="Go 语言学习笔记 -1：HelloWorld"><a href="#Go 语言学习笔记 -1：HelloWorld" class="headerlink" title="Go 语言学习笔记 -1：HelloWorld"></a>Go 语言学习笔记 -1：HelloWorld</h2><p>Go 语言是一种编译型语言，源代码都会编译成二进制机器码。</p>
<p>所有 Go 源文件都应该放置在工作区里的 src 目录下。Linux 的工作区（Workspace）应该设置在 $HOME/go，也可以通过设置 GOPATH 环境变量，用其他目录来作为工作区。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span></span><br><span class="line">  bin <span class="comment">// 编译生成的二进制文件存储位置</span></span><br><span class="line">    hello</span><br><span class="line">  src <span class="comment">// 所有 Go 源文件都应该放置在工作区里的 src 目录下</span></span><br><span class="line">    hello <span class="comment">// 为每个 project 新建一个文件夹</span></span><br><span class="line">      helloworld.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>

<p>第一个 Go 程序</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>解析：</p>
<ul>
<li><p><code>package main</code> - 每一个 Go 文件都应该在开头进行 package name 的声明（译注：只有可执行程序的包名应当为 main）。包（Packages）用于代码的封装与重用，这里的包名称是 main。</p>
</li>
<li><p><code>import &quot;fmt&quot;</code> - 我们引入了 fmt 包，用于在 main 函数里面打印文本到标准输出。</p>
</li>
<li><p><code>func main()</code> - main 是一个特殊的函数。整个程序就是从 main 函数开始运行的。main 函数必须放置在 main 包中。{和} 分别表示 main 函数的开始和结束部分。</p>
</li>
<li><p><code>fmt.Println(&quot;Hello World&quot;)</code> - fmt 包中的 Println 函数用于把文本写入标准输出。</p>
</li>
</ul>
<hr>
<h2 id="Go 语言学习笔记 -2：变量"><a href="#Go 语言学习笔记 -2：变量" class="headerlink" title="Go 语言学习笔记 -2：变量"></a>Go 语言学习笔记 -2：变量 </h2><p><strong> 变量 </strong> 指定了某存储单元（Memory Location）的名称，该存储单元会存储特定类型的值。</p>
<ol>
<li><p>声明单个变量：var name type，例如：var age int</p>
</li>
<li><p>声明变量并初始化：var name type = initialValue</p>
</li>
<li><p>类型推断：如果变量有初始值，那么 Go 能够自动推断具有初始值的变量的类型。因此，如果变量有初始值，就可以在变量声明中省略 type， 如 var age = 16 指 age 类型为 int 型。</p>
</li>
<li><p>声明多个变量：var name1, name2 type = initialValue1, initialValue2</p>
</li>
<li><p>在一个语句中声明不同类型的变量，如：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    age = <span class="number">19</span></span><br><span class="line">    name = “laowang”</span><br><span class="line">    adult = <span class="literal">true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>变量的简短声明语法：<code>:=</code> 操作符，例如：<code>age, name := 20, &quot;zhangsan&quot;</code>。简短声明要求 <code>:=</code> 操作符左边的 <strong> 所有变量都有初始值</strong>。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a, b := <span class="number">20</span>, <span class="number">30</span> <span class="comment">// 声明 a 和 b</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;a is&quot;</span>, a, <span class="string">&quot;b is&quot;</span>, b)</span><br><span class="line">    a, b := <span class="number">40</span>, <span class="number">50</span> <span class="comment">// 错误，没有尚未声明的变量</span></span><br><span class="line">    a, c := <span class="number">40</span>, <span class="number">60</span> <span class="comment">// 正确，有新的尚未声明的变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><p>变量也可以在运行时进行赋值，如 <code>a := math.Min(15, 20)</code></p>
</li>
<li><p>由于 Go 是强类型（Strongly Typed）语言，因此不允许某一类型的变量赋值为其他类型的值。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    age := <span class="number">29</span>      <span class="comment">// age 是 int 类型</span></span><br><span class="line">    age = <span class="string">&quot;naveen&quot;</span> <span class="comment">// 错误，尝试赋值一个字符串给 int 类型变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Go 语言学习笔记 -3：变量类型"><a href="#Go 语言学习笔记 -3：变量类型" class="headerlink" title="Go 语言学习笔记 -3：变量类型"></a>Go 语言学习笔记 -3：变量类型</h2><ol>
<li>Go 语言支持的变量类型：</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">bool</span><br><span class="line">数字类型</span><br><span class="line">    int8, int16, int32, int64, int</span><br><span class="line">    uint8, uint16, uint32, uint64, uint</span><br><span class="line">    float32, float64</span><br><span class="line">    complex64, complex128 // 复数型</span><br><span class="line">    byte</span><br><span class="line">    rune</span><br><span class="line">string</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 Printf 方法中，使用 <code>%T</code> 格式说明符（Format Specifier），可以打印出变量的类型。Go 的 <code>unsafe</code> 包提供了一个 <code>Sizeof</code> 函数，该函数接收变量并返回它的字节大小。如：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;type of age is %T, size of age is %d&quot;</span>, age, unsafe.Sizeof(age))</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>复数类型：<code>complex64</code> 表示实部和虚部都是 <code>float32</code> 类型，<code>complex128</code> 表示实部和虚部都是 <code>float64</code> 类型。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c1 := <span class="built_in">complex</span>(<span class="number">5</span>, <span class="number">7</span>) <span class="comment">// 通过内置函数声明复数变量 c1</span></span><br><span class="line">c2 := <span class="number">8</span> + <span class="number">27i</span> <span class="comment">// 通过简短声明声明复数变量 c2</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>其它变量类型：<code>byte</code> 是 <code>uint8</code> 的别名， <code>rune</code> 是 <code>int32</code> 的别名。</p>
</li>
<li><p>Go 是强类型（Strongly Typed）语言， Go 没有自动类型提升或类型转换：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i, j <span class="type">int</span>, float = <span class="number">5</span>, <span class="number">10.2</span></span><br><span class="line">diff := i - j <span class="comment">// 错误， int - float 不被允许</span></span><br><span class="line">diff := i - <span class="type">int</span>(j) <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Go 语言学习笔记 -4：常量"><a href="#Go 语言学习笔记 -4：常量" class="headerlink" title="Go 语言学习笔记 -4：常量"></a>Go 语言学习笔记 -4：常量</h2><ol>
<li><p>关键字：<code>const</code>，常量不能再重新赋值为其他的值。</p>
</li>
<li><p>常量的值会在 <strong> 编译的时候 </strong> 确定。因为函数调用发生在 <strong> 运行时</strong>，所以不能将函数的返回值赋值给常量。如：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a := math.Sqrt(<span class="number">4</span>) <span class="comment">// 允许</span></span><br><span class="line"><span class="keyword">const</span> b := math.Sqrt(<span class="number">9</span>) <span class="comment">// 不允许，编译先于运行</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>常量是可以没有类型的，如：<code>const name = &quot;zhangsan&quot;</code>；常量也可以是有类型的，如：<code>const name string = &quot;lisi&quot;</code>，即 name 是一个 string 类型的 <strong> 常量</strong>。</p>
</li>
<li><p>Go 的类型策略不允许将一种类型的变量赋值给另一种类型的变量。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> defaultName = <span class="string">&quot;Sam&quot;</span> <span class="comment">// 允许</span></span><br><span class="line">    <span class="keyword">type</span> myString <span class="type">string</span></span><br><span class="line">    <span class="keyword">var</span> customName myString = <span class="string">&quot;Sam&quot;</span> <span class="comment">// 允许</span></span><br><span class="line">    customName = defaultName <span class="comment">// 不允许，即使 myString 是 string 类型的别名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>布尔常量</strong>：字符串常量的规则适用于布尔常量。</li>
</ol>
<p><code>var name = &quot;Sam&quot;</code> 无类型的 <strong> 常量 </strong> Sam 是如何赋值给<strong> 变量</strong> name 的？</p>
<blockquote>
<p>答案是 <strong> 无类型的常量有一个与它们相关联的默认类型，并且当且仅当一行代码需要时才提供它</strong>（常量可以赋值给 “合适的” 类型，而不需要类型转换）。在声明变量时，如果使用常量来赋值，变量会从常量的默认类型中获取类型。在这种情况下，常量 “Sam” 的默认类型是字符串，所以变量 name 的类型也是字符串。</p>
</blockquote>
<blockquote>
<p>学习链接：<a href="https://studygolang.com/subject/2">https://studygolang.com/subject/2</a>，感谢如此优秀的教程！</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go变量与常量</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 笔记之字符串和指针</title>
    <url>/posts/230915155105.html</url>
    <content><![CDATA[<h2 id="Go 语言学习笔记 -14：字符串"><a href="#Go 语言学习笔记 -14：字符串" class="headerlink" title="Go 语言学习笔记 -14：字符串"></a>Go 语言学习笔记 -14：字符串</h2><ol>
<li><p>Go 语言中的字符串是一个 <strong> 字节切片</strong>。</p>
</li>
<li><p><code>%x</code> 格式限定符用于指定 16 进制编码，<code>%c</code> 格式限定符用于打印字符串的字符。</p>
</li>
<li><p>在 UTF-8 编码中，一个代码点（字符的编码）可能会占用超过一个字节的空间，所以使用 <code>%c</code> 格式打印时可能会出错，可以用 <code>rune</code> 解决。</p>
</li>
<li><p><code>rune</code> 是 Go 语言的内建类型，它也是 <code>int32</code> 的别称。在 Go 语言中，<code>rune</code> 表示一个代码点。代码点无论占用多少个字节，都可以用一个 <code>rune</code> 来表示。</p>
</li>
</ol>
<span id="more"></span>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">&quot;Señor&quot;</span></span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%c &quot;</span>,s[i]) <span class="comment">// 打印出错，S e Ã ± o r</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">runes := []<span class="type">rune</span>(s)</span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; <span class="built_in">len</span>(runes); i++ &#123; <span class="comment">// 字符串被转化为一个 rune 切片</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%c &quot;</span>,runes[i]) <span class="comment">// 打印正确，S e ñ o r</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>字符串的 for range 循环更简单。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printCharsAndBytes</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> index, <span class="type">rune</span> := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%c starts at byte %d\n&quot;</span>, <span class="type">rune</span>, index)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name := <span class="string">&quot;Señor&quot;</span></span><br><span class="line">    printCharsAndBytes(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">S starts at byte 0  </span></span><br><span class="line"><span class="comment">e starts at byte 1  </span></span><br><span class="line"><span class="comment">ñ starts at byte 2  // ñ 占了两个字节</span></span><br><span class="line"><span class="comment">o starts at byte 4  </span></span><br><span class="line"><span class="comment">r starts at byte 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>用字节切片构造字符串：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包含字符串 Café 用 UTF-8 编码后的 16 进制字节</span></span><br><span class="line">byteSlice := []<span class="type">byte</span>&#123;<span class="number">0x43</span>, <span class="number">0x61</span>, <span class="number">0x66</span>, <span class="number">0xC3</span>, <span class="number">0xA9</span>&#125;</span><br><span class="line">str := <span class="type">string</span>(byteSlice)</span><br><span class="line">fmt.Println(str) <span class="comment">// Café</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>用 <code>rune</code> 切片构造字符串：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包含字符串 Señor 的 16 进制的 Unicode 代码点</span></span><br><span class="line">runeSlice := []<span class="type">rune</span>&#123;<span class="number">0x0053</span>, <span class="number">0x0065</span>, <span class="number">0x00f1</span>, <span class="number">0x006f</span>, <span class="number">0x0072</span>&#125;</span><br><span class="line">str := <span class="type">string</span>(runeSlice)</span><br><span class="line">fmt.Println(str) <span class="comment">// Señor</span></span><br></pre></td></tr></table></figure>

<ol start="8">
<li>字符串的长度：utf-8 package 包中的 <code>func RuneCountInString(s string) (n int)</code> 方法用来 <strong> 获取字符串的长度 </strong>。这个方法传入一个字符串参数然后<strong> 返回字符串中的 rune 的数量</strong>。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">word1 := <span class="string">&quot;Señor&quot;</span> </span><br><span class="line">fmt.Println(utf8.RuneCountInString(word1)) <span class="comment">// 5</span></span><br><span class="line">word2 := <span class="string">&quot;Pets&quot;</span></span><br><span class="line">fmt.Println(utf8.RuneCountInString(word2)) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<ol start="9">
<li>字符串是不可变的：一旦一个字符串被创建，它将不可被修改。为了修改字符串，可以把字符串转化为一个 rune 切片，这个切片可以进行任何想要的改变，最后再转化为一个字符串。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mutate</span><span class="params">(s []<span class="type">rune</span>)</span></span> <span class="type">string</span> &#123;  </span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span> <span class="comment">// 修改切片</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(s) <span class="comment">// 转换为一个字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    h := <span class="string">&quot;hello&quot;</span></span><br><span class="line">    fmt.Println(mutate([]<span class="type">rune</span>(h))) <span class="comment">// 用 rune 切片构造字符串，输出 aello</span></span><br><span class="line">    fmt.Println(h) <span class="comment">// 输出 hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Go 语言学习笔记 -15：指针"><a href="#Go 语言学习笔记 -15：指针" class="headerlink" title="Go 语言学习笔记 -15：指针"></a>Go 语言学习笔记 -15：指针</h2><ol>
<li><p>指针是一种存储变量内存地址（Memory Address）的变量。例如，变量 b 的值为 156，而 b 的内存地址为 0x1040a124，变量 a 存储了 b 的地址。我们就称 a 指向了 b。</p>
</li>
<li><p>指针的声明：指针变量的类型为 <code>*T</code>，该指针指向一个 <code>T</code> 类型的变量。</p>
</li>
</ol>
<ul>
<li>&amp; 操作符用于获取变量的地址。下面的程序把 b 的地址赋值给 <code>*int</code> 类型的 a。我们称 a 指向了 b。当我们打印 a 的值时，会打印出 b 的地址。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b := <span class="number">255</span></span><br><span class="line">    <span class="keyword">var</span> a *<span class="type">int</span> = &amp;b</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Type of a is %T\n&quot;</span>, a) <span class="comment">// *int</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;address of b is&quot;</span>, a)  <span class="comment">// 0x1040a124</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>指针的零值（Zero Value）是 <code>nil</code>。声明变量 <code>var b *int</code>，此时 <code>b == nil</code> 为 <code>true</code>。</p>
</li>
<li><p>指针的解引用：指针的解引用可以获取指针所指向的变量的值。将 <code>a</code> 解引用的语法是 <code>*a</code>。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    b := <span class="number">255</span></span><br><span class="line">    a := &amp;b</span><br><span class="line">    fmt.Println(<span class="string">&quot;address of b is&quot;</span>, a) <span class="comment">// 0x1040a124</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;value of b is&quot;</span>, *a)  <span class="comment">// 255</span></span><br><span class="line">    *a++  <span class="comment">// (*a)++</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;new value of b is&quot;</span>, b) <span class="comment">// 256</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>向函数传递指针参数：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(val *<span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    *val = <span class="number">55</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := <span class="number">58</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;value of a before function call is&quot;</span>, a) <span class="comment">// 58</span></span><br><span class="line">    b := &amp;a</span><br><span class="line">    change(b)</span><br><span class="line">    fmt.Println(<span class="string">&quot;value of a after function call is&quot;</span>, a) <span class="comment">// 55</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>假如我们想要在函数内修改一个数组，并希望调用函数的地方也能得到修改后的数组，一种解决方案是把一个指向数组的指针传递给这个函数（但 Go 语言习惯的方法是用切片处理，见序号 7）。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(arr *[3]<span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    (*arr)[<span class="number">0</span>] = <span class="number">90</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>&#125;</span><br><span class="line">    modify(&amp;a)</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>a[x]</code> 是 <code>(*a)[x]</code> 的简写形式，因此上面代码中的 <code>(*arr)[0]</code> 可以替换为 <code>arr[0]</code>。</li>
</ul>
<ol start="7">
<li><strong>不要向函数传递数组的指针，而应该使用数组切片</strong>：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(sls []<span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    sls[<span class="number">0</span>] = <span class="number">90</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>&#125;</span><br><span class="line">    modify(a[:]) <span class="comment">// 使用切片</span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>别再传递数组指针了，而是使用切片吧。上面的代码更加简洁，也更符合 Go 语言的习惯。</li>
</ul>
<blockquote>
<p>学习链接：<a href="https://studygolang.com/subject/2">https://studygolang.com/subject/2</a>，感谢如此优秀的教程！</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go字符串</tag>
        <tag>Go指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 笔记之数组与切片</title>
    <url>/posts/230912152800.html</url>
    <content><![CDATA[<h2 id="Go 语言学习笔记 -10：数组"><a href="#Go 语言学习笔记 -10：数组" class="headerlink" title="Go 语言学习笔记 -10：数组"></a>Go 语言学习笔记 -10：数组</h2><ol>
<li><p>数组是 <strong> 同一类型元素 </strong> 的集合，Go 语言中不允许混合不同类型的元素。</p>
</li>
<li><p>一个数组的表示形式为 <code>[n]T</code>。n 表示数组中元素的数量，T 代表每个元素的类型。如： <code>var arr [3]int</code>。</p>
</li>
<li><p>数组简略声明：<code>arr := [3]int&#123;12, 78, 50&#125;</code>，在简略声明中，可对部分元素赋值：<code>arr := [3]int&#123;12&#125;</code>，剩下的元素自动赋值为 0 。</p>
</li>
<li><p>可以忽略声明数组的长度，并用 <code>...</code> 代替，让编译器为你自动计算长度：<code>arr := [...]int&#123;12, 21&#125;</code>。</p>
</li>
<li><p><strong>数组是值类型，不是引用类型 </strong>：这意味着当数组赋值给一个新的变量时，该变量会得到一个原始数组的副本。<strong> 如果对新变量进行更改，则不会影响原始数组</strong>。注：对切片的修改会影响原始数组。</p>
</li>
</ol>
<span id="more"></span>

<ol start="6">
<li><strong>当数组作为参数传递给函数时，它们是按值传递，而原始数组保持不变（原始数组不会因为函数调用而改变）</strong>。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeLocal</span><span class="params">(num [5]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    num[<span class="number">0</span>] = <span class="number">55</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;inside function &quot;</span>, num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num := [...]<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;before passing to function &quot;</span>, num)</span><br><span class="line">    changeLocal(num) <span class="comment">// num is passed by value</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;after passing to function &quot;</span>, num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// before passing to function  [5 6 7 8 8]</span></span><br><span class="line"><span class="comment">// inside function  [55 6 7 8 8]</span></span><br><span class="line"><span class="comment">// after passing to function  [5 6 7 8 8]</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li><p>数组的长度：<code>len(arr)</code>。</p>
</li>
<li><p>数组的迭代 for 循环：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;%d-th element of arr is %.2f\n&quot;</span>, i, arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>数组的迭代：Go 提供了一种更好、更简洁的方法，通过 <strong> 使用 for 循环的 <code>range</code> 方法来遍历数组</strong>。<code>range</code> 返回索引和该索引处的值。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;%d-th element of arr is %.2f\n&quot;</span>, i, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>多维数组：1）简略声明；2）先声明二维数组变量，再根据索引来对数组添加值。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr := [<span class="number">3</span>][<span class="number">2</span>]<span class="type">string</span>&#123; <span class="comment">// 简略声明</span></span><br><span class="line">      &#123;<span class="string">&quot;lion&quot;</span>, <span class="string">&quot;tiger&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;pigeon&quot;</span>, <span class="string">&quot;peacock&quot;</span>&#125;, <span class="comment">// this comma is necessary. The compiler will complain if you omit this comma</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v1 := <span class="keyword">range</span> arr &#123; <span class="comment">// 打印二维数组</span></span><br><span class="line">    <span class="keyword">for</span> _, v2 := <span class="keyword">range</span> v1 &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s &quot;</span>, v2)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>数组的缺陷：长度固定，不可能增加数组的长度。</li>
</ol>
<hr>
<h2 id="Go 语言学习笔记 -11：切片"><a href="#Go 语言学习笔记 -11：切片" class="headerlink" title="Go 语言学习笔记 -11：切片"></a>Go 语言学习笔记 -11：切片</h2><ol>
<li><p>切片是 <strong> 由数组建立 </strong> 的一种方便、灵活且功能强大的包装（Wrapper）。<strong>切片本身不拥有任何数据 </strong>。它们只是对现有数组的<strong> 引用</strong>。</p>
</li>
<li><p>创建一个切片 A ：带有 <code>T</code> 类型元素的切片由 <code>[]T</code> 表示。语法：<code>a[start:end]</code> 创建一个从 a 数组索引 start 开始到 end - 1 结束的切片。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">76</span>, <span class="number">77</span>, <span class="number">78</span>, <span class="number">79</span>, <span class="number">80</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b []<span class="type">int</span> = a[<span class="number">1</span>:<span class="number">4</span>] <span class="comment">// 数组切片</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建一个切片 B ：创建一个数组，并返回一个存储在 c 中的 <strong> 切片引用</strong>。注意：<code>[]</code> 内无内容。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c := []<span class="type">int</span>&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125; <span class="comment">// creates and array and returns a slice reference</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p><strong>对切片的修改会影响原始数组</strong>。</p>
</li>
<li><p>当多个切片共用相同的底层数组时，每个切片所做的更改将反映在数组中。</p>
</li>
<li><p><strong>切片的长度和容量</strong>：切片的长度是切片中的元素数。切片的容量是从创建切片索引开始（到数组末尾）的底层数组中的元素数。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fruitarray := [...]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>&#125;</span><br><span class="line">    fruitslice := fruitarray[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">    fmt.Println(<span class="string">&quot;length of slice: %d, capacity: %d&quot;</span>, <span class="built_in">len</span>(fruitslice), <span class="built_in">cap</span>(fruitslice)) <span class="comment">// 2, 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>切片可以重置其容量：<code>slicename[:cap(slicename)]</code>。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fruitarray := [...]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>&#125;</span><br><span class="line">    fruitslice := fruitarray[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">    fmt.Println(<span class="string">&quot;length of slice: %d, capacity: %d&quot;</span>, <span class="built_in">len</span>(fruitslice), <span class="built_in">cap</span>(fruitslice)) <span class="comment">// 2, 3. print: [b, c]</span></span><br><span class="line">    fruitslice = fruitslice[:<span class="built_in">cap</span>(fruitslice)] <span class="comment">// re-slicing furitslice till its capacity. print: [b, c, d]</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;After re-slicing length is&quot;</span>, <span class="built_in">len</span>(fruitslice), <span class="string">&quot;and capacity is&quot;</span>, <span class="built_in">cap</span>(fruitslice)) <span class="comment">// 3, 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><p><strong>使用 <code>make</code> 创建一个切片</strong>：<code>func make ([]T, len, cap)</code> 通过传递类型、长度和容量来创建切片。其中，容量是可选参数，默认值为切片长度。<strong><code>make</code> 函数创建一个数组，并返回引用该数组的切片</strong>。如 <code>arrslice := make([]float64, 5, 5)</code>。</p>
</li>
<li><p>切片是动态的，可以使用 <code>append</code> 将新元素追加到切片上。<code>append</code> 函数定义为：<code>func append(slice []T, x ...T) []T</code>，其中 <code>x...T</code> 表示该函数接收 T 类型的参数 x 的个数是可变的，如：<code>arrslice = append(arrslice, 5.6, 7.3)</code>。</p>
</li>
</ol>
<blockquote>
<p><code>append</code> 函数会返回一个新的切片，其中包含了原始切片和追加的元素：</p>
<ol>
<li>如果原始切片的容量足够，<code>append</code> 函数会在原始切片的基础上进行追加；</li>
<li>如果原始切片的容量不够，<code>append</code> 函数会创建一个新的底层数组，并将原始切片中的元素和追加的元素复制到新的底层数组中。</li>
</ol>
<p>因此，append 函数返回的切片可能指向一个新的底层数组，而不是原始切片所指向的底层数组。</p>
</blockquote>
<ol start="10">
<li><p>数组是固定的，但 <strong> 切片具有动态长度 </strong>：切片是由一个指向数组的指针、长度和容量组成的数据结构。当我们向切片中追加元素时，如果切片的长度小于容量，新元素会直接添加到切片的末尾，切片的长度会增加。但是，如果追加元素后切片的长度超过了容量，Go 语言会创建一个新的更大的底层数组，将原来的元素复制到新的数组中，并将新元素添加到新数组的末尾。然后，切片会指向这个新数组（<strong> 相比于旧切片，引用类型的地址改变了</strong>），并且容量会成为原来的两倍（并不是每次执行 <code>append</code> 时容量都会变成旧切片的两倍，只有当长度超过容量时，才会扩充一倍容量）。这样，切片就具有了动态长度的特性。</p>
</li>
<li><p>切片类型的零值为 <code>nil</code>：一个 <code>nil</code> 切片的长度和容量为 0，可以使用 <code>append</code> 函数将值追加到 <code>nil</code> 切片。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names []<span class="type">string</span> <span class="comment">// zero value of a slice is nil</span></span><br><span class="line"><span class="keyword">if</span> names == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;slice is nil going to append&quot;</span>)</span><br><span class="line">    names = <span class="built_in">append</span>(names, <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Sebastian&quot;</span>, <span class="string">&quot;Vinay&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;names contents:&quot;</span>, names)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="12">
<li><p><code>...</code> 可将一个切片添加到另一个切片中：<code>append(slice1, slice2...)</code>。</p>
</li>
<li><p>切片的函数传递：切片在内部可由一个结构体类型表示，即：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    Length         <span class="type">int</span></span><br><span class="line">    Capacity       <span class="type">int</span></span><br><span class="line">    ZerothElement  *<span class="type">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>切片本身包含了长度、容量和指向底层数组首个元素的指针。当切片作为参数传递给函数时，虽然是通过值传递，但是切片内部的指针变量（这里的<code>byte</code>）仍然指向相同的底层数组。因此，当函数内部修改底层数组的值时，这些修改在函数外部是可见的。</p>
</li>
<li><p>然而，如果函数内部修改了切片的长度或容量，将会创建一个新的切片，而不会影响原始切片。这是因为切片的长度和容量是切片结构体的字段，而非底层数组的属性。因此，修改切片的长度或容量会创建一个新的切片结构体，其中的指针变量仍然指向原始的底层数组，但是新的切片具有不同的长度和容量。</p>
</li>
<li><p>因此，可以说当切片传递给函数时，函数内部对底层数组的修改，在函数外部是可见的，但是对切片的长度和容量的修改是不可见的。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifySlice</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">100</span> <span class="comment">// 修改底层数组的值</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">200</span>) <span class="comment">// 创建新的切片，不影响原始切片</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Inside modifySlice:&quot;</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    numbers := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Before modifySlice:&quot;</span>, numbers)</span><br><span class="line">    modifySlice(numbers)</span><br><span class="line">    fmt.Println(<span class="string">&quot;After modifySlice:&quot;</span>, numbers)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Before modifySlice: [1 2 3 4 5]</span></span><br><span class="line"><span class="comment">// Inside modifySlice: [100 2 3 4 5 200]</span></span><br><span class="line"><span class="comment">// After modifySlice: [100 2 3 4 5]  // 函数内部对底层数组的修改在函数外部是可见的</span></span><br></pre></td></tr></table></figure>

<ol start="14">
<li><strong>多维切片</strong>：类似于多维数组，但每行索引对应的元素数量可以不等于其它行。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pls := [][]<span class="type">string</span> &#123;</span><br><span class="line">      &#123;<span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;JavaScript&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;Go&quot;</span>, <span class="string">&quot;Rust&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="15">
<li>内存优化：切片持有对底层数组的引用，只要切片在内存中，数组就不能被垃圾回收。一种回收数组的方法时使用 <code>copy</code> 函数 <code>func copy(dst, src[]T) int</code> 来生成一个切片的副本，这样就可以使用新的切片，原始数组也可以被垃圾回收。注：返回的 int 类型的值为 dst 的长度。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countries</span><span class="params">()</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    countries := []<span class="type">string</span>&#123;<span class="string">&quot;USA&quot;</span>, <span class="string">&quot;Singapore&quot;</span>, <span class="string">&quot;Germany&quot;</span>, <span class="string">&quot;India&quot;</span>, <span class="string">&quot;Australia&quot;</span>&#125;</span><br><span class="line">    neededCountries := countries[:<span class="built_in">len</span>(countries)<span class="number">-2</span>]</span><br><span class="line">    countriesCpy := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(neededCountries))</span><br><span class="line">    <span class="built_in">copy</span>(countriesCpy, neededCountries) <span class="comment">//copies neededCountries to countriesCpy</span></span><br><span class="line">    <span class="keyword">return</span> countriesCpy</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    countriesNeeded := countries()</span><br><span class="line">    fmt.Println(countriesNeeded)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>学习链接：<a href="https://studygolang.com/subject/2">https://studygolang.com/subject/2</a>，感谢如此优秀的教程！</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go数组</tag>
        <tag>Go切片</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 1029 两地调度</title>
    <url>/posts/231107094652.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/two-city-scheduling/">1029 两地调度</a>：公司计划面试 <code>2N</code> 人。第 <code>i</code> 个面试者飞往 A 市的费用为 <code>costs[i][0]</code>，飞往 B 市的费用为 <code>costs[i][1]</code>。返回将每个面试者都飞到某一座城市的最低费用，要求每个城市都有 <code>N</code> 个面试者抵达。</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：costs = [[10,20],[30,200],[400,50],[30,20]]</span><br><span class="line">输出：110</span><br><span class="line">解释：</span><br><span class="line">第一个人去 a 市，费用为 10。</span><br><span class="line">第二个人去 a 市，费用为 30。</span><br><span class="line">第三个人去 b 市，费用为 50。</span><br><span class="line">第四个人去 b 市，费用为 20。</span><br><span class="line"></span><br><span class="line">最低总费用为 10 + 30 + 50 + 20 = 110，每个城市都有一半的人在面试。</span><br></pre></td></tr></table></figure>

<h2 id="排序 - 贪心算法"><a href="# 排序 - 贪心算法" class="headerlink" title="排序 + 贪心算法"></a>排序 + 贪心算法 </h2><p> 要求每个城市都有 <code>N</code> 个面试者抵达。我们可以选择 <code>N</code> 个面试者去 A 市，那么剩下的 <code>N</code> 个面试者自然就得去 B 市了。<strong>那哪些人去 A 市呢</strong>？</p>
<p>「每个人」只需要考虑自己选哪个城市更省钱，但必须要有 <code>N</code> 个人去 A 市，<code>N</code> 个人去 B 市。因此，我们只需要 <strong> 比较「所有人」去 B 市与去 A 市的成本差——差值越大，说明去 A 市比去 B 市省出来的成本更多；差值越小，说明能省出来的成本就越少，这些人就去 B 市吧</strong>。</p>
<p>时间复杂度：<code>O(nlogn)</code>，排序所需时间，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *pa, <span class="type">const</span> <span class="type">void</span> *pb)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *arr1 = *(<span class="type">const</span> <span class="type">int</span> **)pa;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *arr2 = *(<span class="type">const</span> <span class="type">int</span> **)pb;</span><br><span class="line">    <span class="comment">// 按 B 市与 A 市成本差降序排序</span></span><br><span class="line">    <span class="keyword">return</span> (arr2[<span class="number">1</span>] - arr2[<span class="number">0</span>]) - (arr1[<span class="number">1</span>] - arr1[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">twoCitySchedCost</span><span class="params">(<span class="type">int</span>** costs, <span class="type">int</span> costsSize, <span class="type">int</span>* costsColSize)</span> &#123;</span><br><span class="line">    qsort(costs, costsSize, <span class="keyword">sizeof</span>(costs[<span class="number">0</span>]), cmp);</span><br><span class="line">    <span class="type">int</span> minCost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; costsSize; ++i) &#123;</span><br><span class="line">        <span class="comment">// 前一半差值大的去 A 市, 后一半差值小的去 B 市</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; (costsSize &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">            minCost += costs[i][<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minCost += costs[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 142 环形链表 II</title>
    <url>/posts/231102165703.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142 环形链表 II</a>：给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 <code>pos</code> 是 -1，则在该链表中没有环。注意：<code>pos</code> 不作为参数进行传递，仅仅是为了标识链表的实际情况。说明：不允许修改给定的链表。</p>
<span id="more"></span>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入: head = [3,2,0,-4], pos = 1</span><br><span class="line">输出: 返回索引为 1 的链表节点 </span><br><span class="line">解释: 链表中有一个环，其尾部连接到第二个节点。</span><br><span class="line"></span><br><span class="line">输入: head = [1,2], pos = 0</span><br><span class="line">输出: 返回索引为 0 的链表节点 </span><br><span class="line">解释: 链表中有一个环，其尾部连接到第一个节点。</span><br><span class="line"></span><br><span class="line">输入: head = [1], pos = -1</span><br><span class="line">输出: 返回 null </span><br><span class="line">解释: 链表中没有环。</span><br></pre></td></tr></table></figure>

<h2 id="哈希表 - 遍历"><a href="# 哈希表 - 遍历" class="headerlink" title="哈希表 + 遍历"></a>哈希表 + 遍历 </h2><p> 我们可以借助一个哈希表来存储链表中的节点，随着遍历的进行，会第二次遇到相同的节点，这个最先遇到的节点就是入环的第一个节点。</p>
<p>时间复杂度：<code>O(n)</code>，一趟遍历，空间复杂度：<code>O(n)</code>，哈希表最多存储链表的全部节点。</p>
<h2 id="快慢指针"><a href="# 快慢指针" class="headerlink" title="快慢指针"></a>快慢指针 </h2><p> 前置知识：<strong>使用快慢指针可以判断链表中是否存在环。若存在环，则快慢指针终有相遇的时候，若不存在环，快指针最后会退出链表</strong>。</p>
<p>因此，判断环形链表入环的第一个节点，也可以使用快慢指针。</p>
<p><img src="/images/leetcode/lc-142.png" alt=""></p>
<p>如上图，当快慢指针在位置 $O$ 相遇时，假设快指针绕环走过 $n$ 圈，那么其走过链表的总长度为 $a + b + n(b + c)$。同样地，慢指针绕环走过 $m$ 圈，那么其走过链表的总长度为 $a + b + m(b + c)$。</p>
<p>假设快指针每次走 $2$ 步，慢指针每次走 $1$ 步，那么有 $a + b + n(b + c) = 2(a + b + m(b + c))$，化简得 $a+b = (n - 2m)(b + c)$。</p>
<p>那么，$n$ 和 $m$ 分别是几圈呢？</p>
<p>当慢指针第一次进入环的起始位置时（假设为位置 $A$），由于快指针一定在慢指针前面，所以此时快指针已经在环上（假设为位置 $B$）。因为快指针的速度是慢指针的速度的 $2$ 倍，当它们在环上移动时，慢指针移动一圈会又回到环的起点位置 $A$，此时快指针移动了两圈也回到位置 $B$。</p>
<p>相同的时间下，快指针在走这两圈的路上一定会遇到（且为 $1$ 次）只走一圈的满指针；且因为慢指针慢，要「追上」慢指针，快指针一定会走过环一圈，使其「落后于」慢指针，然后再相遇，故 $n = 1, m = 0$。代入 $a+b = (n - 2m)(b + c)$ 有 $a = c$。</p>
<p>因此，我们 <strong> 只需要在快慢指针相遇时，再申请一个指针，从链表头开始走（与慢指针同速度）。当慢指针和这个新申请的指针相遇时，就是环形链表入环的第一个节点</strong>。</p>
<p>时间复杂度：<code>O(n)</code>，一趟遍历，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode *<span class="title function_">detectCycle</span><span class="params">(<span class="keyword">struct</span> ListNode *head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">slow</span> =</span> head, *fast = head, *node = head;</span><br><span class="line">    <span class="comment">// 判断快指针能不能再往后移动两个节点</span></span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="comment">// 相遇</span></span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未相遇</span></span><br><span class="line">    <span class="keyword">if</span> ((fast == <span class="literal">NULL</span>) || (fast-&gt;next == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确定环形链表入环的第一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (node != slow) &#123;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 19 删除链表的倒数第 N 个节点</title>
    <url>/posts/231027150243.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19 删除链表的倒数第 N 个节点</a>：给定一个链表，删除链表的倒数第 N 个节点，并且返回链表的头节点。进阶：你能尝试使用一趟扫描实现吗？</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>

<h2 id="两趟遍历"><a href="# 两趟遍历" class="headerlink" title="两趟遍历"></a>两趟遍历 </h2><p> 删除倒数第 <code>n</code> 个，即需要统计链表长度 <code>L</code>，然后删除正数第 <code>L-n+1</code> 个即可。</p>
<p>第一趟遍历：统计链表长度；第二趟遍历：删除节点。</p>
<p>时间复杂度：<code>O(L)</code>，遍历了两遍链表，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeNthFromEnd</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node</span> =</span> head;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    node = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除的是第一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (n == size) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newHead</span> =</span> head-&gt;next;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(head);</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">temp</span> =</span> node-&gt;next;</span><br><span class="line">    node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">    temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快慢指针（一趟遍历）"><a href="# 快慢指针（一趟遍历）" class="headerlink" title="快慢指针（一趟遍历）"></a>快慢指针（一趟遍历）</h2><p>进阶：你能尝试使用一趟扫描实现吗？</p>
<p>我们可以使用两个指针（快慢指针），让快指针先走 <code>n</code> 步，然后快指针和慢指针同时、同速度走，当快指针走完时，慢指针刚好走了 <code>L-n</code> 步。</p>
<p>时间复杂度：<code>O(L)</code>，遍历了一遍链表，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeNthFromEnd</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">slow</span> =</span> head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除的是第一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newHead</span> =</span> head-&gt;next;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(head);</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next) &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">temp</span> =</span> slow-&gt;next;</span><br><span class="line">    slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">    temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 160 相交链表</title>
    <url>/posts/231025143947.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists">160 相交链表</a>：编写一个程序，找到两个无环单链表相交的起始节点，如果不存在交点则返回 <code>null</code>。要求时间复杂度为 <code>O(m+n)</code>，空间复杂度为 <code>O(1)</code>。</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A:          a1 → a2</span><br><span class="line">                    ↘</span><br><span class="line">                      c1 → c2 → c3</span><br><span class="line">                    ↗</span><br><span class="line">B:    b1 → b2 → b3</span><br></pre></td></tr></table></figure>

<p>但是不会出现以下相交的情况，因为每个节点只有 <strong> 一个</strong> <code>next</code> 指针，也就只能有一个后继节点，而以下示例中节点 <code>c</code> 有两个后继节点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A:          a1 → a2       d1 → d2</span><br><span class="line">                    ↘  ↗</span><br><span class="line">                      c</span><br><span class="line">                    ↗  ↘</span><br><span class="line">B:    b1 → b2 → b3        e1 → e2</span><br></pre></td></tr></table></figure>

<h2 id="暴力解法"><a href="# 暴力解法" class="headerlink" title="暴力解法"></a>暴力解法 </h2><p> 两重循环，对于链表 A 的每一个节点，依次从头到尾遍历链表 B 的每一个节点，当链表 A 的当前节点与链表 B 的当前节点 <strong> 首次 </strong> 相同时，即为相交的起始节点，即可返回答案。</p>
<p>很显然，时间复杂度：<code>O(mn)</code>，空间复杂度：<code>O(1)</code>，不满足题意。</p>
<h2 id="哈希表解法"><a href="# 哈希表解法" class="headerlink" title="哈希表解法"></a>哈希表解法 </h2><p> 遍历链表 A 时存储指针地址到哈希表中。遍历链表 B 时，判断当前节点是否在哈希表中，若在（<strong>第一个 </strong> 在的），即为相交的起始节点，即可返回答案。</p>
<p>很显然，时间复杂度：<code>O(m+n)</code>，空间复杂度：<code>O(m)</code>，不满足题意。</p>
<h2 id="双指针解法"><a href="# 双指针解法" class="headerlink" title="双指针解法"></a>双指针解法 </h2><p> 设链表 A 的长度为 a + c，链表 B 的长度为 b + c，其中 c 为尾部公共部分长度，<strong>可知长度满足：a + c + b = b + c + a</strong>。</p>
<p>当访问链表 A 的指针访问到链表尾部时，<strong>令它从链表 B 的头部开始访问链表 B</strong>；同样地，当访问链表 B 的指针访问到链表尾部时，<strong>令它从链表 A 的头部开始访问链表 A</strong>。</p>
<p>这样就能控制访问 A 和 B 两个链表的指针 <strong> 能同时访问到相交点 </strong>。如果不存在交点，那么 a + b = b + a，以下实现代码中<code>nodeA</code> 和<code>nodeB</code>会同时为<code>null</code>，从而退出循环。</p>
<p>时间复杂度：<code>O(m+n)</code>，空间复杂度：<code>O(1)</code>，满足题意。</p>
<p>C 语言实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode *<span class="title function_">getIntersectionNode</span><span class="params">(<span class="keyword">struct</span> ListNode *headA, <span class="keyword">struct</span> ListNode *headB)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">nodeA</span> =</span> headA, *nodeB = headB;</span><br><span class="line">    <span class="keyword">while</span> (nodeA != nodeB) &#123;</span><br><span class="line">        nodeA = (nodeA != <span class="literal">NULL</span> ? nodeA-&gt;next : headB);</span><br><span class="line">        nodeB = (nodeB != <span class="literal">NULL</span> ? nodeB-&gt;next : headA);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nodeA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Python 语言实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        nodeA, nodeB = headA, headB</span><br><span class="line">        <span class="keyword">while</span>(nodeA != nodeB):</span><br><span class="line">            nodeA = headB <span class="keyword">if</span>(nodeA == <span class="literal">None</span>) <span class="keyword">else</span> nodeA.<span class="built_in">next</span></span><br><span class="line">            nodeB = headA <span class="keyword">if</span>(nodeB == <span class="literal">None</span>) <span class="keyword">else</span> nodeB.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> nodeA</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 206 反转链表</title>
    <url>/posts/231025185947.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206 反转链表</a>：反转一个单链表。例如，输入：<code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>；输出：<code>5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code>。</p>
<span id="more"></span>

<h2 id="LIFO 堆栈解法"><a href="#LIFO 堆栈解法" class="headerlink" title="LIFO 堆栈解法"></a>LIFO 堆栈解法 </h2><p> 可以使用堆栈的后进先出特性来实现链表的反转。遍历链表中的节点，并存储在堆栈中；遍历完后，依次弹出堆栈中的节点，并将它与上一个节点链接起来。</p>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(n)</code>。</p>
<h2 id="双指针解法"><a href="# 双指针解法" class="headerlink" title="双指针解法"></a>双指针解法 </h2><p> 可以借助一前一后两个指针，在遍历链表的过程中，将两个前后两个节点的指向关系反转。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1  2  3  4  5  NULL</span><br><span class="line"> -&gt; -&gt; -&gt; -&gt; -&gt;</span><br><span class="line"> &lt;- &lt;- &lt;- &lt;- &lt;-</span><br></pre></td></tr></table></figure>

<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">pre</span> =</span> head, *cur = head-&gt;next;  <span class="comment">// 双指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">suff</span> =</span> <span class="literal">NULL</span>, *tail = <span class="literal">NULL</span>;  <span class="comment">// 临时指针和结果指针</span></span><br><span class="line">    pre-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            tail = cur;  <span class="comment">// 记录最后一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        suff = cur-&gt;next;  <span class="comment">// 记录下一个节点</span></span><br><span class="line">        cur-&gt;next = pre;  <span class="comment">// 转向关系反转</span></span><br><span class="line">        pre = cur;  <span class="comment">// 更新上一个节点</span></span><br><span class="line">        cur = suff;  <span class="comment">// 更新当前节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="头插法"><a href="# 头插法" class="headerlink" title="头插法"></a>头插法 </h2><p> 对于链表中的每一个节点，我们 <strong> 都将它插在新链表的头结点之前</strong>，对于链表 <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>：</p>
<ol>
<li>遍历前新链表为 <code>NULL</code>；</li>
<li>遍历第一个节点时，将其插入在新链表 <code>NULL</code> 的头结点之前，更新后的链表为 <code>1-&gt;NULL</code>;</li>
<li>遍历第二个节点时，将其插入在新链表 <code>1-&gt;NULL</code> 的头结点之前，更新后的链表为 <code>2-&gt;1-&gt;NULL</code>;</li>
<li>…</li>
<li>遍历最后一个节点时，将其插入在新链表 <code>4-&gt;3-&gt;2-&gt;1-&gt;NULL</code> 的头结点之前，更新后的链表为 <code>5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code>;</li>
</ol>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">newHead</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> =</span> head;  <span class="comment">// 当前节点</span></span><br><span class="line">        head = head-&gt;next;  <span class="comment">// 先找到下一个节点</span></span><br><span class="line">        cur-&gt;next = newHead;  <span class="comment">// 当前节点指向新链表的头</span></span><br><span class="line">        newHead = cur;  <span class="comment">// 更新新链表的头</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>双指针解法与头插法有什么区别？</p>
</blockquote>
<p>双指针解法是反转前后两个节点的指向关系；头插法是初始化一个新的空链表，依次将待反转链表的节点，追加在新链表的最前面。</p>
<h2 id="递归解法"><a href="# 递归解法" class="headerlink" title="递归解法"></a>递归解法 </h2><p> 假设我们要反转链表 <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>，可以先反转节点 <code>1</code> 后面 <strong> 更短的链表</strong>，即 <code>2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>，这会得到 <code>5-&gt;4-&gt;3-&gt;2-&gt;NULL</code>。最后，再将节点 <code>1</code> 链接到上面反转的链表的最后一个非空节点（即节点 <code>2</code>）和 <code>NULL</code> 节点之间。</p>
<p>递归的终止条件就是链表无需反转了，即链表没有节点或只有一个节点。</p>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(n)</code>，递归深度可能达到 <code>n</code> 层。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur</span> =</span> reverseList(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是用递归方式实现单链表的反转。让我们逐行解析代码的实现原理：</p>
<ol>
<li>首先，检查头指针 <code>head</code> 是否为空或者链表只有一个节点（即 <code>head-&gt;next</code> 为空）。如果是的话，直接返回头指针。</li>
<li>如果链表有多个节点，递归调用 <code>reverseList</code> 函数，传入 <code>head-&gt;next</code> 作为参数，<strong>目的是将 <code>head-&gt;next</code> 节点及之后的节点进行反转</strong>。</li>
<li>在递归调用之后，我们得到了反转后的链表的头指针 <code>cur</code>，它的尾结点是 <code>head-&gt;next</code>。</li>
<li>然后，我们 <strong> 将 <code>head</code> 节点插入到反转后的链表的末尾</strong>，即 <code>head-&gt;next-&gt;next = head</code>。这一步是将 <code>head</code> 节点的下一个节点（<code>head-&gt;next</code>）指向 <code>head</code>，实现反转。</li>
<li>最后，将 <code>head</code> 的下一个节点指向 <code>NULL</code>，以确保链表的末尾指向 <code>NULL</code>。</li>
<li>返回反转后的链表的头指针 <code>cur</code>。</li>
</ol>
<p>这段代码的核心思想是通过递归来实现链表的反转。通过不断地调用 <code>reverseList</code> 函数，<strong>每次反转两个节点</strong>，最终实现整个链表的反转。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 117 填充每个节点的下一个右侧节点指针 II</title>
    <url>/posts/231103121209.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117 填充每个节点的下一个右侧节点指针 II</a>：给定一个包含指针 <code>next</code> 成员的二叉树：填充它的每个 <code>next</code> 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 <code>next</code> 指针设置为 <code>NULL</code>。初始状态下，所有 <code>next</code> 指针都被设置为 <code>NULL</code>。</p>
<span id="more"></span>

<p>树结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node *left;</span><br><span class="line">    Node *right;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例图：<br><img src="https://assets.leetcode.com/uploads/2019/02/15/117_sample.png" alt=""></p>
<h2 id="队列 - 层序遍历"><a href="# 队列 - 层序遍历" class="headerlink" title="队列 + 层序遍历"></a>队列 + 层序遍历 </h2><p> 根据题目描述，「填充它的每个 <code>next</code> 指针，让这个指针指向（同层的）其下一个右侧节点」，我们很容易想到使用「层序遍历」解决这个问题。而层序遍历通常需要借助 FIFO 队列实现。</p>
<p><strong>关于借助队列的树的层序遍历</strong>：首先要入队根节点；然后，记录队列中的节点个数 <code>size</code>；随后，弹出 <code>size</code> 个节点，在弹出的过程中入队弹出节点的左、右节点；最后，在这 <code>size</code> 个节点弹出后，队列中剩下的节点，就是刚刚入队的树的下一层节点。只要队列不为空，我们就反复进行上述操作，直到队列为空为止（二叉树的叶子层没有左、右节点，便不会再有节点入队，队列也就为空了）。</p>
<p>时间复杂度：<code>O(n)</code>，一趟遍历，空间复杂度：<code>O(n)</code>，需要使用队列保存二叉树中的节点。</p>
<blockquote>
<p>关于队列，我们可以使用 <a href="https://pursue26.github.io/posts/231017105123.html"> 数据结构之队列（链表实现）</a>中实现的接口。但是，为了简单、清晰，我在这里直接使用数组模拟 FIFO 队列。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">TreeNode_t</span>;</span></span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">connect</span><span class="params">(<span class="keyword">struct</span> Node* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	TreeNode_t *<span class="built_in">queue</span>[<span class="number">6000</span>];</span><br><span class="line">    <span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;  <span class="comment">// 队列的头尾指针</span></span><br><span class="line">    <span class="built_in">queue</span>[rear++] = root;  <span class="comment">// 树不为空, 首先入队根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (rear - front &gt; <span class="number">0</span>) &#123;  <span class="comment">// 队列不为空</span></span><br><span class="line">        <span class="type">int</span> size = rear - front;  <span class="comment">// 当前队列的数据大小</span></span><br><span class="line">        TreeNode_t *curNode = <span class="literal">NULL</span>, *preNode = <span class="literal">NULL</span>;  <span class="comment">// 当前节点和上一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 弹出这几个数据（某一层的所有节点）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            curNode = <span class="built_in">queue</span>[front++];  <span class="comment">// 首指针后移</span></span><br><span class="line">            <span class="comment">// 链接前后两个节点, 并更新上一个节点为当前节点</span></span><br><span class="line">            <span class="keyword">if</span> (preNode) &#123;</span><br><span class="line">                preNode-&gt;next = curNode;</span><br><span class="line">            &#125;</span><br><span class="line">            preNode = curNode;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 入队左右子树的节点</span></span><br><span class="line">            <span class="keyword">if</span> (curNode-&gt;left) &#123;</span><br><span class="line">                <span class="built_in">queue</span>[rear++] = curNode-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curNode-&gt;right) &#123;</span><br><span class="line">                <span class="built_in">queue</span>[rear++] = curNode-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每层的最后一个节点指向空地址</span></span><br><span class="line">        curNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="利用已建立的链表构建下一层链表"><a href="# 利用已建立的链表构建下一层链表" class="headerlink" title="利用已建立的链表构建下一层链表"></a>利用已建立的链表构建下一层链表 </h2><p> 根据题目描述，「填充它的每个 <code>next</code> 指针，让这个指针指向（同层的）其下一个右侧节点」。这样填充后，二叉树的每一层都将是一个单链表，链表的头节点是每层最左侧的树节点。这样，我们就可以根据链表中的节点，获得它的下一层的左、右孩子节点。</p>
<p>因此，我们可以利用当前层的链表 <code>currLayer</code> 来构建下一层的链表 <code>nextLayer</code>：</p>
<ul>
<li>下一层的构建过程就是：不断的访问 <code>currLayer</code> 中的节点，通过它访问下一层的左、右孩子节点，将这些孩子链接起来，就是 <code>nextLayer</code>；</li>
<li>构建的下一层的链表时，要记录下一层的头结点，以便更新当前层为下一层。<ul>
<li>下一层的头结点，就是 <code>currLayer</code> 中的节点里，第一个有孩子节点（若有左、右孩子，左孩子优先）。</li>
</ul>
</li>
</ul>
<p>最后，当下一层为叶子结点层时，便不会有下一层链表，当前层链表会更新为 <code>NULL</code>，标志着每层的链表构建完成。</p>
<p>时间复杂度：<code>O(n)</code>，一趟遍历，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">connect</span><span class="params">(<span class="keyword">struct</span> Node* root)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">currLayer</span> =</span> root;  <span class="comment">// 首层的链表为树的根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要当前层不为空, 就可以试探下一层</span></span><br><span class="line">    <span class="keyword">while</span> (currLayer) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">node</span> =</span> currLayer;  <span class="comment">// 获取当前层的头节点, 用于遍历</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">nextLayer</span> =</span> <span class="literal">NULL</span>;  <span class="comment">// 记录下一层的头节点</span></span><br><span class="line">        <span class="type">bool</span> isFirst = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        currLayer = <span class="literal">NULL</span>;  <span class="comment">// 置空当前层</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (node) &#123;  <span class="comment">// 遍历当前层构成的链表</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">data</span>[2] =</span> &#123;node-&gt;left, node-&gt;right&#125;;</span><br><span class="line">            <span class="comment">// 遍历当前节点的左右节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (data[i]) &#123;</span><br><span class="line">                    <span class="comment">// 判断是否是下一层的第一个节点</span></span><br><span class="line">                    <span class="keyword">if</span> (isFirst) &#123;</span><br><span class="line">                        nextLayer = data[i];</span><br><span class="line">                        currLayer = nextLayer;  <span class="comment">// 更新当前层为下一层头节点, 用于下一轮最外层 while 循环</span></span><br><span class="line">                        isFirst = <span class="literal">false</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        nextLayer-&gt;next = data[i];  <span class="comment">// 链接下一层的节点</span></span><br><span class="line">                        nextLayer = nextLayer-&gt;next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>评论区用户 @M9988：方法二确实比方法一巧妙。但是，作为面试准备的话，我更推崇练习方法一。因为方法一才是层序（BFS）遍历的通用模式。把这个 BFS 模板练熟以后，面试方可信手拈来（再在里面做附加逻辑）。方法二，技巧性强，可以提高，但是面试的话还是把场景套上模板的熟练能力。</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树遍历</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
        <tag>树遍历</tag>
        <tag>层序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 21 合并两个有序链表</title>
    <url>/posts/231026101239.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21 合并两个有序链表</a>：输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">    链表 A：1-&gt;2-&gt;4</span><br><span class="line">    链表 B：1-&gt;3-&gt;4</span><br><span class="line">    合并链表：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>

<h2 id="双指针解法"><a href="# 双指针解法" class="headerlink" title="双指针解法"></a>双指针解法 </h2><p> 使用两个指针遍历链表，分别指向链表 A 和链表 B 的头结点，然后比较两个指针所指向的节点的大小关系，将较小的节点链接到合并链表的末尾，并后移对应的指针；直到其中一个指针为空时，将另一个非空指针指向的剩余链表拼接到合并链表的末尾。</p>
<p>时间复杂度：<code>O(m+n)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">mergeTwoLists</span><span class="params">(<span class="keyword">struct</span> ListNode* list1, <span class="keyword">struct</span> ListNode* list2)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据大小关系确定合并链表的头结点, 并确定每个链表的起始位置</span></span><br><span class="line">    <span class="keyword">if</span> (list1-&gt;val &lt;= list2-&gt;val) &#123;</span><br><span class="line">        head = list1;</span><br><span class="line">        list1 = list1-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        head = list2;</span><br><span class="line">        list2 = list2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> =</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (list1 &amp;&amp; list2) &#123;</span><br><span class="line">        <span class="comment">// 比较两个指针所指向的节点的大小关系，将较小的节点链接到合并链表的末尾</span></span><br><span class="line">        <span class="keyword">if</span> (list1-&gt;val &lt;= list2-&gt;val) &#123;</span><br><span class="line">            cur-&gt;next = list1;</span><br><span class="line">            list1 = list1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur-&gt;next = list2;</span><br><span class="line">            list2 = list2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将非空指针指向的剩余链表拼接到合并链表的末尾</span></span><br><span class="line">    cur-&gt;next = (list1 == <span class="literal">NULL</span> ? list2 : list1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的双指针直接复用的两个链表指针变量。</p>
</blockquote>
<p>上面代码虽然清晰，但是有点长了。其实，我们可以 <strong> 利用一个临时的「哑结点」作为合并链表的头结点的上一个节点</strong>，来简化操作。</p>
<p>这样，就不需要上面代码中 <code>while</code> 循环前的「根据大小关系确定合并链表的头结点, 并确定每个链表的起始位置」判断了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">mergeTwoLists</span><span class="params">(<span class="keyword">struct</span> ListNode* list1, <span class="keyword">struct</span> ListNode* list2)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>;</span>  <span class="comment">// 哑结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> =</span> &amp;dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (list1 &amp;&amp; list2) &#123;</span><br><span class="line">        <span class="comment">// 比较两个指针所指向的节点的大小关系，将较小的节点链接到合并链表的末尾</span></span><br><span class="line">        <span class="keyword">if</span> (list1-&gt;val &lt;= list2-&gt;val) &#123;</span><br><span class="line">            cur-&gt;next = list1;</span><br><span class="line">            list1 = list1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur-&gt;next = list2;</span><br><span class="line">            list2 = list2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将非空指针指向的剩余链表拼接到合并链表的末尾</span></span><br><span class="line">    cur-&gt;next = (list1 == <span class="literal">NULL</span> ? list2 : list1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.next;  <span class="comment">// 返回哑结点的下一个节点, 即为合并链表的头结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归解法"><a href="# 递归解法" class="headerlink" title="递归解法"></a>递归解法 </h2><p> 我们同样可以利用递归实现合并两个链表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">mergeTwoLists</span><span class="params">(<span class="keyword">struct</span> ListNode* list1, <span class="keyword">struct</span> ListNode* list2)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (list1-&gt;val &lt;= list2-&gt;val) &#123;</span><br><span class="line">        list1-&gt;next = mergeTwoLists(list1-&gt;next, list2);</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list2-&gt;next = mergeTwoLists(list1, list2-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这种写法，跟双指针解法中的第一个代码块相似，直接在原有的链表上进行操作，并直接返回较小节点的头节点作为合并后的链表头。</p>
<p>同样地，我们也可以像双指针解法中的第二个代码块那样，利用一个哑结点，将哑结点的下一个节点指向链表 A 和链表 B 中较小的节点 N，并递归地将较小的节点 N 指向后续合并链表的头结点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">mergeTwoLists</span><span class="params">(<span class="keyword">struct</span> ListNode* list1, <span class="keyword">struct</span> ListNode* list2)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> =</span> &amp;dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (list1-&gt;val &lt;= list2-&gt;val) &#123;</span><br><span class="line">        cur-&gt;next = list1;</span><br><span class="line">        list1-&gt;next = mergeTwoLists(list1-&gt;next, list2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cur-&gt;next = list2;</span><br><span class="line">        list2-&gt;next = mergeTwoLists(list1, list2-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">    cur = cur-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 234 回文链表</title>
    <url>/posts/231101094219.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">234 回文链表 </a>：请判断一个链表是否为回文链表。所谓回文链表就是以链表中间为中心点两边对称。<strong> 进阶</strong>：你能否用 <code>O(n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度解决此题？</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;2-&gt;1; 输出: true</span><br><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;1; 输出: false</span><br></pre></td></tr></table></figure>

<h2 id="多次遍历"><a href="# 多次遍历" class="headerlink" title="多次遍历"></a>多次遍历 </h2><p> 我们可以遍历链表中的每个节点，依次把它们存储在数组中，最后从数组的两头往中间判断链表是否是回文数组。</p>
<p>这就需要对链表进行两次遍历。第一次遍历，计算链表的长度，用于申请合适的数组空间；第二次遍历，向数组中存储链表节点。最后，我们需要对数组进行一次遍历，来判断链表是否是回文链表。</p>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(n)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node</span> =</span> head;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算链表的长度</span></span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        size++;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">nums</span>[<span class="title">size</span>];</span></span><br><span class="line">    node = head;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 向数组中存储链表节点</span></span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        nums[size++] = node;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数组的两头往中间判断链表是否是回文链表</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[left++]-&gt;val != nums[right--]-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快慢指针 - 反转链表"><a href="# 快慢指针 - 反转链表" class="headerlink" title="快慢指针 + 反转链表"></a>快慢指针 + 反转链表</h2><blockquote>
<p>你能否用 <code>O(n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度解决此题？</p>
</blockquote>
<p>可以使用快慢指针找到链表的中点，然后断开链表，并将前一段链表进行反转，然后同时遍历两段链表，来判断原链表是否是回文链表。</p>
<p>这样，就不需要额外的申请内存空间（但是会修改入参的内容）。</p>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">newHead</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> =</span> head;  <span class="comment">// 当前节点</span></span><br><span class="line">        head = head-&gt;next;  <span class="comment">// 先找到下一个节点</span></span><br><span class="line">        cur-&gt;next = newHead;  <span class="comment">// 当前节点指向新链表的头</span></span><br><span class="line">        newHead = cur;  <span class="comment">// 更新新链表的头</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快慢指针寻找链表中点两侧的节点</span></span><br><span class="line">    <span class="comment">// 1-&gt;2-&gt;2-&gt;1, 1-&gt;2-&gt;3-&gt;2-&gt;1</span></span><br><span class="line">    <span class="comment">//    ↑  ↑        ↑     ↑</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span> =</span> head, *slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新指定快指针的位置</span></span><br><span class="line">    <span class="keyword">if</span> (fast) &#123;</span><br><span class="line">        fast = slow-&gt;next-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fast = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断开链表, 并反转链表</span></span><br><span class="line">    slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">reverseHead</span> =</span> reverseList(head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断链表是否是回文链表</span></span><br><span class="line">    <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast-&gt;val != reverseHead-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        reverseHead = reverseHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 2 两数相加</title>
    <url>/posts/231031120718.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/add-two-numbers/">2 两数相加 </a>：给出两个<strong> 非空 </strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong> 逆序 </strong> 的方式存储的，并且它们的每个节点只能存储 <strong> 一位 </strong> 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure>

<h2 id="一次遍历（哑结点）"><a href="# 一次遍历（哑结点）" class="headerlink" title="一次遍历（哑结点）"></a>一次遍历（哑结点）</h2><p>对于待相加的两个链表中的节点，它们相加可能出现进位（相加的值大于 9）。这时在下次相加时就要考虑这个带进位的结果；同时，最后一次相加的结果可能有进位，也可能没有进位，这也是不能忽略的。</p>
<p>每次相加都要创建一个链表节点，用于存储相加的值，并把它们链接起来，形成题目要求的返回的新链表。</p>
<p>时间复杂度：<code>O(max(m, n))</code>，空间复杂度：<code>O(1)</code>，不考虑输出占用的空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">addTwoNumbers</span><span class="params">(<span class="keyword">struct</span> ListNode* l1, <span class="keyword">struct</span> ListNode* l2)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> =</span> &amp;dummy;</span><br><span class="line">    <span class="type">int</span> curSum = <span class="number">0</span>, carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l1 || l2 || carry &gt; <span class="number">0</span>) &#123;  <span class="comment">// 把最后一次加法是否有进位放在这里, 简化代码</span></span><br><span class="line">        <span class="comment">// 创建节点并指向 NULL</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node</span> =</span> (<span class="keyword">struct</span> ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算当前两节点相加的和, 加上进位</span></span><br><span class="line">        curSum = carry;</span><br><span class="line">        <span class="keyword">if</span> (l1) &#123;</span><br><span class="line">            curSum += l1-&gt;val;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2) &#123;</span><br><span class="line">            curSum += l2-&gt;val;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算本次加法的进位和相加值</span></span><br><span class="line">        carry = curSum &gt; <span class="number">9</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        curSum = curSum % <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将下一个节点指向新节点, 并修改其值为相加值</span></span><br><span class="line">        node-&gt;val = curSum;</span><br><span class="line">        cur-&gt;next = node;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// // 判断最后一次加法是否有进位, 有责增加一个节点存储进位值</span></span><br><span class="line">    <span class="comment">// if (carry &gt; 0) &#123;</span></span><br><span class="line">    <span class="comment">//     struct ListNode *node = (struct ListNode *)malloc(sizeof(struct ListNode));</span></span><br><span class="line">    <span class="comment">//     node-&gt;next = NULL;</span></span><br><span class="line">    <span class="comment">//     node-&gt;val = carry;</span></span><br><span class="line">    <span class="comment">//     cur-&gt;next = node;</span></span><br><span class="line">    <span class="comment">//     cur-&gt;next-&gt;next = NULL;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 328 奇偶链表</title>
    <url>/posts/231102120708.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/odd-even-linked-list/">328 奇偶链表</a>：给定一个单链表，把所有的奇数位节点和偶数位节点分别链接在一起，并链接这两个链表（即奇数位的尾结点的下一个节点是偶数位的首节点）。请尝试使用原地算法完成。你的算法的空间复杂度应为 <code>O(1)</code>，时间复杂度应为 <code>O(n)</code>。</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: head = [1,2,3,4,5]</span><br><span class="line">输出: [1,3,5,2,4]</span><br><span class="line">输入: head = [2,1,3,5,6,4,7]</span><br><span class="line">输出: [2,3,6,7,1,5,4]</span><br></pre></td></tr></table></figure>


<h2 id="数组 - 遍历"><a href="# 数组 - 遍历" class="headerlink" title="数组 + 遍历"></a>数组 + 遍历 </h2><p> 可以使用两个数组，一个数组按序存储奇数位节点，一个数组按序存储偶数位节点。最后，先遍历奇数数组，再遍历偶数数组，即可。</p>
<p>时间复杂度：<code>O(n)</code>，三趟遍历，空间复杂度：<code>O(n)</code>，用于临时存储链表中的节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">oddEvenList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node</span> =</span> head;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        size++;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    node = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配两个数组的空间, 使用位运算计算</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">odd</span>[(<span class="title">size</span> &gt;</span>&gt; <span class="number">1</span>) + (size &amp; <span class="number">1</span>)];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">even</span>[(<span class="title">size</span> &gt;</span>&gt; <span class="number">1</span>)];</span><br><span class="line">    <span class="type">int</span> oddIdx = <span class="number">0</span>, evenIdx = <span class="number">0</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((size &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 一个数组按序存储奇数位节点</span></span><br><span class="line">            odd[oddIdx++] = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 一个数组按序存储偶数位节点</span></span><br><span class="line">            even[evenIdx++] = node;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先遍历奇数数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; oddIdx; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; oddIdx - <span class="number">1</span>) &#123;</span><br><span class="line">            odd[i]-&gt;next = odd[i + <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 奇数位的尾结点的下一个节点是偶数位的首节点</span></span><br><span class="line">            odd[i]-&gt;next = even[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再遍历偶数数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; evenIdx; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; evenIdx - <span class="number">1</span>) &#123;</span><br><span class="line">            even[i]-&gt;next = even[i + <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            even[i]-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双指针交替遍历"><a href="# 双指针交替遍历" class="headerlink" title="双指针交替遍历"></a>双指针交替遍历 </h2><p> 可以使用奇指针和偶指针两个指针来进行模拟。首先，奇指针 <code>odd</code> 指向链表第一个节点，偶指针 <code>even</code> 指向链表第二个节点。那么，偶指针的下一个节点 <code>even-&gt;next</code> 就是下一个奇数节点 <code>odd = even-&gt;next</code>，这个奇数节点的下一个节点就是下一个偶数节点 <code>even = odd-&gt;next</code>。然后，我们将前后相邻的奇数位、偶数位节点分别链接起来。最后，再将最后一个奇数位节点链接到第一个偶数位节点即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ------- </span><br><span class="line">|       |</span><br><span class="line">1---2---3---4---5</span><br><span class="line"> -/- -/-</span><br><span class="line">    |       |</span><br><span class="line">     -------</span><br><span class="line"></span><br><span class="line">         -------</span><br><span class="line">        |       |</span><br><span class="line">1---2---3---4---5</span><br><span class="line">         -/- -/-</span><br><span class="line">            |       |</span><br><span class="line">             -------</span><br></pre></td></tr></table></figure>

<p>时间复杂度：<code>O(n)</code>，一趟遍历，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">oddEvenList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">odd</span> =</span> head, *even = head-&gt;next;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">evenHead</span> =</span> even;  <span class="comment">// 记录第一个偶数位节点, 否则会因为破坏链表的链接关系, 无法找到这个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (odd-&gt;next &amp;&amp; even-&gt;next) &#123;</span><br><span class="line">        <span class="comment">// 临时记录奇数位和偶数位节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">oddTmp</span> =</span> odd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">evenTmp</span> =</span> even;</span><br><span class="line">        <span class="comment">// 找到下一个奇数位和偶数位节点</span></span><br><span class="line">        odd = even-&gt;next;  <span class="comment">// odd = odd-&gt;next-&gt;next;</span></span><br><span class="line">        even = odd-&gt;next;  <span class="comment">// even = even-&gt;next-&gt;next;</span></span><br><span class="line">        <span class="comment">// 分别链接前后相邻的奇数位和偶数位节点</span></span><br><span class="line">        oddTmp-&gt;next = odd;</span><br><span class="line">        evenTmp-&gt;next = even;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将最后一个奇数位节点链接到第一个偶数位节点</span></span><br><span class="line">    odd-&gt;next = evenHead;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>while</code> 循环中，<code>odd-&gt;next &amp;&amp; even-&gt;next</code> 表示 <strong> 至少还有未链接到奇数链表末尾的奇数位节点</strong>，这个条件等价于 <code>odd-&gt;next &amp;&amp; odd-&gt;next-&gt;next</code>。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 435 无重叠区间</title>
    <url>/posts/231109150855.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435 无重叠区间</a>：给定一个区间的集合 <code>intervals</code>，其中 <code>intervals[i] = [start_i, end_i]</code>。返回需要移除区间的最小数量，使剩余区间互不重叠。注意，区间 <code>[1,2]</code> 和 <code>[2,3]</code> 的边界相互接触，但没有相互重叠。</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: intervals = [[1,4],[2,3],[4,6]]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 移除 [1,4] 后，剩下的区间没有重叠。</span><br></pre></td></tr></table></figure>

<h2 id="右区间排序 - 贪心算法"><a href="# 右区间排序 - 贪心算法" class="headerlink" title="右区间排序 + 贪心算法"></a>右区间排序 + 贪心算法 </h2><p> 既然说，移除最少的区间，使剩下区间互相不重叠。对于示例，因为 <code>[1,4]</code> 和 <code>[2,3]</code> 这两个区间重叠了，但都没跟 <code>[4,6]</code> 区间重叠，而 <code>[1,4]</code> 区间的右边界太大了，可能会影响到后续区间的最小值，有造成更多区间被移除的风险。所以，我们才移除右边界较大的那个区间。</p>
<p>因此，我们可以按照区间的右边界升序排序，然后使用一前、一后两个指针，指向待比较的两个区间，判断这两个区间是否需要移除一个：</p>
<ul>
<li>前指针指向的区间的右边界不大于后指针指向的区间的左边界，则不需要移除：<ul>
<li>前指针指向后区间，后指针后移一个区间</li>
</ul>
</li>
<li>前指针指向的区间的右边界大于后指针指向的区间的左边界，则需要移除：<ul>
<li>直接移除后区间（区间已经排序，留下右边界小的区间），前指针保持固定，后指针后移一个区间</li>
</ul>
</li>
</ul>
<p>时间复杂度：<code>O(nlogn)</code>，排序所需时间，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *pa, <span class="type">const</span> <span class="type">void</span> *pb)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *arr1 = *(<span class="type">const</span> <span class="type">int</span> **)pa;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *arr2 = *(<span class="type">const</span> <span class="type">int</span> **)pb;</span><br><span class="line">    <span class="keyword">return</span> arr1[<span class="number">1</span>] - arr2[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>** intervals, <span class="type">int</span> intervalsSize, <span class="type">int</span>* intervalsColSize)</span>&#123;</span><br><span class="line">    qsort(intervals, intervalsSize, <span class="keyword">sizeof</span>(intervals[<span class="number">0</span>]), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pre = <span class="number">0</span>, cur = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt; intervalsSize) &#123;</span><br><span class="line">        <span class="comment">// 不需要移除</span></span><br><span class="line">        <span class="keyword">if</span> (intervals[pre][<span class="number">1</span>] &lt;= intervals[cur][<span class="number">0</span>]) &#123;</span><br><span class="line">            pre = cur;  <span class="comment">// 前指针指向后一个区间</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 需要移除</span></span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        cur++;  <span class="comment">// 后指针后移一个区间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="左区间排序 - 贪心算法"><a href="# 左区间排序 - 贪心算法" class="headerlink" title="左区间排序 + 贪心算法"></a>左区间排序 + 贪心算法 </h2><p> 当然，我们也可以按照区间的左边界升序排序。但在需要移除时，需要进一步判断是移除前一个区间，还是后一个区间；也就是，对上一节中的「直接移除后区间（区间已经排序，留下右边界小的区间）」的判断。</p>
<p>时间复杂度：<code>O(nlogn)</code>，排序所需时间，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *pa, <span class="type">const</span> <span class="type">void</span> *pb)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *arr1 = *(<span class="type">const</span> <span class="type">int</span> **)pa;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *arr2 = *(<span class="type">const</span> <span class="type">int</span> **)pb;</span><br><span class="line">    <span class="keyword">return</span> arr1[<span class="number">0</span>] - arr2[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>** intervals, <span class="type">int</span> intervalsSize, <span class="type">int</span>* intervalsColSize)</span>&#123;</span><br><span class="line">    qsort(intervals, intervalsSize, <span class="keyword">sizeof</span>(intervals[<span class="number">0</span>]), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pre = <span class="number">0</span>, cur = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt; intervalsSize) &#123;</span><br><span class="line">        <span class="comment">// 不需要移除</span></span><br><span class="line">        <span class="keyword">if</span> (intervals[pre][<span class="number">1</span>] &lt;= intervals[cur][<span class="number">0</span>]) &#123;</span><br><span class="line">            pre = cur;  <span class="comment">// 前指针指向后一个区间</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 需要移除</span></span><br><span class="line">            <span class="comment">// 进一步判断是移除前一个区间，还是后一个区间</span></span><br><span class="line">            <span class="keyword">if</span> (intervals[pre][<span class="number">1</span>] &gt;= intervals[cur][<span class="number">1</span>]) &#123;</span><br><span class="line">                pre = cur;  <span class="comment">// 移除前一个区间</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        cur++;  <span class="comment">// 后指针后移一个区间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个题目，其实是 <strong> 预定会议的一个问题</strong>，给定若干个会议时间（开始时间 - 结束时间），然后去预定会议，那么能够成功预定的最大会议数是多少？其核心是找出最大不重叠区间的个数。</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 445 两数相加 II</title>
    <url>/posts/231031163133.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/add-two-numbers-ii/">445 两数相加 II</a>：给你两个非空链表来代表两个非负整数。<strong>数字最高位位于链表开始位置</strong>。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。你可以假设除了数字 0 之外，这两个数字都不会以零开头。进阶：如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [7,2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,8,0,7]</span><br></pre></td></tr></table></figure>

<h2 id="反转链表再遍历"><a href="# 反转链表再遍历" class="headerlink" title="反转链表再遍历"></a>反转链表再遍历 </h2><p> 其实我们可以利用 <a href="https://pursue26.github.io/posts/231025185947.html">LeetCode 刷题之 206 反转链表 </a> 和 <a href="https://pursue26.github.io/posts/231031120718.html">LeetCode 刷题之 2 两数相加 </a> 完成该题。</p>
<p>首先，将链表 <code>l1</code> 和链表 <code>l2</code> 反转，然后调用两数相加的代码，最后再对返回的链表再次反转即可。</p>
<p>时间复杂度：<code>O(max(m, n))</code>，空间复杂度：<code>O(1)</code>，不考虑输出占用的空间；递归调用栈的空间复杂度：<code>O(max(m, n))</code>，如果采用迭代的方式反转链表，则为常数空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">tail</span> =</span> reverseList(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">addTwoNumbers_i</span><span class="params">(<span class="keyword">struct</span> ListNode* l1, <span class="keyword">struct</span> ListNode* l2)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> =</span> &amp;dummy;</span><br><span class="line">    <span class="type">int</span> curSum = <span class="number">0</span>, carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l1 || l2 || carry &gt; <span class="number">0</span>) &#123;  <span class="comment">// 把最后一次加法是否有进位放在这里, 简化代码</span></span><br><span class="line">        <span class="comment">// 创建节点并指向 NULL</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node</span> =</span> (<span class="keyword">struct</span> ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算当前两节点相加的和, 加上进位</span></span><br><span class="line">        curSum = carry;</span><br><span class="line">        <span class="keyword">if</span> (l1) &#123;</span><br><span class="line">            curSum += l1-&gt;val;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2) &#123;</span><br><span class="line">            curSum += l2-&gt;val;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算本次加法的进位和相加值</span></span><br><span class="line">        carry = curSum &gt; <span class="number">9</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        curSum = curSum % <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将下一个节点指向新节点, 并修改其值为相加值</span></span><br><span class="line">        node-&gt;val = curSum;</span><br><span class="line">        cur-&gt;next = node;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">addTwoNumbers</span><span class="params">(<span class="keyword">struct</span> ListNode* l1, <span class="keyword">struct</span> ListNode* l2)</span>&#123;</span><br><span class="line">    l1 = reverseList(l1);</span><br><span class="line">    l2 = reverseList(l2);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">head</span> =</span> addTwoNumbers_i(l1, l2);</span><br><span class="line">    <span class="keyword">return</span> reverseList(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LIFO 堆栈"><a href="#LIFO 堆栈" class="headerlink" title="LIFO 堆栈"></a>LIFO 堆栈</h2><blockquote>
<p>进阶：如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p>
</blockquote>
<p><strong>记住：如果需要考虑链表反转，首先考虑栈（后进先出）</strong>。</p>
<p>因此，我们可以申请两个栈空间，依次遍历两个链表，将节点按遍历顺序放入各自的堆栈中。然后，依次同时从两个堆栈中各弹出一个节点，进行两数相加，将相加形成的新节点，放入第三个堆栈中，直到相加操作结束。最后，依次弹出第三个堆栈中的节点，并将它们链接在一起，即为答案。</p>
<p>堆栈的实现：我们可以使用 <a href="https://pursue26.github.io/posts/231016161508.html"> 数据结构之堆栈（数组实现）</a>或 <a href="https://pursue26.github.io/posts/231016184406.html"> 数据结构之堆栈（链表实现）</a>中实现的堆栈数据结构。但是，为了简便，这里使用了普通数组来模拟堆栈。</p>
<p>时间复杂度：<code>O(max(m, n))</code>，空间复杂度：<code>O(max(m, n))</code>，即堆栈占用的空间，不考虑输出占用的空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">addTwoNumbers</span><span class="params">(<span class="keyword">struct</span> ListNode* l1, <span class="keyword">struct</span> ListNode* l2)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">stack1</span>[101], *<span class="title">stack2</span>[101], *<span class="title">stack3</span>[101];</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node1</span> =</span> l1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node2</span> =</span> l2;</span><br><span class="line">    <span class="type">int</span> pos1 = <span class="number">0</span>, pos2 = <span class="number">0</span>, pos3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (node1) &#123;</span><br><span class="line">        stack1[pos1++] = node1;</span><br><span class="line">        node1 = node1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (node2) &#123;</span><br><span class="line">        stack2[pos2++] = node2;</span><br><span class="line">        node2 = node2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pos1--;  <span class="comment">// 变成索引值</span></span><br><span class="line">    pos2--;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> curSum = <span class="number">0</span>, carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos1 &gt;= <span class="number">0</span> || pos2 &gt;= <span class="number">0</span> || carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建节点并指向 NULL</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node</span> =</span> (<span class="keyword">struct</span> ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算当前两节点相加的和, 加上进位</span></span><br><span class="line">        curSum = carry;</span><br><span class="line">        <span class="keyword">if</span> (pos1 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            curSum += stack1[pos1]-&gt;val;</span><br><span class="line">            pos1--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            curSum += stack2[pos2]-&gt;val;</span><br><span class="line">            pos2--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算本次加法的进位和相加值</span></span><br><span class="line">        carry = curSum &gt; <span class="number">9</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        curSum = curSum % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 相加和入第三个堆栈</span></span><br><span class="line">        node-&gt;val = curSum;</span><br><span class="line">        stack3[pos3++] = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">ans</span> =</span> stack3[--pos3];</span><br><span class="line">    <span class="comment">// 依次弹出第三个堆栈中的节点</span></span><br><span class="line">    <span class="keyword">while</span> (pos3 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        stack3[pos3]-&gt;next = stack3[pos3 - <span class="number">1</span>];</span><br><span class="line">        pos3--;</span><br><span class="line">    &#125;</span><br><span class="line">    stack3[pos3]-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 725 分隔链表</title>
    <url>/posts/231101135228.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/split-linked-list-in-parts/">725 分隔链表</a>：给定一个头结点为 <code>root</code> 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 <code>null</code>。这 k 个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。返回一个由上述 k 部分组成的数组。</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3], k = 5</span><br><span class="line">输出：[[1],[2],[3],[],[]]</span><br><span class="line">输入：head = [1,2,3,4,5,6,7,8,9,10], k = 3</span><br><span class="line">输出：[[1,2,3,4],[5,6,7],[8,9,10]]</span><br></pre></td></tr></table></figure>

<p>函数接口：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode** <span class="title function_">splitListToParts</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> k, <span class="type">int</span>* returnSize)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="两趟遍历"><a href="# 两趟遍历" class="headerlink" title="两趟遍历"></a>两趟遍历 </h2><p> 该题就是正常的遍历，然后划分即可。首先，一次遍历计算链表的长度 <code>size</code>；然后，根据链表长度 <code>size</code> 和 <code>k</code> 值，计算划分的链表的长度，前 <code>size % k</code> 段的长度为 <code>size / k + 1</code>，后 <code>size - size % k</code> 段的长度为 <code>size / k</code>。</p>
<p>时间复杂度：<code>O(n)</code>，两趟遍历，空间复杂度：<code>O(1)</code>，不算输出占用的空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode** <span class="title function_">splitListToParts</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> k, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node</span> =</span> head;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算链表长度</span></span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        size++;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    node = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请返回的空间, 并全部初始化为 NULL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> **<span class="title">ans</span> =</span> (<span class="keyword">struct</span> ListNode **)<span class="built_in">malloc</span>(k * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode *));</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0</span>, k * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode *));</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a = size / k, b = size % k;</span><br><span class="line">    <span class="type">int</span> splitSize = <span class="number">0</span>, idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> save = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        <span class="comment">// 存储划分的每段链表的头节点</span></span><br><span class="line">        <span class="keyword">if</span> (save) &#123;</span><br><span class="line">            ans[idx++] = node;</span><br><span class="line">            save = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        splitSize++;</span><br><span class="line">        <span class="comment">// 前 b 次划分的链表长度为 a+1, 后 size-b 次划分的链表长度为 a</span></span><br><span class="line">        <span class="keyword">if</span> (splitSize &lt; a + (b &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>)) &#123;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            splitSize = <span class="number">0</span>;</span><br><span class="line">            b = fmax(--b, <span class="number">0</span>);  <span class="comment">// b 减到 0 停止</span></span><br><span class="line">            save = <span class="literal">true</span>;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">tmp</span> =</span> node;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = k;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 83 删除排序链表中的重复元素</title>
    <url>/posts/231026184514.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83 删除排序链表中的重复元素</a>：给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">输出: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure>

<h2 id="双指针解法"><a href="# 双指针解法" class="headerlink" title="双指针解法"></a>双指针解法 </h2><p> 我们可以使用 <strong> 一前、一后两个指针，找到前、后相邻的两个值不相等的节点，将它们链接起来</strong>。然后，将「前指针」重新指向「后指针」，「后指针」往后移动，继续找前、后相邻的两个值不相等的节点…直到后指针为空为止。</p>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">deleteDuplicates</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">left</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">right</span> =</span> head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left-&gt;val == right-&gt;val) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">temp</span> =</span> right;</span><br><span class="line">            right = right-&gt;next;</span><br><span class="line">            <span class="comment">// 释放节点空间</span></span><br><span class="line">            temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将它们链接起来</span></span><br><span class="line">            left-&gt;next = right;</span><br><span class="line">            <span class="comment">// 将前指针重新指向后指针，后指针往后移动</span></span><br><span class="line">            left = right;</span><br><span class="line">            right = right-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    left-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么退出前还有一行 <code>left-&gt;next = NULL</code> 代码？<br>这是因为，如果原链表最后是以重复的元素退出 <code>while</code> 循环的，则 <code>left</code> 就是最后一个节点，但 <code>left-&gt;next</code> 此时还不是 <code>NULL</code>，所以需要这一行代码。</p>
<h2 id="单指针解法"><a href="# 单指针解法" class="headerlink" title="单指针解法"></a>单指针解法 </h2><p> 其实，我们也可以只使用一个指针，这个指针指向当前节点，只要「下一个节点」与当前节点的值相等，我们就更新当前节点的 <strong> 下一个节点 </strong> 为「再」下一个节点；遇到不相等时，才 <strong> 更新当前指针 </strong> 为「下一个节点」。</p>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">deleteDuplicates</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 「下一个节点」与当前节点的值相等</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val == cur-&gt;next-&gt;val) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">temp</span> =</span> cur-&gt;next;</span><br><span class="line">            <span class="comment">// 更新当前节点的下一个节点为「再」「下一个节点」</span></span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            <span class="comment">// 释放节点空间</span></span><br><span class="line">            temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不相等时，才更新当前指针为「下一个节点」</span></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归解法"><a href="# 递归解法" class="headerlink" title="递归解法"></a>递归解法 </h2><p> 假设，函数 <code>deleteDuplicates(head)</code> 已经了实现删除链表 <code>head</code> 中的重复节点，并返回删除后的链表的头节点。</p>
<p>那么，我们以 <code>head-&gt;next</code> 为头节点调用函数 <code>deleteDuplicates(head-&gt;next)</code>，将实现以 <code>head-&gt;next</code> 为头节点的 <strong> 子链表 </strong> 的去重操作，这时只需要将 <code>head</code> 的下一个节点指向这个去重的链表，就可以实现对 <strong> 完整链表 </strong> 的去重操作了。</p>
<p>但是，可能会遇到 <code>head</code> 和它的下一个节点 <code>head-&gt;next</code> 的值相等的时候，这是就需要 <strong> 修正头节点的地址</strong> —— 抛弃前面的节点。</p>
<p>递归的终止条件就是，链表为空或者只有一个节点。因为这时不需要进行去重操作。</p>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(n)</code>。</p>
<p>一种写法：先递归处理下一个节点，然后再判断下一个节点的值是否与当前节点的值相等，如果相等则删除当前节点，重新指定头节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">deleteDuplicates</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    head-&gt;next = deleteDuplicates(head-&gt;next);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next-&gt;val == head-&gt;val) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">temp</span> =</span> head;</span><br><span class="line">        head = head-&gt;next;  <span class="comment">// 修正头节点的地址</span></span><br><span class="line">        temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种写法：先判断下一个节点的值是否与当前节点的值相等，如果相等则先删除当前节点，然后递归地处理下一个节点，并更新头节点为删除重复节点之后的头节点；否则，说明相邻节点不重复，递归地处理下一个节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">deleteDuplicates</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next-&gt;val == head-&gt;val) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">temp</span> =</span> head-&gt;next;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(head);</span><br><span class="line">        head = deleteDuplicates(temp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        head-&gt;next = deleteDuplicates(head-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不管哪种写法，针对链表中的重复节点，都是删除前面的节点，保留下最后一个节点。</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>博客文章分类汇总</title>
    <url>/posts/summary.html</url>
    <content><![CDATA[<center><b>这篇文章是个人博客中系列文章的分类汇总。</b></center>

<span id="more"></span>

<h1 id="基础知识"><a href="# 基础知识" class="headerlink" title="基础知识"></a>基础知识 </h1><p><a href="https://pursue26.github.io/posts/231010144856.html"> 模运算（求余运算）</a><br><a href="https://pursue26.github.io/posts/231014105311.html">异或运算</a></p>
<h1 id="C 语言系列"><a href="#C 语言系列" class="headerlink" title="C 语言系列"></a>C 语言系列</h1><p><a href="https://pursue26.github.io/posts/230916171929.html">C 语言之 main 函数参数</a><br><a href="https://pursue26.github.io/posts/230922143003.html">C 语言之多维数组</a><br><a href="https://pursue26.github.io/posts/230913200729.html">C 语言之 const 关键字</a><br><a href="https://pursue26.github.io/posts/230918174223.html">C 语言之 typedef 自定义类型基础</a><br><a href="https://pursue26.github.io/posts/230920172849.html">C 语言之 typedef 实践</a><br><a href="https://pursue26.github.io/posts/230922172626.html">C 语言之 uthash 哈希表基础</a><br><a href="https://pursue26.github.io/posts/230921094127.html">C 语言之锁与原子操作基础</a><br><a href="https://pursue26.github.io/posts/230911151334.html">C 语言之 pthread 多线程</a><br><a href="https://pursue26.github.io/posts/230918114841.html">C 语言之大小端知识</a></p>
<h1 id="Golang 语言系列"><a href="#Golang 语言系列" class="headerlink" title="Golang 语言系列"></a>Golang 语言系列</h1><p><a href="https://pursue26.github.io/posts/230907162612.html">Go 笔记之变量与常量</a><br><a href="https://pursue26.github.io/posts/230909120145.html">Go 笔记之函数 &amp; 包 &amp; 判断 &amp; 循环</a><br><a href="https://pursue26.github.io/posts/230912152800.html">Go 笔记之数组与切片</a><br><a href="https://pursue26.github.io/posts/230913161326.html">Go 笔记之可变参数函数与 Map 集合</a><br><a href="https://pursue26.github.io/posts/230915155105.html">Go 笔记之字符串和指针</a></p>
<h1 id="数据结构与算法系列"><a href="# 数据结构与算法系列" class="headerlink" title="数据结构与算法系列"></a>数据结构与算法系列 </h1><h2 id="数据结构系列"><a href="# 数据结构系列" class="headerlink" title="数据结构系列"></a> 数据结构系列 </h2><p><a href="https://pursue26.github.io/posts/231007174854.html"> 数据结构之链表（数组实现）</a><br><a href="https://pursue26.github.io/posts/231016161508.html">数据结构之堆栈（数组实现）</a><br><a href="https://pursue26.github.io/posts/231016184406.html">数据结构之堆栈（链表实现）</a><br><a href="https://pursue26.github.io/posts/231017105123.html">数据结构之队列（链表实现）</a><br><a href="https://pursue26.github.io/posts/231017154121.html">数据结构之双端队列（链表实现）</a><br><a href="https://pursue26.github.io/posts/231018102559.html">数据结构之堆基础与堆结构（数组实现）</a><br><a href="https://pursue26.github.io/posts/231019102311.html">数据结构之优先队列（堆实现）</a><br><a href="https://pursue26.github.io/posts/230905224335.html">数据结构之二叉树的遍历 </a><br><a href="https://pursue26.github.io/posts/231020174358.html"> 数据结构之二叉搜索树 </a><br><a href="https://pursue26.github.io/posts/230916094606.html"> 数据结构之拓扑排序 </a><br><a href="https://pursue26.github.io/posts/230925185057.html"> 数据结构之 Trie 字典树 </a><br><a href="https://pursue26.github.io/posts/231023164532.html"> 数据结构之并查集（数组实现）</a></p>
<h2 id="数据结构算法系列"><a href="# 数据结构算法系列" class="headerlink" title="数据结构算法系列"></a>数据结构算法系列 </h2><h3 id="排序算法系列"><a href="# 排序算法系列" class="headerlink" title="排序算法系列"></a> 排序算法系列 </h3><p><a href="https://pursue26.github.io/posts/231108163339.html"> 数据结构算法之快速排序 </a><br><a href="https://pursue26.github.io/posts/231107171607.html"> 数据结构算法之堆排序</a></p>
<h1 id="Docker 系列"><a href="#Docker 系列" class="headerlink" title="Docker 系列"></a>Docker 系列</h1><p><a href="https://pursue26.github.io/posts/230909171809.html">Docker 学习笔记</a></p>
<h1 id="计算机网络系列"><a href="# 计算机网络系列" class="headerlink" title="计算机网络系列"></a>计算机网络系列 </h1><p><a href="https://pursue26.github.io/posts/231011192359.html"> 计网之 OSI 参考模型</a></p>
<h1 id="操作系统系列"><a href="# 操作系统系列" class="headerlink" title="操作系统系列"></a>操作系统系列 </h1><h2 id="操作系统课程学习（清华大学 - 陈渝老师）"><a href="# 操作系统课程学习（清华大学 - 陈渝老师）" class="headerlink" title="操作系统课程学习（清华大学 - 陈渝老师）"></a> 操作系统课程学习（清华大学 - 陈渝老师）</h2><p><a href="https://pursue26.github.io/posts/230921190726.html">操作系统之 chapter1 概述 </a><br><a href="https://pursue26.github.io/posts/230924172528.html"> 操作系统之 chapter2 启动 &amp; 中断 &amp; 异常 &amp; 系统调用 </a><br><a href="https://pursue26.github.io/posts/231017195157.html"> 操作系统之 chapter3.1 内存分层体系与地址空间生成 </a><br><a href="https://pursue26.github.io/posts/231108195351.html"> 操作系统之 chapter3.2 连续内存分配</a></p>
<h1 id="LeetCode 刷题系列"><a href="#LeetCode 刷题系列" class="headerlink" title="LeetCode 刷题系列"></a>LeetCode 刷题系列 </h1><h2 id="链表相关"><a href="# 链表相关" class="headerlink" title="链表相关"></a> 链表相关</h2><p><a href="https://pursue26.github.io/posts/231025143947.html">LeetCode 刷题之 160 相交链表</a><br><a href="https://pursue26.github.io/posts/231025185947.html">LeetCode 刷题之 206 反转链表</a><br><a href="https://pursue26.github.io/posts/231026101239.html">LeetCode 刷题之 21 合并两个有序链表</a><br><a href="https://pursue26.github.io/posts/231026184514.html">LeetCode 刷题之 83 删除排序链表中的重复元素</a><br><a href="https://pursue26.github.io/posts/231027150243.html">LeetCode 刷题之 19 删除链表的倒数第 N 个节点</a><br><a href="https://pursue26.github.io/posts/231031120718.html">LeetCode 刷题之 2 两数相加</a><br><a href="https://pursue26.github.io/posts/231031163133.html">LeetCode 刷题之 445 两数相加 II</a><br><a href="https://pursue26.github.io/posts/231101094219.html">LeetCode 刷题之 234 回文链表</a><br><a href="https://pursue26.github.io/posts/231101135228.html">LeetCode 刷题之 725 分隔链表</a><br><a href="https://pursue26.github.io/posts/231102120708.html">LeetCode 刷题之 328 奇偶链表</a><br><a href="https://pursue26.github.io/posts/231102165703.html">LeetCode 刷题之 142 环形链表 II</a></p>
<h2 id="贪心算法"><a href="# 贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p><a href="https://pursue26.github.io/posts/231107094652.html">LeetCode 刷题之 1029 两地调度</a><br><a href="https://pursue26.github.io/posts/231109150855.html">LeetCode 刷题之 435 无重叠区间</a></p>
<h2 id="树的遍历"><a href="# 树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><p><a href="https://pursue26.github.io/posts/231103121209.html">LeetCode 刷题之 117 填充每个节点的下一个右侧节点指针 II</a></p>
]]></content>
  </entry>
  <entry>
    <title>异或运算</title>
    <url>/posts/231014105311.html</url>
    <content><![CDATA[<p>异或是一个数学运算符，英文为 exclusive OR，缩写成 XOR。异或的数学符号为 $\bigoplus$，计算机符号为「XOR」。如果二进制数 a 和 b 的同位置的值不相同，则该位置的结果为 1，反之为 0。</p>
<span id="more"></span>

<h2 id="异或也叫半加运算"><a href="# 异或也叫半加运算" class="headerlink" title="异或也叫半加运算"></a>异或也叫半加运算 </h2><p> 异或也叫半加运算，其运算法则相当于 <strong> 不带进位的二进制加法</strong>，如 $0 \bigoplus 0=0, 1 \bigoplus 0=1, 0 \bigoplus 1=1, 1 \bigoplus 1=0$，这些法则与加法是相同的，如 $0+0=0, 1+0=1, 0+1=1, 1+1=(1)0$，只是不带进位，所以异或常被认作不进位加法。</p>
<h2 id="异或运算性质"><a href="# 异或运算性质" class="headerlink" title="异或运算性质"></a>异或运算性质</h2><ol>
<li>归零律：任何数与自身异或都等于 0，即 $a \bigoplus a=0$</li>
<li>恒等律：任何数与 0 异或都等于其本身，即 $a \bigoplus 0=a$</li>
<li>交换律：即 $a \bigoplus b = b \bigoplus a$</li>
<li>结合律：即 $a \bigoplus b \bigoplus c = a \bigoplus (b \bigoplus c) = (a \bigoplus b) \bigoplus c$</li>
<li>自反性：对给定的数 b，用同样的运算因子 a 作两次异或运算后仍得到 b 本身，即 $a \bigoplus b \bigoplus a = b$</li>
</ol>
<h2 id="异或运算应用"><a href="# 异或运算应用" class="headerlink" title="异或运算应用"></a>异或运算应用 </h2><h3 id="交换两个数"><a href="# 交换两个数" class="headerlink" title="交换两个数"></a> 交换两个数 </h3><p> 若需要交换两个 <strong> 整形变量 </strong> 的值，除了通常使用的借用中间变量进行交换外，还可以利用异或的自反性，仅使用两个变量进行交换，如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> &#123;</span><br><span class="line">    (*a) = (*a)^(*b);  <span class="comment">// a1 = a^b</span></span><br><span class="line">    (*b) = (*a)^(*b);  <span class="comment">// b = (a^b)^b = a</span></span><br><span class="line">    (*a) = (*a)^(*b);  <span class="comment">// a = (a^b)^a = b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="找出重复的数"><a href="# 找出重复的数" class="headerlink" title="找出重复的数"></a>找出重复的数 </h3><p> 假设一个集合中有 $n$ 个数，范围为 $[1, n-1]$，其中有 $n - 2$ 个互不相同的数，有一个数重复一次，设计一个 $O(n)$ 时间复杂度，$O(1)$ 空间复杂度的算法，找出这个数。</p>
<p>推导：</p>
<ol>
<li>假设不包含重复的第二个数的所有数的异或的结果为 $1 \bigoplus2 \bigoplus … \bigoplus (n-1) = T$；</li>
<li>那么，包含第二个重复的数的所有数的异或结果为 $1 \bigoplus2 \bigoplus … \bigoplus (n-1) \bigoplus x = T \bigoplus x$。</li>
</ol>
<p>通过自反性可以得出这个重复的数为 $T \bigoplus (T \bigoplus x) = x$。这里利用的异或的自反性，同时需要具备一个前置条件，就是：我们需要知道集合中都出现过哪些数，这样才能求出序号 1 的结果。</p>
<p>例如，下面的代码中，数组 <code>nums[n]</code> 存储着 $[1, n-1]$ 区间中的所有数，但只有一个数是重复的数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">find_duplicate</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  <span class="comment">// 所有数异或</span></span><br><span class="line">        res ^= nums[i];  <span class="comment">// T^x</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;  <span class="comment">// 所有不重复的数异或</span></span><br><span class="line">        res ^= i;  <span class="comment">// res := (T^x)^T</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="找出不成对的一个数"><a href="# 找出不成对的一个数" class="headerlink" title="找出不成对的一个数"></a>找出不成对的一个数</h3><p><a href="https://leetcode.cn/problems/single-number">LeetCode 习题</a>：一个数组存放若干整数，一个数出现奇数次，其余数均出现偶数次，找出这个出现奇数次的数。</p>
<p>思路：使用异或运算的归零律、恒等律和交换律，将数组中的所有数异或求结果，将会是偶数个 0 异或（最终结果还是 0），再异或上那个出现奇数词的数，最终结果就是 0 异或 x，即那个不成对的数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        res ^= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="找出不成对的两个数"><a href="# 找出不成对的两个数" class="headerlink" title="找出不成对的两个数"></a>找出不成对的两个数</h3><p><a href="https://leetcode.cn/problems/single-number-iii">LeetCode 习题</a>：一个数组存放若干整数，两个不同的数出现了奇数次，其余数均出现偶数次，找出这两个出现奇数次的数。</p>
<p>假设这两个出现奇数次的数为 x 和 y：</p>
<ol>
<li>按照上述方法，找到这两个数异或后的结果 z；</li>
<li>在异或中，同位置的值不同则结果为 1。基于此，可以找到 z 的二进制中最右侧的那个 1（假设 x 的二进制在同位置为 1），然后丢弃左侧的二进制数；</li>
<li>再次遍历数组，跳过那个同位置不为 1 的数（即 y），这就等价于数组是「成对的数中有且仅有一个不成对的数」，即找到了一个不成对的数（这里为 x）；</li>
<li>另一个数 y 便是：x^(x^y)，即 x^z。</li>
</ol>
<blockquote>
<p>序号 2 中，当然也可能跳过成对的数，但没关系，因为这个数不会跳过一个、保留一个，就当少了一对成对的数，不会对找出那个不成对的数有影响。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *ans = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">long</span> xor = <span class="number">0</span>, lsb = <span class="number">0</span>;  <span class="comment">// 防止溢出风险</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        xor ^= <span class="number">1LL</span> * nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    lsb = xor &amp; (~xor + <span class="number">1</span>);</span><br><span class="line">    ans[<span class="number">0</span>] = <span class="number">0</span>, ans[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nums[i] &amp; lsb) != <span class="number">0</span>) &#123;</span><br><span class="line">            ans[<span class="number">0</span>] ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[<span class="number">1</span>] = xor ^ ans[<span class="number">0</span>];</span><br><span class="line">    (*returnSize) = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是如何计算上述序号 2 中的那个二进制数的呢？</p>
<p>一个整数 <code>x</code> 与<code>(~x+1)</code>进行按位与运算的结果是将 <code>x</code> 的最右边的 1 保留下来，其他位都置为 0。这个操作通常用于获取 <code>x</code> 的最右边的 1 所代表的值，也可以称为获取 <code>x</code> 的最低有效位（LSB）。<br>举个例子，假设 <code>x</code> 的二进制表示为 10110100，那么 <code>~x</code> 的二进制表示为 01001011，然后再加上 1，得到 <code>(~x+1)</code> 的二进制表示为 01001100。最后，将 <code>x</code> 与<code>(~x+1)</code>进行按位与运算，得到的结果就是 00000100，即 <code>x</code> 的最右边的 1 所代表的值为 4。</p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://www.cnblogs.com/jasonkoo/articles/2760411.html">https://www.cnblogs.com/jasonkoo/articles/2760411.html</a></li>
<li><a href="https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677">https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>异或运算</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter2 启动 &amp; 中断 &amp; 异常 &amp; 系统调用</title>
    <url>/posts/230924172528.html</url>
    <content><![CDATA[<p>这篇文章主要介绍操作系统的启动，中断、异常、系统调用的特征和差别，以及处理流程（机制）。</p>
<span id="more"></span>

<h2 id="操作系统启动"><a href="# 操作系统启动" class="headerlink" title="操作系统启动"></a>操作系统启动 </h2><h3 id="作用解析"><a href="# 作用解析" class="headerlink" title="作用解析"></a> 作用解析</h3><ul>
<li>硬盘（disk）：存放 OS 和 BootLoader</li>
<li>BIOS：基本 I/O 处理系统</li>
<li>BootLoader：用于加载 OS，将 OS 从 disk 加载到内存中</li>
</ul>
<blockquote>
<p>BIOS 是一种固化在计算机主板上的软件程序，其中的一个主要作用就是：启动计算机 —— 当你启动计算机时，<strong>BIOS 是第一个被执行的程序</strong>。它负责进行硬件自检（POST，Power-On Self-Test）以及初始化计算机的硬件设备，包括处理器、内存、硬盘、显卡等。<strong>BIOS 还负责加载操作系统的引导程序（BootLoader）</strong>。</p>
</blockquote>
<h3 id="启动步骤"><a href="# 启动步骤" class="headerlink" title="启动步骤"></a>启动步骤</h3><img src="/images/os-kernel/chapter2/os-startup.png" alt="计算机启动流程" width="60%" height="60%">

<p>操作系统启动过程可以概括为以下几个步骤：</p>
<ol>
<li>电源启动</li>
<li>BIOS 自检</li>
<li>加载引导程序（BootLoader）</li>
<li>引导程序的工作</li>
<li>内核初始化：操作系统内核接管控制权后，它会进行一系列的初始化工作，包括初始化进程管理、内存管理、文件系统等重要的系统组件</li>
<li>用户登录</li>
</ol>
<h4 id="BIOS 自检"><a href="#BIOS 自检" class="headerlink" title="BIOS 自检"></a>BIOS 自检</h4><img src="/images/os-kernel/chapter2/os-startup-layout.png" alt="计算机启动时内存和硬盘布局" width="60%" height="60%">

<p>计算机启动时，BIOS 从一个特定地址（CS:IP = 0xF000:FFF0）开始执行，这两个寄存器合在一起可以形成一个具体的物理内存地址。BIOS 就从这个内存地址开始执行 POST（加电自检）、寻找显卡和执行 BIOS。</p>
<blockquote>
<p>段寄存器（CS）和指令寄存器（IP）是计算机中的两种不同类型的寄存器：<br><strong>段寄存器 </strong> 是用于存储内存中的段地址的寄存器。在计算机中，内存被划分为多个段，每个段都有一个唯一的段地址。段寄存器存储着当前程序正在访问的段的地址。当程序需要访问内存中的数据时，它会使用段寄存器中的地址来确定要访问的段，并将其与偏移地址（存储在其他寄存器中）相加以获取最终的物理地址。<br><strong>指令寄存器（也称为程序计数器）</strong>是用于存储下一条要执行的指令的地址的寄存器。在计算机执行程序时，指令寄存器中保存着当前正在执行的指令的地址。当一条指令执行完毕后，指令寄存器会自动增加，以指向下一条将要执行的指令的地址。这样，计算机可以按顺序执行存储器中的指令序列。指令寄存器的值的改变决定了计算机下一步要执行的操作。</p>
</blockquote>
<h4 id="加载 BootLoader"><a href="# 加载 BootLoader" class="headerlink" title="加载 BootLoader"></a>加载 BootLoader</h4><img src="/images/os-kernel/chapter2/os-load-bootloader.png" alt="BIOS 加载引导程序" width="60%" height="60%">

<p><strong>BIOS 负责加载 BootLoader</strong>：BIOS 会从预设的启动设备（如硬盘、光盘、USB 等）中加载引导程序（BootLoader）到内存中。引导程序通常位于硬盘的特定扇区或光盘的启动区。</p>
<p><strong>引导程序的工作</strong>：引导程序负责初始化硬件（如 CPU、内存等），加载操作系统内核，并将控制权交给内核。它还可以提供多个操作系统的选择菜单（如 GRUB），以供用户选择启动的操作系统。</p>
<h4 id="加载 OS"><a href="# 加载 OS" class="headerlink" title="加载 OS"></a>加载 OS</h4><p>BootLoader 放在硬盘的第一个主引导扇区（512 字节）。这样，BIOS 从硬盘的第一个扇区寻找，一下便能找到 BootLoader。</p>
<img src="/images/os-kernel/chapter2/os-bootloader-address.png" alt="引导程序的内存地址空间" width="60%" height="60%">

<p><strong>BIOS 负责加载 BootLoader</strong>：将 BootLoader 从磁盘的引导扇区加载到 0x7C00 内存地址处。</p>
<p><strong>BootLoader 负责加载 OS</strong>：将操作系统的代码和数据从硬盘加载到内存中。之后，控制权交给到 OS（跳转到 OS 的起始地址）。</p>
<h2 id="中断、异常和系统调用"><a href="# 中断、异常和系统调用" class="headerlink" title="中断、异常和系统调用"></a>中断、异常和系统调用 </h2><p> 操作系统与设备和程序之间的交互可以通过中断、异常和系统调用来实现。</p>
<h3 id="定义"><a href="# 定义" class="headerlink" title="定义"></a>定义 </h3><p><strong> 中断（hardware interrupt）</strong>：是指外部事件（如硬件设备请求、定时器中断等）打断程序的正常执行，引发操作系统的处理程序来处理相应的事件。通过中断，设备可以向操作系统发出请求，操作系统可以响应并进行相应的处理。</p>
<p><strong>异常（exception）</strong>：是指程序执行过程中出现的错误或异常情况，如除零错误、访问非法内存等。当发生异常时，操作系统会捕获并进行相应的处理，例如终止异常程序、显示错误消息等。</p>
<p><strong>系统调用（system call）</strong>：是应用程序通过操作系统提供的接口来请求操作系统的服务。通过系统调用，应用程序可以访问操作系统提供的功能，如文件读写、网络通信、内存管理等。应用程序通过系统调用将请求传递给操作系统，操作系统执行相应的操作，并将结果返回给应用程序。</p>
<h3 id="来源"><a href="# 来源" class="headerlink" title="来源"></a>来源 </h3><p><strong> 中断来源于外设</strong>：来自不同的硬件设备的计时器和网络的中断。</p>
<p><strong>异常来源于不良的应用程序</strong>：非法指令或者其他坏的处理状态（如：内存出错）。</p>
<p><strong>系统调用来源于应用程序</strong>：应用程序主动向操作系统发出服务请求。</p>
<h3 id="处理时间"><a href="# 处理时间" class="headerlink" title="处理时间"></a>处理时间</h3><ul>
<li>中断：异步</li>
<li>异常：同步</li>
<li>系统调用：同步或异步<ul>
<li>同步：指应用程序等待系统调用的返回结果</li>
<li>异步：指应用程序发出系统调用后就去干别的事情了</li>
</ul>
</li>
</ul>
<blockquote>
<p>异步：应用程序不知道什么时候会发生 <br> 同步：执行到某一条指令一定会发生该事件</p>
</blockquote>
<h3 id="响应状态"><a href="# 响应状态" class="headerlink" title="响应状态"></a>响应状态</h3><ul>
<li>中断：持续，对用户应用程序是透明的（用户程序感知不到）</li>
<li>异常：杀死或重新执行指令</li>
<li>系统调用：等待和持续</li>
</ul>
<h3 id="中断、异常和系统调用比较"><a href="# 中断、异常和系统调用比较" class="headerlink" title="中断、异常和系统调用比较"></a>中断、异常和系统调用比较</h3><img src="/images/os-kernel/chapter2/os-interrupt-exception-syscall-compare.png" alt="中断、异常和系统调用比较" width="60%" height="60%">

<table>
<thead>
<tr>
<th>交互方式</th>
<th>来源</th>
<th>处理时间</th>
<th>响应状态</th>
</tr>
</thead>
<tbody><tr>
<td>中断</td>
<td>外设</td>
<td>异步</td>
<td>持续，对用户应用程序透明</td>
</tr>
<tr>
<td>异常</td>
<td>不良的应用程序</td>
<td>同步</td>
<td>杀死或重新执行指令</td>
</tr>
<tr>
<td>系统调用</td>
<td>应用程序</td>
<td>同步或异步</td>
<td>等待和持续</td>
</tr>
</tbody></table>
<h3 id="中断和异常处理流程"><a href="# 中断和异常处理流程" class="headerlink" title="中断和异常处理流程"></a>中断和异常处理流程 </h3><p> 中断是外设的事件，异常是内部 CPU 的事件。中断和异常迫使 CPU 访问一些与中断和异常相关的功能和服务。</p>
<h4 id="中断处理流程"><a href="# 中断处理流程" class="headerlink" title="中断处理流程"></a>中断处理流程 </h4><p> 操作系统的中断处理流程包括硬件中断处理和软件中断处理两个部分。</p>
<p><strong>硬件中断 </strong> 处理流程如下：</p>
<ol>
<li>硬件设备产生中断信号，例如外设完成数据传输、定时器到达计时器溢出等。</li>
<li><strong>CPU 检测到中断信号后，会立即停止当前正在执行的指令，并将当前执行指令的上下文（包括寄存器状态、程序计数器等）保存到内存中的堆栈中</strong>。</li>
<li>CPU 根据中断信号的类型，通过中断向量表或中断描述符表（IDT）查找相应的中断处理程序的入口地址。</li>
<li>CPU 跳转到中断处理程序的入口地址，开始执行中断处理程序。</li>
<li>中断处理程序根据中断类型执行相应的操作，例如处理设备的数据、更新操作系统状态等。</li>
<li><strong>中断处理程序执行完毕后，将之前保存的上下文从堆栈中恢复回来</strong>。</li>
<li>CPU 继续执行被中断的指令或者执行下一个指令。</li>
</ol>
<p><strong>软件中断 </strong> 处理流程如下：</p>
<ol>
<li>程序通过系统调用或软中断指令触发软件中断。</li>
<li>CPU 执行软中断指令后，<strong>会暂停当前正在执行的指令，并将当前执行指令的上下文保存到内存中的堆栈中</strong>。</li>
<li>CPU 根据软中断号，在中断向量表或中断描述符表（IDT）中查找相应的中断处理程序的入口地址。</li>
<li>CPU 跳转到中断处理程序的入口地址，开始执行中断处理程序。</li>
<li>中断处理程序根据软中断号执行相应的操作，例如系统调用、异常处理等。</li>
<li>中断处理程序执行完毕后，<strong>将之前保存的上下文从堆栈中恢复回来</strong>。</li>
<li>CPU 继续执行被中断的指令或者执行下一个指令。<br>可以概括为：“触发软中断——暂存上下文——查表——跳转（进入）——执行——退出——恢复上下文——继续”。</li>
</ol>
<p>中断处理流程可以概括为：“产生中断——暂存上下文——查表——跳转（进入）——执行——退出——恢复上下文——继续执行”。</p>
<p>总的来说，中断处理流程包括 <strong> 中断信号的检测、上下文的保存与恢复、中断处理程序的执行 </strong> 等步骤，以保证操作系统能够及时响应硬件设备的请求或软件的触发。</p>
<blockquote>
<p>应用程序完全不会感知到中断的产生。</p>
</blockquote>
<h4 id="异常处理流程"><a href="# 异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程 </h4><p> 操作系统的异常处理流程如下：</p>
<ol>
<li><strong>异常产生</strong>：异常是指在程序执行过程中发生的错误或异常情况，例如访问非法内存、除零错误等。异常可以由硬件产生，也可以由软件产生。</li>
<li><strong>异常检测</strong>：CPU 会检测到异常的发生，并中断当前正在执行的指令。</li>
<li><strong>异常处理程序选择</strong>：CPU 会通过中断向量表或中断描述符表（IDT）查找相应的异常处理程序的入口地址。</li>
<li><strong>上下文保存</strong>：CPU 会将当前执行指令的上下文（包括寄存器状态、程序计数器等）保存到内存中的堆栈中。</li>
<li><strong>异常处理程序执行</strong>：CPU 跳转到异常处理程序的入口地址，开始执行异常处理程序。</li>
<li><strong>异常处理</strong>：异常处理程序会根据异常类型执行相应的操作，例如打印错误信息、终止异常进程、恢复系统状态等。</li>
<li><strong>上下文恢复</strong>：异常处理程序执行完毕后，将之前保存的上下文从堆栈中恢复回来。</li>
<li><strong>异常返回</strong>：CPU 继续执行被中断（指的是由异常引起的中断，而不是外部设备或事件所引起的中断）的指令或者执行下一个指令。</li>
</ol>
<p>总的来说，异常处理流程包括 <strong> 异常信号的检测、上下文的保存与恢复、异常处理程序的执行 </strong> 等步骤，异常处理流程的目的是在程序出现异常时能够及时处理异常情况，保证系统的稳定性和可靠性。</p>
<h3 id="系统调用"><a href="# 系统调用" class="headerlink" title="系统调用"></a>系统调用 </h3><p> 系统调用来源于应用程序，需要操作系统提供服务，这些服务需要操作系统来执行，这个过程就需要一个接口：<strong>系统调用接口</strong>。应用程序访问主要是通过高层次的 API 接口，而不是直接进行系统调用。</p>
<img src="/images/os-kernel/chapter2/os-syscall.png" alt="系统调用示例" width="60%" height="60%">

<p><strong>三种最常用的 APIs</strong>：</p>
<ul>
<li>Win32 API：用于 Windows</li>
<li>POSIX API：用于 POSIX-based systems（包括 UNIX，LINUX，Mac OS X）</li>
<li>Java API：用于 JAVA 虚拟机（JVM 跨平台）</li>
</ul>
<p><strong>特点</strong>：</p>
<ul>
<li>通常情况下，每个系统调用对应一个系统调用号<ul>
<li>系统调用接口根据这些序号来维护表的索引</li>
</ul>
</li>
<li>系统调用接口调用内核态中预期的系统调用<ul>
<li>并返回系统调用的状态和其他任何返回值</li>
</ul>
</li>
<li>用户不需要知道系统调用是如何实现的<ul>
<li>只需要获取 API 和了解操作系统将什么作为返回结果</li>
<li>操作系统接口的细节大部分都隐藏在 API 中</li>
</ul>
</li>
</ul>
<p><strong>用户态</strong>：操作系统运行中，CPU 所处的特权级别特别低，不能访问特权指令、I/O 指令。</p>
<p><strong>内核态</strong>：操作系统运行中，CPU 所处的级别很高，可以执行任何一条指令，包括特权指令、I/O 指令。</p>
<p><strong>系统调用 </strong>：触发 CPU<strong> 从用户态到内核态的转换</strong>。切换程序和内核的堆栈，需要一定的开销，但是换来了安全。</p>
<p><strong>系统调用是跨越操作系统边界的开销</strong>（值得的且必须的，保证了操作系统的安全性）：</p>
<ul>
<li>在执行时间上的开销超过程序调用</li>
<li>开销：<ul>
<li>建立中断、异常、系统调用号与对应服务例程映射关系的初始化开销</li>
<li>建立内核堆栈（用于内核退出时保存，内核执行时恢复，类似于应用程序的堆栈）</li>
<li>验证参数（内核不信任应用程序，故而需要验证参数）</li>
<li>内核态映射到用户态的地址空间（<strong>通过拷贝的方式传递数据</strong>，不像用户态下的应用程序，可以通过指针传递实现）<ul>
<li>更新页面映射权限</li>
</ul>
</li>
<li>内核态独立地址空间<ul>
<li>通过在 TLB 中维护不同的页表实现</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>「内核态独立地址空间」是指在操作系统中，内核和用户程序所使用的内存地址空间是相互独立的。</p>
</blockquote>
<h2 id="什么是更新页面映射权限"><a href="# 什么是更新页面映射权限" class="headerlink" title="什么是更新页面映射权限"></a>什么是更新页面映射权限 </h2><p>「更新页面映射权限」是指在操作系统中，<strong> 对虚拟内存中的页面进行权限的调整或修改</strong>。</p>
<p>在虚拟内存管理中，操作系统将物理内存空间映射到进程的虚拟地址空间中，形成了一种虚拟内存映射。每个页面都有对应的权限，例如读、写、执行等。当需要修改某个页面的权限时，就需要进行页面映射权限的更新。</p>
<p>更新页面映射权限的具体操作包括：</p>
<ol>
<li><strong>检查该页面的当前权限</strong>：首先，操作系统会检查该页面的当前权限，确定要进行哪些修改。</li>
<li><strong>修改页面权限</strong>：根据需要，操作系统会修改页面的权限，例如增加或删除某项权限。</li>
<li><strong>更新页表 </strong>：在虚拟内存管理中，每个进程都有自己的页表，<strong> 用于记录虚拟地址与物理地址之间的映射关系</strong>。当页面的权限发生变化时，操作系统需要更新相应的页表项，以反映最新的权限信息。</li>
</ol>
<p>通过更新页面映射权限，操作系统可以 <strong> 实现对进程的内存访问控制</strong>，保证系统的安全性和稳定性。</p>
<h2 id="应用程序不能直接访问外设"><a href="# 应用程序不能直接访问外设" class="headerlink" title="应用程序不能直接访问外设"></a>应用程序不能直接访问外设 </h2><p> 应用程序不能直接访问外设，而要通过操作系统的原因主要有以下几点：</p>
<ol>
<li>安全性：操作系统（内核）是被信任的第三方，只有操作系统才能执行特权指令，保护硬件和系统资源的安全。</li>
<li>统一性：通过操作系统提供的接口，应用程序可以统一地访问不同的外设，而不需要关心具体的硬件细节。</li>
<li>方便性：操作系统提供了一些高级功能和服务，如文件系统、网络协议等，应用程序可以更方便地使用这些功能。</li>
</ol>
<blockquote>
<p>参考资料<br>1：<a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a><br>2：<a href="https://blog.csdn.net/weixin_53407527/category_11825873.html">https://blog.csdn.net/weixin_53407527/category_11825873.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter1 概述</title>
    <url>/posts/230921190726.html</url>
    <content><![CDATA[<p>这篇文章主要介绍操作系统的定义、架构层次、界面和内核、内部组成和特征等内容。</p>
<span id="more"></span>

<h1 id="概述"><a href="# 概述" class="headerlink" title="概述"></a>概述 </h1><h2 id="操作系统定义"><a href="# 操作系统定义" class="headerlink" title="操作系统定义"></a> 操作系统定义 </h2><p><strong> 用户角度</strong>：操作系统是一个控制软件。</p>
<ul>
<li>管理应用软件：可以限制不同的应用程序占用不同的资源</li>
<li>为应用程序提供服务：I/O 服务，声卡、网卡的访问服务</li>
<li>杀死应用程序</li>
</ul>
<p><strong>程序角度</strong>：操作系统是资源管理器。</p>
<ul>
<li>管理外设，分配资源</li>
<li>抽象化作用<ul>
<li>CPU 抽象成进程</li>
<li>磁盘抽象成文件</li>
<li>内存抽象成地址空间</li>
</ul>
</li>
</ul>
<h2 id="操作系统的架构层次"><a href="# 操作系统的架构层次" class="headerlink" title="操作系统的架构层次"></a>操作系统的架构层次 </h2><p> 硬件之上、应用软件之下（为应用软件提供服务支持）。</p>
<h2 id="操作系统的界面和内核"><a href="# 操作系统的界面和内核" class="headerlink" title="操作系统的界面和内核"></a>操作系统的界面和内核</h2><p>Linux、Windows、Android 的界面属于外壳（shell），而不是内核（kernel）。kernel 是操作系统的研究重点，处于 shell 之下。</p>
<h2 id="操作系统内部组成"><a href="# 操作系统内部组成" class="headerlink" title="操作系统内部组成"></a>操作系统内部组成 </h2><p> 操作系统（kernel）内部组件包括：</p>
<ul>
<li>CPU 调度器</li>
<li>物理内存管理</li>
<li>虚拟内存管理</li>
<li>文件系统管理</li>
<li>中断处理与 I/O 设备驱动</li>
</ul>
<h2 id="操作系统特征："><a href="# 操作系统特征：" class="headerlink" title="操作系统特征："></a>操作系统特征：</h2><ul>
<li>并发<ul>
<li>计算机系统中同时存在多个运行的程序，需要 OS 管理和调度。</li>
</ul>
</li>
<li>共享<ul>
<li>“同时”访问或互斥共享。</li>
</ul>
</li>
<li>虚拟<ul>
<li>利用多道程序设计技术，让每一个用户都觉得有一个计算机专门为他服务。</li>
</ul>
</li>
<li>异步<ul>
<li>每个程序的执行不是一贯到底，而是走走停停 &amp; 交替执行，向前推进速度不可预知；</li>
<li>只要运行环境相同，OS 保证程序运行结果相同。</li>
</ul>
</li>
</ul>
<blockquote>
<p>「并发」在一段时间内可以有多个程序运行，而「并行」是在一个时间点上可以有多个程序运行，并行需要多核 CPU 支持。</p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter3.1 内存分层体系与地址空间生成</title>
    <url>/posts/231017195157.html</url>
    <content><![CDATA[<p>这篇文章主要介绍计算机的体系结构，内存的分层体系，操作系统的内存管理，地址空间和地址生成等内容。</p>
<span id="more"></span>

<h2 id="计算机体系结构"><a href="# 计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构 </h2><p>CPU：主要完成了对整个程序或软件的执行的控制。<br> 内存：主要是放置了程序的代码和它所处理的数据。<br>外设：各种外部设备配合程序更好的完成工作。</p>
<img src="/images/os-kernel/chapter3/computer-architecture.png" alt="计算机体系结构" width="60%" height="60%">

<h2 id="内存分层体系"><a href="# 内存分层体系" class="headerlink" title="内存分层体系"></a>内存分层体系</h2><img src="/images/os-kernel/chapter3/memory-layering.png" alt="内存分层体系" width="60%" height="60%">

<p>计算机内存包含多个层次，包括 CPU 寄存器、cache 和主存（物理内存）、硬盘（虚拟内存）。硬盘用于保存持久化数据。</p>
<ul>
<li>CPU 寄存器和 cache：<ul>
<li>访问速度快，但容量小；</li>
<li>寄存器是 CPU 内部的存储单元，用于存储临时数据和指令；</li>
<li>cache 是位于 CPU 和主存之间的高速缓存，<strong>用于加速对主存的访问</strong>。</li>
</ul>
</li>
<li>主存（物理内存）：<ul>
<li>存放操作系统和程序代码等数据；</li>
<li>容量较大，但访问速度相对较慢；</li>
<li>主存中的数据掉电会丢失。</li>
</ul>
</li>
<li>硬盘（虚拟内存）：<ul>
<li>保存持久化数据，即使掉电也不会丢失；</li>
<li>访问速度较慢，但容量可以很大。</li>
</ul>
</li>
</ul>
<p>操作系统会根据需要将数据从主存中放到硬盘中，以便管理数据的容量和提高运行效率。</p>
<h2 id="操作系统的内存管理"><a href="# 操作系统的内存管理" class="headerlink" title="操作系统的内存管理"></a>操作系统的内存管理 </h2><h3 id="目标"><a href="# 目标" class="headerlink" title="目标"></a> 目标 </h3><p> 操作系统的内存管理到底要做什么事情呢？它有如下几个重要的目标。</p>
<ul>
<li>抽象：逻辑地址空间<ul>
<li>操作系统通过提供逻辑地址空间，将底层细节抽象化，使应用程序不需要关心物理内存和外设的管理。</li>
</ul>
</li>
<li>保护：独立地址空间<ul>
<li>为了避免应用程序相互访问彼此的地址空间，操作系统提供了独立的地址空间，将它们隔离，以保护应用程序免受破坏。</li>
</ul>
</li>
<li>共享：访问相同内存<ul>
<li>多个应用程序之间也可能进行交互，操作系统允许多个应用程序共享相同的内存空间，以实现高效和可靠的数据传递。</li>
</ul>
</li>
<li>虚拟：更多的地址空间<ul>
<li>物理内存空间有限，操作系统将必要的数据放在主存中，而将暂时不需要访问的数据临时存放在磁盘上，从而扩展了可用的地址空间。</li>
</ul>
</li>
</ul>
<img src="/images/os-kernel/chapter3/os-memory-management.png" alt="操作系统的内存管理" width="60%" height="60%">

<p>在这张图中，操作系统将进程 P1、进程 P2、进程 P3 和进程 P4 将必要的数据被放在主存中（进程 P1 优先级最高，所有的数据都在主存中），暂时不需要访问的数据（进程 P4/P2/P3 的一部分数据）临时存放在磁盘上。</p>
<p>从上图中，也可以看出进程（我们的程序）属于逻辑地址空间，主存和磁盘的内存空间属于物理内存空间。</p>
<h3 id="内存管理的不同方法"><a href="# 内存管理的不同方法" class="headerlink" title="内存管理的不同方法"></a>内存管理的不同方法</h3><ul>
<li>程序重定位（relocation）</li>
<li>分段（segmentation）</li>
<li>分页（page）</li>
<li>虚拟内存（virtual memory）</li>
<li>按需分页虚拟内存<ul>
<li>目前多数操作系统（如 Linux）采用</li>
</ul>
</li>
</ul>
<blockquote>
<p>内存管理的实现高度依赖于硬件：</p>
<ul>
<li>必须知道内存架构（与计算机存储架构紧耦合）</li>
<li>MMU（内存管理单元）：硬件组件负责处理 CPU 的内存访问请求</li>
</ul>
</blockquote>
<h2 id="地址空间与地址生成"><a href="# 地址空间与地址生成" class="headerlink" title="地址空间与地址生成"></a>地址空间与地址生成 </h2><h3 id="地址空间定义"><a href="# 地址空间定义" class="headerlink" title="地址空间定义"></a> 地址空间定义 </h3><p> 物理地址空间就是内存条和硬盘的空间，它的管理和控制由硬件来完成的。</p>
<p>逻辑地址空间就是一个运行的程序所拥有的的内存空间，是一种一维的线性地址空间（这种设计可以使得应用程序很容易的进行数据访问操作）。</p>
<blockquote>
<p>逻辑地址空间的设计使得数据访问更加方便的「其中一个原因」就是：<br>逻辑地址空间是一维的线性地址空间，即内存地址在逻辑上是连续的。这种设计使得程序可以使用简单的地址计算来访问数据，而不需要考虑数据在内存中的实际物理位置。这样，程序员可以通过 <strong> 使用相对地址来访问数据，而不需要关注数据的具体位置</strong>。</p>
</blockquote>
<img src="/images/os-kernel/chapter3/memory-space.png" alt="地址空间" width="60%" height="60%">

<h3 id="物理 -vs- 逻辑地址空间对应关系"><a href="# 物理 -vs- 逻辑地址空间对应关系" class="headerlink" title="物理 vs. 逻辑地址空间对应关系"></a>物理 vs. 逻辑地址空间对应关系</h3><p>「物理地址空间 vs. 逻辑地址空间」是如何建立对应关系的？</p>
<p>一个运行的程序所访问的逻辑地址空间，最终都会对应着物理地址空间中的某一位置，可能放在主存中、也可能放在硬盘中。物理地址空间和逻辑地址空间通过映射关系对应起来（映射关系由操作系统进行有效地管理）。</p>
<h3 id="逻辑地址生成"><a href="# 逻辑地址生成" class="headerlink" title="逻辑地址生成"></a>逻辑地址生成 </h3><p> 下图展示了逻辑地址的生成过程。</p>
<img src="/images/os-kernel/chapter3/logical-address-generation.png" alt="逻辑地址生成" width="60%" height="60%">

<ol>
<li>C 程序文件（.c 文件）中的函数和变量名即逻辑地址。编译器会将 C 程序转换为汇编语言程序（.s 文件），并在汇编代码中使用符号来代表函数和变量的名字。</li>
<li>汇编语言程序（.s 文件）中的符号仍然是逻辑地址。编译器将汇编语言程序转换为机器语言程序（.o 文件），并将变量和函数的符号名转换为逻辑地址。</li>
<li>链接器（linker）将多个机器语言程序（.o 文件）链接在一起，形成一个单一的可执行文件（.exe 文件）。链接器会为每个变量和函数分配唯一的逻辑地址，并解决不同文件之间的符号引用关系。</li>
<li>加载器（loader）将可执行文件（.exe 文件）加载到内存中运行。加载器会将可执行文件的代码和数据加载到内存的适当位置，并进行地址的重定位。由于加载过程中会存在一定的偏移量，程序需要根据偏移量来进行正确的数据访问和指令操作。</li>
</ol>
<blockquote>
<p>逻辑地址生成的过程可以在编译器、链接器和加载器等工具的协同作用下完成，操作系统通常不需要干预该过程。这样的设计使得程序员可以方便地使用符号和逻辑地址进行开发，而无需关心实际的物理地址和内存布局。</p>
</blockquote>
<h3 id="物理地址生成"><a href="# 物理地址生成" class="headerlink" title="物理地址生成"></a>物理地址生成 </h3><p> 下图展示了物理地址的生成过程。</p>
<img src="/images/os-kernel/chapter3/physical-address-generation.png" alt="物理地址生成" width="60%" height="60%">

<p>物理地址的生成过程是由操作系统的内存管理单元（MMU）来完成的。MMU 负责将逻辑地址转换为物理地址，使得程序能够正确地访问内存。</p>
<ol>
<li>分页：操作系统将整个物理内存划分为固定大小的页面（page），通常是 4KB 或者更大的大小。同时，逻辑地址空间也被划分为相同大小的页面。</li>
<li>页表：每个进程都有一个页表，用于记录逻辑地址与物理地址的映射关系。页表的每个表项（entry）记录了逻辑页面号与物理页面号的对应关系。</li>
<li>地址转换：当程序访问某个逻辑地址时，MMU 会根据页表中的映射关系将逻辑地址转换为物理地址。具体的转换过程是 <strong> 通过逻辑地址中的页号（page number）和页内偏移（page offset）进行计算得到</strong>。</li>
<li>物理地址访问：得到物理地址后，程序就可以使用该地址直接访问内存中的数据或指令。</li>
</ol>
<blockquote>
<p>需要注意的是，物理地址生成的过程是 <strong> 在程序运行时 </strong> 由硬件执行的，而不是编译、链接或加载阶段进行的。<strong>操作系统会在程序加载到内存时设置好页表，并将页表的基地址告诉 MMU，以便进行地址转换</strong>。这样，程序在运行过程中，无需关心物理地址的生成和管理，而是通过逻辑地址进行访问。</p>
</blockquote>
<p>为了加快地址转换的速度，操作系统会将逻辑地址到物理地址的映射关系存储在内存中，并由 CPU 进行缓存。</p>
<blockquote>
<p>具体来说，当 CPU 首次访问某个逻辑地址时，MMU 会根据页表将逻辑地址转换为物理地址，并将该映射关系存储在一个特殊的高速缓存中，称为转换后备缓冲器（Translation Lookaside Buffer，简称 TLB）。TLB 是一种硬件缓存，用于临时存储逻辑地址到物理地址的映射关系。<br>当程序再次访问相同的逻辑地址时，CPU 会首先检查 TLB 中是否存在该映射关系：</p>
<ul>
<li>如果存在，则可以直接从 TLB 中获取物理地址，从而避免了访问内存的开销；</li>
<li>如果 TLB 中没有找到对应的映射关系，则需要通过页表来进行地址转换，并将新的映射关系存储到 TLB 中，以便下次访问时可以直接使用。</li>
</ul>
</blockquote>
<h3 id="地址安全检查"><a href="# 地址安全检查" class="headerlink" title="地址安全检查"></a>地址安全检查 </h3><p> 为了避免应用程序相互访问彼此的地址空间，操作系统提供了独立的地址空间，将它们隔离，以保护应用程序免受破坏。</p>
<img src="/images/os-kernel/chapter3/address-security-check.png" alt="地址安全检查" width="60%" height="60%">


<p>地址安全检查使应用程序在内存中正常执行，同时保证在内存中不同的应用程序之间不会相互破坏。</p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://blog.csdn.net/weixin_53407527/article/details/124930556">Operation System- 第 3 章 - 内存分层体系 &amp; 地址空间生成</a></li>
<li>部分内容由 GPT 二次编辑 &amp; 润色生成。</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>内存分层体系</tag>
        <tag>地址空间生成</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter3.2 连续内存分配</title>
    <url>/posts/231108195351.html</url>
    <content><![CDATA[<p>这篇文章主要介绍操作系统的连续内存分配，包括内存的内碎片与外碎片、内存的动态分配算法、压缩式碎片整理与交换式碎片整理。</p>
<span id="more"></span>

<h2 id="连续内存分配"><a href="# 连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配 </h2><p> 连续内存分配：给进程分配一块不小于指定大小的、连续的物理内存区域。</p>
<h3 id="内存碎片问题"><a href="# 内存碎片问题" class="headerlink" title="内存碎片问题"></a>内存碎片问题 </h3><p> 内存碎片问题指的是空闲的内存无法被利用，细分为外部碎片和内部碎片。</p>
<ul>
<li>外部碎片：分配单元（进程）间的未使用内存</li>
<li>内部碎片：分配单元（进程）内的不能被利用的内存</li>
</ul>
<h3 id="分区的动态分配"><a href="# 分区的动态分配" class="headerlink" title="分区的动态分配"></a>分区的动态分配 </h3><p> 动态分区分配：当程序被加载执行时，分配一个进程指定大小可变的分区（块、内存块），且分区的物理地址是连续的。</p>
<p>分区的动态分配方式有以下三种：</p>
<ol>
<li>第一匹配分配（first fit）：在空闲的内存块中，从低内存往高内存顺序搜索，找到 <strong> 第一个 </strong> 比需求大的空闲块, 分配给应用程序。</li>
<li>最优适配分配（best fit）：在空闲的内存块中，找到比需求大的 <strong> 最小的 </strong> 空闲块, 分配给应用程序。</li>
<li>最差适配分配（worst fit）：在空闲的内存块中，找到比 <strong> 最大的 </strong> 空闲块, 分配给应用程序。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|....| 500bytes |.......| 1k bytes |...| 400bytes |...|    </span><br></pre></td></tr></table></figure>

<p>例如，现在有一个应用程序，需要 300bytes 的内存块，那么第一匹配分配将会选择 500bytes 的内存块，最优适配分配将会选择 400bytes 的内存块，最差适配分配将会选择 1k bytes 的内存块。</p>
<p>分配方式的区别：</p>
<table>
<thead>
<tr>
<th></th>
<th>第一匹配分配</th>
<th>最优适配分配</th>
<th>最差适配分配</th>
</tr>
</thead>
<tbody><tr>
<td>分配方式原理 &amp; 实现</td>
<td>按地址排序的空闲块列表、需要寻找合适的分区、重分配时需检查合并相邻空闲分区</td>
<td>按尺寸排序的空闲块列表、需要寻找合适的分区、重分配时需检查合并相邻空闲分区</td>
<td>按尺寸排序的空闲块列表、分配最大分区、重分配时需检查合并相邻空闲分区，并调整空闲分区列表顺序</td>
</tr>
<tr>
<td>优势</td>
<td>简单易实现、容易产生更大空闲块</td>
<td>相对简单、对小尺寸分配高效、可避免大的空闲分区被拆分</td>
<td>分配快、对中尺寸分配高效</td>
</tr>
<tr>
<td>劣势</td>
<td>容易产生外部碎片、不确定性、分配大块时较慢</td>
<td>容易产生外部碎片、重分配慢（释放分区较慢）、产生微小碎片</td>
<td>容易产生外部碎片、重分配慢（释放分区较慢）、容易破坏大的空闲分区，后续难以分配大的分区</td>
</tr>
</tbody></table>
<blockquote>
<p>三种分配方式并无优劣之分，因为我们无法判断内存请求的大小。</p>
</blockquote>
<h2 id="碎片整理"><a href="# 碎片整理" class="headerlink" title="碎片整理"></a>碎片整理 </h2><p> 可以看到的是，三种分区动态分配的方式都会产生外部碎片，因此我们可以对碎片进行一定的整理来解决碎片问题。</p>
<p>何为碎片整理？即通过调整应用程序（进程）占用的分区位置来减少或避免分区碎片，以腾出更大的内存块。</p>
<h3 id="压缩式碎片整理"><a href="# 压缩式碎片整理" class="headerlink" title="压缩式碎片整理"></a>压缩式碎片整理</h3><ul>
<li>方式：重置程序以合并外部碎片</li>
<li>条件：要求所有程序是动态可重定位的</li>
<li>需要解决的问题：<ul>
<li>何时重置？（在程序处于等待状态时才可以重置）</li>
<li>需要考虑内存拷贝的开销</li>
</ul>
</li>
</ul>
<p>一个压缩式碎片整理的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 原始应用程序的内存块和外部碎片</span><br><span class="line">|....| 500bytes |.......| 1k bytes |...| 400bytes |...|   </span><br><span class="line"></span><br><span class="line">// 新增一个应用程序，需要 1200bytes 的内存块，通过压缩式碎片整理，腾出一块满足需求的内存卡分配给新的应用程序</span><br><span class="line">|....|.......|...|...| 500bytes | 1k bytes | 400bytes |   </span><br></pre></td></tr></table></figure>

<h3 id="交换式碎片整理"><a href="# 交换式碎片整理" class="headerlink" title="交换式碎片整理"></a>交换式碎片整理</h3><ul>
<li>方式：运行程序需要更多的内存时，抢占等待的程序并且回收它们的内存，以增大可用内存空间</li>
<li>需要解决的问题：<ul>
<li>哪些程序应该被回收？</li>
</ul>
</li>
</ul>
<p>一个交换式碎片整理的示例：</p>
<ol>
<li>运行中：P3</li>
<li>等待中：P1，P2，P4</li>
<li>内存分布 -&gt; 主存：OS / P1 / P3 / P2 / P4 磁盘：空</li>
<li>当 P3 程序需要更大的内存时，可将等待中的 P4 程序先放入虚拟内存中 -&gt; </li>
<li>内存分布 -&gt; 主存：OS / P1 /    P3   / P2 磁盘：P4</li>
</ol>
<blockquote>
<p>参考资料<br>1：<a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a><br>2：<a href="https://blog.csdn.net/weixin_53407527/article/details/124891795">https://blog.csdn.net/weixin_53407527/article/details/124891795</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>连续内存分配</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之二叉树的遍历</title>
    <url>/posts/230905224335.html</url>
    <content><![CDATA[<h2 id="二叉树的遍历"><a href="# 二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历 </h2><p> 二叉树是一种非常重要的数据结构，很多其它数据结构都是基于二叉树的基础演变而来的。</p>
<p>所谓遍历 Traversal 是指沿着某条搜索路线，依次对树中每个结点均做一次且仅做一次访问。</p>
<p>对于二叉树，有深度遍历和广度遍历，深度遍历有前序、中序以及后序遍历三种方法，广度遍历即我们平常所说的层次遍历。因为树的定义本身就是递归定义，因此采用递归的方法去实现树的三种遍历不仅容易理解而且代码很简洁，而对于广度遍历来说，需要其他数据结构的支撑。</p>
<p>四种遍历的主要思想是：</p>
<ul>
<li><p>前序遍历：根节点 -&gt; 左子树 -&gt; 右子树</p>
</li>
<li><p>中序遍历：左子树 -&gt; 根节点 -&gt; 右子树</p>
</li>
<li><p>后续遍历：左子树 -&gt; 右子树 -&gt; 根节点</p>
</li>
<li><p>层序遍历：依二叉树的深度从左到右（右到左）按层遍历</p>
</li>
</ul>
<p>其中，前、中、后续指的是「根节点」的遍历顺序，例如前序遍历是先遍历根节点。</p>
<span id="more"></span>

<p>以下为一棵二叉树不同的遍历顺序以及实现方法（非递归实现 / 递归实现）：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \   \</span><br><span class="line">4   5   6</span><br><span class="line"></span><br><span class="line">层次遍历顺序：[1 2 3 4 5 6] / 非递归实现：队列 + BFS</span><br><span class="line">前序遍历顺序：[1 2 4 5 3 6] / 非递归实现：栈，递归实现：DFS</span><br><span class="line">中序遍历顺序：[4 2 5 1 3 6] / 非递归实现：栈，递归实现：DFS</span><br><span class="line">后序遍历顺序：[4 5 2 6 3 1] / 非递归实现：栈，递归实现：DFS</span><br></pre></td></tr></table></figure>

<p>层次遍历使用 BFS 实现，利用的就是 BFS 一层一层遍历的特性，而前序、中序、后序遍历利用了 DFS 实现。</p>
<blockquote>
<p>前序、中序、后序遍只是在对节点访问的顺序有一点不同，其它都相同。</p>
</blockquote>
<p>下面直接从 Leetcode 练习题，学习二叉树的不同遍历方法。</p>
<h3 id="二叉树的层序遍历"><a href="# 二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h3><blockquote>
<p>题目链接：<a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></p>
</blockquote>
<p><strong>题目</strong>：给定一个非空二叉树，返回一个由每层节点平均值组成的数组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">输出: [3, 14.5, 11]</span><br><span class="line">解释: 第 0 层的平均值是 3,  第 1 层是 14.5, 第 2 层是 11. 因此返回 [3, 14.5, 11].</span><br></pre></td></tr></table></figure>

<p><strong>层序遍历</strong>：利用队列实现二叉树的层序遍历。</p>
<p>python 双端队列实现二叉树的层序遍历：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">averageOfLevels</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">import</span> collections</span><br><span class="line">    queue = collections.deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        size = <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="built_in">sum</span>, tmp_size = <span class="number">0</span>, size</span><br><span class="line">        <span class="keyword">while</span> size &gt; <span class="number">0</span>:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            size -= <span class="number">1</span></span><br><span class="line">            <span class="built_in">sum</span> += node.val</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">        res.append(<span class="built_in">sum</span> / tmp_size)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>C 语言实现基于链表的队列，然后基于队列实现二叉树的层序遍历：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define the structure for a node in the queue</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define the structure for the queue</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    Node *front;</span><br><span class="line">    Node *rear;</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to create a new node</span></span><br><span class="line">Node *<span class="title function_">createNode</span><span class="params">(<span class="keyword">struct</span> TreeNode *data)</span> &#123;</span><br><span class="line">    Node *newNode = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to create an empty queue</span></span><br><span class="line">Queue* <span class="title function_">createQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    Queue *<span class="built_in">queue</span> = (Queue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to check if the queue is empty</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Queue *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to enqueue an element into the queue</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enQueue</span><span class="params">(Queue *<span class="built_in">queue</span>, <span class="keyword">struct</span> TreeNode *data)</span> &#123;</span><br><span class="line">    Node *newNode = createNode(data);</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear-&gt;next = newNode;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to dequeue an element from the queue</span></span><br><span class="line"><span class="keyword">struct</span> TreeNode *<span class="title function_">deQueue</span><span class="params">(Queue* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *temp = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">data</span> =</span> temp-&gt;data;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;front-&gt;next;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span>* <span class="title function_">averageOfLevels</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    <span class="type">double</span> *ans = (<span class="type">double</span> *)<span class="built_in">malloc</span>(<span class="number">10000</span> * <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">    Queue *<span class="built_in">queue</span> = createQueue();</span><br><span class="line">    enQueue(<span class="built_in">queue</span>, root);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> size = <span class="built_in">queue</span>-&gt;size;</span><br><span class="line">        <span class="type">int</span> tmp_size = size;</span><br><span class="line">        <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">node</span> =</span> deQueue(<span class="built_in">queue</span>);</span><br><span class="line">            sum += node-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">                enQueue(<span class="built_in">queue</span>, node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">                enQueue(<span class="built_in">queue</span>, node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[(*returnSize)++] = sum / tmp_size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之双端队列（链表实现）</title>
    <url>/posts/231017154121.html</url>
    <content><![CDATA[<p>队列提供了一种先进先出（FIFO, First-In First-Out）的存储结构。在 <a href="https://pursue26.github.io/posts/231017105123.html"> 数据结构之队列（链表实现）</a>中，我们介绍了链表实现的队列数据结构，但这种普通的队列只能从尾部插入节点、从首部删除节点。</p>
<p>双端队列（Deque, double-ended queue）是普通队列的扩展，是指允许两端都可以进行入队和出队操作的队列，它不遵循 FIFO 原则。这篇文章扩展了 <a href="https://pursue26.github.io/posts/231017105123.html"> 数据结构之队列（链表实现）</a>，实现了基于链表的双端队列。</p>
<span id="more"></span>

<h2 id="FIFO 队列结构和接口"><a href="#FIFO 队列结构和接口" class="headerlink" title="FIFO 队列结构和接口"></a>FIFO 队列结构和接口 </h2><p> 下面是 <a href="https://pursue26.github.io/posts/231017105123.html"> 数据结构之队列（链表实现）</a>中实现的普通队列的数据结构和 API 接口。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    TreeNode_t *data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">queue</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    Node_t *front;</span><br><span class="line">    Node_t *rear;</span><br><span class="line">&#125; Queue_t;</span><br><span class="line"></span><br><span class="line">Queue_t *<span class="title function_">createQueue</span><span class="params">(<span class="type">int</span> max_size)</span>;</span><br><span class="line">Node_t *<span class="title function_">createNode</span><span class="params">(TreeNode_t *data)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Queue_t *<span class="built_in">queue</span>)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Queue_t *<span class="built_in">queue</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">enQueue</span><span class="params">(Queue_t *<span class="built_in">queue</span>, TreeNode_t *data)</span>;</span><br><span class="line">TreeNode_t *<span class="title function_">deQueue</span><span class="params">(Queue_t* <span class="built_in">queue</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(Queue_t* <span class="built_in">queue</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">freeQueue</span><span class="params">(Queue_t* <span class="built_in">queue</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>为了实现双端队列，我们需要在普通队列的基础上，增加两个操作：</p>
<ol>
<li>一个就是在队列首部执行入队操作（插入节点），我们使用接口 <code>void enQueueFront(Queue_t *queue, TreeNode_t *data)</code>；</li>
<li>另一个就是在队列尾部执行出队操作（删除节点），我们使用接口 <code>TreeNode_t *deQueueRear(Queue_t* queue)</code>。</li>
</ol>
<p>下面就来实现这两个接口。为了一致，这里不再修改队列结构体的别名从 <code>Queue_t</code> 到 <code>Deque_t</code>。</p>
<h2 id="双端队列之队首入队操作"><a href="# 双端队列之队首入队操作" class="headerlink" title="双端队列之队首入队操作"></a>双端队列之队首入队操作</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">enQueueFront</span><span class="params">(Queue_t *<span class="built_in">queue</span>, TreeNode_t *data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;queue is full.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node_t *newNode = createNode(data);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">            <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newNode-&gt;next = <span class="built_in">queue</span>-&gt;front;  <span class="comment">// 新节点指向队列头结点</span></span><br><span class="line">            <span class="built_in">queue</span>-&gt;front = newNode;  <span class="comment">// 新节点成为队列头结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;size += <span class="number">1</span>;  <span class="comment">// 更新队列大小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>普通队列在队尾入队的过程是：队列尾指针指向新入队的节点，然后更新队列尾指针为该节点地址。与普通队列在队尾入队操作不同的是，双端队列在队首入队的过程是：新节点指向队列头指针，然后更新队列头指针为新节点地址。</p>
<h2 id="双端队列之队尾出队操作"><a href="# 双端队列之队尾出队操作" class="headerlink" title="双端队列之队尾出队操作"></a>双端队列之队尾出队操作</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode_t *<span class="title function_">deQueueRear</span><span class="params">(Queue_t* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node_t *prev = <span class="literal">NULL</span>;</span><br><span class="line">    Node_t *curr = <span class="built_in">deque</span>-&gt;front;</span><br><span class="line">    <span class="keyword">while</span> (curr-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode_t *data = curr-&gt;data;</span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        prev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">deque</span>-&gt;rear = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">deque</span>-&gt;front = <span class="built_in">deque</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">deque</span>-&gt;size -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(curr);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>普通队列执行出队操作的时间复杂度为 <code>O(1)</code>，而这里双端队列在队尾出队的操作的时间复杂度为 <code>O(n)</code>。这是因为普通队列在队首出队后，可以直接通过 <code>queue-&gt;front-&gt;next</code> 操作确定新的头指针，而双端队列在队尾出队后，只能通过遍历队列中的节点，找到倒数第二个节点，才能确定新的尾指针。</p>
<p>那么，如何提高双端队列的队尾出队操作的时间复杂度呢？</p>
<p>可以通过将链表修改为双端链表，即不再只有一个 <code>next</code> 指针，同时还有一个 <code>prev</code> 指针，用于指向链表中当前节点的上一个节点。这样就可以实现 <code>O(1)</code> 时间复杂度的双端队列的队尾出队操作。</p>
<h2 id="双端链表实现的双端队列"><a href="# 双端链表实现的双端队列" class="headerlink" title="双端链表实现的双端队列"></a>双端链表实现的双端队列 </h2><h3 id="结构示意图"><a href="# 结构示意图" class="headerlink" title="结构示意图"></a> 结构示意图 </h3><p> 下面是一个示意双端队列的线条图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">front                                               rear</span><br><span class="line">  ↓                                                  ↓</span><br><span class="line">+---+            +---+            +---+            +---+</span><br><span class="line">|   | ← prev   ← |   | ← prev   ← |   | ← prev   ← |   |</span><br><span class="line">|   |            |   |            |   |            |   |</span><br><span class="line">|   | → next   → |   | → next   → |   | → next   → |   |</span><br><span class="line">+---+            +---+            +---+            +---+</span><br></pre></td></tr></table></figure>

<p>在双端队列中，有两个方向：从头 <code>front</code> 到尾 <code>rear</code> 和从尾到头。每个节点都有一个指向前一个节点的指针 <code>prev</code> 和一个指向后一个节点的指针 <code>next</code>。<code>front</code> 指向队列的头部节点，<code>rear</code> 指向队列的尾部节点。</p>
<h3 id="完整代码"><a href="# 完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    TreeNode_t *data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">deque</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    Node_t *front;</span><br><span class="line">    Node_t *rear;</span><br><span class="line">&#125; Deque_t;</span><br><span class="line"></span><br><span class="line">Deque_t *<span class="title function_">createDeque</span><span class="params">(<span class="type">int</span> max_size)</span> &#123;</span><br><span class="line">    Deque_t *<span class="built_in">deque</span> = (Deque_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Deque_t));</span><br><span class="line">    <span class="built_in">deque</span>-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">deque</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">deque</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">deque</span>-&gt;max = max_size;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">deque</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node_t *<span class="title function_">createNode</span><span class="params">(TreeNode_t *data)</span> &#123;</span><br><span class="line">    Node_t *newNode = (Node_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node_t));</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Deque_t *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">deque</span>-&gt;size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Deque_t *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">deque</span>-&gt;size &gt;= <span class="built_in">deque</span>-&gt;max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enDeque</span><span class="params">(Deque_t *<span class="built_in">deque</span>, TreeNode_t *data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;deque is full.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node_t *newNode = createNode(data);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">            <span class="built_in">deque</span>-&gt;front = <span class="built_in">deque</span>-&gt;rear = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node_t *curRear = <span class="built_in">deque</span>-&gt;rear;</span><br><span class="line">            curRear-&gt;next = newNode;  <span class="comment">// 尾指针链接新数据</span></span><br><span class="line">            <span class="built_in">deque</span>-&gt;rear = newNode;  <span class="comment">// 尾指针指向新数据</span></span><br><span class="line">            <span class="built_in">deque</span>-&gt;rear-&gt;prev = curRear;  <span class="comment">// !! 双端队列!!, 尾指针的上一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">deque</span>-&gt;size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enDequeFront</span><span class="params">(Deque_t *<span class="built_in">deque</span>, TreeNode_t *data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;deque is full.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node_t *newNode = createNode(data);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">            <span class="built_in">deque</span>-&gt;front = <span class="built_in">deque</span>-&gt;rear = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newNode-&gt;next = <span class="built_in">deque</span>-&gt;front;  <span class="comment">// 新节点指向队列头结点</span></span><br><span class="line">            <span class="built_in">deque</span>-&gt;front-&gt;prev = newNode;  <span class="comment">// !! 双端队列!!, 头指针的上一个节点</span></span><br><span class="line">            <span class="built_in">deque</span>-&gt;front = newNode;  <span class="comment">// 新节点成为队列头结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">deque</span>-&gt;size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode_t *<span class="title function_">deDeque</span><span class="params">(Deque_t* <span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node_t *node = <span class="built_in">deque</span>-&gt;front;</span><br><span class="line">    TreeNode_t *data = node-&gt;data;</span><br><span class="line">    <span class="comment">// 根据当前队列中节点的数量，决定是否同步更新队列的尾指针</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">deque</span>-&gt;size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">deque</span>-&gt;front = <span class="built_in">deque</span>-&gt;front-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">deque</span>-&gt;front = <span class="built_in">deque</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">deque</span>-&gt;size -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode_t *<span class="title function_">deDequeRear</span><span class="params">(Deque_t* <span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node_t *node = <span class="built_in">deque</span>-&gt;rear;</span><br><span class="line">    TreeNode_t *data = node-&gt;data;</span><br><span class="line">    <span class="comment">// 根据当前队列中节点的数量，决定是否同步更新队列的尾指针</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">deque</span>-&gt;size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">deque</span>-&gt;rear = <span class="built_in">deque</span>-&gt;rear-&gt;prev;</span><br><span class="line">        <span class="built_in">deque</span>-&gt;rear-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">deque</span>-&gt;front = <span class="built_in">deque</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">deque</span>-&gt;size -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printDeque</span><span class="params">(Deque_t* <span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Deque is empty\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Deque: &quot;</span>);</span><br><span class="line">        Node_t *node = <span class="built_in">deque</span>-&gt;front;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;data-&gt;val);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeDeque</span><span class="params">(Deque_t* <span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">deque</span> &amp;&amp;(!isEmpty(<span class="built_in">deque</span>)))&#123;</span><br><span class="line">        Node_t *node = <span class="built_in">deque</span>-&gt;front;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Node_t *tmp = node-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(node);</span><br><span class="line">            node = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(<span class="built_in">deque</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    Deque_t *<span class="built_in">deque</span> = createDeque(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一些测试用的树节点</span></span><br><span class="line">    TreeNode_t *node = (TreeNode_t *)<span class="built_in">malloc</span>(<span class="number">5</span> * <span class="keyword">sizeof</span>(TreeNode_t));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        node[i].val = <span class="number">10</span> + i;</span><br><span class="line">        node[i].left = <span class="literal">NULL</span>;</span><br><span class="line">        node[i].right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printDeque(<span class="built_in">deque</span>);</span><br><span class="line"></span><br><span class="line">    enDequeFront(<span class="built_in">deque</span>, &amp;node[<span class="number">0</span>]);</span><br><span class="line">    enDequeFront(<span class="built_in">deque</span>, &amp;node[<span class="number">1</span>]);</span><br><span class="line">    enDeque(<span class="built_in">deque</span>, &amp;node[<span class="number">2</span>]);</span><br><span class="line">    printDeque(<span class="built_in">deque</span>);</span><br><span class="line"></span><br><span class="line">    enDequeFront(<span class="built_in">deque</span>, &amp;node[<span class="number">3</span>]);</span><br><span class="line">    enDeque(<span class="built_in">deque</span>, &amp;node[<span class="number">4</span>]);</span><br><span class="line">    printDeque(<span class="built_in">deque</span>);</span><br><span class="line"></span><br><span class="line">    TreeNode_t *data1 = deDeque(<span class="built_in">deque</span>);</span><br><span class="line">    TreeNode_t *data2 = deDequeRear(<span class="built_in">deque</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Removed data: %d %d\n&quot;</span>, data1-&gt;val, data2-&gt;val); <span class="comment">// 实际工程中要先判非空再取数据</span></span><br><span class="line">    TreeNode_t *data3 = deDequeRear(<span class="built_in">deque</span>);</span><br><span class="line">    TreeNode_t *data4 = deDeque(<span class="built_in">deque</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Removed data: %d %d\n&quot;</span>, data3-&gt;val, data4-&gt;val);</span><br><span class="line">    printDeque(<span class="built_in">deque</span>);</span><br><span class="line"></span><br><span class="line">    freeDeque(<span class="built_in">deque</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放测试用的树节点内存</span></span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Deque is empty</span><br><span class="line">Deque: 11 10 12</span><br><span class="line">Deque: 13 11 10 12 14</span><br><span class="line">Removed data: 13 14</span><br><span class="line">Removed data: 12 11</span><br><span class="line">Deque: 10</span><br></pre></td></tr></table></figure>

<p>在上述代码中，与 <a href="https://pursue26.github.io/posts/231017105123.html#%20%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C"> 普通队列中的入队操作 </a> 的两点区别是：</p>
<ol>
<li>在双端链表实现的双端队列中，在 <strong> 队尾入队 </strong> 操作中增加了队尾指针的前一个节点的代码 <code>deque-&gt;rear-&gt;prev = curRear</code>，服务于队尾出队的操作。</li>
<li>在双端链表实现的双端队列中，在 <strong> 队首入队 </strong> 操作中增加了队首指针的前一个节点的代码 <code>deque-&gt;front-&gt;prev = newNode</code>，服务于队尾出队的操作。</li>
</ol>
<p>为什么序号 2 中的那行代码也服务于队尾出队操作呢？</p>
<p>设想以下操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">enDequeFront(<span class="built_in">deque</span>, &amp;node[<span class="number">0</span>]);</span><br><span class="line">enDequeFront(<span class="built_in">deque</span>, &amp;node[<span class="number">1</span>]);</span><br><span class="line">deDequeRear(<span class="built_in">deque</span>);</span><br></pre></td></tr></table></figure>
<p>一开始就往队首插入节点，如果没有代码 <code>deque-&gt;front-&gt;prev = newNode</code>，那么尾结点的前一个节点地址将为 <code>NULL</code>，则无法更新指定尾结点。</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>队列</category>
      </categories>
      <tags>
        <tag>队列</tag>
        <tag>双端队列</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之优先队列（堆实现）</title>
    <url>/posts/231019102311.html</url>
    <content><![CDATA[<p>优先队列（priority queue）是最重要的元素始终位于最前面的队列。与普通队列不同的是，优先队列中的元素并不是按照先进先出的顺序进行处理，而是根据其优先级决定处理顺序，具有较高优先级的元素会优先被处理。<br>优先队列可以是最大优先队列（最大的元素在前）或最小优先队列（最小的元素在先）。优先队列对于需要处理大数据量，并且需要反复确定哪一个现在是最大的或最小（最重要）的数据的算法非常有用。</p>
<span id="more"></span>

<h2 id="优先队列的实现方式"><a href="# 优先队列的实现方式" class="headerlink" title="优先队列的实现方式"></a>优先队列的实现方式 </h2><p> 在实现上，优先队列可以使用不同的数据结构来实现，例如堆、二叉搜索树、有序动态数组等。</p>
<ol>
<li><strong>使用有序动态数组实现</strong>：将最重要的数据放在数组的末尾。<ul>
<li>缺点：插入新数据很慢，因为插入的数据必须保证数组依然有序。这就需要利用二分搜索算法确定插入的位置，并使用线性时间向后移动数组，以便新数据插入到那里。</li>
</ul>
</li>
<li><strong>使用平衡二叉树实现</strong>：这对于构建双端优先队列非常有用，因为它同时有效地实现了「查找最小值」和「查找最大值」（最重要和最不重要）。</li>
<li><strong>使用堆实现</strong>：堆是实现优先队列的天然数据结构。事实上，堆和优先队列这两个术语经常被用作同义词。<ul>
<li>优点：堆比有序动态数组更有效，因为堆只需部分排序，堆的插入和删除操作都是 <code>O(log n)</code> 时间复杂度。</li>
</ul>
</li>
</ol>
<blockquote>
<p>使用堆来实现优先队列是最常见和高效的方式。</p>
</blockquote>
<h2 id="基于堆实现优先队列"><a href="# 基于堆实现优先队列" class="headerlink" title="基于堆实现优先队列"></a>基于堆实现优先队列 </h2><p><a href="https://pursue26.github.io/posts/231018102559.html"> 数据结构之堆基础与堆结构（数组实现）</a>介绍了堆的基本理论知识和最大堆的实现。因此，我们基于这篇文章中实现的最大堆，进行简单的修改，实现优先队列这种数据结构。</p>
<h3 id="优先队列结构定义"><a href="# 优先队列结构定义" class="headerlink" title="优先队列结构定义"></a>优先队列结构定义 </h3><p> 为了体现堆中数据的复杂性，不再使用整形数值作为堆中的数据，而是使用结构体作为堆中的数据节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义堆中的数据, 不同优先级的待学习课程</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">    <span class="type">char</span> *course;</span><br><span class="line">&#125; Node_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Heap</span> &#123;</span></span><br><span class="line">    Node_t *heap;   <span class="comment">// 堆的数组</span></span><br><span class="line">    <span class="type">int</span> size;       <span class="comment">// 堆的当前大小</span></span><br><span class="line">    <span class="type">int</span> capacity;   <span class="comment">// 堆的容量</span></span><br><span class="line">&#125; PriorityQueue_t;</span><br></pre></td></tr></table></figure>

<h3 id="优先队列完整代码"><a href="# 优先队列完整代码" class="headerlink" title="优先队列完整代码"></a>优先队列完整代码 </h3><p> 这里，我们直接给出优先队列数据结构的完整代码，不明白的函数可以参考 <a href="https://pursue26.github.io/posts/231018102559.html"> 数据结构之堆基础与堆结构（数组实现）</a>中对应的小节。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义堆中的数据, 不同优先级的待学习课程</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">    <span class="type">char</span> *course;</span><br><span class="line">&#125; Node_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Heap</span> &#123;</span></span><br><span class="line">    Node_t *heap;   <span class="comment">// 堆的数组</span></span><br><span class="line">    <span class="type">int</span> size;       <span class="comment">// 堆的当前大小</span></span><br><span class="line">    <span class="type">int</span> capacity;   <span class="comment">// 堆的容量</span></span><br><span class="line">&#125; PriorityQueue_t;</span><br><span class="line"></span><br><span class="line">PriorityQueue_t* <span class="title function_">initPriorityQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PriorityQueue_t *<span class="built_in">queue</span> = (PriorityQueue_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(PriorityQueue_t));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;heap = (Node_t *)<span class="built_in">malloc</span>(capacity * <span class="keyword">sizeof</span>(Node_t));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;capacity = capacity;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getParentIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (index - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getLeftChildIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getRightChildIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (index &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(Node_t *s1, Node_t *s2)</span> &#123;</span><br><span class="line">    Node_t temp = *s1;</span><br><span class="line">    <span class="built_in">memcpy</span>(s1, s2, <span class="keyword">sizeof</span>(Node_t));</span><br><span class="line">    <span class="built_in">memcpy</span>(s2, &amp;temp, <span class="keyword">sizeof</span>(Node_t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">siftUp</span><span class="params">(PriorityQueue_t *<span class="built_in">queue</span>, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    Node_t *heap = <span class="built_in">queue</span>-&gt;heap;</span><br><span class="line">    <span class="type">int</span> parentIndex = getParentIndex(index);</span><br><span class="line">    <span class="keyword">while</span> ((index &gt; <span class="number">0</span>) &amp;&amp; (heap[index].priority &gt; heap[parentIndex].priority)) &#123;</span><br><span class="line">        swap(&amp;(heap[index]), &amp;(heap[parentIndex]));</span><br><span class="line">        index = parentIndex;  <span class="comment">// 交换节点后, 更新当前节点的位置</span></span><br><span class="line">        parentIndex = getParentIndex(index);  <span class="comment">// 重新获取父节点位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">siftDown</span><span class="params">(PriorityQueue_t* <span class="built_in">queue</span>, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxIndex = index;</span><br><span class="line">    <span class="type">int</span> leftChildIndex = getLeftChildIndex(index);</span><br><span class="line">    <span class="type">int</span> rightChildIndex = getRightChildIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来的两个判断为找出具有更大值的孩子的索引</span></span><br><span class="line">    <span class="keyword">if</span> (leftChildIndex &lt; <span class="built_in">queue</span>-&gt;size &amp;&amp; <span class="built_in">queue</span>-&gt;heap[leftChildIndex].priority &gt; <span class="built_in">queue</span>-&gt;heap[maxIndex].priority) &#123;</span><br><span class="line">        maxIndex = leftChildIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rightChildIndex &lt; <span class="built_in">queue</span>-&gt;size &amp;&amp; <span class="built_in">queue</span>-&gt;heap[rightChildIndex].priority &gt; <span class="built_in">queue</span>-&gt;heap[maxIndex].priority) &#123;</span><br><span class="line">        maxIndex = rightChildIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index != maxIndex) &#123;</span><br><span class="line">        swap(&amp;(<span class="built_in">queue</span>-&gt;heap[index]), &amp;(<span class="built_in">queue</span>-&gt;heap[maxIndex]));</span><br><span class="line">        siftDown(<span class="built_in">queue</span>, maxIndex);  <span class="comment">// 递归方式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(PriorityQueue_t *<span class="built_in">queue</span>, Node_t *node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;size &gt;= <span class="built_in">queue</span>-&gt;capacity) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Queue is full!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;heap[<span class="built_in">queue</span>-&gt;size] = *node;  <span class="comment">// 存储在堆数组的最后一个索引后面</span></span><br><span class="line">    siftUp(<span class="built_in">queue</span>, <span class="built_in">queue</span>-&gt;size);  <span class="comment">// 进行堆化中的上浮操作</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">peek</span><span class="params">(PriorityQueue_t *<span class="built_in">queue</span>, Node_t* top)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(top, <span class="number">0</span>, <span class="keyword">sizeof</span>(Node_t));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Queue is empty!\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(top, &amp;(<span class="built_in">queue</span>-&gt;heap[<span class="number">0</span>]), <span class="keyword">sizeof</span>(Node_t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop</span><span class="params">(PriorityQueue_t *<span class="built_in">queue</span>, Node_t* top)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(top, <span class="number">0</span>, <span class="keyword">sizeof</span>(Node_t));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Queue is empty!\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(top, &amp;(<span class="built_in">queue</span>-&gt;heap[<span class="number">0</span>]), <span class="keyword">sizeof</span>(Node_t));</span><br><span class="line">        <span class="built_in">queue</span>-&gt;heap[<span class="number">0</span>] = <span class="built_in">queue</span>-&gt;heap[<span class="built_in">queue</span>-&gt;size - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">queue</span>-&gt;size--;</span><br><span class="line">        siftDown(<span class="built_in">queue</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printPriorityQueue</span><span class="params">(PriorityQueue_t *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Priority queue:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">queue</span>-&gt;size; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;    %s: %d\n&quot;</span>, <span class="built_in">queue</span>-&gt;heap[i].course, <span class="built_in">queue</span>-&gt;heap[i].priority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyPriorityQueue</span><span class="params">(PriorityQueue_t *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">queue</span>-&gt;heap);</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">10</span>, capacity = <span class="number">10</span>;</span><br><span class="line">    Node_t node[] = &#123;</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="string">&quot;Computer Science&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">7</span>, <span class="string">&quot;Discrete Mathematics&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">26</span>, <span class="string">&quot;Data Structures and Algorithms&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">25</span>, <span class="string">&quot;Operating Systems&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">19</span>, <span class="string">&quot;C Programming Languages&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">17</span>, <span class="string">&quot;Computer Networks&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="string">&quot;Database Management Systems&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">90</span>, <span class="string">&quot;Artificial Intelligence&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, <span class="string">&quot;Linear Algebra&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">36</span>, <span class="string">&quot;Calculus&quot;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    PriorityQueue_t *<span class="built_in">queue</span> = initPriorityQueue(capacity);</span><br><span class="line">    Node_t *topNode = (Node_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node_t));</span><br><span class="line">    <span class="built_in">memset</span>(topNode, <span class="number">0</span>, <span class="keyword">sizeof</span>(Node_t));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        push(<span class="built_in">queue</span>, &amp;(node[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    printPriorityQueue(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    peek(<span class="built_in">queue</span>, topNode);</span><br><span class="line">    <span class="keyword">if</span> (topNode-&gt;course &amp;&amp; topNode != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Priority queue top course: %s\n&quot;</span>, topNode-&gt;course);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pop(<span class="built_in">queue</span>, topNode);</span><br><span class="line">    <span class="keyword">if</span> (topNode-&gt;course &amp;&amp; topNode != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Priority queue pop course: %s\n&quot;</span>, topNode-&gt;course);</span><br><span class="line">    &#125;</span><br><span class="line">    printPriorityQueue(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        pop(<span class="built_in">queue</span>, topNode);</span><br><span class="line">        <span class="keyword">if</span> (topNode-&gt;course &amp;&amp; topNode != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Priority queue pop course: %s\n&quot;</span>, topNode-&gt;course);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(topNode);</span><br><span class="line">    destroyPriorityQueue(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Priority queue:</span><br><span class="line">    Artificial Intelligence: 90</span><br><span class="line">    Calculus: 36</span><br><span class="line">    Computer Networks: 17</span><br><span class="line">    Operating Systems: 25</span><br><span class="line">    Data Structures and Algorithms: 26</span><br><span class="line">    Discrete Mathematics: 7</span><br><span class="line">    Database Management Systems: 1</span><br><span class="line">    Computer Science: 2</span><br><span class="line">    Linear Algebra: 3</span><br><span class="line">    C Programming Languages: 19</span><br><span class="line">Priority queue top course: Artificial Intelligence</span><br><span class="line">Priority queue pop course: Artificial Intelligence</span><br><span class="line">Priority queue:</span><br><span class="line">    Calculus: 36</span><br><span class="line">    Data Structures and Algorithms: 26</span><br><span class="line">    Computer Networks: 17</span><br><span class="line">    Operating Systems: 25</span><br><span class="line">    C Programming Languages: 19</span><br><span class="line">    Discrete Mathematics: 7</span><br><span class="line">    Database Management Systems: 1</span><br><span class="line">    Computer Science: 2</span><br><span class="line">    Linear Algebra: 3</span><br><span class="line">Priority queue pop course: Calculus</span><br><span class="line">Priority queue pop course: Data Structures and Algorithms</span><br><span class="line">Priority queue pop course: Operating Systems</span><br><span class="line">Priority queue pop course: C Programming Languages</span><br><span class="line">Priority queue pop course: Computer Networks</span><br><span class="line">Priority queue pop course: Discrete Mathematics</span><br><span class="line">Priority queue pop course: Linear Algebra</span><br><span class="line">Priority queue pop course: Computer Science</span><br><span class="line">Priority queue pop course: Database Management Systems</span><br><span class="line">Queue is empty!</span><br></pre></td></tr></table></figure>

<p>在这个代码中，你可能已经注意到函数 <code>peek</code> 和 <code>pop</code> 的返回值类型是 <code>void</code>，且增加了一个入参 <code>Node_t *</code>。这是因为，这里实现的堆优先队列中存储的是复杂的结构体，我们在获取堆顶数据或弹出堆顶数据时，需要保存数据的所有内容。完成这个目的可以考虑以下两种方式：</p>
<ol>
<li>增加一个 <code>Node_t *</code> 入参：将外部申请的一块空间的地址传进来，用于保存堆顶数据，同时也可以处理堆优先队列为空的分支。这种方式，在读取数据及时的情况下，可以实现重复利用这块空间。</li>
<li>将函数 <code>peek</code> 和 <code>pop</code> 的返回值修改为 <code>Node_t *</code>：这种方式需要在函数内部 <code>malloc</code> 一块空间用于保存返回的数据块，后续需要由用户手动释放每次函数调用所申请的空间，避免内存泄漏。<ul>
<li>这种方式，需要多次 <code>malloc</code> 申请空间和多次 <code>free</code> 释放空间，且没有尽可能地遵循谁申请谁释放的原则。</li>
<li><strong>我们不能将堆顶的地址直接作为函数的返回值，因为堆顶的地址的数据是不固定的（在堆化时会被修改）</strong>。</li>
</ul>
</li>
</ol>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://github.com/kodecocodes/swift-algorithm-club/tree/master/Priority%20Queue">Priority Queue in swift-algorithm-club</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>优先队列</category>
      </categories>
      <tags>
        <tag>优先队列</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter4.1 非连续内存分配之分段与分页</title>
    <url>/posts/231111172507.html</url>
    <content><![CDATA[<p>这篇文章主要介绍操作系统的非连续内存分配，包括非连续内存分配的必要性、分段（segmentation）与分页（paging）技术。</p>
<span id="more"></span>

<h2 id="非连续内存分配的必要性"><a href="# 非连续内存分配的必要性" class="headerlink" title="非连续内存分配的必要性"></a>非连续内存分配的必要性 </h2><p> 第三章介绍的是连续内存管理，即：操作系统加载到内存以及程序加载到内存中时，分配一块连续的空闲内存块，但是容易出现碎片问题。这一章介绍的非连续内存分配，可以有效的减少碎片的出现。</p>
<h3 id="连续内存分配的缺点"><a href="# 连续内存分配的缺点" class="headerlink" title="连续内存分配的缺点"></a>连续内存分配的缺点</h3><ol>
<li>分配给一个程序的物理内存是连续的</li>
<li>内存利用率低</li>
<li>有外碎片、内碎片的问题</li>
</ol>
<blockquote>
<p>能否通过一些手段来改善这些情况？非连续内存分配！</p>
</blockquote>
<h3 id="非连续内存分配的优点"><a href="# 非连续内存分配的优点" class="headerlink" title="非连续内存分配的优点"></a>非连续内存分配的优点</h3><ol>
<li>分配给一个程序的物理地址空间是非连续的</li>
<li>更好的内存利用和管理</li>
<li>允许共享代码与数据（共享库等…）</li>
<li>支持动态加载和动态链接</li>
</ol>
<h3 id="非连续内存分配的缺点"><a href="# 非连续内存分配的缺点" class="headerlink" title="非连续内存分配的缺点"></a>非连续内存分配的缺点 </h3><p> 建立虚拟地址和物理地址的转换难度大</p>
<ul>
<li>软件方案（开销相当大）</li>
<li>硬件方案（采用硬件辅助机制）<ul>
<li>分段（segmentation）</li>
<li>分页（paging）</li>
</ul>
</li>
</ul>
<h2 id="非连续内存分配"><a href="# 非连续内存分配" class="headerlink" title="非连续内存分配"></a>非连续内存分配 </h2><h3 id="分段（segmentation）"><a href="# 分段（segmentation）" class="headerlink" title="分段（segmentation）"></a> 分段（segmentation）</h3><h4 id="分段"><a href="# 分段" class="headerlink" title="分段"></a>分段 </h4><p> 分段（segmentation）是一种非连续内存分配技术，用于操作系统中 <strong> 管理进程的内存空间</strong>。在分段技术中，进程的内存空间被划分为多个段，每个段具有不同的大小和功能。</p>
<img src="/images/os-kernel/chapter4/process-memory-segmentation.png" alt="进程内存空间划分" width="50%" height="50%">

<p>「段」：在程序执行时，会存在来自不同文件的函数和不同的数据字段。这些函数可能分布在程序的不同文件中，而数据字段则可以包括堆、栈、.bss、.data 等不同类型。</p>
<ul>
<li>堆用于动态内存分配</li>
<li>栈用于函数调用和局部变量存储</li>
<li>.bss 用于存储未初始化的静态变量</li>
<li>.data 用于存储已初始化的静态变量</li>
</ul>
<p>「分段」：更好的实现内存的分离和共享</p>
<p>程序的分段地址空间如下图所示：<br><img src="/images/os-kernel/chapter4/process-segmentation-space.png" alt="程序的分段地址空间" width="60%" height="60%"></p>
<p>把左边运行程序的逻辑地址空间看成一个连续的一维线性数组，通过段机制的映射关系，把不同的内存块（如：代码、数据、堆、栈）分别映射到不同的内存中的段，可以看到映射到物理地址空间后，位置不一样，变得不连续了。</p>
<p>分段的逻辑视图，连续的逻辑地址空间被分配到物理空间中的不连续内存空间中：<br><img src="/images/os-kernel/chapter4/segmentation-logical-view.png" alt="分段的逻辑视图" width="60%" height="60%"></p>
<h4 id="段表"><a href="# 段表" class="headerlink" title="段表"></a>段表 </h4><p> 段表是一种数据结构，用于 <strong> 存储和管理分段技术下的进程内存空间</strong>。它通常是一个数组或链表，每个元素表示一个段的相关信息。一个段对应着一个内存“块”。</p>
<p>下面是一个简化的段表数据结构示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentEntry</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> segmentID;      <span class="comment">// 段 ID</span></span><br><span class="line">    <span class="type">int</span> baseAddress;    <span class="comment">// 段基址</span></span><br><span class="line">    <span class="type">int</span> limit;          <span class="comment">// 段界限</span></span><br><span class="line">    <span class="type">int</span> permissions;    <span class="comment">// 段访问权限</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，每个段表项包含了以下信息：</p>
<ul>
<li><code>segmentID</code>：段的唯一标识符，用于区分不同的段。</li>
<li><code>baseAddress</code>：段的基址，指示段在内存中的起始位置。</li>
<li><code>limit</code>：段的界限，指示段的大小。通常以字节为单位。</li>
<li><code>permissions</code>：段的访问权限，用于控制对段的读、写和执行操作。</li>
</ul>
<p>段表根据进程的需要进行动态更新，以反映内存中段的分配和释放情况。通过段表，操作系统可以轻松地查找和管理进程的各个段，实现内存隔离和安全性。</p>
<h4 id="分段寻址方案"><a href="# 分段寻址方案" class="headerlink" title="分段寻址方案"></a>分段寻址方案</h4><img src="/images/os-kernel/chapter4/segmentation-scheme.png" alt="硬件分段实现方案" width="60%" height="60%">

<p>逻辑地址空间连续，但是物理地址空间不连续，使用映射机制进行关联。</p>
<p>程序访问物理内存地址需要：一个二维的二元组 <code>(segmentID, addrOffset)</code>，即 <code>(段号, 段内偏移地址)</code>。</p>
<p>操作系统会维护一张段表，每个索引行存储着 <code>(segmentID, baseAddress, limit)</code></p>
<p>因此，逻辑地址映射后的物理地址为：段号对应的段基址 + 二元组中的段内偏移地址</p>
<blockquote>
<p>段表 在寻址之前操作系统就会建立好，之后段机制就可以正常工作了。</p>
</blockquote>
<h2 id="分页（paging）"><a href="# 分页（paging）" class="headerlink" title="分页（paging）"></a>分页（paging）</h2><h3 id="分页概述"><a href="# 分页概述" class="headerlink" title="分页概述"></a>分页概述 </h3><p> 分页（paging）是操作系统中的一种非连续内存分配技术。它将物理内存和逻辑内存进行分割：</p>
<ul>
<li>将逻辑内存地址空间划分相等大小的页面（page）<ul>
<li>大小是 2 的幂，例如：512bytes / 4096bytes / 8192bytes</li>
</ul>
</li>
<li>将物理内存也划分成相等大小的物理页帧（page frame）<ul>
<li>大小是 2 的幂，例如：512bytes / 4096bytes / 8192bytes</li>
</ul>
</li>
</ul>
<blockquote>
<p>逻辑空间中内存划分叫做页（page），物理空间中内存划分叫做页帧（page frame），且划分的 page 大小和 frame 大小要保持一致。</p>
</blockquote>
<h3 id="页到页帧的转换"><a href="# 页到页帧的转换" class="headerlink" title="页到页帧的转换"></a>页到页帧的转换 </h3><p> 页到页帧的转换方案（pages to page frames）/ 逻辑地址到物理地址的转换方案：</p>
<ul>
<li>通过页表（page table）</li>
<li>内存管理单元（MMU）/ 快表（TLB）</li>
</ul>
<h3 id="帧（Frame）"><a href="# 帧（Frame）" class="headerlink" title="帧（Frame）"></a>帧（Frame）</h3><p>物理内存被分割为大小相等的帧，一个内存物理地址是一个二元组 <code>(f, o)</code>：</p>
<ul>
<li><code>f</code> 为页帧号（一共有 $F$ 位，可以表示 $2^F$ 个不同的页帧）</li>
<li><code>o</code> 为页帧内偏移（一共有 $S$ 位，每个页帧最大可以分配 $2^S$ 字节）</li>
</ul>
<p>页帧占用高地址空间，页帧内偏移占用低地址空间。二元组对应的物理地址为 $addr = 2^{S} \times f + o$。</p>
<blockquote>
<p>好比一本书，一共有 $2^F$ 页，每页书最多可以写 $2^S$ 个字，当前打开的页面是第 $f$ 页，笔处在本页第 $o$ 个字的位置，处在全书第 $2^{S} \times f + o$ 字的位置。</p>
</blockquote>
<p>举个栗子，试试你会不会算：<br>一个由 $16 bit$ 组成的地址空间，$9 bit$ 大小（512 字节）的页帧，物理地址的二元组为 $(3,6)$，请问物理地址是多少？</p>
<p>由描述可知，$F=16-9=7, S=9, f=3, o=6$，则二元组对应的物理地址为 $2^{9} \times 3 + 6 = 1542$。</p>
<blockquote>
<p>分页和分段的最大区别：这里的 $S$ 是一个固定的数，即每页页帧大小相同，而分段中的长度限制不固定。</p>
</blockquote>
<h3 id="页（Page）"><a href="# 页（Page）" class="headerlink" title="页（Page）"></a>页（Page）</h3><p>进程逻辑地址空间被划分为大小相等的页，一个进程逻辑地址是一个二元组 <code>(p, o)</code>：</p>
<ul>
<li><code>p</code> 为页号（一共有 $P$ 位，可以表示 $2^P$ 个不同的页）</li>
<li><code>o</code> 为页内偏移（一共有 $S$ 位，每页最大可以分配 $2^S$ 字节）</li>
</ul>
<p>二元组对应的逻辑（虚拟）地址为 $addr = 2^{S} \times p + o$。</p>
<blockquote>
<p>通常页号大小 <strong> 不等于 </strong> 页帧号大小，页内偏移跟页帧内偏移大小一致，每页（页帧）的字节数大小一致。</p>
</blockquote>
<h3 id="页寻址方案"><a href="# 页寻址方案" class="headerlink" title="页寻址方案"></a>页寻址方案 </h3><p> 当进程需要访问一个逻辑地址时，操作系统将逻辑地址分成两个部分：页号（page number）和页内偏移（page offset）。页号用于索引页表（page table），页表记录了每个页号对应的物理页帧号。通过找到页表中对应的物理页帧号，再加上页内偏移，就可以得到实际的物理地址，从而进行物理内存访问。</p>
<img src="/images/os-kernel/chapter4/page-addressing-scheme.png" alt="页寻址方案" width="60%" height="60%">

<blockquote>
<p>页寻址过程：逻辑地址 -&gt; 页号 -&gt; 查找页表 -&gt; 物理页帧号 -&gt; 利用页内偏移 -&gt; 实际物理地址 -&gt; 物理内存访问。</p>
</blockquote>
<ul>
<li>页表保存了逻辑地址到物理地址的映射关系（页号：物理页帧号）</li>
<li>逻辑地址空间应当大于物理内存空间</li>
<li>页映射到帧</li>
<li>页是连续的虚拟内存</li>
<li>帧是非连续的物理内存（有助于减少碎片的产生）</li>
<li>不是所有的页都有对应的帧</li>
</ul>
<blockquote>
<p>参考资料<br>1：<a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a><br>2：<a href="https://blog.csdn.net/weixin_53407527/article/details/124891795">https://blog.csdn.net/weixin_53407527/article/details/124891795</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>非连续内存分配</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之堆栈（数组实现）</title>
    <url>/posts/231016161508.html</url>
    <content><![CDATA[<p>栈与数组类似，但功能受限，只能通过 push 将新元素添加到栈的顶部，通过 pop 从栈中移除顶部的元素，并通过 peek 查看顶部的元素而不将其弹出。栈提供了后进先出（LIFO, last-in first-out）的顺序，最后推入的元素将在下一次弹出时首先出栈。</p>
<span id="more"></span>

<h2 id="堆栈的实现方式"><a href="# 堆栈的实现方式" class="headerlink" title="堆栈的实现方式"></a>堆栈的实现方式 </h2><p> 在 C 语言中，可以使用以下方法来实现堆栈（stack）数据结构：</p>
<ol>
<li><p>使用数组：可以使用一个固定大小的数组来表示堆栈。堆栈有两个重要的指针：一个是指向栈顶的指针，另一个是指向栈底的指针。在数组中，栈顶指针指向最新添加的元素，栈底指针指向最旧的元素。可以使用数组的索引来实现栈的推入 (push) 和弹出 (pop) 操作。</p>
</li>
<li><p>使用链表：可以使用链表来表示堆栈。链表中的每个节点包含一个元素和一个指向下一个节点的指针。栈顶指针指向链表的第一个节点，栈底指针指向链表的最后一个节点。入栈操作将创建一个新节点，并将其插入链表的开头；出栈操作将删除链表的第一个节点。</p>
</li>
</ol>
<blockquote>
<p>链表实现堆栈时，<strong>采用头插法</strong>，即在链表头结点前插入新节点、删除节点。这样做，方便 push 和 pop 操作；如果在链表的最后插入新节点，那么在 pop 操作时，更新栈顶的节点指针将会很麻烦 &amp; 费时。</p>
</blockquote>
<p>这篇文章将介绍使用数组实现堆栈这种数据结构。</p>
<h2 id="数组实现堆栈"><a href="# 数组实现堆栈" class="headerlink" title="数组实现堆栈"></a>数组实现堆栈 </h2><h3 id="定义并初始化堆栈结构"><a href="# 定义并初始化堆栈结构" class="headerlink" title="定义并初始化堆栈结构"></a> 定义并初始化堆栈结构 </h3><p> 使用一个固定长度的数组来实现具有先进先出的堆栈结构。为了将不同的堆栈和栈顶位置对应起来，这里使用一个结构体来组合堆栈和栈顶位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE (3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCEPTION_VALUE (-1) </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data[MAX_SIZE];  <span class="comment">// 数组实现堆栈</span></span><br><span class="line">    <span class="type">int</span> top;  <span class="comment">// 初始化栈顶位置</span></span><br><span class="line">&#125; Stack;</span><br></pre></td></tr></table></figure>

<h3 id="初始化堆栈"><a href="# 初始化堆栈" class="headerlink" title="初始化堆栈"></a>初始化堆栈</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// memset(stack-&gt;data, 0, MAX_SIZE * sizeof(int));</span></span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断堆栈是否为空"><a href="# 判断堆栈是否为空" class="headerlink" title="判断堆栈是否为空"></a>判断堆栈是否为空</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断堆栈是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断堆栈是否已满"><a href="# 判断堆栈是否已满" class="headerlink" title="判断堆栈是否已满"></a>判断堆栈是否已满</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断堆栈是否已满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == MAX_SIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="入栈操作"><a href="# 入栈操作" class="headerlink" title="入栈操作"></a>入栈操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元素入栈</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">push</span><span class="params">(Stack *<span class="built_in">stack</span>, <span class="type">int</span> element)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is full\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;data[++(<span class="built_in">stack</span>-&gt;top)] = element;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="出栈操作"><a href="# 出栈操作" class="headerlink" title="出栈操作"></a>出栈操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元素出栈</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[(<span class="built_in">stack</span>-&gt;top)--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了区分栈空时的返回值与正常出栈的数据，需要定义异常值为不会出现在正常数据中的值；或者修改函数的返回值为指针类型，返回值不为空时对应着有效数据。</p>
<h3 id="获取栈顶元素"><a href="# 获取栈顶元素" class="headerlink" title="获取栈顶元素"></a>获取栈顶元素</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取栈顶元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="打印堆栈数据"><a href="# 打印堆栈数据" class="headerlink" title="打印堆栈数据"></a>打印堆栈数据</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印堆栈中的元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printStack</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">stack</span>-&gt;top; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">stack</span>-&gt;data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组实现堆栈完整代码"><a href="# 数组实现堆栈完整代码" class="headerlink" title="数组实现堆栈完整代码"></a>数组实现堆栈完整代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE (3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCEPTION_VALUE (-1) </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data[MAX_SIZE];  <span class="comment">// 数组实现堆栈</span></span><br><span class="line">    <span class="type">int</span> top;  <span class="comment">// 初始化栈顶位置</span></span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// memset(stack-&gt;data, 0, MAX_SIZE * sizeof(int));</span></span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == MAX_SIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">push</span><span class="params">(Stack *<span class="built_in">stack</span>, <span class="type">int</span> element)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is full\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;data[++(<span class="built_in">stack</span>-&gt;top)] = element;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[(<span class="built_in">stack</span>-&gt;top)--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printStack</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">stack</span>-&gt;top; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">stack</span>-&gt;data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> *argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    Stack stack1;</span><br><span class="line">    initStack(&amp;stack1);</span><br><span class="line"></span><br><span class="line">    printStack(&amp;stack1);</span><br><span class="line">    push(&amp;stack1, <span class="number">1</span>);</span><br><span class="line">    push(&amp;stack1, <span class="number">2</span>);</span><br><span class="line">    push(&amp;stack1, <span class="number">3</span>);</span><br><span class="line">    printStack(&amp;stack1);</span><br><span class="line">    push(&amp;stack1, <span class="number">4</span>);</span><br><span class="line">    printStack(&amp;stack1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Pop element: %d\n&quot;</span>, pop(&amp;stack1));</span><br><span class="line">    printStack(&amp;stack1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Top element: %d\n&quot;</span>, peek(&amp;stack1));</span><br><span class="line">    printStack(&amp;stack1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stack is empty</span><br><span class="line">Stack: 1 2 3</span><br><span class="line">Stack is full</span><br><span class="line">Stack: 1 2 3</span><br><span class="line">Pop element: 3</span><br><span class="line">Stack: 1 2</span><br><span class="line">Top element: 2</span><br><span class="line">Stack: 1 2</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>堆栈</category>
      </categories>
      <tags>
        <tag>堆栈</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之堆栈（链表实现）</title>
    <url>/posts/231016184406.html</url>
    <content><![CDATA[<p>栈提供了一种后进先出（LIFO, last-in first-out）存储结构，并在 <a href="https://pursue26.github.io/posts/231016161508.html"> 数据结构之堆栈（数组实现）</a>中，介绍了数组实现的堆栈。这篇文章将介绍通过链表的方式实现堆栈这种数据结构。</p>
<span id="more"></span>

<h2 id="堆栈的实现方式"><a href="# 堆栈的实现方式" class="headerlink" title="堆栈的实现方式"></a>堆栈的实现方式 </h2><p> 在 C 语言中，可以使用以下方法来实现堆栈（stack）数据结构：</p>
<ol>
<li><p>使用数组：可以使用一个固定大小的数组来表示堆栈。堆栈有两个重要的指针：一个是指向栈顶的指针，另一个是指向栈底的指针。在数组中，栈顶指针指向最新添加的元素，栈底指针指向最旧的元素。可以使用数组的索引来实现栈的推入 (push) 和弹出 (pop) 操作。</p>
</li>
<li><p>使用链表：可以使用链表来表示堆栈。链表中的每个节点包含一个元素和一个指向下一个节点的指针。栈顶指针指向链表的第一个节点，栈底指针指向链表的最后一个节点。入栈操作将创建一个新节点，并将其插入链表的开头；出栈操作将删除链表的第一个节点。</p>
</li>
</ol>
<blockquote>
<p>链表实现堆栈时，<strong>采用头插法</strong>，即在链表头结点前插入新节点、删除节点。这样做，方便 push 和 pop 操作；如果在链表的最后插入新节点，那么在 pop 操作时，更新栈顶的节点指针将会很麻烦 &amp; 费时。</p>
</blockquote>
<h2 id="链表实现堆栈的优点"><a href="# 链表实现堆栈的优点" class="headerlink" title="链表实现堆栈的优点"></a>链表实现堆栈的优点 </h2><p> 链表实现堆栈相比于数组实现堆栈有以下几个优点：</p>
<ol>
<li>动态大小：链表实现的堆栈可以根据需要动态调整大小，而数组实现的堆栈需要预先指定大小。这意味着链表实现的堆栈可以根据实际需求进行扩展或缩小，而不会浪费内存或导致栈溢出。</li>
<li>内存管理：链表实现的堆栈只使用必要的内存空间，而数组实现的堆栈在创建时需要一定大小的连续内存空间。这意味着链表实现的堆栈可以更好地处理内存管理，避免浪费内存或导致内存溢出。</li>
</ol>
<p>总的来说，链表实现的堆栈更加灵活和动态，适用于需要频繁插入和删除操作的场景，而数组实现的堆栈更适用于事先知道栈大小且不需要频繁调整大小的场景。</p>
<h2 id="链表实现堆栈"><a href="# 链表实现堆栈" class="headerlink" title="链表实现堆栈"></a>链表实现堆栈 </h2><h3 id="定义并初始化堆栈结构"><a href="# 定义并初始化堆栈结构" class="headerlink" title="定义并初始化堆栈结构"></a> 定义并初始化堆栈结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;  <span class="comment">// 堆栈的数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span>  <span class="comment">// 下一个弹出的数据的存储地址</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;  <span class="comment">// 数据量大小</span></span><br><span class="line">    <span class="type">int</span> max;   <span class="comment">// 最大容量</span></span><br><span class="line">    Node *top;  <span class="comment">// 堆栈的头指针</span></span><br><span class="line">&#125; Stack;</span><br></pre></td></tr></table></figure>

<p>在这里，我们使用一个结构体实现具有先进先出的堆栈结构，其中的两个成员标记这堆栈中的数据量和最大存储数据量大小，另一个成员标记着栈顶地址。</p>
<ul>
<li>这里的栈顶地址，即为链表的头结点地址，所有这个成员的数据类型为链表结构：<ul>
<li>链表结构中需要包含存放的数据和指向下一个数据的地址。</li>
</ul>
</li>
</ul>
<p>其中，成员 <code>size</code> 和成员 <code>max</code> 主要用于执行堆栈是否为空和堆栈是否已满操作，<code>top</code>指针主要用于执行堆栈的入栈、出栈和栈顶查询等操作。</p>
<h3 id="初始化堆栈"><a href="# 初始化堆栈" class="headerlink" title="初始化堆栈"></a>初始化堆栈</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EXCEPTION_VALUE (-1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> max_size = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">Stack *<span class="title function_">initStack</span><span class="params">(<span class="type">int</span> max_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    Stack *<span class="built_in">stack</span> = (Stack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    <span class="built_in">stack</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;max = max_size;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断堆栈是否为空"><a href="# 判断堆栈是否为空" class="headerlink" title="判断堆栈是否为空"></a>判断堆栈是否为空</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断堆栈是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断堆栈是否已满"><a href="# 判断堆栈是否已满" class="headerlink" title="判断堆栈是否已满"></a>判断堆栈是否已满</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断堆栈是否已满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;size &gt;= <span class="built_in">stack</span>-&gt;max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="入栈操作"><a href="# 入栈操作" class="headerlink" title="入栈操作"></a>入栈操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元素入栈</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">push</span><span class="params">(Stack *<span class="built_in">stack</span>, <span class="type">int</span> element)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is full\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node *node = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        node-&gt;data = element;</span><br><span class="line">        node-&gt;next = <span class="built_in">stack</span>-&gt;top;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;size++;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;top = node;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="出栈操作"><a href="# 出栈操作" class="headerlink" title="出栈操作"></a>出栈操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元素出栈</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> topVal = <span class="built_in">stack</span>-&gt;top-&gt;data;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;top = <span class="built_in">stack</span>-&gt;top-&gt;next;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;size--;</span><br><span class="line">        <span class="keyword">return</span> topVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了区分栈空时的返回值与正常出栈的数据，需要定义异常值为不会出现在正常数据中的值；或者修改函数的返回值为指针类型，返回值不为空时对应着有效数据。</p>
<h3 id="获取栈顶元素"><a href="# 获取栈顶元素" class="headerlink" title="获取栈顶元素"></a>获取栈顶元素</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取栈顶元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="打印堆栈数据"><a href="# 打印堆栈数据" class="headerlink" title="打印堆栈数据"></a>打印堆栈数据</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印堆栈中的元素, 从栈顶打印到栈底</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printStack</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack: &quot;</span>);</span><br><span class="line">        Node *head = <span class="built_in">stack</span>-&gt;top;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, head-&gt;data);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表实现堆栈完整代码"><a href="# 链表实现堆栈完整代码" class="headerlink" title="链表实现堆栈完整代码"></a>链表实现堆栈完整代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCEPTION_VALUE (-1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    Node *top;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line">Stack *<span class="title function_">initStack</span><span class="params">(<span class="type">int</span> max_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    Stack *<span class="built_in">stack</span> = (Stack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    <span class="built_in">stack</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;max = max_size;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;size &gt;= <span class="built_in">stack</span>-&gt;max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">push</span><span class="params">(Stack *<span class="built_in">stack</span>, <span class="type">int</span> element)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is full\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node *node = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        node-&gt;data = element;</span><br><span class="line">        node-&gt;next = <span class="built_in">stack</span>-&gt;top;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;size++;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;top = node;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> topVal = <span class="built_in">stack</span>-&gt;top-&gt;data;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;top = <span class="built_in">stack</span>-&gt;top-&gt;next;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;size--;</span><br><span class="line">        <span class="keyword">return</span> topVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printStack</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack: &quot;</span>);</span><br><span class="line">        Node *head = <span class="built_in">stack</span>-&gt;top;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, head-&gt;data);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> *argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    Stack *stack1 = <span class="literal">NULL</span>;</span><br><span class="line">    stack1 = initStack(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    printStack(stack1);</span><br><span class="line">    push(stack1, <span class="number">1</span>);</span><br><span class="line">    push(stack1, <span class="number">2</span>);</span><br><span class="line">    push(stack1, <span class="number">3</span>);</span><br><span class="line">    printStack(stack1);</span><br><span class="line">    push(stack1, <span class="number">4</span>);</span><br><span class="line">    printStack(stack1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Pop element: %d\n&quot;</span>, pop(stack1));</span><br><span class="line">    printStack(stack1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Top element: %d\n&quot;</span>, peek(stack1));</span><br><span class="line">    printStack(stack1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stack is empty</span><br><span class="line">Stack: 3 2 1</span><br><span class="line">Stack is full</span><br><span class="line">Stack: 3 2 1</span><br><span class="line">Pop element: 3</span><br><span class="line">Stack: 2 1</span><br><span class="line">Top element: 2</span><br><span class="line">Stack: 2 1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>堆栈</category>
      </categories>
      <tags>
        <tag>堆栈</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之拓扑排序</title>
    <url>/posts/230916094606.html</url>
    <content><![CDATA[<h2 id="什么是拓扑排序"><a href="# 什么是拓扑排序" class="headerlink" title="什么是拓扑排序"></a>什么是拓扑排序 </h2><p> 引用百度百科的拓扑排序定义：</p>
<blockquote>
<p>对一个有向无环图（Directed Acyclic Graph, DAG）$G$ 进行拓扑排序，是将 $G$ 中所有顶点排成一个 <strong> 线性序列 </strong>，使得图中任意一对顶点 $u$ 和 $v$，若边 $&lt;u,v&gt; \in E(G)$，则 $u$ <strong> 在线性序列中出现在 </strong> $v$ 之前。通常，这样的线性序列称为满足拓扑次序（Topological Order）的序列，简称<strong> 拓扑序列</strong>。</p>
</blockquote>
<p>拓扑排序可以被理解为对一个有向无环图进行排序的操作。在这个排序中，图中的顶点被排列成一个线性序列，<strong>满足以下条件：对于图中的任意一对顶点 $u$ 和 $v$，如果存在一条边 $&lt;u,v&gt;$，那么在线性序列中，顶点 $u$ 出现在顶点 $v$ 之前</strong>。</p>
<p>换句话说，拓扑排序可以将有向无环图中的顶点按照它们的依赖关系排序，使得所有的依赖关系都被满足。这对于处理任务的依赖关系非常有用，例如工程项目中的任务调度，编译器中的源代码依赖等。</p>
<span id="more"></span>

<p>例如，下图中 <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code> 是一个正确的拓扑排序，每个节点都在它所依赖的节点后面。而 <code>1-&gt;2-&gt;4-&gt;3-&gt;5</code> 则不满足拓扑排序的要求，<code>4</code> 依赖于 <code>3</code>，却出现在了 <code>3</code> 前面。</p>
<p><img src="/images/data-structure/topo-sort.png" alt=""></p>
<h2 id="拓扑排序基本原理"><a href="# 拓扑排序基本原理" class="headerlink" title="拓扑排序基本原理"></a>拓扑排序基本原理 </h2><p> 拓扑排序（Topological Sorting）是一种用于有向无环图（DAG）的排序算法，它将图中的节点按照依赖关系进行排序，使得所有的依赖关系都被满足。</p>
<p>拓扑排序的一些重要知识点：</p>
<ol>
<li><p>有向无环图（DAG）：拓扑排序只能应用于没有环的有向图，因为有环的图存在循环依赖，无法进行拓扑排序。</p>
</li>
<li><p>入度和出度：在拓扑排序中，入度表示指向某个节点的边的数量，出度表示从某个节点发出的边的数量。</p>
</li>
<li><p>拓扑排序算法：拓扑排序算法可以通过深度优先搜索或广度优先搜索（Kahn 算法）来实现。<strong>DFS 通常使用递归或栈来实现，而 BFS 则使用队列来实现</strong>。</p>
</li>
<li><p>多个拓扑排序结果：一个有向图可能存在多种不同的拓扑排序结果，这取决于节点的访问顺序。一种常见的方法是使用优先队列或字典序来选择节点的顺序，以得到特定的排序结果。</p>
</li>
</ol>
<h3 id="要解决的问题"><a href="# 要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题 </h3><p> 对于有向图进行拓扑排序要解决两个问题：</p>
<ul>
<li>一是要判断待排序的有向图是不是无环；</li>
<li>二是按照依赖关系生成正确的序列。</li>
</ul>
<h3 id="基本思想"><a href="# 基本思想" class="headerlink" title="基本思想"></a>基本思想 </h3><p> 拓扑排序的基本思想是：</p>
<ul>
<li><p>入度思想：首先找到图中没有前驱节点的节点（即入度为 0 的节点），将其 <strong> 顺序 </strong> 加入结果列表中，并将其从图中删除。然后，继续寻找新的没有前驱节点的节点，并重复以上过程，直到所有的节点都被加入结果列表中或者无法再找到没有前驱节点的节点为止。</p>
</li>
<li><p>出度思想：首先找到图中没有后驱节点的节点（即出度为 0 的节点），将其 <strong> 逆序 </strong> 加入结果列表中，并将其从图中删除。然后，继续寻找新的没有后驱节点的节点，并重复以上过程，直到所有的节点都被加入结果列表中或者无法再找到没有后驱节点的节点为止。</p>
</li>
</ul>
<h3 id="BFS-Kaha 拓扑排序算法"><a href="#BFS-Kaha 拓扑排序算法" class="headerlink" title="BFS/Kaha 拓扑排序算法"></a>BFS/Kaha 拓扑排序算法 </h3><p> 拓扑排序的具体步骤：</p>
<ol>
<li>初始化一个结果列表（或者称为拓扑序列）和一个队列。</li>
<li>遍历图中的所有节点（对），统计每个节点的入度（即有多少条边指向该节点）。</li>
<li>将入度为 0 的节点加入队列中。</li>
<li>当队列不为空时，执行以下操作：<ul>
<li>取出队首节点，并将其加入结果列表中。</li>
<li>遍历该节点的所有邻接节点（即该节点指向的节点）：<ul>
<li>将邻接节点的入度减 1。</li>
<li>如果邻接节点的入度减为 0，将其加入队列中。</li>
</ul>
</li>
</ul>
</li>
<li>如果结果列表的长度等于图中的节点数，则说明拓扑排序成功，返回结果列表，表示拓扑序列。</li>
<li>如果结果列表的长度小于图中的节点数，则说明图中存在环，无法进行拓扑排序。</li>
</ol>
<p>通过循环找到入度为 0 的节点，并将其加入结果列表，然后更新与该节点相邻的节点的入度，重复此过程，最终得到一个满足拓扑次序的序列，或者判断出图中存在环。</p>
<blockquote>
<p>BFS / Kaha 拓扑排序算法是从入度的角度着手的，这种方法可称之为 <strong> 入度方法</strong>。</p>
</blockquote>
<h3 id="BFS 拓扑排序实现"><a href="#BFS 拓扑排序实现" class="headerlink" title="BFS 拓扑排序实现"></a>BFS 拓扑排序实现 </h3><p> 以 <a href="https://leetcode.cn/problems/course-schedule-ii/">Leetcode 课程表 II</a> 为例，给出 BFS 拓扑排序算法的实现过程。</p>
<p>题目大意：一共有 n 门课程，课程之间存在依赖关系，比如先修完 A 课程，才能修 B 课程。问这个学生能不能修完所有课程，能的话则返回一种可能的课程学习顺序。</p>
<p>代码实现中的关键变量：</p>
<ul>
<li><code>indegree[]</code>：初始化每个节点的入度，并随着节点出队更新入度值；</li>
<li><code>edges[][]</code>：记录每个节点影响的其它节点，用于该节点的入度变为 0 时更新“影响的其它节点”的入度值；</li>
<li><code>queue</code>：队列用于入队、出队所有入度为 0 的节点；</li>
<li><code>ans[]</code>：结果队列用于保存出队的节点；</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ELEM_TYPE int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Define the structure for a node in the queue</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ELEM_TYPE data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define the structure for the queue</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    Node* front;</span><br><span class="line">    Node* rear;</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to create a new node</span></span><br><span class="line">Node* <span class="title function_">createNode</span><span class="params">(ELEM_TYPE data)</span> &#123;</span><br><span class="line">    Node* newNode = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to create an empty queue</span></span><br><span class="line">Queue* <span class="title function_">createQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    Queue* <span class="built_in">queue</span> = (Queue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to check if the queue is empty</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Queue* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to enqueue an element into the queue</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enQueue</span><span class="params">(Queue* <span class="built_in">queue</span>, ELEM_TYPE data)</span> &#123;</span><br><span class="line">    Node* newNode = createNode(data);</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear-&gt;next = newNode;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to dequeue an element from the queue</span></span><br><span class="line">ELEM_TYPE <span class="title function_">deQueue</span><span class="params">(Queue* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* temp = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">    ELEM_TYPE data = temp-&gt;data;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;front-&gt;next;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">findOrder</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>** prerequisites, <span class="type">int</span> prerequisitesSize, <span class="type">int</span>* prerequisitesColSize, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> indegree[numCourses];  <span class="comment">// 每个节点的入度，入度为 0 表示不受其它节点影响 </span></span><br><span class="line">    <span class="type">int</span> **edges = (<span class="type">int</span> **)<span class="built_in">malloc</span>(numCourses * <span class="keyword">sizeof</span>(<span class="type">int</span> *));  <span class="comment">// 二维数组, 记录每个节点影响的节点们</span></span><br><span class="line">    <span class="type">int</span> edgeNums[numCourses];  <span class="comment">// 记录每个节点影响的节点数量, 用于动态扩展空间</span></span><br><span class="line">    <span class="type">int</span> *ans = (<span class="type">int</span> *)<span class="built_in">malloc</span>(numCourses * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">        indegree[i] = <span class="number">0</span>;</span><br><span class="line">        edgeNums[i] = <span class="number">0</span>;</span><br><span class="line">        edges[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">0</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 后续按需扩展</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历所有节点对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prerequisitesSize; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> suff = prerequisites[i][<span class="number">0</span>], pre = prerequisites[i][<span class="number">1</span>];</span><br><span class="line">        edgeNums[pre]++;  <span class="comment">// suff 受到了 pre 影响, 故 pre 节点影响的节点数量 +1</span></span><br><span class="line">        indegree[suff]++;  <span class="comment">// suff 受到了 pre 影响，其入度要 +1</span></span><br><span class="line">        edges[pre] = (<span class="type">int</span> *)<span class="built_in">realloc</span>(edges[pre], edgeNums[pre] * <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 扩展内存</span></span><br><span class="line">        edges[pre][edgeNums[pre] - <span class="number">1</span>] = suff;  <span class="comment">// 在索引(pre, 最后位置) 记录 suff</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue* <span class="built_in">queue</span> = createQueue();</span><br><span class="line">    <span class="comment">// 入度所有不受影响的节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            enQueue(<span class="built_in">queue</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        ELEM_TYPE cur = deQueue(<span class="built_in">queue</span>);</span><br><span class="line">        ans[count++] = cur;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历出队的节点影响的所有节点, 它们的受影响度将 -1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edgeNums[cur]; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> x = edges[cur][i];</span><br><span class="line">            indegree[x]--;</span><br><span class="line">            <span class="keyword">if</span> (indegree[x] == <span class="number">0</span>) &#123;</span><br><span class="line">                enQueue(<span class="built_in">queue</span>, x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">        <span class="built_in">free</span>(edges[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(edges);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断结果队列长度，确定是否可以完成拓扑排序</span></span><br><span class="line">    <span class="keyword">if</span> (count == numCourses) &#123;</span><br><span class="line">        (*returnSize) = count;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (*returnSize) = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DFS 拓扑排序算法"><a href="#DFS 拓扑排序算法" class="headerlink" title="DFS 拓扑排序算法"></a>DFS 拓扑排序算法</h3><p>DFS 拓扑排序算法的思想和 BFS 拓扑排序算法相似，但在具体步骤上有所不同。</p>
<p>DFS 拓扑排序算法的基本思想是：通过递归遍历图中的节点，<strong>从一个起始节点开始</strong>，当遍历到一个节点时，先将其所有未访问的邻居节点进行递归遍历，之后将当前节点添加到结果列表中。如果在递归的过程中，发现当遍历到一个节点时，存在已经被访问过的邻居节点，则说明途中存在环，无法进行拓扑排序。</p>
<p>DFS 拓扑排序的具体步骤如下：</p>
<ol>
<li>初始化一个空的结果列表和一个空的访问状态列表。</li>
<li>对于图中的每个节点，如果该节点未被访问，则调用 DFS 函数进行遍历。</li>
<li>在 DFS 函数中，首先将当前节点标记为正在访问。</li>
<li>递归遍历当前节点的所有未访问的邻居节点，将每个邻居节点作为新的起始节点进行递归遍历。</li>
<li>当没有未访问的邻居节点时，将当前节点的访问状态更新为已访问，并逆序添加到结果列表中。</li>
<li>最终，结果列表中的节点正序顺序即为 DFS 拓扑排序的结果。</li>
</ol>
<blockquote>
<p>需要注意的是：在进行 DFS 拓扑排序的过程中，如果发现某个节点的邻居节点已经被访问过（即已经在结果列表中），那么说明存在环，无法进行拓扑排序。在这种情况下，可以中断排序过程并返回一个表示存在环的标志。</p>
</blockquote>
<p>代码实现中的关键变量：</p>
<ul>
<li><code>visited[]</code>：记录每个节点的访问状态，0 表示未访问，1 表示正在访问，2 表示访问完成；</li>
<li><code>edges[][]</code>：记录每个节点所有邻居节点；</li>
<li><code>ans[]</code>：结果队列；</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span>* visited, <span class="type">int</span>** edges, <span class="type">int</span>* edgeNums, <span class="type">int</span>* ans, <span class="type">int</span>* cnt, <span class="type">bool</span>* valid)</span> &#123;</span><br><span class="line">    visited[node] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edgeNums[node]; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> neigNode = edges[node][i];</span><br><span class="line">        <span class="keyword">if</span> (visited[neigNode] == <span class="number">0</span>) &#123;</span><br><span class="line">            dfs(neigNode, visited, edges, edgeNums, ans, cnt, valid);</span><br><span class="line">            <span class="comment">// 这行代码测试发现不是必须的, 为什么不是必须的？加上可以有剪枝（提前终止）的作用</span></span><br><span class="line">            <span class="keyword">if</span> (!(*valid)) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (visited[neigNode] == <span class="number">1</span>) &#123;</span><br><span class="line">            *valid = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    visited[node] = <span class="number">2</span>;</span><br><span class="line">    ans[--(*cnt)] = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">findOrder</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>** prerequisites, <span class="type">int</span> prerequisitesSize, <span class="type">int</span>* prerequisitesColSize, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span>* visited = (<span class="type">int</span> *)<span class="built_in">malloc</span>(numCourses * <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 记录每一个节点的访问状态</span></span><br><span class="line">    <span class="type">int</span>** edges = (<span class="type">int</span> **)<span class="built_in">malloc</span>(numCourses * <span class="keyword">sizeof</span>(<span class="type">int</span> *));  <span class="comment">// 二维数组, 记录每个节点所有邻居节点</span></span><br><span class="line">    <span class="type">int</span>* edgeNums = (<span class="type">int</span> *)<span class="built_in">malloc</span>(numCourses * <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 记录每个节点的邻居节点数量</span></span><br><span class="line">    <span class="type">int</span>* ans = (<span class="type">int</span> *)<span class="built_in">malloc</span>(numCourses * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span> cnt = numCourses;</span><br><span class="line">    <span class="type">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, numCourses * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">memset</span>(edgeNums, <span class="number">0</span>, numCourses * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">        edges[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">0</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建邻接表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prerequisitesSize; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> suff = prerequisites[i][<span class="number">0</span>], pre = prerequisites[i][<span class="number">1</span>];  <span class="comment">// edge: pre-&gt;suff</span></span><br><span class="line">        edges[pre] = (<span class="type">int</span> *)<span class="built_in">realloc</span>(edges[pre], (edgeNums[pre] + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        edges[pre][edgeNums[pre]] = suff;</span><br><span class="line">        edgeNums[pre]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// DFS 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            dfs(i, visited, edges, edgeNums, ans, &amp;cnt, &amp;valid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">        <span class="built_in">free</span>(edges[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(edges);</span><br><span class="line">    <span class="built_in">free</span>(visited);</span><br><span class="line">    <span class="built_in">free</span>(edgeNums);</span><br><span class="line">    </span><br><span class="line">    *returnSize = (cnt &gt; <span class="number">0</span> || !valid) ? <span class="number">0</span> : numCourses;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考链接：<a href="https://jingsam.github.io/2020/08/11/topological-sort.html">https://jingsam.github.io/2020/08/11/topological-sort.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之链表（数组实现）</title>
    <url>/posts/231007174854.html</url>
    <content><![CDATA[<p>线性表是一组 <strong> 按线性顺序排列的、具有相同特征的数据元素的有限序列</strong>，其中的数据元素之间存在一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的（这句话只适用大部分线性表，而不是全部，如循环链表把最后一个数据元素的尾指针指向了首位结点）。线性表可以用于表示一串有序的数据，例如数组、链表、栈和队列等都是线性表的实现方式。</p>
<p>线性表中的「单链表」的实现，包括单链表的顺序存储（数组实现）和单链表的链式存储。这篇文章主要介绍单链表的顺序存储（数组实现）。</p>
<span id="more"></span>

<h2 id="数组和链表的特点"><a href="# 数组和链表的特点" class="headerlink" title="数组和链表的特点"></a>数组和链表的特点 </h2><p> 首先介绍一下数组和链表的特点。</p>
<p>数组：创建数组时会在内存空间中划分出一块连续的内存，然后数据进入时会将数据按顺序存储在这块连续的内存中。因为数组在存储数据时是按顺序存储的，存储数据的内存也是连续的。所以，<strong>数组的特点就是寻址读取数据容易，插入和删除比较困难 / 费时</strong>。</p>
<p>链表：链表不同于数组，不会先划分出一块连续的内存，链表中的数据并不是连续的，链表在存储数据的内存中有两块区域，一块区域用来存储数据，一块区域用来记录下一个数据保存在哪里。虽然链表是线性表，但是并不会按线性的顺序存储数据。所以，<strong>链表在插入和删除时比较容易，在读取数据时比较麻烦</strong>。</p>
<blockquote>
<p>这里的容易，即意味着时间复杂度低；麻烦，即意味着时间复杂度高。</p>
</blockquote>
<h2 id="链表的顺序存储（数组实现）"><a href="# 链表的顺序存储（数组实现）" class="headerlink" title="链表的顺序存储（数组实现）"></a>链表的顺序存储（数组实现）</h2><p>链表的 API 主要包括：</p>
<ul>
<li>创建并初始化链表</li>
<li>查找链表中的元素</li>
<li>向链表中插入元素</li>
<li>删除链表中的元素</li>
<li>获取链表的长度</li>
</ul>
<h3 id="链表结构定义"><a href="# 链表结构定义" class="headerlink" title="链表结构定义"></a>链表结构定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE (100)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data[MAX_SIZE];  <span class="comment">// 存储元素的数组</span></span><br><span class="line">    <span class="type">int</span> length;  <span class="comment">// 链表的长度</span></span><br><span class="line">&#125; ArrayList;</span><br></pre></td></tr></table></figure>

<p>这段代码定义了一个名为 <code>ArrayList</code> 的结构体，用来表示一个数组实现的链表。</p>
<p>该结构体包含两个成员变量：</p>
<ol>
<li><code>int data[MAX_SIZE]</code>：一个整型数组，用来存储链表中的元素。</li>
<li><code>int length</code>：一个整型变量，表示链表的长度。</li>
</ol>
<p>通过使用这个结构体，我们可以创建一个顺序存储结构的链表，其中元素按照顺序存储在数组中，并且可以通过索引来访问和修改链表中的元素。</p>
<h3 id="创建并初始化链表"><a href="# 创建并初始化链表" class="headerlink" title="创建并初始化链表"></a>创建并初始化链表 </h3><p> 使用动态申请内存空间的方式创建并初始化一个链表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ArrayList *<span class="title function_">initArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    ArrayList *<span class="built_in">list</span> = (ArrayList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArrayList));</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">list</span>-&gt;data, <span class="number">0</span>, MAX_SIZE * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">list</span>-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// printf(&quot;ArrayList size is %d bytes, data size is %d bytes.\n&quot;, sizeof(list), sizeof(list-&gt;data));</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查找链表中的元素"><a href="# 查找链表中的元素" class="headerlink" title="查找链表中的元素"></a>查找链表中的元素 </h3><p> 在链表中查找目标元素第一次出现时的索引，不存在则返回 -1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findArrayList</span><span class="params">(ArrayList *<span class="built_in">list</span>, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">/* 查找成功的平均比较次数为(n+1)/2 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>-&gt;length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;data[i] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;  <span class="comment">// 返回元素在链表中的索引</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 没有找到元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么查找成功的平均比较次数为 $\frac {n+1}{2}$ 呢？</p>
</blockquote>
<p>假设链表的长度为 $n$，若元素在链表中存在，在最坏情况下，需要比较 $n$ 次才能找到元素；在最好情况下，只需要比较 $1$ 次就能找到元素。因此，平均比较次数为 $\frac {n+1}{2}$。</p>
<h3 id="向链表中插入元素"><a href="# 向链表中插入元素" class="headerlink" title="向链表中插入元素"></a>向链表中插入元素 </h3><p> 向链表中指定的索引位置插入一个元素，可以在有效数据的最前面和最后面插入元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">insertArrayList</span><span class="params">(ArrayList *<span class="built_in">list</span>, <span class="type">int</span> index, <span class="type">int</span> element)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;length == MAX_SIZE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;List is full! Unable to insert element.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="built_in">list</span>-&gt;length) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid index! Unable to insert element.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">list</span>-&gt;length - <span class="number">1</span>; i &gt;= index; i--) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;data[i + <span class="number">1</span>] = <span class="built_in">list</span>-&gt;data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;data[index] = element;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length++;  <span class="comment">// 更新链表的长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除链表中的元素"><a href="# 删除链表中的元素" class="headerlink" title="删除链表中的元素"></a>删除链表中的元素 </h3><p> 删除链表中指定索引位置的元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deleteArrayList</span><span class="params">(ArrayList *<span class="built_in">list</span>, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;List is empty! Unable to delete element.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">list</span>-&gt;length) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid index! Unable to delete element.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; <span class="built_in">list</span>-&gt;length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;data[i] = <span class="built_in">list</span>-&gt;data[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length--;  <span class="comment">// 更新链表的长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取链表的长度"><a href="# 获取链表的长度" class="headerlink" title="获取链表的长度"></a>获取链表的长度 </h3><p> 获取链表中有效数据元素的长度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getArrayListLength</span><span class="params">(ArrayList *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>-&gt;length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="释放链表空间"><a href="# 释放链表空间" class="headerlink" title="释放链表空间"></a>释放链表空间</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freeArrayList</span><span class="params">(ArrayList *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表的数组实现完整代码"><a href="# 链表的数组实现完整代码" class="headerlink" title="链表的数组实现完整代码"></a>链表的数组实现完整代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE (100)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data[MAX_SIZE];  <span class="comment">// 存储元素的数组</span></span><br><span class="line">    <span class="type">int</span> length;  <span class="comment">// 链表的长度</span></span><br><span class="line">&#125; ArrayList;</span><br><span class="line"></span><br><span class="line">ArrayList *<span class="title function_">initArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    ArrayList *<span class="built_in">list</span> = (ArrayList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArrayList));</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">list</span>-&gt;data, <span class="number">0</span>, MAX_SIZE * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">list</span>-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ArrayList size is %d bytes, data size is %d bytes.\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="built_in">list</span>), <span class="keyword">sizeof</span>(<span class="built_in">list</span>-&gt;data));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findArrayList</span><span class="params">(ArrayList *<span class="built_in">list</span>, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>-&gt;length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;data[i] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;  <span class="comment">// 返回元素在链表中的索引</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 没有找到元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertArrayList</span><span class="params">(ArrayList *<span class="built_in">list</span>, <span class="type">int</span> index, <span class="type">int</span> element)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;length == MAX_SIZE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;List is full! Unable to insert element.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="built_in">list</span>-&gt;length) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid index! Unable to insert element.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">list</span>-&gt;length - <span class="number">1</span>; i &gt;= index; i--) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;data[i + <span class="number">1</span>] = <span class="built_in">list</span>-&gt;data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;data[index] = element;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length++;  <span class="comment">// 更新链表的长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteArrayList</span><span class="params">(ArrayList *<span class="built_in">list</span>, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;List is empty! Unable to delete element.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">list</span>-&gt;length) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid index! Unable to delete element.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; <span class="built_in">list</span>-&gt;length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;data[i] = <span class="built_in">list</span>-&gt;data[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length--;  <span class="comment">// 更新链表的长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getArrayListLength</span><span class="params">(ArrayList *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>-&gt;length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printArrayList</span><span class="params">(ArrayList *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>-&gt;length; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">list</span>-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeArrayList</span><span class="params">(ArrayList *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    ArrayList *<span class="built_in">list</span> = initArrayList();</span><br><span class="line"></span><br><span class="line">    insertArrayList(<span class="built_in">list</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    insertArrayList(<span class="built_in">list</span>, <span class="number">1</span>, <span class="number">20</span>);</span><br><span class="line">    insertArrayList(<span class="built_in">list</span>, <span class="number">2</span>, <span class="number">30</span>);</span><br><span class="line">    printArrayList(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    insertArrayList(<span class="built_in">list</span>, <span class="number">2</span>, <span class="number">40</span>);</span><br><span class="line">    insertArrayList(<span class="built_in">list</span>, <span class="number">0</span>, <span class="number">15</span>);</span><br><span class="line">    printArrayList(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Length of list: %d\n&quot;</span>, getArrayListLength(<span class="built_in">list</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> index = findArrayList(<span class="built_in">list</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">if</span> (index != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Element 20 is found at index %d\n&quot;</span>, index);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Element 20 is not found\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deleteArrayList(<span class="built_in">list</span>, <span class="number">1</span>);</span><br><span class="line">    printArrayList(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Length of list: %d\n&quot;</span>, getArrayListLength(<span class="built_in">list</span>));</span><br><span class="line"></span><br><span class="line">    freeArrayList(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ArrayList size is 8 bytes, data size is 400 bytes.</span><br><span class="line">10 20 30</span><br><span class="line">15 10 20 40 30</span><br><span class="line">Length of list: 5</span><br><span class="line">Element 20 is found at index 2</span><br><span class="line">15 20 40 30</span><br><span class="line">Length of list: 4</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之并查集（数组实现）</title>
    <url>/posts/231023164532.html</url>
    <content><![CDATA[<p>并查集（Union-Find Disjoint Sets, UFDS）是一种用于处理一些不相交集合的数据结构，实现为一个森林，其中的每棵树表示一个集合，树中的节点表示对应集合中的元素。</p>
<p>顾名思义，并查集支持两种操作：</p>
<ul>
<li>合并（Union）：合并两个元素所属集合（合并对应的树），通常是将两个集合的根节点连接在一起。</li>
<li>查找（Find）：查找某个元素所属集合，通常是找到该元素所在集合的根节点，这可以用于判断两个元素是否属于同一集合。</li>
</ul>
<span id="more"></span>

<p>下图是一个具有四个不相交集合的树构成的森林。<br><img src="/images/data-structure/UFDS-demo3.png" alt=""></p>
<h2 id="并查集应用场景"><a href="# 并查集应用场景" class="headerlink" title="并查集应用场景"></a>并查集应用场景 </h2><p> 并查集数据结构最常见的应用是跟踪无向图的连接组件。它还用于实现 Kruskal 算法的高效版本，以查找图的最小生成树。</p>
<p>关于并查集的应用，后面的学习中再做整理~</p>
<h2 id="并查集实现"><a href="# 并查集实现" class="headerlink" title="并查集实现"></a>并查集实现 </h2><p> 上面介绍了什么是并查集，并给出了并查集支持的一些操作。下面开始，逐步实现基于数组的并查集。</p>
<h3 id="初始化"><a href="# 初始化" class="headerlink" title="初始化"></a>初始化 </h3><p><strong> 并查集的实现可以使用数组来表示每个元素所属的集合</strong>，其中：</p>
<ul>
<li>数组的索引表示元素的值；</li>
<li>数组的值表示该元素所属的集合的代表元素。</li>
</ul>
<blockquote>
<p>一般用集合的根节点作为该集合的代表元素。</p>
</blockquote>
<p>初始时，每个元素都是独立的集合，它属于它自己（表示为一棵只有根节点的树），即每个元素的值和索引相同（将根节点的父亲设为自己）。</p>
<p>初始化时，就像这样，自己指向自己，树的高度为 0。<br><img src="/images/data-structure/UFDS-init.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化并查集</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> rank[], <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= size; ++i) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">        rank[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里 <code>rank[i]</code> 的值是以顶点 <code>i</code> 为根的子树高度的上限，它用作后面 <code>UnionSet(i, j)</code> 操作的引导启发式。先不用管 <code>rank[i]</code> 了，后面还会遇到。</p>
</blockquote>
<h3 id="查找"><a href="# 查找" class="headerlink" title="查找"></a>查找 </h3><p> 就像文章一开头说的那样，并查集的查找操作，是查找某个元素所属集合，通常是找到该元素所在集合的根节点。具体地，</p>
<ul>
<li>查找当前元素的父元素，若父元素不是自己，则更新它为当前元素，并查找它的父元素，直到当前元素的父元素是自己为止。</li>
</ul>
<h4 id="并查集查找（迭代实现）"><a href="# 并查集查找（迭代实现）" class="headerlink" title="并查集查找（迭代实现）"></a>并查集查找（迭代实现）</h4><p>朴素的并查集查找操作（迭代实现）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找元素所属的集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (parent[x] != x) &#123;</span><br><span class="line">        x = parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="并查集查找（递归实现）"><a href="# 并查集查找（递归实现）" class="headerlink" title="并查集查找（递归实现）"></a>并查集查找（递归实现）</h4><p>朴素的并查集查找操作（递归实现）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找元素所属的集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[x] == x) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findSet(parent, parent[x]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="并查集查找（带路径压缩的递归实现）"><a href="# 并查集查找（带路径压缩的递归实现）" class="headerlink" title="并查集查找（带路径压缩的递归实现）"></a>并查集查找（带路径压缩的递归实现）</h4><p>想一想，一个集合中的所有元素，虽然有共同的代表元素，但是这棵树可能呈现不同的形状。</p>
<p><img src="/images/data-structure/UFDS-same-set.png" alt=""></p>
<p>上面这张图中，左边与右边集合中的元素一致，且代表元素都是 1，<strong>但是树的形状不同</strong>。这样的话，对于同一个元素（比如 4），查找到其代表元素 1 的迭代（递归）次数是不一样的，左边需要 3 次才能完成，而右边只需要 1 次就能完成。</p>
<p>因此，<strong>为了提高效率，就需要尽可能降低迭代（递归）次数。这就需要进行「路径压缩」</strong>。</p>
<p>想一想，上面递归方式实现的查找操作 <code>findSet(int parent[], int x)</code> 中，是查找元素 <code>x</code> 的代表元素并返回。在这个函数内部，如果当前元素的父元素不是代表元素，函数会递归的查找其父元素的代表元素（我们被划分在同一个集合中了，假如我的代表元素是 R，那么我的父元素的代表元素也是 R 呀）。</p>
<p>因此，我们可以 <strong> 在递归的过程中，更新当前元素的代表元素，从而实现「路径压缩」</strong>，以加快后续查找。</p>
<p>并查集查找操作（带路径压缩的递归实现）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找元素所属的集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[x] == x) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 路径压缩</span></span><br><span class="line">        parent[x] = findSet(parent, parent[x]);</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="路径压缩查找示例"><a href="# 路径压缩查找示例" class="headerlink" title="路径压缩查找示例"></a>路径压缩查找示例 </h4><p> 假如，我们有如下的不相交集合：<br><img src="/images/data-structure/UFDS-demo1.png" alt=""></p>
<p>现在，我们使用带路径压缩的并查集查找函数，查找元素 1 的代表元素，这一过程可以可视化为下面的动画。<br><img src="/images/data-structure/UFDS-demo2.gif" alt=""></p>
<blockquote>
<p>图中 <code>r</code> 就是 <code>rank</code> 的缩写，<code>s</code> 代表的是元素的数量。</p>
</blockquote>
<h3 id="合并"><a href="# 合并" class="headerlink" title="合并"></a>合并 </h3><p> 要合并两棵树（集合），我们只需要将一棵树的根节点连到另一棵树的根节点。要完成这一操作，我们需要：</p>
<ol>
<li>查找一个元素 <code>x</code> 的代表元素；</li>
<li>查找另一个元素 <code>y</code> 的代表元素；</li>
<li>若两者的代表元素不同，则将其中一棵树的根节点连接到另一棵树的根节点上；若两者的代表元素相同，则无需合并。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 合并两个集合</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unionSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> rootX = findSet(parent, x);</span><br><span class="line">    <span class="type">int</span> rootY = findSet(parent, y);</span><br><span class="line">    <span class="comment">// 属于不同集合</span></span><br><span class="line">    <span class="keyword">if</span> (rootX != rootY) &#123;</span><br><span class="line">        <span class="comment">// 将前者所在的树的根节点连接到后者所在的树的根节点上</span></span><br><span class="line">        parent[rootX] = rootY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启发式合并"><a href="# 启发式合并" class="headerlink" title="启发式合并"></a>启发式合并 </h3><p> 合并时，选择哪棵树的根节点作为新树的根节点会影响未来操作的复杂度。我们可以 <strong> 将节点较少或深度（树高）较小的树连接到另一棵</strong>，以免发生退化。</p>
<blockquote>
<p>这样做的目的是尽量避免将较大的树作为子树合并到较小的树上，从而保持树的平衡，减小树的高度。</p>
<p>在并查集中，「退化」指的是树结构变得非常不平衡，即树的高度非常大，接近于线性结构（如链表）。</p>
</blockquote>
<p>因此，在 <a href="# 初始化"> 初始化小节 </a> 中，数组 <code>rank[i]</code> 就是用来维护以顶点 <code>i</code> 为根的子树高度的上限，它就是在这里被使用的啦。</p>
<h4 id="启发式合并（以树高为标准）"><a href="# 启发式合并（以树高为标准）" class="headerlink" title="启发式合并（以树高为标准）"></a>启发式合并（以树高为标准）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">unionSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> rank[], <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> rootX = findSet(parent, x);</span><br><span class="line">    <span class="type">int</span> rootY = findSet(parent, y);</span><br><span class="line">    <span class="comment">// 属于不同集合</span></span><br><span class="line">    <span class="keyword">if</span> (rootX != rootY) &#123;</span><br><span class="line">        <span class="comment">// 将深度较小的树连到另一棵树</span></span><br><span class="line">        <span class="keyword">if</span> (rank[rootX] &lt; rank[rootY]) &#123;</span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootX] &gt; rank[rootY]) &#123;</span><br><span class="line">            parent[rootY] = rootX;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将前者所在的树的根节点连接到后者所在的树的根节点上</span></span><br><span class="line">            <span class="comment">// 被连接的树的高度将会加一, 对应的 rank 值加一</span></span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">            rank[rootY]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <a href="# 初始化"> 初始化 </a> 时，每个元素都是一个独立的集合，每个树的高度都为 0：</p>
<ul>
<li>在进行第一次集合合并时（比如元素 1 和元素 3），则 <code>unionSet(parent, rank, 1, 3)</code> 操作，会合并为一棵 <code>3-&gt;1</code> 的树，其中 3 为根节点，这棵新树会长高一个单位；</li>
<li>在进行第二次集合合并时（比如元素 1 和元素 4），则 <code>unionSet(parent, rank, 1, 4)</code> 操作，会合并为一棵 <code>4&lt;-3-&gt;1</code> 的树，其中 3 为根节点，由于 1 所在的树高大于 4 所在的树高，因此在合并后，树高不会变得更高，因此不会更新 <code>rank</code> 值。</li>
</ul>
<blockquote>
<p><strong>注意：在启发式合并的过程中，只能保证根节点对应 <code>rank</code> 值是正确的，不能保证其它位置的 <code>rank</code> 值的正确性</strong>。</p>
</blockquote>
<h4 id="启发式合并示例"><a href="# 启发式合并示例" class="headerlink" title="启发式合并示例"></a>启发式合并示例 </h4><p> 假如，我们有如下几个不相交集合：<br><img src="/images/data-structure/UFDS-demo3.png" alt=""></p>
<p>现在，我们使用以树高为标准的启发式合并，执行 <code>unionSet(parent, rank, 10, 8)</code>，这一过程可以可视化为下面的动画。<br><img src="/images/data-structure/UFDS-demo4.gif" alt=""></p>
<p>这里 <code>x = 10, y = 8</code> 与 <code>x = 8, y = 10</code> 执行后，得到的树是不一样的哦。</p>
<blockquote>
<p>你可能已经发现了：在执行合并的过程中，树也会被路径压缩，这是因为并查集的合并接口调用了查找接口。</p>
</blockquote>
<h3 id="相同集合"><a href="# 相同集合" class="headerlink" title="相同集合"></a>相同集合 </h3><p> 判断两个元素是否属于同一集合。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isSameSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> findSet(parent, x) == findSet(parent, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并查集复杂度"><a href="# 并查集复杂度" class="headerlink" title="并查集复杂度"></a>并查集复杂度 </h2><p> 时间复杂度：</p>
<ul>
<li>初始化：<code>O(n)</code></li>
<li>朴素查找：<code>O(n)</code></li>
<li>带路径压缩的查找：<code>O(h)</code>，可以优化至 <code>O(α(n))</code>，其中 <code>h</code> 是树的高度，足够平衡时 <code>h = log(n)</code>，<code>α</code> 是阿克曼函数</li>
<li>带路径压缩的合并：<code>O(h)</code>，可以优化至 <code>O(α(n))</code></li>
</ul>
<p>空间复杂度：<code>O(n)</code></p>
<blockquote>
<p>这里的并查集数据结构的实现，是采用的 Quick Union 方式，而不是 Quick Find 方式。</p>
</blockquote>
<h2 id="并查集完整代码测试"><a href="# 并查集完整代码测试" class="headerlink" title="并查集完整代码测试"></a>并查集完整代码测试 </h2><h3 id="完整代码"><a href="# 完整代码" class="headerlink" title="完整代码"></a> 完整代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> rank[], <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= size; ++i) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">        rank[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[x] == x) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 路径压缩</span></span><br><span class="line">        parent[x] = findSet(parent, parent[x]);</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unionSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> rank[], <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> rootX = findSet(parent, x);</span><br><span class="line">    <span class="type">int</span> rootY = findSet(parent, y);</span><br><span class="line">    <span class="comment">// 属于不同集合</span></span><br><span class="line">    <span class="keyword">if</span> (rootX != rootY) &#123;</span><br><span class="line">        <span class="comment">// 将深度较小的树连到另一棵树</span></span><br><span class="line">        <span class="keyword">if</span> (rank[rootX] &lt; rank[rootY]) &#123;</span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootX] &gt; rank[rootY]) &#123;</span><br><span class="line">            parent[rootY] = rootX;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将前者所在的树的根节点连接到后者所在的树的根节点上</span></span><br><span class="line">            <span class="comment">// 被连接的树的高度将会加一, 对应的 rank 值加一</span></span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">            rank[rootY]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isSameSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> findSet(parent, x) == findSet(parent, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试代码"><a href="# 测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE (101)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> rank[], <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">findSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unionSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> rank[], <span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">isSameSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> parent[MAX_SIZE];</span><br><span class="line">    <span class="type">int</span> rank[MAX_SIZE];</span><br><span class="line">    <span class="type">int</span> size = <span class="number">10</span>; <span class="comment">// 假设有 10 个元素，从 1 到 10 编号</span></span><br><span class="line"></span><br><span class="line">    init(parent, rank, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 findSet 函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(1): %d\n&quot;</span>, findSet(parent, <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(2): %d\n&quot;</span>, findSet(parent, <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(3): %d\n&quot;</span>, findSet(parent, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 unionSet 函数</span></span><br><span class="line">    unionSet(parent, rank, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    unionSet(parent, rank, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    unionSet(parent, rank, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    unionSet(parent, rank, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">    unionSet(parent, rank, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(1): %d\n&quot;</span>, findSet(parent, <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(2): %d\n&quot;</span>, findSet(parent, <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(3): %d\n&quot;</span>, findSet(parent, <span class="number">3</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(4): %d\n&quot;</span>, findSet(parent, <span class="number">4</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(5): %d\n&quot;</span>, findSet(parent, <span class="number">5</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(6): %d\n&quot;</span>, findSet(parent, <span class="number">6</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(7): %d\n&quot;</span>, findSet(parent, <span class="number">7</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(8): %d\n&quot;</span>, findSet(parent, <span class="number">8</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(9): %d\n&quot;</span>, findSet(parent, <span class="number">9</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(10): %d\n&quot;</span>, findSet(parent, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    unionSet(parent, rank, <span class="number">7</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(7): %d\n&quot;</span>, findSet(parent, <span class="number">7</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(9): %d\n&quot;</span>, findSet(parent, <span class="number">9</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 isSameSet 函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;isSameSet(1, 2): %d\n&quot;</span>, isSameSet(parent, <span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;isSameSet(3, 4): %d\n&quot;</span>, isSameSet(parent, <span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;isSameSet(2, 4): %d\n&quot;</span>, isSameSet(parent, <span class="number">2</span>, <span class="number">4</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;isSameSet(7, 10): %d\n&quot;</span>, isSameSet(parent, <span class="number">7</span>, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试结果"><a href="# 测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">findSet(1): 1</span><br><span class="line">findSet(2): 2</span><br><span class="line">findSet(3): 3</span><br><span class="line">findSet(1): 2</span><br><span class="line">findSet(2): 2</span><br><span class="line">findSet(3): 4</span><br><span class="line">findSet(4): 4</span><br><span class="line">findSet(5): 6</span><br><span class="line">findSet(6): 6</span><br><span class="line">findSet(7): 8</span><br><span class="line">findSet(8): 8</span><br><span class="line">findSet(9): 10</span><br><span class="line">findSet(10): 10</span><br><span class="line">findSet(7): 10</span><br><span class="line">findSet(9): 10</span><br><span class="line">isSameSet(1, 2): 1</span><br><span class="line">isSameSet(3, 4): 1</span><br><span class="line">isSameSet(2, 4): 0</span><br><span class="line">isSameSet(7, 10): 1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://visualgo.net/en/ufds">https://visualgo.net/en/ufds</a></li>
<li><a href="https://oi-wiki.org/ds/dsu">https://oi-wiki.org/ds/dsu</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>Disjoint-Set</tag>
        <tag>Union-Find</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之队列（链表实现）</title>
    <url>/posts/231017105123.html</url>
    <content><![CDATA[<p>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，在表的后端（rear）进行插入操作。与堆栈一样，队列也是一种操作受限制的线性表，进行插入操作的端称为队尾，进行删除操作的端称为队头。数据的入队和出队遵循先进先出（FIFO, First-In First-Out）的原则。</p>
<span id="more"></span>

<p>这篇文章主要介绍通过链表实现队列，但会首先介绍一下队列的几种实现方式和各自的特点、适用场景。</p>
<h2 id="队列的实现方式"><a href="# 队列的实现方式" class="headerlink" title="队列的实现方式"></a>队列的实现方式 </h2><p> 在 C 语言中，FIFO 队列的实现方式有以下几种：</p>
<ol>
<li><p>数组实现：使用一个固定大小的数组作为队列的存储空间，使用两个指针 front 和 rear 分别指向队列的头部和尾部，通过不断移动指针和调整数组元素的位置来实现入队和出队操作。</p>
</li>
<li><p>链表实现：使用链表作为队列的存储结构，通过定义一个链表节点结构体来存储队列元素的值和指向下一个节点的指针。通过调整链表节点的指针关系来实现入队和出队操作。</p>
</li>
<li><p>循环队列实现：使用一个固定大小的数组作为队列的存储空间，同时使用两个指针 front 和 rear 分别指向队列的头部和尾部。当 rear 指针到达数组末尾时，再次从数组头部开始存储元素，实现循环利用数组空间的效果。</p>
</li>
</ol>
<h2 id="不同实现方式适用的场景"><a href="# 不同实现方式适用的场景" class="headerlink" title="不同实现方式适用的场景"></a>不同实现方式适用的场景 </h2><p> 数组实现队列、链表实现队列和循环队列实现，都有各自的特点和适用场景，以下是不同实现方式的一些适用场景：</p>
<ol>
<li><p>数组实现适用于以下场景：</p>
<ul>
<li>队列大小固定，不需要频繁进行大小调整。</li>
<li>元素个数相对较少，不会造成数组空间的浪费。</li>
<li>需要快速随机访问队列元素。</li>
</ul>
</li>
<li><p>链表实现适用于以下场景：</p>
<ul>
<li>队列大小不确定，会频繁进行大小调整。</li>
<li>元素个数可能非常大，链表能够动态分配内存。</li>
<li>需要频繁进行插入和删除操作。</li>
</ul>
</li>
<li><p>循环队列实现适用于以下场景：</p>
<ul>
<li>队列大小固定，不需要频繁进行大小调整。</li>
<li>队列元素个数可能会超过数组大小，但是可以接受覆盖旧元素的方式。</li>
<li>需要快速入队和出队操作。</li>
</ul>
</li>
</ol>
<p>根据实际需求和对性能的要求，可以选择适合的实现方式。例如，如果队列大小固定且元素个数不会超过数组大小，可以选择数组实现；如果队列大小不确定且需要频繁进行插入和删除操作，可以选择链表实现；如果队列大小固定但元素个数可能超过数组大小且需要快速入队和出队操作，可以选择循环队列实现。</p>
<h2 id="链表实现队列"><a href="# 链表实现队列" class="headerlink" title="链表实现队列"></a>链表实现队列 </h2><h3 id="定义基于链表的队列结构"><a href="# 定义基于链表的队列结构" class="headerlink" title="定义基于链表的队列结构"></a> 定义基于链表的队列结构 </h3><p><strong> 为了体现队列中数据的复杂性</strong>，这里不再使用基本数据类型（如整形、字符型）作为队列中的数据，而是使用了二叉树结构，即在队列中保存的数据是一个二叉树节点，节点中包含节点值、节点的左子树指针和节点的右子树指针。</p>
<p>首先，定义二叉树的结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode_t;</span><br></pre></td></tr></table></figure>

<p>然后，定义链表的结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Define the structure for a node in the queue</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    TreeNode_t *data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node_t;</span><br></pre></td></tr></table></figure>

<p>在这里，链表中的成员就是：用于存储二叉树节点数据的结构体和指向下一个链表节点的指针。</p>
<p>最后，定义队列的结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Define the structure for the queue</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">queue</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    Node_t *front;</span><br><span class="line">    Node_t *rear;</span><br><span class="line">&#125; Queue_t;</span><br></pre></td></tr></table></figure>

<p>在这里，队列中的成员就是：队头指针和队尾指针，以及一个记录队列中数据数量的成员变量和一个标记队列可以容纳的最大数据量的成员变量。</p>
<h3 id="队列的创建与初始化"><a href="# 队列的创建与初始化" class="headerlink" title="队列的创建与初始化"></a>队列的创建与初始化 </h3><p> 首先，创建一个空队列（队列中还没有存储数据），并初始化成员变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function to create an empty queue</span></span><br><span class="line">Queue_t *<span class="title function_">createQueue</span><span class="params">(<span class="type">int</span> max_size)</span> &#123;</span><br><span class="line">    Queue_t *<span class="built_in">queue</span> = (Queue_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue_t));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;max = max_size;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，对于空队列，后续入队操作会有数据存储到队列中，数据需要必要的存储空间来存储。在这里，我们创建并初始化一段空间用于存储数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function to create a new node</span></span><br><span class="line">Node_t *<span class="title function_">createNode</span><span class="params">(TreeNode_t *data)</span> &#123;</span><br><span class="line">    Node_t *newNode = (Node_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node_t));</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断队列是否为空"><a href="# 判断队列是否为空" class="headerlink" title="判断队列是否为空"></a>判断队列是否为空</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function to check if the queue is empty</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Queue_t *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，也可以使用 <code>(!queue-&gt;front) &amp;&amp; (queue-&gt;front == queue-&gt;rear)</code> 判断队列是否为空。 </p>
<h3 id="判断队列是否已满"><a href="# 判断队列是否已满" class="headerlink" title="判断队列是否已满"></a>判断队列是否已满</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function to check if the queue is full</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Queue_t *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;size &gt;= <span class="built_in">queue</span>-&gt;max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="入队操作"><a href="# 入队操作" class="headerlink" title="入队操作"></a>入队操作 </h3><p> 入队操作，即在队列的尾部插入一个数据。</p>
<ul>
<li>如果队列已满，则无法继续执行入队操作；</li>
<li>如果队列为空，则队列的头指针（front）和尾指针（rear）都指向新插入的数据的存放地址；</li>
<li>否则，链接并更新队列的尾指针（rear）为新插入的数据的存放地址。</li>
</ul>
<p>入队操作后需要更新队列的大小。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function to enqueue an element into the queue</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enQueue</span><span class="params">(Queue_t *<span class="built_in">queue</span>, TreeNode_t *data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;queue is full.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node_t *newNode = createNode(data);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">            <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">queue</span>-&gt;rear-&gt;next = newNode;  <span class="comment">// 尾指针链接新数据</span></span><br><span class="line">            <span class="built_in">queue</span>-&gt;rear = newNode;  <span class="comment">// 尾指针指向新数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;size += <span class="number">1</span>;  <span class="comment">// 更新队列大小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="出队操作"><a href="# 出队操作" class="headerlink" title="出队操作"></a>出队操作 </h3><p> 出队操作，即在队列的头部删除一个数据。出队操作需要依次执行以下操作：</p>
<ol>
<li>获取头指针地址 &amp; 数据；</li>
<li>更新队列头指针；</li>
<li>更新队列大小；</li>
<li>释放原头指针内存空间；</li>
<li>返回数据。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function to dequeue an element from the queue</span></span><br><span class="line">TreeNode_t *<span class="title function_">deQueue</span><span class="params">(Queue_t* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node_t *node = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">    TreeNode_t *data = node-&gt;data;</span><br><span class="line">    <span class="comment">// 根据当前队列中节点的数量，决定是否同步更新队列的尾指针</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;front-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips：出队操作在在更新队列头指针时，需要根据当前队列中节点的数量，决定是否同步更新队列的尾指针。</p>
</blockquote>
<blockquote>
<p>释放 <code>node</code> 内存空间后，不会造成 <code>data</code> 数据无法访问吗？<br>不会。这是因为，在释放节点之前，我们先将数据指针 <code>node-&gt;data</code> 保存到一个新的变量 <code>data</code> 中，然后释放节点，最后返回保存的数据指针。这样可以确保返回的数据指针依然有效。</p>
</blockquote>
<h3 id="打印队列数据"><a href="# 打印队列数据" class="headerlink" title="打印队列数据"></a>打印队列数据</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function to print all elements from the queue</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(Queue_t* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Queue is empty\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Queue: &quot;</span>);</span><br><span class="line">        Node_t *node = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;data-&gt;val);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="释放队列"><a href="# 释放队列" class="headerlink" title="释放队列"></a>释放队列</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function to free all memory from the queue</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeQueue</span><span class="params">(Queue_t* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span> &amp;&amp;(!isEmpty(<span class="built_in">queue</span>)))&#123;</span><br><span class="line">        Node_t *node = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Node_t *tmp = node-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(node);</span><br><span class="line">            node = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放队列内存空间时，需要依次释放队列中的每一个节点的空间，最后再释放队列结构本身的数据空间。</p>
<h2 id="链表实现队列完整代码"><a href="# 链表实现队列完整代码" class="headerlink" title="链表实现队列完整代码"></a>链表实现队列完整代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    TreeNode_t *data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">queue</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    Node_t *front;</span><br><span class="line">    Node_t *rear;</span><br><span class="line">&#125; Queue_t;</span><br><span class="line"></span><br><span class="line">Queue_t *<span class="title function_">createQueue</span><span class="params">(<span class="type">int</span> max_size)</span> &#123;</span><br><span class="line">    Queue_t *<span class="built_in">queue</span> = (Queue_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue_t));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;max = max_size;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node_t *<span class="title function_">createNode</span><span class="params">(TreeNode_t *data)</span> &#123;</span><br><span class="line">    Node_t *newNode = (Node_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node_t));</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Queue_t *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Queue_t *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;size &gt;= <span class="built_in">queue</span>-&gt;max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enQueue</span><span class="params">(Queue_t *<span class="built_in">queue</span>, TreeNode_t *data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;queue is full.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node_t *newNode = createNode(data);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">            <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">queue</span>-&gt;rear-&gt;next = newNode;  <span class="comment">// 尾指针链接新数据</span></span><br><span class="line">            <span class="built_in">queue</span>-&gt;rear = newNode;  <span class="comment">// 尾指针指向新数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;size += <span class="number">1</span>;  <span class="comment">// 更新队列大小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode_t *<span class="title function_">deQueue</span><span class="params">(Queue_t* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node_t *node = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">    TreeNode_t *data = node-&gt;data;</span><br><span class="line">    <span class="comment">// 根据当前队列中节点的数量，决定是否同步更新队列的尾指针</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;front-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(Queue_t* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Queue is empty\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Queue: &quot;</span>);</span><br><span class="line">        Node_t *node = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;data-&gt;val);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeQueue</span><span class="params">(Queue_t* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span> &amp;&amp;(!isEmpty(<span class="built_in">queue</span>)))&#123;</span><br><span class="line">        Node_t *node = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Node_t *tmp = node-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(node);</span><br><span class="line">            node = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    Queue_t *<span class="built_in">queue</span> = createQueue(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一些测试用的树节点</span></span><br><span class="line">    TreeNode_t *node = (TreeNode_t *)<span class="built_in">malloc</span>(<span class="number">4</span> * <span class="keyword">sizeof</span>(TreeNode_t));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        node[i].val = <span class="number">10</span> + i;</span><br><span class="line">        node[i].left = <span class="literal">NULL</span>;</span><br><span class="line">        node[i].right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printQueue(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    enQueue(<span class="built_in">queue</span>, &amp;node[<span class="number">0</span>]);</span><br><span class="line">    enQueue(<span class="built_in">queue</span>, &amp;node[<span class="number">1</span>]);</span><br><span class="line">    enQueue(<span class="built_in">queue</span>, &amp;node[<span class="number">2</span>]);</span><br><span class="line">    printQueue(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    enQueue(<span class="built_in">queue</span>, &amp;node[<span class="number">3</span>]);</span><br><span class="line">    printQueue(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    TreeNode_t *data1 = deQueue(<span class="built_in">queue</span>);</span><br><span class="line">    TreeNode_t *data2 = deQueue(<span class="built_in">queue</span>);</span><br><span class="line">    TreeNode_t *data3 = deQueue(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Dequeued data: %d %d %d\n&quot;</span>, data1-&gt;val, data2-&gt;val, data3-&gt;val); <span class="comment">// 实际工程中要先判非空再取数据</span></span><br><span class="line">    printQueue(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    freeQueue(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放测试用的树节点内存</span></span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Queue is empty</span><br><span class="line">Queue: 10 11 12</span><br><span class="line">queue is full.</span><br><span class="line">Queue: 10 11 12</span><br><span class="line">Dequeued data: 10 11 12</span><br><span class="line">Queue is empty</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>队列</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法之堆排序</title>
    <url>/posts/231107171607.html</url>
    <content><![CDATA[<p>堆排序是一种基于二叉堆数据结构的排序算法。它的主要思想是将待排序的序列构建成一个大顶堆（或小顶堆），然后 <strong> 依次取出堆顶元素，将其与堆中最后一个元素交换，并调整堆，使得剩余元素仍满足堆的性质</strong>。重复这个过程，直到堆中只剩下一个待调整元素，即可得到一个有序序列。</p>
<p>上面说，大顶堆依次将堆顶（当前最大）元素与堆中最后一个元素交换。因此，基于大顶堆的堆排序后的结果是一个升序序列，基于小顶堆的堆排序后的结果是一个降序序列。</p>
<span id="more"></span>

<blockquote>
<p>上面调整堆的堆化过程，是将「剩余的元素」重新构造成一个堆（通过交换的方式放在堆尾的元素不再参与堆化调整）。</p>
</blockquote>
<h2 id="堆排序步骤"><a href="# 堆排序步骤" class="headerlink" title="堆排序步骤"></a>堆排序步骤 </h2><p> 按文章开头的描述，堆排序的过程可以分为两个主要步骤：<strong>构建堆和调整堆</strong>。下面以大顶堆的堆排序来进行描述。</p>
<ol>
<li><p>构建堆：<br>首先，将待排序的序列构建成一个初始堆。可以 <strong> 从最后一个非叶子节点开始，依次向前遍历 </strong>，对每个节点进行调整，使得该节点的值大于其子节点的值。这个过程称为堆化，可以使用<strong> 下沉操作 </strong> 来实现。</p>
</li>
<li><p>调整堆：<br>将堆顶元素与堆中最后一个元素交换位置，<strong>并将堆的大小减一 </strong>。然后对堆顶元素进行<strong> 下沉操作</strong>，使得剩余元素仍满足堆的性质。重复这个过程，直到堆中只剩下一个元素，即可得到一个有序序列。</p>
</li>
</ol>
<p>堆排序在实际应用中具有较高的效率和稳定性，尤其适用于大规模数据的排序。</p>
<blockquote>
<p>堆化的两个主要操作是下沉（弹出堆顶元素时使用）和上浮（往堆中添加新元素时使用）操作，可以参考 <a href="https://pursue26.github.io/posts/231018102559.html"> 数据结构之堆基础与堆结构（数组实现）</a>。</p>
</blockquote>
<h2 id="堆排序复杂度"><a href="# 堆排序复杂度" class="headerlink" title="堆排序复杂度"></a>堆排序复杂度 </h2><p> 堆排序的时间复杂度为 <code>O(nlogn)</code>，其中 <code>n</code> 是待排序序列的长度。由于堆排序只需要常数的辅助空间，因此它是一种原地排序算法，空间复杂度为 <code>O(1)</code>。但 <strong> 堆排序是不稳定的排序算法，即相同元素的顺序可能会发生改变</strong>。</p>
<h2 id="堆排序实现"><a href="# 堆排序实现" class="headerlink" title="堆排序实现"></a>堆排序实现 </h2><h3 id="从无序序列构建堆"><a href="# 从无序序列构建堆" class="headerlink" title="从无序序列构建堆"></a> 从无序序列构建堆 </h3><p> 对于给定的长度为 $n$ 的无序序列进行堆排序的第一个过程是：构建堆——将无序序列构建成一个二叉堆数据结构。</p>
<p>上面说「从最后一个非叶子节点开始，依次向前遍历」，最后一个非叶子节点的数组索引（从 $0$ 开始）为 $n/2 - 1$。</p>
<p>为了完成从无序序列构建堆的这一过程。我们首先给出堆化中的下沉操作。<strong>假设，我们现在已经有一个满足堆属性的数组，当我们修改了数组某一个索引位置的值时，就需要重新对这个位置，以及之前的所有位置都进行堆化调整</strong>。</p>
<p>例如，对于下面的大顶堆：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    60</span><br><span class="line">   /  \</span><br><span class="line">  30  40</span><br><span class="line"> / \</span><br><span class="line">25 28</span><br></pre></td></tr></table></figure>

<p>如果把索引 1 位置的值 30 修改为 70，那么索引 1 和 索引 0 都需要进行堆化调整。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 调整索引 1 位置</span><br><span class="line">        60</span><br><span class="line">       /  \</span><br><span class="line">      70  40</span><br><span class="line">     / \</span><br><span class="line">    25 28</span><br><span class="line"></span><br><span class="line">// 调整索引 0 位置</span><br><span class="line">        70</span><br><span class="line">       /  \</span><br><span class="line">      60  40</span><br><span class="line">     / \</span><br><span class="line">    25 28</span><br></pre></td></tr></table></figure>

<p>如果把索引 1 位置的值 30 修改为 15，那么索引 1 和 索引 0 也都需要进行堆化调整。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 调整索引 1 位置</span><br><span class="line">        60</span><br><span class="line">       /  \</span><br><span class="line">      28  40</span><br><span class="line">     / \</span><br><span class="line">    25 15</span><br><span class="line"></span><br><span class="line">// 调整索引 0 位置（满足堆属性，随即退出）</span><br><span class="line">        60</span><br><span class="line">       /  \</span><br><span class="line">      28  40</span><br><span class="line">     / \</span><br><span class="line">    25 15</span><br></pre></td></tr></table></figure>

<p>对于给定的长度为 <code>n</code> 的数组（满足堆属性），当修改了索引 <code>i</code> 位置的值时，堆化调整以索引 <code>i</code> 为根节点的子树，使这棵以索引 <code>i</code> 为根节点的树重新满足堆属性（但不再能保证整个数组满足堆属性，若需要整棵树都满足堆属性，还需要按顺序对以索引 <code>i-1</code> 到以索引 <code>0</code>为根的子树进行堆化调整）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下沉操作，使以索引 i 为根节点的子树满足堆属性</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="type">int</span> largest = i;  <span class="comment">// 初始化根节点为最大值</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;  <span class="comment">// 左子节点</span></span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;  <span class="comment">// 右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子节点大于根节点，则更新最大值</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果右子节点大于根节点，则更新最大值</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果最大值不是根节点，则进行交换，并递归调整子堆</span></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="type">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[largest];</span><br><span class="line">        arr[largest] = temp;</span><br><span class="line"></span><br><span class="line">        heapify(arr, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在开始从最后一个非叶子节点，依次向前遍历进行下沉堆化。每遍历一个节点，都会使得以这个节点为根节点的树满足堆属性，那么当遍历完索引为 <code>0</code> 的位置后，整个数组将满足堆属性，构成一棵二叉堆。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建堆（从最后一个非叶子节点开始，依次向前遍历进行下沉堆化）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    heapify(arr, n, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调整堆"><a href="# 调整堆" class="headerlink" title="调整堆"></a>调整堆 </h3><p> 将堆顶元素与堆中最后一个元素交换位置，<strong>并将堆的大小减一 </strong>。然后对堆顶元素进行<strong> 下沉操作</strong>，使得剩余元素仍满足堆的性质。重复这个过程，直到堆中只剩下一个元素，即可得到一个有序序列。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 依次取出堆顶元素，并调整这个更小的堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="type">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">    arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">    arr[i] = temp;</span><br><span class="line">    heapify(arr, i, <span class="number">0</span>);  <span class="comment">// 将堆的大小减小为 i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆排序完整代码"><a href="# 堆排序完整代码" class="headerlink" title="堆排序完整代码"></a>堆排序完整代码 </h2><h3 id="堆排序代码"><a href="# 堆排序代码" class="headerlink" title="堆排序代码"></a> 堆排序代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> i)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(arr, n, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">        heapify(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序测试代码"><a href="# 堆排序测试代码" class="headerlink" title="堆排序测试代码"></a>堆排序测试代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> i)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 原始数组：&quot;</span>);</span><br><span class="line">    printArray(arr, n);</span><br><span class="line"></span><br><span class="line">    heapSort(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 排序后数组：&quot;</span>);</span><br><span class="line">    printArray(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试结果"><a href="# 测试结果" class="headerlink" title="测试结果"></a>测试结果 </h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 原始数组：12 11 13 5 6 7</span><br><span class="line">排序后数组：5 6 7 11 12 13</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>堆排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法之快速排序</title>
    <url>/posts/231108163339.html</url>
    <content><![CDATA[<p>快速排序是一种常用的排序算法，它基于分治的思想，通过将数组划分为较小的子数组，然后递归地排序这些子数组来达到排序整个数组的目的。</p>
<p>快速排序的基本思想是从数组中选择一个基准元素，然后通过一趟排序将数组分成两部分，以基准元素为轴，使得左边的元素都小于等于基准元素，右边的元素都大于基准元素。然后对这两部分分别进行递归排序，最终将整个数组排序。</p>
<span id="more"></span>

<h2 id="快速排序步骤"><a href="# 快速排序步骤" class="headerlink" title="快速排序步骤"></a>快速排序步骤 </h2><p> 快速排序具体步骤如下：</p>
<ol>
<li>选择一个基准元素 <code>pivot</code>，可以是数组的第一个元素或最后一个元素；</li>
<li>设置两个指针，一个指向数组的起始位置 <code>left</code>，一个指向数组的结束位置 <code>right</code>；</li>
<li>从 <code>left</code> 指针开始向右遍历，找到下一个大于 <code>pivot</code> 的元素，记其索引为 <code>i</code>；</li>
<li>从 <code>right</code> 指针开始向左遍历，找到下一个小于等于 <code>pivot</code> 的元素，记其索引为 <code>j</code>；</li>
<li>如果 <code>i&lt;j</code>，交换 <code>i</code> 和 <code>j</code> 处的元素；</li>
<li>重复步骤 3-5，直到 <code>left</code> 指针和 <code>right</code> 指针相遇；</li>
<li>将基准元素 <code>pivot</code> 与指针相遇处的元素交换。</li>
<li>递归地对基准元素左边的子数组和右边的子数组进行快速排序。</li>
</ol>
<h2 id="快速排序复杂度"><a href="# 快速排序复杂度" class="headerlink" title="快速排序复杂度"></a>快速排序复杂度 </h2><p> 快速排序的时间复杂度为 $O(n \times logn)$，其中 $n$ 为数组的长度。它是一种 <strong> 原地排序算法，不需要额外的存储空间</strong>，但是在最坏情况下可能会出现时间复杂度为 $O(n^2)$ 的情况，需要进行优化。</p>
<h2 id="快速排序实现"><a href="# 快速排序实现" class="headerlink" title="快速排序实现"></a>快速排序实现 </h2><h3 id="交换两个元素"><a href="# 交换两个元素" class="headerlink" title="交换两个元素"></a> 交换两个元素</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="划分数组为两部分"><a href="# 划分数组为两部分" class="headerlink" title="划分数组为两部分"></a>划分数组为两部分 </h3><p> 通过一趟排序将数组分成两部分，以基准元素为轴，使得左边的元素都小于等于基准元素，右边的元素都大于基准元素，最后返回基准元素在数组中的索引。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[left];</span><br><span class="line">    <span class="type">int</span> i = left + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到下一个大于 pivot 的元素</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j &amp;&amp; arr[i] &lt;= pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到下一个小于等于 pivot 的元素</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= i &amp;&amp; arr[j] &gt; pivot) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不是在对方遍历过的区间找到的, 就交换并自增自减指针</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            swap(&amp;arr[i++], &amp;arr[j--]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(&amp;arr[left], &amp;arr[j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的倒数第二行代码中，为什么基准元素是与索引为 <code>j</code> 的元素进行交换呢？</p>
<p>这是因为，我们选择了区间 $[left, right]$ 的 <strong> 左边界 </strong> 的元素作为了基准元素。划分后，<strong>左边都是小于等于基准元素的元素</strong>，而索引 <code>j</code> 右边都是大于基准元素的元素，所以基准元素是与索引为 <code>j</code> 的元素进行交换。</p>
<p>同样地，如果我们选择区间 $[left, right]$ 右边界的元素作为了基准元素，那么代码就该这样写了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> pivot = arr[right];</span><br><span class="line"><span class="type">int</span> i = left;</span><br><span class="line"><span class="type">int</span> j = right - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">swap(&amp;arr[right], &amp;arr[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> i;</span><br></pre></td></tr></table></figure>

<h3 id="递归实现快速排序"><a href="# 递归实现快速排序" class="headerlink" title="递归实现快速排序"></a>递归实现快速排序 </h3><p> 递归地对基准元素左边的子数组和右边的子数组进行快速排序。快速排序接口的入参为 <code>left=0</code> 和 <code>right=n-1</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> pivot = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, pivot - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, pivot + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速排序完整代码"><a href="# 快速排序完整代码" class="headerlink" title="快速排序完整代码"></a>快速排序完整代码 </h2><h3 id="快速排序代码"><a href="# 快速排序代码" class="headerlink" title="快速排序代码"></a> 快速排序代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[left];</span><br><span class="line">    <span class="type">int</span> i = left + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到下一个大于 pivot 的元素</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j &amp;&amp; arr[i] &lt;= pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到下一个小于等于 pivot 的元素</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= i &amp;&amp; arr[j] &gt; pivot) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不是在对方遍历过的区间找到的, 就交换并自增自减指针</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            swap(&amp;arr[i++], &amp;arr[j--]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(&amp;arr[left], &amp;arr[j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> pivot = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, pivot - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, pivot + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序测试代码"><a href="# 快速排序测试代码" class="headerlink" title="快速排序测试代码"></a>快速排序测试代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 原始数组：&quot;</span>);</span><br><span class="line">    printArray(arr, n);</span><br><span class="line"></span><br><span class="line">    quickSort(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 排序后数组：&quot;</span>);</span><br><span class="line">    printArray(arr, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试结果"><a href="# 测试结果" class="headerlink" title="测试结果"></a>测试结果 </h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 原始数组：3 1 4 1 5 9 2 6 5 3 5</span><br><span class="line">排序后数组：1 1 2 3 3 4 5 5 5 6 9</span><br></pre></td></tr></table></figure>

<h2 id="进阶 1：基准元素的选择"><a href="# 进阶 1：基准元素的选择" class="headerlink" title="进阶 1：基准元素的选择"></a>进阶 1：基准元素的选择 </h2><h3 id="首尾基准元素"><a href="# 首尾基准元素" class="headerlink" title="首尾基准元素"></a> 首尾基准元素 </h3><p> 上文说，基准元素可以是「数组的第一个元素或最后一个元素」，这其实是非常不可取的，<strong>在某些情况下可能导致最差的性能</strong>。因为：</p>
<ol>
<li>假如，初始数组就已经是一个升序数组：我们每次都选择第一元素作为基准元素，那么右指针 <code>j</code> 会向左遍历整个数组，但不会进行任何交换操作。这一轮划分操作的时间复杂度为 <code>O(n)</code>，整个排序过程的时间复杂度为 <code>O(n^2)</code>。</li>
<li>同样地，初始数组就已经是一个降序数组：我们每次都选择最后一个元素作为基准元素，那么左指针 <code>i</code> 会向右遍历整个数组，但不会进行任何交换操作。这一轮划分操作的时间复杂度为 <code>O(n)</code>，整个排序过程的时间复杂度为 <code>O(n^2)</code>。</li>
</ol>
<h3 id="随机基准元素"><a href="# 随机基准元素" class="headerlink" title="随机基准元素"></a>随机基准元素 </h3><p> 随机基准元素，避免了上述问题，可谓是一种再好不过的基准元素的选择办法。但是，<strong>随机数的产生是有时间成本的，不一定会使得快速排序的更快</strong>。</p>
<h3 id="三数中值基准元素"><a href="# 三数中值基准元素" class="headerlink" title="三数中值基准元素"></a>三数中值基准元素 </h3><p><strong> 三数中值是一种常用的基准元素选择方式 </strong>。它通过比较数组的第一个、中间和最后一个元素，<strong> 选择它们的中位数作为基准元素</strong>。这种方式可以在一定程度上避免最差情况的发生，并提高算法的性能。</p>
<p>如何选出三数的中位数在数组中的对应索引呢？多轮比较！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getMedianIdx</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> min = (arr[left] &lt; arr[mid]) ? left : mid;</span><br><span class="line">    min = (arr[min] &lt; arr[right]) ? min : right;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max = (arr[left] &gt; arr[mid]) ? left : mid;</span><br><span class="line">    max = (arr[max] &gt; arr[right]) ? max : right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (min == left) &#123;</span><br><span class="line">        <span class="keyword">return</span> max == right ? mid : right;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (min == right) &#123;</span><br><span class="line">        <span class="keyword">return</span> max == left ? mid : left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> max == right ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进阶 2：何时停止进行交换"><a href="# 进阶 2：何时停止进行交换" class="headerlink" title="进阶 2：何时停止进行交换"></a>进阶 2：何时停止进行交换 </h2><p> 上文的划分代码中，当左指针等于基准元素的时候并没有停止（<code>while (i &lt;= j &amp;&amp; arr[i] &lt;= pivot) &#123;i++;&#125;</code>），当右指针等于基准元素的时候却停止了（<code>while (j &gt;= i &amp;&amp; arr[j] &gt; pivot) &#123;j--;&#125;</code>）。那么左、右指针是否应该停止呢？</p>
<p>假设，未排序的初始数组都的所有元素都相同，那么试想一下左、右指针指向的元素等于基准元素时的情况：</p>
<ol>
<li>左、右指针都不停止：那么先执行 <code>while</code> 循环的那个指针会一直移动，直到与另一个指针相遇（另一个指针一步也没移动）。这一轮移动划分的时间复杂度为 <code>O(n)</code>，最后基准元素的位置还是在某一侧。下一次移动还是同样的情况，每次划分的数组的长度都是减少 1（另一个数组长度为 0）。整个排序过程的时间复杂度为 <code>O(n^2)</code>。</li>
<li>左、右指针都停止：那么两个指针会交换着指向的元素，直到来到数组中间，基准元素也会放在中间。这样下次划分时两个数组的长度都会减半。整个排序过程的时间复杂度为 <code>O(nlogn)</code>。</li>
<li>一个指针不停止、一个指针停止：等价于「左、右指针都不停止」的情况，因为情况 1 中，另一个指针就没有机会移动（就相当于停止啊）。</li>
</ol>
<p>综上，<strong>当指针指向的元素等于基准元素时，应该停止</strong>。</p>
<h2 id="优化后的快速排序代码"><a href="# 优化后的快速排序代码" class="headerlink" title="优化后的快速排序代码"></a>优化后的快速排序代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 将选中的基准元素与数组末尾元素交换,  并指定基准元素为「数组末尾元素」</span></span><br><span class="line">    <span class="type">int</span> pivotIdx = getMedianIdx(arr, left, right);</span><br><span class="line">    swap(&amp;arr[right], &amp;arr[pivotIdx]);</span><br><span class="line">    <span class="type">int</span> pivot = arr[right];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = left, j = right - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j &amp;&amp; arr[i] &lt; pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= i &amp;&amp; arr[j] &gt; pivot) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            swap(&amp;arr[i++], &amp;arr[j--]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(&amp;arr[right], &amp;arr[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> pivot = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, pivot - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, pivot + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>最后留一个问题：快速排序为什么「快速」？</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title>计网之 OSI 模型</title>
    <url>/posts/231011192359.html</url>
    <content><![CDATA[<p>这篇文章主要介绍 OSI（Open System Interconnect）参考模型，以及 message、segment、datagram、packet、frame、bit 等概念。</p>
<span id="more"></span>

<h2 id="计算机网络各层代表设备"><a href="# 计算机网络各层代表设备" class="headerlink" title="计算机网络各层代表设备"></a>计算机网络各层代表设备</h2><ul>
<li>物理层：网卡、网线、光纤、atm 线缆等</li>
<li>数据链路层：二层交换机</li>
<li>网络层：路由器、三层交换机、防火墙</li>
<li>传输层：代表协议，如 TCP &amp; UDP</li>
<li>应用层：各种协议，如 HTTP &amp; SMTP &amp; FTP</li>
</ul>
<h2 id="OSI 模型中各层单位"><a href="#OSI 模型中各层单位" class="headerlink" title="OSI 模型中各层单位"></a>OSI 模型中各层单位 </h2><p> 在计算机网络中，有许多不同的概念用于描述数据在不同层次的传输和封装。以下是这些概念的简要介绍：</p>
<table>
<thead>
<tr>
<th>数据单元</th>
<th>层次</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>message</td>
<td>应用层</td>
<td>在应用层发送和接收的数据单元，它可以是任意大小的数据块</td>
</tr>
<tr>
<td>segment</td>
<td>传输层</td>
<td>在传输层（如 TCP）中使用的数据单元，segment 包含了源端口号和目的端口号，并提供可靠的、有序的数据传输</td>
</tr>
<tr>
<td>datagram</td>
<td>网络层</td>
<td>在网络层（如 IP）中使用的数据单元，datagram 包含了源 IP 和目的 IP，并提供不可靠的、无序的数据传输</td>
</tr>
<tr>
<td>packet</td>
<td>网络层通用</td>
<td>在网络层中使用的通用术语，用于表示在网络中传输的数据单元，可以指代 segment 或 datagram</td>
</tr>
<tr>
<td>frame</td>
<td>数据链路层</td>
<td>在数据链路层中使用的数据单元，frame 包含了物理地址（如 MAC 地址）和错误检测码，用于在物理网络中传输数据</td>
</tr>
<tr>
<td>bit</td>
<td>物理层</td>
<td>是计算机网络中最小的数据单位，用于表示二进制的 0 或 1</td>
</tr>
</tbody></table>
<h2 id="OSI 模型中各层的服务对象"><a href="#OSI 模型中各层的服务对象" class="headerlink" title="OSI 模型中各层的服务对象"></a>OSI 模型中各层的服务对象 </h2><p> 不同层之间是在为谁提供服务呢？</p>
<p>应用层为应用程序提供服务，传输层为应用层提供端到端的数据传输服务，网络层为传输层提供网络间的数据传输服务，数据链路层为网络层提供主机到主机的数据传输服务。</p>
<ol>
<li>应用层为应用程序提供服务。</li>
<li>传输层主要为进程提供端到端的通信服务。<ul>
<li>传输层使用端口号来标识不同的进程，将应用层的数据划分为较小的数据单元（segment），并通过网络传输到目的地。</li>
<li>传输层可以提供可靠的数据传输，保证数据的完整性和顺序性。</li>
<li>此外，传输层还负责多个进程间的数据分发和复用，可以同时为多个进程提供服务。</li>
</ul>
</li>
<li>网络层主要为主机提供服务。<ul>
<li>网络层负责将传输层的数据单元（segment）打包成网络层的数据单元（datagram），并通过网络进行传输。</li>
<li>网络层使用 IP 地址来标识主机和网络，通过路由选择算法将数据传输到目的地，实现主机间的通信。</li>
</ul>
</li>
<li>数据链路层主要为同一链路上的主机（或设备）提供服务。<ul>
<li>数据链路层负责将网络层的数据单元（datagram）打包成数据链路层的数据单元（frame），并通过物理链路进行传输。</li>
<li>数据链路层使用 MAC 地址来标识主机或设备，通过帧的发送和接收来实现同一链路上的通信。</li>
</ul>
</li>
</ol>
<p>总结成表格如下：</p>
<table>
<thead>
<tr>
<th>层级</th>
<th>功能</th>
<th>提供服务的对象</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>为应用程序提供服务</td>
<td>应用程序</td>
</tr>
<tr>
<td>传输层</td>
<td>为进程提供端到端的通信服务，划分数据单元，保证数据传输可靠性和顺序性，数据分发和复用</td>
<td>进程</td>
</tr>
<tr>
<td>网络层</td>
<td>为主机提供服务，将传输层的数据单元打包成网络层的数据单元，通过网络进行传输，寻址和路由选择，实现主机间通信</td>
<td>主机</td>
</tr>
<tr>
<td>数据链路层</td>
<td>为同一链路上的主机或设备提供服务，将网络层的数据单元打包成数据链路层的数据单元，通过物理链路进行传输，帧的封装和解封装，帧的传输和错误检测，介质访问控制</td>
<td>同一链路上的主机或设备</td>
</tr>
<tr>
<td>物理层</td>
<td>通过物理链路进行数据传输，数据的编码和解码，数据的传输和接收</td>
<td>物理链路上的设备和传输介质等</td>
</tr>
</tbody></table>
<h2 id="OSI-vs-TCP-IP 模型"><a href="#OSI-vs-TCP-IP 模型" class="headerlink" title="OSI vs. TCP/IP 模型"></a>OSI vs. TCP/IP 模型</h2><p><img src="/images/computer-network/OSI-TCP-model.png" alt="OSI vs. TCP/IP 模型"></p>
<h2 id="OSI 模型数据封装与解封装过程"><a href="#OSI 模型数据封装与解封装过程" class="headerlink" title="OSI 模型数据封装与解封装过程"></a>OSI 模型数据封装与解封装过程</h2><p><img src="/images/computer-network/OSI-data-encapsulation-unpacking.png" alt="OSI 模型数据封装与解封装过程"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>OSI模型</tag>
      </tags>
  </entry>
  <entry>
    <title>模运算（求余运算）</title>
    <url>/posts/231010144856.html</url>
    <content><![CDATA[<p>两数相加、两数相乘怎么求余数，负数求余数到底等于多少，如何高效求余数？这篇文章将记录这些知识，方便后续查阅。</p>
<span id="more"></span>

<h2 id="正数求余"><a href="# 正数求余" class="headerlink" title="正数求余"></a>正数求余 </h2><p> 自然数对正数求余是指将一个自然数除以另一个正整数后得到的余数。</p>
<p>例如，对于自然数 $a$ 和正整数 $m$，求 $a/m$ 的余数，可以用符号「%」表示，即 $a \% m$。</p>
<p>假设 $a=km+r, (a&gt;=0, m&gt;0)$，那么 $a/m$ 等于 $k, (k&gt;=0)$，$a \% m$ 等于 $r, (0&lt;=r&lt;m)$。</p>
<h2 id="两数相加求余"><a href="# 两数相加求余" class="headerlink" title="两数相加求余"></a>两数相加求余 </h2><p> 结论：一般地，两个整数相加后求余数，有如下等式：</p>
<p>$$<br>\begin{cases}<br>(a + b) \% m \\<br>= ((a \% m) + (b \% m)) \% m \\<br>\end{cases}<br>$$</p>
<p>证明：根据 <strong> 带余除法</strong>，任意整数 $a$ 都可以表示为 $a=km+r$，这里 $r$ 相当于 $a \% m$。那么设 $a=k_{1}m+r_{1}, b=k_{2}m+r_{2}$，则有</p>
<p>$$<br>\begin{cases}<br>(a + b) \% m \\<br>= ((k_{1} + k_{2})m + r_{1} + r_{2}) \% m \\<br>= (r_{1} + r_{2}) \% m \\<br>= ((a \% m) + (b \% m)) \% m \\<br>\end{cases}<br>$$</p>
<p>证毕。</p>
<h2 id="两数相乘求余"><a href="# 两数相乘求余" class="headerlink" title="两数相乘求余"></a>两数相乘求余 </h2><p> 结论：一般地，两个整数相乘后求余数，有如下等式：</p>
<p>$$<br>(a \times b) \% m = ((a \% m) \times (b \% m)) \% m<br>$$</p>
<p>证明：根据 <strong> 带余除法</strong>，任意整数 $a$ 都可以表示为 $a=km+r$，这里 $r$ 相当于 $a \% m$。那么设 $a=k_{1}m+r_{1}, b=k_{2}m+r_{2}$，则有</p>
<p>$$<br>\begin{cases}<br>(a \times b) \% m \\<br>= ((k_{1}k_{2})m^{2} + (k_{1}r_{2} + k_{2}r_{1})m + r_{1}r_{2}) \% m \\<br>= (r_{1}r_{2}) \% m \\<br>= ((a \% m) \times (b \% m)) \% m \\<br>\end{cases}<br>$$</p>
<p>证毕。</p>
<h2 id="负数求余"><a href="# 负数求余" class="headerlink" title="负数求余"></a>负数求余 </h2><h3 id="不同语言的负数求余"><a href="# 不同语言的负数求余" class="headerlink" title="不同语言的负数求余"></a> 不同语言的负数求余</h3><ol>
<li>一个负数对一个正数求余数：</li>
</ol>
<ul>
<li>C、C++ 和 Java 的结果是商尽可能大（在坐标轴上尽可能靠右），余数的正负号与被除数的正负号保持一致，即为负数。</li>
<li>Python、Google 计算器和百度计算器的结果是商尽可能小（在坐标轴上尽可能靠左），余数的正负号与除数的正负号保持一致，为正数。</li>
</ul>
<table>
<thead>
<tr>
<th>语言</th>
<th>语句</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>C/C++</td>
<td><code>cout &lt;&lt; (-7) % 3;</code></td>
<td>-1</td>
</tr>
<tr>
<td>Java（1.6）</td>
<td><code>System.out.println((-7) % 3);</code></td>
<td>-1</td>
</tr>
<tr>
<td>Python 2.6</td>
<td><code>(-7) % 3</code></td>
<td>2</td>
</tr>
<tr>
<td>百度计算器</td>
<td><code>(-7) mod 3</code></td>
<td>2</td>
</tr>
<tr>
<td>Google 计算器</td>
<td><code>(-7) mod 3</code></td>
<td>2</td>
</tr>
</tbody></table>
<ol start="2">
<li>一个正数对一个负数求余数：</li>
</ol>
<ul>
<li>C、C++ 和 Java 的结果是商尽可能大（在坐标轴上尽可能靠右），余数的正负号与被除数的正负号保持一致，即为正数。</li>
<li>Python、Google 计算器和百度计算器的结果是商尽可能小（在坐标轴上尽可能靠左），余数的正负号与除数的正负号保持一致，为负数。</li>
</ul>
<table>
<thead>
<tr>
<th>语言</th>
<th>语句</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>C/C++</td>
<td><code>cout &lt;&lt; 7 % (-3);</code></td>
<td>1</td>
</tr>
<tr>
<td>Java (1.6)</td>
<td><code>System.out.println(7 % (-3));</code></td>
<td>1</td>
</tr>
<tr>
<td>Python 2.6</td>
<td><code>7 % (-3)</code></td>
<td>-2</td>
</tr>
<tr>
<td>百度计算器</td>
<td><code>7 mod (-3)</code></td>
<td>-2</td>
</tr>
<tr>
<td>Google 计算器</td>
<td><code>7 mod (-3)</code></td>
<td>-2</td>
</tr>
</tbody></table>
<ol start="3">
<li>一个负数对一个负数求余数：</li>
</ol>
<ul>
<li>C、C++ 和 Java 以及 Python、Google 计算器和百度计算器的结果都是商尽可能小（在坐标轴上尽可能靠左），余数为负数。</li>
</ul>
<table>
<thead>
<tr>
<th>语言</th>
<th>语句</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>C/C++</td>
<td><code>cout &lt;&lt; -7 % (-3);</code></td>
<td>-1</td>
</tr>
<tr>
<td>Java (1.6)</td>
<td><code>System.out.println(-7 % (-3));</code></td>
<td>-1</td>
</tr>
<tr>
<td>Python 2.6</td>
<td><code>-7 % (-3)</code></td>
<td>-1</td>
</tr>
<tr>
<td>百度计算器</td>
<td><code>-7 mod (-3)</code></td>
<td>-1</td>
</tr>
<tr>
<td>Google 计算器</td>
<td><code>-7 mod (-3)</code></td>
<td>-1</td>
</tr>
</tbody></table>
<h3 id="总结"><a href="# 总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>在被除数与除数 <strong> 正负号相同时 </strong>，所有语言<strong> 都期望商尽可能小 </strong>（<del> 余数的正负号与被除数、除数的正负号一致</del>）。</li>
<li>在被除数与除数 <strong> 正负号相反时</strong>：</li>
</ol>
<ul>
<li>对于 C、C++ 和 Java，<strong>期望商尽可能大 </strong>（<del> 余数的正负号与 <strong> 被除数 </strong> 的正负号保持一致</del>）；</li>
<li>对于 Python、Google 计算器和百度计算器，<strong>还是期望商尽可能小 </strong>（<del> 余数的正负号与 <strong> 除数 </strong> 的正负号保持一致</del>）。</li>
</ul>
<h2 id="位运算求余数"><a href="# 位运算求余数" class="headerlink" title="位运算求余数"></a>位运算求余数 </h2><p> 对于自然数 $a$ 和正整数 $m$，在某些情况下，当 $m=2^n$ 时，有如下替换公式：</p>
<p>$$<br>a \% m = a \&amp; (m - 1)<br>$$</p>
<p>即:</p>
<p>$$<br>a \% 2^{n} = a \&amp; (2^{n} - 1)<br>$$</p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://leetcode.cn/problems/movement-of-robots/solutions/2304680/nao-jin-ji-zhuan-wan-pai-xu-tong-ji-pyth-we55/?envType=daily-question&envId=2023-10-10">灵茶山艾府 Leetcode2731 移动机器人题解</a></li>
<li><a href="http://ceeji.net/blog/mod-in-real/">实数范围内的求模（求余）运算：负数求余究竟怎么求</a></li>
<li><a href="https://blog.csdn.net/lonyw/article/details/80519652">使用位操作（&amp; 运算）代替求余操作</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>模运算</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之 pthread 多线程</title>
    <url>/posts/230911151334.html</url>
    <content><![CDATA[<h2 id="多线程"><a href="# 多线程" class="headerlink" title="多线程"></a>多线程 </h2><h3 id="进程与线程"><a href="# 进程与线程" class="headerlink" title="进程与线程"></a> 进程与线程 </h3><p><strong> 进程</strong>：是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单元，是应用程序运行的载体。进程一般由程序、数据集合和进程控制块三部分组成：</p>
<ul>
<li><p>程序：描述进程的功能，控制进程的指令集（写论文的目的和手段）</p>
</li>
<li><p>数据集：程序在执行时所需要的数据和工作区（写论文的材料）</p>
</li>
<li><p>进程控制块：跟踪每个进程的状态，操作系统会为进程保留进程列表（写作者）</p>
</li>
</ul>
<p><strong>线程 </strong>：线程是程序执行中的一个单一的<strong> 顺序控制流程</strong>，是程序执行流的最小单元，是处理器调度和分派的基本单位。</p>
<ul>
<li><p>一个进程至少有一个线程，一个进程也可以有多个线程。（一个父亲可以有一个、多个孩子）</p>
</li>
<li><p>各个线程之间共享程序的内存空间，即所在进程的内存空间。（多个孩子共享一个家庭空间）</p>
</li>
<li><p>一个标准的线程由线程 ID、当前指令指针 PC、寄存器和堆栈组成。（每个孩子有其自身的成长轨迹）</p>
</li>
</ul>
<span id="more"></span>

<p><strong>进程与线程的区别</strong>：</p>
<ul>
<li><p>线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位。</p>
</li>
<li><p>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线。</p>
</li>
<li><p>进程之间相互独立，但 <strong> 同一进程下的各个线程之间共享程序的内存空间 </strong>（代码段、数据集、堆等）以及一些<strong> 进程级的资源</strong>（如打开文件和信号等），某进程内的线程在其他进程中不可见。</p>
</li>
<li><p><strong>线程上下文切换比进程上下文切换要快得多</strong>。</p>
</li>
</ul>
<h3 id="上下文切换"><a href="# 上下文切换" class="headerlink" title="上下文切换"></a>上下文切换 </h3><h4 id="时间片"><a href="# 时间片" class="headerlink" title="时间片"></a> 时间片 </h4><p> 多任务系统往往需要同时执行多道作业。作业数往往大于机器的 CPU 数，然而一颗 CPU 同时只能执行一项任务，如何让用户感觉这些任务正在同时进行呢? 操作系统的设计者巧妙地利用了 <strong> 时间片轮转的方式</strong>。</p>
<p><strong>时间片是 CPU 分配给各个任务（线程）的时间</strong>。</p>
<blockquote>
<p>思考：单核 CPU 为何也支持多线程呢？</p>
<p>虽然单核 CPU 只有一个物理处理单元，但它可以 <strong> 通过时间分片的方式支持多线程</strong>。在单核 CPU 中，操作系统通过时间片轮转算法将 CPU 时间划分为多个时间片段，每个时间片段分配给一个线程执行。当一个线程的时间片用完后，操作系统会暂停该线程的执行，并切换到下一个线程继续执行。这种切换是非常快速的，以至于我们感觉多个线程在同时执行。</p>
<p>需要注意的是，在单核 CPU 上并发执行的多线程是通过时间片轮转调度实现的，每个线程在任意给定的时间点上 <strong> 只能有一个 </strong> 线程在执行。而在多核 CPU 上，可以实现真正的并行执行，每个核心可以同时执行一个线程，从而提高并发性能。</p>
</blockquote>
<h4 id="上下文切换 -1"><a href="# 上下文切换 -1" class="headerlink" title="上下文切换"></a>上下文切换 </h4><p><strong> 线程上下文 </strong>：是指某一时间点 CPU <strong> 寄存器和程序计数器的内容</strong>，CPU 通过时间片分配算法来循环执行任务（线程），因为时间片非常短，所以 CPU 通过不停地切换线程执行。</p>
<p>换言之，单 CPU 这么频繁，多核 CPU 一定程度上可以减少上下文切换。</p>
<p><strong>上下文切换 </strong>：CPU 切换前把当前任务的状态保存下来（以便下次切换回这个任务时可以再次加载这个任务的状态），然后加载下一任务的状态并执行。<strong> 任务的状态保存及再加载</strong>，这段过程就叫做上下文切换。</p>
<h3 id="多线程编程"><a href="# 多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h3><ul>
<li><p>多进程模式：启动多个进程，每个进程虽然只有一个线程，但是多个进程可以一块执行多个任务。</p>
</li>
<li><p><strong>多线程模式</strong>：启动一个进程，在一个进程内启动多个线程，多个线程一起执行多个任务。</p>
</li>
<li><p>多进程 + 多线程模式：启动多个进程，每个进程再启动多个线程，这样同时执行的任务就更多了。</p>
</li>
</ul>
<p>其实创建线程之后，线程并不是始终保持一个状态的，其状态大概如下：</p>
<ol>
<li>New 创建</li>
<li>Runnable 就绪，等待调度</li>
<li>Running 运行</li>
<li>Blocked 阻塞，阻塞可能在 Wait / Locked / Sleeping 阶段</li>
<li>Dead 消亡</li>
</ol>
<p>线程有着不同的状态，也有不同的类型。大致可分为：</p>
<ul>
<li><p>主线程：主线程是程序启动时自动创建的线程，它负责执行程序的主要逻辑。主线程通常负责处理用户交互、调度其他线程的创建和管理等任务。</p>
</li>
<li><p>子线程：子线程是由主线程创建的额外线程，用于执行并发任务。子线程可以并行地执行任务，从而提高程序的效率和响应性。</p>
</li>
<li><p>守护线程（后台线程）：守护线程是一种特殊类型的线程，它在后台运行，<strong>不会阻止程序的退出</strong>。当所有的非守护线程都退出时，守护线程也会自动结束。守护线程通常用于执行一些后台任务，如日志记录、定时任务等。</p>
</li>
<li><p>前台线程：前台线程是与守护线程相对的概念，它是指 <strong> 会阻止程序退出的线程</strong>。当所有的前台线程都退出时，程序才会结束。</p>
</li>
</ul>
<h3 id="pthread 多线程"><a href="#pthread 多线程" class="headerlink" title="pthread 多线程"></a>pthread 多线程</h3><p>POSIX 线程（Pthreads）是一套标准的线程 API，用于多线程编程。该库定义了一组 C 语言函数，允许程序员创建和管理多个线程，并提供同步和互斥机制，以确保线程之间的正确协调。</p>
<p>Pthreads 库是 POSIX 标准的一部分，其全称是“Portable Operating System Interface”，旨在为 Unix-like 操作系统（如 Linux、FreeBSD、Mac OS X 等）提供一致的接口。由于该标准的广泛接受和实现，因此 Pthreads 库现在在许多不同的平台上都可用。</p>
<p>Pthreads 库的一个优点是它允许程序员创建轻量级线程（LWP），这些线程比进程更轻量级，因此在创建和销毁它们时所需的开销较小。此外，由于它是标准的 POSIX 接口，因此 Pthreads 库可在不同的操作系统上重用，从而提高了代码的可移植性。</p>
<p>pthread 库需要头文件：<code>pthread.h</code></p>
<p>gcc 编译链接参数：<code>lpthread</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc ./demo.c -o demo -lpthread</span><br></pre></td></tr></table></figure>

<h4 id="创建线程相关"><a href="# 创建线程相关" class="headerlink" title="创建线程相关"></a>创建线程相关 </h4><h5 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create"></a>pthread_create</h5><p><code>pthread_create</code> 是一个用于创建线程的函数，它的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pthread_t 类型的原型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="type">pthread_t</span>;</span><br></pre></td></tr></table></figure>

<p>该函数接收四个参数，分别是：</p>
<ol>
<li><p><code>thread</code>：一个指向线程标识符的指针，由函数创建并返回。</p>
</li>
<li><p><code>attr</code>：一个指向线程属性的指针，用于设置线程的属性。如果不需要设置属性，传入 <code>NULL</code> 即可。</p>
</li>
<li><p><code>start_routine</code>：线程执行的函数指针，该函数接受一个 <code>void *</code> 类型的参数，并返回一个 <code>void *</code> 类型的值。</p>
</li>
<li><p><code>arg</code>：传递给线程执行函数的参数，如果有多个参数，可以传递一个指向参数结构体的指针。</p>
</li>
</ol>
<p>当调用 <code>pthread_create</code> 函数时，它会创建一个新的线程，并将其标识符存储在 <code>thread</code> 指针中。新线程的执行将从 <code>start_routine</code> 函数开始，<code>arg</code>参数将作为 <code>start_routine</code> 的参数传递给它。</p>
<p>创建线程时，可以选择使用默认线程属性，也可以使用 <code>pthread_attr_t</code> 结构体来设置一些属性，例如线程的调度策略、栈大小、优先级等等。如果不需要设置属性，可以将 <code>attr</code> 参数设置为<code>NULL</code>。</p>
<p><code>pthread_create</code>函数成功时返回 0，否则返回一个错误码。如果返回非零错误码，可以使用 <code>perror</code> 函数或 <code>strerror</code> 函数打印出错误信息。</p>
<h5 id="pthread-self"><a href="#pthread-self" class="headerlink" title="pthread_self"></a>pthread_self</h5><p><code>pthread_self</code>函数返回调用它的线程的线程 ID：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<h5 id="pthread-equal"><a href="#pthread-equal" class="headerlink" title="pthread_equal"></a>pthread_equal</h5><p><code>pthread_equal</code>函数通过线程 ID 比较线程是否相等，如果两个线程相等，返回非 0 值，如果不相等，返回 0：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br></pre></td></tr></table></figure>

<h5 id="pthread-detach"><a href="#pthread-detach" class="headerlink" title="pthread_detach"></a>pthread_detach</h5><p><code>pthread_detach</code> 函数用于将指定的线程分离出去，所谓分离出去就是指 <strong> 主线程再不需要 </strong> 通过 <code>pthread_join</code> 等方式，等待该线程的结束并回收其线程控制块（TCB）的资源，<strong>被分离的线程结束后由操作系统负责其资源的回收</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>thread</code> 参数是要分离的线程的标识符，返回值为 0 表示成功，非 0 值表示出错。</p>
<p>需要注意的是，如果一个线程被分离了，就不能再对它调用 <code>pthread_join</code> 函数，否则会出错。因此，在调用 <code>pthread_detach</code> 函数之前，必须确保不会再调用 <code>pthread_join</code> 函数。</p>
<p>一般来说，主线程是要负责创建出来的子线程的资源回收工作的：</p>
<ul>
<li><p>如果主线程先于子线程退出，并且子线程没有设置为分离状态，那么子线程结束后其资源是无法得到回收的，会造成资源浪费和系统臃肿。</p>
</li>
<li><p>如果主线程先于子线程退出，但是子线程是分离状态，那么子线程退出的时候操作系统会自动回收其资源。</p>
</li>
</ul>
<p>分离线程并不是分离了之后，就跟主线程没有一点关系了。主线程退出了，分离线程还是一样退出，只是分离线程的资源是由系统回收的。</p>
<h4 id="终止线程相关"><a href="# 终止线程相关" class="headerlink" title="终止线程相关"></a>终止线程相关 </h4><p> 终止线程的三种方式：</p>
<ol>
<li><p>线程从启动例程返回，返回值就是线程的退出码；</p>
</li>
<li><p>线程可以被同一进程中的其他线程取消（通过<code>pthread_cancel()</code>）；</p>
</li>
<li><p>线程自身调用 <code>pthread_ exit()</code> 函数终止。</p>
</li>
</ol>
<h5 id="pthread-cancel"><a href="#pthread-cancel" class="headerlink" title="pthread_cancel"></a>pthread_cancel</h5><p><code>pthread_cancel</code> 函数是一个用于取消 POSIX 线程的函数。该函数向目标线程发送一个取消请求，如果该线程允许取消，则会在处理该请求时终止该线程的执行。</p>
<blockquote>
<p>线程可以设置为允许取消（默认情况下）或者禁止取消。如果线程允许取消，它将在收到取消请求后 <strong> 尽快取消</strong>，并执行一些清理工作；如果线程禁止取消，它将继续运行，直到完成其任务或者显式地调用 <code>pthread_exit</code> 函数。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure>

<p><code>pthread_cancel</code> 函数有以下两种用法：</p>
<ol>
<li><p><code>int pthread_cancel(pthread_t thread);</code> 此用法向线程 ID 为 <code>thread</code> 的线程发送取消请求。如果请求成功发送，则返回 0。如果线程 ID 无效或请求无法发送，则返回一个非零错误码。</p>
</li>
<li><p><code>void pthread_testcancel(void);</code> 此用法可以在线程执行期间调用，用于测试是否有取消请求已经发送给该线程。如果是，则在线程执行期间发生取消动作，该线程的执行将立即停止。</p>
</li>
</ol>
<p>需要注意的是，<code>pthread_cancel</code> 函数并不保证能够成功地取消目标线程的执行。当目标线程正在执行某些不可取消的操作（例如某些系统调用）时，取消请求可能会被暂时挂起，直到目标线程离开这些操作为止。另外，使用 <code>pthread_cancel</code> 函数需要注意线程同步问题，避免出现死锁等问题。</p>
<p>总的来说，<code>pthread_cancel</code> 函数可以用于线程的优雅终止，但是需要谨慎使用，避免出现意外的问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread is running...\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 在循环中调用 pthread_testcancel 函数检查是否有取消请求</span></span><br><span class="line">        pthread_testcancel();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread_id;</span><br><span class="line">    <span class="comment">// 创建一个线程并启动它</span></span><br><span class="line">    pthread_create(&amp;thread_id, <span class="literal">NULL</span>, &amp;thread_func, <span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 在主线程中调用 pthread_cancel 函数向子线程发送取消请求</span></span><br><span class="line">    pthread_cancel(thread_id);</span><br><span class="line">    <span class="comment">// 等待子线程结束</span></span><br><span class="line">    pthread_join(thread_id, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread has been canceled.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">root@fw:~/w26/ccodes# ./demo</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread has been canceled.</span><br><span class="line">root@fw:~/w26/ccodes#</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，首先创建了一个子线程并启动它，在子线程的循环中不断输出信息，同时在循环中调用 <code>pthread_testcancel</code> 函数检查是否有取消请求。在主线程中等待 5 秒钟后，调用 <code>pthread_cancel</code> 函数向子线程发送取消请求，然后等待子线程结束并输出一条信息表示子线程已经被成功取消。</p>
<p><strong>调用与不调用 <code>pthread_testcancel()</code> 的区别</strong>：</p>
<ol>
<li><p>调用 <code>pthread_testcancel</code> 函数可以让线程在循环或其他 <em> 可取消的操作中 </em> 主动检查是否有取消请求，并在检测到取消请求时 <em> 及时终止 </em> 线程的执行。这样可以增加线程的可靠性，<strong>确保线程在可以取消的时候及时响应取消请求</strong>。</p>
</li>
<li><p>如果不调用 <code>pthread_testcancel</code> 函数，线程可能会在某些不可取消的操作中被阻塞（例如在 <code>sleep</code> 等待时），无法及时响应取消请求，导致取消请求被暂时挂起。</p>
</li>
<li><p>因此，为了保证线程能够及时响应取消请求，通常建议在线程的循环或其他可取消的操作中调用 <code>pthread_testcancel</code> 函数，以便让线程在合适的时机进行取消。但是需要注意的是，在使用 <code>pthread_testcancel</code> 函数时，必须确保线程的同步操作是线程安全的，否则可能会导致程序出现不可预期的错误。</p>
</li>
<li><p>当然，在某些情况下，如果线程不会进入可取消的状态，或者线程在处理临界区时不能被取消，那么调用 <code>pthread_testcancel</code> 函数可能会导致线程被错误地取消。在这种情况下，可以通过设置线程的取消状态为 <code>PTHREAD_CANCEL_DISABLE</code> 来禁用取消操作，以避免意外的取消。</p>
</li>
</ol>
<p>总之，调用 <code>pthread_testcancel</code> 函数可以让线程更加及时地、可靠地响应取消请求，从而增加程序的安全性和稳定性，但需要注意线程同步的问题，以避免出现错误。</p>
<h5 id="pthread-exit"><a href="#pthread-exit" class="headerlink" title="pthread_exit"></a>pthread_exit</h5><p><code>pthread_exit()</code>是一个线程终止函数，它允许一个线程在它的 <strong> 任意位置退出</strong>。该函数接受一个参数，表示线程的返回值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure>

<p>调用 <code>pthread_exit()</code> 函数会立即终止当前线程的执行，并将传递的参数作为线程的返回值。如果该线程被其他线程等待，那么该返回值可以被其他线程获取。</p>
<blockquote>
<p>注意：指针 <code>retval</code> 指向的内容不能为函数中局部变量，因为一旦线程函数终止，它们将不再存在。</p>
</blockquote>
<p><code>pthread_exit()</code>函数通常在以下情况下使用：</p>
<ol>
<li><p>在线程执行完任务后，主动结束自己的执行。</p>
</li>
<li><p>当线程执行出现错误时，使用该函数退出线程。</p>
</li>
<li><p>在主线程中调用 <code>pthread_exit()</code> 函数来结束整个程序的执行。</p>
</li>
</ol>
<blockquote>
<p>注意：如果在主线程中调用了<code>pthread_exit(NULL)</code>，则主线程退出，而不是退出进程，因此如果子线程存在，会继续执行。</p>
<p>需要注意的是，当一个线程调用 <code>pthread_exit()</code> 函数后，该线程会 <strong> 立即终止，不会再执行任何其他操作 </strong>。因此，如果线程需要进行一些清理工作，比如释放内存、关闭文件等，就需要在调用<code>pthread_exit()</code> 函数之前完成这些操作。</p>
</blockquote>
<h4 id="等待线程结束"><a href="# 等待线程结束" class="headerlink" title="等待线程结束"></a>等待线程结束 </h4><h5 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join"></a>pthread_join</h5><p><code>pthread_join</code> 函数用于 <strong> 等待一个指定线程结束，并回收其占用的资源</strong>。它的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>thread</code>：要等待的线程的标识符，即线程创建时返回的 <code>pthread_t</code> 类型的值。该参数指定了需要等待的线程。</p>
</li>
<li><p><code>retval</code>：用于存储线程的返回值的指针。该参数是一个 <strong> 指向指针的指针，因为线程的返回值的类型可能是不确定的，可能是一个整型、浮点型或者指针等类型 </strong>。在<code>pthread_join</code> 函数返回时，线程的返回值将会被存储在 <code>retval</code> 所指向的内存空间中。</p>
</li>
</ol>
<p>需要注意的是，<code>retval</code>参数是可选的，如果不需要获取线程的返回值，可以将其设置为 <code>NULL</code>。另外，如果线程没有返回值，或者<strong> 在线程函数中没有显式地调用 <code>pthread_exit</code> 函数退出线程 </strong>，那么<code>retval</code> 参数将被忽略。</p>
<p>该函数会阻塞当前线程，直到指定的线程 <code>thread</code> 结束执行。具体来说，当我们调用 <code>pthread_join</code> 函数时，如果指定的线程 <code>thread</code> 还在运行中，当前线程就会被阻塞，等待该线程结束；如果线程 <code>thread</code> 已经结束了，那么 <code>pthread_join</code> 函数会立即返回，并将线程的返回值存储在 <code>retval</code> 中。此外，<code>pthread_join</code>函数会自动回收线程占用的资源，避免了资源泄露的问题。</p>
<p>以下是一个简单的示例代码，用于演示如何使用 <code>pthread_join</code> 函数等待线程结束并获取其返回值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *num = (<span class="type">int</span> *)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread is running, parameter is %d\n&quot;</span>, *num);</span><br><span class="line">    <span class="type">int</span> *res = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *res = (*num) * (*num);</span><br><span class="line">    pthread_exit((<span class="type">void</span> *)res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="type">int</span> parameter = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *result;</span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, thread_func, &amp;parameter);</span><br><span class="line">    pthread_join(thread, (<span class="type">void</span> **)&amp;result);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread returned: %d\n&quot;</span>, *result);</span><br><span class="line">    <span class="built_in">free</span>(result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果在线程函数中不调用 <code>pthread_exit</code> 函数退出线程，而是直接返回，那么该线程的返回值将是一个未定义的值，可能会导致程序出现不可预料的错误。因此，<strong>在编写多线程程序时，一定要记得在线程函数中调用 <code>pthread_exit</code> 函数退出线程</strong>。</p>
<h4 id="多线程示例"><a href="# 多线程示例" class="headerlink" title="多线程示例"></a>多线程示例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">my_thread_func</span><span class="params">(<span class="type">void</span> *pointer)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// sleep(1);</span></span><br><span class="line">        <span class="type">int</span> id = *(<span class="type">int</span> *)pointer;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread %d running, i=%d\r\n&quot;</span>, id, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(pointer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> threadId[<span class="number">5</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *arg = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*arg));</span><br><span class="line">        *arg = i;  <span class="comment">// 注意一</span></span><br><span class="line">        pthread_create(&amp;threadId[i], <span class="literal">NULL</span>, my_thread_func, (<span class="type">void</span> *)(arg));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(threadId[i], (<span class="type">void</span> **)(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread end\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于线程之间是异步执行的，因此在输出语句中的 <code>id</code> 值可能会和线程实际运行的顺序不一致，<strong>无法保证顺序执行</strong>。如果需要保证顺序执行，可以使用互斥锁来同步线程之间的执行顺序。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">root@fw:~/w26/ccodes# ./demo</span><br><span class="line">thread 0 running, k=0</span><br><span class="line">thread 2 running, k=0</span><br><span class="line">thread 2 running, k=1</span><br><span class="line">thread 0 running, k=1</span><br><span class="line">thread 1 running, k=0</span><br><span class="line">thread 1 running, k=1</span><br><span class="line">thread 2 running, k=2</span><br><span class="line">thread 1 running, k=2</span><br><span class="line">thread 3 running, k=0</span><br><span class="line">thread 3 running, k=1</span><br><span class="line">thread 3 running, k=2</span><br><span class="line">thread 4 running, k=0</span><br><span class="line">thread 4 running, k=1</span><br><span class="line">thread 4 running, k=2</span><br><span class="line">thread 0 running, k=2</span><br><span class="line">main thread end</span><br><span class="line">root@fw:~/w26/ccodes#</span><br></pre></td></tr></table></figure>

<p>对于注意一的解释：在 <code>main</code> 函数中循环创建 5 个线程时，每个线程的 <code>my_thread_func</code> 函数都被传递了指向 <code>i</code> 的指针，而 <code>i</code> 是一个 <em> 自动变量 </em>，其生命周期仅在循环内部。<strong> 由于线程的创建和调度是异步的</strong>，因此当线程实际运行时，<code>i</code> 可能已经被更新成另一个值，这会导致线程使用了错误的数据。</p>
<p>使用 <code>malloc</code> 申请临时变量来保存自动变量 <code>i</code> 的值，每个线程函数都被传递了一个指向分配的临时变量的指针，该变量保存了正确的 <code>i</code> 值。在线程函数中，使用 <code>*(int *)pointer</code> 获取 <code>i</code> 的值，并在使用完后释放该临时变量的内存空间。</p>
<blockquote>
<p>何为自动变量？</p>
</blockquote>
<p>在 C 和 C++ 等编程语言中，当在函数或代码块内部声明一个变量时，该变量默认为自动变量。自动变量具有以下特点：</p>
<ol>
<li><p>作用域：自动变量的作用域仅限于声明它的代码块内部。这意味着在声明的代码块外部是无法访问到该变量的。</p>
</li>
<li><p>存储方式：自动变量通常存储在栈（stack）上。当进入声明变量的代码块时，该变量会在栈上分配存储空间，当代码块执行完毕时，变量会自动释放所占用的栈空间。</p>
</li>
<li><p>初始化：自动变量在声明时可以选择是否进行初始化。如果未初始化，则其值是不确定的。</p>
</li>
</ol>
<p>自动变量适用于那些在局部范围内使用的临时数据和临时存储需求较小的变量。与全局变量和静态变量相比，自动变量具有更短的生命周期和更小的作用域，能够更有效地管理内存和避免命名冲突。</p>
<h4 id="多线程同步示例"><a href="# 多线程同步示例" class="headerlink" title="多线程同步示例"></a>多线程同步示例 </h4><p> 保证线程内顺序执行，可以使用互斥锁来同步线程之间的执行顺序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">my_thread_func</span><span class="params">(<span class="type">void</span> *pointer)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// sleep(1);</span></span><br><span class="line">        <span class="type">int</span> i = *(<span class="type">int</span> *)(pointer);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread %d running, k=%d\r\n&quot;</span>, i, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(pointer);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> threadId[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *arg = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*arg));</span><br><span class="line">        *arg = i;  <span class="comment">// 注意一</span></span><br><span class="line">        pthread_create(&amp;threadId[i], <span class="literal">NULL</span>, my_thread_func, (<span class="type">void</span> *)(arg));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(threadId[i], (<span class="type">void</span> **)(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread end\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">root@fw:~/w26/ccodes# ./demo</span><br><span class="line">thread 1 running, k=0</span><br><span class="line">thread 1 running, k=1</span><br><span class="line">thread 1 running, k=2</span><br><span class="line">thread 3 running, k=0</span><br><span class="line">thread 3 running, k=1</span><br><span class="line">thread 3 running, k=2</span><br><span class="line">thread 2 running, k=0</span><br><span class="line">thread 2 running, k=1</span><br><span class="line">thread 2 running, k=2</span><br><span class="line">thread 0 running, k=0</span><br><span class="line">thread 0 running, k=1</span><br><span class="line">thread 0 running, k=2</span><br><span class="line">thread 4 running, k=0</span><br><span class="line">thread 4 running, k=1</span><br><span class="line">thread 4 running, k=2</span><br><span class="line">main thread end</span><br><span class="line">root@fw:~/w26/ccodes#</span><br></pre></td></tr></table></figure>

<p>在修改后的代码中，我们使用 <code>pthread_mutex_t</code> 类型定义了一个互斥锁，并在 <code>main</code> 函数中初始化了它。在 <code>my_thread_func</code> 函数中，我们在循环前加锁（某一个线程获取了锁），循环结束后解锁（该线程释放了锁，此时其它线程可以获取锁了），以保证线程的顺序执行（先获取到锁的线程，会执行完锁之间的内容，不再会出现上面未加锁的示例中，执行到一半，便去执行其它线程的内容）。最后在 <code>main</code> 函数结束前销毁互斥锁。</p>
<hr>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>进程与线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 学习笔记</title>
    <url>/posts/230909171809.html</url>
    <content><![CDATA[<h2 id="1- 什么是 Docker？"><a href="#1- 什么是 Docker？" class="headerlink" title="1. 什么是 Docker？"></a>1. 什么是 Docker？</h2><p>Docker 是一个开源的容器化平台，用于构建、打包和部署应用程序。它允许开发人员将应用程序和它们的依赖项打包成一个轻量级、可移植的容器，然后在任何支持 Docker 的环境中运行。</p>
<h3 id="1-1-Docker 的核心概念"><a href="#1-1-Docker 的核心概念" class="headerlink" title="1.1 Docker 的核心概念"></a>1.1 Docker 的核心概念 </h3><p> 在深入学习 Docker 之前，了解以下几个核心概念是很重要的：</p>
<ul>
<li><p><strong>容器（Container）</strong>：一个 <strong> 独立 </strong> 运行的沙箱（sandboxed）应用程序实例，包含应用程序及其所有依赖项。容器是 Docker 的基本构建块，有以下特点：</p>
<ul>
<li><p>利用 <a href="https://medium.com/@saschagrunert/demystifying-containers-part-i-kernel-space-2c53d6979504">kernel namespaces and cgroups</a> 实现隔离 / 独立。</p>
</li>
<li><p>是一个可运行的镜像的实例，可以使用 DockerAPI 或 CLI 创建、开始、停止、移动、删除一个容器。</p>
</li>
<li><p>可以运行在本地机器上、虚拟机上或者部署在云上。</p>
</li>
<li><p>可移植的（能运行在任何操作系统上）。</p>
</li>
<li><p>与其它容器隔离并运行自己的软件、二进制文件和配置。</p>
</li>
</ul>
</li>
<li><p><strong>镜像（Image）</strong>：一个只读的模板，用于创建容器。镜像包含了运行应用程序所需的一切，例如代码、运行时环境、库和依赖项。</p>
</li>
<li><p><strong>仓库（Repository）</strong>：用于存储和组织 Docker 镜像的地方。可以将仓库看作是镜像的集合。</p>
</li>
<li><p><strong>Dockerfile</strong>：一个文本文件，包含了一系列命令和指令，用于从头开始构建 Docker 镜像。</p>
</li>
</ul>
<span id="more"></span>

<h3 id="1-2-Dcoker-registry"><a href="#1-2-Dcoker-registry" class="headerlink" title="1.2 Dcoker registry"></a>1.2 Dcoker registry</h3><p>Docker Registry 是用于 <strong> 存储、管理和分发 Docker 镜像的中央仓库</strong>。它允许用户将自己创建的镜像上传到仓库，或者从仓库中拉取他人创建的镜像。在 Docker 中，默认使用 Docker 官方的公共注册服务器，称为 Docker Hub。此外，还可以在本地或私有云环境中搭建自己的 Docker Registry。</p>
<p>以下是 Docker Registry 的一些重要概念：</p>
<ol>
<li><p>镜像（Image）：Docker 镜像是一个包含了应用程序、运行时环境、库和依赖的只读模板。镜像是构建和运行容器的基础。在 Docker Registry 中，镜像被存储和管理。</p>
</li>
<li><p>仓库（Repository）：仓库是包含多个镜像的集合。仓库可以用于组织和管理镜像。每个镜像都有一个唯一的标签（tag），用于标识不同版本或变体的镜像。</p>
</li>
<li><p>注册服务器（Registry Server）：注册服务器是存储和分发镜像的服务器。Docker Hub 是 Docker 官方提供的公共注册服务器。除了 Docker Hub，还可以搭建私有的注册服务器，例如 Docker 官方提供的开源项目 Docker Registry 或第三方的解决方案。</p>
</li>
<li><p>仓库名称（Repository Name）：仓库名称用于唯一标识一个仓库。它由用户名（如果是私有仓库还包括域名）、斜杠和仓库名称组成，例如 <code>username/repository</code> 或<code>domain.com/username/repository</code>。</p>
</li>
<li><p>标签（Tag）：标签用于标识仓库中的镜像的不同版本或变体。通过标签，可以区分不同的镜像，并拉取特定的版本。</p>
</li>
</ol>
<p>常见的 Docker Registry 操作包括：</p>
<ul>
<li><p>拉取镜像（Pull Image）：从注册服务器上拉取镜像到本地，以供使用或进一步构建容器。</p>
</li>
<li><p>推送镜像（Push Image）：将本地创建的镜像推送到注册服务器，以便其他人可以访问和使用。</p>
</li>
<li><p>搜索镜像（Search Image）：在注册服务器上搜索和浏览可用的镜像，以找到感兴趣的镜像。</p>
</li>
<li><p>删除镜像（Delete Image）：从注册服务器上删除不再需要的镜像，释放存储空间。</p>
</li>
</ul>
<p>使用 Docker Registry，你可以方便地共享和分发镜像，构建自己的镜像仓库，并进行版本控制和管理。无论是使用公共注册服务器还是搭建私有的注册服务器，Docker Registry 都是 Docker 生态系统中重要的组成部分之一。</p>
<blockquote>
<p>什么叫分发镜像？<br>分发镜像是指将 Docker 镜像从一个地方复制到另一个地方，以便其他用户可以访问和使用该镜像。</p>
<p>分发镜像的过程一般包括以下步骤：1）Dockerfile 构建镜像；2）打标签；3）推送到 Registry；4）拉取镜像。</p>
<p>分发镜像的好处包括：1）共享性；2）可移植性；3）版本控制：使用标签来管理镜像的不同版本，可以轻松回退到先前的版本或升级到新的版本。</p>
</blockquote>
<h2 id="2-Docker 的安装和配置"><a href="#2-Docker 的安装和配置" class="headerlink" title="2. Docker 的安装和配置"></a>2. Docker 的安装和配置 </h2><h3 id="2-1- 安装 Docker"><a href="#2-1- 安装 Docker" class="headerlink" title="2.1 安装 Docker"></a>2.1 安装 Docker</h3><p> 首先，需要安装 Docker 引擎。以下是在常见操作系统上安装 Docker 的步骤：</p>
<p><strong>Ubuntu</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install docker.io</span></span><br></pre></td></tr></table></figure>

<p><strong>Windows</strong></p>
<ol>
<li>前往 <a href="https://www.docker.com/products/docker-desktop">Docker 官方网站</a> 下载 Docker Desktop。</li>
<li>双击安装包并按照指示完成安装。可能需要更新 WSL，<strong>需要把 Windows 的更新计划打开</strong>，否则可能无法更新 WSL。</li>
</ol>
<h3 id="2-2- 配置 Docker"><a href="#2-2- 配置 Docker" class="headerlink" title="2.2 配置 Docker"></a>2.2 配置 Docker</h3><p>安装完成后，你可能需要进行一些配置。例如，你可以设置 Docker 镜像加速器以加快下载速度。以下是一个示例：</p>
<ol>
<li>打开 Docker 配置文件：</li>
</ol>
<ul>
<li><strong>Ubuntu</strong>：<code>/etc/docker/daemon.json</code></li>
<li><strong>MacOS</strong> / <strong>Windows</strong>：Docker Desktop 应用程序 &gt; Preferences &gt; Docker Engine</li>
</ul>
<ol start="2">
<li>如果文件不存在，创建它。然后，将以下内容添加到配置文件中：</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;https://your-mirror.example.com&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;insecure-registries&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>保存配置文件并重启 Docker 服务：</li>
</ol>
<ul>
<li><strong>Ubuntu</strong>：<ul>
<li><code>sudo systemctl daemon-reload</code></li>
<li><code>sudo systemctl restart docker</code></li>
</ul>
</li>
<li><strong>MacOS</strong> / <strong>Windows</strong>：在 Docker Desktop 应用程序中点击重启按钮。</li>
</ul>
<h2 id="3- 使用 Docker"><a href="#3- 使用 Docker" class="headerlink" title="3. 使用 Docker"></a>3. 使用 Docker</h2><h3 id="3-1- 运行容器"><a href="#3-1- 运行容器" class="headerlink" title="3.1 运行容器"></a>3.1 运行容器 </h3><p> 要运行一个容器，首先需要一个 Docker 镜像。可以从 Docker 仓库中获取现有的镜像，或者自己创建一个。以下是一个运行基于 Ubuntu 的容器的示例：</p>
<ol>
<li>拉取 Ubuntu 镜像：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker pull ubuntu</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>运行容器：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -it ubuntu /bin/bash</span></span><br></pre></td></tr></table></figure>

<p>这将以交互式终端的方式在 Ubuntu 容器中运行一个 bash shell。你可以在容器中执行任意命令。</p>
<ol start="3">
<li>退出容器：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">exit</span></span></span><br></pre></td></tr></table></figure>

<h3 id="3-2- 构建自定义镜像"><a href="#3-2- 构建自定义镜像" class="headerlink" title="3.2 构建自定义镜像"></a>3.2 构建自定义镜像 </h3><p> 使用 Dockerfile 可以构建自定义的 Docker 镜像。以下是一个简单的示例：</p>
<ol>
<li><p>创建一个新目录，例如 <code>myapp</code>，并在其中创建一个名为<code>Dockerfile</code> 的文件。</p>
</li>
<li><p>在 <code>Dockerfile</code> 中添加以下内容：</p>
</li>
</ol>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用较小的基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 维护者信息</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=<span class="string">&quot;Your Name &lt;your.email@example.com&gt;&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Vim 编辑器</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get install -y vim &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get clean &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装所需的软件包, 将多个 RUN 指令合并为一个（减小 image 的体积）</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install --no-cache-dir --upgrade pip setuptools wheel &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    pip install --no-cache-dir \</span></span><br><span class="line"><span class="language-bash">    langchain==0.0.162 \</span></span><br><span class="line"><span class="language-bash">    openai \</span></span><br><span class="line"><span class="language-bash">    fastapi \</span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地项目文件复制到容器中</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./ /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> ENV_VARIABLE_NAME=value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;/app/src/main.py&quot;</span>, <span class="string">&quot;--extra-arg&quot;</span>, <span class="string">&quot;value&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>以上示例使用了 python 作为基础镜像，并在容器中安装了一些软件包，设置了工作目录，复制了本地文件，并设置了环境变量和默认运行命令。</p>
<ol start="3">
<li>在 <code>Dockerfile</code> 所在的目录中打开终端，并构建镜像：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker build -t aigc/plugins:v1.0.0 .</span></span><br></pre></td></tr></table></figure>

<p>这将使用 <code>Dockerfile</code> 创建一个名为 <code>aigc/plugins</code> 的镜像，版本号为<code>v1.0.0</code>。</p>
<ol start="4">
<li>运行容器：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --restart=always -d --name aigc_plugins -p 8385:8385 \</span></span><br><span class="line"><span class="language-bash">    -v /home/aigc/mount/plugins/data/store:/app/store \</span></span><br><span class="line"><span class="language-bash">    -v /home/aigc/mount/plugins/data/cfg:/app/cfg aigc/plugins:v1.0.0 python /app/src/main.py \</span></span><br><span class="line"><span class="language-bash">    --ip 0.0.0.0 --port 8385 --url http://0.0.0.0:8383/v1/completions</span></span><br></pre></td></tr></table></figure>

<p>现在你可以在自定义镜像的容器中运行你的应用程序。</p>
<ol start="5">
<li>进入容器：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> -it aigc_plugins bash</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>删除容器：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">rm</span> -f aigc_plugins</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">rm</span> -f &lt;container-id&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>查看容器运行的日志，并保存到文件中：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker logs -f aigc_plugins | <span class="built_in">tee</span> -a aigc_plugins_logs.txt</span></span><br></pre></td></tr></table></figure>

<ol start="8">
<li>打包保存镜像：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker save -o aigc_plugins.tar aigc/plugins:v1.0.0</span></span><br></pre></td></tr></table></figure>

<ol start="9">
<li>加载本地镜像包：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker load -i aigc_plugins.tar</span></span><br></pre></td></tr></table></figure>

<h2 id="4-Docker-Volumes 与 Mount"><a href="#4-Docker-Volumes 与 Mount" class="headerlink" title="4. Docker Volumes 与 Mount"></a>4. Docker Volumes 与 Mount</h2><p>Docker Volumes（卷）是 Docker 中用于 <strong> 持久化数据 </strong> 的一种机制，它允许将主机上的目录或文件与容器内的路径进行映射，从而实现数据在容器和主机之间的共享和持久化存储。</p>
<h3 id="4-1- 创建 -Volume"><a href="#4-1- 创建 -Volume" class="headerlink" title="4.1 创建 Volume"></a>4.1 创建 Volume</h3><p>使用 <code>docker volume create</code> 命令可以创建一个新的 Volume。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume create my-volume</span></span><br></pre></td></tr></table></figure>

<p>上述命令将创建一个名为 <code>my-volume</code> 的新 Volume。Docker 会在宿主机的默认 Volume 存储位置上创建一个目录，用于保存 Volume 的数据。</p>
<blockquote>
<p>Where is Docker storing my data when I use a volume?</p>
</blockquote>
<p>使用 <code>docker volume inspect</code> 命令查看 Volume 存储位置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume inspect my-volume</span></span><br></pre></td></tr></table></figure>

<p>接着，你将看到如下信息：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;CreatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021-06-01T16:18:36Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Labels&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Mountpoint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/volumes/my-volume/_data&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my-volume&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p>Mountpoint 是数据在磁盘上的实际位置。请注意，在大多数机器上，您需要具有根访问权限才能从主机访问此目录。但是，这就是它所在的位置。</p>
</blockquote>
<h3 id="4-2- 容器中使用 -Volume"><a href="#4-2- 容器中使用 -Volume" class="headerlink" title="4.2 容器中使用 Volume"></a>4.2 容器中使用 Volume</h3><p>在运行容器时，可以使用 <code>-v</code> 或 <code>--mount</code> 参数将 Volume 挂载到容器内的路径上。</p>
<h4 id="4-2-1-v 参数卷挂载"><a href="#4-2-1-v 参数卷挂载" class="headerlink" title="4.2.1 -v 参数卷挂载"></a>4.2.1 -v 参数卷挂载</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d -v my-volume:/path/in/container my-image</span></span><br></pre></td></tr></table></figure>

<p>上述命令将创建一个基于 <code>my-image</code> 镜像的容器，并将名为 <code>my-volume</code> 的 Volume 挂载到容器内的 <code>/path/in/container</code> 路径上。</p>
<h4 id="4-2-2-–mount 参数卷挂载"><a href="#4-2-2-–mount 参数卷挂载" class="headerlink" title="4.2.2 –mount 参数卷挂载"></a>4.2.2 –mount 参数卷挂载 </h4><p> 使用 <code>--mount</code> 参数可以更细粒度地配置容器中的 Volume 挂载。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d --mount <span class="built_in">type</span>=volume,<span class="built_in">source</span>=my-volume,target=/path/in/container my-image</span></span><br></pre></td></tr></table></figure>

<p>在上述命令中，我们使用了 <code>--mount</code> 参数来指定挂载的类型和配置。<code>type=volume</code> 表示挂载类型为 Volume，<code>source=my-volume</code> 指定了要挂载的 Volume 的名称为 <code>my-volume</code>，<code>target=/path/in/container</code> 指定了挂载到容器内的路径为 <code>/path/in/container</code>。</p>
<p>除了指定挂载类型、Volume 名称和路径外，<code>--mount</code> 参数还可以接受其他选项，例如读写权限、文件系统类型等。下面是一个更详细的示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d --mount <span class="built_in">type</span>=volume,<span class="built_in">source</span>=my-volume,target=/path/in/container,ro,volume-opt=option=value my-image</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们添加了一些额外的选项。<code>ro</code> 表示将 Volume 挂载为只读（read-only），<code>volume-opt=option=value</code> 表示指定了额外的 Volume 选项。你可以根据需要使用适当的选项来满足挂载的要求。</p>
<p>使用 <code>--mount</code> 参数进行 Volume 挂载可以提供更多的灵活性和配置选项，例如指定挂载类型、读写权限、Volume 选项等。这使得我们能够更好地控制容器与 Volume 之间的数据交互。</p>
<h3 id="4-3- 挂载主机目录作为 -Volume"><a href="#4-3- 挂载主机目录作为 -Volume" class="headerlink" title="4.3 挂载主机目录作为 Volume"></a>4.3 挂载主机目录作为 Volume</h3><p>除了使用命名 Volume，还可以直接将主机上的目录或文件挂载为 Volume，即 <strong> 绑定挂载（Bind mounts）</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d -v /path/on/host:/path/in/container my-image</span></span><br></pre></td></tr></table></figure>

<p>上述命令将主机上的 <code>/path/on/host</code> 目录挂载到容器内的 <code>/path/in/container</code> 路径上。</p>
<blockquote>
<p>绑定挂载（Bind mounts）允许将主机文件系统上的特定路径直接挂载到容器内的路径上。<br>卷挂载（Volume mounts）通过使用 Docker 卷 (Volume) 将容器内的路径与主机上的路径进行关联。</p>
</blockquote>
<h3 id="4-4- 查看 -Volume"><a href="#4-4- 查看 -Volume" class="headerlink" title="4.4 查看 Volume"></a>4.4 查看 Volume</h3><p>使用 <code>docker volume ls</code> 命令可以列出所有已创建的 Volumes。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume <span class="built_in">ls</span></span></span><br></pre></td></tr></table></figure>

<p>上述命令将显示所有已创建的 Volumes 的列表，包括它们的名称和所在的路径。</p>
<h3 id="4-5- 删除 -Volume"><a href="#4-5- 删除 -Volume" class="headerlink" title="4.5 删除 Volume"></a>4.5 删除 Volume</h3><p>要删除一个不再需要的 Volume，可以使用 <code>docker volume rm</code> 命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume <span class="built_in">rm</span> my-volume</span></span><br></pre></td></tr></table></figure>

<p>上述命令将删除名为 <code>my-volume</code> 的 Volume。请注意，只有在没有任何容器使用该 Volume 时，才能成功删除。</p>
<h3 id="4-6-Volume-Mounts-Vs-Bind-Mounts"><a href="#4-6-Volume-Mounts-Vs-Bind-Mounts" class="headerlink" title="4.6 Volume Mounts Vs Bind Mounts"></a>4.6 Volume Mounts Vs Bind Mounts</h3><h4 id="4-6-1-Volume-Mounts 的特性"><a href="#4-6-1-Volume-Mounts 的特性" class="headerlink" title="4.6.1 Volume Mounts 的特性"></a>4.6.1 Volume Mounts 的特性 </h4><p> 卷挂载通过使用 Docker 卷 (Volume) 将容器内的路径与主机上的路径进行关联。Docker 卷是一种特殊的目录，用于存储容器中的数据。卷挂载具有以下特点：</p>
<ul>
<li><p><strong>主机位置</strong>：Docker 选择卷的主机位置，通常在宿主机上的特定目录中。</p>
</li>
<li><p><strong>数据持久化</strong>：Volume 提供了一种持久化存储数据的方式。即使容器被删除或重新创建，Volume 中的数据仍然保持不变。</p>
</li>
<li><p><strong>容器间数据共享</strong>：多个容器可以共享同一个 Volume，使得它们可以轻松地共享数据。</p>
</li>
<li><p><strong>与主机文件系统交互</strong>：通过将主机上的目录挂载为 Volume，容器可以访问主机的文件系统，方便与容器之外的环境交互。</p>
</li>
<li><p><strong>备份和迁移</strong>：使用 Volumes 可以方便地备份和迁移容器的数据，通过备份或迁移 Volume，可以快速复制或迁移整个容器的数据。</p>
</li>
<li><p><strong>卷驱动程序支持</strong>：卷挂载支持使用不同的卷驱动程序，例如本地主机文件系统、网络存储或其他存储后端。</p>
</li>
</ul>
<h4 id="4-6-2-Bind-Mounts 的特性"><a href="#4-6-2-Bind-Mounts 的特性" class="headerlink" title="4.6.2 Bind Mounts 的特性"></a>4.6.2 Bind Mounts 的特性 </h4><p> 绑定挂载允许将主机文件系统上的特定路径直接挂载到容器内的路径上。绑定挂载具有以下特点：</p>
<ul>
<li><p><strong>主机位置</strong>：您可以自行选择要挂载的主机路径，它可以是任何主机上的目录或文件。</p>
</li>
<li><p><strong>与主机文件系统实时同步</strong>：容器中的更改会实时反映在绑定挂载的主机路径上，反之亦然。</p>
</li>
<li><p><strong>灵活性</strong>：绑定挂载允许容器与宿主机之间进行更紧密的交互，方便开发人员对文件进行编辑、调试或测试。</p>
</li>
<li><p><strong>支持权限和访问控制</strong>：绑定挂载可以继承主机文件系统的权限设置，以控制容器对文件的读写权限。</p>
</li>
</ul>
<h4 id="4-6-3- 选择使用卷挂载还是绑定挂载"><a href="#4-6-3- 选择使用卷挂载还是绑定挂载" class="headerlink" title="4.6.3 选择使用卷挂载还是绑定挂载"></a>4.6.3 选择使用卷挂载还是绑定挂载</h4><table>
<thead>
<tr>
<th></th>
<th>命名卷 (Named Volumes)</th>
<th>绑定挂载 (Bind Mounts)</th>
</tr>
</thead>
<tbody><tr>
<td>主机位置</td>
<td>由 Docker 选择</td>
<td>由您决定</td>
</tr>
<tr>
<td>挂载示例 (使用 <code>--mount</code>)</td>
<td><code>type=volume,src=my-volume,target=/usr/local/data</code></td>
<td><code>type=bind,src=/path/to/data,target=/usr/local/data</code></td>
</tr>
<tr>
<td>容器内容填充新卷</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>支持卷驱动程序</td>
<td>是</td>
<td>否</td>
</tr>
</tbody></table>
<p>在选择使用卷挂载还是绑定挂载时，可以根据具体需求和场景来进行决策：</p>
<ul>
<li><p>如果需要数据持久性、跨容器共享和卷驱动程序支持，则应选择卷挂载。</p>
</li>
<li><p>如果需要与主机文件系统实时同步、灵活的文件访问和交互，则应选择绑定挂载。</p>
</li>
</ul>
<p>在实际应用中，根据不同的需求，卷挂载和绑定挂载可以结合使用，以满足容器与主机之间数据共享和交互的需求。</p>
<blockquote>
<p>容器内容填充新卷是指在使用卷挂载（Volume Mounts）时，如果目标卷是新创建的并且为空（即没有初始数据），<strong>容器启动时会将容器内的内容填充到新创建的卷中</strong>。</p>
<p>这意味着，如果使用一个新的、空的卷挂载到容器内的路径上，并且容器内的路径中有预先存在的数据，那么在容器启动时，这些数据会被复制到新的卷中，以便卷中具有与容器内部相同的初始数据。这样可以确保在容器重新创建或迁移时，新创建的卷具有与原始容器相同的初始状态。</p>
</blockquote>
<h2 id="5-Container-networking"><a href="#5-Container-networking" class="headerlink" title="5. Container networking"></a>5. Container networking</h2><blockquote>
<p>请记住，默认情况下，容器是独立运行的，对同一台机器上的其他进程或容器一无所知。那么，如何让一个容器与另一个容器通信呢？答案是网络（network）。如果将两个容器放在同一个网络上，它们就可以相互通信。</p>
</blockquote>
<h3 id="5-1- 容器网络特性"><a href="#5-1- 容器网络特性" class="headerlink" title="5.1 容器网络特性"></a>5.1 容器网络特性 </h3><p> 容器网络是 Docker 中一个重要的概念，它允许 <strong> 在容器之间建立网络连接和通信</strong>。通过容器网络，可以实现容器间的数据传输、服务发现和跨主机的容器通信等功能。以下是容器网络的一些关键点和特性：</p>
<ul>
<li><p><strong>网络命名空间 (Network Namespace)</strong>：每个容器都有自己独立的网络命名空间，使得容器可以拥有自己的网络栈，包括网络接口、IP 地址和路由表等。这样可以实现容器之间的网络隔离，避免网络冲突和干扰。</p>
</li>
<li><p><strong>虚拟以太网桥 (Virtual Ethernet Bridge)</strong>：Docker 使用虚拟以太网桥来连接容器和宿主机的网络。每个宿主机上的 Docker 守护进程会创建一个名为 docker0 的桥接接口，<strong>通过该接口与容器的网络命名空间相连</strong>。</p>
</li>
<li><p><strong>网络驱动程序 (Network Drivers)</strong>：Docker 提供了多种网络驱动程序，用于实现不同的网络功能和配置选项。默认情况下，Docker 使用桥接网络驱动程序 (Bridge Network Driver)，但还支持其他驱动程序，如 Overlay、Host、Macvlan 等，以满足不同的网络需求。</p>
</li>
<li><p><strong>容器间通信 </strong>：容器可以通过使用网络连接和端口来实现相互通信。<strong> 可以使用容器的 IP 地址、端口号或容器名称来访问其他容器上的服务</strong>。容器网络还支持多个容器共享同一个网络端口的负载均衡和服务发现功能。</p>
</li>
<li><p><strong>跨主机容器通信</strong>：通过使用网络驱动程序中的 Overlay 网络模式，可以在多个主机上创建一个虚拟网络，使得不同主机上的容器可以直接通信。这为构建分布式应用和容器编排平台（如 Docker Swarm 和 Kubernetes）提供了基础。</p>
</li>
<li><p><strong>外部网络访问</strong>：容器可以通过端口映射 (Port Mapping) 的方式将容器内部的服务暴露给外部网络。通过将容器的特定端口映射到宿主机上的端口，可以使得外部网络能够访问容器中的应用程序或服务。</p>
</li>
</ul>
<p>容器网络是 Docker 中实现容器间通信和与外部网络交互的重要机制。通过灵活配置和管理容器网络，可以构建具有高可用性、可伸缩性和弹性的容器化应用程序。</p>
<h3 id="5-2- 容器网络实践命令"><a href="#5-2- 容器网络实践命令" class="headerlink" title="5.2 容器网络实践命令"></a>5.2 容器网络实践命令 </h3><h4 id="5-2-1- 创建自定义容器网络"><a href="#5-2-1- 创建自定义容器网络" class="headerlink" title="5.2.1 创建自定义容器网络"></a>5.2.1 创建自定义容器网络</h4><p> 使用 <code>docker network create</code> 命令可以创建自定义的 Docker 网络。例如，创建一个名为 <code>my-network</code> 的自定义网络：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker network create my-network</span></span><br></pre></td></tr></table></figure>

<p>这将在 Docker 中创建一个新的网络，供容器使用。</p>
<h4 id="5-2-2- 运行容器并连接到网络"><a href="#5-2-2- 运行容器并连接到网络" class="headerlink" title="5.2.2 运行容器并连接到网络"></a>5.2.2 运行容器并连接到网络 </h4><p> 在创建容器时，可以使用 <code>--network</code> 参数将容器连接到指定的网络。例如，将一个容器连接到 <code>my-network</code> 网络：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --network my-network my-image</span></span><br></pre></td></tr></table></figure>

<p>这将在启动容器时将其连接到 <code>my-network</code> 网络，使得容器可以与该网络中的其他容器进行通信。</p>
<h4 id="5-2-3- 查看容器网络信息"><a href="#5-2-3- 查看容器网络信息" class="headerlink" title="5.2.3 查看容器网络信息"></a>5.2.3 查看容器网络信息 </h4><p> 使用 <code>docker network inspect</code> 命令可以查看特定网络的详细信息。例如，查看名为 <code>my-network</code> 的网络信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker network inspect my-network</span></span><br></pre></td></tr></table></figure>

<p> 这将显示与 <code>my-network</code> 相关的网络配置和容器列表等信息。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my-network&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;000f5e28bfcafa18622593e04dba1bc70c1bc9480a055c0a0bb2b8ec13039138&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Created&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-06-01T22:51:27.366486209-04:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bridge&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;EnableIPv6&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;IPAM&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;default&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Config&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;Subnet&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.18.0.0/16&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;Gateway&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.18.0.1&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Internal&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Attachable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Ingress&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ConfigFrom&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Network&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ConfigOnly&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Containers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Labels&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h4 id="5-2-4- 容器间通信"><a href="#5-2-4- 容器间通信" class="headerlink" title="5.2.4 容器间通信"></a>5.2.4 容器间通信 </h4><p> 容器可以通过使用容器名称或 IP 地址进行互相通信。例如，通过容器名称进行通信：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --name container1 --network my-network my-image</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --name container2 --network my-network my-image</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>container1</code> 和 <code>container2</code> 这两个容器可以通过彼此的名称进行通信。例如，通过 <code>ping</code> 命令测试容器之间的连通性：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> container1 ping container2</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>container1</code> 容器使用 <code>ping container2</code> 的命令来 ping <code>container2</code> 容器。由于容器名称在容器网络中被解析为相应容器的 IP 地址，因此可以直接使用容器名称来实现容器间的通信。</p>
<blockquote>
<p>通过使用容器名称进行通信，可以减少对容器 IP 地址的依赖，提高容器间通信的灵活性。注意，容器名称必须在同一网络中才能相互解析，因此需要将容器都连接到同一个网络中。</p>
</blockquote>
<h4 id="5-2-5- 端口映射"><a href="#5-2-5- 端口映射" class="headerlink" title="5.2.5 端口映射"></a>5.2.5 端口映射 </h4><p> 使用 <code>-p</code> 参数可以将容器内的端口映射到宿主机上，以使得外部网络可以访问容器中的服务。例如，将容器的 8080 端口映射到宿主机的 80 端口：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -p 80:8080 my-image</span></span><br></pre></td></tr></table></figure>

<p>这将使得宿主机上的 80 端口转发到容器内的 8080 端口，从而允许外部网络通过宿主机的 80 端口访问容器中的服务。</p>
<p>以上是一些与容器网络相关的实践命令和示例。通过灵活运用这些命令，可以有效管理和配置容器网络，实现容器间的通信和与外部网络的交互。</p>
<h2 id="6-Docker-Compose"><a href="#6-Docker-Compose" class="headerlink" title="6. Docker Compose"></a>6. Docker Compose</h2><p>Docker Compose 是一个用于定义和运行 <strong> 多个容器 </strong> 的工具。它使用一个 <code>docker-compose.yml</code> 文件来配置应用程序的服务、网络和卷。以下是一个示例：</p>
<ol>
<li>创建一个名为 <code>docker-compose.yml</code> 的文件，并在其中定义服务：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.9&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">aigc/plugins:v1.0.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">aigc_plugins</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my_network</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">python</span> <span class="string">/app/src/main.py</span> </span><br><span class="line">        <span class="string">--ip</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> </span><br><span class="line">        <span class="string">--port</span> <span class="number">8385</span> </span><br><span class="line">        <span class="string">--url</span> <span class="string">http://0.0.0.0:8383/v1/completions</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8385</span><span class="string">:8385</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/aigc/mount/plugins/data/store:/app/store</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/aigc/mount/plugins/data/cfg:/app/cfg</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">cpus:</span> <span class="string">&quot;0.5&quot;</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">1024M</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">my_network:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">plugins_net</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure>

<p>以上示例定义了一个名为 <code>plugins</code> 的服务，使用当前目录中的 <code>Dockerfile</code> 构建镜像。它将主机的 <code>8385</code> 端口映射到容器的 <code>8385</code> 端口，并将本地的 <code>./</code> 目录挂载到容器的 <code>/app</code> 目录，还设置了一个环境变量。</p>
<ol start="2">
<li>在包含 <code>docker-compose.yml</code> 文件的目录中打开终端，并运行服务：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker-compose up</span></span><br></pre></td></tr></table></figure>

<p>Docker Compose 将自动构建镜像并运行服务。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之二叉搜索树</title>
    <url>/posts/231020174358.html</url>
    <content><![CDATA[<p>二叉搜索树（Binary Search Tree，BST）是一种常见的数据结构，它具有以下特点：</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值。</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值。</li>
<li>它的左、右子树也分别为二叉搜索树。</li>
</ul>
<p>由于 BST 的特点，二叉搜索树的查找、插入和删除效率都很高（BST 足够「平衡」情况下）。</p>
<span id="more"></span>

<h2 id="二叉搜索树操作"><a href="# 二叉搜索树操作" class="headerlink" title="二叉搜索树操作"></a>二叉搜索树操作 </h2><p> 二叉搜索树是什么样子的呢？百闻不如一见，直接上图：</p>
<p><img src="/images/data-structure/BST-Tree1.png" alt=""></p>
<h2 id="插入一个节点"><a href="# 插入一个节点" class="headerlink" title="插入一个节点"></a>插入一个节点 </h2><p> 如果我们插入一个节点，它的值为 9，我们应该插在哪里呢？看图~</p>
<p><img src="/images/data-structure/BST-Tree2.png" alt=""></p>
<p>我们插入值 9 的过程大概是这样的：</p>
<ol>
<li>9 &gt; 根节点 7 吗？大于，则转向看右子树；</li>
<li>9 &gt; 根节点 10 吗？小于，则转向看左子树；</li>
<li>左子树为空，则将 9 插入在这里。</li>
</ol>
<p>看看，这是不是跟有序数组的二分查找算法的思想一样呢，根据值的大小关系，决定下次搜索的区域（但 BST 的判断不一定每次都会排除 50% 的区域，这要看 BST 是否足够「平衡」）！</p>
<h2 id="搜索一个节点"><a href="# 搜索一个节点" class="headerlink" title="搜索一个节点"></a>搜索一个节点</h2><p><img src="/images/data-structure/BST-Searching.png" alt=""></p>
<p>搜索一个节点的过程跟上面插入一个节点的过程类似：</p>
<ol>
<li>5 == 根节点 7 吗？不等于；大于吗？小于，则转向左子树搜索；</li>
<li>5 == 根节点 2 吗？不等于；大于吗？大于，则转向右子树搜索；</li>
<li>5 == 根节点 5 吗？等于，搜索成功。</li>
</ol>
<h2 id="遍历二叉搜索树"><a href="# 遍历二叉搜索树" class="headerlink" title="遍历二叉搜索树"></a>遍历二叉搜索树 </h2><p> 我们知道，二叉树的遍历有前序遍历、中序遍历和后续遍历以及层序遍历。它们有不同的特点：</p>
<ul>
<li>前序遍历：先遍历根节点，再遍历左右子树；</li>
<li>中序遍历：先遍历左子树，中间遍历根节点，最后遍历右子树；</li>
<li>后续遍历：先遍历左子树和右子树，最后遍历根节点；</li>
<li>层序遍历：从上到下、从左到右，按层遍历二叉树中的每一个节点。</li>
</ul>
<p>结合二叉搜索树的特点：左子树上所有结点的值均小于它的根结点的值 &amp; 右子树上所有结点的值均大于它的根结点的值。设想一下，如果我们先获取左子树的值，再获取根节点的值，最后再获取右子树的值，并将它们按获取顺序保存到数组中，那么这个数组是不是按升序排序的数组呢？</p>
<p>没错，<strong>二叉搜索树的中序遍历的结果是一个按升序排序的有序数组</strong>，所以二叉搜索树又称二叉排序树。</p>
<p>二叉搜索树的中序遍历过程图。<br><img src="/images/data-structure/BST-in-order-traversing.png" alt=""></p>
<h2 id="删除一个节点"><a href="# 删除一个节点" class="headerlink" title="删除一个节点"></a>删除一个节点 </h2><p> 删除节点也很容易，根据二叉搜索树的特点，我们删除一个节点后，只需要将这个节点的左子树的最大值（或者是右子树的最小值）拿过来，放到这个被删除的节点这里即可。这样，删除一个节点后，这棵树依然是一棵二叉搜索树。</p>
<p><img src="/images/data-structure/BST-delete-node.png" alt=""></p>
<p>上图的 BST 删除一个节点中，Fig. 1 -&gt; Fig. 2 使用了左子树的最大值，Fig. 1 -&gt; Fig. 3 使用了右子树的最小值。</p>
<h2 id="二叉搜索树接口实现"><a href="# 二叉搜索树接口实现" class="headerlink" title="二叉搜索树接口实现"></a>二叉搜索树接口实现 </h2><h3 id="定义 -BST- 结构"><a href="# 定义 -BST- 结构" class="headerlink" title="定义 BST 结构"></a> 定义 BST 结构</h3><p>BST 结构定义与普通二叉树结构定义没有区别。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode_t;</span><br></pre></td></tr></table></figure>

<h3 id="创建一个节点"><a href="# 创建一个节点" class="headerlink" title="创建一个节点"></a>创建一个节点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode_t* <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    TreeNode_t *newNode = (TreeNode_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode_t));</span><br><span class="line">    newNode-&gt;val = val;</span><br><span class="line">    newNode-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入一个节点（迭代实现）"><a href="# 插入一个节点（迭代实现）" class="headerlink" title="插入一个节点（迭代实现）"></a>插入一个节点（迭代实现）</h3><p>给定一棵 BST，插入一个节点的过程为：</p>
<ol>
<li>判断根节点是否为空：<ul>
<li>为空，则创建一个节点，并返回该节点。</li>
</ul>
</li>
<li>根节点不为空，则判断插入的节点值与根节点的大小关系：<ul>
<li>相等，则不需插入，直接返回根节点。</li>
<li>小于，则需要确定根节点是否有左子树：<ul>
<li>无左子树，则创建一个节点并将其作为根节点的左子树，插入节点结束。</li>
<li>有左子树，更新根节点为左孩子节点，继续执行步骤 2；</li>
</ul>
</li>
<li>大于，则需要确定根节点是否有右子树：<ul>
<li>无右子树，则创建一个节点并将其作为根节点的右子树，插入节点结束。</li>
<li>有右子树，更新根节点为右孩子节点，继续执行步骤 2；</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode_t* <span class="title function_">insertNode</span><span class="params">(TreeNode_t* root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> createNode(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode_t *curNode = root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curNode-&gt;val == val) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; curNode-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curNode-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                curNode-&gt;left = createNode(val);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curNode = curNode-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (curNode-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                curNode-&gt;right = createNode(val);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curNode = curNode-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入一个节点（递归实现）"><a href="# 插入一个节点（递归实现）" class="headerlink" title="插入一个节点（递归实现）"></a>插入一个节点（递归实现）</h3><p>通过插入节点的迭代实现可以看出，插入的过程本质上是插入的值与不同子树的根节点做大小比较的过程，并在合适的位置插入新节点。因此，我们也可以递归地实现插入节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode_t* <span class="title function_">insertNode</span><span class="params">(TreeNode_t* root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> createNode(val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;left = insertNode(root-&gt;left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;right = insertNode(root-&gt;right, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="搜索一个节点（迭代实现）"><a href="# 搜索一个节点（迭代实现）" class="headerlink" title="搜索一个节点（迭代实现）"></a>搜索一个节点（迭代实现）</h3><p>给定一棵 BST，搜素一个节点的过程为：</p>
<ol>
<li>判断根节点是否为空：<ul>
<li>为空，则搜索失败，返回 <code>NULL</code>。</li>
<li>不为空，判断值是否相等：<ul>
<li>相等，则搜索成功，返回当前节点。</li>
<li>不相等，则判断搜索值与根节点值的大小关系，更新根节点，并重复步骤 1。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode_t* <span class="title function_">searchNode</span><span class="params">(TreeNode_t* root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    TreeNode_t *curNode = root;</span><br><span class="line">    <span class="keyword">while</span> (curNode &amp;&amp; (val != curNode-&gt;val)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val &lt; curNode-&gt;val) &#123;</span><br><span class="line">            curNode = curNode-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curNode = curNode-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="搜索一个节点（递归实现）"><a href="# 搜索一个节点（递归实现）" class="headerlink" title="搜索一个节点（递归实现）"></a>搜索一个节点（递归实现）</h3><p>同样地，搜索一个节点也有递归实现方式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode_t* <span class="title function_">searchNode</span><span class="params">(TreeNode_t* root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span> || val == root-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> searchNode(root-&gt;left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchNode(root-&gt;right, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历 -BST"><a href="# 中序遍历 -BST" class="headerlink" title="中序遍历 BST"></a>中序遍历 BST</h3><p>就像上面说的，二叉搜索树的中序遍历的结果是一个按升序排序的有序数组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inOrderTraversal</span><span class="params">(TreeNode_t* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        inOrderTraversal(root-&gt;left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;val);</span><br><span class="line">        inOrderTraversal(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历也是递归实现？！二叉树的每一棵子树还是一棵二叉树，所以二叉树的很多操作都可以用递归的方式实现。</p>
<h3 id="查找 -BST- 的最小节点"><a href="# 查找 -BST- 的最小节点" class="headerlink" title="查找 BST 的最小节点"></a>查找 BST 的最小节点 </h3><p> 给定一棵 BST 或它的子树，有时需要查找它的最小节点（比如后面的删除一个节点时，就会用到这个函数哦）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode_t* <span class="title function_">findMinNode</span><span class="params">(TreeNode_t* root)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (root-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = root-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查找 -BST- 的最大节点"><a href="# 查找 -BST- 的最大节点" class="headerlink" title="查找 BST 的最大节点"></a>查找 BST 的最大节点 </h3><p> 给定一棵 BST 或它的子树，有时需要查找它的最大节点（比如后面的删除一个节点时，也可能用到这个函数哦）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode_t* <span class="title function_">findMaxNode</span><span class="params">(TreeNode_t* root)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (root-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查找前驱节点"><a href="# 查找前驱节点" class="headerlink" title="查找前驱节点"></a>查找前驱节点 </h3><p> 在 BST 中，一个节点的 <strong> 前驱节点定义为比该节点小的所有节点中的最大节点</strong>。换句话说，它是在中序遍历顺序中位于该节点之前的节点。</p>
<p>如何确定前驱节点呢？</p>
<ul>
<li>如果一个节点有左子树，那么左子树的最大值就是前驱节点；</li>
<li>如果一个节点没有左子树，那么它的前驱节点就是离它最近的拥有右子树的祖先节点；<ul>
<li><strong>确定方法 </strong>：从根节点搜，只要值比该节点的值小，它就<strong> 可能 </strong> 是前驱节点。通过在满足条件的情况下，不断更新这个节点（离它越来越近），最后就是前驱节点啦。</li>
</ul>
</li>
<li>如果一个节点既没有左子树也没有右子树，那么它没有前驱节点。</li>
</ul>
<blockquote>
<p>什么叫「离它最近的拥有右子树的祖先节点」呢？<br>举个例子，上面的那张图中，节点 5 没有右子树，离它最近的拥有右子树的节点是节点 2，节点 2 是节点 5 的祖先节点，所以 5 的前驱节点是 2。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode_t* <span class="title function_">predecessorNode</span><span class="params">(TreeNode_t* root, TreeNode_t* node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果节点有左子树，则前驱节点为左子树中的最右节点</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">        <span class="keyword">return</span> findMaxNode(node-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果节点没有左子树，则前驱节点为离它最近的拥有右子树的祖先节点</span></span><br><span class="line">    TreeNode_t* predecessor = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; node-&gt;val) &#123;</span><br><span class="line">            predecessor = root;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &gt; node-&gt;val) &#123;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> predecessor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数一为 BST 的根节点，参数二为 BST 的某一节点，即想要查找参数二的前驱节点，参数二也可以传入根节点哦。</p>
</blockquote>
<h3 id="查找后驱节点"><a href="# 查找后驱节点" class="headerlink" title="查找后驱节点"></a>查找后驱节点 </h3><p> 在 BST 中，一个节点的 <strong> 后驱节点定义为比该节点大的所有节点中的最小节点</strong>。换句话说，它是在中序遍历顺序中位于该节点之后的节点。</p>
<p>如何确定后驱节点呢？</p>
<ul>
<li>如果一个节点有右子树，那么右子树的最小值就是后驱节点；</li>
<li>如果一个节点没有右子树，那么它的后驱节点就是离它最近的拥有左子树的祖先节点；</li>
<li>如果一个节点既没有右子树也没有左子树，那么它没有后驱节点。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode_t* <span class="title function_">successorNode</span><span class="params">(TreeNode_t* root, TreeNode_t* node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果节点有右子树，则后驱节点为右子树中的最左节点</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">        <span class="keyword">return</span> findMinNode(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果节点没有右子树，则后驱节点为离它最近的拥有左子树的祖先节点</span></span><br><span class="line">    TreeNode_t* successor = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; node-&gt;val) &#123;</span><br><span class="line">            successor = root;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; node-&gt;val) &#123;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> successor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除一个节点（递归实现）"><a href="# 删除一个节点（递归实现）" class="headerlink" title="删除一个节点（递归实现）"></a>删除一个节点（递归实现）</h3><p>给定一棵 BST，删除一个节点的思路为：</p>
<ul>
<li>若待删除的值小于根节点的值，则在左子树中查找并删除；</li>
<li>若待删除的值大于根节点的值，则在右子树中查找并删除；</li>
<li>若待删除的值等于根节点的值，要看它有没有左、右子树：<ul>
<li>无左子树和右子树：直接删除；</li>
<li>仅有左子树，则只需更新根节点的地址为其左孩子的地址，并释放原根节点空间即可。</li>
<li>仅有右子树，则只需更新根节点的地址为其右孩子的地址，并释放原根节点空间即可。</li>
<li>既有左子树、又有右子树：<ul>
<li>找左子树的最大值节点, 将根节点的值替换它的值，并删除它（又一次调用删除一个节点的函数）；或者找右子树的最小值节点, 将根节点的值替换它的值，并删除它。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode_t* <span class="title function_">deleteNode</span><span class="params">(TreeNode_t* root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;left = deleteNode(root-&gt;left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找到要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有子节点的情况</span></span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            root = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 只有右子节点的情况</span></span><br><span class="line">            TreeNode_t* temp = root;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 只有左子节点的情况</span></span><br><span class="line">            TreeNode_t* temp = root;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 有两个子节点的情况</span></span><br><span class="line">            <span class="comment">// 找左子树的最大值, 替换并删除它; 或者找右子树的最小值, 替换并删除它</span></span><br><span class="line">            TreeNode_t* temp = findMinNode(root-&gt;right);</span><br><span class="line">            root-&gt;val = temp-&gt;val;</span><br><span class="line">            root-&gt;right = deleteNode(root-&gt;right, temp-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="销毁 -BST"><a href="# 销毁 -BST" class="headerlink" title="销毁 BST"></a>销毁 BST</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">destroyBST</span><span class="params">(TreeNode_t* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        destroyBST(root-&gt;left);</span><br><span class="line">        destroyBST(root-&gt;right);</span><br><span class="line">        <span class="built_in">free</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在销毁二叉搜索树后，我们要将根节点指针 <code>root</code> 设为 <code>NULL</code>，以防止在后续操作中误用已被释放的内存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">destroyBST(root);</span><br><span class="line">root = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<h2 id="BST- 完整代码测试"><a href="#BST- 完整代码测试" class="headerlink" title="BST 完整代码测试"></a>BST 完整代码测试 </h2><h3 id="完整代码"><a href="# 完整代码" class="headerlink" title="完整代码"></a> 完整代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode_t;</span><br><span class="line"></span><br><span class="line">TreeNode_t* <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    TreeNode_t *newNode = (TreeNode_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode_t));</span><br><span class="line">    newNode-&gt;val = val;</span><br><span class="line">    newNode-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode_t* <span class="title function_">insertNode</span><span class="params">(TreeNode_t* root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> createNode(val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;left = insertNode(root-&gt;left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;right = insertNode(root-&gt;right, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode_t* <span class="title function_">searchNode</span><span class="params">(TreeNode_t* root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span> || val == root-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> searchNode(root-&gt;left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchNode(root-&gt;right, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrderTraversal</span><span class="params">(TreeNode_t* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        inOrderTraversal(root-&gt;left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;val);</span><br><span class="line">        inOrderTraversal(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode_t* <span class="title function_">findMinNode</span><span class="params">(TreeNode_t* root)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (root-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = root-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode_t* <span class="title function_">findMaxNode</span><span class="params">(TreeNode_t* root)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (root-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode_t* <span class="title function_">predecessorNode</span><span class="params">(TreeNode_t* root, TreeNode_t* node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果节点有左子树，则前驱节点为左子树中的最右节点</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">        <span class="keyword">return</span> findMaxNode(node-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果节点没有左子树，则前驱节点为离它最近的拥有右子树的祖先节点</span></span><br><span class="line">    TreeNode_t* predecessor = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; node-&gt;val) &#123;</span><br><span class="line">            predecessor = root;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &gt; node-&gt;val) &#123;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> predecessor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode_t* <span class="title function_">successorNode</span><span class="params">(TreeNode_t* root, TreeNode_t* node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果节点有右子树，则后驱节点为右子树中的最左节点</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">        <span class="keyword">return</span> findMinNode(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果节点没有右子树，则后驱节点为离它最近的拥有左子树的祖先节点</span></span><br><span class="line">    TreeNode_t* successor = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; node-&gt;val) &#123;</span><br><span class="line">            successor = root;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; node-&gt;val) &#123;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> successor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode_t* <span class="title function_">deleteNode</span><span class="params">(TreeNode_t* root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;left = deleteNode(root-&gt;left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找到要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有子节点的情况</span></span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            root = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 只有右子节点的情况</span></span><br><span class="line">            TreeNode_t* temp = root;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 只有左子节点的情况</span></span><br><span class="line">            TreeNode_t* temp = root;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 有两个子节点的情况</span></span><br><span class="line">            <span class="comment">// 找左子树的最大值, 替换并删除它; 或者找右子树的最小值, 替换并删除它</span></span><br><span class="line">            TreeNode_t* temp = findMinNode(root-&gt;right);</span><br><span class="line">            root-&gt;val = temp-&gt;val;</span><br><span class="line">            root-&gt;right = deleteNode(root-&gt;right, temp-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyBST</span><span class="params">(TreeNode_t* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        destroyBST(root-&gt;left);</span><br><span class="line">        destroyBST(root-&gt;right);</span><br><span class="line">        <span class="built_in">free</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试代码"><a href="# 测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 规范化地打印二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printBinaryTree</span><span class="params">(TreeNode_t* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">    printBinaryTree(root-&gt;left);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; &lt;- %d -&gt; &quot;</span>, root-&gt;val);</span><br><span class="line">    printBinaryTree(root-&gt;right);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argv, <span class="type">char</span> *argc[])</span> &#123;</span><br><span class="line">    TreeNode_t* root = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试插入节点和搜索节点</span></span><br><span class="line">    root = insertNode(root, <span class="number">5</span>);</span><br><span class="line">    root = insertNode(root, <span class="number">3</span>);</span><br><span class="line">    root = insertNode(root, <span class="number">7</span>);</span><br><span class="line">    root = insertNode(root, <span class="number">2</span>);</span><br><span class="line">    root = insertNode(root, <span class="number">4</span>);</span><br><span class="line">    root = insertNode(root, <span class="number">6</span>);</span><br><span class="line">    root = insertNode(root, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    TreeNode_t* result = searchNode(root, <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Node found: %d\n&quot;</span>, result-&gt;val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Node not found\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = searchNode(root, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Node found: %d\n&quot;</span>, result-&gt;val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Node not found\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试中序遍历</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In-order traversal: &quot;</span>);</span><br><span class="line">    inOrderTraversal(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试查找最小值节点和最大值节点</span></span><br><span class="line">    TreeNode_t* minNode = findMinNode(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Minimum value: %d\n&quot;</span>, minNode-&gt;val);</span><br><span class="line"></span><br><span class="line">    TreeNode_t* maxNode = findMaxNode(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Maximum value: %d\n&quot;</span>, maxNode-&gt;val);</span><br><span class="line"></span><br><span class="line">    printBinaryTree(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试前驱节点和后继节点</span></span><br><span class="line">    TreeNode_t* node = searchNode(root, <span class="number">4</span>);</span><br><span class="line">    TreeNode_t* predecessor = predecessorNode(root, node);</span><br><span class="line">    <span class="keyword">if</span> (predecessor != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Predecessor of %d: %d\n&quot;</span>, node-&gt;val, predecessor-&gt;val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No predecessor for %d\n&quot;</span>, node-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node = searchNode(root, <span class="number">7</span>);</span><br><span class="line">    TreeNode_t* successor = successorNode(root, node);</span><br><span class="line">    <span class="keyword">if</span> (successor != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Successor of %d: %d\n&quot;</span>, node-&gt;val, successor-&gt;val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No successor for %d\n&quot;</span>, node-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试删除节点</span></span><br><span class="line">    root = deleteNode(root, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次中序遍历，检查删除是否成功</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In-order traversal after deletion: &quot;</span>);</span><br><span class="line">    inOrderTraversal(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁二叉搜索树</span></span><br><span class="line">    destroyBST(root);</span><br><span class="line">    root = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试结果"><a href="# 测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Node found: 6</span><br><span class="line">Node not found</span><br><span class="line">In-order traversal: 2 3 4 5 6 7 8</span><br><span class="line">Minimum value: 2</span><br><span class="line">Maximum value: 8</span><br><span class="line">(((&lt;- 2 -&gt;) &lt;- 3 -&gt; (&lt;- 4 -&gt;)) &lt;- 5 -&gt; ((&lt;- 6 -&gt;) &lt;- 7 -&gt; (&lt;- 8 -&gt;)))</span><br><span class="line">Predecessor of 4: 3</span><br><span class="line">Successor of 7: 8</span><br><span class="line">In-order traversal after deletion: 2 4 5 6 7 8</span><br></pre></td></tr></table></figure>

<blockquote>
<p>插入和搜索的迭代实现方式也验证了，没有问题。</p>
</blockquote>
<p>建立的这棵树是这样子的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       5</span><br><span class="line">     /   \</span><br><span class="line">    /     \</span><br><span class="line">   3       7</span><br><span class="line"> /   \   /   \</span><br><span class="line">2     4 6     8</span><br></pre></td></tr></table></figure>

<p>节点 4 的前驱节点是 3，节点 7 的后驱节点是 8，没有问题！</p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://github.com/kodecocodes/swift-algorithm-club/blob/master/Binary%20Search%20Tree/README.markdown">BST in swift-algorithm-club</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉搜索树</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之堆基础与堆结构（数组实现）</title>
    <url>/posts/231018102559.html</url>
    <content><![CDATA[<p>堆（Heap）是一类特殊的数据结构，是最高效的优先级队列。堆是用 <strong> 数组实现 </strong> 的<strong>完全 </strong> 二叉树，所以它没有使用父指针或者子指针，省内存。</p>
<span id="more"></span>

<blockquote>
<p>完全二叉树的形式是指除了最后一层之外，其他所有层的结点都是满的，而最后一层的所有结点都靠左边。</p>
</blockquote>
<h2 id="堆属性"><a href="# 堆属性" class="headerlink" title="堆属性"></a>堆属性 </h2><p><strong> 堆属性 </strong>：在最大堆中，父结点的值比每一个子结点的值都要大（可以等于）。在最小堆中，父结点的值比每一个子结点的值都要小（可以等于）。这就是所谓的「堆属性」，并且这个属性对堆中的<strong> 每一个结点 </strong> 都成立。</p>
<p>在一个最大堆中，最小元素一定在叶子结点中，但不能确定是哪一个；在一个最小堆中，最大元素一定在叶子结点中，但不能确定是哪一个。</p>
<p>下面是一个堆数据的二叉树模式图和紧凑数组模式图。<br>二叉树模式图：<br><img src="/images/data-structure/heap-tree-format-data.png" alt="堆的二叉树模式图"><br>紧凑数组模式图：<br><img src="/images/data-structure/heap-array-format-data.png" alt="堆的紧凑数组模式图"></p>
<blockquote>
<p>堆的根结点存放的是最大或者最小元素，但是 <strong> 其他结点的排序顺序是未知的，只是满足堆属性而已</strong>。</p>
</blockquote>
<h2 id="堆与普通树的区别"><a href="# 堆与普通树的区别" class="headerlink" title="堆与普通树的区别"></a>堆与普通树的区别</h2><ol>
<li><p><strong>结点顺序</strong>：在最大堆中，任一根结点都不小于其左、右子结点的值，而在二叉搜索树中，根结点一定大于其左结点的值，也一定小于其右结点的值。</p>
</li>
<li><p><strong>内存占用</strong>：普通树占用的内存比其存储的数据要多，因为要为每个结点对象及其左、右子结点指针分配内存，而堆仅仅使用一个数组存储数据，不需要指针。</p>
</li>
<li><p><strong>平衡</strong>：二叉搜索树时间复杂度为 <code>O(log n)</code> 的前提是树尽可能是平衡的。而堆中平衡不是问题，只要满足堆属性即可保证 <code>O(log n)</code> 的性能。</p>
</li>
<li><p><strong>搜索 </strong>：二叉搜索树中搜索很快，即二分查找 <code>O(log n)</code>。但是，在堆中搜索很慢，即遍历数组 <code>O(n)</code>，在堆中搜索不是第一优先级，因为<strong> 使用堆的目的是将最大（或者最小）的结点放在最前面，从而快速的进行相关插入、删除操作</strong>。</p>
</li>
</ol>
<h2 id="堆中父我子节点映射关系"><a href="# 堆中父我子节点映射关系" class="headerlink" title="堆中父我子节点映射关系"></a>堆中父我子节点映射关系 </h2><p><strong> 父我子结点映射关系</strong>：对于数组中索引为 $i$ 的结点（我），其父结点索引和左、右子结点在数组中的索引位置为如下：</p>
<p>$$<br>\begin{cases}<br>my(i) = i; \\<br>parent(i) = floor(\frac{i-1}{2}); \\<br>left(i) = 2i+1; \\<br>right(i) = 2i + 2 = left(i) + 1; \\<br>\end{cases}<br>$$</p>
<blockquote>
<p>所有结点的索引一定不能越界，即 $i \in [0, n-1]$。</p>
</blockquote>
<h2 id="堆数组元素大小关系"><a href="# 堆数组元素大小关系" class="headerlink" title="堆数组元素大小关系"></a>堆数组元素大小关系 </h2><p><strong> 数组关系</strong>：根据堆属性可知，在最大堆中有 $array[parent(i)] &gt;= array[i]$ ，在最小堆中有 $array[parent(i)] &lt;= array[i]$。</p>
<h2 id="堆的二叉树模式的高度"><a href="# 堆的二叉树模式的高度" class="headerlink" title="堆的二叉树模式的高度"></a>堆的二叉树模式的高度 </h2><p> 堆的形状一定是一棵 <strong> 完全 </strong> 二叉树。在堆中，在当前层级所有的结点都已经填满之前不允许开始下一层的填充。</p>
<p>一个有 $n$ 个结点的堆，其高度为 $h=floor(log_{2}{n})$。堆的前 $h-1$ 层结点数量为 $2^{h}-1$。堆的最后一层若填满的话，最后一层包含 $2^h$ 个结点，整个堆共有 $n=2^{h+1}-1$ 个结点。</p>
<p>叶结点总是位于数组的 $[floor(n/2), n-1]$ 区间，那么 <strong> 最后一个非叶子结点</strong>（最后一个内部结点）索引即 $floor(n/2)-1$。</p>
<blockquote>
<p>堆的高度从 0 层开始，空堆的高度为 -1，高度为 $h$ 的堆有 $h + 1$ 层（0 到 h 层）。</p>
</blockquote>
<h2 id="堆化（heapify）"><a href="# 堆化（heapify）" class="headerlink" title="堆化（heapify）"></a>堆化（heapify）</h2><p>「堆化」的目的是在堆进行插入或删除操作后，为了确保堆仍然是一个有效的最大堆或最小堆（仍然满足堆属性），需要进行一些必要的操作（上浮和下沉操作），这个过程就叫做堆化。</p>
<ol>
<li><code>shiftUp()</code>: If the element is greater (max-heap) or smaller (min-heap) than its parent, it needs to be swapped with the parent. This makes it move up the tree.</li>
<li><code>shiftDown()</code>. If the element is smaller (max-heap) or greater (min-heap) than its children, it needs to move down the tree.</li>
</ol>
<blockquote>
<p>上浮或下沉是一个递归过程，需要 <code>O(log n)</code> 时间。因为每次上浮或下沉都会选择一个子树、而抛弃另一个子树（上浮或下沉的次数最多为树的高度）。</p>
</blockquote>
<p>为什么在插入或删除时，会有上浮和下沉过程？</p>
<p>这是因为，删除操作时，会 pop 出堆顶的元素，<strong>并将堆数组的最后一个索引的元素填充到堆顶</strong>，这个操作会使得堆不再满足堆属性；而在插入操作时，会先将数据存储在堆数组的最后一个索引后面，插入的数据大小未知，也会导致堆不再满足堆属性。因此，在插入或删除操作执行后，需要进行堆化这一过程。</p>
<h2 id="数组实现堆数据结构"><a href="# 数组实现堆数据结构" class="headerlink" title="数组实现堆数据结构"></a>数组实现堆数据结构 </h2><h3 id="堆结构定义"><a href="# 堆结构定义" class="headerlink" title="堆结构定义"></a> 堆结构定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Heap</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *<span class="built_in">array</span>;     <span class="comment">// 堆的数组</span></span><br><span class="line">    <span class="type">int</span> size;       <span class="comment">// 堆的当前大小</span></span><br><span class="line">    <span class="type">int</span> capacity;   <span class="comment">// 堆的容量</span></span><br><span class="line">&#125; Heap_t;</span><br></pre></td></tr></table></figure>

<p>堆结构与之前的栈的结构类似，包括堆的最大容量、堆的当前大小（数据量）、存储数据的空间（数组）。</p>
<blockquote>
<p>这里，堆的数据成员使用一个指针，可以在创建不同的堆时，根据需要申请堆的容量；如果使用一个数组变量（如 <code>int array[MAX_CAPACITY]</code>），则在创建不同的堆时，无法修改堆的最大容量。<br>这里，堆的数据成员使用一个 <code>int *</code> 类型的指针，如果我们堆中存放的数据是复杂的组合数据，简单地修改数据成员的指针类型即可。</p>
</blockquote>
<h3 id="堆的初始化"><a href="# 堆的初始化" class="headerlink" title="堆的初始化"></a>堆的初始化 </h3><p> 堆的初始化，包括申请堆本身的内存空间和数据成员的内存空间两部分，以及对基本成员做初始化操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化堆</span></span><br><span class="line">Heap_t* <span class="title function_">initHeap</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Heap_t *heap = (Heap_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Heap_t));</span><br><span class="line">    heap-&gt;<span class="built_in">array</span> = (<span class="type">int</span> *)<span class="built_in">malloc</span>(capacity * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    heap-&gt;size = <span class="number">0</span>;</span><br><span class="line">    heap-&gt;capacity = capacity;</span><br><span class="line">    <span class="keyword">return</span> heap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取父节点索引"><a href="# 获取父节点索引" class="headerlink" title="获取父节点索引"></a>获取父节点索引 </h3><p> 根据上述的理论基础，我们知道当前节点 $i$ 的父节点的索引为 $parent(i) = floor(\frac{i-1}{2})$。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取节点的父节点索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getParentIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (index - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取左子节点索引"><a href="# 获取左子节点索引" class="headerlink" title="获取左子节点索引"></a>获取左子节点索引 </h3><p> 根据上述的理论基础，我们知道当前节点 $i$ 的左子节点的索引为 $left(i) = 2i+1$。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取节点的左子节点索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getLeftChildIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取右子节点索引"><a href="# 获取右子节点索引" class="headerlink" title="获取右子节点索引"></a>获取右子节点索引 </h3><p> 根据上述的理论基础，我们知道当前节点 $i$ 的右子节点的索引为 $right(i) = 2i+2$。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取节点的右子节点索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getRightChildIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (index &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆化之上浮操作"><a href="# 堆化之上浮操作" class="headerlink" title="堆化之上浮操作"></a>堆化之上浮操作 </h3><p> 在插入操作时，会先将数据存储在堆数组的最后一个索引后面，而插入的数据大小未知，会导致堆不再满足堆属性，需要进行堆化中的上浮操作，使堆数组重新满足堆属性。</p>
<p>首先，封装一个实现交换数组中两个位置的值的函数。这里，使用了异或运算的自反性，而没有使用临时变量的方式交换两个数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *<span class="built_in">array</span>, <span class="type">int</span> idx1, <span class="type">int</span> idx2)</span> &#123;</span><br><span class="line">    <span class="built_in">array</span>[idx1] = <span class="built_in">array</span>[idx1] ^ <span class="built_in">array</span>[idx2];</span><br><span class="line">    <span class="built_in">array</span>[idx2] = <span class="built_in">array</span>[idx1] ^ <span class="built_in">array</span>[idx2];</span><br><span class="line">    <span class="built_in">array</span>[idx1] = <span class="built_in">array</span>[idx1] ^ <span class="built_in">array</span>[idx2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在最大堆的堆化上浮操作中，如果当前索引对应的节点的值比其父节点的值大，则应该将两个节点进行交换，<strong>直到不满足当前节点比其父节点大或当前节点达到堆顶为止</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上浮操作，将节点移动到正确的位置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">siftUp</span><span class="params">(Heap_t *heap, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *<span class="built_in">array</span> = heap-&gt;<span class="built_in">array</span>;</span><br><span class="line">    <span class="type">int</span> parentIndex = getParentIndex(index);</span><br><span class="line">    <span class="keyword">while</span> ((index &gt; <span class="number">0</span>) &amp;&amp; (<span class="built_in">array</span>[index] &gt; <span class="built_in">array</span>[parentIndex])) &#123;</span><br><span class="line">        swap(<span class="built_in">array</span>, parentIndex, index);</span><br><span class="line">        index = parentIndex;  <span class="comment">// 交换节点后, 更新当前节点的位置</span></span><br><span class="line">        parentIndex = getParentIndex(index);  <span class="comment">// 重新获取父节点位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆化之下沉操作（迭代方式）"><a href="# 堆化之下沉操作（迭代方式）" class="headerlink" title="堆化之下沉操作（迭代方式）"></a>堆化之下沉操作（迭代方式）</h3><p>在删除操作时，会 pop 出堆顶的元素，并将堆数组的最后一个索引的元素填充到堆顶，这个操作会使得堆不再满足堆属性，需要进行堆化中的下沉操作 —— 将这个数放到合适它的位置，使堆数组重新满足堆属性。</p>
<p>在最大堆的堆化下沉操作中，当前索引对应的节点的值要跟它的左右孩子节点做比较，并跟两者中较大的孩子做位置替换，<strong>直到无需跟左右孩子节点替换（值比它俩都大）为止</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下沉操作，将节点移动到正确的位置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">siftDown</span><span class="params">(Heap_t *heap, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *<span class="built_in">array</span> = heap-&gt;<span class="built_in">array</span>;</span><br><span class="line">    <span class="type">int</span> size = heap-&gt;size;</span><br><span class="line">    <span class="type">int</span> leftChildIndex, rightChildIndex, maxIndex;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; size) &#123;</span><br><span class="line">        leftChildIndex = getLeftChildIndex(index);</span><br><span class="line">        rightChildIndex = getRightChildIndex(index);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接下来的两个判断为找出具有更大值的孩子的索引</span></span><br><span class="line">        maxIndex = index;</span><br><span class="line">        <span class="keyword">if</span> (leftChildIndex &lt; size &amp;&amp; <span class="built_in">array</span>[leftChildIndex] &gt; <span class="built_in">array</span>[maxIndex]) &#123;</span><br><span class="line">            maxIndex = leftChildIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightChildIndex &lt; size &amp;&amp; <span class="built_in">array</span>[rightChildIndex] &gt; <span class="built_in">array</span>[maxIndex]) &#123;</span><br><span class="line">            maxIndex = rightChildIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (maxIndex != index) &#123;</span><br><span class="line">            swap(<span class="built_in">array</span>, maxIndex, index);</span><br><span class="line">            index = maxIndex;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>while 循环处的条件其实为 true 也行, 代码里那么写是防止首次进入 while 循环时，便是非法的索引，这样可以少一次循环处理。</p>
</blockquote>
<h3 id="堆化之下沉操作（递归方式）"><a href="# 堆化之下沉操作（递归方式）" class="headerlink" title="堆化之下沉操作（递归方式）"></a>堆化之下沉操作（递归方式）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">siftDown</span><span class="params">(Heap_t* heap, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxIndex = index;</span><br><span class="line">    <span class="type">int</span> leftChildIndex = getLeftChildIndex(index);</span><br><span class="line">    <span class="type">int</span> rightChildIndex = getRightChildIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来的两个判断为找出具有更大值的孩子的索引</span></span><br><span class="line">    <span class="keyword">if</span> (leftChildIndex &lt; heap-&gt;size &amp;&amp; heap-&gt;<span class="built_in">array</span>[leftChildIndex] &gt; heap-&gt;<span class="built_in">array</span>[maxIndex]) &#123;</span><br><span class="line">        maxIndex = leftChildIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rightChildIndex &lt; heap-&gt;size &amp;&amp; heap-&gt;<span class="built_in">array</span>[rightChildIndex] &gt; heap-&gt;<span class="built_in">array</span>[maxIndex]) &#123;</span><br><span class="line">        maxIndex = rightChildIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index != maxIndex) &#123;</span><br><span class="line">        swap(heap-&gt;<span class="built_in">array</span>, maxIndex, index);</span><br><span class="line">        siftDown(heap, maxIndex);  <span class="comment">// 递归方式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取堆顶元素"><a href="# 获取堆顶元素" class="headerlink" title="获取堆顶元素"></a>获取堆顶元素</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取堆顶元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(Heap_t *heap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Heap is empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap-&gt;<span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入数据"><a href="# 插入数据" class="headerlink" title="插入数据"></a>插入数据 </h3><p> 在插入操作时，会 <strong> 先将数据存储在堆数组的最后一个索引后面 </strong>，而插入的数据大小未知，会导致堆不再满足堆属性，需要<strong> 进行堆化中的上浮操作</strong>，使堆数组重新满足堆属性。</p>
<p>下面的动画演示了插入 <code>2,7,26,25,19,17,1,90,3,36</code> 数据（创建堆并维持堆属性）的过程。<br><img src="/images/data-structure/heap-push.gif" alt="堆插入数据"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Heap_t *heap, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;size &gt;= heap-&gt;capacity) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Heap is full!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    heap-&gt;<span class="built_in">array</span>[heap-&gt;size] = value;  <span class="comment">// 存储在堆数组的最后一个索引后面</span></span><br><span class="line">    siftUp(heap, heap-&gt;size);  <span class="comment">// 进行堆化中的上浮操作</span></span><br><span class="line">    heap-&gt;size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果不希望遇到堆满的情况（希望在堆满时依然可以插入数据），则可以在堆满时进行动态扩容，并修改堆的容量。</p>
</blockquote>
<h3 id="删除堆顶数据"><a href="# 删除堆顶数据" class="headerlink" title="删除堆顶数据"></a>删除堆顶数据 </h3><p> 在删除操作时，会 pop 出堆顶的元素，并 <strong> 将堆数组的最后一个索引的元素填充到堆顶 </strong>，这个操作会使得堆不再满足堆属性，需要<strong> 进行堆化中的下沉操作</strong> —— 将这个数放到合适它的位置，使堆数组重新满足堆属性。</p>
<p>下面的动画演示了删除堆顶数据的过程。<br><img src="/images/data-structure/heap-pop.gif" alt="删除堆顶数据过程"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除堆顶元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Heap_t *heap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Heap is empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> top = heap-&gt;<span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    heap-&gt;<span class="built_in">array</span>[<span class="number">0</span>] = heap-&gt;<span class="built_in">array</span>[heap-&gt;size - <span class="number">1</span>];</span><br><span class="line">    heap-&gt;size--;</span><br><span class="line">    siftDown(heap, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除堆顶后的紧凑型数组模式图是这样的：<br><img src="/images/data-structure/heap-pop-after.png" alt="删除堆顶数据后"></p>
<h3 id="打印堆数据"><a href="# 打印堆数据" class="headerlink" title="打印堆数据"></a>打印堆数据</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印堆元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printHeap</span><span class="params">(Heap_t *heap)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Heap: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; heap-&gt;size; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, heap-&gt;<span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="销毁堆"><a href="# 销毁堆" class="headerlink" title="销毁堆"></a>销毁堆</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 销毁堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyHeap</span><span class="params">(Heap_t *heap)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(heap-&gt;<span class="built_in">array</span>);</span><br><span class="line">    <span class="built_in">free</span>(heap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆操作的时间复杂度"><a href="# 堆操作的时间复杂度" class="headerlink" title="堆操作的时间复杂度"></a>堆操作的时间复杂度 </h2><p> 堆的时间复杂度如下：</p>
<ul>
<li>插入元素到堆：<code>O(log n)</code></li>
<li>删除堆顶元素：<code>O(log n)</code></li>
<li>获取堆顶元素：<code>O(1)</code></li>
<li>「Floyd 上浮方式」构建堆：<code>O(n)</code></li>
<li>堆排序：<code>O(n*log n)</code></li>
<li>上浮操作：<code>O(n*log n)</code></li>
<li>下沉操作：<code>O(n*log n)</code></li>
</ul>
<blockquote>
<p>为什么构建堆的过程的时间复杂度为 <code>O(n)</code> 呢？</p>
</blockquote>
<h2 id="数组实现堆完整代码"><a href="# 数组实现堆完整代码" class="headerlink" title="数组实现堆完整代码"></a>数组实现堆完整代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *<span class="built_in">array</span>;     <span class="comment">// 堆的数组</span></span><br><span class="line">    <span class="type">int</span> size;       <span class="comment">// 堆的当前大小</span></span><br><span class="line">    <span class="type">int</span> capacity;   <span class="comment">// 堆的容量</span></span><br><span class="line">&#125; Heap_t;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *<span class="built_in">array</span>, <span class="type">int</span> idx1, <span class="type">int</span> idx2)</span> &#123;</span><br><span class="line">    <span class="built_in">array</span>[idx1] = <span class="built_in">array</span>[idx1] ^ <span class="built_in">array</span>[idx2];</span><br><span class="line">    <span class="built_in">array</span>[idx2] = <span class="built_in">array</span>[idx1] ^ <span class="built_in">array</span>[idx2];</span><br><span class="line">    <span class="built_in">array</span>[idx1] = <span class="built_in">array</span>[idx1] ^ <span class="built_in">array</span>[idx2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Heap_t* <span class="title function_">initHeap</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Heap_t *heap = (Heap_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Heap_t));</span><br><span class="line">    heap-&gt;<span class="built_in">array</span> = (<span class="type">int</span> *)<span class="built_in">malloc</span>(capacity * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    heap-&gt;size = <span class="number">0</span>;</span><br><span class="line">    heap-&gt;capacity = capacity;</span><br><span class="line">    <span class="keyword">return</span> heap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getParentIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (index - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getLeftChildIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getRightChildIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (index &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">siftUp</span><span class="params">(Heap_t *heap, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *<span class="built_in">array</span> = heap-&gt;<span class="built_in">array</span>;</span><br><span class="line">    <span class="type">int</span> parentIndex = getParentIndex(index);</span><br><span class="line">    <span class="keyword">while</span> ((index &gt; <span class="number">0</span>) &amp;&amp; (<span class="built_in">array</span>[index] &gt; <span class="built_in">array</span>[parentIndex])) &#123;</span><br><span class="line">        swap(<span class="built_in">array</span>, parentIndex, index);</span><br><span class="line">        index = parentIndex;  <span class="comment">// 交换节点后, 更新当前节点的位置</span></span><br><span class="line">        parentIndex = getParentIndex(index);  <span class="comment">// 重新获取父节点位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">siftDown</span><span class="params">(Heap_t* heap, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxIndex = index;</span><br><span class="line">    <span class="type">int</span> leftChildIndex = getLeftChildIndex(index);</span><br><span class="line">    <span class="type">int</span> rightChildIndex = getRightChildIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来的两个判断为找出具有更大值的孩子的索引</span></span><br><span class="line">    <span class="keyword">if</span> (leftChildIndex &lt; heap-&gt;size &amp;&amp; heap-&gt;<span class="built_in">array</span>[leftChildIndex] &gt; heap-&gt;<span class="built_in">array</span>[maxIndex]) &#123;</span><br><span class="line">        maxIndex = leftChildIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rightChildIndex &lt; heap-&gt;size &amp;&amp; heap-&gt;<span class="built_in">array</span>[rightChildIndex] &gt; heap-&gt;<span class="built_in">array</span>[maxIndex]) &#123;</span><br><span class="line">        maxIndex = rightChildIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index != maxIndex) &#123;</span><br><span class="line">        swap(heap-&gt;<span class="built_in">array</span>, maxIndex, index);</span><br><span class="line">        siftDown(heap, maxIndex);  <span class="comment">// 递归方式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(Heap_t *heap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Heap is empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap-&gt;<span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Heap_t *heap, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;size &gt;= heap-&gt;capacity) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Heap is full!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    heap-&gt;<span class="built_in">array</span>[heap-&gt;size] = value;  <span class="comment">// 存储在堆数组的最后一个索引后面</span></span><br><span class="line">    siftUp(heap, heap-&gt;size);  <span class="comment">// 进行堆化中的上浮操作</span></span><br><span class="line">    heap-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Heap_t *heap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Heap is empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> top = heap-&gt;<span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    heap-&gt;<span class="built_in">array</span>[<span class="number">0</span>] = heap-&gt;<span class="built_in">array</span>[heap-&gt;size - <span class="number">1</span>];</span><br><span class="line">    heap-&gt;size--;</span><br><span class="line">    siftDown(heap, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printHeap</span><span class="params">(Heap_t *heap)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Heap: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; heap-&gt;size; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, heap-&gt;<span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyHeap</span><span class="params">(Heap_t *heap)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(heap-&gt;<span class="built_in">array</span>);</span><br><span class="line">    <span class="built_in">free</span>(heap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">10</span>, capacity = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> nums[] = &#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">26</span>,<span class="number">25</span>,<span class="number">19</span>,<span class="number">17</span>,<span class="number">1</span>,<span class="number">90</span>,<span class="number">3</span>,<span class="number">36</span>&#125;;</span><br><span class="line">    Heap_t *heap = initHeap(capacity);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        push(heap, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printHeap(heap);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Heap top: %d\n&quot;</span>, peek(heap));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Heap pop: %d\n&quot;</span>, pop(heap));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Heap top: %d\n&quot;</span>, peek(heap));</span><br><span class="line">    printHeap(heap);</span><br><span class="line">    destroyHeap(heap);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Heap: 90 36 17 25 26 7 1 2 3 19</span><br><span class="line">Heap top: 90</span><br><span class="line">Heap pop: 90</span><br><span class="line">Heap top: 36</span><br><span class="line">Heap: 36 26 17 25 19 7 1 2 3</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://github.com/kodecocodes/swift-algorithm-club/tree/master/Heap">Heap in swift-algorithm-club</a></li>
<li><a href="https://visualgo.net/zh/heap">堆的动画制作网站</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之字典树</title>
    <url>/posts/230925185057.html</url>
    <content><![CDATA[<h2 id="什么是字典树"><a href="# 什么是字典树" class="headerlink" title="什么是字典树"></a>什么是字典树 </h2><p> 字典树，是一种 <strong> 以空间换时间 </strong> 的数据结构，又称 Trie 树、前缀树，是一种树形结构（字典树是一种数据结构），典型应用是统计、排序、和保存大量字符串（但不仅限于字符串）。所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</p>
<span id="more"></span>

<p><img src="/images/data-structure/trie-demo.png" alt="字典树示意图"></p>
<blockquote>
<p>可能大部分情况你很难直观或者有接触的体验，可能对前缀这个玩意没啥概念，可能做题遇到前缀问题也是暴力匹配蒙混过关，<strong>如果字符串比较少使用哈希表等结构可能也能蒙混过关，但如果字符串比较长、相同前缀较多，那么使用字典树可以大大减少内存的使用和效率 </strong>。<br> 一个字典树的应用场景：在 Google 搜索框输入部分单词下面会有一些神关联的搜索内容，你有时候都很神奇是怎么做到的，这其实就是字典树的一个思想。</p>
</blockquote>
<h2 id="字典树的性质"><a href="# 字典树的性质" class="headerlink" title="字典树的性质"></a>字典树的性质 </h2><p> 字典树是一种高效的数据结构，用于存储和快速检索字符串集合。它具有以下性质：</p>
<ol>
<li>字典树的 <strong> 根节点不包含任何字符</strong>，每个节点都代表一个字符，从根节点到叶节点的路径组成一个字符串。</li>
<li>每个节点可以包含 <strong> 多个子节点</strong>，每个子节点代表一个字符，节点之间的连接表示字符之间的关系。</li>
<li>每个节点的子节点通过不同的字符来标识，不同节点之间的路径上的字符不会重复。</li>
<li>字典树中的每个节点都可以 <strong> 存储一个附加值</strong>，用于表示该节点所代表的字符串的一些信息。</li>
<li>字典树可以 <strong> 高效地插入和查找字符串</strong>。插入操作将一个字符串的字符逐个添加到字典树中，查找操作根据给定的前缀或完整字符串，在字典树中检索相应的字符串。</li>
<li>字典树可以用于 <strong> 前缀匹配</strong>，例如，可以快速找到所有具有相同前缀的字符串。</li>
<li>字典树的 <strong> 空间复杂度相对较高</strong>，因为它需要为每个字符创建一个节点，但它可以通过压缩节点来减少空间占用。</li>
</ol>
<h2 id="设计实现字典树"><a href="# 设计实现字典树" class="headerlink" title="设计实现字典树"></a>设计实现字典树 </h2><p> 上面已经介绍了什么是字典树，那么我们开始设计一个字典树吧！</p>
<p>对于字典树，可能不同的场景或者需求设计上有一些细致的区别，但整体来说一般的字典树有创建、插入、查询（指定字符串）、查询（指定前缀）操作。</p>
<p>以 <a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">LeetCode 实现字典树 </a> 为例，实现字符集是 26 个英文小写字母的字典树的创建、插入、查询操作。</p>
<ul>
<li><code>trieCreate()</code> 初始化字典树对象。</li>
<li><code>void trieInsert(Trie *obj, char *word)</code> 向字典树中插入字符串<code>word</code>。</li>
<li><code>bool trieSearch(Trie *obj, char *word)</code> 搜索字符串 <code>word</code> 是否在字典树中。</li>
<li><code>bool trieStartsWith(Trie *obj, char *prefix)</code> 搜索字符串的前缀 <code>prefix</code> 是否在字典树中。</li>
</ul>
<h3 id="定义字典树类"><a href="# 定义字典树类" class="headerlink" title="定义字典树类"></a>定义字典树类 </h3><p> 字典树中的每一个节点，都是一个 <code>Trie</code> 类，而这个节点标识的字符可以是字符集中的任意一个字符。简单地，可以使用一个 <code>Trie</code> 类型数组（长度为字符集大小）来标识所有子节点。同时，为了表示该节点是否是某一个字符串的结束字符，可以添加一个布尔类型的结束标记 <code>isEnd</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUMS (26)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> *<span class="title">children</span>[<span class="title">NUMS</span>];</span>  <span class="comment">// 子节点指针数组，用于存储子节点的指针</span></span><br><span class="line">    <span class="type">bool</span> isEnd;  <span class="comment">// 表示当前节点是否为一个单词的结束节点</span></span><br><span class="line">    <span class="type">char</span> padding[<span class="number">7</span>];  <span class="comment">// 用于字节对齐的占位</span></span><br><span class="line">&#125; Trie;</span><br></pre></td></tr></table></figure>

<h3 id="字典树创建（初始化）"><a href="# 字典树创建（初始化）" class="headerlink" title="字典树创建（初始化）"></a>字典树创建（初始化）</h3><p>字典树有一个根节点，且字典树的根节点不包含任何字符。所以，我们需要初始化一个 <code>Trie</code> 类，并置空所有的子节点地址，以表示根节点不包含任何字符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Trie* <span class="title function_">trieCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    Trie *node = (Trie *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Trie));</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to create a trie node\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;sizeof(Trie) = %d\n&quot;, sizeof(Trie));  // x64, 216</span></span><br><span class="line">    <span class="built_in">memset</span>(node-&gt;children, <span class="number">0</span>, <span class="keyword">sizeof</span>(Trie));</span><br><span class="line">    node-&gt;isEnd = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用 <code>trieCreate()</code> 函数创建了节点 <code>node</code>，它不包含任何字符。</p>
<h3 id="字典树插入字符串"><a href="# 字典树插入字符串" class="headerlink" title="字典树插入字符串"></a>字典树插入字符串 </h3><p> 插入字符串的过程是逐个字符地搜索并检查它们是否存在于字典树中。如果某个字符不存在，则需要在上一个字符对应的节点上创建一个新的子节点，并将该节点指向新的字符（新的节点）。这样，就能够正确地构建出整个字符串在字典树中的路径。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trieInsert</span><span class="params">(Trie *obj, <span class="type">char</span> *word)</span> &#123;</span><br><span class="line">    Trie* curr = obj;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; word[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> index = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;children[index] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Trie* child = trieCreate();</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;failed to create a new trie\r\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr-&gt;children[index] = child;</span><br><span class="line">            curr-&gt;children[index]-&gt;isEnd = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将当前节点更新为新节点</span></span><br><span class="line">        curr = curr-&gt;children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将最后一个字符所在的节点标记为字符串的结尾</span></span><br><span class="line">    curr-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从根节点开始遍历字符串的每一个字符，然后根据字符计算出在子节点数组中的索引位置：</p>
<ul>
<li>如果该位置为空，则创建一个新的节点，并将该位置指向新节点；</li>
<li>然后，<strong>将当前节点更新为新节点</strong>，继续下一个字符的判断；</li>
<li>最后，将最后一个字符所在的节点标记为字符串的结尾，表示该字符串已经插入到字典树中。</li>
</ul>
<h3 id="字典树查询字符串"><a href="# 字典树查询字符串" class="headerlink" title="字典树查询字符串"></a>字典树查询字符串 </h3><p> 查询字符串的过程是在字典树已经建立好的情况下进行的。类似于插入过程，也是逐个字符地搜索并检查它们是否存在于字典树中（但不需要创建新的子节点）。如果在查询的过程中发现某个节点为空（未被初始化），则说明该字符串在字典树中不存在。如果成功遍历到最后一个字符所对应的节点，并且该节点标记为结束字符，则表明该字符串在字典树中存在；反之，如果最后一个字符对应的节点不是结束字符，则表明该字符串在字典树中不存在。所以 <strong> 在查询过程中，我们需要注意判断节点是否为空以及最后一个字符对应节点的结束字符标记</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">trieSearch</span><span class="params">(Trie *obj, <span class="type">char</span> *word)</span> &#123;</span><br><span class="line">    Trie* curr = obj;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; word[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> index = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;children[index] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr-&gt;isEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从根节点开始遍历字符串的每一个字符：</p>
<ul>
<li>首先，根据字符计算出在子节点数组中的索引位置：<ul>
<li>如果对应位置的子节点为空，则表示字典树中没有该字符串；</li>
<li>如果对应位置的子节点非空，则将当前节点更新为新节点，继续后续字符的判断；</li>
</ul>
</li>
<li>最后，根据结束字符的状态，返回字符串是否存在。</li>
</ul>
<h3 id="字典树前缀查询"><a href="# 字典树前缀查询" class="headerlink" title="字典树前缀查询"></a>字典树前缀查询 </h3><p> 前缀查询的过程也是在字典树已经建立好的情况下进行的。与查询字符串的过程类似，我们仍然是逐个字符地搜索并检查它们是否存在于字典树中。不同之处在于，前缀查询不需要判断前缀字符串的最后一个字符是否是结束字符，只要能成功遍历到最后一个字符，就可以确认该前缀字符串存在于字典树中。</p>
<blockquote>
<p>因为字典树的特点是每个节点都存储了字符集中的每个字符的子节点，所以只要前缀字符串中的每个字符都在字典树中存在对应的子节点，就可以确定该前缀字符串存在于字典树中。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">trieStartsWith</span><span class="params">(Trie *obj, <span class="type">char</span> *prefix)</span> &#123;</span><br><span class="line">    Trie* curr = obj;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; prefix[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> index = prefix[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;children[index] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字典树释放"><a href="# 字典树释放" class="headerlink" title="字典树释放"></a>字典树释放 </h3><p> 字典树释放的过程需要释放 <strong> 每个 </strong> 节点的 <strong> 所有子节点 </strong> 的空间。如果某个节点的子节点不为空，则需要继续深入该子节点，释放它的子节点的空间，直到最底层的叶子节点。然后再回溯到上一层节点，继续释放它的其他子节点，直到所有节点的空间都被释放完毕。所以字典树的释放过程是一个递归地释放每个节点的所有子节点的过程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trieFree</span><span class="params">(Trie *obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUMS; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj-&gt;children[i]) &#123;</span><br><span class="line">            trieFree(obj-&gt;children[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完整字典树代码"><a href="# 完整字典树代码" class="headerlink" title="完整字典树代码"></a>完整字典树代码 </h3><p> 上面的代码汇总在一起就是完整的字典树的最基础的版本了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUMS (26)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> *<span class="title">children</span>[<span class="title">NUMS</span>];</span>  <span class="comment">// 子节点指针数组，用于存储子节点的指针</span></span><br><span class="line">    <span class="type">bool</span> isEnd;  <span class="comment">// 表示当前节点是否为一个单词的结束节点</span></span><br><span class="line">    <span class="type">char</span> padding[<span class="number">7</span>];  <span class="comment">// 用于字节对齐的占位</span></span><br><span class="line">&#125; Trie;</span><br><span class="line"></span><br><span class="line">Trie* <span class="title function_">trieCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    Trie *node = (Trie *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Trie));</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to create a trie node\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;sizeof(Trie) = %d\n&quot;, sizeof(Trie));  // x64, 216</span></span><br><span class="line">    <span class="built_in">memset</span>(node-&gt;children, <span class="number">0</span>, <span class="keyword">sizeof</span>(Trie));</span><br><span class="line">    node-&gt;isEnd = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trieInsert</span><span class="params">(Trie *obj, <span class="type">char</span> *word)</span> &#123;</span><br><span class="line">    Trie* curr = obj;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; word[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> index = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;children[index] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Trie* child = trieCreate();</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;failed to create a new trie\r\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr-&gt;children[index] = child;</span><br><span class="line">            curr-&gt;children[index]-&gt;isEnd = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    curr-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">trieSearch</span><span class="params">(Trie *obj, <span class="type">char</span> *word)</span> &#123;</span><br><span class="line">    Trie* curr = obj;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; word[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> index = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;children[index] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr-&gt;isEnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">trieStartsWith</span><span class="params">(Trie *obj, <span class="type">char</span> *prefix)</span> &#123;</span><br><span class="line">    Trie* curr = obj;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; prefix[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> index = prefix[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;children[index] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trieFree</span><span class="params">(Trie *obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUMS; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj-&gt;children[i]) &#123;</span><br><span class="line">            trieFree(obj-&gt;children[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    Trie *root = trieCreate();</span><br><span class="line"></span><br><span class="line">    trieInsert(root, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line">    trieInsert(root, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search apple: %s\n&quot;</span>, trieSearch(root, <span class="string">&quot;apple&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search banana: %s\n&quot;</span>, trieSearch(root, <span class="string">&quot;banana&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search car: %s\n&quot;</span>, trieSearch(root, <span class="string">&quot;car&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search prefix bana: %s\n&quot;</span>, trieStartsWith(root, <span class="string">&quot;bana&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    trieFree(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度"><a href="# 复杂度" class="headerlink" title="复杂度"></a>复杂度 </h3><p> 时间复杂度：初始化为 $O(1)$，其余操作为 $O(|S|)$，其中 $|S|$ 是每次插入或查询的字符串的长度。</p>
<p>空间复杂度：$O(|T| \times \Sigma)$，其中 $|T|$ 为所有插入字符串的长度之和，$\Sigma$ 为字符集的大小。</p>
<h2 id="为什么根节点不包含任何字符"><a href="# 为什么根节点不包含任何字符" class="headerlink" title="为什么根节点不包含任何字符"></a>为什么根节点不包含任何字符 </h2><p> 字典树的根节点不包含任何字符是为了保持数据结构的一致性和简洁性。每个节点代表一个字符，根节点是整个字典树的起始点，它并不代表具体的字符。</p>
<ul>
<li>如果根节点包含一个字符，那么在插入和搜索操作时就需要额外的处理逻辑。例如，在搜索一个字符串时，需要先判断根节点的字符是否匹配，然后再进入下一层的子节点进行匹配。这样的处理逻辑会增加代码的复杂性。</li>
<li>而将根节点作为一个特殊的节点，不包含任何字符，可以简化操作。在搜索一个字符串时，直接从根节点开始匹配 <strong> 下一层的子节点</strong>（<code>node-&gt;children[x]</code>）即可，不需要额外的判断逻辑。这样的设计使得字典树的实现更加简单和统一。</li>
</ul>
<h2 id="为什么字典树空间复杂度相对较高"><a href="# 为什么字典树空间复杂度相对较高" class="headerlink" title="为什么字典树空间复杂度相对较高"></a>为什么字典树空间复杂度相对较高 </h2><p> 字典树是一种以空间换时间的数据结构（空间复杂度相对较高）。这是因为 <strong> 它需要存储每个节点的子节点指针 </strong>，具体来说，字典树的空间复杂度与字典树中存储的字符串数量和字符串的平均长度相关。<strong> 每个节点都需要存储一个指向下一个字符节点的指针</strong>，而每个字符串的字符数量会决定树的深度。因此，当字典树中包含大量的字符串或者字符串的平均长度较长时，字典树的空间复杂度就相对较高。</p>
<h2 id="哈希表实现的字典树"><a href="# 哈希表实现的字典树" class="headerlink" title="哈希表实现的字典树"></a>哈希表实现的字典树 </h2><p> 字典树基础班很容易，但很可能会出现一些延伸。</p>
<p>对于上面是 26 个字符的，我们很容易用 ASCII 找到对应索引，如果字符可能性比较多，用数组可能浪费的空间比较大，那我们也可以用哈希表实现字典树。使用哈希表替代数组，其实逻辑是一样的，只需要判断时候用哈希表判断是否存在对应的 key 即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uthash/src/uthash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    +-----------------------+</span></span><br><span class="line"><span class="comment">    |         Trie          |</span></span><br><span class="line"><span class="comment">    +-----------------------+</span></span><br><span class="line"><span class="comment">    |   ch                  |</span></span><br><span class="line"><span class="comment">    |   isEnd               |      +-----------------------+</span></span><br><span class="line"><span class="comment">    |   children            | ---&gt; |         Trie          |</span></span><br><span class="line"><span class="comment">    |   hh                  |      +-----------------------+</span></span><br><span class="line"><span class="comment">    +-----------------------+</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> *<span class="title">children</span>;</span></span><br><span class="line">    UT_hash_handle hh;</span><br><span class="line">&#125; Trie;</span><br><span class="line"></span><br><span class="line">Trie* <span class="title function_">trieCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    Trie *node = (Trie *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Trie));</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to create a trie node\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;ch = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    node-&gt;isEnd = <span class="literal">false</span>;</span><br><span class="line">    node-&gt;children = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trieInsert</span><span class="params">(Trie *root, <span class="type">char</span> *word)</span> &#123;</span><br><span class="line">    Trie *curr = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; word[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        Trie *child = <span class="literal">NULL</span>;</span><br><span class="line">        HASH_FIND(hh, curr-&gt;children, &amp;word[i], <span class="keyword">sizeof</span>(<span class="type">char</span>), child);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            child = trieCreate();</span><br><span class="line">            child-&gt;ch = word[i];</span><br><span class="line">            HASH_ADD(hh, curr-&gt;children, ch, <span class="keyword">sizeof</span>(<span class="type">char</span>), child);</span><br><span class="line">        &#125;</span><br><span class="line">        curr = child;</span><br><span class="line">    &#125;</span><br><span class="line">    curr-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">trieSearch</span><span class="params">(Trie *root, <span class="type">char</span> *word)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trie *curr = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; word[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        Trie *child = <span class="literal">NULL</span>;</span><br><span class="line">        HASH_FIND(hh, curr-&gt;children, &amp;word[i], <span class="keyword">sizeof</span>(<span class="type">char</span>), child);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr-&gt;isEnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">trieStartsWith</span><span class="params">(Trie *root, <span class="type">char</span> *prefix)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trie *curr = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; prefix[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        Trie *child = <span class="literal">NULL</span>;</span><br><span class="line">        HASH_FIND(hh, curr-&gt;children, &amp;prefix[i], <span class="keyword">sizeof</span>(<span class="type">char</span>), child);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trieFree</span><span class="params">(Trie *root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Trie *curr, *tmp;</span><br><span class="line">    HASH_ITER(hh, root-&gt;children, curr, tmp) &#123;</span><br><span class="line">        trieFree(curr-&gt;children);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    Trie *root = trieCreate();</span><br><span class="line"></span><br><span class="line">    trieInsert(root, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line">    trieInsert(root, <span class="string">&quot;+861**01[]&#x27;;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search apple: %s\n&quot;</span>, trieSearch(root, <span class="string">&quot;apple&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search +861**01[]&#x27;;/: %s\n&quot;</span>, trieSearch(root, <span class="string">&quot;+861**01[]&#x27;;/&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search car: %s\n&quot;</span>, trieSearch(root, <span class="string">&quot;car&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search prefix app: %s\n&quot;</span>, trieStartsWith(root, <span class="string">&quot;app&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    trieFree(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面为程序运行的结果。可以看到，使用哈希表实现字典树，可以处理的字符种类不再是仅限于英文字母。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Search apple: Found</span><br><span class="line">Search +861**01[]&#x27;;/: Found</span><br><span class="line">Search car: Not Found</span><br><span class="line">Search prefix app: Found</span><br></pre></td></tr></table></figure>

<p>关于 <code>HASH_FIND</code>、<code>HASH_ADD</code> 和 <code>HASH_ITER</code> 的使用可以看 <a href="https://troydhanson.github.io/uthash/userguide.html#_general_macros"> 这里</a>。</p>
<blockquote>
<p>参考连接：<a href="https://segmentfault.com/a/1190000040801084">https://segmentfault.com/a/1190000040801084</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>字典树</category>
      </categories>
      <tags>
        <tag>字典树</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
</search>
