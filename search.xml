<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C 语言之 const 关键字</title>
    <url>/posts/230913200729.html</url>
    <content><![CDATA[<p>宏定义 <code>#define</code> 和 <code>const</code> 关键字在 C 语言中有不同的用途：</p>
<ol>
<li>
<p><code>#define</code> 用于定义宏常量，它在编译前进行简单的文本替换，没有类型检查和作用域限制。宏常量的值可以是任意的表达式，包括函数调用和运算符操作，但容易导致代码的可读性和可维护性降低。</p>
</li>
<li>
<p><code>const</code> 关键字用于定义常量变量，具有类型检查和作用域限制的特性。常量变量的值在定义后不能被修改，提高了代码的可读性和可维护性。常量变量的作用域仅限于定义它的代码块内，其他代码块无法访问该常量。</p>
</li>
<li>
<p><code>const</code> 关键字还可以用于定义指向常量的指针、常量指针以及指向常量的常量指针。这些用法可以在编译阶段进行类型检查，避免了在运行时可能出现的错误。</p>
</li>
<li>
<p>编译器通常不会为 <em> 普通的</em> <code>const</code> 常量分配存储空间，而是将它们保存在符号表中，成为编译期间的常量。这样可以避免存储和读内存的操作，提高程序的执行效率。</p>
</li>
</ol>
<p>综上所述，虽然 <code>#define</code> 可以用于定义常量，但 <code>const</code> 关键字更加推荐，因为它提供了类型检查和作用域限制，提高了代码的可读性和可维护性，同时能够进行编译期间的优化。</p>
<span id="more"></span>
<h2 id="修饰常量变量（Constant-Variables）">修饰常量变量（Constant Variables）</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> var = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> var = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>这两种写法是等价的，都表示变量 <code>n</code> 的值不能被修改了。需要注意的是，用 <code>const</code> 修饰变量时，一定要给变量初始化，否则后续就不能赋值了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C program to demonstrate that constant variables can not be modified</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> var = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compilation error: assignment of read-only variable &#x27;var&#x27;</span></span><br><span class="line">    var = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="修饰常量字符串">修饰常量字符串</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>字符指针指向的字符串是不能修改的 </strong>：在 C 语言中，字符串常量是以<strong> 只读方式 </strong> 存储的，编译器会将其 <strong> 存储在只读的数据段 </strong> 中。而使用 <code>const</code> 关键字修饰的指针变量，会告诉编译器不允许通过该指针修改指向的数据。</p>
<p>如果没有 <code>const</code> 的修饰，我们可能会在后面有意无意的写 <code>str[0]='x'</code> 这样的语句，这样会导致对只读内存区域的赋值，然后程序会立刻异常终止。但是，有了 <code>const</code>，这个错误就能在程序被编译的时候被检查出来，这就是 <code>const</code> 的好处，让逻辑错误在编译期被发现。</p>
<h2 id="指针常量（Pointer-to-Constant）">指针常量（Pointer to Constant）</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* ptr;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *ptr;</span><br></pre></td></tr></table></figure>
<p>这两种写法是等价的。指针常量可以更改指针 <code>ptr</code> 的地址，以指向任何其他同类型的变量，但不能更改指针 <code>ptr</code> 指向的对象的值。指针常量中的指针被存储在读写区域（read-write area），在本例中为堆栈，所指向的对象可能位于只读区域或读写区域。</p>
<blockquote>
<p>简言之：指针（的地址）可变；指针地址不变的前提下，其指向的内容不可变。</p>
</blockquote>
<p>变量 <code>i</code> 是变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C program to demonstrate that the pointer to point to any other integer variable, </span></span><br><span class="line"><span class="comment">// but the value of the object (entity) pointed can not be changed</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">/* ptr is pointer to constant */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* ptr = &amp;i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line">    <span class="comment">/* error: object pointed cannot be modified using the pointer ptr */</span></span><br><span class="line">    <span class="comment">/* error: assignment of read-only location &#x27;*ptr&#x27; */</span></span><br><span class="line">    *ptr = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    ptr = &amp;j; <span class="comment">/* valid */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变量 <code>i</code> 本身就是常量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C program to demonstrate that the pointer to point to any other integer variable, </span></span><br><span class="line"><span class="comment">// but the value of the object (entity) pointed can not be changed</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* i is stored in read only area*/</span></span><br><span class="line">    <span class="type">int</span> <span class="type">const</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* pointer to integer constant. Here i</span></span><br><span class="line"><span class="comment">    is of type &quot;const int&quot;, and &amp;i is of</span></span><br><span class="line"><span class="comment">    type &quot;const int *&quot;. And ptr is of type</span></span><br><span class="line"><span class="comment">    &quot;const int *&quot;, types are matching no issue */</span></span><br><span class="line">    <span class="type">int</span> <span class="type">const</span>* ptr = &amp;i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* error: assignment of read-only location &#x27;*ptr&#x27; */</span></span><br><span class="line">    *ptr = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* valid. We call it up qualification. In</span></span><br><span class="line"><span class="comment">    C/C++, the type of &quot;int *&quot; is allowed to up</span></span><br><span class="line"><span class="comment">    qualify to the type &quot;const int *&quot;. The type of</span></span><br><span class="line"><span class="comment">    &amp;j is &quot;int *&quot; and is implicitly up qualified by</span></span><br><span class="line"><span class="comment">    the compiler to &quot;const int *&quot; */</span></span><br><span class="line"></span><br><span class="line">    ptr = &amp;j;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 C++ 中，不允许进行下限定（down qualification）操作，而在 C 中进行此操作可能会导致警告。下限定是指将已经限定了类型的变量赋值给没有限定类型的变量的情况。</p>
<p>在 C++ 和 C 中，上限定（up qualification）是允许的，不会引发警告或错误。上限定是指将没有限定类型的变量赋值给已经限定了类型的变量的情况。这意味着可以将一个没有限定类型的变量赋值给一个已经限定了类型的变量，而编译器会自动进行类型转换。上限定操作可以用于提升变量的类型精度或实现类型转换。例如，将一个整数赋值给一个浮点数变量，编译器会自动将整数转换为浮点数类型。</p>
</blockquote>
<p>下限定操作示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C program to demonstrate the down qualification</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="type">const</span> j = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ptr is pointing an integer object */</span></span><br><span class="line">    <span class="type">int</span>* ptr = &amp;i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The below assignment is invalid in C++, results in</span></span><br><span class="line"><span class="comment">    error In C, the compiler *may* throw a warning, but</span></span><br><span class="line"><span class="comment">    casting is implicitly allowed */</span></span><br><span class="line">    ptr = &amp;j;  <span class="comment">/* warning: assignment discards ‘const’ qualifier from pointer target type [-Wdiscarded-qualifiers] */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In C++, it is called &#x27;down qualification&#x27;. The type</span></span><br><span class="line"><span class="comment">    of expression &amp;j is &quot;const int *&quot; and the type of ptr</span></span><br><span class="line"><span class="comment">    is &quot;int *&quot;. The assignment &quot;ptr = &amp;j&quot; causes to</span></span><br><span class="line"><span class="comment">    implicitly remove const-ness from the expression &amp;j.</span></span><br><span class="line"><span class="comment">    C++ being more type restrictive, will not allow</span></span><br><span class="line"><span class="comment">    implicit down qualification. However, C++ allows</span></span><br><span class="line"><span class="comment">    implicit up qualification. The reason being, const</span></span><br><span class="line"><span class="comment">    qualified identifiers are bound to be placed in</span></span><br><span class="line"><span class="comment">    read-only memory (but not always). If C++ allows</span></span><br><span class="line"><span class="comment">    above kind of assignment (ptr = &amp;j), we can use &#x27;ptr&#x27;</span></span><br><span class="line"><span class="comment">    to modify value of j which is in read-only memory.</span></span><br><span class="line"><span class="comment">    The consequences are implementation dependent, the</span></span><br><span class="line"><span class="comment">    program may fail</span></span><br><span class="line"><span class="comment">    at runtime. So strict type checking helps clean code.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常量指针指向变量（Constant-Pointer-to-Variable）">常量指针指向变量（Constant Pointer to Variable）</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="type">const</span> ptr;</span><br></pre></td></tr></table></figure>
<p>上面的声明是一个指向整型变量的常量指针，这意味着我们可以改变该指针所指向的对象的值，但不能改变该指针指向另一个变量。</p>
<blockquote>
<p>简言之：指针（地址）是常量，不可变；指针指向的变量可变。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C program to demonstrate that the value of object pointed</span></span><br><span class="line"><span class="comment">// by pointer can be changed but the pointer can not point to another variable</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* constant pointer to integer */</span></span><br><span class="line">    <span class="type">int</span>* <span class="type">const</span> ptr = &amp;i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line"></span><br><span class="line">    *ptr = <span class="number">100</span>; <span class="comment">/* valid */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* error: assignment of read-only variable &#x27;ptr&#x27; */</span></span><br><span class="line">    ptr = &amp;j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常量指针指向常量（Constant-Pointer-to-Constant）">常量指针指向常量（Constant Pointer to Constant）</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> ptr;</span><br></pre></td></tr></table></figure>
<p>上面的声明是一个指向常量变量的常量指针，这意味着我们不能更改指针所指向的值，也不能将指针指向其他变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C program to demonstrate that value pointed by the</span></span><br><span class="line"><span class="comment">// pointer can not be changed as well as we cannot point the</span></span><br><span class="line"><span class="comment">// pointer to other variables</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* constant pointer to constant integer */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> ptr = &amp;i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr: %d\n&quot;</span>, *ptr);</span><br><span class="line"></span><br><span class="line">    ptr = &amp;j; <span class="comment">/* error: assignment of read-only variable &#x27;ptr&#x27; */</span></span><br><span class="line">    *ptr = <span class="number">100</span>; <span class="comment">/* error: assignment of read-only location &#x27;*ptr&#x27; */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>Type</th>
<th>Declaration</th>
<th>Pointer Value Change</th>
<th>Pointing Value Change</th>
</tr>
</thead>
<tbody>
<tr>
<td>Pointer to Variable</td>
<td><code>int *ptr</code></td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Pointer to Constant</td>
<td><code>const int *ptr</code></td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Pointer to Constant</td>
<td><code>int const *ptr</code></td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Constant Pointer to Variable</td>
<td><code>int* const ptr</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>Constant Pointer to Constant</td>
<td><code>const int* const ptr</code></td>
<td>No</td>
<td>No</td>
</tr>
</tbody>
</table>
<p>注：</p>
<ol>
<li>
<p>Pointer Value Change（指向的值的改变），如 <code>*ptr = 100</code></p>
</li>
<li>
<p>Pointing Value Change（指针的值的改变），如 <code>ptr = &amp;a</code></p>
</li>
<li>
<p>如果 <code>const</code> 在 <code>*</code> 的左边，那么 <code>const</code> 可以与类型互换位置，如 <code>const int *ptr</code> 等价于 <code>int const *ptr</code></p>
</li>
<li>
<p>被 <code>const</code> 修饰的变量，地址不可变还是值不可变，傻傻分不清？观察 <code>const</code> 靠近普通类型还是靠近指针类型：</p>
<ul>
<li>如果 <code>const</code> 靠近的是普通类型，那么常量变量的值不可变，指针地址可变，如 <code>const int *ptr</code>，<code>int const *ptr</code></li>
<li>如果 <code>const</code> 靠近的是指针类型，那么指针指向的基本类型的值可变，指针地址不可变，如 <code>int* const ptr</code></li>
</ul>
</li>
<li>
<p><strong>指针常量与常量指针记忆方法</strong>：只保留 <code>const</code> 和 <code>*</code>，从右往左读，如下：</p>
<ul>
<li><s>int</s> *<s>ptr</s>指针变量</li>
<li>const <s>int</s> *<s>ptr</s>指针常量</li>
<li><s>int</s> const *<s>ptr</s>指针常量</li>
<li><s>int</s>* const <s>ptr</s>常量指针</li>
<li>const <s>int</s>* const <s>ptr</s>常量指针指向常量变量</li>
</ul>
</li>
</ol>
<blockquote>
<p>参考链接：<a href="https://www.geeksforgeeks.org/const-qualifier-in-c/">https://www.geeksforgeeks.org/const-qualifier-in-c/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>const关键字</tag>
        <tag>下限定</tag>
        <tag>上限定</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之 main 函数参数</title>
    <url>/posts/230916171929.html</url>
    <content><![CDATA[<h2 id="指令行操作"> 指令行操作 </h2>
<p>C 语言支持从 CLI（指令行）传入参数给 main() 函数，多个命令行参数之间用空格分隔，但是如果参数本身带有空格，那么就使用双引号或单引号。</p>
<p>C 语言的 main 函数是程序的入口函数，它可以有两种形式的参数：</p>
<span id="more"></span>
<ol>
<li>
<p> 无参数形式：main 函数的原型可以是 <code>int main(void)</code>。这表示不接受任何参数，程序执行时不需要从命令行传递参数给 main 函数。</p>
</li>
<li>
<p> 带参数形式：main 函数的原型可以是 <code>int main(int argc, char *argv[])</code>。其中，<code>argc</code> 表示命令行参数的个数，而 <code>argv</code> 是一个字符串指针数组，每个元素都是一个命令行参数的字符串。</p>
<ul>
<li><code>argc</code> 标识传入的参数个数。如果没有提供任何参数，<code>argc</code> 将被设置为 1；否则，<code>argc</code> 将被设置为传入的参数个数加 1。</li>
<li><code>argv[0]</code> 通常是程序的名称或路径的字符串。</li>
<li><code>argv[1]</code> 到 <code>argv[argc - 1]</code> 是命令行传递给程序的参数，以空格分隔。</li>
</ul>
</li>
</ol>
<p> 值得注意的是，也可以使用 <code>char **argv</code> 来代替 <code>char *argv[]</code> 形参，两者具有相同的类型含义。因为数组变量名 <code>argv</code> 就是指向 <code>argv[]</code> 数组的第一个元素的指针，同时又因为第一个元素的数值就是一个指针，所以此时的数组变量名 <code>argv</code> 的本质就是一个指针的指针（双重指针）。</p>
<p> 下面是一个例子，演示如何使用带参数的 main 函数来接收命令行参数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;number of params: %d\n&quot;</span>, argc);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;param-%d: %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 如果编译并运行这个程序，并在命令行中输入参数，例如 <code>./a.out arg1 arg2 3 arg4</code>，则输出如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">number of params: 5</span><br><span class="line">param-0: ./a.out</span><br><span class="line">param-1: arg1</span><br><span class="line">param-2: arg2</span><br><span class="line">param-3: 3</span><br><span class="line">param-4: arg4</span><br></pre></td></tr></table></figure>
<p> 参考链接：<a href="https://is-cloud.blog.csdn.net/article/details/105347737">https://is-cloud.blog.csdn.net/article/details/105347737</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>main函数参数</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之 typedef 自定义类型基础</title>
    <url>/posts/230918174223.html</url>
    <content><![CDATA[<p><code>typedef</code> 关键字用于自定义数据类型的一个别名，或者称之为「定义了一种新的数据类型」。它可以有效简化定义一个复杂数据类型的代码实现。</p>
<span id="more"></span>
<h2 id="定义一种类型的别名">定义一种类型的别名</h2>
<p>定义一种类型的别名，而不只是简单的宏替换。例如，可以用作同时声明指针类型的 <strong> 多个对象</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* pa, pb;</span><br></pre></td></tr></table></figure>
<p>不符合意图，它只声明了一个指向字符变量的指针 <code>pa</code> 和一个字符变量<code>pb</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* PCHAR;</span><br><span class="line">PCHAR pa, pb;</span><br></pre></td></tr></table></figure>
<p>符合意图，同时声明了两个指向字符变量的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *pa, *pb;</span><br></pre></td></tr></table></figure>
<p>也符合意图，但相对来说没有用 <code>typedef</code> 的形式直观，尤其在需要大量指针的地方，<code>typedef</code> 的方式更省事。</p>
<h2 id="为结构体类型对象起别名">为结构体类型对象起别名</h2>
<p><code>typedef</code> 可以用在 <code>struct</code> 结构体中，为声明的 <code>struct</code> 结构体类型的对象起别名。</p>
<p><strong>声明 </strong> 结构体类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPOINT</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一般结构体变量的定义为 <code>struct struct_name obj_name</code>，如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPOINT</span> <span class="title">stCoor</span>;</span>  <span class="comment">// 定义一个结构体变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPOINT</span> *<span class="title">pstCoor</span> =</span> <span class="literal">NULL</span>; <span class="comment">// 定义一个结构体指针变量</span></span><br></pre></td></tr></table></figure>
<p><strong>定义 </strong> 结构体类型（而非定义结构体变量）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagPOINT</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125; stPOINT, *pstPOINT;</span><br></pre></td></tr></table></figure>
<p>使用 <code>typedef</code> 为 <code>struct</code> 声明的结构体类型起别名后，定义该结构体类型的变量时，可以不再书写 <code>struct</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">stPOINT stCoor;  <span class="comment">// 定义一个结构体变量</span></span><br><span class="line">pstPOINT pstCoor = <span class="literal">NULL</span>; <span class="comment">// 定义一个结构体指针变量</span></span><br><span class="line">stPOINT *pstCoor; <span class="comment">// 定义一个结构体指针变量</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面既有「声明」，又有「定义」，那声明结构体类型、定义结构体类型和定义结构体变量的区别：</p>
</blockquote>
<ul>
<li>
<p>声明结构体类型：只是指定了一个结构体的类型，它相当于一个模型，但其中并无具体数据，系统对之也 <strong> 不分配实际的内存单元</strong>。</p>
</li>
<li>
<p>定义结构体类型：使用 <code>typedef</code> 为 <code>struct</code> 声明的结构体类型起别名后，即定义了一个结构体类型，但此时 <strong> 未分配内存单元</strong>。</p>
<ul>
<li>这里用定义一词，对应了本文最开始所说的，<code>typedef</code> 关键字用于定义了一种新的数据类型。</li>
</ul>
</li>
<li>
<p>定义结构体变量：其中有具体的数据，也为变量分配内存单元。</p>
</li>
</ul>
<h2 id="定义与平台无关的类型">定义与平台无关的类型</h2>
<p>例如，定义一个叫 <code>REAL</code> 的浮点类型，在目标平台上，让它表示最高精度类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> REAL;</span><br></pre></td></tr></table></figure>
<p>在不支持 <code>long double</code> 的平台上，改为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> REAL;</span><br></pre></td></tr></table></figure>
<p>在连 <code>double</code> 都不支持的平台上，改为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> REAL;</span><br></pre></td></tr></table></figure>
<p>也就是说，当跨平台时，只要修改 <code>typedef</code> 定义本身就行，不用对其他源码做任何修改。标准库就广泛使用了这个技巧，比如 <code>size_t</code>。</p>
<p>另外，因为 <code>typedef</code> 是定义了一种类型的别名，而不是简单的字符串替换，所以它比宏来得稳健（虽然有时候用宏也可以完成以上的用途）。</p>
<h2 id="右左原则">右左原则</h2>
<p>理解、简化复杂声明可用的「右左法则」：从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*func)(<span class="type">void</span> *p);</span><br></pre></td></tr></table></figure>
<p>上面的示例中，</p>
<ol>
<li>首先，找到变量名 <code>func</code>，外面有一对圆括号，而且左边是一个<code>*</code> 号，这说明 <code>func</code> 是一个指针；</li>
<li>然后，跳出这个圆括号，先看右边，又遇到圆括号，这说明 <code>(*func)</code> 是一个函数，所以 <code>func</code> 是一个指向这类函数的指针，即函数指针，这类函数具有 <code>void*</code> 类型的形参，返回值类型是<code>int</code>。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*func[<span class="number">5</span>])(<span class="type">int</span> *);</span><br></pre></td></tr></table></figure>
<p>上面的示例中，</p>
<ol>
<li>首先，找到变量名 <code>func</code>，右边是一个<code>[]</code> 运算符，说明 <code>func</code> 是具有 5 个元素的数组；</li>
<li>然后，遇到圆括号了，调转阅读方向，<code>func</code>的左边有一个 <code>*</code>，说明<code>func</code> 的元素是指针；
<ul>
<li>注意，这里的 <code>*</code> 不是修饰 <code>func</code>，而是修饰<code>func[5]</code> 的，原因是 <code>[]</code> 运算符优先级比 <code>*</code> 高，<code>func</code>先跟 <code>[]</code> 结合；</li>
</ul>
</li>
<li>最后，跳出这个括号，看右边，又遇到圆括号，说明 <code>func</code> 数组的元素是函数类型的指针，它指向的函数具有 <code>int*</code> 类型的形参，返回值类型为<code>int</code>。</li>
</ol>
<p>也可以记住这 2 个模式：</p>
<ul>
<li><code>type (*x)(....)</code> ——— 函数指针</li>
<li><code>type (*x)[]</code> ——— 数组指针</li>
</ul>
<h2 id="为复杂的声明定义一个新的简单的别名">为复杂的声明定义一个新的简单的别名</h2>
<p><code>typedef</code> 为复杂的声明定义一个新的简单的别名的方法是：在原来的声明里逐步用别名替换一部分复杂声明，如此循环，把带变量名的部分留到最后替换，得到的就是原声明的最简化版。</p>
<h3 id="示例一：函数指针数组">示例一：函数指针数组</h3>
<p>我们知道，<code>int *arr[5]</code> 表示 <code>arr</code> 是一个包含 5 个元素的数组，由于 <code>arr</code> 左边是一个 <code>*</code>，所以数组中的每个元素都是一个指针，是一个 <code>int</code> 类型的指针。</p>
<p>原声明：<code>int *(*a[5])(int, char*)</code>，变量名为 <code>a</code>。</p>
<p>这个声明中，<code>a</code> 也是一个数组，由于 <code>a</code> 左边是一个 <code>*</code>，所以数组中的元素也是指针，是什么指针呢？是一个返回类型为 <code>int*</code>、参数为<code>(int, char*)</code> 的函数指针。</p>
<p>所以，我们可以定义一个新的函数类型，它接受两个参数：一个是 <code>int</code> 类型，另一个是 <code>char*</code> 类型，返回一个 <code>int</code> 类型的指针，即 <code>typedef int *(*pFunc)(int, char*)</code></p>
<p>那么，原声明就变成了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pFunc a[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>这里，变量 <code>a</code> 是一个数组，数组中的每个元素都是一个函数指针，这个函数指针的返回类型为<code>int*</code>、参数为<code>(int, char*)</code>。</p>
<h3 id="示例二：函数指针数组">示例二：函数指针数组</h3>
<p>原声明：<code>void (*b[10]) (void (*)())</code>，变量名为 <code>b</code>。</p>
<p>这个声明也是一个函数指针数组，只不过不像示例一中的函数的入参是 <code>(int, char*)</code>，这个示例中函数的入参是另外一个函数指针 <code>void (*)()</code>，它指向的函数没有入参，返回值类型是 <code>void</code>。</p>
<p>为了简化声明，我们可以：</p>
<ol>
<li>先替换右边部分括号里的，即 <code>typedef void (*pFuncParam)()</code>，其中 <code>pFuncParam</code> 为别名一，定义了一个没有入参、返回值为 <code>void</code> 的函数指针；</li>
<li>再替换左边的变量 <code>b</code>，即 <code>typedef void (*pFunc)(pFuncParam)</code>，<code>pFunc</code> 为别名二，定义了一个入参为 <code>pFuncParam</code>、返回值为 <code>void</code> 的函数指针。</li>
</ol>
<p>那么，原声明就变成了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pFunc b[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>这里，变量 <code>b</code> 是一个数组，数组中的每个元素都是一个函数指针，这个函数指针的返回类型为<code>void</code>，参数为一个指向返回类型为<code>void</code>、没有入参的函数指针。</p>
<h3 id="示例三：数组指针">示例三：数组指针</h3>
<p>原声明：<code>double (*e)[9]</code>，变量名为 <code>e</code>。这是一个指针，它指向一个有 9 个元素的数组，元素类型为 <code>double</code>。这可以简化为 <code>typedef double (*pArr)[9]</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pArr e;</span><br></pre></td></tr></table></figure>
<p>这里，变量 <code>e</code> 是一个指针，它指向一个长度为 9 的数组，数组的元素类型是 <code>double</code>。</p>
<blockquote>
<p>示例一、二与示例三是有差别的，前者是数组（数组中的元素是指针），后者是指针（指针指向的是一个数组）。</p>
</blockquote>
<h2 id="函数指针和数组指针示例">函数指针和数组指针示例</h2>
<h3 id="函数指针">函数指针</h3>
<p>函数指针是指向函数的指针变量，它可以存储函数的地址。通过函数指针可以在程序运行时动态地调用不同的函数。函数指针的声明方式为：<code>data_type (*pointer_var_name)(param_list)</code>。</p>
<p>以下是一个函数指针的示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*pFunc)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>; <span class="comment">// 定义一个函数指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    pFunc ptr = add; <span class="comment">// 指向 add 函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2 + 3 = %d\n&quot;</span>, ptr(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 调用 add 函数</span></span><br><span class="line"></span><br><span class="line">    ptr = subtract; <span class="comment">// 指向 subtract 函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;5 - 2 = %d\n&quot;</span>, ptr(<span class="number">5</span>, <span class="number">2</span>)); <span class="comment">// 调用 subtract 函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组指针">数组指针</h3>
<p>数组指针是指向数组的指针变量，它可以存储数组的地址。通过数组指针可以访问数组的元素。数组指针的声明方式为：<code>data_type (*pointer_var_name)[array_length]</code>。</p>
<p>以下是一个数组指针的示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*pArr)</span>[5]; <span class="comment">// 定义一个数组指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    pArr ptr = &amp;arr; <span class="comment">// 指向 arr 数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, (*ptr)[i], *((<span class="type">int</span> *)ptr + i)); <span class="comment">// 通过数组指针访问数组元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 <code>(*ptr)</code> 为什么要解引用？</p>
<p>这是因为，数组变量名 <code>arr</code> 表示的就是数组的首地址，而在 <code>pArr ptr = &amp;arr</code> 中，<code>ptr</code> 表示指向数组首地址的地址（存储数组首地址的地址空间），所以要解引用来获取数组的首地址，才能访问数组中的数据。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>typedef</tag>
        <tag>右左原则</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之 typedef 实践</title>
    <url>/posts/230920172849.html</url>
    <content><![CDATA[<p>在 <a href="https://pursue26.github.io/posts/230918174223.html">C 语言之 typedef 自定义类型基础</a> 中介绍了 <code>typedef</code> 的使用，下面介绍一些 <code>typedef</code> 的实践。</p>
<span id="more"></span>
<h2 id="两大陷阱">两大陷阱</h2>
<h3 id="不是简单的字符串替换">不是简单的字符串替换</h3>
<p><code>typedef</code> 是定义了一种类型的新别名，不同于宏，它不是简单的字符串替换。</p>
<p>当 <code>const</code> 与 <code>typedef</code> 相结合时，如定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* PSTR;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mystrcmp</span><span class="params">(<span class="type">const</span> PSTR, <span class="type">const</span> PSTR)</span>;</span><br></pre></td></tr></table></figure>
<p><code>const PSTR</code> 实际上相当于指针常量 <code>const char*</code> 吗？</p>
<p>不是的，它实际上相当于 <code>char* const</code>。这是因为 <code>const</code> 给予了整个指针本身以常量性，也就是形成了常量指针。简单来说，记住当 <code>const</code> 和 <code>typedef</code> 一起出现时，<code>typedef</code> 不会是简单的字符串替换就行。</p>
<h3 id="与其它存储类关键字不共存">与其它存储类关键字不共存</h3>
<p><code>typedef</code> 在语法上是一个 <strong> 存储类关键字</strong>，虽然它并不真正影响对象的存储特性，但变量只能被一种储类的关键字修饰。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">static</span> <span class="type">int</span> SINT_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">auto</span> <span class="type">int</span> AINT_t;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">typedef</span> <span class="type">int</span> INT_t;</span><br></pre></td></tr></table></figure>
<p>上述代码中，有两个存储类关键字，会编译将失败，报错 error: multiple storage classes in declaration specifiers</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INT_t;</span><br><span class="line"><span class="type">static</span> INT_t a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>这种写法是合法的。</p>
<blockquote>
<p>其它存储类关键字有 <code>auto</code>、<code>extern</code>、<code>mutable</code>、<code>static</code>、<code>register</code> 等。</p>
</blockquote>
<h2 id="typedef、const 与 define 结合">typedef、const 与 define 结合</h2>
<p>示例 1：通常讲，<code>typedef</code> 要比 <code>define</code> 要好，<strong>特别是在有指针的场合</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> pStr2 char*</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* pStr1;</span><br><span class="line"></span><br><span class="line">pStr1 s1, s2;  </span><br><span class="line">pStr2 s3, s4;</span><br></pre></td></tr></table></figure>
<p>在上述的变量定义中，<code>s1</code>、<code>s2</code>、<code>s3</code>都被定义为 <code>char *</code>，而<code>s4</code> 则定义成了 <code>char</code>，不是我们所预期的指针变量，根本原因就在于<code>define</code> 只是简单的字符串替换而 <code>typedef</code> 则是为一个类型起新名字。</p>
<p>示例 2：当 <code>const</code> 和<code>typedef</code>一起出现时，<code>typedef</code>不会是简单的字符串替换。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* pStr;</span><br><span class="line"><span class="type">char</span> s[<span class="number">4</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *p1 = s;</span><br><span class="line"><span class="type">const</span> pStr p2 = s; <span class="comment">// 实际为 char* const p2 = s;</span></span><br><span class="line"></span><br><span class="line">p1++;  <span class="comment">// 指针常量的指针可变</span></span><br><span class="line">p2++;  <span class="comment">// 编译报错, 常量指针的指针不可变</span></span><br><span class="line">*p1 = <span class="string">&#x27;m&#x27;</span>;  <span class="comment">// 编译报错, 指针常量的值不可变</span></span><br><span class="line"></span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">s[<span class="number">1</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s = %s, %c\r\n&quot;</span>, s, *p1, *p2);  <span class="comment">//dec, e, d</span></span><br><span class="line">*p2 = <span class="string">&#x27;m&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s = %s, %c\r\n&quot;</span>, s, *p1, *p2);  <span class="comment">//mec, e, m</span></span><br></pre></td></tr></table></figure>
<p>示例中，</p>
<ul>
<li><code>const char *p1</code>是限定数据类型为 <code>char *</code> 的指针变量可变，指针变量指向的对象不可变，所以 <code>p1++</code> 正确；</li>
<li><code>p2++</code>出错了，这个问题再一次提醒我们：<code>typedef</code>和 <code>define</code> 不同，它不是简单的文本替换；</li>
<li><code>const pStr p2</code>并不等于 <code>const char *p2</code>，<code>const pStr p2</code> 和<code>const long x</code>本质上没有区别，都是对变量进行只读限制，只不过此处变量 <code>p2</code> 的数据类型是我们自己定义的，而不是系统固有类型。因此，<code>const pStr p2</code>的含义是：限定数据类型为 <code>char *</code> 的指针变量 <code>p2</code> 为只读，因此 <code>p2++</code> 错误。</li>
</ul>
<h2 id="抑制劣质代码">抑制劣质代码</h2>
<p>人们常常使用 <code>typedef</code> 来编写更美观和可读的代码。所谓美观，意指 <code>typedef</code> 能隐藏笨拙的语法构造以及平台相关的数据类型，从而增强可移植性以及未来的可维护性。在编程中使用 <code>typedef</code> 目的一般有两个，一个是给变量一个易记且意义明确的新名字，另一个是简化一些比较复杂的类型声明。</p>
<h3 id="定义易于记忆的类型名">定义易于记忆的类型名</h3>
<p><code>typedef</code> 使用最多的地方是创建易于记忆的类型名，用它来归档程序员的意图。类型出现在所声明的变量名字中，位于 <code>typedef</code> 关键字右边。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure>
<p>此声明定义了一个 <code>int</code> 的同义字，名字为 <code>size</code>。注意 <code>typedef</code> 并不创建新的类型，它仅仅为现有类型添加一个同义字。因此，你可以在任何需要 <code>int</code> 的上下文中使用 <code>size</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">measure</span><span class="params">(size *pSize)</span>;</span><br><span class="line">size <span class="built_in">array</span>[<span class="number">4</span>];</span><br><span class="line">size len = file.getlength();</span><br></pre></td></tr></table></figure>
<p><code>typedef</code> 还可以掩饰复合类型，如指针和数组。例如，你不用像下面这样重复定义有 81 个字符元素的数组：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> line[<span class="number">81</span>];</span><br><span class="line"><span class="type">char</span> text[<span class="number">81</span>];</span><br></pre></td></tr></table></figure>
<p>定义一个 <code>typedef</code>，每当要用到相同类型和大小的数组时，可以这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> Line[<span class="number">81</span>];</span><br><span class="line">Line text, secondline;</span><br><span class="line">getline(text);</span><br></pre></td></tr></table></figure>
<p>同样，也可以像下面这样隐藏指针语法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">char</span> *<span class="type">pstr_t</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mystrcmp</span><span class="params">(<span class="type">pstr_t</span>, <span class="type">pstr_t</span>)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>记住</strong>，不管什么时候，只要为指针声明 <code>typedef</code>，都要在最终的 <code>typedef</code> 名称中加一个 <code>const</code>，比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">char</span> *<span class="type">cpstr_t</span>;  <span class="comment">// 指针常量, 使得该指针可变, 而指针指向的对象不可变（只读）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* <span class="type">const</span> <span class="type">cpstr_t</span>;  <span class="comment">// 常量指针, 使得该指针不可变（只读）, 但指针指向的对象可变的</span></span><br></pre></td></tr></table></figure>
<h3 id="简化代码">简化代码</h3>
<p>上面讨论的 <code>typedef</code> 行为有点像 <code>define</code> 宏，用其实际类型替代同义字。不同点是 <code>typedef</code> 在编译时被解释，因此可以让编译器来应付超越预处理器能力的文本替换。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*PF)</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *)</span>;</span><br></pre></td></tr></table></figure>
<p>这个声明引入了 <code>PF</code> 类型作为函数指针的同义字，该函数有两个 <code>const char *</code> 类型的参数以及一个 <code>int</code> 类型的返回值。如果要使用下列形式的函数声明，那么上述这个 <code>typedef</code> 是不可或缺的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PF <span class="title function_">Register</span><span class="params">(PF pf)</span>;</span><br></pre></td></tr></table></figure>
<p><code>Register()</code> 的参数是一个 <code>PF</code> 类型的回调函数，返回某个函数的地址，其署名与先前注册的名字相同。下面我展示一下如果不用 <code>typedef</code>，我们是如何实现这个声明的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*Register (<span class="type">int</span> (*pf)(<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *))) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *); </span><br></pre></td></tr></table></figure>
<p>很少有程序员理解它是什么意思，更不用说这种费解的代码所带来的出错风险了。显然，这里使用 <code>typedef</code> 不是一种特权，而是一种必需。</p>
<p>持怀疑态度的人可能会问：“OK，还会有人写这样的代码吗？”，快速浏览一下揭示 <code>signal()</code> 函数的头文件 <code>&lt;csinal&gt;</code>，有一个同样接口的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// signal 原型</span></span><br><span class="line"><span class="type">void</span> (*signal(<span class="type">int</span> sig, <span class="type">void</span> (*func)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// typedef 优化后</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*pFun)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">pFun <span class="title function_">signal</span><span class="params">(<span class="type">int</span> sig, pFun func)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考链接：<a href="https://www.cnblogs.com/a-s-m/p/10995722.html">https://www.cnblogs.com/a-s-m/p/10995722.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>typedef</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之 uthash 哈希表基础</title>
    <url>/posts/230922172626.html</url>
    <content><![CDATA[<p>由于 C 语言本身不存在哈希，但当需要使用哈希表的时候，自己构建又会异常复杂。因此，我们可以调用开源的第三方库 <code>uthash.h</code>，<strong>这只是一个头文件</strong>。我们需要做的就是将头文件通过 <code>#include &quot;uthash.h&quot;</code> 引入到自己的项目中。由于 <code>uthash</code> 仅是头文件，因此没有可链接的库代码。</p>
<span id="more"></span>
<h2 id="uthash 简介">uthash 简介</h2>
<p>使用 <code>uthash</code> 添加、查找和删除通常是常数时间的操作，此哈希库的目标是简约、高效。它大约有 1000 行 C 代码，它会 <em> 自动内联</em>，因为它是作为宏实现的。</p>
<p><code>uthash</code> 还包括三个额外的头文件，主要提供链表、动态数组和动态字符串。</p>
<ul>
<li><code>utlist.h</code> 为 C 结构提供了链接列表宏。</li>
<li><code>utarray.h</code> 使用宏实现动态数组。</li>
<li><code>utstring.h</code> 实现基本的动态字符串。</li>
</ul>
<blockquote>
<p>内联是一种编译器优化，它将「函数调用」替换为「函数体的代码」。这样可以避免函数调用时所需的开销，从而提高性能。</p>
</blockquote>
<h2 id="uthash 的使用">uthash 的使用</h2>
<h3 id="初始化">初始化</h3>
<p>这里我们将 <code>id</code> 作为一个索引值，也就是键 key，将 <code>name</code> 作为值 value，它可以是任意复杂结构。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uthash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;                    <span class="comment">/* key */</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    UT_hash_handle hh;         <span class="comment">/* makes this structure hashable */</span></span><br><span class="line">&#125; HashItem;</span><br><span class="line"></span><br><span class="line">HashItem *hashTbl = <span class="literal">NULL</span>;    <span class="comment">/* important! initialize to NULL */</span></span><br></pre></td></tr></table></figure>
<p>注意：结构中一定要包含 <code>UT_hash_handle hh</code>（<code>hh</code>不需要初始化）。它可以命名为任何名称，但是一般都命名为 <code>hh</code>。</p>
<h3 id="添加">添加</h3>
<ul>
<li>
<p><code>HASH_ADD_INT</code>：表示添加的键值为整型，参数为 <code>(head, keyfield_name, item_ptr)</code>；</p>
</li>
<li>
<p><code>HASH_ADD_STR</code>：表示添加的键值为字符串类型，参数为 <code>(head, keyfield_name, item_ptr)</code>；</p>
</li>
<li>
<p><code>HASH_ADD_PTR</code>：表示添加的键值为指针类型，参数为 <code>(head, keyfield_name, item_ptr)</code>；</p>
</li>
<li>
<p><code>HASH_ADD</code>：表示添加的键值可以是任意类型，参数为 <code>(hh_name, head, keyfield_name, key_len, item_ptr)</code>。</p>
</li>
</ul>
<p>这些常见的宏的参数可以看 <a href="https://troydhanson.github.io/uthash/userguide.html#_convenience_macros"> 这里 </a>，一般性的宏（如<code>HASH_ADD</code>）的参数可以看<a href="https://troydhanson.github.io/uthash/userguide.html#_general_macros"> 这里</a>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add_user</span><span class="params">(<span class="type">int</span> user_id, <span class="type">char</span> *name)</span> &#123;</span><br><span class="line">    HashItem *hashNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加前先进行重复性检查，因为当把两个相同 key 值的结构体添加到哈希表中时会报错 */</span></span><br><span class="line">    HASH_FIND_INT(hashTbl, &amp;user_id, hashNode);  <span class="comment">/* id already in the hash? */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 只有在哈希中不存在 ID 的情况下，才创建该项目并将其添加；否则，只修改已经存在的结构 */</span></span><br><span class="line">    <span class="keyword">if</span> (hashNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      hashNode = (HashItem *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashItem));</span><br><span class="line">      hashNode-&gt;id = user_id;</span><br><span class="line">      HASH_ADD_INT(hashTbl, id, hashNode);  <span class="comment">/* id: name of key field */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(hashNode-&gt;name, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>HASH_ADD_INT</code> 函数中，</p>
<ul>
<li>第一个参数 <code>hashTbl</code> 是哈希表；</li>
<li>第二个参数 <code>id</code> 是键字段的名称；</li>
<li>第三个参数 <code>hashNode</code> 是指向要添加的结构的指针。</li>
</ul>
<h3 id="将指向哈希指针的指针传递给函数（重要）">将指向哈希指针的指针传递给函数（重要）</h3>
<p>在上面的例子中 <code>hashTbl</code> 是一个全局变量，但是如果调用者想将哈希指针传递给函数 <code>add_user</code> 怎么办？乍一看，您似乎可以简单地将 <code>hashTbl</code> 作为参数传递，但这行不通。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_user</span><span class="params">(HashItem *obj, <span class="type">int</span> user_id, <span class="type">char</span> *name)</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  HASH_ADD_INT(obj, id, hashNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正确地，你需要 <strong> 传递一个指向哈希指针的指针</strong>（a pointer to the hash pointer）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_user</span><span class="params">(HashItem **obj, <span class="type">int</span> user_id, <span class="type">char</span> *name)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  HASH_ADD_INT(*obj, id, hashNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>必须处理「指向哈希指针的指针」的原因很简单：散列宏会修改它（换句话说，它们修改指针地址本身，而不仅仅是它指向的内容）</strong>。</p>
<p>The reason it’s necessary to deal with a pointer to the hash pointer is simple: the hash macros modify it (in other words, they modify the <em>pointer itself</em> not just what it points to).</p>
<blockquote>
<p>假设哈希表 <code>hashTbl</code> 的指针（地址）是 <code>0x7fffd69b9a10</code>，那么通过运算符 <code>&amp;</code> 可以得到存放该地址的地址，假如为 <code>0x8defd69b9a26</code>，那么后续散列宏修改了哈希指针后，我们还可以通过地址 <code>0x8defd69b9a26</code> 指向的内容（哈希表的地址）来获取最新的哈希表地址。</p>
</blockquote>
<h3 id="查找">查找</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HashItem *<span class="title function_">find_user</span><span class="params">(<span class="type">int</span> user_id)</span> &#123;</span><br><span class="line">    HashItem *hashNode = <span class="literal">NULL</span>;</span><br><span class="line">    HASH_FIND_INT(hashTbl, &amp;user_id, hashNode);  <span class="comment">/* hashNode: output pointer */</span></span><br><span class="line">    <span class="keyword">return</span> hashNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>HASH_FIND_INT</code> 函数中，</p>
<ul>
<li>第一个参数 <code>hashTbl</code> 是哈希表；</li>
<li>第二个参数是 <code>user_id</code> 的地址（一定要传递地址）；</li>
<li>第三个参数 <code>hashNode</code> 是输出变量。</li>
</ul>
<p>当可以在哈希表中找到相应键值时，返回给定键的结构到 <code>hashNode</code>，当找不到时返回 <code>NULL</code> 到 <code>hashNode</code>。也就是说可以通过判断返回值是否为 <code>NULL</code> 来判断查找的键值是否存在于哈希表中。</p>
<h3 id="替换">替换</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">replace_user</span><span class="params">(HashItem *obj, HashItem *newHashNode)</span> &#123;</span><br><span class="line">    HashItem *oldHashNode = find_user(newHashNode-&gt;id);</span><br><span class="line">    <span class="keyword">if</span> (oldHashNode) &#123;</span><br><span class="line">        HASH_REPLACE_INT(hashTbl, id, newHashNode, oldHashNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HASH_REPLACE</code> 宏等效于 <code>HASH_ADD</code> 宏，<code>HASH_REPLACE</code> 会尝试查找和删除项目，如果找到并删除了一个项目，它将返回该项目的指针作为输出参数。</p>
<h3 id="删除">删除</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delete_user</span><span class="params">(HashItem *hashNode)</span> &#123;</span><br><span class="line">    HASH_DEL(hashTbl, hashNode);  <span class="comment">/* user: pointer to delete */</span></span><br><span class="line">    <span class="built_in">free</span>(hashNode);             <span class="comment">/* optional; it&#x27;s up to you */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>要从哈希表中删除结构，必须具有指向它的指针（如果只有键值，应该先执行 <code>HASH_FIND</code> 以获取结构的指针）。</p>
</li>
<li>
<p>这里 <code>hashTbl</code> 是哈希表，<code>hashNode</code> 是指向我们要从哈希表中删除的结构的指针。删除结构只是将其从哈希表中删除，并非 <code>free</code>，何时释放结构的选择完全取决于自己，<code>uthash</code> 永远不会释放您的结构。</p>
</li>
</ol>
<h3 id="迭代删除">迭代删除</h3>
<p>上面的「删除」只能从哈希表中删除指定的一个结构，如果想将所有结构从哈希表中删除，可以使用迭代删除操作。</p>
<p><code>HASH_ITER</code> 宏是一个删除安全的迭代构造，它扩展为一个简单的 <code>for</code> 循环。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delete_all</span><span class="params">()</span> &#123;</span><br><span class="line">    HashItem *curr = <span class="literal">NULL</span>, *tmp = <span class="literal">NULL</span>;</span><br><span class="line">    HASH_ITER(hh, hashTbl, curr, tmp) &#123;</span><br><span class="line">        HASH_DEL(hashTbl, curr);  <span class="comment">/* delete; users advances to next */</span></span><br><span class="line">        <span class="built_in">free</span>(curr);               <span class="comment">/* optional- if you want to free  */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="一次性删除">一次性删除</h4>
<p>如果你只想删除所有的结构（哈希结点），而不释放它们的内存空间或进行任何逐个元素的清理操作，你可以使用单个操作更高效地完成这个任务。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HASH_CLEAR(hh, hashTbl);</span><br></pre></td></tr></table></figure>
<p>之后，列表头（这里是 <code>hashTbl</code>）将被设置为 <code>NULL</code>。</p>
<blockquote>
<p>在 uthash 中，ut 是 unordered tables，即无序表。</p>
<p>上面全大写的宏，为了方便，有些也被我叫成了函数。</p>
<p>上面的代码，未做充分的指针为空判断，实际使用指针前，要先进行不为空判断。</p>
</blockquote>
<h2 id="uthash 的实践">uthash 的实践</h2>
<p>以 <a href="https://leetcode.cn/problems/two-sum/">LeetCode 两数之和 </a> 为例，介绍 <code>uthash.h</code> 哈希表的使用。</p>
<p>题目大意：从一个数组中找出两个索引不同的数，使得它们的和等于目标值，并返回这两个数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uthash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    UT_hash_handle hh;</span><br><span class="line">&#125; HashItem;</span><br><span class="line"></span><br><span class="line">HashItem *<span class="title function_">hashFindItem</span><span class="params">(HashItem **obj, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    HashItem *pEntry = <span class="literal">NULL</span>;</span><br><span class="line">    HASH_FIND_INT(*obj, &amp;key, pEntry);</span><br><span class="line">    <span class="keyword">return</span> pEntry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hashAddItem</span><span class="params">(HashItem **obj, <span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    HashItem *pEntry = hashFindItem(obj, key);</span><br><span class="line">    <span class="keyword">if</span> (pEntry == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pEntry = (HashItem *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashItem));</span><br><span class="line">        pEntry-&gt;key = key;</span><br><span class="line">        HASH_ADD_INT(*obj, key, pEntry);</span><br><span class="line">    &#125;</span><br><span class="line">    pEntry-&gt;val = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hashFree</span><span class="params">(HashItem **obj)</span> &#123;</span><br><span class="line">    HashItem *curr = <span class="literal">NULL</span>, *tmp = <span class="literal">NULL</span>;</span><br><span class="line">    HASH_ITER(hh, *obj, curr, tmp) &#123;</span><br><span class="line">        HASH_DEL(*obj, curr);  </span><br><span class="line">        <span class="built_in">free</span>(curr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *<span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    HashItem *hashTbl = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        <span class="comment">// 重要：传入的是指向哈希指针的指针</span></span><br><span class="line">        HashItem *hashNode = hashFindItem(&amp;hashTbl, nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (hashNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            hashAddItem(&amp;hashTbl, nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        HashItem *hashNode = hashFindItem(&amp;hashTbl, target - nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (hashNode &amp;&amp; hashNode-&gt;val != i) &#123;</span><br><span class="line">            *returnSize = <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> *ans = (<span class="type">int</span> *)<span class="built_in">malloc</span>((*returnSize) * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">            ans[<span class="number">0</span>] = i, ans[<span class="number">1</span>] = hashNode-&gt;val;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，我们定义了哈希表的查找、添加、释放接口，接口中的第一个参数均为指向哈希表指针的指针（二级指针），这是必须的。</p>
<ol>
<li>首先，在进行哈希操作前，先定义了一个哈希表 <code>hashTbl</code>，他是一个 <code>HashItem</code> 类型的指针；</li>
<li>然后，将数组中的键 - 值对（索引对应的值 - 索引）依次添加到哈希表中，并使用操作符 <code>&amp;</code> 获取指向哈希指针的指针；</li>
<li>最后，经过查找后，不再使用哈希表，这时通过释放接口，将哈希表中的所有哈希结点迭代地删除并释放对应的内存空间。</li>
</ol>
<p>如果哈希表的键值不是整形，而是字符类型呢，应该怎么使用呢？可以参考 <a href="https://pursue26.github.io/posts/230925185057.html#%20%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%AD%97%E5%85%B8%E6%A0%91"> 这里 </a> 的一个例子。</p>
<blockquote>
<p>源码地址：<a href="https://github.com/troydhanson/uthash">https://github.com/troydhanson/uthash</a></p>
</blockquote>
<blockquote>
<p>英文原版用户指导：<a href="https://troydhanson.github.io/uthash/userguide.html">https://troydhanson.github.io/uthash/userguide.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之一、二级指针</title>
    <url>/posts/240224193217.html</url>
    <content><![CDATA[<p>本文介绍了 C 语言中的一级指针和二级指针，并通过示例说明了为什么在函数参数中使用一级指针，函数内部对指针形参本身的修改不会影响外部指针的指向。同时，也演示了如何使用二级指针在函数内部改变指针的指向以及进行内存分配操作。</p>
<span id="more"></span>
<h1 id="概念">概念</h1>
<p>在如下的 A 指向 B、B 指向 C 的指向关系中，首先：</p>
<p>C 是一个变量，里面是「一段内容」，这段内容需要存储在一个地址空间里。C 的起始地址是 0x00000008。</p>
<p>B 是一个指针变量，其内容是 C 的地址 0x00000008（专业术语：B 指向 C），但是 B 本身也要占空间的啊，所以 B 也有地址。B 的起始地址是 0x00000004。</p>
<p>那么，到此为止都比较好理解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B == 0x00000008;   // B 的内容，也就是 C 的地址 0x00000008</span><br><span class="line">*B == 一段内容;    // B 解引用，也就是 B 指针指向的 C 的值</span><br><span class="line">&amp;B == 0x00000004;  // B 取地址，B 本身的地址是 0x00000004</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看指针变量 B，就是查看 B 的内容（这里是 C 的地址）。对指针变量 B 解引用，就是查看它的内容（内容是一个地址）下的内容。</p>
</blockquote>
<img src="../images/language-notes/second-rank-pointer.png" alt="指针访问" width="100%" height="100%">
<p>A 是二级指针变量，其中存放着 B 的地址 0x00000004。A 本身也有地址，是 0x00000000。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*A == B == 0x00000008;  // A 解引用，也就是 A 指针指向的 B 的内容（即 B 的内容是 C 的地址）</span><br><span class="line">**A == *B == 一段内容;  // B 解引用，也就是 B 指针指向的 C 的内容</span><br><span class="line">A == &amp;B == 0x00000004;  // A 存的是 B 的地址，B 的地址是 0x00000004</span><br><span class="line">&amp;A == 0x00000000;       // A 取地址，A 本身的地址是 0x00000000</span><br></pre></td></tr></table></figure>
<p>上面三个变量的 C 语言定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> c = <span class="number">123</span>;  <span class="comment">// 一段内容</span></span><br><span class="line"><span class="type">int</span> *b = &amp;c;</span><br><span class="line"><span class="type">int</span> **a = &amp;b;  <span class="comment">// 按顺序定义，定义二级指针前要定义一级指针</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;c, &amp;b, &amp;a = %p, %p, %p\n&quot;</span>, &amp;c, &amp;b, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c, b, a = %d, %p, %p\n&quot;</span>, c, b, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*b, *a, **a = %d, %p, %d\n&quot;</span>, *b, *a, **a);</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;c, &amp;b, &amp;a = 0x7fff05148014, 0x7fff05148018, 0x7fff05148020</span><br><span class="line">c, b, a = 123, 0x7fff05148014, 0x7fff05148018</span><br><span class="line">*b, *a, **a = 123, 0x7fff05148014, 123</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li>c, b, a 各自有各自的地址；</li>
<li>c 的内容是 123，b 的内容是 c 的地址，a 的内容是 b 的地址；</li>
<li>b 解引用是 123，a 解引用就是 b 的内容（即 c 的地址），a 的解引用的解引用（即 b 的解引用）就是 123。</li>
</ul>
<h1 id="使用">使用</h1>
<p>二级指针作为函数参数的作用：在函数外部定义一个指针 p，<strong>在函数内给指针变量（是对指针变量，不是对指针解引用）赋值，函数结束后对指针 p 生效，那么我们就需要二级指针</strong>。</p>
<p>看看下面一段代码：有两个变量 a 和 b、一个指针 q（q 指向 a）。现在，我们想让 q 指向 b（要在函数里面实现）。</p>
<h2 id="一级指针的实现">一级指针的实现</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> *q;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>* p)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;note:3, func:&amp;p=%p, p=%p\n&quot;</span>, &amp;p, p);</span><br><span class="line">    p = &amp;b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;note:4, func:&amp;p=%p, p=%p\n&quot;</span>, &amp;p, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;note:1, &amp;a=%p, &amp;b=%p, &amp;q=%p\n&quot;</span>, &amp;a, &amp;b, &amp;q);</span><br><span class="line"></span><br><span class="line">    q = &amp;a;  <span class="comment">// 现在让指针 q 指向 a</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;note:2, *q=%d, q=%p, &amp;q=%p\n&quot;</span>, *q, q, &amp;q);</span><br><span class="line">    func(q);  <span class="comment">// 期望在这个函数里让指针 q 指向 b</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;note:5, *q=%d, q=%p, &amp;q=%p\n&quot;</span>, *q, q, &amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">note:1, &amp;a=0x5627cc40d010, &amp;b=0x5627cc40d014, &amp;q=0x5627cc40d020</span><br><span class="line">note:2, *q=10, q=0x5627cc40d010, &amp;q=0x5627cc40d020</span><br><span class="line">note:3, func:&amp;p=0x7ffd3af06678, p=0x5627cc40d010</span><br><span class="line">note:4, func:&amp;p=0x7ffd3af06678, p=0x5627cc40d014</span><br><span class="line">note:5, *q=10, q=0x5627cc40d010, &amp;q=0x5627cc40d020</span><br></pre></td></tr></table></figure>
<p>从结果可以看出：</p>
<ul>
<li>note:1 -&gt; a, b, q 各自有各自的地址</li>
<li>note:2 -&gt; q 指向了 a，即地址 q 里的内容是 a 的地址</li>
<li>note:3 -&gt; 把指针 q 作为参数传入了函数，在函数内部参数 p 的地址不再是 q 的地址、但参数 p 的内容是 q 的内容（即 a 的地址）。是的，<strong>参数传递是制作了一个副本，也就是指针 p 和指针 q 不是同一个指针、但是指向的地址却是相同的</strong>。</li>
<li>note:4 -&gt; p 指向了 b</li>
<li>note:5 -&gt; 函数退出，<strong>p 的修改并不会对 q 造成影响</strong>。</li>
</ul>
<p>结论：</p>
<p><strong>编译器总是要为函数的每个参数制作临时副本</strong>，指针入参 q 的副本是 p，编译器使得原内存和副本内存指向的内容保持一样，即 <code>p = q</code>，但是这两块内存自身的地址不一样 <code>&amp;p != &amp;q</code>。</p>
<p>如果函数体内的程序修改了参数 p 这块副本内存的内容（比如在这里它指向 b 的地址），但是原内存 q 指向的内容不受影响。所以，在这里并不影响函数外的指针 q。</p>
<p><strong>要想在函数内部修改对函数外部可见（生效），这就需要二级指针操作</strong>。</p>
<h2 id="二级指针的实现">二级指针的实现</h2>
<h3 id="例子一">例子一</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span>* q;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>** p)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;note:3, func:&amp;p=%p, p=%p\n&quot;</span>, &amp;p, p);</span><br><span class="line">    *p = &amp;b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;note:4, func:&amp;p=%p, p=%p\n&quot;</span>, &amp;p, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;note:1, &amp;a=%p, &amp;b=%p, &amp;q=%p\n&quot;</span>, &amp;a, &amp;b, &amp;q);</span><br><span class="line"></span><br><span class="line">    q = &amp;a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;note:2, *q=%d, q=%p, &amp;q=%p\n&quot;</span>, *q, q, &amp;q);</span><br><span class="line">    func(&amp;q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;note:5, *q=%d, q=%p, &amp;q=%p\n&quot;</span>, *q, q, &amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码只修改了三处：</p>
<ul>
<li>函数 func 的形参变成了二级指针 int **p</li>
<li>函数内对二级指针解引用后，指向了 b</li>
<li>main 函数中，将一级指针 p 的地址（即二级指针）传入了函数 func</li>
</ul>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">note:1, &amp;a=0x563b8d952010, &amp;b=0x563b8d952014, &amp;q=0x563b8d952020</span><br><span class="line">note:2, *q=10, q=0x563b8d952010, &amp;q=0x563b8d952020</span><br><span class="line">note:3, func:&amp;p=0x7ffcc73f68b8, p=0x563b8d952020</span><br><span class="line">note:4, func:&amp;p=0x7ffcc73f68b8, p=0x563b8d952020</span><br><span class="line">note:5, *q=100, q=0x563b8d952014, &amp;q=0x563b8d952020</span><br></pre></td></tr></table></figure>
<p>note:3 -&gt; 将一级指针 p 的地址（即二级指针）传入了函数 func。函数内部 &amp;p 就是 <strong> 副本 </strong>p 本身的地址 (&amp;p=…68b8)，二级指针 p 的值 (p=…2020) 就是指针 q 的地址 (&amp;q=…2020)，即<code>*p == q</code>；通过解引用<code>*p=&amp;b</code> 重新指定了 q 指向的地址（即等价于执行了<code>q=&amp;b</code>）。所以，在函数退出后，q 指向的地址发生改变。</p>
<p>结论：<strong>在函数中，通过传递指向指针 (q) 的指针 (&amp;q)，可以修改指针 (q) 本身指向的地址 (q=&amp;b)</strong>。</p>
<h3 id="例子二">例子二</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE (100)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_malloc1</span><span class="params">(<span class="type">char</span>* s1)</span> &#123;s1 = (<span class="type">char</span>*)<span class="built_in">malloc</span>(SIZE * <span class="keyword">sizeof</span>(<span class="type">char</span>));&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">my_malloc2</span><span class="params">(<span class="type">char</span>** s2)</span> &#123;*s2 = (<span class="type">char</span>*)<span class="built_in">malloc</span>(SIZE * <span class="keyword">sizeof</span>(<span class="type">char</span>));&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len = <span class="number">3</span>;</span><br><span class="line">    <span class="type">char</span>** p1 = (<span class="type">char</span>**)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="type">char</span>*));</span><br><span class="line">    <span class="type">char</span>** p2 = (<span class="type">char</span>**)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="type">char</span>*));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(p1, <span class="number">0</span>, <span class="keyword">sizeof</span>(p1));</span><br><span class="line">    <span class="built_in">memset</span>(p2, <span class="number">0</span>, <span class="keyword">sizeof</span>(p2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;my_malloc1(), before: p1[%d] is %s\n&quot;</span>, i, p1[i] == <span class="literal">NULL</span> ? <span class="string">&quot;NULL&quot;</span> : <span class="string">&quot;NOT NULL&quot;</span>);</span><br><span class="line">        my_malloc1(p1[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;my_malloc1(), after:  p2[%d] is %s\n&quot;</span>, i, p1[i] == <span class="literal">NULL</span> ? <span class="string">&quot;NULL&quot;</span> : <span class="string">&quot;NOT NULL&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (p1[i]) &#123;<span class="built_in">free</span>(p1[i]);&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;my_malloc2(), before: p2[%d] is %s\n&quot;</span>, i, p2[i] == <span class="literal">NULL</span> ? <span class="string">&quot;NULL&quot;</span> : <span class="string">&quot;NOT NULL&quot;</span>);</span><br><span class="line">        my_malloc2(&amp;p2[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;my_malloc2(), after:  p2[%d] is %s\n&quot;</span>, i, p2[i] == <span class="literal">NULL</span> ? <span class="string">&quot;NULL&quot;</span> : <span class="string">&quot;NOT NULL&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (p2[i]) &#123;<span class="built_in">free</span>(p2[i]);&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_malloc1(), before: p1[0] is NULL</span><br><span class="line">my_malloc1(), after:  p2[0] is NULL</span><br><span class="line">my_malloc1(), before: p1[1] is NULL</span><br><span class="line">my_malloc1(), after:  p2[1] is NULL</span><br><span class="line">my_malloc1(), before: p1[2] is NULL</span><br><span class="line">my_malloc1(), after:  p2[2] is NULL</span><br><span class="line">my_malloc2(), before: p2[0] is NULL</span><br><span class="line">my_malloc2(), after:  p2[0] is NOT NULL</span><br><span class="line">my_malloc2(), before: p2[1] is NULL</span><br><span class="line">my_malloc2(), after:  p2[1] is NOT NULL</span><br><span class="line">my_malloc2(), before: p2[2] is NULL</span><br><span class="line">my_malloc2(), after:  p2[2] is NOT NULL</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们尝试在函数内部给函数外申请的二级指针（指针数组 <code>p1, p2</code> 的每个位置（初始时都是空地址）分配一块内存。</p>
<p>在函数 <code>my_malloc1</code> 中，使用一级指针作为函数参数。就相当于给 <code>p1[i]</code> 的拷贝副本 <code>s1</code> 分配内存，<code>p1[i]</code>依然没有分配内存，所以在函数退出后，<code>p1[i]</code>依然是空地址。</p>
<p>在函数 <code>my_malloc2</code> 中，使用二级指针作为函数参数。<code>&amp;p2[i]</code>的拷贝副本为 <code>s2</code>，<code>*s2</code> 解引用的内容与拷贝前 <code>&amp;p2[i]</code> 指向的内容一致（是 <code>p2[i]</code>），此时对其分配内存，在函数退出后，<code>p2[i]</code> 是一个分配的有效地址。</p>
<h1 id="总结">总结</h1>
<p>在函数中，通过传递指向指针的指针（二级指针），可以修改指针本身指向的地址。</p>
<ul>
<li>通过二级指针，在函数内部改变指针的指向（例子一）。</li>
<li>通过二级指针，在函数内部进行内存分配（例子二）。</li>
</ul>
<p>注意，函数形参使用的是一级指针，就是值传递，值传递在函数里面 <strong> 修改指针 </strong>，改变的是形参的值，而不是实参的值；但可以通过对形参<strong> 解引用赋值</strong>，来改变实参指向的地址里的值。</p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://www.techxiaofei.com/post/cpp/secondary_pointer">https://www.techxiaofei.com/post/cpp/secondary_pointer</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>一级指针</tag>
        <tag>二级指针</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之代码 TOP-K 问题</title>
    <url>/posts/240307195203.html</url>
    <content><![CDATA[<p>本文整理了 C 语言开发中的可能出现的代码问题，包括返回值处理、断言的使用、系统资源使用、内存释放、内存越界、空野指针和未初始化，并给出了必要的解释和错误示例代码。</p>
<span id="more"></span>
<h1 id="返回值处理（TOP1）">返回值处理（TOP1）</h1>
<ol>
<li>
<p>被调函数执行结果对业务流程有影响时，调用者却 <strong> 没有处理其返回值</strong>。</p>
<ul>
<li>若返回值是指针类型，可能导致空指针访问——如被调函数申请内存失败；</li>
<li>若返回值是多种返回值系列，可能导致缺少必要的回退——如中间某步异常退出导致的的资源泄漏。</li>
</ul>
</li>
<li>
<p>调用者对被调函数的返回值处理不准确，导致有隐患或问题。</p>
<ul>
<li>返回值数据类型被错误转换——如返回值为 int 类型，却被强转为 bool 类型；</li>
<li>返回值比较的目标不是该函数的返回值系列——如用函数 A 的返回值系列跟被调函数 B 的返回值作比较。</li>
</ul>
</li>
</ol>
<h1 id="断言的使用（TOP2）">断言的使用（TOP2）</h1>
<ol>
<li>使用断言错误，包括：
<ul>
<li>在 debug 断言中包含非逻辑表达式——如 <code>DBGASSERT(0 == func(&amp;a, &amp;b))</code> 包含了业务逻辑；</li>
<li>对程序运行中可能发生的情况使用了断言检查。</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc -D_DEBUG_VERSION xxx.c  or  gcc xxx.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG_VERSION</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBGASSERT(expression)                                                                                        \</span></span><br><span class="line"><span class="meta">    do &#123;                                                                                                             \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!(expression)) &#123;                                                                                         \</span></span><br><span class="line"><span class="meta">            fprintf(stderr, <span class="string">&quot;Assertion failed: %s, file %s/%s:%d\n&quot;</span>, #expression, __FILE__, __FUNCTION__, __LINE__); \</span></span><br><span class="line"><span class="meta">            abort();                                                                                                 \</span></span><br><span class="line"><span class="meta">        &#125;                                                                                                            \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBGASSERT(expression) ((void)0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>断言用于对程序运行过程中 <strong> 不应该发生 </strong> 的情况进行 <strong> 检查</strong>。</p>
<p>条件判断用于对程序运行过程中 <strong> 可能发生 </strong> 的情况进行 <strong> 处理</strong>。</p>
<h1 id="系统资源使用（TOP3）">系统资源使用（TOP3）</h1>
<ol>
<li>资源的申请释放不在同一层次或者不对称。</li>
<li>在成对的系统资源操作之间异常退出。</li>
<li>过早的申请资源，导致不必要的异常回退或资源泄漏等问题。</li>
<li>将申请的资源直接赋给间接变量（包括：数据结构字段、多级指针、全局变量）。</li>
</ol>
<blockquote>
<p>系统资源包括但不限于：动态内存、操作句柄（文件 / 接口）、中断、信号量。</p>
</blockquote>
<h2 id="例子（问题一）">例子（问题一）</h2>
<p>资源的申请释放不在同一层次。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag_student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span>* pcName;</span><br><span class="line">    <span class="type">char</span>* pcCard;</span><br><span class="line">&#125; STUDENT_S;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">example1_wrong</span><span class="params">(...)</span> &#123;</span><br><span class="line">    STUDENT_S* pstStu = (STUDENT_S*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(STUDENT_S));</span><br><span class="line">    DBGASSERT(<span class="literal">NULL</span> != pstStu);</span><br><span class="line">    <span class="keyword">while</span> (...) &#123;</span><br><span class="line">        ...;</span><br><span class="line">        <span class="keyword">if</span> (...) &#123;</span><br><span class="line">            <span class="built_in">free</span>(pstStu);  <span class="comment">// 资源释放不在同一层次</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...;</span><br><span class="line">    &#125;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">example1_correct</span><span class="params">(...)</span> &#123;</span><br><span class="line">    STUDENT_S* pstStu = (STUDENT_S*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(STUDENT_S));</span><br><span class="line">    DBGASSERT(<span class="literal">NULL</span> != pstStu);</span><br><span class="line">    <span class="keyword">while</span> (...) &#123;</span><br><span class="line">        ...;</span><br><span class="line">        <span class="keyword">if</span> (...) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...;</span><br><span class="line">    &#125;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="built_in">free</span>(pstStu);  <span class="comment">// 资源释放在同一层次</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的错误示例是申请资源在外层、释放资源在内层；另一种不在同一层是：定义在外层，申请资源在内层、释放资源在外层——可能导致资源泄漏或空指针问题。</p>
</blockquote>
<h2 id="例子（问题二）">例子（问题二）</h2>
<p>在成对的系统资源操作之间异常退出，异常退出前忘记释放资源。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">example2_wrong</span><span class="params">(...)</span> &#123;</span><br><span class="line">    STUDENT_S* pstStu = (STUDENT_S*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(STUDENT_S));</span><br><span class="line">    DBGASSERT(<span class="literal">NULL</span> != pstStu);</span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">if</span> (...) &#123;</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// 异常退出应释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="built_in">free</span>(pstStu);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例子（问题三）">例子（问题三）</h2>
<p>过早的申请资源，导致不必要的异常回退或资源泄漏等问题。资源申请应在合法性和前提条件满足之后再进行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> case1 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">example3_wrong</span><span class="params">(...)</span> &#123;</span><br><span class="line">    STUDENT_S* pstStu = (STUDENT_S*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(STUDENT_S));</span><br><span class="line">    DBGASSERT(<span class="literal">NULL</span> != pstStu);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">10</span> == case1) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="built_in">free</span>(pstStu);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">example3_correct</span><span class="params">(...)</span> &#123;</span><br><span class="line">    STUDENT_S* pstStu = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">10</span> == case1) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 合法性和前提条件已满足 */</span></span><br><span class="line">    pstStu = (STUDENT_S*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(STUDENT_S));</span><br><span class="line">    DBGASSERT(<span class="literal">NULL</span> != pstStu);</span><br><span class="line">    ...;</span><br><span class="line">    <span class="built_in">free</span>(pstStu);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例子（问题四）">例子（问题四）</h2>
<p>将申请的资源直接赋给间接变量（包括：数据结构字段、多级指针、全局变量），这可能会导致一些潜在的错误不能被检测工具检测到。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAC_ADDR_LEN (6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAC_LEN (14)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">example4_wrong</span><span class="params">(...)</span> &#123;</span><br><span class="line">    *ppstData = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(MAC_ADDR_LEN * <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>));</span><br><span class="line">    DBGASSERT(<span class="literal">NULL</span> != *ppstStu);</span><br><span class="line">    <span class="built_in">memcpy</span>(*ppstData, aucMacAddr, MAC_LEN);  <span class="comment">// 复制的长度大于申请的长度</span></span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上述低级错误无法通过工具检测，因为资源被直接赋给了多级指针 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">example4_correct</span><span class="params">(...)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* pcTempData = <span class="literal">NULL</span>;</span><br><span class="line">    pcTempData = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(MAC_ADDR_LEN * <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>));</span><br><span class="line">    DBGASSERT(<span class="literal">NULL</span> != pcTempData);</span><br><span class="line">    <span class="comment">/* 若这里长度书写错误，比如超长，pclint 可以触发 Warning 669 */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pcTempData, aucMacAddr, MAC_LEN);</span><br><span class="line">    *ppstData = pcTempData;  <span class="comment">// 所有操作成功或结束后，挂接资源到相应的变量或数据结构上</span></span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于数据结构的子内存，如对学生的身份证 <code>pstStu-&gt;card</code> 申请资源时，也应先将申请资源挂到局部指针变量上，万事俱备，再赋给数据结构的子内存 <code>pstStu-&gt;card = pcTempCardInfo</code>。</p>
</blockquote>
<h1 id="内存释放（TOP4）">内存释放（TOP4）</h1>
<ol>
<li>用不匹配的内存释放函数释放内存资源。</li>
<li>释放非法地址、内存重复释放、释放后再使用。</li>
<li>释放内存前没有先从数据结构上摘除。</li>
<li>内存资源泄漏，没有第一时间释放资源。</li>
</ol>
<p>解释（问题一）：</p>
<ul>
<li>如用结构体 B 的内存释放函数，去释放结构体 A 的指针变量动态申请的内存资源。</li>
</ul>
<p>解释（问题二）：</p>
<ul>
<li>释放非法地址：试图使用 <code>free()</code> 函数释放一个未经 <code>malloc()</code> 或类似函数分配的内存地址；</li>
<li>内存重复释放：如将内存资源传递给某接口（该接口负责内存资源的释放），这时不应再次释放内存资源；</li>
<li>释放后再使用：释放内存后，该内存块的内容和所有权已经归还给系统，再次访问这块内存会导致不可预测的结果。因此，<strong>最好在释放内存资源后，将指针变量赋值为 NULL，这样再次使用会报空指针错误</strong>。</li>
</ul>
<p>解释（问题三）：</p>
<ul>
<li>如删除链表中的节点时，先释放了对应节点的内存资源，再尝试从链表中剔除该节点。应该先剔除再释放对应节点的内存资源。</li>
</ul>
<p>解释（问题四）：</p>
<ul>
<li>如在网络收包接口中，申请了内存资源，但未正确释放，造成了内存泄漏。这样，在大流量的冲击下，短时间内会使系统可用资源耗尽，导致系统崩溃。</li>
</ul>
<h1 id="内存越界（TOP5）">内存越界（TOP5）</h1>
<ol>
<li>字符串、内存拷贝或清零等操作越界。</li>
<li>缓冲区空间太小导致数据溢出。</li>
<li>非法参数没有检查导致访问越界。</li>
</ol>
<h2 id="例子（问题一）-v2">例子（问题一）</h2>
<p>字符串拷贝越界。如果以动态申请的内存资源大小为准，我们应该拷贝<code>ulLen-1</code>，但其实申请的内存资源大小是错的，应该是<code>ulLen+1</code>，要包含字符串末尾的<code>\0</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ulLen = <span class="built_in">strlen</span>(pcWord);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">example1_wrong</span><span class="params">(...)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* pcTemp = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(ulLen * <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>));  <span class="comment">// 少 `\0` 的位置</span></span><br><span class="line">    DBGASSERT(<span class="literal">NULL</span> != pcTemp);</span><br><span class="line">    <span class="built_in">strncpy</span>(pcTemp, pcWord, ulLen); <span class="comment">// 拷贝的字节数错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">example1_correct</span><span class="params">(...)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* pcTemp = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>((ulLen + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>));</span><br><span class="line">    DBGASSERT(<span class="literal">NULL</span> != pcTemp);</span><br><span class="line">    <span class="built_in">strncpy</span>(pcTemp, pcWord, ulLen);</span><br><span class="line">    pcTemp[ulLen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内存拷贝越界，内存拷贝应 <strong> 以目的缓冲区的字节数为依据</strong>，才能实现防止访问越界</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* pcTemp = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>));</span><br><span class="line"><span class="built_in">strncpy</span>(pcTemp, pcWord, (<span class="type">unsigned</span> <span class="type">long</span>)<span class="keyword">sizeof</span>(pcWord));  <span class="comment">// wrong</span></span><br><span class="line"><span class="built_in">strncpy</span>(pcTemp, pcWord, (<span class="type">unsigned</span> <span class="type">long</span>)<span class="keyword">sizeof</span>(pcTemp));  <span class="comment">// correct</span></span><br></pre></td></tr></table></figure>
<p>内存清零错误。memset 函数的第三个参数应该是要设置的字节数，而不是数组的大小。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">DBGASSERT(<span class="literal">NULL</span> != arr);</span><br><span class="line"><span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(arr));       <span class="comment">// wrong, sizeof(arr) i.e., sizeof(int*) == 4</span></span><br><span class="line"><span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// correct</span></span><br></pre></td></tr></table></figure>
<h2 id="例子（问题二）-v2">例子（问题二）</h2>
<p>缓冲区空间太小、字符串拼装越界。推荐使用 n 系列函数，比如 snprintf。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">example2_wrong</span><span class="params">(...)</span> &#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(name, <span class="string">&quot;name-%ld&quot;</span>, ulId);  <span class="comment">// ulong 值填充后很可能超过缓冲区大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">example2_correct</span><span class="params">(...)</span> &#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(name, <span class="number">10</span>, <span class="string">&quot;name-%ld&quot;</span>, ulId);  <span class="comment">// 限制最大填充大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="空野指针（TOP6）">空野指针（TOP6）</h1>
<ol>
<li>释放全局变量上的资源后没有清零全局变量。</li>
<li><strong>释放数据结构上挂接的内存后没有清零数据结构上的挂接字段</strong>。</li>
<li>访问空指针。</li>
</ol>
<h2 id="例子（问题一）-v3">例子（问题一）</h2>
<p>释放全局变量上的资源后没有清零全局变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">DBGASSERT(<span class="literal">NULL</span> != arr);</span><br><span class="line"><span class="built_in">free</span>(arr);</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">100</span>;  <span class="comment">// 不会报错，但 free 后 arr 地址已经是野指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 正确做法 */</span></span><br><span class="line"><span class="built_in">free</span>(arr);</span><br><span class="line">arr = <span class="literal">NULL</span>;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">100</span>;  <span class="comment">// segment fault</span></span><br></pre></td></tr></table></figure>
<h2 id="例子二（问题二）">例子二（问题二）</h2>
<p>释放数据结构上挂接的内存后没有清零数据结构上的挂接字段。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">STUDENT_S* pstStu = (STUDENT_S*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(STUDENT_S));</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">example2_wrong</span><span class="params">(...)</span> &#123;</span><br><span class="line">    <span class="type">char</span>* pcTempCard = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">18</span> * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    DBGASSERT(<span class="literal">NULL</span> != pcTempCard);</span><br><span class="line">    pstStu-&gt;pcCard = pcTempCard;  <span class="comment">// 动态资源挂接到数据结构的字段</span></span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">if</span> (...) &#123;</span><br><span class="line">        <span class="built_in">free</span>(pcTempCard);  <span class="comment">// pstStu-&gt;pcCard 字段没有清零</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="未初始化（TOP7）">未初始化（TOP7）</h1>
<ol>
<li>导致访问未初始化的变量或数据结构字段或动态内存。</li>
<li>函数的入参未被初始化</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">example1_wrong</span><span class="params">(...)</span> &#123;</span><br><span class="line">    STUDENT_S stStu;</span><br><span class="line">    <span class="keyword">if</span> (...) &#123;</span><br><span class="line">        stStu.age = <span class="number">18</span>;  <span class="comment">// 条件不成立时，该字段不会初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    stStu.pcName = <span class="string">&quot;lihua&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: %d\n&quot;</span>, stStu.pcName, stStu.age);  <span class="comment">// 可能使用未初始化的字段</span></span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nr;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">example2_wrong</span><span class="params">(<span class="type">int</span> *nr)</span> &#123;</span><br><span class="line">    (*nr)++;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br><span class="line">example2_wrong(&amp;nr);  <span class="comment">// 从几开始加?</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>代码问题</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之关键字与专有名词</title>
    <url>/posts/231214192113.html</url>
    <content><![CDATA[<p>由 ANSI 标准定义的 C 语言关键字共有 32 个。根据关键字的作用，可以将关键字分为 <strong> 数据类型关键字 </strong> 和<strong>流程控制关键字 </strong> 两大类。</p>
<span id="more"></span>
<h1 id="数据类型关键字">数据类型关键字</h1>
<h2 id="基础数据类型（5 个）">基础数据类型（5 个）</h2>
<ul>
<li><code>void</code>：声明函数无返回值或无参数，声明无类型指针，显式丢弃运算结果。</li>
<li><code>char</code>：字符型类型数据，属于整型数据的一种。</li>
<li><code>int</code>：整型数据，通常为编译器指定的机器字长。</li>
<li><code>float</code>：单精度浮点型数据，属于浮点数据的一种。</li>
<li><code>double</code>：双精度浮点型数据，属于浮点数据的一种。</li>
</ul>
<h2 id="类型修饰关键字（4 个）">类型修饰关键字（4 个）</h2>
<ul>
<li><code>short</code>：修饰<code>int</code>，短整型数据，可省略被修饰的<code>int</code>。</li>
<li><code>long</code>：修饰<code>int</code>，长整形数据，可省略被修饰的<code>int</code>。</li>
<li><code>signed</code>：修饰整型数据，有符号数据类型。</li>
<li><code>unsigned</code>：修饰整型数据，无符号数据类型。</li>
</ul>
<h2 id="复杂类型关键字（5 个）">复杂类型关键字（5 个）</h2>
<ul>
<li><code>struct</code>：结构体声明。</li>
<li><code>union</code>：共用体声明。</li>
<li><code>enum</code>：枚举声明</li>
<li><code>typedef</code>：声明类型别名。</li>
<li><code>sizeof</code>：得到特定类型或特定类型变量的大小。</li>
</ul>
<h2 id="存储级别关键字（6 个）">存储级别关键字（6 个）</h2>
<ul>
<li><code>auto</code>：指定为自动变量，由编译器自动分配及释放，通常在栈上分配。</li>
<li><code>static</code>：指定为静态变量，分配在静态变量区，修饰函数时，指定函数作用域为文件内部。</li>
<li><code>register</code>：指定为寄存器变量，建议编译器将变量存储到寄存器中使用，也可以修饰函数形参，建议编译器通过寄存器而不是堆栈传递参数。</li>
<li><code>extern</code>：指定对应变量为外部变量，即在另外的目标文件中定义，可以认为是约定由另外文件声明的对象的一个「引用」。</li>
<li><code>const</code>：与 <code>volatile</code> 合称「CV 特性」，指定变量不可被当前线程 / 进程改变（但有可能被系统或其他线程 / 进程改变）。</li>
<li><code>volatile</code>：与 <code>const</code> 合称「CV 特性」，指定变量的值有可能会被系统或其他进程 / 线程改变，强制编译器每次从内存中取得该变量的值。</li>
</ul>
<h1 id="流程控制关键字">流程控制关键字</h1>
<h2 id="跳转结构（4 个）">跳转结构（4 个）</h2>
<ul>
<li><code>return</code>：用在函数体中，返回特定值（或者是 <code>void</code> 值，即不返回值）。</li>
<li><code>continue</code>：结束当前循环，开始下一轮循环。</li>
<li><code>break</code>：跳出当前循环或 <code>switch</code> 结构。</li>
<li><code>goto</code>：无条件跳转语句。</li>
</ul>
<h2 id="分支结构（5 个）">分支结构（5 个）</h2>
<ul>
<li><code>if</code>：条件语句。</li>
<li><code>else</code>：条件语句否定分支，与 <code>if</code> 连用。</li>
<li><code>switch</code>：开关语句（多重分支语句）。</li>
<li><code>case</code>：开关语句中的分支标记。</li>
<li><code>default</code>：开关语句中的「其他」分支，可选。</li>
</ul>
<h2 id="循环结构（3 个）">循环结构（3 个）</h2>
<ul>
<li><code>for</code>：循环结构。</li>
<li><code>do</code>：循环结构，与 <code>while</code> 一起使用。</li>
<li><code>while</code>：循环结构。</li>
</ul>
<h1 id="专有名词解释">专有名词解释</h1>
<h2 id="自动变量">自动变量</h2>
<p>在 C 和 C++ 等编程语言中，当在函数或代码块内部声明一个变量时，该变量默认为自动变量。自动变量具有以下特点：</p>
<ol>
<li>作用域：自动变量的作用域仅限于声明它的代码块内部。这意味着在声明的代码块外部是无法访问到该变量的。</li>
<li>存储方式：自动变量通常存储在栈（stack）上。当进入声明变量的代码块时，该变量会在栈上分配存储空间，当代码块执行完毕时，变量会自动释放所占用的栈空间。</li>
<li>初始化：自动变量在声明时可以选择是否进行初始化。如果未初始化，则其值是不确定的。</li>
</ol>
<p>自动变量适用于那些在局部范围内使用的临时数据和临时存储需求较小的变量。与全局变量和静态变量相比，自动变量具有更短的生命周期和更小的作用域，能够更有效地管理内存和避免命名冲突。</p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/37908790">https://zhuanlan.zhihu.com/p/37908790</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>关键字</tag>
        <tag>专有名词</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之多维数组</title>
    <url>/posts/230922143003.html</url>
    <content><![CDATA[<p> 本文章主要介绍 C 语言创建多维数组的方式及其排序，包括静态多维数组、<code>malloc</code> 动态申请多维数组、指针数组的多维数组和多维结构体数组的创建。</p>
<span id="more"></span>
<h2 id="排序接口"> 排序接口 </h2>
<p><code>qsort</code> 函数是 C 语言标准库中的一个排序函数，用于对数组进行快速排序。它的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qsort</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *base, </span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> nmemb, </span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> size, </span></span><br><span class="line"><span class="params">    <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p> 参数说明：</p>
<ul>
<li><code>base</code>：指向需要排序的数组的第一个元素的指针。</li>
<li><code>nmemb</code>：数组中元素的个数。</li>
<li><code>size</code>：每个元素的大小（以字节为单位）。</li>
<li><code>compar</code>：指向比较函数的指针，用于指定数组元素的比较规则。</li>
</ul>
<p><code>base</code> 指定了待排序数组的首地址，再结合 <code>nmemb * size</code> 可以确定要排序的数组的范围。</p>
<p> 比较函数 <code>compar</code> 的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">compar</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span>;</span><br></pre></td></tr></table></figure>
<p> 参数说明：</p>
<ul>
<li><code>a</code> 和 <code>b</code>：指向待比较的两个元素的指针。</li>
</ul>
<p> 比较函数 <code>compar</code> 必须返回一个整数值，表示 <code>a</code> 和 <code>b</code> 的大小关系：</p>
<ul>
<li> 如果 <code>a</code> 小于 <code>b</code>，则返回一个负整数。</li>
<li> 如果 <code>a</code> 等于 <code>b</code>，则返回零。</li>
<li> 如果 <code>a</code> 大于 <code>b</code>，则返回一个正整数。</li>
</ul>
<p> 通过传入不同的比较函数，<code>qsort</code> 函数可以实现对不同类型的数组进行排序。</p>
<h2 id="静态多维数组"> 静态多维数组 </h2>
<h3 id="多维数组创建"> 多维数组创建 </h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> rows = <span class="number">3</span>, cols = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> arr[rows][cols];</span><br></pre></td></tr></table></figure>
<h3 id="多维数组排序"> 多维数组排序 </h3>
<p> 按照二维数组第 0 列升序排序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">int</span> *)a)[<span class="number">0</span>] - ((<span class="type">int</span> *)b)[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入 cmp 函数指针的 arr 是一个一维指针 </span></span><br><span class="line">qsort(arr, rows, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), cmp);  <span class="comment">// 快速排序 </span></span><br></pre></td></tr></table></figure>
<h2 id="malloc 动态申请多维数组">malloc 动态申请多维数组 </h2>
<h3 id="多维数组创建 -v2"> 多维数组创建 </h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> rows = <span class="number">3</span>, cols = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态申请二维数组 </span></span><br><span class="line"><span class="type">int</span> **arr = (<span class="type">int</span> **)<span class="built_in">malloc</span>(rows * <span class="keyword">sizeof</span>(<span class="type">int</span> *));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">    arr[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(cols * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放内存 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(arr);</span><br></pre></td></tr></table></figure>
<p> 释放 <code>malloc</code> 申请的多维数组时，不能直接 <code>free(arr)</code>，因为 <code>malloc</code> 和 <code>free</code> 执行次数要一致。</p>
<h3 id="多维数组排序 -v2"> 多维数组排序 </h3>
<p> 按照二维数组第 0 列升序排序，若相等，则按第 1 列升序排序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span> &#123;</span><br><span class="line">    <span class="comment">// a 是一个指向二维数组首行的指针 </span></span><br><span class="line">    <span class="comment">// 通过类型转换和解引用操作, ap 指向了 a 所指向的整型数组的首地址 </span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* ap = *(<span class="type">int</span> **)a;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* bp = *(<span class="type">int</span> **)b;</span><br><span class="line">    <span class="keyword">if</span> (ap[<span class="number">0</span>] == bp[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ap[<span class="number">1</span>] - bp[<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ap[<span class="number">0</span>] - bp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入 cmp 函数指针的 arr 是一个二维指针 </span></span><br><span class="line">qsort(arr, rows, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), cmp);</span><br></pre></td></tr></table></figure>
<h2 id="malloc 动态申请多维结构体数组">malloc 动态申请多维结构体数组 </h2>
<h3 id="多维结构体数组创建"> 多维结构体数组创建 </h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> rows = <span class="number">3</span>, cols = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">&#125; Node_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态申请二维数组 </span></span><br><span class="line">Node_t **arr = (Node_t **)<span class="built_in">malloc</span>(rows * <span class="keyword">sizeof</span>(Node_t *));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">    arr[i] = (Node_t *)<span class="built_in">malloc</span>(cols * <span class="keyword">sizeof</span>(Node_t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放内存 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">    <span class="comment">// 如果结构体成员中有指针且申请了空间, 则需要先释放成员的空间再释放结构体的空间 </span></span><br><span class="line">    <span class="built_in">free</span>(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(arr);</span><br></pre></td></tr></table></figure>
<h3 id="多维结构体数组排序"> 多维结构体数组排序 </h3>
<p> 按照二维数组第 0 列的结构体成员 <code>x</code> 降序排序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// return (Node_t *)a-&gt;x - (Node_t *)b-&gt;x;   // 错误写法 </span></span><br><span class="line">    <span class="keyword">return</span> ((Node_t *)a)-&gt;x - ((Node_t *)b)-&gt;x;   <span class="comment">// 正确写法 1</span></span><br><span class="line">    <span class="comment">// return (*(Node_t *)b).x - (*(Node_t *)a).x;     // 正确写法 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">qsort(arr, rows, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), cmp);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-&gt;</code> 操作符的优先级高于 <code>()</code> 操作符。</li>
</ul>
<h2 id="指针数组的多维数组"> 指针数组的多维数组 </h2>
<p> 使用指针数组的多维数组：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> rows = <span class="number">3</span>, cols = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* arr[rows];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cols; i++) &#123;</span><br><span class="line">    arr[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放内存 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这种方式创建的多维数组实际上是一个指针数组，每个指针指向一个一维数组，可以在运行时动态分配每个一维数组的大小（方便创建每行元素个数不同的多维数组）。</p>
<h3 id="多维数组排序 -v3"> 多维数组排序 </h3>
<p> 按照二维数组第 0 列降序排序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* ap = *(<span class="type">int</span> **)a;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* bp = *(<span class="type">int</span> **)b;</span><br><span class="line">    <span class="keyword">return</span> bp[<span class="number">0</span>] - ap[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入 cmp 函数指针的 arr 是一个二维指针 </span></span><br><span class="line">qsort(arr, rows, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), cmp);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>多维数组</tag>
        <tag>数组排序</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之大小端知识</title>
    <url>/posts/230918114841.html</url>
    <content><![CDATA[<p>在计算机中，数据在内存中的存储是以 byte 为单位的。字节序是由于 CPU 对大于一个字节的变量，在内存中的存放顺序不同而产生的。</p>
<p>不同的计算机体系结构使用不同的字节序，对于大于一个字节的变量表示，有小端模式（Little Endian, LE）和大端模式（Big Endian, BE）两种表示方式。</p>
<span id="more"></span>
<h1 id="字节序">字节序</h1>
<h2 id="主机字节序">主机字节序</h2>
<p>不同机器的主机字节序可能不同，这与 CPU 设计有关，数据的顺序是由 CPU 决定的，而与操作系统无关。我们把某个给定系统所用的字节序称为主机字节序（host byte order）。比如 x86 系列 CPU 都是 little-endian 的字节序。</p>
<ul>
<li>
<p>小端模式（Little Endian, LE）：高位字节存储在高位地址，而低位字节存储在低位地址。</p>
</li>
<li>
<p>大端模式（Big Endian, BE）：高位字节存储在低位地址，而低位字节存储在高位地址，与小端模式相反。</p>
</li>
</ul>
<p><img src="../images/le-be-endian.png" alt="大小端模式"></p>
<p>在小端字节序主机系统中进行字节序转换时，需要将低地址的字节和高地址的字节进行交换，便可得到大端字节序。</p>
<h2 id="网络字节序">网络字节序</h2>
<p>网络字节序是 TCP/IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。网络字节序采用 big-endian 方式。</p>
<p>由于这个原因，为了确保数据在不同主机之间传输时能够被正确解释，需要在不同字节序之间进行转换。在网络通信中，一般需要将数据转换为网络字节序进行传输。</p>
<h1 id="主机字节序类型判断">主机字节序类型判断</h1>
<p>可以使用共用体（union）来判断当前 CPU 平台是大端字节序还是小端字节序。这是因为共用体的特点是：使用长度最大的数据类型作为共用体的大小。</p>
<ul>
<li>
<p>建立一个联合类型 <code>BYTE_ORDER_UN</code>，用于测试字节序，可以通过成员 <code>byte</code> 来访问 <code>value</code> 变量的高字节和低字节。</p>
</li>
<li>
<p>声明一个 <code>BYTE_ORDER_UN</code> 类型的变量 <code>unByteOrder</code>，将值 <code>0xabcd</code> 赋给成员变量 <code>value</code>。由于在类型 <code>BYTE_ORDER_UN</code> 中，<code>value</code> 和 <code>byte</code> 成员 <strong> 共享一块内存</strong>，所以可以通过 <code>byte</code> 的不同成员来访问 <code>value</code> 的高字节和低字节。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">byte_order</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> byte[<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span>)];</span><br><span class="line">&#125; BYTE_ORDER_UN;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    BYTE_ORDER_UN unByteOrder;</span><br><span class="line">    unByteOrder.value = <span class="number">0xabcd</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((unByteOrder.byte[<span class="number">0</span>] == <span class="number">0xcd</span>) &amp;&amp; (unByteOrder.byte[<span class="number">1</span>] == <span class="number">0xab</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Listen endian byte order, byte[0]: 0x%x, byte[1]: 0x%x\n&quot;</span>, \</span><br><span class="line">        unByteOrder.byte[<span class="number">0</span>], unByteOrder.byte[<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>((unByteOrder.byte[<span class="number">0</span>] == <span class="number">0xab</span>) &amp;&amp; (unByteOrder.byte[<span class="number">1</span>] == <span class="number">0xcd</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Big endian byte order, byte[0]: 0x%x, byte[1]: 0x%x\n&quot;</span>, \</span><br><span class="line">        unByteOrder.byte[<span class="number">0</span>], unByteOrder.byte[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主机系统为小端字节序的测试结果：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ gcc byteOrder.c -o byteOrder</span><br><span class="line">$ ./byteOrder</span><br><span class="line">Listen endian byte order, byte[0]: 0xcd, byte[1]: 0xab</span><br></pre></td></tr></table></figure>
<h1 id="主机字节序到网络字节序转换">主机字节序到网络字节序转换</h1>
<p><strong>字节交换的作用是生成一个网络字节序的变量，其字节的顺序与主机类型和操作系统无关</strong>。进行网络字节序转换的时候，只要转换一次就可以了，不要进行多次转换。如果进行多次字节序的转换，最后生成的网络字节序的值可能是错误的。例如：</p>
<ul>
<li>
<p>对于主机为小端字节序的系统，进行两次字节序转换的过程如下图所示，经过两次转换，最终的值与最初的主机字节序相同。</p>
</li>
<li>
<p>对于主机为大端字节序的系统，无论进行多少次字节序的转换，最终的值与最初的主机字节序相同。</p>
</li>
</ul>
<p><img src="../images/htos-conversion.png" alt="小端系统中的变量多次字节序转换"></p>
<p>下面的例子是对 16 位数值和 32 位数值进行字节序转换，每种类型的数值进行两次转换，最后打印结果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITS16 (16)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITS32 (32)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">two_bytes_order</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> byte[<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span>)];</span><br><span class="line">&#125; TWO_BYTES_ORDER_UN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">four_bytes_order</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> byte[<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span>)];</span><br><span class="line">&#125; FOUR_BYTES_ORDER_UN;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">showValue</span><span class="params">(<span class="type">void</span> *begin, <span class="type">int</span> flag)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p = (<span class="type">unsigned</span> <span class="type">char</span> *)begin;</span><br><span class="line">    <span class="type">int</span> byteNums = flag &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; byteNums; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%x (%p) &quot;</span>, *(p + i), p + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    TWO_BYTES_ORDER_UN v16_orig, v16_turn1, v16_turn2;</span><br><span class="line">    FOUR_BYTES_ORDER_UN v32_orig, v32_turn1, v32_turn2;</span><br><span class="line"></span><br><span class="line">    v16_orig.value = <span class="number">0xabcd</span>;</span><br><span class="line">    v16_turn1.value = htons(v16_orig.value);</span><br><span class="line">    v16_turn2.value = htons(v16_turn1.value);</span><br><span class="line"></span><br><span class="line">    v32_orig.value = <span class="number">0x12345678</span>;</span><br><span class="line">    v32_turn1.value = htonl(v32_orig.value);</span><br><span class="line">    v32_turn2.value = htonl(v32_turn1.value);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;16bits host to network byte order change:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\torig:    &quot;</span>);</span><br><span class="line">    showValue(v16_orig.byte, BITS16);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t1 times: &quot;</span>);</span><br><span class="line">    showValue(v16_turn1.byte, BITS16);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t2 times: &quot;</span>);</span><br><span class="line">    showValue(v16_turn2.byte, BITS16);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;32bits host to network byte order change:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\torig:    &quot;</span>);</span><br><span class="line">    showValue(v32_orig.byte, BITS32);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t1 times: &quot;</span>);</span><br><span class="line">    showValue(v32_turn1.byte, BITS32);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t2 times: &quot;</span>);</span><br><span class="line">    showValue(v32_turn2.byte, BITS32);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小端模式到网络字节序转换的测试结果：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ gcc byteOrder2.c -o byteOrder2</span><br><span class="line">$ ./byteOrder2</span><br><span class="line">16bits host to network byte order change:</span><br><span class="line">        orig:    cd (0x7ffcd6ad66de) ab (0x7ffcd6ad66df)</span><br><span class="line">        1 times: ab (0x7ffcd6ad66dc) cd (0x7ffcd6ad66dd)</span><br><span class="line">        2 times: cd (0x7ffcd6ad66da) ab (0x7ffcd6ad66db)</span><br><span class="line">32bits host to network byte order change:</span><br><span class="line">        orig:    78 (0x7ffcd6ad66d0) 56 (0x7ffcd6ad66d1) 34 (0x7ffcd6ad66d2) 12 (0x7ffcd6ad66d3)</span><br><span class="line">        1 times: 12 (0x7ffcd6ad66c8) 34 (0x7ffcd6ad66c9) 56 (0x7ffcd6ad66ca) 78 (0x7ffcd6ad66cb)</span><br><span class="line">        2 times: 78 (0x7ffcd6ad66c0) 56 (0x7ffcd6ad66c1) 34 (0x7ffcd6ad66c2) 12 (0x7ffcd6ad66c3)</span><br></pre></td></tr></table></figure>
<p>16 位变量 0xabcd 在内存中的表示方式为 cd 在前、ab 在后；进行一次字节序转换后变为 ab 在前，cd 在后。在进行第一次转换后字节序发生了变化，而进行第二次字节序转换后与原始的排列方式一致。</p>
<h1 id="大小端转换">大小端转换</h1>
<p>上面的代码中 <code>htons</code> 和 <code>htonl</code>，分别给出了主机字节序到网络字节序的 <code>short</code> 和 <code>long</code> 类型的转换接口。那么，这个接口是如何实现大小端转换的呢？</p>
<p><strong>通过位运算的方式来实现大小端的转换</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">little_endian_to_big_endian_4bytes</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((value &amp; <span class="number">0x000000ff</span>) &lt;&lt; <span class="number">24</span>) | ((value &amp; <span class="number">0x0000ff00</span>) &lt;&lt; <span class="number">8</span>) | </span><br><span class="line">           ((value &amp; <span class="number">0x00ff0000</span>) &gt;&gt; <span class="number">8</span>) | ((value &amp; <span class="number">0xff000000</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">little_endian_to_big_endian_2bytes</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((value &amp; <span class="number">0x00ff</span>) &lt;&lt; <span class="number">8</span>) | ((value &amp; <span class="number">0xff00</span>) &gt;&gt; <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> little_value2 = <span class="number">0xabcd</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> little_value4 = <span class="number">0x12345678</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> big_value2 = little_endian_to_big_endian_2bytes(little_value2);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> big_value4 = little_endian_to_big_endian_4bytes(little_value4);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;LE2 value: 0x%04x\n&quot;</span>, little_value2);  <span class="comment">// LE2 value: 0xabcd</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;BE2 value: 0x%04x\n&quot;</span>, big_value2);  <span class="comment">// BE2 value: 0xcdab</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;LE4 value: 0x%08x\n&quot;</span>, little_value4);  <span class="comment">// LE4 value: 0x12345678</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;BE4 value: 0x%08x\n&quot;</span>, big_value4);  <span class="comment">// BE4 value: 0x78563412</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="多变量存储在连续内存中的字节序转换">多变量存储在连续内存中的字节序转换</h1>
<p>示例 1：两个 2 字节变量存储在连续的内存中，与一个 4 字节变量存储在连续的内存中，从小端主机字节序转换为大端网络字节序后的结果一样吗？一样的！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">four_bytes_order</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> val1;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> val2;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> val3;</span><br><span class="line">&#125; FOUR_BYTES_ORDER_S;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITS16 (16)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITS32 (32)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">showValue</span><span class="params">(<span class="type">void</span> *begin, <span class="type">int</span> flag)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p = (<span class="type">unsigned</span> <span class="type">char</span> *)begin;</span><br><span class="line">    <span class="type">int</span> byteNums = flag &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; byteNums; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%x (%p) &quot;</span>, *(p + i), p + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    FOUR_BYTES_ORDER_S sOrig, sTurn;</span><br><span class="line">    </span><br><span class="line">    sOrig.val1 = <span class="number">0x1234</span>;</span><br><span class="line">    sOrig.val2 = <span class="number">0x5678</span>;</span><br><span class="line">    sTurn.val1 = htons(sOrig.val1);</span><br><span class="line">    sTurn.val2 = htons(sOrig.val2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;16 + 16 host to network byte order change:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\thost:    &quot;</span>);</span><br><span class="line">    showValue(&amp;sOrig.val1, BITS32);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\tnetwork: &quot;</span>);</span><br><span class="line">    showValue(&amp;sTurn.val1, BITS32);</span><br><span class="line"></span><br><span class="line">    sOrig.val3 = <span class="number">0x12345678</span>;</span><br><span class="line">    sTurn.val3 = htonl(sOrig.val3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;32 host to network byte order change:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\thost:    &quot;</span>);</span><br><span class="line">    showValue(&amp;sOrig.val3, BITS32);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\tnetwork: &quot;</span>);</span><br><span class="line">    showValue(&amp;sTurn.val3, BITS32);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上述连续内存的两个 2 字节变量和一个 4 字节变量，转换成的网络字节序都是 <code>0x12345678</code>：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ gcc byteOrder2.c -o byteOrder3</span><br><span class="line">$ ./byteOrder3</span><br><span class="line">16 + 16 host to network byte order change:</span><br><span class="line">        host:    34 (0x7fffd69b9a10) 12 (0x7fffd69b9a11) 78 (0x7fffd69b9a12) 56 (0x7fffd69b9a13)</span><br><span class="line">        network: 12 (0x7fffd69b9a00) 34 (0x7fffd69b9a01) 56 (0x7fffd69b9a02) 78 (0x7fffd69b9a03)</span><br><span class="line">32 host to network byte order change:</span><br><span class="line">        host:    78 (0x7fffd69b9a18) 56 (0x7fffd69b9a19) 34 (0x7fffd69b9a1a) 12 (0x7fffd69b9a1b)</span><br><span class="line">        network: 12 (0x7fffd69b9a08) 34 (0x7fffd69b9a09) 56 (0x7fffd69b9a0a) 78 (0x7fffd69b9a0b)</span><br></pre></td></tr></table></figure>
<p>示例 2：一个变量 <code>0x12345678abcd9876</code>，分别以 <code>short + long + short</code> 和 <code>long + long</code> 变量存储在一个连续内容中，那么两种存储的小端主机字节序和大端网络字节序在内存中的存储的值顺序一致吗？大端网络字节序是一致的！</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">val_le = 0x12345678abcd9876</span><br><span class="line"></span><br><span class="line">short + long + short</span><br><span class="line">    a = 0x1234</span><br><span class="line">    b = 0x5678abcd</span><br><span class="line">    c = 0x9876</span><br><span class="line"></span><br><span class="line">分别给出其主机序和网络序：</span><br><span class="line">    内存低地址 -----------------------&gt; 内存高地址 </span><br><span class="line">    小端主机序：34 12 | cd ab 78 56 | 76 98</span><br><span class="line">    大端网络序：12 34 | 56 78 ab cd | 98 76</span><br><span class="line"></span><br><span class="line">long + long</span><br><span class="line">    d = 0x12345678</span><br><span class="line">    e = 0xabcd9876</span><br><span class="line"></span><br><span class="line"> 分别给出其主机序和网络序：</span><br><span class="line">    内存低地址 -----------------------&gt; 内存高地址</span><br><span class="line">    小端主机序：78 56 34 12 | 76 98 cd ab</span><br><span class="line">    大端网络序：12 34 56 78 | ab cd 98 76</span><br></pre></td></tr></table></figure>
<p>可以看出, 两种组合变量的主机序到网络序转换后的结果是一致的！</p>
<blockquote>
<p>参考：</p>
<ol>
<li><a href="https://blog.51cto.com/u_15249901/4893764">https://blog.51cto.com/u_15249901/4893764</a></li>
<li><a href="https://blog.csdn.net/Jmilk/article/details/106898871">https://blog.csdn.net/Jmilk/article/details/106898871</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>大小端</tag>
        <tag>字节序</tag>
        <tag>网络字节序</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言之输出打印函数</title>
    <url>/posts/240103180653.html</url>
    <content><![CDATA[<p>本文汇总 C 语言中不同的数据输出（打印）函数，包括 <code>printf(), fprintf(), sprintf(), snprintf()</code> 和 <code>puts(), putchar()</code>。</p>
<span id="more"></span>
<h1 id="printf- 输出到终端">printf()输出到终端</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>功能 </strong>：将格式化的数据<strong> 打印到标准输出（终端）</strong>。</li>
<li><strong>用法 </strong>：<code>printf</code> 函数使用<strong> 格式字符串</strong> <code>format</code> 来指定输出的格式，可以包含占位符 <code>%</code> 来代表不同类型的数据。</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;My age is %d\n&quot;</span>, age);</span><br></pre></td></tr></table></figure>
<p>输出：<code>My age is 18</code></p>
<h1 id="fprintf- 输出到文件">fprintf()输出到文件</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>功能 </strong>：将格式化的数据<strong> 打印到指定的文件流</strong>。</li>
<li><strong>用法</strong>：<code>fprintf</code> 函数与 <code>printf</code> 函数类似，不同之处在于它需要指定一个文件流作为输出目标。</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *name = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(file, <span class="string">&quot;Hello, %s!\n&quot;</span>, name);</span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：在当前工作目录下创建一个名为 <code>output.txt</code> 的文件，并将字符串 <code>Hello, World!</code> 写入该文件。</p>
<h1 id="sprintf- 输出到字符串变量">sprintf()输出到字符串变量</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>功能 </strong>：将格式化的数据<strong> 打印到字符串 <code>str</code> 中</strong>。</li>
<li><strong>用法</strong>：<code>sprintf</code> 函数与 <code>printf</code> 函数类似，不同之处在于它将格式化的数据写入一个字符串 <code>str</code> 中。</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> message[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(message, <span class="string">&quot;My age is %d&quot;</span>, age);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, message);</span><br></pre></td></tr></table></figure>
<p>输出：<code>My age is 18</code></p>
<h1 id="snprintf- 输出到字符串变量">snprintf()输出到字符串变量</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">snprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>功能 </strong>：将格式化的数据<strong> 打印到指定长度 <code>size</code> 的字符串 <code>str</code> 中，防止字符串溢出</strong>。</li>
<li><strong>用法</strong>：<code>snprintf</code> 函数与 <code>sprintf</code> 函数类似，不同之处在于它需要指定字符串的大小，以避免溢出。</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> message[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="type">char</span> *name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line"><span class="built_in">snprintf</span>(message, <span class="keyword">sizeof</span>(message), <span class="string">&quot;My age is %d, my name is %s&quot;</span>, age, name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, message);</span><br></pre></td></tr></table></figure>
<p>输出：<code>My age is 18, my name is Alic</code>（只打印前 30 个字符，结束符 <code>\0</code> 算一个字符，所以打印内容中没有 <code>e</code>）</p>
<h1 id="puts- 输出字符串到终端">puts()输出字符串到终端</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">puts</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>功能</strong>：<code>puts()</code> 函数用于将字符串输出到标准输出（控制台）。它会自动在输出的字符串末尾添加一个换行符。</li>
<li><strong>用法 </strong>：<code>puts()</code> 函数<strong> 只能用于打印字符串</strong>，无法使用占位符打印其它数据类型的变量。</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="built_in">puts</span>(str);</span><br></pre></td></tr></table></figure>
<p>输出：<code>Hello, world!</code>（字符串末尾自动添加了一个换行符）</p>
<h1 id="putchar- 输出字符到终端">putchar()输出字符到终端</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">putchar</span><span class="params">(<span class="type">int</span> c)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>功能</strong>：<code>putchar()</code> 函数用于将一个字符输出到标准输出（控制台）。</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="built_in">putchar</span>(c);</span><br></pre></td></tr></table></figure>
<p>输出：<code>A</code></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>打印函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 笔记之函数 &amp; 包 &amp; 判断 &amp; 循环</title>
    <url>/posts/230909120145.html</url>
    <content><![CDATA[<h2 id="Go 语言笔记 -5：函数">Go 语言笔记 -5：函数</h2>
<ol>
<li>函数声明语法：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functionname</span><span class="params">(parametername1 <span class="keyword">type</span>, parametername2 <span class="keyword">type</span>)</span></span> returntype &#123;  </span><br><span class="line">    <span class="comment">// 函数体（具体实现的功能）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>如果有连续若干个参数，它们的类型一致，那么我们无须一一罗列，只需在最后一个参数后添加该类型。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functionname</span><span class="params">(parametername1, parametername2 <span class="keyword">type</span>)</span></span> returntype &#123;  </span><br><span class="line">    <span class="comment">// 函数体（具体实现的功能）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>Go 语言支持一个函数可以有 <strong> 多个返回值</strong>。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functionname</span><span class="params">(para1 type1, para2 type2)</span></span> (returntype1, returntype2, ...) &#123;</span><br><span class="line">    <span class="comment">// 函数体（具体实现的功能）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<ol start="4">
<li><strong>命名返回值 </strong>：从函数中可以返回一个命名值。一旦命名了返回值，可以认为<strong> 这些值在函数第一行就被声明为变量了</strong>，在函数 return 时不必再跟随命名值。如<code>area, perimeter</code>：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rectProps</span><span class="params">(length, width <span class="type">float64</span>)</span></span> (area, perimeter <span class="type">float64</span>) &#123;  </span><br><span class="line">    area = length * width</span><br><span class="line">    perimeter = (length + width) * <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// 不需要明确指定返回值，默认返回 area, perimeter 的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><strong>空白符</strong>：<code>_</code> 在 Go 中被用作空白符，可以用作表示任何类型的任何值。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">area, _ := rectProps(<span class="number">10.8</span>, <span class="number">5.6</span>) <span class="comment">// 返回值周长被丢弃</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Go 语言笔记 -6：包">Go 语言笔记 -6：包</h2>
<ol>
<li>
<p><code>package packagename</code> 指定了某一源文件属于一个包，它应该放在每一个源文件的第一行。</p>
</li>
<li>
<p><code>main</code> 包和自定义包目录结构（属于某一个包的源文件，都应该放置于一个单独命名的文件夹里，且应该用包名命名文件夹名）：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">    geometry  <span class="comment">// 自定义 main 包</span></span><br><span class="line">        geometry.<span class="keyword">go</span> <span class="comment">// main 函数</span></span><br><span class="line">        rectangle <span class="comment">// 自定义包，文件名为包名</span></span><br><span class="line">            rectprops.<span class="keyword">go</span> <span class="comment">// 属于 rectangle 包的源文件</span></span><br><span class="line">bin</span><br><span class="line">    <span class="comment">// 通过执行 go build geometry/geometry.go 编译得到 </span></span><br><span class="line">    geometry (Linux)</span><br><span class="line">    geometry.exe (Windows)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>
<p>导入自定义包：<code>import packagepath</code>，必须指定自定义包 <code>packagename</code> 相对于工作区 <code>src</code> 文件夹的相对路径，如：<code>import &quot;geometry/rectangle&quot;</code>。</p>
</li>
<li>
<p>导出名字：在 Go 中，任何 <strong> 以大写字母开头的变量或者函数都是被导出的名字，其它包只能访问被导出的函数和变量</strong>（即，如果想在包外访问一个函数，它应该首首字母大写。也就是说，小写字母开头的变量或函数类似于 C 语言中被 static 修饰的变量或函数）。</p>
</li>
<li>
<p><code>init</code> 函数：所有包都可以包含一个 <code>init</code> 函数，<code>init</code> 函数不应该有任何返回值类型和参数。</p>
<ul>
<li>
<p>包的初始化顺序：1）首先初始化 <strong> 被导入的 </strong> 包；2）然后初始化 <strong> 包级别（package level）的变量 </strong>；3）紧接着<strong> 调用 <code>init</code> 函数</strong>，按照编译器解析它们的顺序进行调用。</p>
</li>
<li>
<p>如果一个包导入了另一个包，会先初始化 <strong> 被导入的 </strong> 包。</p>
</li>
<li>
<p>尽管一个包可能会被导入多次，但是它们 <strong> 只会被初始化一次</strong>。</p>
</li>
</ul>
</li>
<li>
<p>空白标识符导入包中的使用：导入了包，却不在代码中使用它，这在 Go 中是非法的，会抛出 <code>xxx.go:6: imported and not used: packagename_yyy</code>。</p>
<ul>
<li>
<p>为了避免这种程序错误，通常会在函数外调用其中的一个函数，并将返回值赋给 <code>_</code> 变量，把这一操作称为「错误屏蔽器」。</p>
</li>
<li>
<p>同时，有时我们并不想使用导入的包中的任一函数或变量，只是 <strong> 为了确保它进行初始化</strong>，这种情况可以使用空白标识符 <code>_</code>，如 <code>import _ &quot;geometry/rectangle&quot;</code>。这样在不调用包中的函数或变量时，也不会报错。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="Go 语言笔记 -7：if-else">Go 语言笔记 -7：if-else</h2>
<ol>
<li>即使 <code>if</code> 状态下仅有一条语句，也必须加 <code>&#123; &#125;</code></li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> condition &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>if</code> 还有另外一种形式，它包含一个 <code>statement</code> 可选语句部分，该组件在条件判断之前运行，语法为：<code>if statement; condition &#123;  &#125;</code>，其中 <code>statement</code> 的作用域仅在 <code>if-else</code> 范围内。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; <span class="comment">// num 的范围仅限于 if else 代码块</span></span><br><span class="line">  <span class="keyword">if</span> num:= <span class="number">10</span>; num % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">    fmt.Println(num, <span class="string">&quot;is even.&quot;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(num, <span class="string">&quot;is odd.&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>一个注意点</strong>：<code>else</code> 必须键入在 <code>&#125;</code> 后面，不能另取一行键入，因为 Go 语言默认在每条语句结束时插入一个分号，但 <code>if else</code> 是一个整体。</li>
</ol>
<h2 id="Go 语言笔记 -8：循环">Go 语言笔记 -8：循环</h2>
<ol>
<li>Go 语言中唯一的循环语句是 <code>for</code>，没有 <code>while</code> 和 <code>do while</code> 循环。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> initialisation; condition; post &#123;  </span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>for</code> 循环的三个组成部分，即初始化、条件和 post 都是可选的（可有可无），如下示例都可以（分号也是可以省略的）。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ; i &lt;= <span class="number">10</span>; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i &lt;= <span class="number">10</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    i += <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>break</code> 为跳出循环，<code>continue</code> 为不执行后续语句，进入下一次循环。</li>
</ol>
<hr>
<h2 id="Go 语言笔记 -9：switch 语句">Go 语言笔记 -9：switch 语句</h2>
<ol>
<li><code>switch</code>是一个条件语句，它可以被认为是替代多个 <code>if else</code> 子句的常用方式，<code>case</code> 不允许出现重复项。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    finger := <span class="number">4</span></span><br><span class="line">    <span class="keyword">switch</span> finger &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;Thumb&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;Index&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;Middle&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>, <span class="number">5</span>: <span class="comment">// 一个选项多个表达式</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;Ring or Pinky&quot;</span>)</span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">// 默认情况</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;incorrect finger number&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p><strong>先声明变量再使用</strong>：<code>switch varname := xxx; varname &#123;...&#125;</code>，此时的 <code>varname</code> 变量的作用域仅限于当前 <code>switch</code> 内。</p>
</li>
<li>
<p><strong>无表达式的 <code>switch</code></strong>：在 switch 语句中，表达式是可选的，可以被省略。如果省略表达式，则表示这个 switch 语句 <strong> 等同于 switch true</strong>，并且 <strong> 每个 case 表达式都被认定为有效，相应的代码块也会被执行</strong>。</p>
</li>
<li>
<p><strong>fallthrough</strong> 关键字：<code>fallthrough</code> 语句可以在已经执行完成的 case 之后，把控制权转移到下一个 case 的执行代码中，而不会跳出 switch。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> num := <span class="number">3</span>; &#123;</span><br><span class="line">        <span class="keyword">case</span> num == <span class="number">3</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;==&quot;</span>)</span><br><span class="line">            <span class="keyword">fallthrough</span></span><br><span class="line">        <span class="keyword">case</span> num &lt; <span class="number">10</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;yes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>switch 和 case 的表达式不一定是常量。</li>
</ol>
<blockquote>
<p>学习链接：<a href="https://studygolang.com/subject/2">https://studygolang.com/subject/2</a>，感谢如此优秀的教程！</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go函数</tag>
        <tag>Go判断</tag>
        <tag>Go循环</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 笔记之变量与常量</title>
    <url>/posts/230907162612.html</url>
    <content><![CDATA[<h2 id="Go 语言笔记 -1：HelloWorld">Go 语言笔记 -1：HelloWorld</h2>
<p>Go 语言是一种编译型语言，源代码都会编译成二进制机器码。</p>
<p>所有 Go 源文件都应该放置在工作区里的 src 目录下。Linux 的工作区（Workspace）应该设置在 $HOME/go，也可以通过设置 GOPATH 环境变量，用其他目录来作为工作区。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span></span><br><span class="line">  bin <span class="comment">// 编译生成的二进制文件存储位置</span></span><br><span class="line">    hello</span><br><span class="line">  src <span class="comment">// 所有 Go 源文件都应该放置在工作区里的 src 目录下</span></span><br><span class="line">    hello <span class="comment">// 为每个 project 新建一个文件夹</span></span><br><span class="line">      helloworld.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>
<p>第一个 Go 程序</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>解析：</p>
<ul>
<li>
<p><code>package main</code> - 每一个 Go 文件都应该在开头进行 package name 的声明（译注：只有可执行程序的包名应当为 main）。包（Packages）用于代码的封装与重用，这里的包名称是 main。</p>
</li>
<li>
<p><code>import &quot;fmt&quot;</code> - 我们引入了 fmt 包，用于在 main 函数里面打印文本到标准输出。</p>
</li>
<li>
<p><code>func main()</code> - main 是一个特殊的函数。整个程序就是从 main 函数开始运行的。main 函数必须放置在 main 包中。</p>
</li>
<li>
<p><code>fmt.Println(&quot;Hello World&quot;)</code> - fmt 包中的 Println 函数用于把文本写入标准输出。</p>
</li>
</ul>
<hr>
<h2 id="Go 语言笔记 -2：变量">Go 语言笔记 -2：变量</h2>
<p><strong>变量 </strong> 指定了某存储单元（Memory Location）的名称，该存储单元会存储特定类型的值。</p>
<ol>
<li>
<p>声明单个变量：var name type，例如：var age int</p>
</li>
<li>
<p>声明变量并初始化：var name type = initialValue</p>
</li>
<li>
<p>类型推断：如果变量有初始值，那么 Go 能够自动推断具有初始值的变量的类型。因此，如果变量有初始值，就可以在变量声明中省略 type， 如 var age = 16 指 age 类型为 int 型。</p>
</li>
<li>
<p>声明多个变量：var name1, name2 type = initialValue1, initialValue2</p>
</li>
<li>
<p>在一个语句中声明不同类型的变量，如：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    age = <span class="number">19</span></span><br><span class="line">    name = <span class="string">&quot;laowang&quot;</span></span><br><span class="line">    adult = <span class="literal">true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>变量的简短 <strong> 声明 </strong> 语法：<code>:=</code> 操作符，例如：<code>age, name := 20, &quot;zhangsan&quot;</code>。简短声明要求 <code>:=</code> 操作符左边：所有变量都要进行初始化且至少存在一个未声明过的变量。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a, b := <span class="number">20</span>, <span class="number">30</span> <span class="comment">// 声明 a 和 b</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;a is&quot;</span>, a, <span class="string">&quot;b is&quot;</span>, b)</span><br><span class="line">    a, b := <span class="number">40</span>, <span class="number">50</span> <span class="comment">// 错误，没有尚未声明的变量</span></span><br><span class="line">    a, c := <span class="number">40</span>, <span class="number">60</span> <span class="comment">// 正确，有新的尚未声明的变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>
<p>变量也可以在运行时进行赋值，如 <code>a := math.Min(15, 20)</code></p>
</li>
<li>
<p>由于 Go 是强类型（Strongly Typed）语言，因此不允许某一类型的变量赋值为其他类型的值。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    age := <span class="number">29</span>      <span class="comment">// age 是 int 类型</span></span><br><span class="line">    age = <span class="string">&quot;naveen&quot;</span> <span class="comment">// 错误，尝试赋值一个字符串给 int 类型变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Go 语言笔记 -3：变量类型">Go 语言笔记 -3：变量类型</h2>
<ol>
<li>Go 语言支持的变量类型：</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">bool</span><br><span class="line">数字类型</span><br><span class="line">    int8, int16, int32, int64, int</span><br><span class="line">    uint8, uint16, uint32, uint64, uint</span><br><span class="line">    float32, float64</span><br><span class="line">    complex64, complex128 // 复数型</span><br><span class="line">    byte</span><br><span class="line">    rune</span><br><span class="line">string</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在 Printf 方法中，使用 <code>%T</code> 格式说明符（Format Specifier）打印出变量的类型。Go 的 <code>unsafe</code> 包提供了一个 <code>Sizeof</code> 函数，该函数接收变量并返回它的字节大小。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;type of age is %T, size of age is %d&quot;</span>, age, unsafe.Sizeof(age))</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>复数类型：<code>complex64</code> 表示实部和虚部都是 <code>float32</code> 类型，<code>complex128</code> 表示实部和虚部都是 <code>float64</code> 类型。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c1 := <span class="built_in">complex</span>(<span class="number">5</span>, <span class="number">7</span>) <span class="comment">// 通过内置函数声明复数变量 c1</span></span><br><span class="line">c2 := <span class="number">8</span> + <span class="number">27i</span> <span class="comment">// 通过简短声明声明复数变量 c2</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>
<p>其它变量类型：<code>byte</code> 是 <code>uint8</code> 的别名， <code>rune</code> 是 <code>int32</code> 的别名。</p>
</li>
<li>
<p>Go 是强类型（Strongly Typed）语言， Go 没有自动类型提升或类型转换：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i, j <span class="type">int</span>, float = <span class="number">5</span>, <span class="number">10.2</span></span><br><span class="line">diff := i - j <span class="comment">// 错误， int - float 不被允许</span></span><br><span class="line">diff := i - <span class="type">int</span>(j) <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Go 语言笔记 -4：常量">Go 语言笔记 -4：常量</h2>
<ol>
<li>
<p>关键字：<code>const</code>，常量不能再重新赋值为其他的值。</p>
</li>
<li>
<p>常量的值会在 <strong> 编译的时候 </strong> 确定。因为函数调用发生在 <strong> 运行时</strong>，所以不能将函数的返回值赋值给常量。如：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a := math.Sqrt(<span class="number">4</span>) <span class="comment">// 允许</span></span><br><span class="line"><span class="keyword">const</span> b := math.Sqrt(<span class="number">9</span>) <span class="comment">// 不允许，编译先于运行</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>
<p>常量是可以没有类型的，如：<code>const name = &quot;zhangsan&quot;</code>；常量也可以是有类型的，如：<code>const name string = &quot;lisi&quot;</code>，即 name 是一个 string 类型的 <strong> 常量</strong>。</p>
</li>
<li>
<p>Go 的类型策略不允许将一种类型的变量赋值给另一种类型的变量。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> defaultName = <span class="string">&quot;Sam&quot;</span> <span class="comment">// 允许</span></span><br><span class="line">    <span class="keyword">type</span> myString <span class="type">string</span>  <span class="comment">// 类似于 C 语言中的 typedef char myChar</span></span><br><span class="line">    <span class="keyword">var</span> customName myString = <span class="string">&quot;Sam&quot;</span> <span class="comment">// 允许</span></span><br><span class="line">    customName = defaultName <span class="comment">// 不允许，即使 myString 是 string 类型的别名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><strong>布尔常量</strong>：字符串常量的规则适用于布尔常量。</li>
</ol>
<blockquote>
<p><code>var name = &quot;Sam&quot;</code> 无类型的 <strong> 常量 </strong> Sam 是如何赋值给<strong> 变量</strong> name 的？</p>
</blockquote>
<p>答案是 <strong> 无类型的常量有一个与它们相关联的默认类型，并且当且仅当一行代码需要时才提供它</strong>（即常量可以赋值给「合适的」类型，而不需要类型转换）。</p>
<p>在声明变量时，如果使用常量来赋值，则 <strong> 变量会从常量的默认类型中获取类型</strong>。在这种情况下，常量 “Sam” 的默认类型是字符串，所以变量 name 的类型也是字符串。</p>
<blockquote>
<p>学习链接：<a href="https://studygolang.com/subject/2">https://studygolang.com/subject/2</a>，感谢如此优秀的教程！</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go变量与常量</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 笔记之可变参数函数与 Map 集合</title>
    <url>/posts/230913161326.html</url>
    <content><![CDATA[<h2 id="Go 语言笔记 -12：可变参数函数">Go 语言笔记 -12：可变参数函数</h2>
<ol>
<li>
<p>可变参数函数是一种 <strong> 参数个数可变 </strong> 的函数。如果函数最后一个参数的类型被记作 <code>...T</code> ，这时函数可以接受任意个 <code>T</code> 类型的参数作为最后一个参数。<strong>只有 </strong> 函数的最后一个参数才允许是可变的。</p>
</li>
<li>
<p>可变参数函数的 <strong> 工作原理 </strong> 是把可变参数转换为一个新的 <strong> 切片</strong>。</p>
</li>
<li>
<p>有一个可以直接将切片传入可变参数函数的语法糖，你可以在切片后加上 <code>...</code> 后缀。这样切片将直接传入函数，不再创建新的切片。</p>
</li>
</ol>
<span id="more"></span>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">find</span><span class="params">(num <span class="type">int</span>, nums ...<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    find(<span class="number">89</span>, <span class="number">88</span>, <span class="number">89</span>, <span class="number">90</span>) <span class="comment">// 语法正确，[88, 89, 90] 将被转换为一个新的切片传入 find 函数</span></span><br><span class="line">    find(<span class="number">89</span>) <span class="comment">// 语法正确, 一个长度和容量为 0 的 nil 切片将被传入 find 函数</span></span><br><span class="line">    nums := []<span class="type">int</span>&#123;<span class="number">87</span>, <span class="number">88</span>, <span class="number">89</span>&#125;</span><br><span class="line">    find(<span class="number">89</span>, nums) <span class="comment">// 语法错误，find 的可变参数要求为 int 型，不能传入 []int 切片</span></span><br><span class="line">    find(<span class="number">89</span>, nums...) <span class="comment">// 语法正确，切片直接传入函数，不再创建新的切片</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Go 语言笔记 -13：Maps">Go 语言笔记 -13：Maps</h2>
<ol>
<li>
<p>map 是在 Go 中将值（value）与键（key）关联的 <strong> 内置类型</strong>。通过相应的键可以获取到值。</p>
</li>
<li>
<p>通过向 <code>make</code> 函数传入键和值的类型，可以创建 map。<code>make(map[type of key]type of value)</code> 是创建 map 的语法。如：<code>personSalary := make(map[string]int)</code>。</p>
</li>
<li>
<p>map 的零值是 <code>nil</code>。如果你想添加元素到 nil map 中，会触发运行时 <code>panic</code>。因此 <strong>map 必须使用 <code>make</code> 函数初始化</strong>。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> personSalary <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> personSalary == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;map is nil. Going to make one.&quot;</span>)</span><br><span class="line">        personSalary = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>) <span class="comment">// 使用 make 方法初始化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    personSalary[<span class="string">&quot;steve&quot;</span>] = <span class="number">12000</span> <span class="comment">// 给 map 添加新元素</span></span><br><span class="line">    personSalary[<span class="string">&quot;jamie&quot;</span>] = <span class="number">15000</span></span><br><span class="line">    personSalary[<span class="string">&quot;mike&quot;</span>] = <span class="number">9000</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;personSalary map contents:&quot;</span>, personSalary) <span class="comment">// map[steve:12000 jamie:15000 mike:9000]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>在声明时初始化 map：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">personSalary := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> &#123;</span><br><span class="line">        <span class="string">&quot;steve&quot;</span>: <span class="number">12000</span>,</span><br><span class="line">        <span class="string">&quot;jamie&quot;</span>: <span class="number">15000</span>, <span class="comment">// 逗号不可缺</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>
<p>获取 map 中的元素：<code>map[key]</code>。如果获取一个不存在的元素，map 会返回 <strong> 该元素类型的零值</strong>（如：<code>[]T</code> 返回 <code>nil</code>，整形返回 <code>0</code>）。</p>
</li>
<li>
<p>如何判断某个 key 是否存在于 map 中：<code>value, ok := map[key]</code>，如果 ok 是 true，表示 key 存在，key 对应的值就是 value ，反之表示 key 不存在。</p>
</li>
<li>
<p>遍历 map 中所有的元素需要用 for range 循环：<code>for key, value := range personSalary &#123;//... &#125;</code>。当使用 for range 遍历 map 时，不保证每次执行程序获取的元素顺序相同。</p>
</li>
<li>
<p>删除 map 中的元素：<code>delete(map, key)</code>，无返回值。</p>
</li>
<li>
<p>获取 map 的长度：<code>len(map)</code>。</p>
</li>
<li>
<p>和 slices 类似，map 也是 <strong> 引用类型 </strong>：当 map 被赋值为一个新变量的时候，它们指向同一个内部数据结构。因此，<strong> 改变其中一个变量，就会影响到另一变量。当 map 作为函数参数传递时也会发生同样的情况，函数中对 map 的任何修改，对于外部的调用都是可见的</strong>。</p>
</li>
<li>
<p>map 之间不能使用 <code>==</code> 操作符判断，<code>==</code> 只能用来检查 map 是否为 nil。</p>
</li>
</ol>
<blockquote>
<p>学习链接：<a href="https://studygolang.com/subject/2">https://studygolang.com/subject/2</a>，感谢如此优秀的教程！</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go可变参数函数</tag>
        <tag>Go集合Map</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 笔记之字符串和指针</title>
    <url>/posts/230915155105.html</url>
    <content><![CDATA[<h2 id="Go 语言笔记 -14：字符串">Go 语言笔记 -14：字符串</h2>
<ol>
<li>
<p>Go 语言中的字符串是一个 <strong> 字节切片</strong>。</p>
</li>
<li>
<p><code>%x</code> 格式限定符用于指定 16 进制编码，<code>%c</code> 格式限定符用于打印字符串的字符。</p>
</li>
<li>
<p>在 UTF-8 编码中，一个代码点（字符的编码）可能会占用超过一个字节的空间，所以使用 <code>%c</code> 格式打印时可能会出错，可以用 <code>rune</code> 解决。</p>
</li>
<li>
<p><code>rune</code> 是 Go 语言的内建类型，它也是 <code>int32</code> 的别称。在 Go 语言中，<code>rune</code> 表示一个代码点。代码点无论占用多少个字节，都可以用一个 <code>rune</code> 来表示。</p>
</li>
</ol>
<span id="more"></span>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">&quot;Señor&quot;</span></span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%c &quot;</span>,s[i]) <span class="comment">// 打印出错，S e Ã ± o r</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">runes := []<span class="type">rune</span>(s)</span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; <span class="built_in">len</span>(runes); i++ &#123; <span class="comment">// 字符串被转化为一个 rune 切片</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%c &quot;</span>,runes[i]) <span class="comment">// 打印正确，S e ñ o r</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>字符串的 for range 循环更简单。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printCharsAndBytes</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> index, <span class="type">rune</span> := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%c starts at byte %d\n&quot;</span>, <span class="type">rune</span>, index)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name := <span class="string">&quot;Señor&quot;</span></span><br><span class="line">    printCharsAndBytes(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">S starts at byte 0  </span></span><br><span class="line"><span class="comment">e starts at byte 1  </span></span><br><span class="line"><span class="comment">ñ starts at byte 2  // ñ 占了两个字节</span></span><br><span class="line"><span class="comment">o starts at byte 4  </span></span><br><span class="line"><span class="comment">r starts at byte 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ol start="6">
<li>用字节切片构造字符串：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包含字符串 Café 用 UTF-8 编码后的 16 进制字节</span></span><br><span class="line">byteSlice := []<span class="type">byte</span>&#123;<span class="number">0x43</span>, <span class="number">0x61</span>, <span class="number">0x66</span>, <span class="number">0xC3</span>, <span class="number">0xA9</span>&#125;</span><br><span class="line">str := <span class="type">string</span>(byteSlice)</span><br><span class="line">fmt.Println(str) <span class="comment">// Café</span></span><br></pre></td></tr></table></figure>
<ol start="7">
<li>用 <code>rune</code> 切片构造字符串：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包含字符串 Señor 的 16 进制的 Unicode 代码点</span></span><br><span class="line">runeSlice := []<span class="type">rune</span>&#123;<span class="number">0x0053</span>, <span class="number">0x0065</span>, <span class="number">0x00f1</span>, <span class="number">0x006f</span>, <span class="number">0x0072</span>&#125;</span><br><span class="line">str := <span class="type">string</span>(runeSlice)</span><br><span class="line">fmt.Println(str) <span class="comment">// Señor</span></span><br></pre></td></tr></table></figure>
<ol start="8">
<li>字符串的长度：utf-8 package 包中的 <code>func RuneCountInString(s string) (n int)</code> 方法用来 <strong> 获取字符串的长度 </strong>。这个方法传入一个字符串参数然后<strong> 返回字符串中的 rune 的数量</strong>。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">word1 := <span class="string">&quot;Señor&quot;</span> </span><br><span class="line">fmt.Println(utf8.RuneCountInString(word1)) <span class="comment">// 5</span></span><br><span class="line">word2 := <span class="string">&quot;Pets&quot;</span></span><br><span class="line">fmt.Println(utf8.RuneCountInString(word2)) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<ol start="9">
<li>字符串是不可变的：一旦一个字符串被创建，它将不可被修改。为了修改字符串，可以把字符串转化为一个 rune 切片，这个切片可以进行任何想要的改变，最后再转化为一个字符串。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mutate</span><span class="params">(s []<span class="type">rune</span>)</span></span> <span class="type">string</span> &#123;  </span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span> <span class="comment">// 修改切片</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(s) <span class="comment">// 转换为一个字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    h := <span class="string">&quot;hello&quot;</span></span><br><span class="line">    fmt.Println(mutate([]<span class="type">rune</span>(h))) <span class="comment">// 用 rune 切片构造字符串，输出 aello</span></span><br><span class="line">    fmt.Println(h) <span class="comment">// 输出 hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Go 语言笔记 -15：指针">Go 语言笔记 -15：指针</h2>
<ol>
<li>
<p>指针是一种存储变量内存地址（Memory Address）的变量。例如，变量 b 的值为 156，而 b 的内存地址为 0x1040a124，变量 a 存储了 b 的地址。我们就称 a 指向了 b。</p>
</li>
<li>
<p>指针的声明：指针变量的类型为 <code>*T</code>，该指针指向一个 <code>T</code> 类型的变量。</p>
</li>
</ol>
<ul>
<li>&amp; 操作符用于获取变量的地址。下面的程序把 b 的地址赋值给 <code>*int</code> 类型的 a。我们称 a 指向了 b。当我们打印 a 的值时，会打印出 b 的地址。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b := <span class="number">255</span></span><br><span class="line">    <span class="keyword">var</span> a *<span class="type">int</span> = &amp;b</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Type of a is %T\n&quot;</span>, a) <span class="comment">// *int</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;address of b is&quot;</span>, a)  <span class="comment">// 0x1040a124</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>
<p>指针的零值（Zero Value）是 <code>nil</code>。声明变量 <code>var b *int</code>，此时 <code>b == nil</code> 为 <code>true</code>。</p>
</li>
<li>
<p>指针的解引用：指针的解引用可以获取指针所指向的变量的值。将 <code>a</code> 解引用的语法是 <code>*a</code>。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    b := <span class="number">255</span></span><br><span class="line">    a := &amp;b</span><br><span class="line">    fmt.Println(<span class="string">&quot;address of b is&quot;</span>, a) <span class="comment">// 0x1040a124</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;value of b is&quot;</span>, *a)  <span class="comment">// 255</span></span><br><span class="line">    *a++  <span class="comment">// (*a)++</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;new value of b is&quot;</span>, b) <span class="comment">// 256</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>向函数传递指针参数：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(val *<span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    *val = <span class="number">55</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := <span class="number">58</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;value of a before function call is&quot;</span>, a) <span class="comment">// 58</span></span><br><span class="line">    b := &amp;a</span><br><span class="line">    change(b)</span><br><span class="line">    fmt.Println(<span class="string">&quot;value of a after function call is&quot;</span>, a) <span class="comment">// 55</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>假如我们想要在函数内修改一个数组，并希望调用函数的地方也能得到修改后的数组，一种解决方案是把一个指向数组的指针传递给这个函数（但 Go 语言习惯的方法是用切片处理，见序号 7）。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(arr *[3]<span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    (*arr)[<span class="number">0</span>] = <span class="number">90</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>&#125;</span><br><span class="line">    modify(&amp;a)</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>a[x]</code> 是 <code>(*a)[x]</code> 的简写形式，因此上面代码中的 <code>(*arr)[0]</code> 可以替换为 <code>arr[0]</code>。</li>
</ul>
<ol start="7">
<li><strong>不要向函数传递数组的指针，而应该使用数组切片</strong>：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(sls []<span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    sls[<span class="number">0</span>] = <span class="number">90</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>&#125;</span><br><span class="line">    modify(a[:]) <span class="comment">// 使用切片</span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>别再传递数组指针了，而是使用切片吧。上面的代码更加简洁，也更符合 Go 语言的习惯。</li>
</ul>
<blockquote>
<p>学习链接：<a href="https://studygolang.com/subject/2">https://studygolang.com/subject/2</a>，感谢如此优秀的教程！</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go字符串</tag>
        <tag>Go指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 笔记之数组与切片</title>
    <url>/posts/230912152800.html</url>
    <content><![CDATA[<h2 id="Go 语言笔记 -10：数组">Go 语言笔记 -10：数组</h2>
<ol>
<li>
<p>数组是 <strong> 同一类型元素 </strong> 的集合，Go 语言中不允许混合不同类型的元素。</p>
</li>
<li>
<p>一个数组的表示形式为 <code>[n]T</code>。n 表示数组中元素的数量，T 代表每个元素的类型。如： <code>var arr [3]int</code>。</p>
</li>
<li>
<p>数组简略声明：<code>arr := [3]int&#123;12, 78, 50&#125;</code>，在简略声明中，可对部分元素赋值：<code>arr := [3]int&#123;12&#125;</code>，剩下的元素自动赋值为 0 。</p>
</li>
<li>
<p>可以忽略声明数组的长度，并用 <code>...</code> 代替，让编译器为你自动计算长度：<code>arr := [...]int&#123;12, 21&#125;</code>。</p>
</li>
<li>
<p><strong>数组是值类型，不是引用类型 </strong>：这意味着当数组赋值给一个新变量时，该变量会得到一个原始数组的副本。<strong> 如果对新变量进行修改，不会影响原始数组</strong>。注：对切片的修改会影响原始数组。</p>
</li>
</ol>
<span id="more"></span>
<ol start="6">
<li>当数组作为参数传递给函数时，<strong>它们是按值传递，原始数组不受函数调用的影响</strong>（在函数内修改数组中的值，不影响函数外的数组）。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeLocal</span><span class="params">(num [5]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    num[<span class="number">0</span>] = <span class="number">55</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;inside function &quot;</span>, num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num := [...]<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;before passing to function &quot;</span>, num)</span><br><span class="line">    changeLocal(num) <span class="comment">// num is passed by value</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;after passing to function &quot;</span>, num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// before passing to function  [5 6 7 8 8]</span></span><br><span class="line"><span class="comment">// inside function  [55 6 7 8 8]</span></span><br><span class="line"><span class="comment">// after passing to function  [5 6 7 8 8]</span></span><br></pre></td></tr></table></figure>
<ol start="7">
<li>
<p>数组的长度：<code>len(arr)</code>。</p>
</li>
<li>
<p>数组的迭代一：for 循环。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;%d-th element of arr is %.2f\n&quot;</span>, i, arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="9">
<li>数组的迭代二：Go 提供了一种更好、更简洁的方法，通过 <strong> 使用 for 循环的 <code>range</code> 方法来遍历数组</strong>。<code>range</code> 返回索引和该索引处的值。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;%d-th element of arr is %.2f\n&quot;</span>, i, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="10">
<li>多维数组的声明方式：1）简略声明；2）先声明多维数组变量，再根据索引来对数组进行初始化。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr := [<span class="number">3</span>][<span class="number">2</span>]<span class="type">string</span>&#123; <span class="comment">// 简略声明</span></span><br><span class="line">      &#123;<span class="string">&quot;lion&quot;</span>, <span class="string">&quot;tiger&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;pigeon&quot;</span>, <span class="string">&quot;peacock&quot;</span>&#125;, <span class="comment">// this comma is necessary. The compiler will complain if you omit this comma</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v1 := <span class="keyword">range</span> arr &#123; <span class="comment">// 打印二维数组</span></span><br><span class="line">    <span class="keyword">for</span> _, v2 := <span class="keyword">range</span> v1 &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s &quot;</span>, v2)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="11">
<li>数组的缺陷：长度固定，定义好后不可改变（切片可以改变哦）。</li>
</ol>
<hr>
<h2 id="Go 语言笔记 -11：切片">Go 语言笔记 -11：切片</h2>
<ol>
<li>
<p>切片是 <strong> 由数组建立 </strong> 的一种方便、灵活且功能强大的包装（Wrapper）。<strong>切片本身不拥有任何数据 </strong>，它只是对现有数组的<strong> 引用</strong>。</p>
</li>
<li>
<p>创建一个切片 A ：带有 <code>T</code> 类型元素的切片由 <code>[]T</code> 表示。语法：<code>a[start:end]</code> 创建一个从 a 数组索引 start 开始到 end - 1 结束的切片。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">76</span>, <span class="number">77</span>, <span class="number">78</span>, <span class="number">79</span>, <span class="number">80</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b []<span class="type">int</span> = a[<span class="number">1</span>:<span class="number">4</span>] <span class="comment">// 数组切片</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>创建一个切片 B ：创建一个数组，并返回一个存储在 c 中的 <strong> 切片引用</strong>。注意：<code>[]</code> 内无内容。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c := []<span class="type">int</span>&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125; <span class="comment">// creates and array and returns a slice reference</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>
<p><strong>对切片的修改会影响原始数组</strong>。当多个切片共用相同的底层数组时，每个切片所做的更改将反映在原始数组中。</p>
</li>
<li>
<p><strong>切片的长度和容量</strong>：切片的长度是切片中的元素数。切片的容量是从创建切片索引开始（到数组末尾）的底层数组中的元素数。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fruitarray := [...]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>&#125;</span><br><span class="line">    fruitslice := fruitarray[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">    fmt.Println(<span class="string">&quot;length of slice: %d, capacity: %d&quot;</span>, <span class="built_in">len</span>(fruitslice), <span class="built_in">cap</span>(fruitslice)) <span class="comment">// 2, 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>切片可以重置其长度为其容量：<code>slicename[:cap(slicename)]</code>。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fruitarray := [...]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>&#125;</span><br><span class="line">    fruitslice := fruitarray[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">    fmt.Println(<span class="string">&quot;length of slice: %d, capacity: %d&quot;</span>, <span class="built_in">len</span>(fruitslice), <span class="built_in">cap</span>(fruitslice)) <span class="comment">// 2, 3. print: [b, c]</span></span><br><span class="line">    fruitslice = fruitslice[:<span class="built_in">cap</span>(fruitslice)] <span class="comment">// re-slicing furitslice till its capacity. print: [b, c, d]</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;After re-slicing length is&quot;</span>, <span class="built_in">len</span>(fruitslice), <span class="string">&quot;and capacity is&quot;</span>, <span class="built_in">cap</span>(fruitslice)) <span class="comment">// 3, 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>
<p><strong>使用 <code>make</code> 创建一个切片</strong>：<code>func make ([]T, len, cap)</code> 通过传递类型、长度和容量来创建切片。其中，容量是可选参数，默认值为切片长度。<strong><code>make</code> 函数创建一个数组，并返回引用该数组的切片</strong>。如 <code>arrslice := make([]float64, 5, 5)</code>。</p>
</li>
<li>
<p>切片是动态的，可以使用 <code>func append(slice []T, x ...T) []T</code> 将新元素追加到切片上。其中 <code>x ...T</code> 表示该函数接收 <code>T</code> 类型的参数 <code>x</code> 的个数是可变的，如：<code>arrslice = append(arrslice, 5.6, 7.3)</code>。</p>
</li>
</ol>
<blockquote>
<p><code>append</code> 函数会返回一个 <strong> 新的切片</strong>，其中包含了原始切片和追加的元素：</p>
<ul>
<li>如果原始切片的容量足够，<code>append</code> 函数会在原始切片的基础上进行追加；</li>
<li>如果原始切片的容量不够，<code>append</code> 函数会创建一个新的底层数组，并将原始切片中的元素和追加的元素复制到新的底层数组中。</li>
</ul>
<p>因此，append 函数 <strong> 返回的切片可能指向一个新的底层数组，而不是原始切片所指向的底层数组</strong>。</p>
</blockquote>
<ol start="9">
<li>
<p>数组是固定的，但 <strong> 切片具有动态长度 </strong>：切片是由一个指向数组的指针、长度和容量组成的数据结构。当我们向切片中追加元素时，如果切片的长度小于容量，新元素会直接添加到切片的末尾，切片的长度会增加。但是，如果追加元素后切片的长度超过了容量，Go 语言会创建一个新的更大的底层数组，将原来的元素复制到新的数组中，并将新元素添加到新数组的末尾。然后，切片会指向这个新数组（<strong> 相比于旧切片，引用类型的地址改变了</strong>），并且容量会成为原来的两倍（并不是每次执行 <code>append</code> 时容量都会变成旧切片的两倍，只有当长度超过容量时，才会扩充一倍容量）。这样，切片就具有了动态长度的特性。</p>
</li>
<li>
<p>切片类型的零值为 <code>nil</code>：一个 <code>nil</code> 切片的长度和容量为 0，可以使用 <code>append</code> 函数将值追加到 <code>nil</code> 切片。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names []<span class="type">string</span> <span class="comment">// zero value of a slice is nil</span></span><br><span class="line"><span class="keyword">if</span> names == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;slice is nil going to append&quot;</span>)</span><br><span class="line">    names = <span class="built_in">append</span>(names, <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Sebastian&quot;</span>, <span class="string">&quot;Vinay&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;names contents:&quot;</span>, names)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="11">
<li>
<p><code>...</code> 可将一个切片添加到另一个切片中：<code>append(slice1, slice2...)</code>。</p>
</li>
<li>
<p>切片的函数传递：切片在内部可由一个结构体类型表示，即：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    Length         <span class="type">int</span></span><br><span class="line">    Capacity       <span class="type">int</span></span><br><span class="line">    ZerothElement  *<span class="type">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>切片本身包含了长度、容量和指向底层数组首个元素的指针。当切片作为参数传递给函数时，虽然是通过值传递，但是切片内部的指针变量（这里的<code>byte</code>）仍然指向相同的底层数组。因此，当函数内部修改底层数组的值时，这些修改在函数外部是可见的。</p>
</li>
<li>
<p>然而，如果函数内部修改了切片的长度或容量，将会创建一个新的切片，而不会影响原始切片。这是因为切片的长度和容量是切片结构体的字段，而非底层数组的属性。因此，修改切片的长度或容量会创建一个新的切片结构体，其中的指针变量仍然指向原始的底层数组，但是新的切片具有不同的长度和容量。</p>
</li>
<li>
<p>因此，可以说当切片传递给函数时，函数内部对底层数组的修改，在函数外部是可见的，但是对切片的长度和容量的修改是不可见的。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifySlice</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">100</span> <span class="comment">// 修改底层数组的值</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">200</span>) <span class="comment">// 创建新的切片，不影响原始切片</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Inside modifySlice:&quot;</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    numbers := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Before modifySlice:&quot;</span>, numbers)</span><br><span class="line">    modifySlice(numbers)</span><br><span class="line">    fmt.Println(<span class="string">&quot;After modifySlice:&quot;</span>, numbers)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Before modifySlice: [1 2 3 4 5]</span></span><br><span class="line"><span class="comment">// Inside modifySlice: [100 2 3 4 5 200]</span></span><br><span class="line"><span class="comment">// After modifySlice: [100 2 3 4 5]  // 函数内部对底层数组的修改在函数外部是可见的</span></span><br></pre></td></tr></table></figure>
<ol start="13">
<li><strong>多维切片</strong>：类似于多维数组，但每行索引对应的元素数量可以不等于其它行。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pls := [][]<span class="type">string</span> &#123;</span><br><span class="line">      &#123;<span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;JavaScript&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;Go&quot;</span>, <span class="string">&quot;Rust&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="14">
<li>内存优化：切片持有对底层数组的引用，只要切片在内存中，数组就不能被垃圾回收。一种回收数组的方法时使用 <code>copy</code> 函数 <code>func copy(dst, src[]T) int</code> 来生成一个切片的副本，这样就可以使用新的切片，原始数组也可以被垃圾回收。注：返回的 int 类型的值为 dst 的长度。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countries</span><span class="params">()</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    countries := []<span class="type">string</span>&#123;<span class="string">&quot;USA&quot;</span>, <span class="string">&quot;Singapore&quot;</span>, <span class="string">&quot;Germany&quot;</span>, <span class="string">&quot;India&quot;</span>, <span class="string">&quot;Australia&quot;</span>&#125;</span><br><span class="line">    neededCountries := countries[:<span class="built_in">len</span>(countries)<span class="number">-2</span>]</span><br><span class="line">    countriesCpy := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(neededCountries))</span><br><span class="line">    <span class="built_in">copy</span>(countriesCpy, neededCountries) <span class="comment">//copies neededCountries to countriesCpy</span></span><br><span class="line">    <span class="keyword">return</span> countriesCpy</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    countriesNeeded := countries()</span><br><span class="line">    fmt.Println(countriesNeeded)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>学习链接：<a href="https://studygolang.com/subject/2">https://studygolang.com/subject/2</a>，感谢如此优秀的教程！</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go数组</tag>
        <tag>Go切片</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 1029 两地调度</title>
    <url>/posts/231107094652.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/two-city-scheduling/">1029 两地调度</a>：公司计划面试 <code>2N</code> 人。第 <code>i</code> 个面试者飞往 A 市的费用为 <code>costs[i][0]</code>，飞往 B 市的费用为 <code>costs[i][1]</code>。返回将每个面试者都飞到某一座城市的最低费用，要求每个城市都有 <code>N</code> 个面试者抵达。</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：costs = [[10,20],[30,200],[400,50],[30,20]]</span><br><span class="line">输出：110</span><br><span class="line">解释：</span><br><span class="line">第一个人去 a 市，费用为 10。</span><br><span class="line">第二个人去 a 市，费用为 30。</span><br><span class="line">第三个人去 b 市，费用为 50。</span><br><span class="line">第四个人去 b 市，费用为 20。</span><br><span class="line"></span><br><span class="line">最低总费用为 10 + 30 + 50 + 20 = 110，每个城市都有一半的人在面试。</span><br></pre></td></tr></table></figure>
<h2 id="排序 - 贪心算法">排序 + 贪心算法</h2>
<p>要求每个城市都有 <code>N</code> 个面试者抵达。我们可以选择 <code>N</code> 个面试者去 A 市，那么剩下的 <code>N</code> 个面试者自然就得去 B 市了。<strong>那哪些人去 A 市呢</strong>？</p>
<p>「每个人」只需要考虑自己选哪个城市更省钱，但必须要有 <code>N</code> 个人去 A 市，<code>N</code> 个人去 B 市。因此，我们只需要 <strong> 比较「所有人」去 B 市与去 A 市的成本差——差值越大，说明去 A 市比去 B 市省出来的成本更多；差值越小，说明能省出来的成本就越少，这些人就去 B 市吧</strong>。</p>
<p>时间复杂度：<code>O(nlogn)</code>，排序所需时间，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *pa, <span class="type">const</span> <span class="type">void</span> *pb)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *arr1 = *(<span class="type">const</span> <span class="type">int</span> **)pa;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *arr2 = *(<span class="type">const</span> <span class="type">int</span> **)pb;</span><br><span class="line">    <span class="comment">// 按 B 市与 A 市成本差降序排序</span></span><br><span class="line">    <span class="keyword">return</span> (arr2[<span class="number">1</span>] - arr2[<span class="number">0</span>]) - (arr1[<span class="number">1</span>] - arr1[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">twoCitySchedCost</span><span class="params">(<span class="type">int</span>** costs, <span class="type">int</span> costsSize, <span class="type">int</span>* costsColSize)</span> &#123;</span><br><span class="line">    qsort(costs, costsSize, <span class="keyword">sizeof</span>(costs[<span class="number">0</span>]), cmp);</span><br><span class="line">    <span class="type">int</span> minCost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; costsSize; ++i) &#123;</span><br><span class="line">        <span class="comment">// 前一半差值大的去 A 市, 后一半差值小的去 B 市</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; (costsSize &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">            minCost += costs[i][<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minCost += costs[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 117 填充每个节点的下一个右侧节点指针 II</title>
    <url>/posts/231103121209.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117 填充每个节点的下一个右侧节点指针 II</a>：给定一个包含指针 <code>next</code> 成员的二叉树：填充它的每个 <code>next</code> 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 <code>next</code> 指针设置为 <code>NULL</code>。初始状态下，所有 <code>next</code> 指针都被设置为 <code>NULL</code>。</p>
<span id="more"></span>
<p>树结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node *left;</span><br><span class="line">    Node *right;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例图：<br>
<img src="https://assets.leetcode.com/uploads/2019/02/15/117_sample.png" alt=""></p>
<h2 id="队列 - 层序遍历">队列 + 层序遍历</h2>
<p>根据题目描述，「填充它的每个 <code>next</code> 指针，让这个指针指向（同层的）其下一个右侧节点」，我们很容易想到使用「层序遍历」解决这个问题。而层序遍历通常需要借助 FIFO 队列实现。</p>
<p><strong>关于借助队列的树的层序遍历</strong>：首先要入队根节点；然后，记录队列中的节点个数 <code>size</code>；随后，弹出 <code>size</code> 个节点，在弹出的过程中入队弹出节点的左、右节点；最后，在这 <code>size</code> 个节点弹出后，队列中剩下的节点，就是刚刚入队的树的下一层节点。只要队列不为空，我们就反复进行上述操作，直到队列为空为止（二叉树的叶子层没有左、右节点，便不会再有节点入队，队列也就为空了）。</p>
<p>时间复杂度：<code>O(n)</code>，一趟遍历，空间复杂度：<code>O(n)</code>，需要使用队列保存二叉树中的节点。</p>
<blockquote>
<p>关于队列，我们可以使用 <a href="https://pursue26.github.io/posts/231017105123.html"> 数据结构之队列（链表实现）</a>中实现的接口。但是，为了简单、清晰，我在这里直接使用数组模拟 FIFO 队列。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">TreeNode_t</span>;</span></span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">connect</span><span class="params">(<span class="keyword">struct</span> Node* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode_t *<span class="built_in">queue</span>[<span class="number">6000</span>];</span><br><span class="line">    <span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;  <span class="comment">// 队列的头尾指针</span></span><br><span class="line">    <span class="built_in">queue</span>[rear++] = root;  <span class="comment">// 树不为空, 首先入队根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (rear - front &gt; <span class="number">0</span>) &#123;  <span class="comment">// 队列不为空</span></span><br><span class="line">        <span class="type">int</span> size = rear - front;  <span class="comment">// 当前队列的数据大小</span></span><br><span class="line">        TreeNode_t *curNode = <span class="literal">NULL</span>, *preNode = <span class="literal">NULL</span>;  <span class="comment">// 当前节点和上一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 弹出这几个数据（某一层的所有节点）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            curNode = <span class="built_in">queue</span>[front++];  <span class="comment">// 首指针后移</span></span><br><span class="line">            <span class="comment">// 链接前后两个节点, 并更新上一个节点为当前节点</span></span><br><span class="line">            <span class="keyword">if</span> (preNode) &#123;</span><br><span class="line">                preNode-&gt;next = curNode;</span><br><span class="line">            &#125;</span><br><span class="line">            preNode = curNode;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 入队左右子树的节点</span></span><br><span class="line">            <span class="keyword">if</span> (curNode-&gt;left) &#123;</span><br><span class="line">                <span class="built_in">queue</span>[rear++] = curNode-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curNode-&gt;right) &#123;</span><br><span class="line">                <span class="built_in">queue</span>[rear++] = curNode-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每层的最后一个节点指向空地址</span></span><br><span class="line">        curNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="利用已建立的链表构建下一层链表">利用已建立的链表构建下一层链表</h2>
<p>根据题目描述，「填充它的每个 <code>next</code> 指针，让这个指针指向（同层的）其下一个右侧节点」。这样填充后，二叉树的每一层都将是一个单链表，链表的头节点是每层最左侧的树节点。这样，我们就可以根据链表中的节点，获得它的下一层的左、右孩子节点。</p>
<p>因此，我们可以利用当前层的链表 <code>currLayer</code> 来构建下一层的链表 <code>nextLayer</code>：</p>
<ul>
<li>下一层的构建过程就是：不断的访问 <code>currLayer</code> 中的节点，通过它访问下一层的左、右孩子节点，将这些孩子链接起来，就是 <code>nextLayer</code>；</li>
<li>构建的下一层的链表时，要记录下一层的头结点，以便更新当前层为下一层。
<ul>
<li>下一层的头结点，就是 <code>currLayer</code> 中的节点里，第一个有孩子节点（若有左、右孩子，左孩子优先）。</li>
</ul>
</li>
</ul>
<p>最后，当下一层为叶子结点层时，便不会有下一层链表，当前层链表会更新为 <code>NULL</code>，标志着每层的链表构建完成。</p>
<p>时间复杂度：<code>O(n)</code>，一趟遍历，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">connect</span><span class="params">(<span class="keyword">struct</span> Node* root)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">currLayer</span> =</span> root;  <span class="comment">// 首层的链表为树的根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要当前层不为空, 就可以试探下一层</span></span><br><span class="line">    <span class="keyword">while</span> (currLayer) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">node</span> =</span> currLayer;  <span class="comment">// 获取当前层的头节点, 用于遍历</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">nextLayer</span> =</span> <span class="literal">NULL</span>;  <span class="comment">// 记录下一层的头节点</span></span><br><span class="line">        <span class="type">bool</span> isFirst = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        currLayer = <span class="literal">NULL</span>;  <span class="comment">// 置空当前层</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (node) &#123;  <span class="comment">// 遍历当前层构成的链表</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">data</span>[2] =</span> &#123;node-&gt;left, node-&gt;right&#125;;</span><br><span class="line">            <span class="comment">// 遍历当前节点的左右节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (data[i]) &#123;</span><br><span class="line">                    <span class="comment">// 判断是否是下一层的第一个节点</span></span><br><span class="line">                    <span class="keyword">if</span> (isFirst) &#123;</span><br><span class="line">                        nextLayer = data[i];</span><br><span class="line">                        currLayer = nextLayer;  <span class="comment">// 更新当前层为下一层头节点, 用于下一轮最外层 while 循环</span></span><br><span class="line">                        isFirst = <span class="literal">false</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        nextLayer-&gt;next = data[i];  <span class="comment">// 链接下一层的节点</span></span><br><span class="line">                        nextLayer = nextLayer-&gt;next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>评论区用户 @M9988：方法二确实比方法一巧妙。但是，作为面试准备的话，我更推崇练习方法一。因为方法一才是层序（BFS）遍历的通用模式。把这个 BFS 模板练熟以后，面试方可信手拈来（再在里面做附加逻辑）。方法二，技巧性强，可以提高，但是面试的话还是把场景套上模板的熟练能力。</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树遍历</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树遍历</tag>
        <tag>层序遍历</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 1410 实体解析器</title>
    <url>/posts/231123181539.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/html-entity-parser/">1410 HTML 实体解析器 </a> 是一种特殊的解析器，它将 HTML 代码作为输入，并用字符本身替换掉所有这些特殊的字符实体。给你输入字符串 <code>text</code> ，请你实现一个 HTML 实体解析器，返回解析器解析后的字符串。</p>
<span id="more"></span>
<p>HTML 里这些特殊字符和它们对应的字符实体包括：<br>
双引号：字符实体为 <code>&amp;quot;</code> ，对应的字符是 <code>&quot;</code> 。<br>
单引号：字符实体为 <code>&amp;apos;</code> ，对应的字符是 <code>'</code> 。<br>
与符号：字符实体为 <code>&amp;amp;</code> ，对应对的字符是 <code>&amp;</code> 。<br>
大于号：字符实体为 <code>&amp;gt;</code> ，对应的字符是 <code>&gt;</code> 。<br>
小于号：字符实体为 <code>&amp;lt;</code> ，对应的字符是 <code>&lt;</code> 。<br>
斜线号：字符实体为 <code>&amp;frasl;</code> ，对应的字符是 <code>/</code> 。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：text = &quot;&amp;amp; is an HTML entity but &amp;ambassador; is not.&quot;</span><br><span class="line">输出：&quot;&amp; is an HTML entity but &amp;ambassador; is not.&quot;</span><br><span class="line"></span><br><span class="line">输入：text = &quot;and I quote: &amp;quot;...&amp;quot;&quot;</span><br><span class="line">输出：&quot;and I quote: \&quot;...\&quot;&quot;</span><br><span class="line"></span><br><span class="line">输入：text = &quot;&amp;&amp;&amp;&quot;</span><br><span class="line">输出：&quot;&amp;&amp;&amp;&quot;</span><br></pre></td></tr></table></figure>
<h2 id="哈希表 - 模拟">哈希表 + 模拟</h2>
<p>这个解法，是我今天刷题时写的，主要练习一下使用 <code>uthash.h</code> 构建 key 为字符串，value 为字符的哈希表。</p>
<p>解法描述：</p>
<ol>
<li>首先，我们可以将这六个字符实体存入一个哈希表中，它的 key 为字符实体，value 为对应的字符；</li>
<li>然后，向右遍历给定的文本 <code>text</code>，当遍历到的字符是 <code>&amp;</code> 时，我们就可以查表判断 <code>&amp;</code> 字符之后的一段字符串，是否是这 6 个字符实体中的一个：
<ul>
<li>如果是，则替换为对应的字符；如果遍历完这一段字符，也没找到，则不替换；</li>
<li>如果中间遇到新的 <code>&amp;</code>，则不应替换，并及时停止、继续步骤 2。</li>
</ul>
</li>
<li>遍历完文本 <code>text</code> 后，则字符实体替换结束。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建 key 为字符串，value 为字符的哈希表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *key;</span><br><span class="line">    <span class="type">char</span> val;</span><br><span class="line">    UT_hash_handle hh;</span><br><span class="line">&#125; HashItem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代地释放所有哈希节点的空间</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hashFree</span><span class="params">(HashItem **obj)</span> &#123;</span><br><span class="line">    HashItem *curr = <span class="literal">NULL</span>, *tmp = <span class="literal">NULL</span>;</span><br><span class="line">    HASH_ITER(hh, *obj, curr, tmp) &#123;</span><br><span class="line">        HASH_DEL(*obj, curr);  </span><br><span class="line">        <span class="built_in">free</span>(curr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LEN (7)  <span class="comment">// strlen(&quot;&amp;frasl;&quot;)</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">entityParser</span><span class="params">(<span class="type">char</span>* text)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *entities[] = &#123;<span class="string">&quot;&amp;quot;&quot;</span>, <span class="string">&quot;&amp;apos;&quot;</span>, <span class="string">&quot;&amp;amp;&quot;</span>, <span class="string">&quot;&amp;gt;&quot;</span>, <span class="string">&quot;&amp;lt;&quot;</span>, <span class="string">&quot;&amp;frasl;&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="type">char</span> entitiesVal[] = &#123;<span class="string">&#x27;\&quot;&#x27;</span>, <span class="string">&#x27;\&#x27;&#x27;</span>, <span class="string">&#x27;&amp;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;/&#x27;</span>&#125;;</span><br><span class="line">    HashItem *hashTbl = <span class="literal">NULL</span>, *hashNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; entities[i]; i++) &#123;</span><br><span class="line">        hashNode = (HashItem *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashItem));</span><br><span class="line">        hashNode-&gt;key = entities[i];</span><br><span class="line">        hashNode-&gt;val = entitiesVal[i];</span><br><span class="line">        <span class="comment">// 已知添加的 key 不会重复，这里就不在添加前先查找 key 是否存在了</span></span><br><span class="line">        HASH_ADD_STR(hashTbl, key, hashNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(text), ;</span><br><span class="line">    <span class="type">char</span> *ans = (<span class="type">char</span> *)<span class="built_in">malloc</span>((n + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (text[i] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (text[i] != <span class="string">&#x27;&amp;&#x27;</span>) &#123; <span class="comment">// 不是字符实体首字符</span></span><br><span class="line">            ans[idx++] = text[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 是字符实体首字符</span></span><br><span class="line">            hashNode = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="type">char</span> temp[<span class="number">8</span>] = &#123;<span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历接下可能出现字符实体的一段字符串</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; fmin(i + MAX_LEN, n); j++) &#123;</span><br><span class="line">                temp[j - i] = text[j];</span><br><span class="line">                HASH_FIND_STR(hashTbl, temp, hashNode);</span><br><span class="line">                <span class="keyword">if</span> (hashNode) &#123; <span class="comment">// 找到则替换，指针后移特定长度</span></span><br><span class="line">                    ans[idx++] = hashNode-&gt;val;</span><br><span class="line">                    i = j + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!hashNode) &#123; <span class="comment">// 遍历完也没找到</span></span><br><span class="line">                ans[idx++] = text[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans[idx] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    hashFree(&amp;hashTbl);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑最坏情况，如字符串 <code>&amp;&amp;&amp;&amp;&amp;&amp;</code>。在外循环中，遍历的每个位置都要进入内循环去查表，在内层循环中，每次都是探测到「一段字符串」的 <strong> 最后位置</strong>，才发现不是字符实体。</p>
<ul>
<li>时间复杂度：<code>O(kn)</code>，<code>k</code> 表示字符实体的最大长度，哈希表查表为 <code>O(1)</code>。</li>
<li>空间复杂度：<code>O(s + 6)</code>，<code>s</code> 表示字符实体的长度和，为哈希表存储的 6 个字符实体的空间。</li>
</ul>
<h2 id="字符串操作 - 模拟（官方）">字符串操作 + 模拟（官方）</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">entityChar</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *entity;</span><br><span class="line">    <span class="type">char</span> character;</span><br><span class="line">&#125; EntityChar;</span><br><span class="line"></span><br><span class="line">EntityChar entityList[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;&amp;quot;&quot;</span>, <span class="string">&#x27;\&quot;&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;&amp;apos;&quot;</span>, <span class="string">&#x27;\&#x27;&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;&amp;amp;&quot;</span>, <span class="string">&#x27;&amp;&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;&amp;gt;&quot;</span>, <span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;&amp;lt;&quot;</span>, <span class="string">&#x27;&lt;&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;&amp;frasl;&quot;</span>, <span class="string">&#x27;/&#x27;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">entityParser</span><span class="params">(<span class="type">char</span> *text)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(text);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="keyword">sizeof</span>(entityList) / <span class="keyword">sizeof</span>(entityList[<span class="number">0</span>]);  <span class="comment">// 字符实体的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *ans = (<span class="type">char</span> *)<span class="built_in">malloc</span>((n + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="type">char</span> *p = ans;  <span class="comment">// 使用指针的方式填充结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">        <span class="type">bool</span> isEntity = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (text[i] == <span class="string">&#x27;&amp;&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line">                <span class="type">char</span> *pKey = entityList[j].entity;</span><br><span class="line">                <span class="type">char</span> *pVal = &amp;entityList[j].character;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strncmp</span>(text + i, pKey, <span class="built_in">strlen</span>(pKey)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">strcpy</span>(p, pVal);  <span class="comment">// 这样写可以兼容值是字符串的情况</span></span><br><span class="line">                    p += <span class="built_in">strlen</span>(pVal);</span><br><span class="line">                    i += <span class="built_in">strlen</span>(pKey);</span><br><span class="line">                    isEntity = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isEntity) &#123;</span><br><span class="line">            *(p++) = text[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑最坏情况，如字符串 <code>&amp;&amp;&amp;&amp;&amp;&amp;</code>。在外循环中，遍历的每个位置都要进入内循环去查表，在内层循环中，要比较 <strong> 每一个长度不同 </strong> 的字符实体。</p>
<ul>
<li>时间复杂度：<code>O(sn)</code>，<code>s</code> 为字符实体的长度和。</li>
<li>空间复杂度：<code>O(s + 6)</code>，变量 <code>entityList</code> 的空间。</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>哈希表</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 142 环形链表 II</title>
    <url>/posts/231102165703.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142 环形链表 II</a>：给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 <code>pos</code> 是 -1，则在该链表中没有环。注意：<code>pos</code> 不作为参数进行传递，仅仅是为了标识链表的实际情况。说明：不允许修改给定的链表。</p>
<span id="more"></span>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入: head = [3,2,0,-4], pos = 1</span><br><span class="line">输出: 返回索引为 1 的链表节点 </span><br><span class="line">解释: 链表中有一个环，其尾部连接到第二个节点。</span><br><span class="line"></span><br><span class="line">输入: head = [1,2], pos = 0</span><br><span class="line">输出: 返回索引为 0 的链表节点 </span><br><span class="line">解释: 链表中有一个环，其尾部连接到第一个节点。</span><br><span class="line"></span><br><span class="line">输入: head = [1], pos = -1</span><br><span class="line">输出: 返回 null </span><br><span class="line">解释: 链表中没有环。</span><br></pre></td></tr></table></figure>
<h2 id="哈希表 - 遍历">哈希表 + 遍历</h2>
<p>我们可以借助一个哈希表来存储链表中的节点，随着遍历的进行，会第二次遇到相同的节点，这个最先遇到的节点就是入环的第一个节点。</p>
<p>时间复杂度：<code>O(n)</code>，一趟遍历，空间复杂度：<code>O(n)</code>，哈希表最多存储链表的全部节点。</p>
<h2 id="快慢指针">快慢指针</h2>
<p>前置知识：<strong>使用快慢指针可以判断链表中是否存在环。若存在环，则快慢指针终有相遇的时候，若不存在环，快指针最后会退出链表</strong>。</p>
<p>因此，判断环形链表入环的第一个节点，也可以使用快慢指针。</p>
<p><img src="../images/leetcode/lc-142.png" alt=""></p>
<p>如上图，当快慢指针在位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span> 相遇时，假设快指针绕环走过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 圈，那么其走过链表的总长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>+</mo><mi>n</mi><mo stretchy="false">(</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a + b + n(b + c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span>。同样地，慢指针绕环走过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 圈，那么其走过链表的总长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>+</mo><mi>m</mi><mo stretchy="false">(</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a + b + m(b + c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span>。</p>
<p>假设快指针每次走 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 步，慢指针每次走 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 步，那么有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>+</mo><mi>n</mi><mo stretchy="false">(</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>+</mo><mi>m</mi><mo stretchy="false">(</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a + b + n(b + c) = 2(a + b + m(b + c))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，化简得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>=</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a+b = (n - 2m)(b + c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span>。</p>
<p>那么，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 分别是几圈呢？</p>
<p>当慢指针第一次进入环的起始位置时（假设为位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>），由于快指针一定在慢指针前面，所以此时快指针已经在环上（假设为位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>）。因为快指针的速度是慢指针的速度的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 倍，当它们在环上移动时，慢指针移动一圈会又回到环的起点位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>，此时快指针移动了两圈也回到位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>。</p>
<p>相同的时间下，快指针在走这两圈的路上一定会遇到（且为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 次）只走一圈的满指针；且因为慢指针慢，要「追上」慢指针，快指针一定会走过环一圈，使其「落后于」慢指针，然后再相遇，故 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>m</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n = 1, m = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。代入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>=</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a+b = (n - 2m)(b + c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span> 有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a = c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span>。</p>
<p>因此，我们 <strong> 只需要在快慢指针相遇时，再申请一个指针，从链表头开始走（与慢指针同速度）。当慢指针和这个新申请的指针相遇时，就是环形链表入环的第一个节点</strong>。</p>
<p>时间复杂度：<code>O(n)</code>，一趟遍历，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode *<span class="title function_">detectCycle</span><span class="params">(<span class="keyword">struct</span> ListNode *head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">slow</span> =</span> head, *fast = head, *node = head;</span><br><span class="line">    <span class="comment">// 判断快指针能不能再往后移动两个节点</span></span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="comment">// 相遇</span></span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未相遇</span></span><br><span class="line">    <span class="keyword">if</span> ((fast == <span class="literal">NULL</span>) || (fast-&gt;next == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确定环形链表入环的第一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (node != slow) &#123;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 146 LRU 缓存</title>
    <url>/posts/231201184542.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/lru-cache/">LRU 缓存</a>：请你设计并实现一个满足 LRU（Least Recently Used）缓存约束的数据结构。</p>
<p>实现 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code> 以正整数作为容量 <code>capacity</code> 初始化 LRU 缓存。</li>
<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code>。</li>
<li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。<strong>如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该逐出最久未使用的关键字</strong>。</li>
</ul>
<p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入 </span><br><span class="line">[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br><span class="line"> 输出 </span><br><span class="line">[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br><span class="line"></span><br><span class="line"> 解释</span><br><span class="line">LRUCache lRUCache = new LRUCache(2);</span><br><span class="line">lRUCache.put(1, 1); // 缓存是 &#123;1=1&#125;</span><br><span class="line">lRUCache.put(2, 2); // 缓存是 &#123;1=1, 2=2&#125;</span><br><span class="line">lRUCache.get(1);    // 返回 1</span><br><span class="line">lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br><span class="line">lRUCache.get(2);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br><span class="line">lRUCache.get(1);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.get(3);    // 返回 3</span><br><span class="line">lRUCache.get(4);    // 返回 4</span><br></pre></td></tr></table></figure>
<h2 id="题目分析">题目分析</h2>
<p>最近最久使用页面置换算法（Least Recently Used, LRU）是操作系统中局部页面置换算法中性能较好的一种算法，当一个缺页中断发生时，它选择 <strong> 最近最久未使用 </strong> 的那个页面淘汰。</p>
<p>在题目中，如果 <code>get</code> 方法获取的关键字存在于缓存中，除了要返回关键字对应的值，同时 <strong> 这条记录将会被刷新为最近（最新）被使用的一条记录 </strong>。同样地，如果 <code>put</code> 方法存储的关键字存在于缓存中，除了要修改关键字对应的值，同时<strong> 这条记录也将会被刷新为最近（最新）被使用的一条记录</strong>。</p>
<p>题目还要求使用 <code>O(1)</code> 的平均时间复杂度完成 <code>get</code> 和 <code>put</code> 方法，这可以使用「双向链表」和「哈希表」来共同设计这个 LRU 缓存数据结构。</p>
<h2 id="双向链表 - 哈希表">双向链表 + 哈希表</h2>
<p>使用「双向链表」和「哈希表」来共同设计这个 LRU 缓存数据结构：</p>
<ul>
<li>双向链表用于维护缓存中的记录，使得这些记录按照访问时间顺序排序，也就是「链表头为最近最久未使用」的一条记录，「链表尾为最新使用」的一条记录。</li>
<li>哈希表用于存储「节点关键字和它在链表中的地址」。</li>
</ul>
<p>这样，我们在进行 <code>get</code> 操作时，可以使用关键字查找哈希表中的 <code>key</code>，来获取它在双向链表中的地址：</p>
<ul>
<li>若查找失败，则返回 <code>-1</code>；</li>
<li>若查找成功，则将对应的节点从链表头部（或中间、尾部）移动到链表的尾部。</li>
</ul>
<p>在进行 <code>put</code> 操作时，可以使用关键字查找哈希表中的 <code>key</code>，来获取它在双向链表中的地址：</p>
<ul>
<li>若查找成功，则将对应的节点从链表头部（或中间、尾部）移动到链表的尾部；</li>
<li>若查找失败，则需要新建一个节点并将其追加到链表尾部，在追加节点前，需要判断缓存大小是否小于容量大小：
<ul>
<li>若小于，则直接新建一个节点并将其追加到链表尾部即可；</li>
<li>若不小于，则需要删除链表头的节点，并将该节点从哈希表中删除；再新建一个节点并将其追加到链表尾部。</li>
</ul>
</li>
</ul>
<h3 id="数据结构设计">数据结构设计</h3>
<p>双向链表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义双向链表的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">doubleLinked</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> page;  <span class="comment">// 键，逻辑页面</span></span><br><span class="line">    <span class="type">int</span> frame;  <span class="comment">// 值，物理页帧面</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">doubleLinked</span> *<span class="title">prev</span>;</span>  <span class="comment">// 前一个节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">doubleLinked</span> *<span class="title">next</span>;</span>  <span class="comment">// 后一个节点指针</span></span><br><span class="line">&#125; stDLinked;</span><br></pre></td></tr></table></figure>
<p>哈希表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义哈希表的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> key;  <span class="comment">// 键，对应着双向链表的键</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">doubleLinked</span> *<span class="title">dlNode</span>;</span>  <span class="comment">// 双向链表节点指针</span></span><br><span class="line">    UT_hash_handle hh;  <span class="comment">// 哈希表句柄</span></span><br><span class="line">&#125; stHash;</span><br></pre></td></tr></table></figure>
<p>LRU 缓存：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 LRU 缓存的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    stDLinked *front;  <span class="comment">// 链表头指针</span></span><br><span class="line">    stDLinked *rear;  <span class="comment">// 链表尾指针</span></span><br><span class="line">    stHash *hashTbl;  <span class="comment">// 哈希表指针</span></span><br><span class="line">    <span class="type">int</span> size;  <span class="comment">// 当前缓存大小</span></span><br><span class="line">    <span class="type">int</span> capacity;  <span class="comment">// 缓存容量</span></span><br><span class="line">&#125; LRUCache;</span><br></pre></td></tr></table></figure>
<p>上述数据结构关系图：</p>
<img src="../images/data-structure/LRU-cache-struct.png" alt="LRU 缓存结构" width="100%" height="100%">
<h3 id="接口实现">接口实现</h3>
<p>创建 LRU 缓存：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 LRU 缓存</span></span><br><span class="line">LRUCache *<span class="title function_">lRUCacheCreate</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    LRUCache *lru = (LRUCache *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LRUCache));</span><br><span class="line">    lru-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    lru-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    lru-&gt;hashTbl = <span class="literal">NULL</span>; <span class="comment">// 哈希表指针初始化为空</span></span><br><span class="line">    lru-&gt;size = <span class="number">0</span>;</span><br><span class="line">    lru-&gt;capacity = capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lru;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现 <code>get</code> 方法和 <code>put</code> 方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printDLinked</span><span class="params">(stDLinked *node)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;print DL: &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d)-&gt;&quot;</span>, node-&gt;page, node-&gt;frame);</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将指定的节点移动到尾结点后</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dlNodeMoveToRear</span><span class="params">(LRUCache *obj, stDLinked *node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    stDLinked *prevNode = node-&gt;prev;</span><br><span class="line">    stDLinked *nextNode = node-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定的节点是链表首节点，但不是链表尾结点</span></span><br><span class="line">    <span class="keyword">if</span> (!prevNode &amp;&amp; nextNode) &#123;</span><br><span class="line">        nextNode-&gt;prev = prevNode;</span><br><span class="line">        obj-&gt;front = nextNode;</span><br><span class="line">        obj-&gt;rear-&gt;next = node;</span><br><span class="line">        node-&gt;prev = obj-&gt;rear;</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        obj-&gt;rear = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevNode &amp;&amp; nextNode) &#123; <span class="comment">// 指定的节点是链表中间节点</span></span><br><span class="line">        nextNode-&gt;prev = prevNode;</span><br><span class="line">        prevNode-&gt;next = nextNode;</span><br><span class="line">        obj-&gt;rear-&gt;next = node;</span><br><span class="line">        node-&gt;prev = obj-&gt;rear;</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        obj-&gt;rear = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 指定的节点是链表尾结点无需处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 LRU 缓存</span></span><br><span class="line">LRUCache *<span class="title function_">lRUCacheCreate</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    LRUCache *lru = (LRUCache *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LRUCache));</span><br><span class="line">    lru-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    lru-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    lru-&gt;hashTbl = <span class="literal">NULL</span>; <span class="comment">// 哈希表指针初始化为空</span></span><br><span class="line">    lru-&gt;size = <span class="number">0</span>;</span><br><span class="line">    lru-&gt;capacity = capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lru;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定的逻辑页面对应的物理页帧号，若存在，则一并将该页表项移动到链表尾部</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lRUCacheGet</span><span class="params">(LRUCache *obj, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line">    stHash *hashNode = <span class="literal">NULL</span>;</span><br><span class="line">    HASH_FIND_INT(obj-&gt;hashTbl, &amp;key, hashNode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hashNode) &#123;</span><br><span class="line">        res = hashNode-&gt;dlNode-&gt;frame;</span><br><span class="line">        dlNodeMoveToRear(obj, hashNode-&gt;dlNode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;Get: (%d, %d) &quot;, key, res);</span></span><br><span class="line">    <span class="comment">// printDLinked(obj-&gt;front);</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往链表中插入页表项，若逻辑页面存在，则修改对应的物理页帧号并将该页表项移动到链表尾部，</span></span><br><span class="line"><span class="comment">// 不存在，则直接将该页表项移动到链表尾部</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lRUCachePut</span><span class="params">(LRUCache *obj, <span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    stHash *hashNode = <span class="literal">NULL</span>;</span><br><span class="line">    HASH_FIND_INT(obj-&gt;hashTbl, &amp;key, hashNode);</span><br><span class="line">    <span class="keyword">if</span> (hashNode) &#123; <span class="comment">// 一. 存在逻辑页面，则直接移动该页表项到链表尾部</span></span><br><span class="line">        dlNodeMoveToRear(obj, hashNode-&gt;dlNode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 二. 不存在逻辑页面，则将该页表项移动到链表尾部</span></span><br><span class="line">        <span class="comment">// 0. 申请追加的链表节点</span></span><br><span class="line">        stDLinked *addNode = (stDLinked *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stDLinked));</span><br><span class="line">        addNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        addNode-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 先检查链表长度是否大于等于最大容量，是则先删除链表头，再追加节点</span></span><br><span class="line">        <span class="keyword">if</span> (obj-&gt;size &gt;= obj-&gt;capacity) &#123;</span><br><span class="line">            <span class="comment">// 1.1 获取链表头节点，并与双向链表断开</span></span><br><span class="line">            stDLinked *delNode = obj-&gt;front;</span><br><span class="line">            obj-&gt;front = obj-&gt;front-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (obj-&gt;front) &#123; obj-&gt;front-&gt;prev = <span class="literal">NULL</span>; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1.2 从哈希表中删除对应的哈希节点</span></span><br><span class="line">            stHash *delHashNode = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="type">int</span> delKey = delNode-&gt;page;</span><br><span class="line">            HASH_FIND_INT(obj-&gt;hashTbl, &amp;delKey, delHashNode);</span><br><span class="line">            HASH_DEL(obj-&gt;hashTbl, delHashNode);</span><br><span class="line">            <span class="built_in">free</span>(delHashNode);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1.3 释放链表节点空间</span></span><br><span class="line">            delNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(delNode);</span><br><span class="line">            <span class="comment">// 1.4 链表长度减一</span></span><br><span class="line">            obj-&gt;size--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 追加节点：分为链表为空和非空两种情况</span></span><br><span class="line">        <span class="keyword">if</span> (obj-&gt;size == <span class="number">0</span>) &#123;</span><br><span class="line">            obj-&gt;front = addNode;</span><br><span class="line">            obj-&gt;rear = obj-&gt;front;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            obj-&gt;rear-&gt;next = addNode;</span><br><span class="line">            addNode-&gt;prev = obj-&gt;rear;</span><br><span class="line">            obj-&gt;rear = addNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 追加节点后，将其添加到哈希表中</span></span><br><span class="line">        hashNode = (stHash *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stHash));</span><br><span class="line">        hashNode-&gt;key = key;</span><br><span class="line">        hashNode-&gt;dlNode = addNode;</span><br><span class="line">        HASH_ADD_INT(obj-&gt;hashTbl, key, hashNode);</span><br><span class="line">        <span class="comment">// 4. 追加节点后，链表长度加一</span></span><br><span class="line">        obj-&gt;size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 三. 最后，统一修改或添加逻辑页面对应的物理页面</span></span><br><span class="line">    hashNode-&gt;dlNode-&gt;page = key;</span><br><span class="line">    hashNode-&gt;dlNode-&gt;frame = value;</span><br><span class="line">    <span class="comment">// printf(&quot;Put: (%d, %d) &quot;, key, value);</span></span><br><span class="line">    <span class="comment">// printDLinked(obj-&gt;front);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放哈希表空间</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hashFree</span><span class="params">(stHash **obj)</span> &#123;</span><br><span class="line">    stHash *curr = <span class="literal">NULL</span>, *tmp = <span class="literal">NULL</span>;</span><br><span class="line">    HASH_ITER(hh, *obj, curr, tmp) &#123;</span><br><span class="line">        HASH_DEL(*obj, curr);</span><br><span class="line">        <span class="built_in">free</span>(curr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放 LRU 缓存空间</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lRUCacheFree</span><span class="params">(LRUCache *obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        hashFree(&amp;(obj-&gt;hashTbl));</span><br><span class="line">        <span class="keyword">while</span> (obj-&gt;front) &#123;</span><br><span class="line">            stDLinked *tmp = obj-&gt;front;</span><br><span class="line">            obj-&gt;front = obj-&gt;front-&gt;next;</span><br><span class="line">            tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = lRUCacheCreate(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = lRUCacheGet(obj, key);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * lRUCachePut(obj, key, value);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * lRUCacheFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="代码执行结果">代码执行结果</h2>
<p>针对上面的测试用例，给出了每步操作后的双向链表的内容，如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Put: (1, 1) print DL: (1, 1)-&gt;NULL</span><br><span class="line">Put: (2, 2) print DL: (1, 1)-&gt;(2, 2)-&gt;NULL</span><br><span class="line">Get: (1, 1) print DL: (2, 2)-&gt;(1, 1)-&gt;NULL</span><br><span class="line">Put: (3, 3) print DL: (1, 1)-&gt;(3, 3)-&gt;NULL</span><br><span class="line">Get: (2, -1) print DL: (1, 1)-&gt;(3, 3)-&gt;NULL</span><br><span class="line">Put: (4, 4) print DL: (3, 3)-&gt;(4, 4)-&gt;NULL</span><br><span class="line">Get: (1, -1) print DL: (3, 3)-&gt;(4, 4)-&gt;NULL</span><br><span class="line">Get: (3, 3) print DL: (4, 4)-&gt;(3, 3)-&gt;NULL</span><br><span class="line">Get: (4, 4) print DL: (3, 3)-&gt;(4, 4)-&gt;NULL</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>设计</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>LeetCode</tag>
        <tag>双向链表</tag>
        <tag>页面置换算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 160 相交链表</title>
    <url>/posts/231025143947.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists">160 相交链表</a>：编写一个程序，找到两个无环单链表相交的起始节点，如果不存在交点则返回 <code>null</code>。要求时间复杂度为 <code>O(m+n)</code>，空间复杂度为 <code>O(1)</code>。</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A:          a1 → a2</span><br><span class="line">                    ↘</span><br><span class="line">                      c1 → c2 → c3</span><br><span class="line">                    ↗</span><br><span class="line">B:    b1 → b2 → b3</span><br></pre></td></tr></table></figure>
<p>但是不会出现以下相交的情况，因为每个节点只有 <strong> 一个</strong> <code>next</code> 指针，也就只能有一个后继节点，而以下示例中节点 <code>c</code> 有两个后继节点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A:          a1 → a2       d1 → d2</span><br><span class="line">                    ↘  ↗</span><br><span class="line">                      c</span><br><span class="line">                    ↗  ↘</span><br><span class="line">B:    b1 → b2 → b3        e1 → e2</span><br></pre></td></tr></table></figure>
<h2 id="暴力解法">暴力解法</h2>
<p>两重循环，对于链表 A 的每一个节点，依次从头到尾遍历链表 B 的每一个节点，当链表 A 的当前节点与链表 B 的当前节点 <strong> 首次 </strong> 相同时，即为相交的起始节点，即可返回答案。</p>
<p>很显然，时间复杂度：<code>O(mn)</code>，空间复杂度：<code>O(1)</code>，不满足题意。</p>
<h2 id="哈希表解法">哈希表解法</h2>
<p>遍历链表 A 时存储指针地址到哈希表中。遍历链表 B 时，判断当前节点是否在哈希表中，若在（<strong>第一个 </strong> 在的），即为相交的起始节点，即可返回答案。</p>
<p>很显然，时间复杂度：<code>O(m+n)</code>，空间复杂度：<code>O(m)</code>，不满足题意。</p>
<h2 id="双指针解法">双指针解法</h2>
<p>设链表 A 的长度为 a + c，链表 B 的长度为 b + c，其中 c 为尾部公共部分长度，<strong>可知长度满足：a + c + b = b + c + a</strong>。</p>
<p>当访问链表 A 的指针访问到链表尾部时，<strong>令它从链表 B 的头部开始访问链表 B</strong>；同样地，当访问链表 B 的指针访问到链表尾部时，<strong>令它从链表 A 的头部开始访问链表 A</strong>。</p>
<p>这样就能控制访问 A 和 B 两个链表的指针 <strong> 能同时访问到相交点 </strong>。如果不存在交点，那么 a + b = b + a，以下实现代码中<code>nodeA</code> 和<code>nodeB</code>会同时为<code>null</code>，从而退出循环。</p>
<p>时间复杂度：<code>O(m+n)</code>，空间复杂度：<code>O(1)</code>，满足题意。</p>
<p>C 语言实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode *<span class="title function_">getIntersectionNode</span><span class="params">(<span class="keyword">struct</span> ListNode *headA, <span class="keyword">struct</span> ListNode *headB)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">nodeA</span> =</span> headA, *nodeB = headB;</span><br><span class="line">    <span class="keyword">while</span> (nodeA != nodeB) &#123;</span><br><span class="line">        nodeA = (nodeA != <span class="literal">NULL</span> ? nodeA-&gt;next : headB);</span><br><span class="line">        nodeB = (nodeB != <span class="literal">NULL</span> ? nodeB-&gt;next : headA);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nodeA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Python 语言实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        nodeA, nodeB = headA, headB</span><br><span class="line">        <span class="keyword">while</span>(nodeA != nodeB):</span><br><span class="line">            nodeA = headB <span class="keyword">if</span>(nodeA == <span class="literal">None</span>) <span class="keyword">else</span> nodeA.<span class="built_in">next</span></span><br><span class="line">            nodeB = headA <span class="keyword">if</span>(nodeB == <span class="literal">None</span>) <span class="keyword">else</span> nodeB.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> nodeA</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 1631 最小体力消耗路径</title>
    <url>/posts/231211184652.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/path-with-minimum-effort/description/">1631 最小体力消耗路径</a>：你准备参加一场远足活动。给你一个二维 <code>rows x cols</code> 的地图 <code>heights</code> ，其中 <code>heights[row][col]</code> 表示格子 <code>(row, col)</code> 的高度。一开始你在最左上角的格子 <code>(0, 0)</code>，且你希望去最右下角的格子 <code>(rows-1, cols-1)</code> （注意下标从 <code>0</code> 开始编号）。你每次可以往上、下、左、右四个方向之一移动，你想要找到耗费体力最小的一条路径。</p>
<p>一条路径耗费的体力值是 <strong> 路径上相邻格子之间高度差的绝对值的最大值 </strong> 决定的。请你返回从左上角走到右下角的最小体力消耗值。</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：heights = [</span><br><span class="line">    [1,2,1,1,1],</span><br><span class="line">    [1,2,1,2,1],</span><br><span class="line">    [1,2,1,2,1],</span><br><span class="line">    [1,2,1,2,1],</span><br><span class="line">    [1,1,1,2,1]</span><br><span class="line">]</span><br><span class="line">输出：0</span><br><span class="line">解释：按着值为 1 的格子走，不需要消耗任何体力。</span><br></pre></td></tr></table></figure>
<h2 id="思考">思考</h2>
<p>这个题，跟以往常见的移动规则不太一样。<strong>常见的是只能向下、向右移动，而此题可以向四个方向移动</strong>。如果是只能向下、向右移动，那么可以用动态规划解决，其状态转移方程为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>a</mi><mi>b</mi><mi>s</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>−</mo><mi>h</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>a</mi><mi>b</mi><mi>s</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>−</mo><mi>h</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">dp[i][j] = min(max(dp[i - 1][j], abs(h[i][j] - h[i - 1][j])), max(dp[i][j - 1], abs(h[i][j] - h[i][j - 1])));
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">b</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">b</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">;</span></span></span></span></span></p>
<p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 表示移动到格子 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 时消耗的最小体力，它可以从上方的格子到达该格子、也可以从左侧的格子到达该格子。所以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 会选择两者中体力消耗较少的那个格子作为经过点。</p>
<p>只能向下、向右移动的动态规划解法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">minimumEffortPathRightDown</span><span class="params">(<span class="type">int</span>** heights, <span class="type">int</span> heightsSize, <span class="type">int</span>* heightsColSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> m = heightsSize, n = *heightsColSize;</span><br><span class="line">    <span class="type">int</span> dp[m][n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = fmax(dp[i][j - <span class="number">1</span>], <span class="built_in">fabs</span>(heights[i][j] - heights[i][j - <span class="number">1</span>]));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span> &amp;&amp; i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = fmax(dp[i - <span class="number">1</span>][j], <span class="built_in">fabs</span>(heights[i][j] - heights[i - <span class="number">1</span>][j]));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                dp[i][j] = fmin(fmax(dp[i - <span class="number">1</span>][j], <span class="built_in">fabs</span>(heights[i][j] - heights[i - <span class="number">1</span>][j])), fmax(dp[i][j - <span class="number">1</span>], <span class="built_in">fabs</span>(heights[i][j] - heights[i][j - <span class="number">1</span>])));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="问题转换">问题转换</h2>
<p>我们可以将本题抽象成如下的一个 <strong> 图论模型</strong>：</p>
<ul>
<li>
<p>我们将地图中的 <strong> 每一个格子看成图中的一个节点</strong>；</p>
</li>
<li>
<p>我么将两个相邻（左右相邻或者上下相邻）的 <strong> 两个格子对应的节点之间连接一条无向边</strong>，边的权值为这两个格子的高度差的绝对值；</p>
</li>
<li>
<p>我们需要找到一条从左上角到右下角的「最短路径」，其中一条路径的长度定义为其经过的 <strong> 所有边权的最大值</strong>。</p>
</li>
</ul>
<p>一般地，<strong>「图」中的所有节点的编号都是不一样的</strong>。所以我们需要将二维的坐标点，转换成唯一的编号。这可以按 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>d</mi><mo>=</mo><mi>r</mi><mi>o</mi><mi>w</mi><mi>s</mi><mo>∗</mo><mi>m</mi><mo>+</mo><mi>c</mi><mi>o</mi><mi>l</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">id = rows * m + cols</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">s</span></span></span></span> 来表示。比如，对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mn>4</mn><mo separator="true">,</mo><mi>n</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">m = 4, n = 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>，从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>3</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(3, 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span> 向上移动到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2, 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span> 就是从节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>14</mn></mrow><annotation encoding="application/x-tex">14</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">4</span></span></span></span> 移动到节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>。</p>
<h2 id="并查集解法">并查集解法</h2>
<p>我们可以将地图中的 <code>mn</code> 个格子（节点）放入并查集中，初始时，所有节点各为一个集合。随着「路径的形成」，路径上的节点将会汇集在不同的集合中（不加干预的话，最终所有的点会汇聚成一个集合）。</p>
<p>因此，<strong>如果左上角和右下角所对应的节点，被合并到同一个集合内，就可以说明形成了一条从左上角到右下角路径</strong>，路径被连通。</p>
<p>但是，我们要找的是一条从左上角到右下角的「最短路径」。所以，我们 <strong> 可以按边权从小到大的顺序，将这条边的两个点合并到集合中</strong>。一旦出现左上角和右下角在同一个集合中，那便是从左上角到右下角的「最短路径」（这次移动的高度差就是首尾连通路径上的最大高度差，但同时也是所有可能的首尾连通路径上的最小高度差）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> from; <span class="comment">// 从哪个坐标</span></span><br><span class="line">    <span class="type">int</span> to; <span class="comment">// 移动到哪个坐标</span></span><br><span class="line">    <span class="type">int</span> h; <span class="comment">// 移动的高度差的绝对值</span></span><br><span class="line">&#125; Edge;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> rank[], <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">        rank[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[x] == x) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 路径压缩</span></span><br><span class="line">        parent[x] = findSet(parent, parent[x]);</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unionSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> rank[], <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> rootX = findSet(parent, x);</span><br><span class="line">    <span class="type">int</span> rootY = findSet(parent, y);</span><br><span class="line">    <span class="comment">// 属于不同集合</span></span><br><span class="line">    <span class="keyword">if</span> (rootX != rootY) &#123;</span><br><span class="line">        <span class="comment">// 将深度较小的树连到另一棵树</span></span><br><span class="line">        <span class="keyword">if</span> (rank[rootX] &lt; rank[rootY]) &#123;</span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootX] &gt; rank[rootY]) &#123;</span><br><span class="line">            parent[rootY] = rootX;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将前者所在的树的根节点连接到后者所在的树的根节点上</span></span><br><span class="line">            <span class="comment">// 被连接的树的高度将会加一, 对应的 rank 值加一</span></span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">            rank[rootY]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isSameSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> findSet(parent, x) == findSet(parent, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *pa, <span class="type">const</span> <span class="type">void</span> *pb)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((Edge *)pa)-&gt;h - ((Edge *)pb)-&gt;h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">minimumEffortPath</span><span class="params">(<span class="type">int</span>** heights, <span class="type">int</span> heightsSize, <span class="type">int</span>* heightsColSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> m = heightsSize, n = *heightsColSize;</span><br><span class="line">    <span class="keyword">if</span> (m * n &lt;= <span class="number">1</span>) &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在矩阵中向右、向下移动，移动可以产生这么多线段（最后一行和最后一列不能移动）</span></span><br><span class="line">    Edge edgeInfo[m * n * <span class="number">2</span>]; <span class="comment">// 实际为 m * n * 2 - m - n;</span></span><br><span class="line">    <span class="type">int</span> edgeSize = <span class="number">0</span>, id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">            id = i * n + j; <span class="comment">// 将二维坐标按行转换为一维坐标点</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; m - <span class="number">1</span>) &#123; <span class="comment">// 向右（对于目的点到源点就是向左）</span></span><br><span class="line">                edgeInfo[edgeSize].from = id;</span><br><span class="line">                edgeInfo[edgeSize].to = id + n;</span><br><span class="line">                edgeInfo[edgeSize].h = <span class="built_in">fabs</span>(heights[i][j] - heights[i + <span class="number">1</span>][j]);</span><br><span class="line">                edgeSize++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; n - <span class="number">1</span>) &#123; <span class="comment">// 向下（对于目的点到源点就是向上）</span></span><br><span class="line">                edgeInfo[edgeSize].from = id;</span><br><span class="line">                edgeInfo[edgeSize].to = id + <span class="number">1</span>;</span><br><span class="line">                edgeInfo[edgeSize].h = <span class="built_in">fabs</span>(heights[i][j] - heights[i][j + <span class="number">1</span>]);</span><br><span class="line">                edgeSize++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    qsort(edgeInfo, edgeSize, <span class="keyword">sizeof</span>(Edge), cmp); <span class="comment">// 按高度差的绝对值排序</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ufSize = m * n; <span class="comment">// 用实际的 edgeSize 会有问题（考虑仅一次移动时，有两个坐标点）</span></span><br><span class="line">    <span class="type">int</span> parent[ufSize], rank[ufSize];</span><br><span class="line">    init(&amp;parent, &amp;rank, ufSize);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edgeSize; i++) &#123; <span class="comment">// 现在按高度顺序遍历每一次移动</span></span><br><span class="line">        unionSet(&amp;parent, &amp;rank, edgeInfo[i].from, edgeInfo[i].to); <span class="comment">// 合并该次移动</span></span><br><span class="line">        <span class="comment">// 经过数次移动后，如果左上角和右下角的点在同一个集合中，那么首尾已经连通，即为答案</span></span><br><span class="line">        <span class="comment">// 因为，这次移动的高度差就是首尾连通路径上的最大高度差，但同时也是所有可能的首尾连通路径上的最小高度差</span></span><br><span class="line">        <span class="keyword">if</span> (isSameSet(&amp;parent, <span class="number">0</span>, m * n - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> edgeInfo[i].h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ~(<span class="number">0x1</span>U &lt;&lt; <span class="number">31</span>); <span class="comment">// 无效返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本题有多种解法，如二分查找、并查集、dijkstra 算法，有时间再补充。</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>图</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>并查集</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 19 删除链表的倒数第 N 个节点</title>
    <url>/posts/231027150243.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19 删除链表的倒数第 N 个节点 </a>：给定一个链表，删除链表的倒数第 N 个节点，并且返回链表的头节点。进阶：你能尝试使用一趟扫描实现吗？</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 输入：head = [1,2,3,4,5], n = 2</span><br><span class="line"> 输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>
<h2 id="两趟遍历"> 两趟遍历 </h2>
<p> 删除倒数第 <code>n</code> 个，即需要统计链表长度 <code>L</code>，然后删除正数第 <code>L-n+1</code> 个即可。</p>
<p> 第一趟遍历：统计链表长度；第二趟遍历：删除节点。</p>
<p> 时间复杂度：<code>O(L)</code>，遍历了两遍链表，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeNthFromEnd</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node</span> =</span> head;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    node = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除的是第一个节点 </span></span><br><span class="line">    <span class="keyword">if</span> (n == size) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newHead</span> =</span> head-&gt;next;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(head);</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">temp</span> =</span> node-&gt;next;</span><br><span class="line">    node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">    temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快慢指针（一趟遍历）"> 快慢指针（一趟遍历）</h2>
<p> 进阶：你能尝试使用一趟扫描实现吗？</p>
<p> 我们可以使用两个指针（快慢指针），让快指针先走 <code>n</code> 步，然后快指针和慢指针同时、同速度走，当快指针走完时，慢指针刚好走了 <code>L-n</code> 步。</p>
<p> 时间复杂度：<code>O(L)</code>，遍历了一遍链表，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeNthFromEnd</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">slow</span> =</span> head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除的是第一个节点 </span></span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newHead</span> =</span> head-&gt;next;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(head);</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next) &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">temp</span> =</span> slow-&gt;next;</span><br><span class="line">    slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">    temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 206 反转链表</title>
    <url>/posts/231025185947.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206 反转链表</a>：反转一个单链表。例如，输入：<code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>；输出：<code>5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code>。</p>
<span id="more"></span>
<h2 id="LIFO 堆栈解法">LIFO 堆栈解法</h2>
<p>可以使用堆栈的后进先出特性来实现链表的反转。遍历链表中的节点，并存储在堆栈中；遍历完后，依次弹出堆栈中的节点，并将它与上一个节点链接起来。</p>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(n)</code>。</p>
<h2 id="双指针解法">双指针解法</h2>
<p>可以借助一前一后两个指针，在遍历链表的过程中，将两个前后两个节点的指向关系反转。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1  2  3  4  5  NULL</span><br><span class="line"> -&gt; -&gt; -&gt; -&gt; -&gt;</span><br><span class="line"> &lt;- &lt;- &lt;- &lt;- &lt;-</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">pre</span> =</span> head, *cur = head-&gt;next;  <span class="comment">// 双指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">suff</span> =</span> <span class="literal">NULL</span>, *tail = <span class="literal">NULL</span>;  <span class="comment">// 临时指针和结果指针</span></span><br><span class="line">    pre-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            tail = cur;  <span class="comment">// 记录最后一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        suff = cur-&gt;next;  <span class="comment">// 记录下一个节点</span></span><br><span class="line">        cur-&gt;next = pre;  <span class="comment">// 转向关系反转</span></span><br><span class="line">        pre = cur;  <span class="comment">// 更新上一个节点</span></span><br><span class="line">        cur = suff;  <span class="comment">// 更新当前节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="头插法">头插法</h2>
<p>对于链表中的每一个节点，我们 <strong> 都将它插在新链表的头结点之前</strong>，对于链表 <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>：</p>
<ol>
<li>遍历前新链表为 <code>NULL</code>；</li>
<li>遍历第一个节点时，将其插入在新链表 <code>NULL</code> 的头结点之前，更新后的链表为 <code>1-&gt;NULL</code>;</li>
<li>遍历第二个节点时，将其插入在新链表 <code>1-&gt;NULL</code> 的头结点之前，更新后的链表为 <code>2-&gt;1-&gt;NULL</code>;</li>
<li>…</li>
<li>遍历最后一个节点时，将其插入在新链表 <code>4-&gt;3-&gt;2-&gt;1-&gt;NULL</code> 的头结点之前，更新后的链表为 <code>5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code>;</li>
</ol>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">newHead</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> =</span> head;  <span class="comment">// 当前节点</span></span><br><span class="line">        head = head-&gt;next;  <span class="comment">// 先找到下一个节点</span></span><br><span class="line">        cur-&gt;next = newHead;  <span class="comment">// 当前节点指向新链表的头</span></span><br><span class="line">        newHead = cur;  <span class="comment">// 更新新链表的头</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>双指针解法与头插法有什么区别？</p>
</blockquote>
<p>双指针解法是反转前后两个节点的指向关系；头插法是初始化一个新的空链表，依次将待反转链表的节点，追加在新链表的最前面。</p>
<h2 id="递归解法">递归解法</h2>
<p>假设我们要反转链表 <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>，可以先反转节点 <code>1</code> 后面 <strong> 更短的链表</strong>，即 <code>2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>，这会得到 <code>5-&gt;4-&gt;3-&gt;2-&gt;NULL</code>。最后，再将节点 <code>1</code> 链接到上面反转的链表的最后一个非空节点（即节点 <code>2</code>）和 <code>NULL</code> 节点之间。</p>
<p>递归的终止条件就是链表无需反转了，即链表没有节点或只有一个节点。</p>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(n)</code>，递归深度可能达到 <code>n</code> 层。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur</span> =</span> reverseList(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码是用递归方式实现单链表的反转。让我们逐行解析代码的实现原理：</p>
<ol>
<li>首先，检查头指针 <code>head</code> 是否为空或者链表只有一个节点（即 <code>head-&gt;next</code> 为空）。如果是的话，直接返回头指针。</li>
<li>如果链表有多个节点，递归调用 <code>reverseList</code> 函数，传入 <code>head-&gt;next</code> 作为参数，<strong>目的是将 <code>head-&gt;next</code> 节点及之后的节点进行反转</strong>。</li>
<li>在递归调用之后，我们得到了反转后的链表的头指针 <code>cur</code>，它的尾结点是 <code>head-&gt;next</code>。</li>
<li>然后，我们 <strong> 将 <code>head</code> 节点插入到反转后的链表的末尾</strong>，即 <code>head-&gt;next-&gt;next = head</code>。这一步是将 <code>head</code> 节点的下一个节点（<code>head-&gt;next</code>）指向 <code>head</code>，实现反转。</li>
<li>最后，将 <code>head</code> 的下一个节点指向 <code>NULL</code>，以确保链表的末尾指向 <code>NULL</code>。</li>
<li>返回反转后的链表的头指针 <code>cur</code>。</li>
</ol>
<p>这段代码的核心思想是通过递归来实现链表的反转。通过不断地调用 <code>reverseList</code> 函数，<strong>每次反转两个节点</strong>，最终实现整个链表的反转。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 21 合并两个有序链表</title>
    <url>/posts/231026101239.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21 合并两个有序链表</a>：输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">    链表 A：1-&gt;2-&gt;4</span><br><span class="line">    链表 B：1-&gt;3-&gt;4</span><br><span class="line">    合并链表：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>
<h2 id="双指针解法">双指针解法</h2>
<p>使用两个指针遍历链表，分别指向链表 A 和链表 B 的头结点，然后比较两个指针所指向的节点的大小关系，将较小的节点链接到合并链表的末尾，并后移对应的指针；直到其中一个指针为空时，将另一个非空指针指向的剩余链表拼接到合并链表的末尾。</p>
<p>时间复杂度：<code>O(m+n)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">mergeTwoLists</span><span class="params">(<span class="keyword">struct</span> ListNode* list1, <span class="keyword">struct</span> ListNode* list2)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据大小关系确定合并链表的头结点, 并确定每个链表的起始位置</span></span><br><span class="line">    <span class="keyword">if</span> (list1-&gt;val &lt;= list2-&gt;val) &#123;</span><br><span class="line">        head = list1;</span><br><span class="line">        list1 = list1-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        head = list2;</span><br><span class="line">        list2 = list2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> =</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (list1 &amp;&amp; list2) &#123;</span><br><span class="line">        <span class="comment">// 比较两个指针所指向的节点的大小关系，将较小的节点链接到合并链表的末尾</span></span><br><span class="line">        <span class="keyword">if</span> (list1-&gt;val &lt;= list2-&gt;val) &#123;</span><br><span class="line">            cur-&gt;next = list1;</span><br><span class="line">            list1 = list1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur-&gt;next = list2;</span><br><span class="line">            list2 = list2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将非空指针指向的剩余链表拼接到合并链表的末尾</span></span><br><span class="line">    cur-&gt;next = (list1 == <span class="literal">NULL</span> ? list2 : list1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的双指针直接复用的两个链表指针变量。</p>
</blockquote>
<p>上面代码虽然清晰，但是有点长了。其实，我们可以 <strong> 利用一个临时的「哑结点」作为合并链表的头结点的上一个节点</strong>，来简化操作。</p>
<p>这样，就不需要上面代码中 <code>while</code> 循环前的「根据大小关系确定合并链表的头结点, 并确定每个链表的起始位置」判断了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">mergeTwoLists</span><span class="params">(<span class="keyword">struct</span> ListNode* list1, <span class="keyword">struct</span> ListNode* list2)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>;</span>  <span class="comment">// 哑结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> =</span> &amp;dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (list1 &amp;&amp; list2) &#123;</span><br><span class="line">        <span class="comment">// 比较两个指针所指向的节点的大小关系，将较小的节点链接到合并链表的末尾</span></span><br><span class="line">        <span class="keyword">if</span> (list1-&gt;val &lt;= list2-&gt;val) &#123;</span><br><span class="line">            cur-&gt;next = list1;</span><br><span class="line">            list1 = list1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur-&gt;next = list2;</span><br><span class="line">            list2 = list2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将非空指针指向的剩余链表拼接到合并链表的末尾</span></span><br><span class="line">    cur-&gt;next = (list1 == <span class="literal">NULL</span> ? list2 : list1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.next;  <span class="comment">// 返回哑结点的下一个节点, 即为合并链表的头结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归解法">递归解法</h2>
<p>我们同样可以利用递归实现合并两个链表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">mergeTwoLists</span><span class="params">(<span class="keyword">struct</span> ListNode* list1, <span class="keyword">struct</span> ListNode* list2)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (list1-&gt;val &lt;= list2-&gt;val) &#123;</span><br><span class="line">        list1-&gt;next = mergeTwoLists(list1-&gt;next, list2);</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list2-&gt;next = mergeTwoLists(list1, list2-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这种写法，跟双指针解法中的第一个代码块相似，直接在原有的链表上进行操作，并直接返回较小节点的头节点作为合并后的链表头。</p>
<p>同样地，我们也可以像双指针解法中的第二个代码块那样，利用一个哑结点，将哑结点的下一个节点指向链表 A 和链表 B 中较小的节点 N，并递归地将较小的节点 N 指向后续合并链表的头结点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">mergeTwoLists</span><span class="params">(<span class="keyword">struct</span> ListNode* list1, <span class="keyword">struct</span> ListNode* list2)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> =</span> &amp;dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (list1-&gt;val &lt;= list2-&gt;val) &#123;</span><br><span class="line">        cur-&gt;next = list1;</span><br><span class="line">        list1-&gt;next = mergeTwoLists(list1-&gt;next, list2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cur-&gt;next = list2;</span><br><span class="line">        list2-&gt;next = mergeTwoLists(list1, list2-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">    cur = cur-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 234 回文链表</title>
    <url>/posts/231101094219.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">234 回文链表 </a>：请判断一个链表是否为回文链表。所谓回文链表就是以链表中间为中心点两边对称。<strong> 进阶</strong>：你能否用 <code>O(n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度解决此题？</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;2-&gt;1; 输出: true</span><br><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;1; 输出: false</span><br></pre></td></tr></table></figure>
<h2 id="多次遍历">多次遍历</h2>
<p>我们可以遍历链表中的每个节点，依次把它们存储在数组中，最后从数组的两头往中间判断链表是否是回文数组。</p>
<p>这就需要对链表进行两次遍历。第一次遍历，计算链表的长度，用于申请合适的数组空间；第二次遍历，向数组中存储链表节点。最后，我们需要对数组进行一次遍历，来判断链表是否是回文链表。</p>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(n)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node</span> =</span> head;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算链表的长度</span></span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        size++;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">nums</span>[<span class="title">size</span>];</span></span><br><span class="line">    node = head;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 向数组中存储链表节点</span></span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        nums[size++] = node;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数组的两头往中间判断链表是否是回文链表</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[left++]-&gt;val != nums[right--]-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快慢指针 - 反转链表">快慢指针 + 反转链表</h2>
<blockquote>
<p>你能否用 <code>O(n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度解决此题？</p>
</blockquote>
<p>可以使用快慢指针找到链表的中点，然后断开链表，并将前一段链表进行反转，然后同时遍历两段链表，来判断原链表是否是回文链表。</p>
<p>这样，就不需要额外的申请内存空间（但是会修改入参的内容）。</p>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">newHead</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> =</span> head;  <span class="comment">// 当前节点</span></span><br><span class="line">        head = head-&gt;next;  <span class="comment">// 先找到下一个节点</span></span><br><span class="line">        cur-&gt;next = newHead;  <span class="comment">// 当前节点指向新链表的头</span></span><br><span class="line">        newHead = cur;  <span class="comment">// 更新新链表的头</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快慢指针寻找链表中点两侧的节点</span></span><br><span class="line">    <span class="comment">// 1-&gt;2-&gt;2-&gt;1, 1-&gt;2-&gt;3-&gt;2-&gt;1</span></span><br><span class="line">    <span class="comment">//    ↑  ↑        ↑     ↑</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span> =</span> head, *slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新指定快指针的位置</span></span><br><span class="line">    <span class="keyword">if</span> (fast) &#123;</span><br><span class="line">        fast = slow-&gt;next-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fast = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断开链表, 并反转链表</span></span><br><span class="line">    slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">reverseHead</span> =</span> reverseList(head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断链表是否是回文链表</span></span><br><span class="line">    <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast-&gt;val != reverseHead-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        reverseHead = reverseHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 2477 达到首都的最少油耗</title>
    <url>/posts/231206201243.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/">2477 达到首都的最少油耗</a>：给你一棵 <code>n</code> 个节点的树（一个无向、连通、无环图），每个节点表示一个城市，编号从 <code>0</code> 到 <code>n - 1</code> ，且恰好有 <code>n - 1</code> 条路，<code>0</code> 是首都。给你一个二维整数数组 <code>roads</code> ，其中 <code>roads[i] = [a_i, b_i]</code> ，表示城市 <code>a_i</code> 和 <code>b_i</code> 之间有一条双向路。</p>
<ul>
<li>每个城市有一辆车（均有 <code>seats</code> 个座位），且每个城市需要一名代表去首都参加会议。</li>
<li>代表可以选择乘坐自己所在城市的车辆，也可以选择乘坐其他城市的车辆。</li>
<li>相邻城市之间的车辆油耗是一升。</li>
</ul>
<p>你需要计算所有代表到达首都所需的最少汽油量。</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">- 代表 2 到达城市 3 ，消耗 1 升汽油。</span><br><span class="line">- 代表 2 和代表 3 一起到达城市 1 ，消耗 1 升汽油。</span><br><span class="line">- 代表 2 和代表 3 一起到达首都，消耗 1 升汽油。</span><br><span class="line">- 代表 1 直接到达首都，消耗 1 升汽油。</span><br><span class="line">- 代表 5 直接到达首都，消耗 1 升汽油。</span><br><span class="line">- 代表 6 到达城市 4 ，消耗 1 升汽油。</span><br><span class="line">- 代表 4 和代表 6 一起到达首都，消耗 1 升汽油。</span><br><span class="line">最少消耗 7 升汽油。</span><br></pre></td></tr></table></figure>
<h2 id="形象化数组">形象化数组</h2>
<p>将数组转换为树的形状：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       0</span><br><span class="line">     / | \</span><br><span class="line">    1  4  5</span><br><span class="line">   /   |</span><br><span class="line">  3    6</span><br><span class="line"> /</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h2 id="问题转换与解题思路">问题转换与解题思路</h2>
<p>题目等价于给出了一棵以节点 <code>0</code> 为根节点的多叉树，初始时树上的每一个节点都有一个人和一辆车，现在所有人都需要通过「车子」向节点 <code>0</code> 移动。</p>
<p>我们可以 <strong> 贪心地 </strong> 从每个叶子节点派车出发，只要车上还有空座位，就把该节点的人拉上车，并向根节点移动。要是车上没有座位了，那么就增派一辆车，也向根节点移动。这样就能保证所有人都到达首都，且油耗最少。</p>
<p>对于上面的示例路径 <code>2-&gt;3-&gt;1-&gt;0</code>，按上面的思路，有：</p>
<ul>
<li>三个人需要去首都，在节点 <code>2</code> 派出一辆车，在节点 <code>1</code> 增派了一辆车，一共需要两辆车，消耗 4 升汽油。</li>
</ul>
<p>通过观察分析，我们可以发现：</p>
<ul>
<li><code>x</code> 个人通过某一段公路到达「该段路的终点」，该段路 <strong> 需要消耗的油量（需要的车辆数）为「人数 / 座位数」向上取整</strong>。如：
<ul>
<li>节点 <code>2</code> 一起移动到节点 <code>3</code>，需要的汽油总量为 <code>ceil(1, 2) = 1</code>；</li>
<li>节点 <code>2,3</code> 一起移动到节点 <code>1</code>，需要的汽油总量为 <code>ceil(2, 2) = 1</code>；</li>
<li>节点 <code>2,3,1</code> 一起移动到节点 <code>0</code>，需要的汽油总量为 <code>ceil(3, 2) = 2</code>。</li>
</ul>
</li>
<li><strong>一条子树总共需要的油量为每一段路需要的油量（需要的车辆数）之和</strong>。</li>
</ul>
<p>那么，我们可以通过从根节点 <code>0</code> 往下进行 <strong> 深度优先搜索 </strong>，根据<strong> 路上累计的人数 </strong> 计算统计每一条边上消耗的汽油（需要的车辆数），把所有边上消耗的汽油相加即为最终答案。</p>
<h2 id="数据转换与存储">数据转换与存储</h2>
<p>题目使用了一个二维数组存储图数据，而我们需要的是每一个节点的邻居节点。所以首先需要将二维数组中的数据转换到邻接矩阵中，存储每个节点的邻居节点，而邻居节点的数量是不固定的。</p>
<p>对于 Python 语言，我们可以使用二维列表完成每个邻居节点的存储：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = roadsSize + <span class="number">1</span></span><br><span class="line">graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="keyword">for</span> edge <span class="keyword">in</span> roads:</span><br><span class="line">    x, y = edge[<span class="number">0</span>], edge[<span class="number">1</span>]</span><br><span class="line">    graph[x].append(y)</span><br><span class="line">    graph[y].append(x)</span><br></pre></td></tr></table></figure>
<p>对于 C 语言，我们需要定义一个二维结构体列表，列表中的每一个位置是一个链表，存储它的所有邻居节点（具体看后面的代码实现）。</p>
<blockquote>
<p>一个节点的所有邻居节点就是它在树中的父节点和子节点的集合，有些节点可能既有父节点又有子节点，而有些节点只有父节点。</p>
</blockquote>
<h2 id="贪心 - 深度优先搜索">贪心 + 深度优先搜索</h2>
<p>通过从根节点 <code>0</code> 往下进行 <strong> 深度优先搜索 </strong>，根据<strong> 路上累计的人数 </strong> 计算统计每一条边上消耗的汽油（需要的车辆数），把所有边上消耗的汽油相加即为最终答案。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单链表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">linked</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">linked</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; ListNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个链表节点</span></span><br><span class="line">ListNode *<span class="title function_">createListNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    ListNode *node = (ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    node-&gt;val = val;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放链表空间</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeList</span><span class="params">(ListNode *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">        ListNode *cur = <span class="built_in">list</span>;</span><br><span class="line">        <span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印链表内容</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(ListNode *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">list</span>-&gt;val);</span><br><span class="line">        <span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向上取整</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">myCeil</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b - <span class="number">1</span>) / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">minimumFuelCost</span><span class="params">(<span class="type">int</span>** roads, <span class="type">int</span> roadsSize, <span class="type">int</span>* roadsColSize, <span class="type">int</span> seats)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = roadsSize + <span class="number">1</span>; <span class="comment">// n 个节点有 n-1 条路，n-1=roadsSize</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个二维列表，存储每个节点的邻居节点（在树中看，邻居就是它的子节点和父节点）</span></span><br><span class="line">    ListNode **graph = (ListNode **)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(ListNode *));</span><br><span class="line">    <span class="built_in">memset</span>(graph, <span class="literal">NULL</span>, n * <span class="keyword">sizeof</span>(ListNode *));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; roadsSize; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x = roads[i][<span class="number">0</span>], y = roads[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// y 的邻居节点是 x，将 x 追加到节点 y 对应的列表中</span></span><br><span class="line">        ListNode *nodeX = createListNode(x);</span><br><span class="line">        nodeX-&gt;next = graph[y];</span><br><span class="line">        graph[y] = nodeX;</span><br><span class="line"></span><br><span class="line">        ListNode *nodeY = createListNode(y);</span><br><span class="line">        nodeY-&gt;next = graph[x];</span><br><span class="line">        graph[x] = nodeY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，每个节点的邻居节点就有了（邻居在列表中的顺序无关紧要）</span></span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     printf(&quot;node %d can be reached: &quot;, i);</span></span><br><span class="line">    <span class="comment">//     printList(graph[i]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">-1</span>, seats, &amp;res, graph); <span class="comment">// 从多叉树的根节点出发，向下遍历每棵子树</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        freeList(graph[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(graph);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> father, <span class="type">int</span> seats, <span class="type">long</span> <span class="type">long</span> *res, <span class="type">const</span> ListNode **graph)</span> &#123;</span><br><span class="line">    <span class="type">int</span> peopleSum = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历当前节点的邻居节点（包含父节点和子节点）</span></span><br><span class="line">    <span class="keyword">for</span> (ListNode *node = graph[cur]; node; node = node-&gt;next) &#123;</span><br><span class="line">        <span class="type">int</span> val = node-&gt;val;</span><br><span class="line">        <span class="comment">// 递归地遍历当前节点的子节点，不递归当前节点的父节点</span></span><br><span class="line">        <span class="keyword">if</span> (val != father) &#123;</span><br><span class="line">            <span class="comment">// 累计以当前节点为根的子节点人数</span></span><br><span class="line">            peopleSum += dfs(val, cur, seats, res, graph);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur != <span class="number">0</span>) &#123; <span class="comment">// 不是根节点时，计算耗油</span></span><br><span class="line">        *res += myCeil(peopleSum, seats);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> peopleSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码分析">代码分析</h2>
<h3 id="向上取整">向上取整</h3>
<p><code>a</code> 与 <code>b</code> 相除的向上取整公式：<code>(a + b - 1) / b</code>。因为 <code>a/b</code> 的余数最大为 <code>b-1</code>，我们多加一个 <code>b-1</code> 会使得：</p>
<ul>
<li>当原来余数为 <code>0</code> 时，新公式计算出来的商的部分还是原来的值；</li>
<li>当原来余数不为 <code>0</code> 时，多加的那部分 <code>b-1</code> 结合原来不为 <code>0</code> 的余数，会使得商的值加一。</li>
</ul>
<p>这样，便达到一个向上取整的效果。</p>
<h3 id="邻居节点">邻居节点</h3>
<p>每个节点的邻居节点打印（以上面的示例为例）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node 0 can be reached: 5 4 1 </span><br><span class="line">node 1 can be reached: 0 3 </span><br><span class="line">node 2 can be reached: 3 </span><br><span class="line">node 3 can be reached: 2 1 </span><br><span class="line">node 4 can be reached: 6 0 </span><br><span class="line">node 5 can be reached: 0 </span><br><span class="line">node 6 can be reached: 4 </span><br></pre></td></tr></table></figure>
<h3 id="DFS 理解">DFS 理解</h3>
<p>在小破站上看到一个评论：</p>
<blockquote>
<p>处理递归，核心就是千万不要想子问题的过程，你的脑子才能处理几层？马上就绕迷糊了。重要的是，要想子问题的结果，思路就清晰了。</p>
<blockquote>
<p>是的，只要代码的边界条件和非边界条件的逻辑写对了，其它的事情交给数学归纳法就好了。也就是说，写对了这两个逻辑，你的代码自动就是正确的了，没必要想递归是怎么一层一层走的。</p>
</blockquote>
</blockquote>
<p><strong>基于上面的评论，这道题中的 DFS 需要做的是（个人理解）</strong>：</p>
<ol>
<li>从多叉树的根节点出发，向下遍历每棵子树（也就是递归地遍历当前节点的子节点，不递归当前节点的父节点）；</li>
<li>也就是说，当遍历的节点的邻居节点是父节点时，不再递归，会得到一个返回值 <code>1</code>；</li>
<li>当遍历的节点的邻居节点是子节点时，递归地遍历它的子节点，累计子树的大小（累计返回值）；</li>
<li>计算完子树大小后，计算到达该子树的根节点时的油耗，累加到最终结果中。</li>
</ol>
<p>例如，对于上面的序号 2，当遍历节点 <code>2</code> 时，递归函数是 <code>dfs(2, 3, ...)</code>，节点 <code>2</code> 中存储的节点是 <code>3</code>，也就是它的父节点，且它没有其它节点了。所以，<code>for</code> 循环结束，不再递归，累计油耗到答案，并返回人数 <code>1</code>。这个返回值后面要累计给 <code>dfs(3, 1, ...)</code> 的返回值 <code>1</code>，即当前的 <code>peopleSum</code> 值就是 <code>dfs(2, 3, ...) + dfs(3, 1, ...) = 2</code>，从节点 <code>3</code> 到它的父节点 <code>1</code> 需要油耗 <code>ceil(2, 2) = 1</code>。</p>
<p><strong>为什么不需要计算根节点 <code>0</code> 的耗油</strong>？<br>
根节点 <code>0</code> 不需要累计油耗到答案，是因为累计的是每个节点到其父节点的公路上的油耗，根节点没有它的父节点，即没有公路，也就不需要油耗了。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>深度优先搜索</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>递归</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 2 两数相加</title>
    <url>/posts/231031120718.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/add-two-numbers/">2 两数相加 </a>：给出两个<strong> 非空 </strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong> 逆序 </strong> 的方式存储的，并且它们的每个节点只能存储 <strong> 一位 </strong> 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure>
<h2 id="一次遍历（哑结点）">一次遍历（哑结点）</h2>
<p>对于待相加的两个链表中的节点，它们相加可能出现进位（相加的值大于 9）。这时在下次相加时就要考虑这个带进位的结果；同时，最后一次相加的结果可能有进位，也可能没有进位，这也是不能忽略的。</p>
<p>每次相加都要创建一个链表节点，用于存储相加的值，并把它们链接起来，形成题目要求的返回的新链表。</p>
<p>时间复杂度：<code>O(max(m, n))</code>，空间复杂度：<code>O(1)</code>，不考虑输出占用的空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">addTwoNumbers</span><span class="params">(<span class="keyword">struct</span> ListNode* l1, <span class="keyword">struct</span> ListNode* l2)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> =</span> &amp;dummy;</span><br><span class="line">    <span class="type">int</span> curSum = <span class="number">0</span>, carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l1 || l2 || carry &gt; <span class="number">0</span>) &#123;  <span class="comment">// 把最后一次加法是否有进位放在这里, 简化代码</span></span><br><span class="line">        <span class="comment">// 创建节点并指向 NULL</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node</span> =</span> (<span class="keyword">struct</span> ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算当前两节点相加的和, 加上进位</span></span><br><span class="line">        curSum = carry;</span><br><span class="line">        <span class="keyword">if</span> (l1) &#123;</span><br><span class="line">            curSum += l1-&gt;val;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2) &#123;</span><br><span class="line">            curSum += l2-&gt;val;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算本次加法的进位和相加值</span></span><br><span class="line">        carry = curSum &gt; <span class="number">9</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        curSum = curSum % <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将下一个节点指向新节点, 并修改其值为相加值</span></span><br><span class="line">        node-&gt;val = curSum;</span><br><span class="line">        cur-&gt;next = node;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// // 判断最后一次加法是否有进位, 有责增加一个节点存储进位值</span></span><br><span class="line">    <span class="comment">// if (carry &gt; 0) &#123;</span></span><br><span class="line">    <span class="comment">//     struct ListNode *node = (struct ListNode *)malloc(sizeof(struct ListNode));</span></span><br><span class="line">    <span class="comment">//     node-&gt;next = NULL;</span></span><br><span class="line">    <span class="comment">//     node-&gt;val = carry;</span></span><br><span class="line">    <span class="comment">//     cur-&gt;next = node;</span></span><br><span class="line">    <span class="comment">//     cur-&gt;next-&gt;next = NULL;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 328 奇偶链表</title>
    <url>/posts/231102120708.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/odd-even-linked-list/">328 奇偶链表</a>：给定一个单链表，把所有的奇数位节点和偶数位节点分别链接在一起，并链接这两个链表（即奇数位的尾结点的下一个节点是偶数位的首节点）。请尝试使用原地算法完成。你的算法的空间复杂度应为 <code>O(1)</code>，时间复杂度应为 <code>O(n)</code>。</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: head = [1,2,3,4,5]</span><br><span class="line">输出: [1,3,5,2,4]</span><br><span class="line">输入: head = [2,1,3,5,6,4,7]</span><br><span class="line">输出: [2,3,6,7,1,5,4]</span><br></pre></td></tr></table></figure>
<h2 id="数组 - 遍历">数组 + 遍历</h2>
<p>可以使用两个数组，一个数组按序存储奇数位节点，一个数组按序存储偶数位节点。最后，先遍历奇数数组，再遍历偶数数组，即可。</p>
<p>时间复杂度：<code>O(n)</code>，三趟遍历，空间复杂度：<code>O(n)</code>，用于临时存储链表中的节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">oddEvenList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node</span> =</span> head;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        size++;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    node = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配两个数组的空间, 使用位运算计算</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">odd</span>[(<span class="title">size</span> &gt;</span>&gt; <span class="number">1</span>) + (size &amp; <span class="number">1</span>)];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">even</span>[(<span class="title">size</span> &gt;</span>&gt; <span class="number">1</span>)];</span><br><span class="line">    <span class="type">int</span> oddIdx = <span class="number">0</span>, evenIdx = <span class="number">0</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((size &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 一个数组按序存储奇数位节点</span></span><br><span class="line">            odd[oddIdx++] = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 一个数组按序存储偶数位节点</span></span><br><span class="line">            even[evenIdx++] = node;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先遍历奇数数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; oddIdx; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; oddIdx - <span class="number">1</span>) &#123;</span><br><span class="line">            odd[i]-&gt;next = odd[i + <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 奇数位的尾结点的下一个节点是偶数位的首节点</span></span><br><span class="line">            odd[i]-&gt;next = even[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再遍历偶数数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; evenIdx; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; evenIdx - <span class="number">1</span>) &#123;</span><br><span class="line">            even[i]-&gt;next = even[i + <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            even[i]-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双指针交替遍历">双指针交替遍历</h2>
<p>可以使用奇指针和偶指针两个指针来进行模拟。首先，奇指针 <code>odd</code> 指向链表第一个节点，偶指针 <code>even</code> 指向链表第二个节点。那么，偶指针的下一个节点 <code>even-&gt;next</code> 就是下一个奇数节点 <code>odd = even-&gt;next</code>，这个奇数节点的下一个节点就是下一个偶数节点 <code>even = odd-&gt;next</code>。然后，我们将前后相邻的奇数位、偶数位节点分别链接起来。最后，再将最后一个奇数位节点链接到第一个偶数位节点即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ------- </span><br><span class="line">|       |</span><br><span class="line">1---2---3---4---5</span><br><span class="line"> -/- -/-</span><br><span class="line">    |       |</span><br><span class="line">     -------</span><br><span class="line"></span><br><span class="line">         -------</span><br><span class="line">        |       |</span><br><span class="line">1---2---3---4---5</span><br><span class="line">         -/- -/-</span><br><span class="line">            |       |</span><br><span class="line">             -------</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<code>O(n)</code>，一趟遍历，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">oddEvenList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">odd</span> =</span> head, *even = head-&gt;next;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">evenHead</span> =</span> even;  <span class="comment">// 记录第一个偶数位节点, 否则会因为破坏链表的链接关系, 无法找到这个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (odd-&gt;next &amp;&amp; even-&gt;next) &#123;</span><br><span class="line">        <span class="comment">// 临时记录奇数位和偶数位节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">oddTmp</span> =</span> odd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">evenTmp</span> =</span> even;</span><br><span class="line">        <span class="comment">// 找到下一个奇数位和偶数位节点</span></span><br><span class="line">        odd = even-&gt;next;  <span class="comment">// odd = odd-&gt;next-&gt;next;</span></span><br><span class="line">        even = odd-&gt;next;  <span class="comment">// even = even-&gt;next-&gt;next;</span></span><br><span class="line">        <span class="comment">// 分别链接前后相邻的奇数位和偶数位节点</span></span><br><span class="line">        oddTmp-&gt;next = odd;</span><br><span class="line">        evenTmp-&gt;next = even;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将最后一个奇数位节点链接到第一个偶数位节点</span></span><br><span class="line">    odd-&gt;next = evenHead;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>while</code> 循环中，<code>odd-&gt;next &amp;&amp; even-&gt;next</code> 表示 <strong> 至少还有未链接到奇数链表末尾的奇数位节点</strong>，这个条件等价于 <code>odd-&gt;next &amp;&amp; odd-&gt;next-&gt;next</code>。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 435 无重叠区间</title>
    <url>/posts/231109150855.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435 无重叠区间</a>：给定一个区间的集合 <code>intervals</code>，其中 <code>intervals[i] = [start_i, end_i]</code>。返回需要移除区间的最小数量，使剩余区间互不重叠。注意，区间 <code>[1,2]</code> 和 <code>[2,3]</code> 的边界相互接触，但没有相互重叠。</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: intervals = [[1,4],[2,3],[4,6]]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 移除 [1,4] 后，剩下的区间没有重叠。</span><br></pre></td></tr></table></figure>
<h2 id="右区间排序 - 贪心算法">右区间排序 + 贪心算法</h2>
<p>既然说，移除最少的区间，使剩下区间互相不重叠。对于示例，因为 <code>[1,4]</code> 和 <code>[2,3]</code> 这两个区间重叠了，但都没跟 <code>[4,6]</code> 区间重叠，而 <code>[1,4]</code> 区间的右边界太大了，可能会影响到后续区间的最小值，有造成更多区间被移除的风险。所以，我们才移除右边界较大的那个区间。</p>
<p>因此，我们可以按照区间的右边界升序排序，然后使用一前、一后两个指针，指向待比较的两个区间，判断这两个区间是否需要移除一个：</p>
<ul>
<li>前指针指向的区间的右边界不大于后指针指向的区间的左边界，则不需要移除：
<ul>
<li>前指针指向后区间，后指针后移一个区间</li>
</ul>
</li>
<li>前指针指向的区间的右边界大于后指针指向的区间的左边界，则需要移除：
<ul>
<li>直接移除后区间（区间已经排序，留下右边界小的区间），前指针保持固定，后指针后移一个区间</li>
</ul>
</li>
</ul>
<p>时间复杂度：<code>O(nlogn)</code>，排序所需时间，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *pa, <span class="type">const</span> <span class="type">void</span> *pb)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *arr1 = *(<span class="type">const</span> <span class="type">int</span> **)pa;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *arr2 = *(<span class="type">const</span> <span class="type">int</span> **)pb;</span><br><span class="line">    <span class="keyword">return</span> arr1[<span class="number">1</span>] - arr2[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>** intervals, <span class="type">int</span> intervalsSize, <span class="type">int</span>* intervalsColSize)</span>&#123;</span><br><span class="line">    qsort(intervals, intervalsSize, <span class="keyword">sizeof</span>(intervals[<span class="number">0</span>]), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pre = <span class="number">0</span>, cur = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt; intervalsSize) &#123;</span><br><span class="line">        <span class="comment">// 不需要移除</span></span><br><span class="line">        <span class="keyword">if</span> (intervals[pre][<span class="number">1</span>] &lt;= intervals[cur][<span class="number">0</span>]) &#123;</span><br><span class="line">            pre = cur;  <span class="comment">// 前指针指向后一个区间</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 需要移除</span></span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        cur++;  <span class="comment">// 后指针后移一个区间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="左区间排序 - 贪心算法">左区间排序 + 贪心算法</h2>
<p>当然，我们也可以按照区间的左边界升序排序。但在需要移除时，需要进一步判断是移除前一个区间，还是后一个区间；也就是，对上一节中的「直接移除后区间（区间已经排序，留下右边界小的区间）」的判断。</p>
<p>时间复杂度：<code>O(nlogn)</code>，排序所需时间，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *pa, <span class="type">const</span> <span class="type">void</span> *pb)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *arr1 = *(<span class="type">const</span> <span class="type">int</span> **)pa;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *arr2 = *(<span class="type">const</span> <span class="type">int</span> **)pb;</span><br><span class="line">    <span class="keyword">return</span> arr1[<span class="number">0</span>] - arr2[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>** intervals, <span class="type">int</span> intervalsSize, <span class="type">int</span>* intervalsColSize)</span>&#123;</span><br><span class="line">    qsort(intervals, intervalsSize, <span class="keyword">sizeof</span>(intervals[<span class="number">0</span>]), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pre = <span class="number">0</span>, cur = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt; intervalsSize) &#123;</span><br><span class="line">        <span class="comment">// 不需要移除</span></span><br><span class="line">        <span class="keyword">if</span> (intervals[pre][<span class="number">1</span>] &lt;= intervals[cur][<span class="number">0</span>]) &#123;</span><br><span class="line">            pre = cur;  <span class="comment">// 前指针指向后一个区间</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 需要移除</span></span><br><span class="line">            <span class="comment">// 进一步判断是移除前一个区间，还是后一个区间</span></span><br><span class="line">            <span class="keyword">if</span> (intervals[pre][<span class="number">1</span>] &gt;= intervals[cur][<span class="number">1</span>]) &#123;</span><br><span class="line">                pre = cur;  <span class="comment">// 移除前一个区间</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        cur++;  <span class="comment">// 后指针后移一个区间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个题目，其实是 <strong> 预定会议的一个问题</strong>，给定若干个会议时间（开始时间 - 结束时间），然后去预定会议，那么能够成功预定的最大会议数是多少？其核心是找出最大不重叠区间的个数。</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 445 两数相加 II</title>
    <url>/posts/231031163133.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/add-two-numbers-ii/">445 两数相加 II</a>：给你两个非空链表来代表两个非负整数。<strong>数字最高位位于链表开始位置</strong>。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。你可以假设除了数字 0 之外，这两个数字都不会以零开头。进阶：如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [7,2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,8,0,7]</span><br></pre></td></tr></table></figure>
<h2 id="反转链表再遍历">反转链表再遍历</h2>
<p>其实我们可以利用 <a href="https://pursue26.github.io/posts/231025185947.html">LeetCode 刷题之 206 反转链表 </a> 和 <a href="https://pursue26.github.io/posts/231031120718.html">LeetCode 刷题之 2 两数相加 </a> 完成该题。</p>
<p>首先，将链表 <code>l1</code> 和链表 <code>l2</code> 反转，然后调用两数相加的代码，最后再对返回的链表再次反转即可。</p>
<p>时间复杂度：<code>O(max(m, n))</code>，空间复杂度：<code>O(1)</code>，不考虑输出占用的空间；递归调用栈的空间复杂度：<code>O(max(m, n))</code>，如果采用迭代的方式反转链表，则为常数空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">tail</span> =</span> reverseList(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">addTwoNumbers_i</span><span class="params">(<span class="keyword">struct</span> ListNode* l1, <span class="keyword">struct</span> ListNode* l2)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> =</span> &amp;dummy;</span><br><span class="line">    <span class="type">int</span> curSum = <span class="number">0</span>, carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l1 || l2 || carry &gt; <span class="number">0</span>) &#123;  <span class="comment">// 把最后一次加法是否有进位放在这里, 简化代码</span></span><br><span class="line">        <span class="comment">// 创建节点并指向 NULL</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node</span> =</span> (<span class="keyword">struct</span> ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算当前两节点相加的和, 加上进位</span></span><br><span class="line">        curSum = carry;</span><br><span class="line">        <span class="keyword">if</span> (l1) &#123;</span><br><span class="line">            curSum += l1-&gt;val;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2) &#123;</span><br><span class="line">            curSum += l2-&gt;val;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算本次加法的进位和相加值</span></span><br><span class="line">        carry = curSum &gt; <span class="number">9</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        curSum = curSum % <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将下一个节点指向新节点, 并修改其值为相加值</span></span><br><span class="line">        node-&gt;val = curSum;</span><br><span class="line">        cur-&gt;next = node;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">addTwoNumbers</span><span class="params">(<span class="keyword">struct</span> ListNode* l1, <span class="keyword">struct</span> ListNode* l2)</span>&#123;</span><br><span class="line">    l1 = reverseList(l1);</span><br><span class="line">    l2 = reverseList(l2);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">head</span> =</span> addTwoNumbers_i(l1, l2);</span><br><span class="line">    <span class="keyword">return</span> reverseList(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LIFO 堆栈">LIFO 堆栈</h2>
<blockquote>
<p>进阶：如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p>
</blockquote>
<p><strong>记住：如果需要考虑链表反转，首先考虑栈（后进先出）</strong>。</p>
<p>因此，我们可以申请两个栈空间，依次遍历两个链表，将节点按遍历顺序放入各自的堆栈中。然后，依次同时从两个堆栈中各弹出一个节点，进行两数相加，将相加形成的新节点，放入第三个堆栈中，直到相加操作结束。最后，依次弹出第三个堆栈中的节点，并将它们链接在一起，即为答案。</p>
<p>堆栈的实现：我们可以使用 <a href="https://pursue26.github.io/posts/231016161508.html"> 数据结构之堆栈（数组实现）</a>或 <a href="https://pursue26.github.io/posts/231016184406.html"> 数据结构之堆栈（链表实现）</a>中实现的堆栈数据结构。但是，为了简便，这里使用了普通数组来模拟堆栈。</p>
<p>时间复杂度：<code>O(max(m, n))</code>，空间复杂度：<code>O(max(m, n))</code>，即堆栈占用的空间，不考虑输出占用的空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">addTwoNumbers</span><span class="params">(<span class="keyword">struct</span> ListNode* l1, <span class="keyword">struct</span> ListNode* l2)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">stack1</span>[101], *<span class="title">stack2</span>[101], *<span class="title">stack3</span>[101];</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node1</span> =</span> l1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node2</span> =</span> l2;</span><br><span class="line">    <span class="type">int</span> pos1 = <span class="number">0</span>, pos2 = <span class="number">0</span>, pos3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (node1) &#123;</span><br><span class="line">        stack1[pos1++] = node1;</span><br><span class="line">        node1 = node1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (node2) &#123;</span><br><span class="line">        stack2[pos2++] = node2;</span><br><span class="line">        node2 = node2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pos1--;  <span class="comment">// 变成索引值</span></span><br><span class="line">    pos2--;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> curSum = <span class="number">0</span>, carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos1 &gt;= <span class="number">0</span> || pos2 &gt;= <span class="number">0</span> || carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建节点并指向 NULL</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node</span> =</span> (<span class="keyword">struct</span> ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算当前两节点相加的和, 加上进位</span></span><br><span class="line">        curSum = carry;</span><br><span class="line">        <span class="keyword">if</span> (pos1 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            curSum += stack1[pos1]-&gt;val;</span><br><span class="line">            pos1--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            curSum += stack2[pos2]-&gt;val;</span><br><span class="line">            pos2--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算本次加法的进位和相加值</span></span><br><span class="line">        carry = curSum &gt; <span class="number">9</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        curSum = curSum % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 相加和入第三个堆栈</span></span><br><span class="line">        node-&gt;val = curSum;</span><br><span class="line">        stack3[pos3++] = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">ans</span> =</span> stack3[--pos3];</span><br><span class="line">    <span class="comment">// 依次弹出第三个堆栈中的节点</span></span><br><span class="line">    <span class="keyword">while</span> (pos3 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        stack3[pos3]-&gt;next = stack3[pos3 - <span class="number">1</span>];</span><br><span class="line">        pos3--;</span><br><span class="line">    &#125;</span><br><span class="line">    stack3[pos3]-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 725 分隔链表</title>
    <url>/posts/231101135228.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/split-linked-list-in-parts/">725 分隔链表 </a>：给定一个头结点为 <code>root</code> 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 <code>null</code>。这 k 个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。返回一个由上述 k 部分组成的数组。</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 输入：head = [1,2,3], k = 5</span><br><span class="line"> 输出：[[1],[2],[3],[],[]]</span><br><span class="line"> 输入：head = [1,2,3,4,5,6,7,8,9,10], k = 3</span><br><span class="line"> 输出：[[1,2,3,4],[5,6,7],[8,9,10]]</span><br></pre></td></tr></table></figure>
<p> 函数接口：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode** <span class="title function_">splitListToParts</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> k, <span class="type">int</span>* returnSize)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="两趟遍历"> 两趟遍历 </h2>
<p> 该题就是正常的遍历，然后划分即可。首先，一次遍历计算链表的长度 <code>size</code>；然后，根据链表长度 <code>size</code> 和 <code>k</code> 值，计算划分的链表的长度，前 <code>size % k</code> 段的长度为 <code>size / k + 1</code>，后 <code>size - size % k</code> 段的长度为 <code>size / k</code>。</p>
<p> 时间复杂度：<code>O(n)</code>，两趟遍历，空间复杂度：<code>O(1)</code>，不算输出占用的空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode** <span class="title function_">splitListToParts</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> k, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node</span> =</span> head;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算链表长度 </span></span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        size++;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    node = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请返回的空间, 并全部初始化为 NULL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> **<span class="title">ans</span> =</span> (<span class="keyword">struct</span> ListNode **)<span class="built_in">malloc</span>(k * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode *));</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0</span>, k * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode *));</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a = size / k, b = size % k;</span><br><span class="line">    <span class="type">int</span> splitSize = <span class="number">0</span>, idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> save = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        <span class="comment">// 存储划分的每段链表的头节点 </span></span><br><span class="line">        <span class="keyword">if</span> (save) &#123;</span><br><span class="line">            ans[idx++] = node;</span><br><span class="line">            save = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        splitSize++;</span><br><span class="line">        <span class="comment">// 前 b 次划分的链表长度为 a+1, 后 size-b 次划分的链表长度为 a</span></span><br><span class="line">        <span class="keyword">if</span> (splitSize &lt; a + (b &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>)) &#123;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            splitSize = <span class="number">0</span>;</span><br><span class="line">            b = fmax(--b, <span class="number">0</span>);  <span class="comment">// b 减到 0 停止 </span></span><br><span class="line">            save = <span class="literal">true</span>;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">tmp</span> =</span> node;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = k;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题之 83 删除排序链表中的重复元素</title>
    <url>/posts/231026184514.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83 删除排序链表中的重复元素</a>：给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">输出: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure>
<h2 id="双指针解法">双指针解法</h2>
<p>我们可以使用 <strong> 一前、一后两个指针，找到前、后相邻的两个值不相等的节点，将它们链接起来</strong>。然后，将「前指针」重新指向「后指针」，「后指针」往后移动，继续找前、后相邻的两个值不相等的节点…直到后指针为空为止。</p>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">deleteDuplicates</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">left</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">right</span> =</span> head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left-&gt;val == right-&gt;val) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">temp</span> =</span> right;</span><br><span class="line">            right = right-&gt;next;</span><br><span class="line">            <span class="comment">// 释放节点空间</span></span><br><span class="line">            temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将它们链接起来</span></span><br><span class="line">            left-&gt;next = right;</span><br><span class="line">            <span class="comment">// 将前指针重新指向后指针，后指针往后移动</span></span><br><span class="line">            left = right;</span><br><span class="line">            right = right-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    left-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么退出前还有一行 <code>left-&gt;next = NULL</code> 代码？<br>
这是因为，如果原链表最后是以重复的元素退出 <code>while</code> 循环的，则 <code>left</code> 就是最后一个节点，但 <code>left-&gt;next</code> 此时还不是 <code>NULL</code>，所以需要这一行代码。</p>
<h2 id="单指针解法">单指针解法</h2>
<p>其实，我们也可以只使用一个指针，这个指针指向当前节点，只要「下一个节点」与当前节点的值相等，我们就更新当前节点的 <strong> 下一个节点 </strong> 为「再」下一个节点；遇到不相等时，才 <strong> 更新当前指针 </strong> 为「下一个节点」。</p>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">deleteDuplicates</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 「下一个节点」与当前节点的值相等</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val == cur-&gt;next-&gt;val) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">temp</span> =</span> cur-&gt;next;</span><br><span class="line">            <span class="comment">// 更新当前节点的下一个节点为「再」「下一个节点」</span></span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            <span class="comment">// 释放节点空间</span></span><br><span class="line">            temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不相等时，才更新当前指针为「下一个节点」</span></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归解法">递归解法</h2>
<p>假设，函数 <code>deleteDuplicates(head)</code> 已经了实现删除链表 <code>head</code> 中的重复节点，并返回删除后的链表的头节点。</p>
<p>那么，我们以 <code>head-&gt;next</code> 为头节点调用函数 <code>deleteDuplicates(head-&gt;next)</code>，将实现以 <code>head-&gt;next</code> 为头节点的 <strong> 子链表 </strong> 的去重操作，这时只需要将 <code>head</code> 的下一个节点指向这个去重的链表，就可以实现对 <strong> 完整链表 </strong> 的去重操作了。</p>
<p>但是，可能会遇到 <code>head</code> 和它的下一个节点 <code>head-&gt;next</code> 的值相等的时候，这是就需要 <strong> 修正头节点的地址</strong> —— 抛弃前面的节点。</p>
<p>递归的终止条件就是，链表为空或者只有一个节点。因为这时不需要进行去重操作。</p>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(n)</code>。</p>
<p>一种写法：先递归处理下一个节点，然后再判断下一个节点的值是否与当前节点的值相等，如果相等则删除当前节点，重新指定头节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">deleteDuplicates</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    head-&gt;next = deleteDuplicates(head-&gt;next);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next-&gt;val == head-&gt;val) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">temp</span> =</span> head;</span><br><span class="line">        head = head-&gt;next;  <span class="comment">// 修正头节点的地址</span></span><br><span class="line">        temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种写法：先判断下一个节点的值是否与当前节点的值相等，如果相等则先删除当前节点，然后递归地处理下一个节点，并更新头节点为删除重复节点之后的头节点；否则，说明相邻节点不重复，递归地处理下一个节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">deleteDuplicates</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next-&gt;val == head-&gt;val) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">temp</span> =</span> head-&gt;next;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(head);</span><br><span class="line">        head = deleteDuplicates(temp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        head-&gt;next = deleteDuplicates(head-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不管哪种写法，针对链表中的重复节点，都是删除前面的节点，保留下最后一个节点。</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>Libevent 高性能 IO 事件驱动库</title>
    <url>/posts/250619154429.html</url>
    <content><![CDATA[<span id="more"></span>
<p>rot13 服务端程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* For sockaddr_in */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="comment">/* For socket functions */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">/* For fcntl */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LINE 16384</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_read</span><span class="params">(<span class="type">evutil_socket_t</span> fd, <span class="type">short</span> events, <span class="type">void</span> *arg)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">do_write</span><span class="params">(<span class="type">evutil_socket_t</span> fd, <span class="type">short</span> events, <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">rot13_char</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">  <span class="comment">/* We don&#x27;t want to use isalpha here; setting the locale would change</span></span><br><span class="line"><span class="comment">   * which characters are considered alphabetical. */</span></span><br><span class="line">  <span class="keyword">if</span> ((c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;m&#x27;</span>) || (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;M&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> c + <span class="number">13</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ((c &gt;= <span class="string">&#x27;n&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) || (c &gt;= <span class="string">&#x27;N&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> c - <span class="number">13</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd_state</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> buffer[MAX_LINE];</span><br><span class="line">  <span class="type">size_t</span> buffer_used;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> n_written;</span><br><span class="line">  <span class="type">size_t</span> write_upto; <span class="comment">// 标记缓存到的位置 </span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">read_event</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">write_event</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> fd_state *<span class="title function_">alloc_fd_state</span><span class="params">(<span class="keyword">struct</span> event_base *base, <span class="type">evutil_socket_t</span> fd)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fd_state</span> *<span class="title">state</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> fd_state));</span><br><span class="line">  <span class="keyword">if</span> (!state) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;failed to alloc fs state\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  state-&gt;read_event = event_new(base, fd, EV_READ | EV_PERSIST, do_read, state);</span><br><span class="line">  <span class="keyword">if</span> (!state-&gt;read_event) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;failed to new read event\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(state);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  state-&gt;write_event =</span><br><span class="line">      event_new(base, fd, EV_WRITE | EV_PERSIST, do_write, state);</span><br><span class="line">  <span class="keyword">if</span> (!state-&gt;write_event) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;failed to new write event\n&quot;</span>);</span><br><span class="line">    event_free(state-&gt;read_event);</span><br><span class="line">    <span class="built_in">free</span>(state);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  state-&gt;buffer_used = state-&gt;n_written = state-&gt;write_upto = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_fd_state</span><span class="params">(<span class="keyword">struct</span> fd_state *state)</span> &#123;</span><br><span class="line">  event_free(state-&gt;read_event);</span><br><span class="line">  event_free(state-&gt;write_event);</span><br><span class="line">  <span class="built_in">free</span>(state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_read</span><span class="params">(<span class="type">evutil_socket_t</span> fd, <span class="type">short</span> events, <span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fd_state</span> *<span class="title">state</span> =</span> (<span class="keyword">struct</span> fd_state *)arg;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">ssize_t</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    assert(state-&gt;write_event);</span><br><span class="line">    result = recv(fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (result &lt;= <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; result; ++i) &#123;</span><br><span class="line">      <span class="comment">// 缓存还有空闲空间 </span></span><br><span class="line">      <span class="keyword">if</span> (state-&gt;buffer_used &lt; <span class="keyword">sizeof</span>(state-&gt;buffer))</span><br><span class="line">        state-&gt;buffer[state-&gt;buffer_used++] = rot13_char(buf[i]);</span><br><span class="line">      <span class="comment">// 服务端读完一行后，加入可写事件，可向客户端写入数据 </span></span><br><span class="line">      <span class="keyword">if</span> (buf[i] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">          state-&gt;buffer[state-&gt;buffer_used - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;receive a line data: %s\n&quot;</span>,</span><br><span class="line">                 (<span class="type">char</span> *)state-&gt;buffer + state-&gt;write_upto);</span><br><span class="line">          state-&gt;buffer[state-&gt;buffer_used - <span class="number">1</span>] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        assert(state-&gt;write_event);</span><br><span class="line">        event_add(state-&gt;write_event, <span class="literal">NULL</span>);</span><br><span class="line">        state-&gt;write_upto = state-&gt;buffer_used;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result == <span class="number">0</span>) &#123; <span class="comment">// 客户端关闭 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;warning, peer closed\n&quot;</span>);</span><br><span class="line">    free_fd_state(state);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">    free_fd_state(state);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_write</span><span class="params">(<span class="type">evutil_socket_t</span> fd, <span class="type">short</span> events, <span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fd_state</span> *<span class="title">state</span> =</span> arg;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一直写到标记处 </span></span><br><span class="line">  <span class="keyword">while</span> (state-&gt;n_written &lt; state-&gt;write_upto) &#123;</span><br><span class="line">    <span class="type">ssize_t</span> result = send(fd, state-&gt;buffer + state-&gt;n_written,</span><br><span class="line">                          state-&gt;write_upto - state-&gt;n_written, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      perror(<span class="string">&quot;send&quot;</span>);</span><br><span class="line">      free_fd_state(state);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(result != <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// printf(&quot;send %ld bytes data\n&quot;, result);</span></span><br><span class="line"></span><br><span class="line">    state-&gt;n_written += result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 巧妙的缓存复用 </span></span><br><span class="line">  <span class="keyword">if</span> (state-&gt;n_written == state-&gt;buffer_used)</span><br><span class="line">    state-&gt;n_written = state-&gt;write_upto = state-&gt;buffer_used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不再可写，等待服务端读取一行客户端数据后，再将其加入可写 </span></span><br><span class="line">  event_del(state-&gt;write_event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_accept</span><span class="params">(<span class="type">evutil_socket_t</span> listener, <span class="type">short</span> event, <span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> =</span> arg;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">ss</span>;</span></span><br><span class="line">  <span class="type">socklen_t</span> slen = <span class="keyword">sizeof</span>(ss);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 阻塞等待客户端的连接 */</span></span><br><span class="line">  <span class="type">int</span> cfd = accept(listener, (<span class="keyword">struct</span> sockaddr *)&amp;ss, &amp;slen);</span><br><span class="line">  <span class="keyword">if</span> (cfd &lt; <span class="number">0</span>) &#123; <span class="comment">// XXXX eagain??</span></span><br><span class="line">    perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cfd &gt; FD_SETSIZE) &#123;</span><br><span class="line">    close(cfd); <span class="comment">// XXX replace all closes with EVUTIL_CLOSESOCKET */</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;accept a client connection, fd=%d\n&quot;</span>, cfd);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fd_state</span> *<span class="title">state</span>;</span></span><br><span class="line">    evutil_make_socket_nonblocking(cfd);</span><br><span class="line">    state = alloc_fd_state(base, cfd);</span><br><span class="line">    assert(state);</span><br><span class="line">    assert(state-&gt;write_event);</span><br><span class="line">    <span class="comment">// 接受客户端连接后，监听客户端可读事件（等监听到可读事件后会触发可写事件）</span></span><br><span class="line">    event_add(state-&gt;read_event, <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">run</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">evutil_socket_t</span> listener;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">listener_event</span>;</span></span><br><span class="line"></span><br><span class="line">  base = event_base_new();</span><br><span class="line">  <span class="keyword">if</span> (!base) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;failed to new event base\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line">  <span class="built_in">sin</span>.sin_addr.s_addr = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">sin</span>.sin_port = htons(<span class="number">40713</span>);</span><br><span class="line"></span><br><span class="line">  listener = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  evutil_make_socket_nonblocking(listener);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> one = <span class="number">1</span>;</span><br><span class="line">  setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;one, <span class="keyword">sizeof</span>(one));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bind(listener, (<span class="keyword">struct</span> sockaddr *)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (listen(listener, <span class="number">16</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  listener_event =</span><br><span class="line">      event_new(base, listener, EV_READ | EV_PERSIST, do_accept, (<span class="type">void</span> *)base);</span><br><span class="line">  event_add(listener_event, <span class="literal">NULL</span>);</span><br><span class="line">  event_base_dispatch(base);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="comment">/* is exactly equivalent to setlinebuf(stdout) */</span></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">  run();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rot13 客户端：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* For sockaddr_in */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="comment">/* For socket functions */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">/* For fcntl */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_event</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">read_event</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">write_event</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> read_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_event</span> <span class="title">my_event</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_read</span><span class="params">(<span class="type">evutil_socket_t</span> fd, <span class="type">short</span> events, <span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">user_event</span> *<span class="title">my_event</span> =</span> (<span class="keyword">struct</span> user_event *)arg;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">  <span class="type">ssize_t</span> recv_bytes = <span class="number">0</span>;</span><br><span class="line">  <span class="type">ssize_t</span> res;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    res = recv(fd, buf + recv_bytes, <span class="keyword">sizeof</span>(buf) - recv_bytes - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;failed to recv, error=%s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;warning, peer closed\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    recv_bytes += res;</span><br><span class="line">  &#125; <span class="keyword">while</span> (res &gt; <span class="number">0</span> &amp;&amp; recv_bytes &lt; <span class="number">1023</span>);</span><br><span class="line"></span><br><span class="line">  buf[recv_bytes] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;receive %dth rot13: %s&quot;</span>, read_cnt + <span class="number">1</span>, buf);</span><br><span class="line">  event_add(my_event-&gt;write_event, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_write</span><span class="params">(<span class="type">evutil_socket_t</span> fd, <span class="type">short</span> events, <span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">user_event</span> *<span class="title">my_event</span> =</span> (<span class="keyword">struct</span> user_event *)arg;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *send_data = <span class="string">&quot;abcdtxyz\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (++read_cnt &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    send(fd, send_data, <span class="built_in">strlen</span>(send_data), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 不再可写，等待再次读取到数据时，再将其加入可写 </span></span><br><span class="line">    event_del(my_event-&gt;write_event);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;send data: %s&quot;</span>, send_data);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 有限次发送后退出 </span></span><br><span class="line">    event_base_loopbreak(my_event-&gt;base);</span><br><span class="line">    event_free(my_event-&gt;write_event);</span><br><span class="line">    event_free(my_event-&gt;read_event);</span><br><span class="line">    event_base_free(my_event-&gt;base);</span><br><span class="line">    close(fd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">run</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">evutil_socket_t</span> cfd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line"></span><br><span class="line">  my_event.base = event_base_new();</span><br><span class="line">  <span class="keyword">if</span> (!my_event.base) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;failed to new event base\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> one = <span class="number">1</span>;</span><br><span class="line">  setsockopt(cfd, SOL_SOCKET, SO_REUSEADDR, &amp;one, <span class="keyword">sizeof</span>(one));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;saddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">  saddr.sin_family = AF_INET;</span><br><span class="line">  saddr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">  saddr.sin_port = htons(<span class="number">40713</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (connect(cfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 在连接成功后再设置为非阻塞模式，否则需要监听连接事件的结果 */</span></span><br><span class="line">  evutil_make_socket_nonblocking(cfd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 写一些数据，可触发服务端的读事件就绪 */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *send_data = <span class="string">&quot;ABCxyz\n&quot;</span>;</span><br><span class="line">  send(cfd, send_data, <span class="built_in">strlen</span>(send_data), <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;send data: %s&quot;</span>, send_data);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 创建客户端的监听事件，用于读取服务端的数据 */</span></span><br><span class="line">  my_event.read_event = event_new(my_event.base, cfd, EV_READ | EV_PERSIST,</span><br><span class="line">                                  do_read, (<span class="type">void</span> *)&amp;my_event);</span><br><span class="line">  <span class="comment">/* 创建客户端的监听事件，用于像服务端写数据 */</span></span><br><span class="line">  my_event.write_event = event_new(my_event.base, cfd, EV_WRITE | EV_PERSIST,</span><br><span class="line">                                   do_write, (<span class="type">void</span> *)&amp;my_event);</span><br><span class="line">  event_add(my_event.read_event, <span class="literal">NULL</span>);</span><br><span class="line">  event_base_dispatch(my_event.base);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;client exit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="comment">/* is exactly equivalent to setlinebuf(stdout) */</span></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">  run();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>IO事件驱动</tag>
        <tag>epoll</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 命令之文件权限</title>
    <url>/posts/240417193754.html</url>
    <content><![CDATA[<p>Linux 是 UNIX like，UNIX 是一种可以由多个用户同时访问的多用户操作系统。Linux 也可以在不进行任何修改的情况下用于大型机和服务器。但这会引发安全问题，因为未经请求或恶意的用户可能会损坏、更改或删除关键数据。<strong>为了有效的安全性，Linux 将授权分为 2 个级别：权限（permission）和所有权（ownership）</strong>。</p>
<span id="more"></span>
<h1 id="Linux- 文件权限">Linux 文件权限</h1>
<p>Linux 文件权限系统基于用户（user）、用户组（group）和其他用户（other）的访问级别来控制文件和目录的访问。权限（permission）包括读取（r）、写入（w）和执行（x）。</p>
<h2 id="基本概念">基本概念</h2>
<p><strong>文件类型</strong>：共 7 种类型，需要 3 bits 即可（实际分配了 4 bits）。</p>
<table>
<thead>
<tr>
<th>表示</th>
<th>描述</th>
<th>文件类型</th>
<th>宏定义</th>
<th>八进制值</th>
</tr>
</thead>
<tbody>
<tr>
<td>s</td>
<td>套接字文件</td>
<td>socket file</td>
<td>S_IFSOCK</td>
<td>0140000</td>
</tr>
<tr>
<td>l</td>
<td>符号链接（软链接）</td>
<td>symbolic link</td>
<td>S_IFLINK</td>
<td>0120000</td>
</tr>
<tr>
<td>-</td>
<td>普通文件</td>
<td>regular file</td>
<td>S_IFREG</td>
<td>0100000</td>
</tr>
<tr>
<td>b</td>
<td>块设备文件</td>
<td>block device</td>
<td>S_IFBLK</td>
<td>060000</td>
</tr>
<tr>
<td>d</td>
<td>目录</td>
<td>directory</td>
<td>S_IFDIR</td>
<td>040000</td>
</tr>
<tr>
<td>c</td>
<td>字符设备文件</td>
<td>character device</td>
<td>S_IFCHR</td>
<td>020000</td>
</tr>
<tr>
<td>p</td>
<td>命名管道</td>
<td>named FIFO pipe</td>
<td>S_IFIFO</td>
<td>010000</td>
</tr>
</tbody>
</table>
<blockquote>
<p>宏定义定义在文件 #include &lt;sys/stat.h&gt; 中，低 12 bits 为权限位，文件类型只需关心高 4bits，故低 12 bits 填充为 0。</p>
</blockquote>
<p><strong>文件权限</strong>：共三类权限，每类权限独立控制，故需要 3 bits。</p>
<ul>
<li><code>r</code> = read permission</li>
<li><code>w</code> = write permission</li>
<li><code>x</code> = execute permission</li>
<li><code>–</code> = no permission</li>
</ul>
<p><strong>所有权</strong>：三类用户，每类用户对文件权限独立控制，故共需要 3 * 3 bits。</p>
<ul>
<li><strong>user</strong>：文件拥有者。默认情况下，创建文件的人成为其拥有者。</li>
<li><strong>group</strong>：文件拥有者所在用户组（user-group）的其他成员。属于一个组的所有用户都将具有相同的组权限来访问该文件。</li>
<li><strong>other</strong>：除拥有者和用户组成员以外的其他用户。</li>
</ul>
<img src="/images/linux-cmd/PermissionsConcept.png" alt="Linux/Unix 中的文件权限" width="50%" height="50%">
<p>每个“文件”有 9 bits 权限位：每 3 个权限位分为一组，分别代表文件所有者、文件所有者所属组、其他用户。同时，具有 4 bits 的“文件”类型，用于表示 7 种类型。其它 3 bits 为特殊权限位。Linux 文件类型和模式的组织结构如下：</p>
<img src="/images/linux-cmd/stat_mode.png" alt="Linux 文件类型和模式的组织结构" width="80%" height="80%">
<p><strong>Linux 命令显示示例</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l</span><br><span class="line">-rw-r--r-- 1 user group 1024 Apr 18 10:00 file.txt</span><br><span class="line">prw-r--r-- 1 root root    10 Apr 18 10:02 tester</span><br><span class="line">drwxr-xr-x 2 root root  4096 Apr 18 13:38 data</span><br></pre></td></tr></table></figure>
<h2 id="文件权限表示方式">文件权限表示方式</h2>
<h3 id="数字模式">数字模式</h3>
<p>在此模式下，文件权限不表示为字符，而是 <strong> 表示为三位八进制数</strong>。下表给出了所有权限类型的数字。</p>
<ul>
<li>每组权限位用数字表示，r=4，w=2，x=1，然后将三个权限相加得到相应的数字。</li>
</ul>
<table>
<thead>
<tr>
<th>Number</th>
<th>Permission Type</th>
<th>Symbol</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>No Permission</td>
<td>---</td>
</tr>
<tr>
<td>1</td>
<td>Execute</td>
<td>--x</td>
</tr>
<tr>
<td>2</td>
<td>Write</td>
<td>-w-</td>
</tr>
<tr>
<td>3</td>
<td>Execute + Write</td>
<td>-wx</td>
</tr>
<tr>
<td>4</td>
<td>Read</td>
<td>r--</td>
</tr>
<tr>
<td>5</td>
<td>Read + Execute</td>
<td>r-x</td>
</tr>
<tr>
<td>6</td>
<td>Read + Write</td>
<td>rw-</td>
</tr>
<tr>
<td>7</td>
<td>Read + Write + Execute</td>
<td>rwx</td>
</tr>
</tbody>
</table>
<p>例如，一个文件权限的 <strong> 数字表示法 </strong> 为<code>764</code>，其对应的 <strong> 符号表示法 </strong> 为 <code>-rwxrw-r--</code>。其中，第一个字符代表文件类型，后面三组分别代表文件所有者、组成员、其他用户的权限。在这个示例中：</p>
<ul>
<li><strong>owner</strong> can read, write and execute</li>
<li><strong>group</strong> can read and write</li>
<li><strong>other</strong> can only read</li>
</ul>
<h3 id="符号模式">符号模式</h3>
<p>在绝对（数字）模式下，你可以同时更改 3 个所有者的权限。但是，<strong>在符号模式下，你可以修改特定所有者的权限</strong>。它利用数学符号来修改 Unix 文件权限。</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>为文件或目录添加权限</td>
</tr>
<tr>
<td>–</td>
<td>删除权限</td>
</tr>
<tr>
<td>=</td>
<td>设置权限并覆盖之前设置的权限</td>
</tr>
</tbody>
</table>
<p>不同的所有者的表示：</p>
<table>
<thead>
<tr>
<th>标记</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>u</td>
<td>用户（所有者）</td>
</tr>
<tr>
<td>g</td>
<td>用户组</td>
</tr>
<tr>
<td>o</td>
<td>其他用户</td>
</tr>
<tr>
<td>a</td>
<td>所有用户</td>
</tr>
</tbody>
</table>
<h2 id="示例命令">示例命令</h2>
<p>ch-change, mod-mode, own-owner, grp-group</p>
<p><code>chmod</code>：改变文件的权限模式</p>
<ul>
<li><code>chmod u+x file.txt</code>：给文件所有者添加执行权限</li>
<li><code>chmod g-w file.txt</code>：删除用户组的写入权限</li>
<li><code>chmod o=rwx file.txt</code>：设置其它用户的文件权限位 <code>rwx</code></li>
<li><code>chmod 644 file.txt</code>：设置文件权限为 <code>-rw-r--r--</code></li>
<li><code>chmod u=rwx,go+x file.txt</code>：设置文件所有者的权限，并给用户组、其它用户添加执行权限</li>
</ul>
<p><code>chown</code>：改变文件的所有者和所属组</p>
<ul>
<li><code>chown user:group file.txt</code>：将文件所有者修改为 <code>user</code>，所属组修改为 <code>group</code></li>
<li><code>chown root file.txt</code>：将文件所有者修改为 <code>root</code></li>
</ul>
<p><code>chgrp</code>：改变文件的所属组</p>
<ul>
<li><code>chgrp group file.txt</code>：将文件所属组修改为 <code>group</code></li>
</ul>
<h1 id="UNIX- 接口">UNIX 接口</h1>
<h2 id="stat-fstat-lstat 函数">stat/fstat/lstat 函数</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> statbuf)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *statbuf)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> statbuf)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">    These functions <span class="keyword">return</span> information about a file, in the buffer</span><br><span class="line">    pointed to by statbuf.  No permissions are required on the file</span><br><span class="line">    itself, but—in the <span class="keyword">case</span> of stat(), fstatat(), and lstat()—execute</span><br><span class="line">    (search) permission is required on all of the directories in</span><br><span class="line">    pathname that lead to the file.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">    On success, zero is returned.  On error, <span class="number">-1</span> is returned, and</span><br><span class="line">    errno is <span class="built_in">set</span> to indicate the error.</span><br></pre></td></tr></table></figure>
<p>这些 <strong> 函数返回指定文件的状态信息，存储在 statbuf 指向的缓冲区中</strong>。文件本身不需要任何权限，但在 stat()、fstatat() 和 lstat() 的情况下，需要对通向该文件的路径名中的所有目录具有执行（搜索）权限。</p>
<ul>
<li>fstat() 与 stat() 相同，只是要检索其信息的文件由文件描述符 fd 指定。</li>
<li>lstat() 与 stat() 相同，只不过如果路径名是符号链接（symbolic link），则它返回有关链接本身的信息，而不是链接引用的文件的信息。</li>
</ul>
<h2 id="struct-stat 结构体">struct stat 结构体</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="type">dev_t</span>      st_dev;      <span class="comment">/* ID of device containing file */</span></span><br><span class="line">    <span class="type">ino_t</span>      st_ino;      <span class="comment">/* Inode number */</span></span><br><span class="line">    <span class="type">mode_t</span>     st_mode;     <span class="comment">/* File type and mode */</span></span><br><span class="line">    <span class="type">nlink_t</span>    st_nlink;    <span class="comment">/* Number of hard links */</span></span><br><span class="line">    <span class="type">uid_t</span>      st_uid;      <span class="comment">/* User ID of owner */</span></span><br><span class="line">    <span class="type">gid_t</span>      st_gid;      <span class="comment">/* Group ID of owner */</span></span><br><span class="line">    <span class="type">dev_t</span>      st_rdev;     <span class="comment">/* Device ID (if special file) */</span></span><br><span class="line">    <span class="type">off_t</span>      st_size;     <span class="comment">/* Total size, in bytes */</span></span><br><span class="line">    <span class="type">blksize_t</span>  st_blksize;  <span class="comment">/* Block size for filesystem I/O */</span></span><br><span class="line">    <span class="type">blkcnt_t</span>   st_blocks;   <span class="comment">/* Number of 512 B blocks allocated */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Since POSIX.1-2008, this structure supports nanosecond</span></span><br><span class="line"><span class="comment">        precision for the following timestamp fields.</span></span><br><span class="line"><span class="comment">        For the details before POSIX.1-2008, see VERSIONS. */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>  <span class="title">st_atim</span>;</span>  <span class="comment">/* Time of last access */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>  <span class="title">st_mtim</span>;</span>  <span class="comment">/* Time of last modification */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>  <span class="title">st_ctim</span>;</span>  <span class="comment">/* Time of last status change */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> st_atime  st_atim.tv_sec  <span class="comment">/* Backward compatibility */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> st_mtime  st_mtim.tv_sec</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> st_ctime  st_ctim.tv_sec</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该结构中 st_mode 字段就是上文中的“Linux 文件类型和模式的组织结构”那张图，只用了 16 bits 就可以得知文件的类型和权限设置，很节省空间！下面是与 st_mode 字段相关的一些宏定义。</p>
<p><strong>判断文件类型的宏定义</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> S_IFMT (0xF000)</span></span><br><span class="line"><span class="comment">/* 判断原理就是拿 m 的高 4bits 与高 4bits 全 1 的 mask 值进行与运算后，与各个文件类型的定义进行比较 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	S_ISDIR(m)	(((m) &amp; S_IFMT) == S_IFDIR) <span class="comment">// 判断文件是否是一个 directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	S_ISFIFO(m)	(((m) &amp; S_IFMT) == S_IFIFO) <span class="comment">// 判断文件是否是一个 named FIFO pipe</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	S_ISCHR(m)	(((m) &amp; S_IFMT) == S_IFCHR) <span class="comment">// 判断文件是否是一个 character device</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	S_ISBLK(m)	(((m) &amp; S_IFMT) == S_IFBLK) <span class="comment">// 判断文件是否是一个 block device</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	S_ISREG(m)	(((m) &amp; S_IFMT) == S_IFREG) <span class="comment">// 判断文件是否是一个 regular file</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用示例 */</span></span><br><span class="line"><span class="type">int</span> ret_code;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">ret_code = stat(path, &amp;st);</span><br><span class="line">assert(ret_code, <span class="number">0</span>);</span><br><span class="line">S_ISREG(st.st_mode); <span class="comment">// 判断文件是否是一个 regular file</span></span><br></pre></td></tr></table></figure>
<p><strong>检查文件权限的宏定义</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> S_IRWXU  00700 <span class="comment">// owner has read, write, and execute permission</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IRUSR  00400 <span class="comment">// owner has read permission</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IWUSR  00200 <span class="comment">// owner has write permission</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IXUSR  00100 <span class="comment">// owner has execute permission</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IRWXG  00070 <span class="comment">// group has read, write, and execute permission</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IRGRP  00040 <span class="comment">// group has read permission</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IWGRP  00020 <span class="comment">// group has write permission</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IXGRP  00010 <span class="comment">// group has execute permission</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IRWXO  00007 <span class="comment">// others (not in group) have read, write, and execute permission</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IROTH  00004 <span class="comment">// others have read permission</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IWOTH  00002 <span class="comment">// others have write permission</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IXOTH  00001 <span class="comment">// others have execute permission</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用示例，判断是否具有执行权限 */</span></span><br><span class="line"><span class="keyword">if</span> ((st.st_mode &amp; S_IXUSR) || (st.st_mode &amp; S_IXGRP) || (st.st_mode &amp; S_IXOTH)) &#123; &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考资料</p>
<ol>
<li><a href="https://rgb-24bit.github.io/blog/2018/linux-file-permission.html">https://rgb-24bit.github.io/blog/2018/linux-file-permission.html</a></li>
<li><a href="https://www.guru99.com/file-permissions.html">https://www.guru99.com/file-permissions.html</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1726535">https://cloud.tencent.com/developer/article/1726535</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Linux命令</category>
      </categories>
      <tags>
        <tag>文件权限</tag>
      </tags>
  </entry>
  <entry>
    <title>Unix 网络编程卷一阅读随笔</title>
    <url>/posts/240527200241.html</url>
    <content><![CDATA[<p>Unix 网络编程卷一阅读随笔。</p>
<span id="more"></span>
<h1 id="TCP 与 socket 系统调用">TCP 与 socket 系统调用</h1>
<p>[C2.4, 35] TCP 客户先与某个给定服务器建立一个连接（三次握手），再跨该连接与那个服务器交换数据，然后终止这个连接（四次挥手）。</p>
<p>[C2.4, 37-39] 结合 socket 网络编程接口，TCP 的三次握手与四次挥手：</p>
<ol>
<li>
<p><strong>服务器被动打开 </strong>：服务器首先调用<code>socket()</code> 函数创建一个套接字，然后调用 <code>bind()</code> 函数将该套接字绑定到一个本地地址和端口。接着，服务器调用 <code>listen()</code> 函数使该套接字进入监听状态，准备好接受外来的连接。</p>
</li>
<li>
<p><strong>服务器调用 <code>accept()</code></strong>：服务器调用<code>accept()</code> 函数，该函数阻塞等待客户端的连接请求。当有客户端请求连接时，<code>accept()</code>返回一个新的套接字描述符，用于与客户端进行通信。原来的监听套接字继续保持监听状态。</p>
</li>
<li>
<p><strong>客户端发起主动打开 </strong>：客户端调用<code>socket()</code> 函数创建一个套接字，然后调用 <code>connect()</code> 函数向服务器发起连接请求。此时，客户端和服务器进行 TCP 的三次握手：</p>
<ul>
<li>客户端发送 SYN 包（第一次握手）。</li>
<li>服务器收到 SYN 包，回复 SYN+ACK 包（第二次握手）。</li>
<li>客户端收到 SYN+ACK 包，回复 ACK 包（第三次握手），连接建立。</li>
</ul>
</li>
<li>
<p><strong>服务器 accept 返回 </strong>：当服务器收到客户端的连接请求（即 SYN 包）后，<code>accept()</code> 函数返回，提供一个新的套接字描述符用于与客户端通信。此时，三次握手完成，客户端和服务器可以开始通信。</p>
</li>
<li>
<p><strong>数据传输</strong>：连接建立后，客户端和服务器可以通过套接字进行数据传输。服务器一般调用<code>read()</code>（或<code>recv()</code>）函数阻塞等待接收数据，客户端调用<code>write()</code>（或<code>send()</code>）函数发送数据。</p>
</li>
<li>
<p><strong>连接关闭 </strong>：数据传输完成后，<em> 通常 </em> 由客户端调用 <code>close()</code> 函数发起主动关闭连接，进行四次挥手：</p>
<ul>
<li>客户端发送 FIN 包，表示主动关闭连接（第一次挥手）。</li>
<li>服务器收到 FIN 包，回复 ACK 包（第二次挥手），此时服务器进入 CLOSE_WAIT 状态。</li>
<li>服务器调用 <code>close()</code> 函数，发送 FIN 包（第三次挥手），表示准备关闭连接。</li>
<li>客户端收到服务器的 FIN 包，回复 ACK 包（第四次挥手），此时连接关闭。</li>
</ul>
<p>客户端进入 TIME_WAIT 状态，等待一定时间后彻底关闭连接，确保服务器收到 ACK 包。</p>
</li>
</ol>
<blockquote>
<p>无论是客户端还是服务器，任何一端都可以调用 <code>close()</code> 执行主动关闭。通常情况是客户端执行主动关闭，但是某些协议（比如 HTTP/1.0）却是由服务器执行主动关闭。</p>
</blockquote>
<img src="/images/unix-socket/unix-2-tcp-1.png" alt="TCP 状态转移图" width="80%" height="80%">
<p>结合 <a href="https://pursue26.github.io/posts/240329202002.html"> 这篇文章 </a> 的 TCP 三次握手和四次挥手一起理解上图和下图。</p>
<img src="/images/unix-socket/unix-2-tcp-2.png" alt="TCP 连接的分组交换（包括连接建立、数据传输和连接终止）" width="80%" height="80%">
<blockquote>
<p>上图中，<strong>服务器对客户端请求的 ACK 确认是伴随着其应答消息一起发送的</strong>，这种做法称为捎带（piggybacking）。它通常在服务器处理请求并产生应答的时间少于 200ms 时发生。如果处理耗时更长，如 1s，那么我们看到的将先是 ACK 确认，后是应答。</p>
</blockquote>
<h1 id="socket 基本结构">socket 基本结构</h1>
<h2 id="socket 地址">socket 地址</h2>
<p>IPv4 套接字地址：struct sockaddr_in {}</p>
<p>IPv6 套接字地址：struct sockaddr_in6 {}</p>
<p>通用套接字地址：struct sockaddr {}</p>
<p>当某种套接字地址作为一个参数传递给任何套接字函数时，套接字总是以引用的形式来传递，且 <strong> 这些套接字函数必须能处理任意协议族的套接字地址结构 </strong>。故此，需要将它们强转转换成通用套接字地址，传递给这些函数。这些函数有：bind(), connect(), accept() 等。</p>
<p>[C3.3, 73-74] 有时候，应用进程需要告诉内核套接字地址的长度（内核就知道从进程复制多少数据进来了，这样内核在操作该结构时不至于越界），且内核需要告诉应用进程套接字地址的长度（它告诉进程内核在该结构中究竟存储了多少数据）。这就需要值 - 结果类型的参数，传入指向地址长度的指针、返回地址长度的结果再存储在这个指针中，供应用进程使用。</p>
<h2 id="IP 地址转换">IP 地址转换</h2>
<p>[C3.6, 81-83]</p>
<p>ASCII 字符串格式的 IP 与二进制格式的网络地址相互转换：</p>
<p>IPv4 ASCII 到 Network 地址：inet_aton(), <s>inet_addr()</s><br>
Network 地址到 IPv4 ASCII：inet_ntoa()</p>
<p>使用于 IPv4 和 IPv6 的新的转换函数，p=presentation, n=numeric：</p>
<p>ASCII 到 Network 地址：inet_pton()<br>
Network 地址到 ASCII：inet_ntop()</p>
<h2 id="输入输出字节比实际少">输入输出字节比实际少</h2>
<p>[C3.9, 88-89]</p>
<p>对于字节流套接字（如 TCP 套接字）上的 read()和 write()函数所表现的行为不同于通常的文件 I/O。字节流套接字上调用 read()或 write()，<strong>输入或输出的字节数可能比实际请求的数量少</strong>，但这不表示发生了错误。</p>
<p>这个现象的原因是：内核中用于套接字的缓冲区可能已达到了极限。此时需要调用者再次调用 read()或 write()函数，以输入或输出剩余的字节。</p>
<p>你是否有印象，好多 read()都在 whlie 循环下执行，除了由于网络的不确定性和延迟，也有上述原因（个人理解）。</p>
<h1 id="socket 基本编程">socket 基本编程</h1>
<h2 id="socket-C-S 通信">socket C/S 通信</h2>
<img src="/images/unix-socket/unix-4-socket-1.png" alt="基本 TCP 客户 / 服务器程序的 socket 函数" width="80%" height="80%">
<h2 id="connect">connect()</h2>
<p>[C4.3, 99-100]</p>
<p>在客户端调用 connect()函数前不必非得调用 bind()函数——因为如果需要的话，内核会确定源 IP 地址，并选择一个临时端口作为源端口。</p>
<h2 id="bind">bind()</h2>
<p>[C4.4, 100-102]</p>
<p>调用 connect()函数将触发 TCP 三次握手，而且仅在连接建立成功或出错时才返回。</p>
<p>bind()函数把一个本地协议地址赋予一个套接字。</p>
<ul>
<li>对于 IP 协议，协议地址是 32 位 IPv4 地址或 128 位 IPv6 地址与 TCP/UDP 端口号的组合。</li>
<li>对于 TCP，调用 bind()函数可以指定一个端口号、或指定一个 IP 地址、也可以两者都指定或都不指定。</li>
<li>一般服务器会绑定一个众所周知的端口号，以便被大家（客户）认识。</li>
<li>如果不绑定端口号，不管服务器还是客户端，当调用 listen()或 connect()时，内核就要为相应的套接字分配一个临时端口。</li>
</ul>
<p>如果客户端或服务器不绑定 IP 地址，会怎么处理？</p>
<ul>
<li>一般地，客户端通常不把 IP 地址绑定到它的套接字上。当连接（服务器）套接字时，内核将根据所用外出网路接口来选择源 IP 地址。</li>
<li>一般地，服务器通常需要把 IP 地址绑定到它的套接字上。当未绑定时，内核就把客户端在三次握手中发送的 SYN 报文的目的 IP 地址作为服务器的源 IP 地址。</li>
<li>使用通配地址时，一般为 htonl(INADDR_ANY) / htonl(in6addr_any)，表示让内核指定 IP 地址。</li>
<li>指定端口为 0 时，表示让内核选择一个临时端口——要查看分配的端口，使用 getsockname()函数返回协议地址，进而获取端口。</li>
</ul>
<h2 id="listen">listen()</h2>
<p>listen()函数仅由 TCP 服务器调用。</p>
<p>当 socket()函数创建一个套接字时，它被假设为一个主动套接字。也就是说，它被假设为是一个将调用 connect()发起连接的客户套接字。但是，在服务端没有 connect()调用，listen()将一个未 connect 的套接字转换成一个被动套接字，指示内核应该接收指向该套接字的连接请求。</p>
<p>listen()监听最大 backlog 个连接，其中 backlog 是未完成连接队列个数（未完成 TCP 三次握手的分节在此队列）和已完成连接队列（已完成 TCP 三次握手的分节在此队列）个数之和。若分节完成三次握手，则将被转移至已完成连接队列的队尾。</p>
<img src="/images/unix-socket/unix-4-socket-2.png" alt="TCP 为监听套接字维护的两个队列" width="80%" height="80%">
<h2 id="accept">accept()</h2>
<p>accept()函数仅由 TCP 服务器调用，用于从已完成连接队列的队头返回下一个已完成连接的客户套接字（返回值称为已连接套接字，accept 第一个参数称为监听套接字）。</p>
<ul>
<li>监听套接字：一个服务器通常仅仅创建一个监听套接字，它在该服务器的生命周期内一直存在。</li>
<li>已连接套接字：随着 TCP 三次握手的完成而由内核创建的客户套接字，并在服务器完成对该客户的服务时，被关闭。</li>
</ul>
<h2 id="fork">fork()</h2>
<p>Unix 系统中派生新进程的唯一方法——fork()及其变体。</p>
<p>在进程中调用一次 fork()，它却返回两次：</p>
<ul>
<li>在父进程中返回一次，返回值是新派生的子进程的 PID；</li>
<li>在子进程中返回一次，返回值是 0。</li>
</ul>
<p>子进程的返回值是 0，是因为子进程的父进程唯一，它可以通过 getpid()获取父进程的 PID。而父进程只能通过记录返回值来存储多个子进程的 PID。</p>
<p><strong>父进程中调用 fork()之前打开的所有描述符，在 fork()返回之后，可在父进程与子进程之间共享</strong>。</p>
<p>利用这个特性，在网络服务器中，可在 accept()返回客户套接字后，fork()一个子进程，由子进程处理这个客户的请求，而父进程可关闭这个客户套接字，从而可以再次 accept()其它连接请求。</p>
<p><strong>对于“父进程可关闭这个客户套接字”，那么为什么子进程中还能使用这个客户套接字</strong>？</p>
<p>这是因为描述符（文件或套接字）都有一个引用计数。引用计数在文件表项中维护，它是当前打开着的描述符的个数。</p>
<p>当 fork()返回后，父进程中先前打开的所有描述符，会在父进程与子进程间共享（也就是被复制），即每个描述符的引用计数都会加 1。因此，一个描述符真正的清理和资源释放要等到其引用计数值达到 0 时才发生。</p>
<h2 id="getsockname">getsockname()</h2>
<p>使用 name 一词令人误解，getsockname()和 getpeername()函数返回是本端或对端的协议地址——对于 IP 协议来说，就是 IP 地址和端口号。</p>
<p>需要这两个函数理由：</p>
<ul>
<li>在没有调用 bind()的客户端上，connect()成功返回后，getsockname()用于返回由内核赋予该连接的本地 IP 地址和端口号。</li>
<li>在以端口号 0 调用 bind()时，getsockname()用于返回由内核动态赋予的本地端口号。</li>
<li>getsockname()可用于获取某个套接字的地址族。</li>
<li>在服务端，可以使用 getsockname()返回已连接套接字（客户套接字）的本地 IP 地址和端口号。</li>
</ul>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Wireshark 抓包分析 TCP 三次握手与四次挥手过程</title>
    <url>/posts/240911185603.html</url>
    <content><![CDATA[<span id="more"></span>
<p>关于 TCP 三次握手与四次挥手的过程与原因，请看 <a href="/posts/240329202002.html"> 这里 </a>。本文主要参考<a href="https://blog.csdn.net/dingdingdodo/article/details/107225020"> 用 wireshark 抓包来详细分析 TCP 三次握手和四次挥手过程</a>，也亲自进行一次抓包、分析。</p>
<h1 id="TCP 三次握手抓包分析">TCP 三次握手抓包分析</h1>
<h2 id="Wireshark 抓包">Wireshark 抓包</h2>
<p>首先开启 Wireshark 监听的网卡，然后访问某个 https 博客，输入简单的过滤规则进行过滤，抓包如下：</p>
<img src="../images/computer-network/wireshake-tcp-3handshakes-0.png" alt="Wireshake 抓包的 TCP 三次握手报文" width="100%" height="100%">
<h2 id="第一次握手">第一次握手</h2>
<h3 id="首部解析">首部解析</h3>
<p>假设 A 为客户端，B 为服务端。</p>
<p>第一次握手：A 向 B 发送连接请求报文，SYN=1, ACK=0，并选择一个初始的序号 x（如抓包中的 Seq=0）。</p>
<img src="../images/computer-network/wireshake-tcp-3handshakes-1.1.png" alt="TCP 建立连接的第一次握手" width="100%" height="100%">
<p>也就是说，第一个包中 SYN 位被置 1，<strong>表示要和目的主机同步序列号</strong>，同时附加并协商 MSS 信息、窗口扩大因子等信息。</p>
<h3 id="Options 解析">Options 解析</h3>
<p>在 TCP 三次握手的第一次握手（即客户端发送的 SYN 报文）中，<strong>TCP 首部的 Options 字段通常会被填充</strong>。这些选项字段用于协商连接参数，以确保通信双方能够在最佳状态下进行数据传输。常见的选项包括：</p>
<img src="../images/computer-network/wireshake-tcp-3handshakes-1.2.png" alt="第一次握手的 Options 选项" width="100%" height="100%">
<p><strong>最大段大小（MSS - Maximum Segment Size）</strong>：</p>
<ul>
<li>作用：告知对方本端可以接收的最大 TCP 段大小（不包括 IP 和 TCP 首部）。</li>
<li>格式：<code>kind 2</code>, <code>length 4</code>, 后跟 2 个字节表示的最大段大小（以字节为单位）。</li>
<li>MSS 值主要基于：本地网络的 MTU（Maximum Transmission Unit，最大传输单元）减去 IP 首部和 TCP 首部的大小。</li>
</ul>
<p><strong>窗口扩大因子（Window Scale）</strong>：</p>
<ul>
<li>作用：扩大 TCP 窗口的大小，从而提高高带宽 - 延迟网络的性能。</li>
<li>格式：<code>kind 3</code>, <code>length 3</code>, 后跟 1 个字节的窗口缩放因子。</li>
</ul>
<p><strong>时间戳（Timestamps）</strong>：</p>
<ul>
<li>作用：用于更准确地测量往返时间（RTT）并防止序列号回绕的问题。</li>
<li>格式：<code>kind 8</code>, <code>length 10</code>, 后跟两个 4 字节字段，分别表示发送方的时间戳值（TSval）和接收方最近时间戳回显（TSecr）。</li>
</ul>
<p><strong>选择性确认许可（SACK Permitted）</strong>：</p>
<ul>
<li>作用：通知对方，发送方支持选择性确认（Selective Acknowledgment）。</li>
<li>格式：<code>kind 4</code>, <code>length 2</code>。</li>
</ul>
<p><strong>NOP（No-Operation）</strong>：</p>
<ul>
<li>作用：用于填充和对齐。</li>
<li>格式：<code>kind 1</code>。没有长度字段。</li>
</ul>
<h2 id="第二次握手">第二次握手</h2>
<p>第二次握手：B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1, ACK=1, ack=x+1（抓包中的 ack=1），同时也选择（随机）一个初始的 seq=y（抓包中的 seq=0）。</p>
<img src="../images/computer-network/wireshake-tcp-3handshakes-2.png" alt="服务端进行同步并确认的第二次握手" width="100%" height="100%">
<p>可能你已经注意到，第二次握手服务端填充的 MSS=1200 字节，而第一次握手客户端填充的 MSS=1460 字节。<strong>两个 MSS 值不一样，会如何协商呢</strong>？</p>
<ul>
<li>如果第二次握手的 MSS 小于第一次握手的 MSS：客户端在后续发送的 TCP 段中会遵循服务端 MSS 大小，以避免 IP 分片。</li>
<li>如果第二次握手的 MSS 大于第一次握手的 MSS：客户端在后续发送的 TCP 段中依然会使用自己的 MSS 大小，而不会超过自己声明的 MSS。</li>
</ul>
<p>不同的 MSS 值在 TCP 三次握手的第一次和第二次握手中是正常的，并且反映了双方位于不同网络环境中的实际情况。最终，客户端将根据服务端的 MSS 设置其发送 TCP 段的大小，从而 <strong> 确保最大限度地利用网络资源并避免不必要的 IP 分片</strong>。</p>
<h2 id="第三次握手">第三次握手</h2>
<p>第三次握手：A 收到 B 的连接确认报文后，还要向 B 发出确认，ACK=1, ack=y+1, seq=x+1。</p>
<img src="../images/computer-network/wireshake-tcp-3handshakes-3.png" alt="客户端进行确认的第三次握手" width="100%" height="100%">
<p>完成三次握手后，就建立了 TCP 连接，之后就可以正常的进行数据发送和接收。</p>
<p>可以发现，第三次握手已经没有 Options 选项了，但是有实际的 Window size value。<strong>那么，实际的窗口大小是如何计算的呢</strong>？</p>
<p>在 TCP 三次握手过程中，窗口扩大因子（Window Scale）用于扩大 TCP 窗口的大小，从而支持更高的吞吐量。窗口扩大因子是在第一次和第二次握手过程中协商的，过程如下：</p>
<ol>
<li>第一次握手（客户端发送 SYN 报文）：客户端声明其希望使用的窗口扩大因子。例如，窗口扩大因子是 8。</li>
<li>第二次握手（服务端发送 SYN-ACK 报文）：服务端同样声明其希望使用的窗口扩大因子。例如，窗口扩大因子也是 8。</li>
</ol>
<p>当双方同意使用窗口扩大因子以后，广义（实际）的 TCP 窗口大小将以左移的方式进行扩展。</p>
<p>窗口大小的实际缩放值取决于 TCP 首部中的 Window size 字段和协商的窗口扩大因子，其计算公式如下：<code>ActualWindowSize = WindowSize &lt;&lt; WindowScale</code>，<strong>即接收方将以发送方报文的 WindowSize 左移发送方 WindowScale 来计算发送方的实际窗口大小（可以确定对方的接收能力）</strong>。</p>
<p>TCP 协议规定，双方将使用各自保存的对方的窗口扩大因子来解释对方的窗口大小。也就是说，<strong>数据传输中，每一方用对方声明的因子来计算对方接收窗口的大小</strong>。</p>
<p>那么，双方将对方的扩大因子存储在哪里？在三次握手完成后，双方会使用存储在 TCP 控制块（TCP Control Block, TCB）中的对方窗口扩大因子来计算对方报告的窗口大小。</p>
<h2 id="原始数据包">原始数据包</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 第一次握手</span><br><span class="line">0000   70 57 bf e6 ea 00 a0 36 9f a0 c8 77 08 00 45 00</span><br><span class="line">0010   00 34 5e ac 40 00 80 06 00 00 0a 31 e0 05 ac fd</span><br><span class="line">0020   76 5e f8 ed 01 bb e3 27 ce b7 00 00 00 00 80 02</span><br><span class="line">0030   20 00 94 f5 00 00 02 04 05 b4 01 03 03 08 01 01</span><br><span class="line">0040   04 02</span><br><span class="line"></span><br><span class="line">// 第二次握手</span><br><span class="line">0000   a0 36 9f a0 c8 77 70 57 bf e6 ea 00 08 00 45 00</span><br><span class="line">0010   00 34 00 00 40 00 6e 06 ff 31 ac fd 76 5e 0a 31</span><br><span class="line">0020   e0 05 01 bb f8 ed f2 08 33 13 e3 27 ce b8 80 12</span><br><span class="line">0030   ff ff 90 cc 00 00 02 04 04 b0 01 01 04 02 01 03</span><br><span class="line">0040   03 08</span><br><span class="line"></span><br><span class="line">// 第三次握手</span><br><span class="line">0000   70 57 bf e6 ea 00 a0 36 9f a0 c8 77 08 00 45 00</span><br><span class="line">0010   00 28 5e ad 40 00 80 06 00 00 0a 31 e0 05 ac fd</span><br><span class="line">0020   76 5e f8 ed 01 bb e3 27 ce b8 f2 08 33 14 50 10</span><br><span class="line">0030   01 01 cf 9a 00 00</span><br></pre></td></tr></table></figure>
<h1 id="TCP 四次挥手抓包分析">TCP 四次挥手抓包分析</h1>
<p>当完成数据发送后，双方要结束对话，由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后，就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭，故需要经过四次挥手完成 TCP 的断开。</p>
<h2 id="Wireshark 抓包 -v2">Wireshark 抓包</h2>
<p>首先开启 Wireshark 监听网口，然后访问某个博客，输入简单的过滤规则进行过滤，首先找到四次挥手报文，标志就是 FIN。这里只有三个包，是服务端的第二次挥手与第三次挥手合并为一个包发送了。</p>
<img src="../images/computer-network/wireshake-tcp-4waves-0.png" alt="Wireshake 抓包的 TCP 四次挥手报文" width="100%" height="100%">
<p>可以看到，源和目的端分别发送了一个 FIN 报文，加上接下来的 ACK 报文，就是四次挥手结束连接。</p>
<h2 id="第一次挥手">第一次挥手</h2>
<p>A 发送连接释放报文，FIN=1。</p>
<img src="../images/computer-network/wireshake-tcp-4waves-1.png" alt="客户端连接释放的第一次挥手" width="100%" height="100%">
<h2 id="第二三次挥手">第二三次挥手</h2>
<p>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据，但是 A 不能向 B 发送数据。</p>
<p>当 B 不再需要连接时，发送连接释放报文，FIN=1。</p>
<img src="../images/computer-network/wireshake-tcp-4waves-3.png" alt="服务端连接释放的第二三次挥手" width="100%" height="100%">
<p>现实场景中，第二次和第三次挥手（ACK 和 FIN）有时会在同一个报文中完成。这种情况下，服务端会同时确认客户端的 FIN，同时也发送自己的 FIN 给客户端。这种合并操作可以减少报文的数量，从而提高网络效率。</p>
<h2 id="第四次挥手">第四次挥手</h2>
<p>B 收到 A 的确认后释放连接，ACK=1。</p>
<img src="../images/computer-network/wireshake-tcp-4waves-4.png" alt="客户端确认后释放的第四次挥手" width="100%" height="100%">
<p>至此，对 TCP 三次挥手和四次挥手的报文分析完成。</p>
<h2 id="原始数据包 -v2">原始数据包</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 第一次挥手</span><br><span class="line">0000   70 57 bf e6 ea 00 a0 36 9f a0 c8 77 08 00 45 00</span><br><span class="line">0010   00 28 51 e7 40 00 80 06 00 00 0a 31 e0 05 8e fb</span><br><span class="line">0020   af 65 c9 36 01 bb 01 43 c8 08 76 be cc 37 50 11</span><br><span class="line">0030   01 00 af 08 00 00</span><br><span class="line"></span><br><span class="line">// 第二、三次挥手</span><br><span class="line">0000   a0 36 9f a0 c8 77 70 57 bf e6 ea 00 08 00 45 00</span><br><span class="line">0010   00 28 50 3f 00 00 6e 06 d3 f9 8e fb af 65 0a 31</span><br><span class="line">0020   e0 05 01 bb c9 36 76 be cc 37 01 43 c8 09 50 11</span><br><span class="line">0030   01 1b ae ec 00 00 00 00 24 ad 4a 14</span><br><span class="line"></span><br><span class="line">// 第四次挥手</span><br><span class="line">0000   70 57 bf e6 ea 00 a0 36 9f a0 c8 77 08 00 45 00</span><br><span class="line">0010   00 28 51 fa 40 00 80 06 00 00 0a 31 e0 05 8e fb</span><br><span class="line">0020   af 65 c9 36 01 bb 01 43 c8 09 76 be cc 38 50 10</span><br><span class="line">0030   01 00 af 07 00 00</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://blog.csdn.net/dingdingdodo/article/details/107225020">https://blog.csdn.net/dingdingdodo/article/details/107225020</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>内核线程的创建</title>
    <url>/posts/240927202500.html</url>
    <content><![CDATA[<span id="more"></span>
]]></content>
      <categories>
        <category>系统编程</category>
      </categories>
      <tags>
        <tag>内核线程</tag>
      </tags>
  </entry>
  <entry>
    <title>项目模块解析之命令行</title>
    <url>/posts/230101120000.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，这个密码看着不太对，请再试试。" data-whm="抱歉，这个文章不能被校验，不过您还是能看看解密后的内容。">
  <script id="hbeData" type="hbeData" data-hmacdigest="50e7b91de6eaa7a0e9e742f3592e7d59190d02ec02214d046bdf992a25b104c5">ee45252aa344cdae5545fd3c2d76f286337ea17cd3a157608508cbce8cb00c6dab20dec7577b2b2cda15eadf84a47d2fca8a791f329d312746c743af9d8c020bafa218b43cd2cbf7f8918f292fd42402586be565438ffbad3ea687a891372160ac018f90be9bead0a21197a6f9ff1d4f64545eb04aba16e6c1abd43fb1987435ab85e97c15a81c0746bdb81a98cd1924ad4a079856b09f263a3ebaa238fe5182e6c7da7f4b01963d373d7bf6b168a46ba1322fd54723f52278a9b7cd77081e1563f74d1b5024658d6d42b3856c6ec4bdc76fbc2239a0ac86129d79e6d5c17d53faf46bb54bf8b125d964a3c70e9edebc43dc2bde5bccb81ceb46009aa181d297ab2f52c1f527ce3e52f5930eb2e97e0f79850534748309921fcedcdc3bfa795788249aa1689c3dd350df2ebbea36f10cad17f9fe4013809a76a9f4d60135b2f097b72458fa232a502d49013d955418a2f565fd65e15247d81f0d0d5676fe5b3f6e44f736210d5b4243aef1fa7b12a78597a3828bbfab28b1fae60b1f2a6b0d1d5fb51307a2cf77f40d8dbd914d6b4fef7aab7b482eca2f3a81cce0704fce3034fd0920520740d02b1df3e6abbef5b818515548a9656ca462e34820cf2c693a1ac577c635d228ef79b32e99f16f6e4456af8752937f1456bb9c5ef077291167c27fea2b0cf47c0ea9b310d8ba07f2df42c5f88549a6060d7198dc6511fe9a89e072de3824120d3d40053abc041c2b5f805b77d2e6dc149324683084354775d753d4019697f79b787c56c49802ed0d099dd10edc9d6076df8f88c2b62f0b58d364432c705d86cf3e153cdcd4713f5661dbf711f0ae8805ca3b3636c02ca16d6e550f872a45a6bfb792453750799dcc616a7b71fe104fa58c4c2462743cb5735d4f</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-xray">
      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好，这里需要密码。</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程编程之锁与原子操作</title>
    <url>/posts/230921094127.html</url>
    <content><![CDATA[<h2 id="常见锁介绍">常见锁介绍</h2>
<p>在 C 语言中，常见的用于解决多线程访问数据的锁包括互斥锁、读写锁、条件变量、自旋锁、屏蔽等。</p>
<span id="more"></span>
<ol>
<li>
<p>互斥锁（mutex）：互斥锁是一种 <strong> 最基本的锁机制 </strong>，用于<strong> 保护共享资源</strong>，防止多个线程同时访问和修改同一个资源。当一个线程持有了互斥锁后，其他线程需要等待该线程释放锁之后才能访问共享资源。</p>
</li>
<li>
<p>读写锁（read-write lock）：读写锁是一种 <strong> 特殊的锁机制 </strong>，它<strong> 允许多个线程同时读取共享资源，但是只允许一个线程写入共享资源</strong>。这种锁可以提高读取操作的并发度，同时保证写入操作的正确性和一致性。如果一个线程获取了写锁，其他线程就必须等待它释放锁后才能继续访问；如果一个线程获取了读锁，其他线程也可以获取读锁并访问资源。</p>
</li>
<li>
<p>条件变量（condition variable）：条件变量是一种 <strong> 用于线程之间通信的同步机制 </strong>，它允许线程在某个条件成立时才能继续执行，通常与互斥锁一起使用。<strong> 当条件变量不满足时，线程释放互斥锁并等待条件变量被唤醒（通过另一个线程来唤醒条件变量）；当条件变量满足时，通知线程重新获取互斥锁并继续执行</strong>。</p>
</li>
<li>
<p>自旋锁（spinlock）：自旋锁是一种 <strong> 忙等待锁机制 </strong>，当一个线程尝试获取锁时，如果锁已经被占用，它会一直循环等待直到锁被释放。<strong> 自旋锁适用于锁的持有时间很短的情况</strong>，因为长时间占用 CPU 会影响系统性能。</p>
</li>
<li>
<p>屏障（barrier）：屏障是一种 <strong> 用于多线程协同的同步机制 </strong>，它允许多个线程在某个点上等待，直到所有线程都到达该点后再继续执行。<strong> 屏障通常用于一组线程需要在某个点进行同步操作 </strong> 的情况，例如多线程排序算法。</p>
</li>
</ol>
<p>综上，互斥锁、读写锁、自旋锁用于实现 <strong> 互斥访问 </strong>，条件变量、屏障用于实现<strong> 同步</strong>。</p>
<h2 id="互斥锁">互斥锁</h2>
<p><strong>互斥锁原理 </strong>：互斥锁属于 sleep-waiting 类型的锁。例如，在一个双核的机器上有两个线程（线程 A 和线程 B），它们分别运行在 Core0 和 Core1 上。假设线程 A 想要通过 pthread_mutex_lock 操作去得到一个临界区的锁，而此时这个锁正被线程 B 所持有，那么线程 A 就会<strong> 被阻塞 </strong>，Core0 会在此时进行上下文切换（Context Switch）将线程 A<strong> 置于等待队列中</strong>，此时 Core0 就可以运行其它的任务而不必进行忙等待。</p>
<p><strong>互斥锁实现</strong>：通常使用了操作系统提供的原子操作或者硬件提供的锁机制，保证锁的正确性和高效性。</p>
<p><strong>互斥锁两种类型</strong>：递归锁和非递归锁。递归锁允许同一线程在不释放锁的情况下多次获取锁，而非递归锁不允许这种情况发生。</p>
<p><strong>互斥锁使用场景</strong>：因互斥锁会引起线程的切换，效率较低；使用互斥锁会引起线程阻塞等待，不会一直占用着 CPU。因此，当锁的内容较多、切换不频繁时，建议使用互斥锁。</p>
<p><strong>互斥锁使用笔记</strong>：互斥锁的使用非常简单，主要包括以下几个步骤：</p>
<ul>
<li>定义互斥锁变量，一般使用 <code>pthread_mutex_t</code> 类型；</li>
<li>在需要保护的代码段前调用 <code>pthread_mutex_lock</code> 函数获取锁；</li>
<li>在代码段执行完毕后调用 <code>pthread_mutex_unlock</code> 函数释放锁；</li>
<li>释放锁之后其他线程就可以获取锁并访问共享资源。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化互斥锁</span></span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在需要保护的代码块前加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="comment">// 访问共享资源</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 访问完毕后解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在使用完后销毁</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br></pre></td></tr></table></figure>
<h2 id="读写锁">读写锁</h2>
<p><strong>读写锁的实现</strong>：通常使用了计数器和互斥锁等机制，通过控制读写访问的次数和顺序来保证数据的正确性和一致性。</p>
<p><strong>读写锁使用笔记</strong>：读写锁的使用也非常简单，主要包括以下几个步骤：</p>
<ul>
<li>定义读写锁变量，一般使用 <code>pthread_rwlock_t</code> 类型；</li>
<li>在需要读取共享资源的代码段前调用 <code>pthread_rwlock_rdlock</code> 函数获取读锁；</li>
<li>在需要写入共享资源的代码段前调用 <code>pthread_rwlock_wrlock</code> 函数获取写锁；</li>
<li>在代码段执行完毕后调用 <code>pthread_rwlock_unlock</code> 函数释放锁；</li>
<li>释放锁之后其他线程就可以获取锁并访问共享资源。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock = PTHREAD_RWLOCK_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化读写锁</span></span><br><span class="line">pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在需要读取共享资源的代码块前加读锁</span></span><br><span class="line">pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line"><span class="comment">// 读取共享资源</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 读取完毕后释放读锁</span></span><br><span class="line">pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在需要写入共享资源的代码块前加写锁</span></span><br><span class="line">pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line"><span class="comment">// 写入共享资源</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 写入完毕后释放写锁</span></span><br><span class="line">pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在使用完读写锁后销毁</span></span><br><span class="line">pthread_rwlock_destroy(&amp;rwlock);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>读锁或写锁都是使用的 <code>rwlock</code> 变量。</p>
</blockquote>
<h2 id="自旋锁">自旋锁</h2>
<p><strong>自旋锁原理 </strong>：自旋锁属于 busy-waiting 类型的锁。例如，在一个双核的机器上有两个线程（线程 A 和线程 B），它们分别运行在 Core0 和 Core1 上。如果线程 A 使用 pthread_spin_lock 操作去请求锁，那么线程 A 就会一直在 Core0 上进行<strong> 忙等待并不停的进行锁请求，直到拿到这个锁为止 </strong>。自旋锁不会引起调用者睡眠，如果自旋锁已经被别的线程持有，调用者就<strong> 一直循环在那里 </strong> 看是否该自旋锁的持有者已经释放了锁。</p>
<p><strong>自旋锁使用场景 </strong>：因为自旋锁不会引起调用者睡眠，所以<strong> 自旋锁的效率远高于互斥锁</strong>。因此，如果锁的内容较少、阻塞的时间较短，使用自旋锁比较好。</p>
<blockquote>
<p>自旋锁只有在内核可抢占式或 SMP 的情况下才真正需要。在单 CPU 且不可抢占式的内核下，自旋锁的操作为空操作。</p>
</blockquote>
<p><strong>自旋锁使用笔记</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义自旋锁</span></span><br><span class="line"><span class="type">pthread_spinlock_t</span> spinlock = PTHREAD_PROCESS_PRIVATE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化自旋锁</span></span><br><span class="line">pthread_spin_init(&amp;spinlock, PTHREAD_PROCESS_PRIVATE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁，如果锁已被其他线程占用，则该函数会一直循环忙等待直到获取到锁</span></span><br><span class="line">pthread_spin_lock(&amp;spinlock);</span><br><span class="line"><span class="comment">// 访问共享资源</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 解锁，使其他线程可以获取锁并访问共享资源</span></span><br><span class="line">pthread_spin_unlock(&amp;spinlock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁自旋锁</span></span><br><span class="line">pthread_spin_destroy(&amp;lock);</span><br></pre></td></tr></table></figure>
<h2 id="条件变量">条件变量</h2>
<p>条件变量（condition variable）：条件变量是一种 <strong> 用于线程之间通信的同步机制 </strong>，它允许线程在某个条件成立时才能继续执行，通常与互斥锁一起使用。<strong> 当条件变量不满足时，线程释放互斥锁并等待条件变量被唤醒（通过另一个线程来唤醒条件变量）；当条件变量满足时，通知线程重新获取互斥锁并继续执行</strong>。</p>
<p><strong>条件变量使用笔记</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义互斥锁和条件变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化互斥锁和条件变量</span></span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (条件不满足预期条件) &#123;</span><br><span class="line">    <span class="comment">// 释放锁，并等待条件变量通知——从而唤醒该线程继续执行</span></span><br><span class="line">    pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件满足（由另一个线程控制），继续执行，访问共享资源</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在使用完后销毁</span></span><br><span class="line">pthread_cond_destroy(&amp;cond);</span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在其他线程中通知条件变量</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="comment">// 访问共享资源</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 解锁后再发送通知</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送条件变量通知其它等待的线程</span></span><br><span class="line">pthread_cond_signal(&amp;cond);</span><br></pre></td></tr></table></figure>
<h3 id="生产消费者同步示例代码">生产消费者同步示例代码</h3>
<p>一个生产者、消费者同步的多线程示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE (4)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> buffer[BUFFER_SIZE];</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;  <span class="comment">// 产品余量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 预期条件是 buffer 不能满（当 buffer 满时为条件不满足预期）</span></span><br><span class="line">        <span class="keyword">while</span> (BUFFER_SIZE == count) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == flag) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;    Buffer full...\n&quot;</span>);</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        buffer[count++] = i++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Producer produced: %d\n&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        pthread_cond_signal(&amp;cond);  <span class="comment">// 释放锁，并通知条件变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 预期条件是 buffer 不能空（当 buffer 空时为条件不满足预期）</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">0</span> == count) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == flag) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;    Buffer empty...\n&quot;</span>);</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> value = buffer[--count];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Consumer consumed: %d\n&quot;</span>, value);</span><br><span class="line"></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        pthread_cond_signal(&amp;cond);  <span class="comment">// 释放锁，并通知条件变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> producer_thread, consumer_thread;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;producer_thread, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;consumer_thread, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(producer_thread, (<span class="type">void</span>**)(<span class="number">0</span>));</span><br><span class="line">    pthread_join(consumer_thread, (<span class="type">void</span>**)(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例代码中，有一个容量为 4 的缓冲区，生产者线程负责往缓冲区中添加数据，消费者线程负责从缓冲区中取出数据：</p>
<ul>
<li>生产者线程通过加锁后检查缓冲区是否已满，如果已满则等待条件变量通知，否则将数据添加到缓冲区，并发送条件变量通知消费者线程。</li>
<li>消费者线程通过加锁后检查缓冲区是否为空，如果为空则等待条件变量通知，否则从缓冲区中取出数据，并发送条件变量通知生产者线程。</li>
</ul>
<p>生产者和消费者线程之间的同步是通过互斥锁和条件变量来实现的。互斥锁用于保护共享资源，条件变量用于线程间的通信和同步。</p>
<p>一种 <em> 可能的 </em> 运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">Consumer consumed: 46584</span><br><span class="line">Consumer consumed: 46583</span><br><span class="line">    Buffer empty...</span><br><span class="line">Producer produced: 46588</span><br><span class="line">Producer produced: 46589</span><br><span class="line">Producer produced: 46590</span><br><span class="line">Consumer consumed: 46589</span><br><span class="line">Consumer consumed: 46588</span><br><span class="line">Consumer consumed: 46587</span><br><span class="line">Producer produced: 46591</span><br><span class="line">Producer produced: 46592</span><br><span class="line">Producer produced: 46593</span><br><span class="line">Producer produced: 46594</span><br><span class="line">    Buffer full...</span><br><span class="line">Consumer consumed: 46593</span><br><span class="line">Consumer consumed: 46592</span><br><span class="line">Consumer consumed: 46591</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="屏障">屏障</h2>
<p>屏障（barrier）：屏障是一种 <strong> 用于多线程协同的同步机制 </strong>，它允许多个线程在某个点上等待，直到所有线程都到达该点后再继续执行。<strong> 屏障通常用于一组线程需要在某个点进行同步操作 </strong> 的情况，例如多线程排序算法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义屏障</span></span><br><span class="line"><span class="type">pthread_barrier_t</span> barrier;</span><br><span class="line"><span class="type">int</span> thread_nums = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化屏障</span></span><br><span class="line">pthread_barrier_init(&amp;barrier, <span class="literal">NULL</span>, thread_nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在每个线程中执行以下代码</span></span><br><span class="line">pthread_barrier_wait(&amp;barrier); <span class="comment">// 等待屏障</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有线程都到达屏障后，继续执行以下代码</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在使用完后销毁</span></span><br><span class="line">pthread_barrier_destroy(&amp;barrier);</span><br></pre></td></tr></table></figure>
<h3 id="屏蔽实现线程同步示例代码">屏蔽实现线程同步示例代码</h3>
<p>下面是一个完整的示例代码，演示了如何使用 pthread 库中的屏障实现线程同步：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义屏障</span></span><br><span class="line"><span class="type">pthread_barrier_t</span> barrier;</span><br><span class="line"><span class="type">int</span> thread_nums = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span>* ptr)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread #%lu, param %d operation\n&quot;</span>, pthread_self(), *(<span class="type">int</span>*)ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待屏障</span></span><br><span class="line">    pthread_barrier_wait(&amp;barrier);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有线程都到达屏障后，继续执行以下代码</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %lu, %d continues after the barrier\n&quot;</span>, pthread_self(), *(<span class="type">int</span>*)ptr);</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[thread_nums];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化屏障</span></span><br><span class="line">    pthread_barrier_init(&amp;barrier, <span class="literal">NULL</span>, thread_nums);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_nums; i++) &#123;</span><br><span class="line">        <span class="type">int</span>* ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        *ptr = i;</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, thread_func, (<span class="type">void</span>*)ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_nums; i++) &#123;</span><br><span class="line">        pthread_join(threads[i], (<span class="type">void</span>**)(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁屏障</span></span><br><span class="line">    pthread_barrier_destroy(&amp;barrier);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在线程函数中，线程首先执行一些操作，然后调用 pthread_barrier_wait 函数等待屏障。<strong>当所有线程都到达屏障后，屏障解除，所有线程继续执行后续的代码</strong>。下面是一种可能的执行结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread #140592591922752, param 1 operation</span><br><span class="line">Thread #140592600315456, param 0 operation</span><br><span class="line">Thread #140592466097728, param 4 operation</span><br><span class="line">Thread #140592583530048, param 2 operation</span><br><span class="line">Thread #140592575137344, param 3 operation</span><br><span class="line">Thread 140592575137344, 3 continues after the barrier</span><br><span class="line">Thread 140592466097728, 4 continues after the barrier</span><br><span class="line">Thread 140592591922752, 1 continues after the barrier</span><br><span class="line">Thread 140592600315456, 0 continues after the barrier</span><br><span class="line">Thread 140592583530048, 2 continues after the barrier</span><br></pre></td></tr></table></figure>
<h2 id="原子操作">原子操作</h2>
<p>所谓原子操作，就是该操作绝不会在执行完毕前被任何其他任务或事件打断。也就是说，它是 <strong> 最小的执行单位</strong>，不可能有比它更小的执行单位。因此，这里的原子实际是使用了物理学里的物质微粒的概念。</p>
<p>原子操作需要硬件的支持，因此是架构相关的，其 API 和原子类型的定义都定义在内核源码树的 <code>include/asm/atomic.h</code> 文件中，<strong>它们都使用汇编语言实现，因为 C 语言并不能实现这样的操作</strong>。</p>
<p>原子操作主要用于实现资源计数，很多引用计数（Reference Count, refcnt）就是通过原子操作实现的。</p>
<h2 id="总结分析">总结分析</h2>
<p>互斥锁是 sleep-waiting 类型的锁：与自旋锁相比它需要消耗大量的系统资源来建立锁，但是在线程被阻塞期间，它不消耗 CPU 资源。</p>
<ol>
<li>当线程被阻塞等待时，线程的调度状态从就绪态到阻塞态，线程被加入等待线程队列；</li>
<li>当锁可用时，在获取锁之前，线程会被从等待队列取出，并将其调度状态切换会运行态。</li>
</ol>
<p>互斥锁适用于那些可能会阻塞很长时间的场景：</p>
<ul>
<li>临界区有 IO 操作</li>
<li>临界区代码复杂或者循环量大</li>
<li>临界区竞争非常激烈</li>
<li>单核处理器</li>
</ul>
<p>自旋锁是 busy-waiting 类型的锁：它只需要消耗很少的资源来建立锁。但当线程被阻塞时，它会一直重复检查锁是否可用了。也就是说，自旋锁处于等待状态时它会一直消耗 CPU 时间。因此，自旋锁适用于那些仅需要阻塞很短时间的场景。</p>
]]></content>
      <categories>
        <category>多线程编程</category>
      </categories>
      <tags>
        <tag>锁</tag>
        <tag>原子操作</tag>
      </tags>
  </entry>
  <entry>
    <title>多进程相关练习</title>
    <url>/posts/240424200123.html</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="练习 sigaction">练习 sigaction</h1>
<p>题目：使用 fork() 编写一个程序。子进程应打印 “hello”，父进程应打印 “goodbye”。你应该尝试确保子进程始终先打印。你能否不在父进程调用 wait() 而做到这一点呢？</p>
<p>方法一：</p>
<p>策略：可以使用 sleep 函数让父进程休眠，等待子进程先打印，父进程再打印即可。</p>
<p>缺点：sleep 多久合适？如果要求父进程要在子进程打印完后，随即让父进程打印呢？</p>
<p>方法二：</p>
<p>策略：使用信号，子进程打印后发出信号，父进程接收到信号后，执行打印操作。</p>
<p>方法二实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">parent_handler</span><span class="params">(<span class="type">int</span> signal)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (signal == SIGCHLD) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;byebye\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_handler</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);       <span class="comment">/* clear the signal set */</span></span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;                <span class="comment">/* enables setting sa_handler, not sa_action */</span></span><br><span class="line">    sa.sa_handler = parent_handler; <span class="comment">/* specify a handler */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* register the handler */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == sigaction(SIGCHLD, &amp;sa, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> cpid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cpid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cpid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">        _exit(EXIT_SUCCESS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        set_handler();</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123; sleep(<span class="number">1</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子进程中的 <code>_exit(0)</code> 的作用？</p>
<p>当父进程完成等待时，父进程将通过调用常规退出函数来终止。相比之下，子进程通过调用 _exit 变体来终止，这会快速跟踪终止通知。实际上，子进程会告诉系统：「尽快」通知父进程，自己已经终止。</p>
<h1 id="练习 exec">练习 exec</h1>
<p>编写一个调用 fork() 的程序，然后调用 execl() 来运行程序 <code>/bin/ls</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> cpid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cpid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cpid == <span class="number">0</span>) &#123;</span><br><span class="line">        execl(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>);  <span class="comment">// 目录, 程序, 参数, 结束标记</span></span><br><span class="line">        <span class="comment">/* 如果 execl 执行成功，以下代码不会被执行 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;execl error\n&quot;</span>);</span><br><span class="line">        _exit(EXIT_FAILURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子进程调用 execl() 成功执行指定程序后，execl() 后面的代码 <strong> 不会再被执行</strong>。</p>
<h1 id="练习 wait">练习 wait</h1>
<p>现在编写一个程序，在父进程中使用 wait()，等待子进程完成。wait() 返回什么？如果在子进程中使用 wait() 会发生什么？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> cpid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cpid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cpid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process (PID: %d)\n&quot;</span>, getpid());</span><br><span class="line">        _exit(EXIT_SUCCESS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* test: move to child process, start */</span></span><br><span class="line">        <span class="type">int</span> wstatus;</span><br><span class="line">        <span class="type">pid_t</span> wc = wait(&amp;wstatus);  <span class="comment">// wait code</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent process (PID: %d), wc: %d, wstatus: %d\n&quot;</span>, getpid(), wc, wstatus);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 通过系统定义的宏，来检查子进程的退出状态是什么 */</span></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(wstatus)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;exited, status=%d\n&quot;</span>, WEXITSTATUS(wstatus));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (WIFSIGNALED(wstatus)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;killed by signal %d\n&quot;</span>, WTERMSIG(wstatus));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (WIFSTOPPED(wstatus)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;stopped by signal %d\n&quot;</span>, WSTOPSIG(wstatus));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (WIFCONTINUED(wstatus)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;continued\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* test: move to child process, end */</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，整形指针 <code>wstatus</code> 用于存储子进程的返回状态——至于这些状态到底是哪个，可以通过系统定义的一些宏来检查。父进程中调用的 <code>wait()</code> 的返回值，正常情况下为子进程的 PID。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">% ./a.out</span><br><span class="line">child process (PID: 669052)</span><br><span class="line">parent process (PID: 669051), <span class="built_in">wc</span>: 669052, wstatus: 256</span><br><span class="line">exited, status=1</span><br><span class="line">%</span><br></pre></td></tr></table></figure>
<p>如果将父进程中的代码块移动到子进程中，从打印可以看出，子进程异常退出，调用 <code>wait()</code> 失败（返回值为 -1）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">% ./a.out</span><br><span class="line">child process (PID: 669073)</span><br><span class="line">parent process (PID: 669073), <span class="built_in">wc</span>: -1, wstatus: 0 <span class="comment"># parent should be child</span></span><br><span class="line">exited, status=0</span><br><span class="line">%</span><br></pre></td></tr></table></figure>
<h1 id="关闭标准输出">关闭标准输出</h1>
<p>题目：编写一个程序，创建一个子进程，然后在子进程中关闭标准输出（STDOUT_FILENO）。如果子进程在关闭描述符后调用 printf() 来打印一些输出，会发生什么？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> cpid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cpid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cpid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process (PID: %d) is running.\n&quot;</span>, getpid());</span><br><span class="line">        close(STDOUT_FILENO);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;some messages after close standard output.\n&quot;</span>);</span><br><span class="line">        _exit(EXIT_SUCCESS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在关闭标准输出之前，子进程会正常打印内容到屏幕。当关闭了标准输出后，printf() 函数会尝试将消息写入已关闭的文件描述符，但这样的操作会失败，因为标准输出已经不可用了。因此，printf() 函数 <strong> 不会在屏幕上打印任何消息</strong>。</p>
<h1 id="标准输出连接到标准输入">标准输出连接到标准输入</h1>
<p>题目：编写一个程序，创建两个子进程，并使用 pipe() 系统调用，将其中一个进程的标准输出连接到另一个进程的标准输入。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];       <span class="comment">// 0-read, 1-write</span></span><br><span class="line">    <span class="type">pid_t</span> cpid1, cpid2;  <span class="comment">// 假设子进程 1 用于写，子进程 2 用于读</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个匿名管道</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == pipe(pipefd)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cpid1 = fork();</span><br><span class="line">    <span class="keyword">if</span> (cpid1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cpid1 == <span class="number">0</span>) &#123;  <span class="comment">// 子进程 1</span></span><br><span class="line">        <span class="comment">// 子进程 1 关闭未使用的读端</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将标准输出重定向到管道的写端</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == dup2(pipefd[<span class="number">1</span>], STDOUT_FILENO)) &#123;</span><br><span class="line">            perror(<span class="string">&quot;dup2&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭多余的文件描述符</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">&quot;execlp&quot;</span>);</span><br><span class="line">        _exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    cpid2 = fork();</span><br><span class="line">    <span class="keyword">if</span> (cpid2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cpid2 == <span class="number">0</span>) &#123;  <span class="comment">// 子进程 2</span></span><br><span class="line">        <span class="comment">// 子进程 2 关闭未使用的写端</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将标准输入重定向到管道的读端</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == dup2(pipefd[<span class="number">0</span>], STDIN_FILENO)) &#123;</span><br><span class="line">            perror(<span class="string">&quot;dup2&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭多余的文件描述符</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从标准输入（重定向的管道读端）读取数据，直到 EOF</span></span><br><span class="line">        <span class="type">char</span> buf;</span><br><span class="line">        <span class="type">ssize_t</span> bytes_read;</span><br><span class="line">        <span class="keyword">while</span> ((bytes_read = read(STDIN_FILENO, &amp;buf, <span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">-1</span> == write(STDOUT_FILENO, &amp;buf, bytes_read)) &#123;</span><br><span class="line">                perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _exit(EXIT_SUCCESS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 关闭父进程中创建的管道的两个端口</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待两个子进程完成</span></span><br><span class="line">        waitpid(cpid1, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        waitpid(cpid2, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本程序首先 fork 一个子进程 1，然后在父进程中再 fork 一个子进程 2。</p>
<img src="../images/others/pipe-redirect.png" alt="管道重定向数据流向" width="80%" height="80%">
<p>子进程 1：</p>
<ol>
<li>首先，关闭不使用的读端，<strong>将标准输出重定向到管道的写端</strong>；</li>
<li>然后，因为后面将调用新程序，管道的写端不会再被使用，这里应提前关闭多余的写端；</li>
<li>最后，调用 execlp 执行 ls 命令（进程的地址空间将会被替换为新程序的地址空间）。</li>
</ol>
<p>子进程 2：</p>
<ol>
<li>首先，关闭不使用的写端，<strong>将标准输入重定向到管道的读端</strong>；</li>
<li>然后，因为重定向的原因，可以提前关闭多余的读端，从标准输入读取数据（也可以先不关闭，从管道读端读取数据，读完后再关闭，但不符合本题目的要求）；</li>
<li>最后，从标准输入读取数据流，写到标准输出，直到字节流结束。</li>
</ol>
<p>父进程：</p>
<ol>
<li>直接关闭不使用的管道读端和写端；</li>
<li>等待两个子进程的退出。</li>
</ol>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">% ./a.out</span><br><span class="line">总计 40</span><br><span class="line">-rwxr-xr-x 1 root root 16360  4 月 26 10:24 a.out</span><br><span class="line">-rw-r--r-- 1 root root   500  4 月 24 19:57 q1.c</span><br><span class="line">-rw-r--r-- 1 root root   961  4 月 25 10:23 q2.c</span><br><span class="line">%</span><br></pre></td></tr></table></figure>
<h1 id="重定向到文件">重定向到文件</h1>
<p>题目：编写一个程序，创建一个子进程，并使用 pipe() 系统调用，将子进程的写入管道的内容重定向到父进程指定的文件中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];  <span class="comment">// 0-read, 1-write</span></span><br><span class="line">    <span class="type">pid_t</span> cpid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建一个匿名管道 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == pipe(pipefd)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cpid = fork();</span><br><span class="line">    <span class="keyword">if</span> (cpid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 子进程往管道写入数据 */</span></span><br><span class="line">    <span class="keyword">if</span> (cpid == <span class="number">0</span>) &#123;</span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>* msg[] = &#123;</span><br><span class="line">            <span class="string">&quot;child process: write some bytes...\n&quot;</span>, </span><br><span class="line">            <span class="string">&quot;child process: write some bytes, again...\n&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> msg_len = <span class="keyword">sizeof</span>(msg) / <span class="keyword">sizeof</span>(msg[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 往管道写入一些内容</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; msg_len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">-1</span> == write(pipefd[<span class="number">1</span>], msg[i], <span class="built_in">strlen</span>(msg[i]))) &#123;</span><br><span class="line">                perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        _exit(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父进程读取管道的数据，并重定向到文件 */</span></span><br><span class="line">    close(pipefd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开一个文件，作为读取管道数据的重定向文件</span></span><br><span class="line">    <span class="type">int</span> redirect_fd = open(<span class="string">&quot;example.txt&quot;</span>, O_RDWR | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == redirect_fd) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf;</span><br><span class="line">    <span class="type">ssize_t</span> bytes_read;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从管道读取数据，并写入到重定向的文件</span></span><br><span class="line">    <span class="keyword">while</span> ((bytes_read = read(pipefd[<span class="number">0</span>], &amp;buf, <span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == write(redirect_fd, &amp;buf, bytes_read)) &#123;</span><br><span class="line">            perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(redirect_fd);</span><br><span class="line">    close(pipefd[<span class="number">0</span>]);</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序，创建一个匿名管道，并 fork 出一个子进程。在子进程中，负责往管道内写入一些数据；在父进程中，负责读取管道中的数据，并将数据写入指定的文件（重定向到文件）。</p>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">% ./a.out</span><br><span class="line">% <span class="built_in">cat</span> example.txt</span><br><span class="line">child process: write some bytes...</span><br><span class="line">child process: write some bytes, again...</span><br><span class="line">%</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
        <category>多进程编程</category>
      </categories>
      <tags>
        <tag>多进程编程</tag>
      </tags>
  </entry>
  <entry>
    <title>工具之 gcc 编译过程分解</title>
    <url>/posts/240207180410.html</url>
    <content><![CDATA[<p>GCC（GNU Compiler Collection）是一个开源的编程语言编译器集合，支持多种编程语言，包括 C、C++、Objective-C、Fortran、Ada 等。它是许多开发者和程序员首选的编译器，因为它的功能强大、稳定，并且跨平台。</p>
<p>这篇文章主要介绍 GCC (GNU Compiler Collection)，以及使用 GCC 编译 C 代码的分解过程。</p>
<span id="more"></span>
<h1 id="C-include">C include</h1>
<p>在 C 语言程序中，会引用各种 <code>#include</code> 头文件（.h），它是如何被引用的？</p>
<p>当我们 <code>#include</code> 头文件时，如 <code>#include &lt;stdio.h&gt;</code>，其实是告诉了 C 预处理器（C preprocessor, cpp）去指定路径 <code>/usr/include/</code> 查找特定的头文件，并将其直接插入到代码中的 <code>#include</code> 位置。</p>
<h1 id="GCC 编译分解">GCC 编译分解</h1>
<p>我么以下面的程序分解 GCC 编译的过程，文件名 <code>hw.c</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* header files go up here */</span></span><br><span class="line"><span class="comment">/* note that C comments are enclosed within a slash and</span></span><br><span class="line"><span class="comment">a star, and may wrap over lines */</span></span><br><span class="line"><span class="comment">// two slashes work too (and may be preferred)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// main returns an integer</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">/* printf is our output function;</span></span><br><span class="line"><span class="comment">    by default, writes to standard out */</span></span><br><span class="line">    <span class="comment">/* printf returns an integer, but we ignore that */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* return 0 to indicate all went well */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GCC 并不是一个真正的编译器，而是一个称为「编译器驱动（compiler driver）」的程序，因此它协调了编译的许多步骤（一般为四到五步），如下图。</p>
<img src="../images/compiler-tool/gcc.png" alt="GCC 编译过程分解" width="100%" height="100%">
<h2 id="预处理">预处理</h2>
<p>预处理指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o hw.i -E hw.c</span><br></pre></td></tr></table></figure>
<p>预处理某些指令，如 <code>#define</code>、<code>#include</code>、注释，并将其 <strong> 直接 </strong> 插入到代码中。例如，下面的代码段是对 <code>hw.c</code> 进行预处理后产生的可读文件 <code>hw.i</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略最前面的 N 行...</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">funlockfile</span> <span class="params">(FILE *__stream)</span> __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span>;</span><br><span class="line"># <span class="number">885</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __uflow (FILE *);</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __overflow (FILE *, <span class="type">int</span>);</span><br><span class="line"># <span class="number">902</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"># <span class="number">6</span> <span class="string">&quot;hw.c&quot;</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="number">7</span> <span class="string">&quot;hw.c&quot;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编译">编译</h2>
<p>编译指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o hw.s -S hw.c</span><br><span class="line">gcc -o hw.s -S hw.i # 这个也行</span><br></pre></td></tr></table></figure>
<p>编译过后的文件称为汇编文件（代码）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        .file   &quot;hw.c&quot;</span><br><span class="line">        .text</span><br><span class="line">        .section        .rodata</span><br><span class="line">.LC0:</span><br><span class="line">        .string &quot;hello, world&quot;</span><br><span class="line">        .text</span><br><span class="line">        .globl  main</span><br><span class="line">        .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">        .cfi_startproc</span><br><span class="line">        endbr64</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        .cfi_def_cfa_offset 16</span><br><span class="line">        .cfi_offset 6, -16</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        .cfi_def_cfa_register 6</span><br><span class="line">        subq    $16, %rsp</span><br><span class="line">        movl    %edi, -4(%rbp)</span><br><span class="line">        movq    %rsi, -16(%rbp)</span><br><span class="line">        leaq    .LC0(%rip), %rax</span><br><span class="line">        movq    %rax, %rdi</span><br><span class="line">        call    puts@PLT</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        leave</span><br><span class="line">        .cfi_def_cfa 7, 8</span><br><span class="line">        ret</span><br><span class="line">        .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">        .size   main, .-main</span><br><span class="line">        .ident  &quot;GCC: (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0&quot;</span><br><span class="line">        .section        .note.GNU-stack,&quot;&quot;,@progbits</span><br><span class="line">        .section        .note.gnu.property,&quot;a&quot;</span><br><span class="line">        .align 8</span><br><span class="line">        .long   1f - 0f</span><br><span class="line">        .long   4f - 1f</span><br><span class="line">        .long   5</span><br><span class="line">0:</span><br><span class="line">        .string &quot;GNU&quot;</span><br><span class="line">1:</span><br><span class="line">        .align 8</span><br><span class="line">        .long   0xc0000002</span><br><span class="line">        .long   3f - 2f</span><br><span class="line">2:</span><br><span class="line">        .long   0x3</span><br><span class="line">3:</span><br><span class="line">        .align 8</span><br><span class="line">4:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>chatGPT 这样说：</p>
<p>这段汇编代码是一个简单的 C 程序的汇编代码示例。下面是对代码中的一些关键部分的解释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.file   &quot;hw.c&quot;</span><br></pre></td></tr></table></figure>
<p>这一行指定了源文件的名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        .section        .rodata</span><br><span class="line">.LC0:</span><br><span class="line">        .string &quot;hello, world&quot;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个只读数据段（.rodata），并在其中定义了一个字符串常量（hello, world）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        .globl  main</span><br><span class="line">        .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br></pre></td></tr></table></figure>
<p>这里定义了一个全局符号（main），表示这是程序的入口点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pushq   %rbp</span><br><span class="line">movq    %rsp, %rbp</span><br></pre></td></tr></table></figure>
<p>这是函数开头的标准操作，用于保存和设置栈帧。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leaq    .LC0(%rip), %rax</span><br><span class="line">movq    %rax, %rdi</span><br><span class="line">call    puts@PLT</span><br></pre></td></tr></table></figure>
<p>这里将字符串常量的地址加载到寄存器 rax 中，并将其作为参数传递给 puts 函数，以便在屏幕上打印出来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl    $0, %eax</span><br><span class="line">leave</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>这些指令用于返回程序的退出码，并清理栈帧。</p>
<p>这些是这段汇编代码的主要部分。它基本上是将字符串 &quot;hello, world&quot; 打印到屏幕上，然后退出程序。</p>
<h2 id="汇编">汇编</h2>
<p>汇编指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o hw.o -c hw.s</span><br><span class="line">gcc -o hw.o -c hw.c # 这个也行</span><br></pre></td></tr></table></figure>
<p>汇编文件汇编后的文件类型是一个二进制文件，编译过程中生成目标文件，该目标文件打开是一个乱码。</p>
<h2 id="链接">链接</h2>
<p>链接指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o hw hw.o</span><br><span class="line">gcc -o hw.o hw.c # 这个也行</span><br></pre></td></tr></table></figure>
<p>组合所有目标代码，并转换为可执行文件。使用 <code>file hw</code> 可查看关于可执行文件的描述。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">root@Standard-PC-i440FX-PIIX-1996:/home/xxx# file hw</span><br><span class="line">hw: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, \</span><br><span class="line">interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=190dc558406e49249a5b73b4b7513b4ab8e13385, for GNU/Linux 3.2.0, not stripped</span><br></pre></td></tr></table></figure>
<p>chatGPT 说，这是一个关于一个可执行文件的描述。让我来解释一下各个部分的含义：</p>
<ul>
<li><code>ELF</code>：代表可执行和可链接格式 (Executable and Linkable Format)，是一种用于执行文件和目标文件的标准文件格式。</li>
<li><code>64-bit LSB</code>：代表这是一个 64 位的可执行文件。</li>
<li><code>pie</code>：代表这是一个位置无关可执行文件 (Position Independent Executable)，这意味着它可以在内存中的任何位置加载并执行。</li>
<li><code>x86-64</code>：代表这是一个 x86-64 架构的可执行文件，也就是 64 位的 x86 架构。</li>
<li><code>version 1 (SYSV)</code>：代表这个可执行文件遵循 System V ABI 的第一个版本。</li>
<li><code>dynamically linked</code>：代表这个可执行文件是动态链接的，它依赖于其他共享库文件来运行。</li>
<li><code>interpreter /lib64/ld-linux-x86-64.so.2</code>：代表在运行该可执行文件时，系统将使用 <code>/lib64/ld-linux-x86-64.so.2</code> 这个动态链接器来加载和解释它。</li>
<li><code>BuildID[sha1]=190...</code>：代表这个可执行文件的构建标识符，它是通过计算文件内容的 SHA-1 哈希来生成的，可以用于唯一标识该文件。</li>
<li><code>for GNU/Linux 3.2.0</code>：代表这个可执行文件是为 GNU/Linux 操作系统的 3.2.0 版本编译的。</li>
<li><code>not stripped</code>：代表这个可执行文件没有被去除符号信息，也就是说，它保留了调试和符号表等信息，可以用于调试和分析。</li>
</ul>
<h1 id="GCC 参数总结">GCC 参数总结</h1>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>-std=&lt;standard&gt;</td>
<td>假设输入源文件符合 &lt;standard&gt;，如 c99。</td>
</tr>
<tr>
<td>-E</td>
<td>只预处理，不编译、汇编或链接。</td>
</tr>
<tr>
<td>-S</td>
<td>只编译，不汇编或链接。</td>
</tr>
<tr>
<td>-c</td>
<td>编译和汇编，但不链接。</td>
</tr>
<tr>
<td>-o &lt;file&gt;</td>
<td>将输出放入 &lt;file&gt; 中。</td>
</tr>
<tr>
<td>-O&lt;digit&gt;</td>
<td>打开优化，等级为 1~3，等级过高优化效果越好，但编译时间越长。</td>
</tr>
<tr>
<td>-Wall</td>
<td>给出更好的警告。</td>
</tr>
<tr>
<td>-g</td>
<td>启用 gdb 调试。</td>
</tr>
<tr>
<td>-pie</td>
<td>创建一个动态链接的位置无关可执行文件。</td>
</tr>
<tr>
<td>-shared</td>
<td>创建一个共享库。</td>
</tr>
</tbody>
</table>
<h1 id="多个文件一起编译">多个文件一起编译</h1>
<p>第一次生成可以使用以下命令，进行一起编译、链接，生成 hw 可执行文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c hw.c helper.c</span><br><span class="line">gcc -o hw hw.o helper.o</span><br></pre></td></tr></table></figure>
<p>后续如果修改部分文件的代码，则 <strong> 仅对修改的源文件编译生成目标文件</strong>，最后一起对目标文件进行链接，更快（特别是大项目）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c hw.c  # 修改过的文件</span><br><span class="line">gcc -o hw hw.o helper.o</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考资料：<br>
1：<a href="https://blog.csdn.net/weixin_39258979/article/details/101023337">https://blog.csdn.net/weixin_39258979/article/details/101023337</a><br>
2：<a href="https://pages.cs.wisc.edu/~remzi/OSTEP/lab-tutorial.pdf">Operating Systems: Three Easy Pieces</a><br>
3：<a href="https://www.cnblogs.com/bobwuming/articles/14931042.html">https://www.cnblogs.com/bobwuming/articles/14931042.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>工具之 gdb 调试入门</title>
    <url>/posts/240312184132.html</url>
    <content><![CDATA[<p>The GNU Debugger (GDB) is an awesome tool for debugging your programs written in C, C++, FORTRAN (please don’t), and plenty of other compiled languages. You can use it by running gdb from the command line.</p>
<span id="more"></span>


	<div class="row">
    <embed src="/pdf/gdb_notes.pdf" width="100%" height="550" type="application/pdf">
	</div>



]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>GDB</tag>
      </tags>
  </entry>
  <entry>
    <title>异或运算</title>
    <url>/posts/231014105311.html</url>
    <content><![CDATA[<p>异或是一个数学运算符，英文为 exclusive OR，缩写成 XOR。异或的数学符号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⨁</mo></mrow><annotation encoding="application/x-tex">\bigoplus</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span></span></span></span>，计算机符号为「XOR」。如果二进制数 a 和 b 的同位置的值不相同，则该位置的结果为 1，反之为 0。</p>
<span id="more"></span>
<h2 id="异或也叫半加运算">异或也叫半加运算</h2>
<p>异或也叫半加运算，其运算法则相当于 <strong> 不带进位的二进制加法</strong>，如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>⨁</mo><mn>0</mn><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo>⨁</mo><mn>0</mn><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo>⨁</mo><mn>1</mn><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>⨁</mo><mn>1</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">0 \bigoplus 0=0, 1 \bigoplus 0=1, 0 \bigoplus 1=1, 1 \bigoplus 1=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，这些法则与加法是相同的，如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>+</mo><mn>0</mn><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo>+</mo><mn>0</mn><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">0+0=0, 1+0=1, 0+1=1, 1+1=(1)0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mord">0</span></span></span></span>，只是不带进位，所以异或常被认作不进位加法。</p>
<h2 id="异或运算性质">异或运算性质</h2>
<ol>
<li>归零律：任何数与自身异或都等于 0，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⨁</mo><mi>a</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a \bigoplus a=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></li>
<li>恒等律：任何数与 0 异或都等于其本身，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⨁</mo><mn>0</mn><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a \bigoplus 0=a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span></li>
<li>交换律：即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⨁</mo><mi>b</mi><mo>=</mo><mi>b</mi><mo>⨁</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a \bigoplus b = b \bigoplus a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">a</span></span></span></span></li>
<li>结合律：即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⨁</mo><mi>b</mi><mo>⨁</mo><mi>c</mi><mo>=</mo><mi>a</mi><mo>⨁</mo><mo stretchy="false">(</mo><mi>b</mi><mo>⨁</mo><mi>c</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>a</mi><mo>⨁</mo><mi>b</mi><mo stretchy="false">)</mo><mo>⨁</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a \bigoplus b \bigoplus c = a \bigoplus (b \bigoplus c) = (a \bigoplus b) \bigoplus c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span></span></span></span></li>
<li>自反性：对给定的数 b，用同样的运算因子 a 作两次异或运算后仍得到 b 本身，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⨁</mo><mi>b</mi><mo>⨁</mo><mi>a</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \bigoplus b \bigoplus a = b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span></li>
</ol>
<h2 id="异或运算应用">异或运算应用</h2>
<h3 id="交换两个数">交换两个数</h3>
<p>若需要交换两个 <strong> 整形变量 </strong> 的值，除了借用中间变量进行交换外，还可以利用异或的自反性，仅使用两个变量进行交换，如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> &#123;</span><br><span class="line">    (*a) = (*a)^(*b);  <span class="comment">// a1 = a^b</span></span><br><span class="line">    (*b) = (*a)^(*b);  <span class="comment">// b = (a^b)^b = a</span></span><br><span class="line">    (*a) = (*a)^(*b);  <span class="comment">// a = (a^b)^a = b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="找出重复的数">找出重复的数</h3>
<p>假设一个集合中有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个数，范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, n-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，其中有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n - 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 个互不相同的数，有一个数重复一次，设计一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间复杂度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 空间复杂度的算法，找出这个数。</p>
<p>推导：</p>
<ol>
<li>假设不包含重复的第二个数的所有数的异或的结果为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>⨁</mo><mn>2</mn><mo>⨁</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>⨁</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">1 \bigoplus2 \bigoplus ... \bigoplus (n-1) = T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>；</li>
<li>那么，包含第二个重复的数的所有数的异或结果为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>⨁</mo><mn>2</mn><mo>⨁</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>⨁</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>⨁</mo><mi>x</mi><mo>=</mo><mi>T</mi><mo>⨁</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">1 \bigoplus2 \bigoplus ... \bigoplus (n-1) \bigoplus x = T \bigoplus x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span></span></span></span>。</li>
</ol>
<p>通过自反性可以得出这个重复的数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>⨁</mo><mo stretchy="false">(</mo><mi>T</mi><mo>⨁</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">T \bigoplus (T \bigoplus x) = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>。这里利用的异或的自反性，同时需要具备一个前置条件，就是：我们需要知道集合中都出现过哪些数，这样才能求出序号 1 的结果。</p>
<p>例如，下面的代码中，数组 <code>nums[n]</code> 存储着 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, n-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 区间中的所有数，但只有一个数是重复的数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">find_duplicate</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  <span class="comment">// 所有数异或</span></span><br><span class="line">        res ^= nums[i];  <span class="comment">// T^x</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;  <span class="comment">// 所有不重复的数异或</span></span><br><span class="line">        res ^= i;  <span class="comment">// res := (T^x)^T</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="找出不成对的一个数">找出不成对的一个数</h3>
<p><a href="https://leetcode.cn/problems/single-number">LeetCode 习题</a>：一个数组存放若干整数，一个数出现奇数次，其余数均出现偶数次，找出这个出现奇数次的数。</p>
<p>思路：使用异或运算的归零律、恒等律和交换律，将数组中的所有数异或求结果——所有出现偶数次的数的异或的结果是 0；再异或上那个出现奇数次的数，最终结果就是 0 异或 x，即那个不成对的数 x。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        res ^= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="找出不成对的两个数">找出不成对的两个数</h3>
<p><a href="https://leetcode.cn/problems/single-number-iii">LeetCode 习题</a>：一个数组存放若干整数，两个不同的数出现了奇数次，其余数均出现偶数次，找出这两个出现奇数次的数。</p>
<p>假设这两个出现奇数次的数为 x 和 y：</p>
<ol>
<li>按照上述方法，将所有数做异或，计算出 x 和 y 或后的结果 z；</li>
<li>在异或中，同位置的值不同则结果为 1。基于此，可以找到 z 的二进制中最右侧的那个 1（假设 x 的二进制在同位置为 1），然后丢弃左侧的二进制数；</li>
<li>再次遍历数组，跳过那个同位置不为 1 的数（即 y），这就等价于数组是「成对的数中有且仅有一个不成对的数」，即找到了一个不成对的数（这里为 x）；</li>
<li>另一个数 y 便是：<code>x^(x^y)</code>，即 <code>x^z</code>。</li>
</ol>
<blockquote>
<p>序号 2 中，当然也可能跳过成对的数，但没关系，因为这个数不会跳过一个、保留一个，就当少了一对成对的数，不会对找出那个不成对的数有影响。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *ans = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">long</span> xor = <span class="number">0</span>, lsb = <span class="number">0</span>;  <span class="comment">// 防止溢出风险</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        xor ^= <span class="number">1LL</span> * nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    lsb = xor &amp; (~xor + <span class="number">1</span>);</span><br><span class="line">    ans[<span class="number">0</span>] = <span class="number">0</span>, ans[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nums[i] &amp; lsb) != <span class="number">0</span>) &#123;</span><br><span class="line">            ans[<span class="number">0</span>] ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[<span class="number">1</span>] = xor ^ ans[<span class="number">0</span>];</span><br><span class="line">    (*returnSize) = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是如何计算上述序号 2 中的那个二进制数的呢？</p>
<p>一个整数 <code>x</code> 与<code>(~x+1)</code>进行按位与运算的结果是将 <code>x</code> 的最右边的 1 保留下来，其他位都置为 0。这个操作通常用于获取 <code>x</code> 的最右边的 1 所代表的值，也可以称为获取 <code>x</code> 的最低有效位（LSB）。<br>
举个例子，假设 <code>x</code> 的二进制表示为 10110100，那么 <code>~x</code> 的二进制表示为 01001011，然后再加上 1，得到 <code>(~x+1)</code> 的二进制表示为 01001100。最后，将 <code>x</code> 与<code>(~x+1)</code>进行按位与运算，得到的结果就是 00000100，即 <code>x</code> 的最右边的 1 所代表的值为 4。</p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://www.cnblogs.com/jasonkoo/articles/2760411.html">https://www.cnblogs.com/jasonkoo/articles/2760411.html</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>异或运算</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter10.1 信号量与管程</title>
    <url>/posts/240113115605.html</url>
    <content><![CDATA[<p>锁（Lock）可以实现对临界区的互斥访问，但多道程序设计仅考虑互斥问题是不够的。除了互斥，还需要考虑同步，以及在临界区内允许多个进程（或线程）进入临界区执行的情况。为了实现这些目标，需要借助更高层的同步互斥的语义，并利用硬件实现的原子操作来实现。</p>
<p>本文介绍信号量（Semaphore），包括二元信号量和一般（计数）信号量。信号量可以实现多个进程（或线程）之间的互斥和同步操作，并允许多个进程（或线程）进入临界区执行。同时，介绍了一种更高级的抽象——管程（Monitor），它可以缓解信号量机制在编写并发程序上的复杂性、简化并发编程。管程是一种程序结构，包含了一组共享变量和操作集合，用于控制对共享资源的访问。</p>
<span id="more"></span>
<img src="../images/os-kernel/chapter10/lock.png" alt="多程序理念" width="70%" height="70%">
<h1 id="信号量（Semaphore）">信号量（Semaphore）</h1>
<h2 id="信号量操作">信号量操作</h2>
<p>信号量（Semaphore）是一种抽象数据结构，用于实现多个进程（或线程）之间的同步和互斥操作的机制。它是一个整型变量（<code>sem</code>），可以用来控制对共享资源的访问。</p>
<p>一个整型变量（<code>sem</code>），具有 2 个原子操作：</p>
<ul>
<li><code>P()</code> 操作：<code>sem</code> 减 1，如果 <code>sem &lt; 0</code>，等待，否则继续；</li>
<li><code>V()</code> 操作：<code>sem</code> 加 1，如果 <code>sem &lt;= 0</code>，唤醒一个等待的进程 P。</li>
</ul>
<p>信号量类似铁路，初始化 2 个资源控制信号灯，进入临界区的进程执行 <code>P()</code> 操作，当临界区已经有 2 个进程时，信号量不足，变为红灯。当再来的进程想要进入临界区时，只能等待，直到某一个进程离开了临界区，变为绿灯，此时进程执行 <code>V()</code> 操作，并将等待的进程唤醒，进入临界区。</p>
<img src="../images/os-kernel/chapter10/semaphore-vivid.gif" alt="信号量比喻" width="80%" height="80%">
<blockquote>
<p>信号量由 dijkstra 在 20 世纪 60 年代提出。<code>P()</code>操作是荷兰语中的 Proberen，意为“尝试”或“试图获取资源”；<code>V()</code>操作是荷兰语中的 Verhogen，意为“增加”或“释放资源”。</p>
</blockquote>
<h2 id="信号量特征">信号量特征</h2>
<ul>
<li>信号量是整数；</li>
<li>信号量是被保护的变量：初始化完成后，唯一改变一个信号量的值的办法是通过 <code>P(), V()</code> 操作（操作必须是原子）；</li>
<li><code>P()</code> 操作能够阻塞、<code>V()</code> 操作不会阻塞；</li>
<li>我们假定信号量是公平的：
<ul>
<li>如果 <code>V()</code> 被无限频繁调用（在同一个信号量上），那么没有线程会被阻塞在 <code>P()</code> 操作上；</li>
<li>在实践中，FIFO 经常被使用，也就是先被阻塞的线程，先出。</li>
</ul>
</li>
</ul>
<blockquote>
<p>自旋锁（Spinlock）能否是 FIFO 类型？不能，锁已被其他线程占用时，该线程会一直自旋（忙等待）直到锁被释放。</p>
</blockquote>
<h2 id="信号量两种类型">信号量两种类型</h2>
<ul>
<li>二进制信号量：值可以是 0 或 1；</li>
<li>一般 / 计数信号量：值可取任意非负值。</li>
</ul>
<details>
  <summary>可以通过使用一个类型的信号量来实现另一个类型的信号量（两者相互实现）。</summary>
<ol>
<li>
<p>使用二进制信号量实现计数信号量：<br>
可以使用一个二进制信号量作为互斥锁（类似于互斥量），用于控制对计数信号量的访问。每当线程要进行计数操作时，需要先获取互斥锁，然后进行计数操作，最后释放互斥锁。这样可以确保每次只有一个线程可以访问计数信号量，保证计数的正确性和一致性。</p>
</li>
<li>
<p>使用计数信号量实现二进制信号量：<br>
可以使用一个计数信号量来实现二进制信号量。计数信号量的初始值为 1，表示资源可用。当线程需要访问二进制信号量时，需要先尝试获取计数信号量。如果计数信号量的值为 1，表示资源可用，线程可以继续执行。如果计数信号量的值为 0，表示资源不可用，线程需要等待。当资源被释放时，线程释放计数信号量，将其值设置为 1，表示资源可用。</p>
</li>
</ol>
</details>
<h2 id="信号量两种用途">信号量两种用途</h2>
<ul>
<li>互斥；</li>
<li>条件同步（如调度约束：一个线程等待另一个线程的事情发生）。</li>
</ul>
<h1 id="信号量使用">信号量使用</h1>
<h2 id="用二进制信号量实现互斥">用二进制信号量实现互斥</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mutex = <span class="keyword">new</span> <span class="built_in">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">mutex-&gt;<span class="built_in">P</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Critical Section; */</span></span><br><span class="line"></span><br><span class="line">mutex-&gt;<span class="built_in">V</span>();</span><br></pre></td></tr></table></figure>
<p>必须成对使用 <code>P(), V()</code> 操作：</p>
<ul>
<li><code>P()</code> 操作保证互斥访问临界资源；</li>
<li><code>V()</code> 操作在使用后释放临界资源；</li>
<li><code>P(), V()</code> 操作不能次序错误、重复或遗漏。</li>
</ul>
<h2 id="用二进制信号量实现调度约束（同步）">用二进制信号量实现调度约束（同步）</h2>
<p><code>P()</code> 等待，<code>V()</code> 发出信号后，两个线程实现同步：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">condition = <span class="keyword">new</span> <span class="built_in">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* thread A */</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">condition-&gt;<span class="built_in">P</span>();</span><br><span class="line"><span class="comment">// （阻塞等待，直到其它线程执行了 `V()` 操作）...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* thread B */</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">condition-&gt;<span class="built_in">V</span>();</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h2 id="生产者 - 消费者问题（线程同步）">生产者 - 消费者问题（线程同步）</h2>
<h3 id="问题描述与分析">问题描述与分析</h3>
<p>生产者 - 消费者问题 <strong> 是一个线程同步的问题</strong>，其中一个线程等待另一个线程完成某个任务。这个问题通常用于模拟生产者和消费者的情景。</p>
<p>例如，在有界缓冲区的生产者 - 消费者问题中：</p>
<ul>
<li>一个或多个生产者生成数据并将其放入缓冲区；</li>
<li>单个消费者每次从缓冲区中取出数据；</li>
<li>在任何给定的时刻，<strong>只有一个 </strong> 生产者或消费者能够访问该缓冲区。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ----------      --------      ----------</span><br><span class="line">| Producer | -&gt; | Buffer | -&gt; | Consumer |</span><br><span class="line"> ----------      --------      ----------</span><br></pre></td></tr></table></figure>
<p>在这种情况下，缓冲区有一个固定的大小，生产者在缓冲区已满时需要等待，而消费者在缓冲区为空时需要等待。</p>
<p>互斥（锁机制）是不够解决这个问题的，因为 <strong> 生产者和消费者需要在某些条件下等待对方的操作完成 </strong>。因此，需要使用其他<strong> 同步机制 </strong> 来协调生产者和消费者的操作。</p>
<h3 id="实现关键与实现方式">实现关键与实现方式</h3>
<p>实现生产者 - 消费者问题的关键点（正确定要求）：</p>
<ul>
<li>在任何一个时刻，只能有一个线程操作缓冲区（互斥约束）；</li>
<li>当缓冲区为空时，消费者必须等待生产者（调度，同步约束）；</li>
<li>当缓冲区为满时，生产者必须等待消费者（调度，同步约束）。</li>
</ul>
<p>实现方式：上述每个约束使用一个单独的信号量：</p>
<ul>
<li>二进制信号量 <code>mutex</code>，初始化为 1，实现互斥访问；</li>
<li>一般信号量 <code>emptySem</code>，初始化为 n，实现缓冲区空时的同步约束；</li>
<li>一般信号量 <code>fullSem</code>，初始化为 0，实现缓冲区满时的同步约束。</li>
</ul>
<h3 id="实现代码">实现代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BoundedBuffer</span> &#123;</span><br><span class="line">    mutex = <span class="keyword">new</span> <span class="built_in">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line">    emptySem = <span class="keyword">new</span> <span class="built_in">Semaphore</span>(n); <span class="comment">// 初始化时，空的程度为〇，每次消费数据后，空的程度提升</span></span><br><span class="line">    fullSem = <span class="keyword">new</span> <span class="built_in">Semaphore</span>(<span class="number">0</span>);  <span class="comment">// 初始化时，满的程度为〇，每次生产数据后，满的程度提升</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者 添加数据</span></span><br><span class="line">BoundedBuffer::<span class="built_in">Deposit</span>(c) &#123;</span><br><span class="line">    emptySem-&gt;<span class="built_in">P</span>(); <span class="comment">// 生产前，空信号量减一</span></span><br><span class="line">    mutex-&gt;<span class="built_in">P</span>();</span><br><span class="line">    <span class="comment">// Add `c` to the buffer;</span></span><br><span class="line">    mutex-&gt;<span class="built_in">V</span>();</span><br><span class="line">    fullSem-&gt;<span class="built_in">V</span>(); <span class="comment">// 生产后，满信号量加一</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者 取出数据</span></span><br><span class="line">BoundedBuffer::<span class="built_in">Remove</span>(c) &#123;</span><br><span class="line">    fullSem-&gt;<span class="built_in">P</span>(); <span class="comment">// 消费前，满信号量减一</span></span><br><span class="line">    mutex-&gt;<span class="built_in">P</span>();</span><br><span class="line">    <span class="comment">// Remove `c` from buffer; </span></span><br><span class="line">    mutex-&gt;<span class="built_in">V</span>();</span><br><span class="line">    emptySem-&gt;<span class="built_in">V</span>(); <span class="comment">// 消费后，空信号量加一</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，当生产者添加了 n 个数据后，缓冲区满。此时再想添加数据时，<code>emptySem</code> 会小于 0，需要等待。同样地，当消费者取出了一些数据后，缓冲区空。此时再想取出数据时，<code>fullSem</code> 会小于 0，需要等待。缓冲区不满、也不空时，可以互斥的添加或取出数据，无需等待。</p>
<h1 id="信号量实现">信号量实现</h1>
<p>使用硬件原语：</p>
<ul>
<li>禁用中断</li>
<li>原子指令（Test-And-Set）</li>
</ul>
<p>类似锁：如禁用中断</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Semaphore</span> &#123;</span><br><span class="line">    <span class="type">int</span> sem;</span><br><span class="line">    WaitQueue q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Semaphore::<span class="built_in">P</span>() &#123;</span><br><span class="line">    --sem;</span><br><span class="line">    <span class="keyword">if</span> (sem &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Add this thread `t` to queue `q`;</span></span><br><span class="line">        <span class="built_in">block</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Semaphore::<span class="built_in">V</span>() &#123;</span><br><span class="line">    ++sem;</span><br><span class="line">    <span class="keyword">if</span> (sem &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Remove a thread `t` from queue `q`;</span></span><br><span class="line">        <span class="built_in">wakeup</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="管程（monitor）与条件变量">管程（monitor）与条件变量</h1>
<h2 id="管程定义">管程定义</h2>
<p>管程（monitor）是一种程序结构，结构内的多个子程序形成的多个工作线程互斥访问共享资源——这些共享资源一般是硬件或一群变量。管程实现了 <strong> 在一个时间点，最多只有一个线程在执行管程的某个子程序</strong>。与那些通过修改数据结构实现互斥访问的并发程序设计相比，管程实现很大程度上简化了程序设计。（来自 Wikipedia 的定义）</p>
<p>管程的目的是：将互斥和条件同步的 <strong> 关注点分离 </strong> 开来。</p>
<ul>
<li>互斥指的是确保在同一时间只有一个进程可以访问共享资源，而条件同步指的是进程之间通过条件变量进行等待和唤醒的机制。</li>
</ul>
<blockquote>
<p>关注点分离（Separation of Concerns, SoC）是将计算机程序分隔为不同部分的设计原则，每一部分会有各自的关注焦点。</p>
</blockquote>
<p>管程主要包含的两个组件：</p>
<ul>
<li>一个锁：用于指定临界区，实现对共享资源的互斥访问；</li>
<li>零或多个条件变量：等待 / 通知信号量，用于管程并发访问共享数据。</li>
</ul>
<p>实现管程的一般方法包括 <strong> 收集相关共享数据和定义方法来访问这些共享数据</strong>：</p>
<ul>
<li>共享数据通常包括需要互斥访问的临界区和条件变量等。</li>
<li>方法定义了对共享数据的操作，用于实现互斥访问和条件等待 / 通知的功能。</li>
</ul>
<p>通过将共享数据和操作封装在一个对象或模块中，可以有效地实现对并发访问的同步控制。</p>
<blockquote>
<p>概括之，管程包含一系列共享变量，以及针对这些变量的一系列操作函数（方法），这些变量和函数被封装在一个对象或模块中，便形成了管程的程序结构。</p>
</blockquote>
<h2 id="管程设计与实现">管程设计与实现</h2>
<img src="../images/os-kernel/chapter10/monitor-arch.png" alt="管程结构" width="70%" height="70%">
<p>如上图所示，多个线程都想进入管程访问共享资源，这就需要一个 entry queue 等待队列，等待获取管程的锁。当某个线程取得锁后，可以进入管程的临界区，并执行管程管理的一些列操作，如函数 <code>Wait(x)</code> 和 <code>Signal(x)</code>。但当在执行某一个操作时，函数可能对共享变量的需求得不到满足，<strong>这时线程会先释放锁 </strong>，并将自身挂到相应的条件变量关联的等待队列上，直到条件变量得到满足后，<strong> 重新获得锁</strong>，并执行相应的操作。</p>
<p>为了完成上述动作，需要实现如下操作：</p>
<p>锁 Lock：</p>
<ul>
<li><code>Lock::Acquire()</code>：等待…直到锁可用，然后抢占锁；</li>
<li><code>Lock::Release()</code>：释放锁，唤醒等待者（若有）。</li>
</ul>
<p>条件变量 Condition variable：</p>
<ul>
<li>允许线程在等待状态下进入临界区，而且可以在某个时刻原子释放锁并进入睡眠。</li>
<li><code>Wait()</code> 操作用于释放锁、进入睡眠并重新获得锁。</li>
<li><code>Signal()</code>操作用于唤醒等待者（或者使用 <code>broadcast()</code> 操作唤醒所有等待者）。</li>
</ul>
<blockquote>
<p>条件变量“允许线程在等待状态下（让其他线程）进入临界区”的意思是，当线程需要等待某个条件满足时，它可以调用条件变量的 <code>Wait()</code> 操作来暂时释放锁并进入等待状态。在等待期间，<strong>其他线程 </strong> 可以获得锁并访问临界区。当条件满足时，等待的线程会被唤醒，并重新获得锁，然后可以进入临界区执行相应的操作。</p>
<p>这样做的好处是，在等待状态下，线程不会占用系统资源，同时其他线程有机会进入临界区执行任务，提高了系统的并发性能。当条件满足时，被唤醒的线程可以安全地继续执行，而不会出现竞争条件和数据不一致的问题。</p>
</blockquote>
<p><strong>条件变量的实现</strong>：</p>
<ul>
<li>需要维护每个条件队列；</li>
<li>需要实现线程的条件等待 <code>Wait()</code> 和通知<code>Signal()</code>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">    <span class="type">int</span> numWaiting = <span class="number">0</span>;</span><br><span class="line">    WaitQueue q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Condition::<span class="built_in">Wait</span>(lock) &#123;</span><br><span class="line">    numWaiting++;</span><br><span class="line">    <span class="comment">// Add this thread `t` to `q`;</span></span><br><span class="line">    <span class="built_in">release</span>(lock);</span><br><span class="line">    <span class="built_in">schedule</span>(); <span class="comment">// 运行态 -&gt; 等待态 need mutex</span></span><br><span class="line">    <span class="built_in">require</span>(lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Condition::<span class="built_in">Signal</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (numWaiting &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Remove a thread `t` from `q`;</span></span><br><span class="line">        <span class="built_in">wakeup</span>(t); <span class="comment">// 等待态 -&gt; 就绪态 need mutex</span></span><br><span class="line">        numWaiting--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>上面的 <code>Wait(lock)</code> 函数，为什么是先释放锁、再获取锁呢？</strong></p>
<p>当在执行某一个操作时，函数可能对共享变量的需求得不到满足，<strong>这时线程会先释放锁，以便其它线程可以获取锁并执行</strong>。如果不释放锁，那所有线程都将无法获取锁，而持有锁的线程也无法满足条件继续执行并释放锁，最终会造成系统崩溃。</p>
<h2 id="管程解决生产者 - 消费者问题">管程解决生产者 - 消费者问题</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BoundedBuffer</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    Lock lock;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// buffer 为空</span></span><br><span class="line">    Condition notFull, notEmpty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BoundedBuffer::<span class="built_in">Deposit</span>(c) &#123;</span><br><span class="line">    lock-&gt;<span class="built_in">Acquire</span>(); <span class="comment">// 管程的定义：只有一个线程能够进入管程，所以将锁放在函数的最开始和最末尾，而不像信号量那样紧贴着临界区</span></span><br><span class="line">    <span class="keyword">while</span> (count == n) &#123;</span><br><span class="line">        notFull.<span class="built_in">Wait</span>(&amp;lock); <span class="comment">// 内部释放刚刚获取的锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Add `c` to the buffer;</span></span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.<span class="built_in">Signal</span>();</span><br><span class="line">    lock-&gt;<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BoundedBuffer::<span class="built_in">Remove</span>(c) &#123;</span><br><span class="line">    lock-&gt;<span class="built_in">Acquire</span>();</span><br><span class="line">    <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        notEmpty.<span class="built_in">Wait</span>(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Remove `c` from buffer;</span></span><br><span class="line">    count--;</span><br><span class="line">    notFull.<span class="built_in">Signal</span>();</span><br><span class="line">    lock-&gt;<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Deposit(c)</code> 和 <code>Remove(c)</code> 中的 <code>while</code> 可以改成 <code>if</code> 吗？</p>
</blockquote>
<h2 id="管程条件变量的释放处理方式">管程条件变量的释放处理方式</h2>
<p>把上面的 <code>Deposit(c)</code> 和 <code>Remove(c)</code> 分别看做下图中的线程 T1 和 T2，管程条件变量的释放后的处理方式有两种：Hoare-style 和 Hoare-style。</p>
<img src="../images/os-kernel/chapter10/hansen-vs-hoare.png" alt="管程条件变量的释放处理方式" width="80%" height="80%">
<p>Hansen-style 的<code>Deposit(c)</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Hansen_style::<span class="built_in">Deposit</span>(c) &#123;</span><br><span class="line">    lock-&gt;<span class="built_in">Acquire</span>();</span><br><span class="line">    <span class="keyword">while</span> (count == n) &#123; <span class="comment">// using `while` for Hansen-style</span></span><br><span class="line">        notFull.<span class="built_in">Wait</span>(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Add thing...</span></span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.<span class="built_in">Signal</span>();</span><br><span class="line">    lock-&gt;<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Hansen-style 管程：条件变量的释放仅仅是一个提示、还需要 <strong> 重新检查 </strong> 条件，所以用 <code>while</code> 反复检查。</p>
<p>Hoare-style 的<code>Deposit(c)</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Hoare_style::<span class="built_in">Deposit</span>(c) &#123;</span><br><span class="line">    lock-&gt;<span class="built_in">Acquire</span>();</span><br><span class="line">    <span class="keyword">if</span> (count == n) &#123; <span class="comment">// using `if` for Hoare-style</span></span><br><span class="line">        notFull.<span class="built_in">Wait</span>(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Add thing...</span></span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.<span class="built_in">Signal</span>();</span><br><span class="line">    lock-&gt;<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Hoare-style 管程：条件变量释放的同时表示放弃管程访问、释放后条件变量的状态可用，所以用 <code>if</code>。</p>
<ul>
<li>Hansen-style 管程：高效。</li>
<li>Hoare-style 管程：低效。</li>
</ul>
<p>在 Hansen-style 管程中，使用 <code>while</code> 循环来防止虚假唤醒（spurious wakeups）。虚假唤醒指的是当一个线程被唤醒时，条件可能并没有满足，但唤醒仍然发生。因此，使用 <code>while</code> 循环来检查条件是否满足，如果条件不满足，则线程继续等待。<br>
在 Hoare-style 管程中，使用 <code>if</code> 语句来等待条件满足。Hoare-style 管程假设条件变量的等待队列中只有满足条件的线程，因此使用 <code>if</code> 语句即可。虽然在 Hoare-style 管程中也可能发生虚假唤醒，但它并不对此进行特别处理。（由 GPT 生成）</p>
<p>现在，这张图多了两种种并发编程的实现，即信号量和「锁 + 条件变量」的管程：<br>
<img src="../images/os-kernel/chapter10/concurrent-summary.png" alt="多程序理念" width="80%" height="80%"></p>
<blockquote>
<p>参考资料：<br>
1：<a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a><br>
2：<a href="https://blog.csdn.net/weixin_53407527/article/details/125207305">https://blog.csdn.net/weixin_53407527/article/details/125207305</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>信号量</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>信号量</tag>
        <tag>管程</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter11 死锁</title>
    <url>/posts/240310162231.html</url>
    <content><![CDATA[<p>本文讨论了操作系统中的死锁问题，探讨了死锁发生的条件和系统模型。通过资源类型、进程资源分配图和死锁特征的介绍，阐述了死锁产生的原因和可能性。最后强调了死锁发生的必要条件，并指出即使满足这些条件也不一定导致死锁的发生。</p>
<span id="more"></span>
<h1 id="死锁问题">死锁问题</h1>
<p>一组阻塞的进程持有一种资源，并等待获取另一个进程所占有的一个资源。这导致它们无法继续执行，进入一种僵局状态。</p>
<blockquote>
<p>例如，系统有 2 个磁带驱动器，进程 P1 和进程 P2 各持有一个，但都需要另一个。</p>
</blockquote>
<p>为什么会发生死锁？由于进程的并发执行抢占资源。</p>
<h1 id="系统模型">系统模型</h1>
<p>资源类型 R<sub>1</sub>，R<sub>2</sub>，…，R<sub>m</sub></p>
<p>每个资源类型 R<sub>i</sub> 有 W<sub>i</sub> 个实例</p>
<p>每个进程可使用的资源如下：</p>
<ul>
<li>require/get &lt;= free resource</li>
<li>use/hold &lt;= requested/used resource</li>
<li>release &lt;= free resource</li>
</ul>
<p><strong>可重复使用的资源</strong></p>
<ul>
<li>在一个时间只能有一个进程使用，且不能被删除</li>
<li>进程获得资源，后来释放由其他进程重用</li>
<li>处理器、I/O 通道、主和副存储器、设备和数据结构（如文件，数据库和信号量）</li>
<li>如果每个进程拥有一个资源并请求其他资源，死锁可能发生</li>
</ul>
<p><strong>使用资源</strong></p>
<ul>
<li>创建和销毁</li>
<li>在 I/O 缓存区的中断、信号、消息、信息</li>
<li>如果接收消息阻塞可能会发生死锁</li>
<li>可能少见的组合事件会引起死锁</li>
</ul>
<p><strong>资源分配图</strong></p>
<p>一组顶点 V 和边 E 的集合，V 有两种类型、E 有两种指向：</p>
<ul>
<li>系统中的所有进程集合：P = {P<sub>1</sub>, P<sub>2</sub>, …, P<sub>n</sub>}</li>
<li>系统中的所有资源类型集合：R = {R<sub>1</sub>, R<sub>2</sub>, …, R<sub>m</sub>}</li>
<li>进程请求资源：P<sub>i</sub> -&gt; R<sub>j</sub></li>
<li>分配或保持资源给进程：R<sub>j</sub> -&gt; P<sub>i</sub></li>
</ul>
<img src="../images/os-kernel/chapter11/deadlock-1.png" alt="进程资源分配图" width="80%" height="80%">
<p>资源分配实例：无死锁、有环有死锁、有环无死锁</p>
<img src="../images/os-kernel/chapter11/deadlock-2.png" alt="资源分配图实例" width="80%" height="80%">
<p><strong>基本情况</strong></p>
<p>如果图中不包含循环：没有死锁。</p>
<p>如果图中包含循环：</p>
<ul>
<li>如果每个资源类只有一个实例，那么死锁。</li>
<li>如果每个资源类有多个实例，<strong>可能 </strong> 死锁。</li>
</ul>
<blockquote>
<p>无环一定不会死锁，但有环不一定死锁，即有环是死锁的必要不充分条件。</p>
</blockquote>
<h1 id="死锁特征">死锁特征</h1>
<p>死锁出现时，一定出现以下四个条件，但出现以下四个条件不一定发生死锁：</p>
<ol>
<li><strong>互斥</strong>：在一个时间只能有一个进程使用资源。</li>
<li><strong>持有并等待</strong>：进程保持 至少一个资源 正在等待 获取其他进程持有的额外资源。</li>
<li><strong>无抢占</strong>：一个资源只能被进程自己释放（进程已经完成了它的任务之后）。</li>
<li><strong>循环等待 </strong>：存在等待进程集合 {P<sub>1</sub>, P<sub>2</sub>, …, P<sub>n</sub>}，P<sub>1</sub> 正在等待 P<sub>2</sub> 所占用的资源，P<sub>2</sub> 正在等待 P<sub>3</sub> 占用的资源，…，P<sub>n-1</sub> 在等待 P<sub>n</sub> 的资源，P<sub>n</sub> 正在等待 P<sub>1</sub> 所占用的资源。</li>
</ol>
<h1 id="死锁处理方法">死锁处理方法</h1>
<ul>
<li>确保系统永远不会进入死锁状态。</li>
<li>运行系统进入死锁状态，然后恢复。</li>
<li>忽略这个问题，假装系统中从来没有发生死锁，用于大多数操作系统，包括 UNIX。</li>
</ul>
<blockquote>
<p>系统忽略死锁是因为检查并避免死锁的代价太大，因此忽略并让应用程序（程序员）保证不会发生死锁。</p>
</blockquote>
<h2 id="死锁预防">死锁预防</h2>
<p>死锁预防（Deadlock Prevention）至少会打破死锁的四个必要条件中的一个，以确保系统不会进入死锁状态。</p>
<p><strong>打破互斥</strong>：共享资源不是必须的，必须占用非共享资源</p>
<p><strong>打破持有并等待</strong>：必须保证当一个进程请求的资源拿不到时，它不再持有任何其他资源</p>
<ul>
<li>进程在不同时间段所需的资源可能不同，要么持有全部资源、要么被迫放弃所有资源，这会导致系统资源利用率低，可能发生饥饿</li>
</ul>
<p><strong>打破无抢占</strong>：进程可以抢占其他进程的资源，如何抢占？比如 kill 掉这个进程（暴力了哈）</p>
<p><strong>打破循环等待</strong>：对所有资源类型进行排序，并要求每个进程按照资源的递增顺序进行申请（这样就不会产生循环了）</p>
<ul>
<li>通用操作系统用的不多，但在应用比较少的嵌入式操作系统用的较多；但同样面临系统资源利用率较低的问题</li>
</ul>
<h2 id="死锁避免">死锁避免</h2>
<p>死锁避免 <strong> 需要系统具有一些额外的先验信息提供</strong>。</p>
<ul>
<li>
<p>最简单有效的先验信息获取方法是：要求每个 <strong> 进程声明 </strong> 它可能需要的每个类型资源的最大数目。</p>
</li>
<li>
<p>资源的分配状态是通过 <strong> 限定提供与分配 </strong> 的资源数量以及进程的最大需求量。</p>
</li>
<li>
<p>死锁避免 <strong> 算法动态检查 </strong> 的资源分配状态，以确保永远不会出现一个环形等待状态。</p>
</li>
<li>
<p>当一个进程请求可用资源时，系统必须判断立即分配是否能使系统处于安全状态。</p>
</li>
</ul>
<p>系统处于安全状态是指：针对所有进程存在一个安全有序序列 {P<sub>1</sub>, P<sub>2</sub>, …, P<sub>j</sub>, …, P<sub>i</sub>, …, P<sub>n</sub>}。针对每个 P<sub>i</sub> 要求的资源，能够由当前可用的资源 + <em>所有</em> P<sub>j</sub> 持有的资源来满足。</p>
<ul>
<li>如果 P<sub>i</sub> 资源的需求不是立即可用，那么 P<sub>i</sub> <em>可以等待 </em> 所有 P<sub>j</sub> 完成。</li>
<li>当 P<sub>i</sub> 完成后，P<sub>i+1</sub> 可以得到所需要的资源并执行、释放所分配的资源并终止。</li>
<li>用同样的方法，P<sub>i+k</sub> 能获得其所需的资源。</li>
</ul>
<p>如果系统处于安全状态：无死锁，处于不安全状态：可能死锁。避免死锁：确保系统永远不会进入不安全状态。</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>死锁</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter1 概述</title>
    <url>/posts/230921190726.html</url>
    <content><![CDATA[<p> 这篇文章主要介绍操作系统的定义、架构层次、界面和内核、内部组成和特征等内容。</p>
<span id="more"></span>
<h1 id="概述"> 概述 </h1>
<h2 id="操作系统定义"> 操作系统定义 </h2>
<p><strong> 用户角度 </strong>：操作系统是一个控制软件。</p>
<ul>
<li> 管理应用软件：可以限制不同的应用程序占用不同的资源 </li>
<li> 为应用程序提供服务：I/O 服务，声卡、网卡的访问服务 </li>
<li> 杀死应用程序 </li>
</ul>
<p><strong> 程序角度 </strong>：操作系统是资源管理器。</p>
<ul>
<li> 管理外设，分配资源 </li>
<li> 抽象化作用
<ul>
<li>CPU 抽象成进程 </li>
<li> 磁盘抽象成文件 </li>
<li> 内存抽象成地址空间 </li>
</ul>
</li>
</ul>
<h2 id="操作系统的架构层次"> 操作系统的架构层次 </h2>
<p> 硬件之上、应用软件之下（为应用软件提供服务支持）。</p>
<h2 id="操作系统的界面和内核"> 操作系统的界面和内核 </h2>
<p>Linux、Windows、Android 的界面属于外壳（shell），而不是内核（kernel）。kernel 是操作系统的研究重点，处于 shell 之下。</p>
<h2 id="操作系统内部组成"> 操作系统内部组成 </h2>
<p> 操作系统（kernel）内部组件包括：</p>
<ul>
<li>CPU 调度器 </li>
<li> 物理内存管理 </li>
<li> 虚拟内存管理 </li>
<li> 文件系统管理 </li>
<li> 中断处理与 I/O 设备驱动 </li>
</ul>
<h2 id="操作系统特征"> 操作系统特征 </h2>
<ul>
<li> 并发
<ul>
<li> 计算机系统中同时存在多个运行的程序，需要 OS 管理和调度。</li>
</ul>
</li>
<li> 共享
<ul>
<li>“同时”访问或互斥共享。</li>
</ul>
</li>
<li> 虚拟
<ul>
<li> 利用多道程序设计技术，让每一个用户都觉得有一个计算机专门为他服务。</li>
</ul>
</li>
<li> 异步
<ul>
<li> 每个程序的执行不是一贯到底，而是走走停停 &amp; 交替执行，向前推进速度不可预知；</li>
<li> 只要运行环境相同，OS 保证程序运行结果相同。</li>
</ul>
</li>
</ul>
<blockquote>
<p>「并发」在一段时间内可以有多个程序运行，而「并行」是在一个时间点上可以有多个程序运行，并行需要多核 CPU 支持。</p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>概述</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>概述</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter2 启动 &amp; 中断 &amp; 异常 &amp; 系统调用</title>
    <url>/posts/230924172528.html</url>
    <content><![CDATA[<p>这篇文章主要介绍操作系统的启动，中断、异常、系统调用的特征和差别，以及处理流程（机制）。</p>
<span id="more"></span>
<h2 id="操作系统启动">操作系统启动</h2>
<h3 id="作用解析">作用解析</h3>
<ul>
<li>硬盘（disk）：存放 OS 和 BootLoader</li>
<li>BIOS：基本 I/O 处理系统</li>
<li>BootLoader：用于加载 OS，将 OS 从 disk 加载到内存中</li>
</ul>
<blockquote>
<p>BIOS 是一种固化在计算机主板上的软件程序，其中的一个主要作用就是：启动计算机 —— 当你启动计算机时，<strong>BIOS 是第一个被执行的程序</strong>。它负责进行硬件自检（POST，Power-On Self-Test）以及初始化计算机的硬件设备，包括处理器、内存、硬盘、显卡等。<strong>BIOS 还负责加载操作系统的引导程序（BootLoader）</strong>。</p>
</blockquote>
<h3 id="启动步骤">启动步骤</h3>
<img src="../images/os-kernel/chapter2/os-startup.png" alt="计算机启动流程" width="80%" height="80%">
<p>操作系统启动过程可以概括为以下几个步骤：</p>
<ol>
<li>电源启动</li>
<li>BIOS 自检</li>
<li>加载引导程序（BootLoader）</li>
<li>引导程序的工作</li>
<li>内核初始化：操作系统内核接管控制权后，它会进行一系列的初始化工作，包括初始化进程管理、内存管理、文件系统等重要的系统组件</li>
<li>用户登录</li>
</ol>
<h4 id="BIOS 自检">BIOS 自检</h4>
<img src="../images/os-kernel/chapter2/os-startup-layout.png" alt="计算机启动时内存和硬盘布局" width="80%" height="80%">
<p>计算机启动时，BIOS 从一个特定地址（CS:IP = 0xF000:FFF0）开始执行，这两个寄存器合在一起可以形成一个具体的物理内存地址。BIOS 就从这个内存地址开始执行 POST（加电自检）、寻找显卡和执行 BIOS。</p>
<blockquote>
<p>段寄存器（CS）和指令寄存器（IP）是计算机中的两种不同类型的寄存器：<br>
<strong>段寄存器 </strong> 是用于存储内存中的段地址的寄存器。在计算机中，内存被划分为多个段，每个段都有一个唯一的段地址。段寄存器存储着当前程序正在访问的段的地址。当程序需要访问内存中的数据时，它会使用段寄存器中的地址来确定要访问的段，并将其与偏移地址（存储在其他寄存器中）相加以获取最终的物理地址。<br>
** 指令寄存器（也称为程序计数器）** 是用于存储下一条要执行的指令的地址的寄存器。在计算机执行程序时，指令寄存器中保存着当前正在执行的指令的地址。当一条指令执行完毕后，指令寄存器会自动增加，以指向下一条将要执行的指令的地址。这样，计算机可以按顺序执行存储器中的指令序列。指令寄存器的值的改变决定了计算机下一步要执行的操作。</p>
</blockquote>
<h4 id="加载 BootLoader">加载 BootLoader</h4>
<img src="../images/os-kernel/chapter2/os-load-bootloader.png" alt="BIOS 加载引导程序" width="80%" height="80%">
<p><strong>BIOS 负责加载 BootLoader</strong>：BIOS 会从预设的启动设备（如硬盘、光盘、USB 等）中加载引导程序（BootLoader）到内存中。引导程序通常位于硬盘的特定扇区或光盘的启动区。</p>
<p><strong>引导程序的工作</strong>：引导程序负责初始化硬件（如 CPU、内存等），加载操作系统内核，并将控制权交给内核。它还可以提供多个操作系统的选择菜单（如 GRUB），以供用户选择启动的操作系统。</p>
<h4 id="加载 OS">加载 OS</h4>
<p>BootLoader 放在硬盘的第一个主引导扇区（512 字节）。这样，BIOS 从硬盘的第一个扇区寻找，一下便能找到 BootLoader。</p>
<img src="../images/os-kernel/chapter2/os-bootloader-address.png" alt="引导程序的内存地址空间" width="80%" height="80%">
<p><strong>BIOS 负责加载 BootLoader</strong>：将 BootLoader 从磁盘的引导扇区加载到 0x7C00 内存地址处。</p>
<p><strong>BootLoader 负责加载 OS</strong>：将操作系统的代码和数据从硬盘加载到内存中。之后，控制权交给到 OS（跳转到 OS 的起始地址）。</p>
<h2 id="中断、异常和系统调用">中断、异常和系统调用</h2>
<p>操作系统与设备和程序之间的交互可以通过中断、异常和系统调用来实现。</p>
<h3 id="定义">定义</h3>
<p><strong>中断（hardware interrupt）</strong>：是指外部事件（如硬件设备请求、定时器中断等）打断程序的正常执行，引发操作系统的处理程序来处理相应的事件。通过中断，设备可以向操作系统发出请求，操作系统可以响应并进行相应的处理。</p>
<p><strong>异常（exception）</strong>：是指程序执行过程中出现的错误或异常情况，如除零错误、访问非法内存等。当发生异常时，操作系统会捕获并进行相应的处理，例如终止异常程序、显示错误消息等。</p>
<p><strong>系统调用（system call）</strong>：是应用程序通过操作系统提供的接口来请求操作系统的服务。通过系统调用，应用程序可以访问操作系统提供的功能，如文件读写、网络通信、内存管理等。应用程序通过系统调用将请求传递给操作系统，操作系统执行相应的操作，并将结果返回给应用程序。</p>
<h3 id="来源">来源</h3>
<p><strong>中断来源于外设</strong>：来自不同的硬件设备的计时器和网络的中断。</p>
<p><strong>异常来源于不良的应用程序</strong>：非法指令或者其他坏的处理状态（如：内存出错）。</p>
<p><strong>系统调用来源于应用程序</strong>：应用程序主动向操作系统发出服务请求。</p>
<h3 id="处理时间">处理时间</h3>
<ul>
<li>中断：异步</li>
<li>异常：同步</li>
<li>系统调用：同步或异步
<ul>
<li>同步：指应用程序等待系统调用的返回结果</li>
<li>异步：指应用程序发出系统调用后就去干别的事情了</li>
</ul>
</li>
</ul>
<blockquote>
<p>异步：应用程序不知道什么时候会发生<br>
同步：执行到某一条指令一定会发生该事件</p>
</blockquote>
<h3 id="响应状态">响应状态</h3>
<ul>
<li>中断：持续，对用户应用程序是透明的（用户程序感知不到）</li>
<li>异常：杀死或重新执行指令</li>
<li>系统调用：等待和持续</li>
</ul>
<table>
<thead>
<tr>
<th>交互方式</th>
<th>来源</th>
<th>处理时间</th>
<th>响应状态</th>
</tr>
</thead>
<tbody>
<tr>
<td>中断</td>
<td>外设</td>
<td>异步</td>
<td>持续，对用户应用程序透明</td>
</tr>
<tr>
<td>异常</td>
<td>不良的应用程序</td>
<td>同步</td>
<td>杀死或重新执行指令</td>
</tr>
<tr>
<td>系统调用</td>
<td>应用程序</td>
<td>同步或异步</td>
<td>等待和持续</td>
</tr>
</tbody>
</table>
<h3 id="中断和异常处理流程">中断和异常处理流程</h3>
<p>中断是外设的事件，异常是内部 CPU 的事件。中断和异常迫使 CPU 访问一些与中断和异常相关的功能和服务。</p>
<h4 id="中断处理流程">中断处理流程</h4>
<p>操作系统的中断处理流程包括硬件中断处理和软件中断处理两个部分。</p>
<p><strong>硬件中断 </strong> 处理流程如下：</p>
<ol>
<li>硬件设备产生中断信号，例如外设完成数据传输、定时器到达计时器溢出等。</li>
<li><strong>CPU 检测到中断信号后，会立即停止当前正在执行的指令，并将当前执行指令的上下文（包括寄存器状态、程序计数器等）保存到内存中的堆栈中</strong>。</li>
<li>CPU 根据中断信号的类型，通过中断向量表或中断描述符表（IDT）查找相应的中断处理程序的入口地址。</li>
<li>CPU 跳转到中断处理程序的入口地址，开始执行中断处理程序。</li>
<li>中断处理程序根据中断类型执行相应的操作，例如处理设备的数据、更新操作系统状态等。</li>
<li><strong>中断处理程序执行完毕后，将之前保存的上下文从堆栈中恢复回来</strong>。</li>
<li>CPU 继续执行被中断的指令或者执行下一个指令。</li>
</ol>
<p><strong>软件中断 </strong> 处理流程如下：</p>
<ol>
<li>程序通过系统调用或软中断指令触发软件中断。</li>
<li>CPU 执行软中断指令后，<strong>会暂停当前正在执行的指令，并将当前执行指令的上下文保存到内存中的堆栈中</strong>。</li>
<li>CPU 根据软中断号，在中断向量表或中断描述符表（IDT）中查找相应的中断处理程序的入口地址。</li>
<li>CPU 跳转到中断处理程序的入口地址，开始执行中断处理程序。</li>
<li>中断处理程序根据软中断号执行相应的操作，例如系统调用、异常处理等。</li>
<li>中断处理程序执行完毕后，<strong>将之前保存的上下文从堆栈中恢复回来</strong>。</li>
<li>CPU 继续执行被中断的指令或者执行下一个指令。</li>
</ol>
<p>总的来说，中断处理流程包括 <strong> 中断信号的检测、上下文的保存与恢复、中断处理程序的执行 </strong> 等步骤，以保证操作系统能够及时响应硬件设备的请求或软件的触发。</p>
<blockquote>
<p>应用程序完全不会感知到中断的产生。</p>
</blockquote>
<h4 id="异常处理流程">异常处理流程</h4>
<p>操作系统的异常处理流程如下：</p>
<ol>
<li><strong>异常产生</strong>：异常是指在程序执行过程中发生的错误或异常情况，例如访问非法内存、除零错误等。异常可以由硬件产生，也可以由软件产生。</li>
<li><strong>异常检测</strong>：CPU 会检测到异常的发生，并中断当前正在执行的指令。</li>
<li><strong>异常处理程序选择</strong>：CPU 会通过中断向量表或中断描述符表（IDT）查找相应的异常处理程序的入口地址。</li>
<li><strong>上下文保存</strong>：CPU 会将当前执行指令的上下文（包括寄存器状态、程序计数器等）保存到内存中的堆栈中。</li>
<li><strong>异常处理程序执行</strong>：CPU 跳转到异常处理程序的入口地址，开始执行异常处理程序。</li>
<li><strong>异常处理</strong>：异常处理程序会根据异常类型执行相应的操作，例如打印错误信息、终止异常进程、恢复系统状态等。</li>
<li><strong>上下文恢复</strong>：异常处理程序执行完毕后，将之前保存的上下文从堆栈中恢复回来。</li>
<li><strong>异常返回</strong>：CPU 继续执行被中断（指的是由异常引起的中断，而不是外部设备或事件所引起的中断）的指令或者执行下一个指令。</li>
</ol>
<p>总的来说，异常处理流程包括 <strong> 异常信号的检测、上下文的保存与恢复、异常处理程序的执行 </strong> 等步骤，异常处理流程的目的是在程序出现异常时能够及时处理异常情况，保证系统的稳定性和可靠性。</p>
<h3 id="系统调用">系统调用</h3>
<p>系统调用来源于应用程序，需要操作系统提供服务，这些服务需要操作系统来执行，这个过程就需要一个接口：<strong>系统调用接口</strong>。应用程序访问主要是通过高层次的 API 接口，而不是直接进行系统调用。</p>
<img src="../images/os-kernel/chapter2/os-syscall.png" alt="系统调用示例" width="80%" height="80%">
<p><strong>三种最常用的 APIs</strong>：</p>
<ul>
<li>Win32 API：用于 Windows</li>
<li>POSIX API：用于 POSIX-based systems（包括 UNIX，LINUX，Mac OS X）</li>
<li>Java API：用于 JAVA 虚拟机（JVM 跨平台）</li>
</ul>
<p><strong>特点</strong>：</p>
<ul>
<li>通常情况下，每个系统调用对应一个系统调用号，系统调用接口根据这些序号来维护表的索引。</li>
<li>系统调用接口调用内核态中预期的系统调用，并返回系统调用的状态和其他任何返回值。</li>
<li>用户不需要知道系统调用是如何实现的，只需要获取 API 和了解操作系统将什么作为返回结果。</li>
</ul>
<p><strong>用户态</strong>：操作系统运行中，CPU 所处的特权级别特别低，不能访问特权指令、I/O 指令。</p>
<p><strong>内核态</strong>：操作系统运行中，CPU 所处的级别很高，可以执行任何一条指令，包括特权指令、I/O 指令。</p>
<p><strong>系统调用 </strong>：触发 CPU<strong> 从用户态到内核态的转换</strong>。切换程序和内核的堆栈，需要一定的开销，但是换来了安全。</p>
<p><strong>系统调用是跨越操作系统边界的开销</strong>（值得的且必须的，保证了操作系统的安全性）：</p>
<ul>
<li>在执行时间上的开销超过程序调用</li>
<li>开销：
<ul>
<li>建立中断、异常、系统调用号与对应服务例程映射关系的初始化开销</li>
<li>建立内核堆栈（用于内核退出时保存，内核执行时恢复，类似于应用程序的堆栈）</li>
<li>验证参数（内核不信任应用程序，故而需要验证参数）</li>
<li>内核态映射到用户态的地址空间（<strong>通过拷贝的方式传递数据</strong>，不像用户态下的应用程序，可以通过指针传递实现）
<ul>
<li>更新页面映射权限</li>
</ul>
</li>
<li>内核态独立地址空间
<ul>
<li>通过在 TLB 中维护不同的页表实现</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>「内核态独立地址空间」是指在操作系统中，内核和用户程序所使用的内存地址空间是相互独立的。</p>
</blockquote>
<h2 id="什么是更新页面映射权限">什么是更新页面映射权限</h2>
<p>「更新页面映射权限」是指在操作系统中，<strong>对虚拟内存中的页面进行权限的调整或修改</strong>。</p>
<p>在虚拟内存管理中，操作系统将物理内存空间映射到进程的虚拟地址空间中，形成了一种虚拟内存映射。每个页面都有对应的权限，例如读、写、执行等。当需要修改某个页面的权限时，就需要进行页面映射权限的更新。</p>
<p>更新页面映射权限的具体操作包括：</p>
<ol>
<li><strong>检查该页面的当前权限</strong>：首先，操作系统会检查该页面的当前权限，确定要进行哪些修改。</li>
<li><strong>修改页面权限</strong>：根据需要，操作系统会修改页面的权限，例如增加或删除某项权限。</li>
<li><strong>更新页表 </strong>：在虚拟内存管理中，每个进程都有自己的页表，<strong> 用于记录虚拟地址与物理地址之间的映射关系</strong>。当页面的权限发生变化时，操作系统需要更新相应的页表项，以反映最新的权限信息。</li>
</ol>
<p>通过更新页面映射权限，操作系统可以 <strong> 实现对进程的内存访问控制</strong>，保证系统的安全性和稳定性。</p>
<h2 id="应用程序不能直接访问外设">应用程序不能直接访问外设</h2>
<p>应用程序不能直接访问外设，而要通过操作系统的原因主要有以下几点：</p>
<ol>
<li>安全性：操作系统（内核）是被信任的第三方，只有操作系统才能执行特权指令，保护硬件和系统资源的安全。</li>
<li>统一性：通过操作系统提供的接口，应用程序可以统一地访问不同的外设，而不需要关心具体的硬件细节。</li>
<li>方便性：操作系统提供了一些高级功能和服务，如文件系统、网络协议等，应用程序可以更方便地使用这些功能。</li>
</ol>
<blockquote>
<p>参考资料：<br>
1：<a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a><br>
2：<a href="https://blog.csdn.net/weixin_53407527/category_11825873.html">https://blog.csdn.net/weixin_53407527/category_11825873.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>中断、异常和系统调用</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>中断</tag>
        <tag>异常</tag>
        <tag>系统调用</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter3.1 内存分层体系与地址空间生成</title>
    <url>/posts/231017195157.html</url>
    <content><![CDATA[<p>这篇文章主要介绍计算机的体系结构，内存的分层体系，操作系统的内存管理，地址空间和地址生成等内容。</p>
<span id="more"></span>
<h2 id="计算机体系结构">计算机体系结构</h2>
<p>CPU：主要完成了对整个程序或软件的执行的控制。<br>
内存：主要是放置了程序的代码和它所处理的数据。<br>
外设：各种外部设备配合程序更好的完成工作。</p>
<img src="/images/os-kernel/chapter3/computer-architecture.png" alt="计算机体系结构" width="80%" height="80%">
<h2 id="内存分层体系">内存分层体系</h2>
<img src="/images/os-kernel/chapter3/memory-layering.png" alt="内存分层体系" width="80%" height="80%">
<p>计算机内存包含多个层次，包括 CPU 寄存器、cache 和主存（物理内存）、硬盘（虚拟内存）。硬盘用于保存持久化数据。</p>
<ul>
<li>CPU 寄存器和 cache：
<ul>
<li>访问速度快，但容量小；</li>
<li>寄存器是 CPU 内部的存储单元，用于存储临时数据和指令；</li>
<li>cache 是位于 CPU 和主存之间的高速缓存，<strong>用于加速对主存的访问</strong>。</li>
</ul>
</li>
<li>主存（物理内存）：
<ul>
<li>存放操作系统和程序代码等数据；</li>
<li>容量较大，但访问速度相对较慢；</li>
<li>主存中的数据掉电会丢失。</li>
</ul>
</li>
<li>硬盘（虚拟内存）：
<ul>
<li>保存持久化数据，即使掉电也不会丢失；</li>
<li>访问速度较慢，但容量可以很大。</li>
</ul>
</li>
</ul>
<p>操作系统会根据需要将数据从主存中放到硬盘中，以便管理数据的容量和提高运行效率。</p>
<h2 id="操作系统的内存管理">操作系统的内存管理</h2>
<h3 id="目标">目标</h3>
<p>操作系统的内存管理到底要做什么事情呢？它有如下几个重要的目标。</p>
<ul>
<li>抽象：逻辑地址空间
<ul>
<li>操作系统通过提供逻辑地址空间，将底层细节抽象化，使应用程序不需要关心物理内存和外设的管理。</li>
</ul>
</li>
<li>保护：独立地址空间
<ul>
<li>为了避免应用程序相互访问彼此的地址空间，操作系统提供了独立的地址空间，将它们隔离，以保护应用程序免受破坏。</li>
</ul>
</li>
<li>共享：访问相同内存
<ul>
<li>多个应用程序之间也可能进行交互，操作系统允许多个应用程序共享相同的内存空间，以实现高效和可靠的数据传递。</li>
</ul>
</li>
<li>虚拟：更多的地址空间
<ul>
<li>物理内存空间有限，操作系统将必要的数据放在主存中，而将暂时不需要访问的数据临时存放在磁盘上，从而扩展了可用的地址空间。</li>
</ul>
</li>
</ul>
<img src="/images/os-kernel/chapter3/os-memory-management.png" alt="操作系统的内存管理" width="80%" height="80%">
<p>在这张图中，操作系统将进程 P1、P2、P3 和 P4 的必要数据放在主存中（进程 P1 优先级最高，所有数据都在主存中），暂时不需要访问的数据（进程 P4/P2/P3 的一部分数据）临时存放在磁盘上。</p>
<p>从上图中，也可以看出进程（我们的程序）属于逻辑地址空间，主存和磁盘的内存空间属于物理内存空间。</p>
<h3 id="内存管理的不同方法">内存管理的不同方法</h3>
<ul>
<li>程序重定位（relocation）</li>
<li>分段（segmentation）</li>
<li>分页（page）</li>
<li>虚拟内存（virtual memory）</li>
<li>按需分页虚拟内存：目前多数操作系统（如 Linux）采用</li>
</ul>
<blockquote>
<p>内存管理的实现高度依赖于硬件：</p>
<ul>
<li>必须知道内存架构（与计算机存储架构紧耦合）</li>
<li>MMU（内存管理单元）：硬件组件负责处理 CPU 的内存访问请求</li>
</ul>
</blockquote>
<h2 id="地址空间与地址生成">地址空间与地址生成</h2>
<h3 id="地址空间定义">地址空间定义</h3>
<p>物理地址空间就是内存条和硬盘的空间，它的管理和控制由硬件来完成的。</p>
<p>逻辑地址空间就是一个运行的程序所拥有的的内存空间，是一种一维的线性地址空间（这种设计可以使得应用程序很容易的进行数据访问操作）。</p>
<blockquote>
<p>逻辑地址空间的设计使得数据访问更加方便的「其中一个原因」就是：<br>
逻辑地址空间是一维的线性地址空间，即内存地址在逻辑上是连续的。这种设计使得程序可以使用简单的地址计算来访问数据，而不需要考虑数据在内存中的实际物理位置。这样，程序员可以通过 <strong> 使用相对地址来访问数据，而不需要关注数据的具体位置</strong>。</p>
</blockquote>
<img src="/images/os-kernel/chapter3/memory-space.png" alt="地址空间" width="80%" height="80%">
<h3 id="地址空间对应关系">地址空间对应关系</h3>
<p>一个运行的程序所访问的逻辑地址空间，最终都会对应着物理地址空间中的某一位置，可能放在主存中、也可能放在硬盘中。物理地址空间和逻辑地址空间通过映射关系对应起来（映射关系由操作系统进行有效地管理）。</p>
<h3 id="逻辑地址生成">逻辑地址生成</h3>
<p>下图展示了逻辑地址的生成过程。</p>
<img src="/images/os-kernel/chapter3/logical-address-generation.png" alt="逻辑地址生成" width="80%" height="80%">
<ol>
<li>C 程序文件（.c 文件）中的函数和变量名即逻辑地址。编译器会将 C 程序转换为汇编语言程序（.s 文件），并在汇编代码中使用符号来代表函数和变量的名字。</li>
<li>汇编语言程序（.s 文件）中的符号仍然是逻辑地址。编译器将汇编语言程序转换为机器语言程序（.o 文件），并将变量和函数的符号名转换为逻辑地址。</li>
<li>链接器（linker）将多个机器语言程序（.o 文件）链接在一起，形成一个单一的可执行文件（.exe 文件）。链接器会为每个变量和函数分配唯一的逻辑地址，并解决不同文件之间的符号引用关系。</li>
<li>加载器（loader）将可执行文件（.exe 文件）加载到内存中运行。加载器会将可执行文件的代码和数据加载到内存的适当位置，并进行地址的重定位。由于加载过程中会存在一定的偏移量，程序需要根据偏移量来进行正确的数据访问和指令操作。</li>
</ol>
<blockquote>
<p>逻辑地址生成的过程可以在编译器、链接器和加载器等工具的协同作用下完成，操作系统通常不需要干预该过程。这样的设计使得程序员可以方便地使用符号和逻辑地址进行开发，而无需关心实际的物理地址和内存布局。</p>
</blockquote>
<h3 id="物理地址生成">物理地址生成</h3>
<p>下图展示了物理地址的生成过程。</p>
<img src="/images/os-kernel/chapter3/physical-address-generation.png" alt="物理地址生成" width="80%" height="80%">
<p>物理地址的生成过程是由操作系统的内存管理单元（MMU）来完成的。MMU 负责将逻辑地址转换为物理地址，使得程序能够正确地访问内存。</p>
<ol>
<li>分页：操作系统将整个物理内存划分为固定大小的页面（page），通常是 4KB 或者更大的大小。同时，逻辑地址空间也被划分为相同大小的页面。</li>
<li>页表：每个进程都有一个页表，用于记录逻辑地址与物理地址的映射关系。页表的每个表项（entry）记录了逻辑页面号与物理页面号的对应关系。</li>
<li>地址转换：当程序访问某个逻辑地址时，MMU 会根据页表中的映射关系将逻辑地址转换为物理地址。具体的转换过程是 <strong> 通过逻辑地址中的页号（page number）和页内偏移（page offset）进行计算得到</strong>：paddr = (page_num &lt;&lt; PAGE_SHIFT(12)) + (vaddr % PAGE_SIZE(1U &lt;&lt; 12))。</li>
<li>物理地址访问：得到物理地址后，程序就可以使用该地址直接访问内存中的数据或指令。</li>
</ol>
<blockquote>
<p>需要注意的是，物理地址生成的过程是 <strong> 在程序运行时 </strong> 由硬件执行的，而不是编译、链接或加载阶段进行的。<strong>操作系统会在程序加载到内存时设置好页表，并将页表的基地址告诉 MMU，以便进行地址转换</strong>。这样，程序在运行过程中，无需关心物理地址的生成和管理，而是通过逻辑地址进行访问。</p>
</blockquote>
<p>为了加快地址转换的速度，操作系统会将逻辑地址到物理地址的映射关系存储在内存中，并由 CPU 进行缓存。</p>
<blockquote>
<p>具体来说，当 CPU 首次访问某个逻辑地址时，MMU 会根据页表将逻辑地址转换为物理地址，并将该映射关系存储在一个特殊的高速缓存中，称为转换后备缓冲器（Translation Lookaside Buffer，简称 TLB）。TLB 是一种硬件缓存，用于临时存储逻辑地址到物理地址的映射关系。<br>
当程序再次访问相同的逻辑地址时，CPU 会首先检查 TLB 中是否存在该映射关系：</p>
<ul>
<li>如果存在，则可以直接从 TLB 中获取物理地址，从而避免了访问内存的开销；</li>
<li>如果 TLB 中没有找到对应的映射关系，则需要通过页表来进行地址转换（上述序号 2 和 3），并将新的映射关系存储到 TLB 中，以便下次访问时可以直接使用。</li>
</ul>
</blockquote>
<h3 id="地址安全检查">地址安全检查</h3>
<p>为了避免应用程序相互访问彼此的地址空间，操作系统提供了独立的地址空间，将它们隔离，以保护应用程序免受破坏。</p>
<img src="/images/os-kernel/chapter3/address-security-check.png" alt="地址安全检查" width="80%" height="80%">
<p>地址安全检查使应用程序在内存中正常执行，同时保证在内存中不同的应用程序之间不会相互破坏。</p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://blog.csdn.net/weixin_53407527/article/details/124930556">https://blog.csdn.net/weixin_53407527/article/details/124930556</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>地址空间与地址生成</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>内存分层体系</tag>
        <tag>地址空间生成</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter3.2 连续内存分配</title>
    <url>/posts/231108195351.html</url>
    <content><![CDATA[<p>这篇文章主要介绍操作系统的连续内存分配，包括内存的内碎片与外碎片、内存的动态分配算法、压缩式碎片整理与交换式碎片整理。</p>
<span id="more"></span>
<h2 id="连续内存分配">连续内存分配</h2>
<p>连续内存分配：给进程分配一块不小于指定大小的、连续的物理内存区域。</p>
<h3 id="内存碎片问题">内存碎片问题</h3>
<p>内存碎片问题指的是空闲的内存无法被利用，细分为外部碎片和内部碎片。</p>
<ul>
<li>外部碎片：分配单元（进程）间的未使用内存</li>
<li>内部碎片：分配单元（进程）内的不能被利用的内存</li>
</ul>
<h3 id="分区的动态分配">分区的动态分配</h3>
<p>动态分区分配：当程序被加载执行时，分配给进程一个指定大小可变的分区（块、内存块），且分区的物理地址是连续的。</p>
<p>分区的动态分配方式有以下三种：</p>
<ol>
<li>第一匹配分配（first fit）：在空闲的内存块中，从低内存往高内存顺序搜索，找到 <strong> 第一个 </strong> 比需求大的空闲块, 分配给应用程序。</li>
<li>最优适配分配（best fit）：在空闲的内存块中，找到比需求大的 <strong> 最小的 </strong> 空闲块, 分配给应用程序。</li>
<li>最差适配分配（worst fit）：在空闲的内存块中，找到 <strong> 最大的 </strong> 空闲块, 分配给应用程序。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|....| 500bytes |.......| 1k bytes |...| 400bytes |...|    </span><br></pre></td></tr></table></figure>
<p>例如，现在有一个应用程序，需要 300bytes 的内存块，那么第一匹配分配将会选择 500bytes 的内存块，最优适配分配将会选择 400bytes 的内存块，最差适配分配将会选择 1k bytes 的内存块。</p>
<p>分配方式的区别：</p>
<table>
<thead>
<tr>
<th></th>
<th>第一匹配分配</th>
<th>最优适配分配</th>
<th>最差适配分配</th>
</tr>
</thead>
<tbody>
<tr>
<td>分配方式原理 &amp; 实现</td>
<td>按地址排序的空闲块列表、需要寻找合适的分区、重分配时需检查合并相邻空闲分区</td>
<td>按尺寸排序的空闲块列表、需要寻找合适的分区、重分配时需检查合并相邻空闲分区</td>
<td>按尺寸排序的空闲块列表、分配最大分区、重分配时需检查合并相邻空闲分区，并调整空闲分区列表顺序</td>
</tr>
<tr>
<td>优势</td>
<td>简单易实现、容易产生更大空闲块</td>
<td>相对简单、对小尺寸分配高效、可避免大的空闲分区被拆分</td>
<td>分配快、对中尺寸分配高效</td>
</tr>
<tr>
<td>劣势</td>
<td>容易产生外部碎片、不确定性、分配大块时较慢</td>
<td>容易产生外部碎片、重分配慢（释放分区较慢）、产生微小碎片</td>
<td>容易产生外部碎片、重分配慢（释放分区较慢）、容易破坏大的空闲分区，后续难以分配大的分区</td>
</tr>
</tbody>
</table>
<blockquote>
<p>三种分配方式并无优劣之分，因为我们无法判断内存请求的大小。</p>
</blockquote>
<h2 id="碎片整理">碎片整理</h2>
<p>可以看到的是，三种分区动态分配的方式都会产生外部碎片，因此我们可以对碎片进行一定的整理来解决碎片问题。</p>
<p>何为碎片整理？即通过调整应用程序（进程）占用的分区位置来减少或避免分区碎片，以腾出更大的内存块。</p>
<h3 id="压缩式碎片整理">压缩式碎片整理</h3>
<ul>
<li>方式：重置程序以合并外部碎片</li>
<li>条件：要求所有程序是动态可重定位的</li>
<li>需要解决的问题：
<ul>
<li>何时重置？（在程序处于等待状态时才可以重置）</li>
<li>需要考虑内存拷贝的开销</li>
</ul>
</li>
</ul>
<p>一个压缩式碎片整理的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 原始应用程序的内存块和外部碎片</span><br><span class="line">|....| 500bytes |.......| 1k bytes |...| 400bytes |...|   </span><br><span class="line"></span><br><span class="line">// 新增一个应用程序，需要 1200bytes 的内存块，通过压缩式碎片整理，腾出一块满足需求的内存卡分配给新的应用程序</span><br><span class="line">|....|.......|...|...| 500bytes | 1k bytes | 400bytes |   </span><br></pre></td></tr></table></figure>
<h3 id="交换式碎片整理">交换式碎片整理</h3>
<ul>
<li>方式：运行程序需要更多的内存时，抢占等待的程序并且回收它们的内存，以增大可用内存空间</li>
<li>需要解决的问题：
<ul>
<li>哪些程序应该被回收？</li>
</ul>
</li>
</ul>
<p>一个交换式碎片整理的示例：</p>
<ol>
<li>运行中：P3</li>
<li>等待中：P1，P2，P4</li>
<li>内存分布，主存：OS / P1 / P3 / P2 / P4，磁盘：空</li>
<li>当 P3 程序需要更大的内存时，可将等待中的 P4 程序先放入虚拟内存中 -&gt; 内存分布，主存：OS / P1 / P3 / P2，磁盘：P4</li>
</ol>
<blockquote>
<p>参考资料：<br>
1：<a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a><br>
2：<a href="https://blog.csdn.net/weixin_53407527/article/details/124891795">https://blog.csdn.net/weixin_53407527/article/details/124891795</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>连续内存分配</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>连续内存分配</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter4.1 非连续内存分配之分段与分页</title>
    <url>/posts/231111172507.html</url>
    <content><![CDATA[<p>这篇文章主要介绍操作系统的非连续内存分配，包括非连续内存分配的必要性、分段（segmentation）与分页（paging）技术。</p>
<span id="more"></span>
<h2 id="非连续内存分配的必要性">非连续内存分配的必要性</h2>
<p>第三章介绍的是连续内存管理，即：操作系统加载到内存以及程序加载到内存中时，分配一块连续的空闲内存块，但是容易出现碎片问题。这一章介绍的非连续内存分配，这可以有效的减少碎片的出现。</p>
<h3 id="连续内存分配的缺点">连续内存分配的缺点</h3>
<ol>
<li>分配给一个程序的物理内存是连续的</li>
<li>内存利用率低</li>
<li>有外碎片、内碎片的问题</li>
</ol>
<blockquote>
<p>能否通过一些手段来改善这些情况？非连续内存分配！</p>
</blockquote>
<h3 id="非连续内存分配的优点">非连续内存分配的优点</h3>
<ol>
<li>分配给一个程序的物理内存是非连续的</li>
<li>更好的内存利用和管理</li>
<li>允许共享代码与数据（共享库等…）</li>
<li>支持动态加载和动态链接</li>
</ol>
<h3 id="非连续内存分配的缺点">非连续内存分配的缺点</h3>
<p>建立虚拟地址和物理地址的转换难度大。</p>
<ul>
<li>软件方案（开销相当大）</li>
<li>硬件方案（采用硬件辅助机制）：分段（segmentation）技术、分页（paging）技术</li>
</ul>
<h2 id="非连续内存分配">非连续内存分配</h2>
<h3 id="分段（segmentation）">分段（segmentation）</h3>
<h4 id="分段">分段</h4>
<p>分段（segmentation）是一种非连续内存分配技术，用于操作系统中 <strong> 管理进程的内存空间</strong>。在分段技术中，进程的内存空间被划分为多个段，每个段具有不同的大小和功能。</p>
<img src="../images/os-kernel/chapter4/process-memory-segmentation.png" alt="进程内存空间划分" width="70%" height="70%">
<p>「段」：在程序执行时，会存在来自不同文件的函数和不同的数据字段。这些函数可能分布在程序的不同文件中，而数据字段则可以包括堆、栈、.bss、.data 等不同类型。</p>
<ul>
<li>堆用于动态内存分配</li>
<li>栈用于函数调用和局部变量存储</li>
<li>.bss 用于存储未初始化的静态变量</li>
<li>.data 用于存储已初始化的静态变量</li>
</ul>
<p>「分段」：更好的实现内存的分离和共享。</p>
<p>程序的分段地址空间如下图所示：<br>
<img src="../images/os-kernel/chapter4/process-segmentation-space.png" alt="程序的分段地址空间" width="80%" height="80%"></p>
<p>把左边运行程序的逻辑地址空间看成一个连续的一维线性数组，通过段机制的映射关系，把不同的内存块（如：代码、数据、堆、栈）分别映射到不同的内存中的段，可以看到映射到物理地址空间后，位置不一样，变得不连续了。</p>
<p>分段的逻辑视图，连续的逻辑地址空间被分配到物理空间中的不连续内存空间中：<br>
<img src="../images/os-kernel/chapter4/segmentation-logical-view.png" alt="分段的逻辑视图" width="80%" height="80%"></p>
<h4 id="段表">段表</h4>
<p>段表是一种数据结构，用于 <strong> 存储和管理分段技术下的进程内存空间</strong>。它通常是一个数组或链表，每个元素表示一个段的相关信息。一个段对应着一个内存块。</p>
<p>下面是一个简化的段表数据结构示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentEntry</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> segmentID;      <span class="comment">// 段 ID</span></span><br><span class="line">    <span class="type">int</span> baseAddress;    <span class="comment">// 段基址</span></span><br><span class="line">    <span class="type">int</span> limit;          <span class="comment">// 段界限</span></span><br><span class="line">    <span class="type">int</span> permissions;    <span class="comment">// 段访问权限</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，每个段表项包含了以下信息：</p>
<ul>
<li><code>segmentID</code>：段的唯一标识符，用于区分不同的段。</li>
<li><code>baseAddress</code>：段的基址，指示段在内存中的起始位置。</li>
<li><code>limit</code>：段的界限，指示段的大小。通常以字节为单位。</li>
<li><code>permissions</code>：段的访问权限，用于控制对段的读、写和执行操作。</li>
</ul>
<p>段表根据进程的需要进行动态更新，以反映内存中段的分配和释放情况。通过段表，操作系统可以轻松地查找和管理进程的各个段，实现内存隔离和安全性。</p>
<h4 id="分段寻址方案">分段寻址方案</h4>
<p>逻辑地址空间连续，但是物理地址空间不连续，使用映射机制进行关联。</p>
<img src="../images/os-kernel/chapter4/segmentation-scheme.png" alt="硬件分段实现方案" width="80%" height="80%">
<p>程序访问物理内存地址需要：一个二维的二元组 <code>(segmentID, addrOffset)</code>，即 <code>(段号, 段内偏移地址)</code>。</p>
<p>操作系统会维护一张段表，以 <code>segmentID</code> 为索引，存储着 <code>(baseAddress, limit)</code> 信息。</p>
<p>因此，逻辑地址通过段表映射后的物理地址为：段号对应的段基址 + 二元组中的段内偏移地址</p>
<blockquote>
<p>段表在寻址之前操作系统就已经建立好了，之后段机制就可以正常工作了。</p>
</blockquote>
<h3 id="分页（paging）">分页（paging）</h3>
<h4 id="分页">分页</h4>
<p>分页（paging）是操作系统中的一种非连续内存分配技术。它将物理内存和逻辑内存进行分割：</p>
<ul>
<li>将逻辑内存空间划分成相等大小的页面（page）
<ul>
<li>大小是 2 的幂，例如：512bytes / 4096bytes / 8192bytes</li>
</ul>
</li>
<li>将物理内存空间也划分成相等大小的物理页帧（page frame）
<ul>
<li>大小是 2 的幂，例如：512bytes / 4096bytes / 8192bytes</li>
</ul>
</li>
</ul>
<blockquote>
<p>逻辑空间中内存划分叫做页（page），物理空间中内存划分叫做页帧（page frame）；划分的 page 大小和 frame 大小要保持一致。</p>
</blockquote>
<h4 id="页到页帧的转换">页到页帧的转换</h4>
<p>页到页帧的转换方案（pages to page frames）/ 逻辑地址到物理地址的转换方案：</p>
<ul>
<li>通过页表（page table）</li>
<li>内存管理单元（MMU）/ 快表（TLB）</li>
</ul>
<h4 id="帧（Frame）">帧（Frame）</h4>
<p>物理内存被分割为大小相等的帧，一个内存的物理地址是一个二元组 <code>(f, o)</code>：</p>
<ul>
<li><code>f</code> 为页帧号（一共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> 位，可以表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>F</mi></msup></mrow><annotation encoding="application/x-tex">2^F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span></span></span></span></span></span></span></span> 个不同的页帧）</li>
<li><code>o</code> 为页帧内偏移（一共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 位，每个页帧有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>S</mi></msup></mrow><annotation encoding="application/x-tex">2^S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span></span></span></span></span></span></span></span> 字节）</li>
</ul>
<p>页帧位占用高地址空间，页帧内偏移位占用低地址空间。二元组对应的物理地址为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>S</mi></msup><mo>×</mo><mi>f</mi><mo>+</mo><mi>o</mi></mrow><annotation encoding="application/x-tex">2^{S} \times f + o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.924661em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">o</span></span></span></span>。</p>
<blockquote>
<p>好比一本书，一共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>F</mi></msup></mrow><annotation encoding="application/x-tex">2^F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span></span></span></span></span></span></span></span> 页，每页最多可以写 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>S</mi></msup></mrow><annotation encoding="application/x-tex">2^S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span></span></span></span></span></span></span></span> 个字，当前打开的页面是第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> 页，笔处在本页第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi></mrow><annotation encoding="application/x-tex">o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">o</span></span></span></span> 个字的位置，处在全书第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>S</mi></msup><mo>×</mo><mi>f</mi><mo>+</mo><mi>o</mi></mrow><annotation encoding="application/x-tex">2^{S} \times f + o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.924661em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">o</span></span></span></span> 个字的位置。</p>
</blockquote>
<p>举个栗子：一个由 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">16 bit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord mathnormal">b</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span></span></span></span> 组成的地址空间，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>9</mn><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">9 bit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord mathnormal">b</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span></span></span></span> 大小（512 字节）的页帧，物理地址的二元组为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>3</mn><mo separator="true">,</mo><mn>6</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(3,6)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mclose">)</span></span></span></span>，请问物理地址是多少？</p>
<p>由描述可知，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mn>9</mn><mo separator="true">,</mo><mi>F</mi><mo>=</mo><mn>16</mn><mo>−</mo><mn>9</mn><mo>=</mo><mn>7</mn><mo separator="true">,</mo><mi>f</mi><mo>=</mo><mn>3</mn><mo separator="true">,</mo><mi>o</mi><mo>=</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">S=9, F=16-9=7, f=3, o=6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">o</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span>，二元组对应的物理地址为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>9</mn></msup><mo>×</mo><mn>3</mn><mo>+</mo><mn>6</mn><mo>=</mo><mn>1542</mn></mrow><annotation encoding="application/x-tex">2^{9} \times 3 + 6 = 1542</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord">4</span><span class="mord">2</span></span></span></span>。</p>
<blockquote>
<p>分页和分段的最大区别：这里的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 是一个固定的数，即每页页帧大小相同，而分段中的段的大小不固定。</p>
</blockquote>
<h4 id="页（Page）">页（Page）</h4>
<p>进程的逻辑地址空间被划分为大小相等的页，一个进程的逻辑地址是一个二元组 <code>(p, o)</code>：</p>
<ul>
<li><code>p</code> 为页号（一共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 位，可以表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>P</mi></msup></mrow><annotation encoding="application/x-tex">2^P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span></span></span></span></span></span></span></span> 个不同的页）</li>
<li><code>o</code> 为页内偏移（一共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 位，每页有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>S</mi></msup></mrow><annotation encoding="application/x-tex">2^S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span></span></span></span></span></span></span></span> 字节）</li>
</ul>
<p>二元组对应的逻辑地址为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>S</mi></msup><mo>×</mo><mi>p</mi><mo>+</mo><mi>o</mi></mrow><annotation encoding="application/x-tex">2^{S} \times p + o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.924661em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">o</span></span></span></span>。</p>
<blockquote>
<p>通常页号 <code>p</code> 不等于页帧号 <code>f</code>，但页内偏移跟页帧内偏移大小一致，页和页帧的字节数大小一致。</p>
</blockquote>
<h4 id="页寻址方案">页寻址方案</h4>
<p>页寻址要解决的就是，如何通过逻辑地址访问到对应的物理内存空间的数据。</p>
<p>当进程需要访问一个逻辑地址时，操作系统将逻辑地址分成两个部分：页号（page number）和页内偏移（page offset）。页号用于索引页表（page table），页表记录了每个页号对应的物理页帧号。通过找到页表中对应的物理页帧号，再加上页内偏移，就可以得到实际的物理地址，从而进行物理内存访问。</p>
<img src="../images/os-kernel/chapter4/page-addressing-scheme.png" alt="页寻址方案" width="80%" height="80%">
<blockquote>
<p>页寻址过程：逻辑地址 -&gt; 页号 -&gt; 查找页表 -&gt; 物理页帧号 -&gt; 利用页内偏移 -&gt; 实际物理地址 -&gt; 物理内存访问。</p>
</blockquote>
<ul>
<li>页表保存了逻辑地址到物理地址的映射关系（页号：物理页帧号）</li>
<li>实际上，逻辑地址空间大于物理内存空间</li>
<li>页映射到帧</li>
<li>页是连续的虚拟内存（逻辑地址中的页号是连续的）</li>
<li>帧是非连续的物理内存（物理地址中的帧号是不连续的），有助于减少碎片的产生</li>
<li>不是所有的页都有对应的帧</li>
</ul>
<p>为什么逻辑地址映射到物理地址空间后的内存是不连续的？</p>
<p>这是因为页寻址时，通过查找页表，将进程的连续页号 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span> 映射到不连续的页帧号 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>，不连续的页帧号对应着不连续的物理内存块。</p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a></li>
<li><a href="https://blog.csdn.net/weixin_53407527/article/details/124891795">https://blog.csdn.net/weixin_53407527/article/details/124891795</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>非连续内存分配</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>非连续内存分配</tag>
        <tag>分段</tag>
        <tag>分页</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter4.2 非连续内存分配之页表</title>
    <url>/posts/231119170537.html</url>
    <content><![CDATA[<p><a href="https://pursue26.github.io/posts/231111172507.html">操作系统之 chapter4.1 非连续内存分配之分段与分页 </a> 介绍了非连续内存的分段与分页技术。那么，如何才能有效的实现逻辑地址到物理地址的转换机制呢？那就是通过页表。本文将介绍页表、快表 TLB、二级 &amp; 多级页表和反向页表，你将学习到如何进行地址转换，以及如何进一步高效的进行地址转换。</p>
<span id="more"></span>
<h2 id="页表">页表</h2>
<h3 id="页表概述">页表概述</h3>
<p>页表是操作系统中用于管理虚拟内存和物理内存之间 <strong> 映射关系 </strong> 的数据结构。它记录了虚拟地址和物理地址之间的对应关系，使得程序可以使用虚拟地址来访问物理内存，而无需关注具体的物理内存地址。</p>
<p>每一个运行的程序都有一个独立的页表：</p>
<ul>
<li>页表属于程序运行状态，会动态变化</li>
<li>PTBR（Page Table Base Register）：页表基址寄存器，用于存储页表的基地址，以指示当前使用的页表位置。</li>
</ul>
<h3 id="页表结构">页表结构</h3>
<p>页表其实就是一个大数组，它的索引 index 指的是 page-number（页号），索引对应的内容是 frame−number（帧号）。得到帧号后，再叠加上 offset（页帧内偏移）即可得到物理地址。</p>
<img src="/images/os-kernel/chapter4/page-table.png" alt="页表结构" width="80%" height="80%">
<p>页表中还有一些特殊标志位：</p>
<ul>
<li>dirty bit，脏位</li>
<li>resident bit，表示这个页表项是否合法（对应的物理地址中是否存在），0- 不存在，1- 存在</li>
<li>clock/reference bit，时钟 / 参考位</li>
</ul>
<p><strong>上图中 PTBR 的作用</strong>？</p>
<p>当程序访问虚拟内存时，CPU 会将虚拟地址发送给内存管理单元（MMU），MMU 根据页表进行地址转换。在这个过程中，CPU 会读取 PTBR 寄存器中的值，以确定当前使用的页表的位置。通过 <strong> 将虚拟地址的高位（即虚拟页号部分）与页表基地址相加，CPU 可以找到相应的表项，并进行地址转换</strong>，获取虚拟地址对应的物理地址。</p>
<blockquote>
<p>PTBR 的值通常在操作系统进行上下文切换时被修改，以切换不同的页表。这样，不同的进程可以拥有独立的页表，实现虚拟内存的隔离和保护。通过修改 PTBR，操作系统可以控制不同进程之间的地址空间映射关系，从而实现多进程共享物理内存的管理。</p>
</blockquote>
<h3 id="地址转换实例">地址转换实例</h3>
<p>具有 16 位地址的系统，具有：</p>
<ul>
<li>每页 1024 bytes，占用 10 位；帧号占用 6 位</li>
<li>物理内存大小为 2^6 * 1024 bytes = 64KB （图中应是 64KB）</li>
</ul>
<img src="/images/os-kernel/chapter4/address-translation.png" alt="地址转换实例" width="80%" height="80%">
<p>从图中可以了解到：</p>
<ul>
<li>
<p>对于二元组为 <code>(4, 0)</code> 的逻辑地址空间，它在页表中对应 <code>index = 4</code> 的那个页表项。可以看出，它对应的 resident bit 位的值为 0，表明这个页表项对应的物理地址不存在。这时请求访问物理内存，可能会造成 <strong> 内存访问异常（可能要杀死程序）</strong>。</p>
</li>
<li>
<p>对于二元组为 <code>(3, 1023)</code> 的逻辑地址空间，它在页表中对应 <code>index = 3</code> 的那个页表项。可以看出，它对应的 resident bit 位的值为 1，表明这个页表项对应的物理地址存在，对应的页帧号的二进制表示为 <code>00100</code>，则对应的物理内存地址为 <code>(4, 1023)</code> ，即 4x1024+1023=5119。</p>
</li>
</ul>
<h3 id="分页机制的性能问题">分页机制的性能问题</h3>
<p>进程访问一次内存单元，需要 2 次内存访问：</p>
<ul>
<li>一次用于获取页表项（通过页号查表获取页帧号）。</li>
<li>一次用于访问数据（访问物理内存的数据）。</li>
</ul>
<p>页表可能非常大：</p>
<ul>
<li>64 位的机器，如果每页 1024 字节，那么一个页表的大小是多少（有多少个页号）？
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup><mi mathvariant="normal">/</mi><msup><mn>2</mn><mn>10</mn></msup><mo>=</mo><msup><mn>2</mn><mn>54</mn></msup></mrow><annotation encoding="application/x-tex">2^{64} / 2^{10} = 2^{54}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span>，这么大的页表，在内存中是放不下的。</li>
</ul>
</li>
<li>每一个运行的程序都需要有一个页表。</li>
</ul>
<p>如何处理？</p>
<ul>
<li>缓存（Caching）：使用 CPU 内部的 TLB（使用相关存储器，可以进行并发的、高速的查询）。</li>
<li>间接（Indirection）访问：使用二级页表、多级页表。</li>
</ul>
<h2 id="快表（TLB）——解决时间问题">快表（TLB）——解决时间问题</h2>
<p>转换后备缓冲区（Translation Look-aside Buffer, TLB）是一种高速缓存，也叫快表，<strong>用于加快虚拟地址到物理地址的转换过程 </strong>。它是页表的一部分，<strong> 用于存储最近使用的虚拟页与物理页的映射关系，以减少对页表的访问次数，提高地址转换的效率</strong>。</p>
<img src="/images/os-kernel/chapter4/cpu-tlb.png" alt="快表" width="80%" height="80%">
<p>TLB 缓存近期访问的页帧转换表项：</p>
<ul>
<li>TLB 是一个小而快速的硬件缓存，使用关联内存（associative memory）实现，具备快速访问性能。每个 TLB 条目包含一个虚拟页号（VPN）和对应的物理页号（PPN），以及一些其他用于管理的标志位，如访问权限、脏位等。</li>
<li>如果 TLB 命中，物理页号可以很快被获取。</li>
<li>如果 TLB 未命中、缺失（TLB miss），对应的表项被更新到 TLB 中（该动作在 x86 的 CPU 中由硬件实现，其他的可能是由操作系统实现）。</li>
</ul>
<blockquote>
<p>当程序访问一个虚拟地址时，CPU 首先在 TLB 中查找对应的虚拟页号。如果找到了匹配的 TLB 条目，就可以直接从 TLB 中获取对应的物理页帧号，然后进行内存访问，无需访问页表。这个过程称为 TLB 命中。</p>
</blockquote>
<p>TLB 缺失会不会很频繁呢？</p>
<p>不会的。假如 32 位的系统，每页的大小为 4K 字节，如果该页的每一个地址都访问一次的话，需要 4K 次才会造成一次 TLB 缺失——因为从当前页首访问到当前页尾，下次访问时会是不同的逻辑页号，这个页号可能不在 TLB 表中。（这是假设情况，实际中 TLB 缺失的频率取决于许多因素，无法简单地通过每页的大小和访问次数来确定 TLB 缺失的频率）</p>
<h2 id="二级 - 多级页表——解决空间问题">二级 &amp; 多级页表——解决空间问题</h2>
<p>二级 &amp; 多级页表利用时间换空间，来解决页表的空间问题。</p>
<p>二级页表：</p>
<ol>
<li>将页号分为两个部分、页表分为两个，一级页号对应一级页表，二级页号对应二级页表；</li>
<li>一级页号查表获得在二级页表的起始地址，地址加上二级页号的值，在二级页表中获得帧号。</li>
</ol>
<p>二级页表节约了一定的空间 —— 在一级页表中如果 <code>resident bit=0</code>，则在二级页表中 <strong> 不存储 </strong> 相关 <code>index</code>，而只有一张页表的话，这一些 <code>index</code> 都需要保留。</p>
<img src="/images/os-kernel/chapter4/secondary-page-table.png" alt="二级页表" width="80%" height="80%">
<blockquote>
<p>二级页表就像是目录的目录，先找到一级目录，再在一级目录内找到二级目录。</p>
</blockquote>
<p>多级页表：</p>
<ul>
<li>通过把页号分为 <code>k</code> 个部分，来实现多级间接页表，建立一棵「页表树」。</li>
</ul>
<img src="/images/os-kernel/chapter4/multi-page-table.png" alt="多级页表" width="80%" height="80%">
<blockquote>
<p>多级页表就像是目录的目录的目录…</p>
</blockquote>
<h2 id="反向页表">反向页表</h2>
<p>有没有一种方法使得页表的大小与逻辑地址大小没有那么大的关系，尽量与物理地址大小建立对应关系？——反向页表</p>
<h3 id="什么是反向页表">什么是反向页表</h3>
<p>在操作系统中，反向页表（Inverted Page Table）是一种用于虚拟内存管理的数据结构。与传统的页表不同，<strong>传统的页表将虚拟页号映射到物理页帧号，而反向页表将物理页帧号映射到虚拟页号</strong>。</p>
<h3 id="反向页表的目的">反向页表的目的</h3>
<p>反向页表的目的是 <strong> 为了解决大型内存系统（地址的寻址空间非常大）中的页表大小太大（占用内存空间太大）和访问效率的问题</strong>。</p>
<h4 id="传统页表和多级页表的弊端">传统页表和多级页表的弊端</h4>
<p><strong>传统页表</strong>：<br>
在传统的页表中，每个进程都有自己的页表，而随着进程数量的增加和每个进程的逻辑地址空间的增大，页表的大小也会急剧增加。这样会导致内存开销大，并且访问页表的时间也会增加。</p>
<p><strong>多级页表</strong>：<br>
在大型内存系统（64-bits 系统）中，前向映射页表变得繁琐，比如：使用了 5 级页表。</p>
<h4 id="反向页表的优势">反向页表的优势</h4>
<p>在传统的页表中，每个进程都有自己的页表。而 <strong> 反向页表只有一张，它只需要为系统中的每个物理页帧分配一个表项，每个表项记录了该物理页帧所属的进程号（PID）和虚拟页号 </strong>。当进行地址转换时，<em> 操作系统只需通过物理页帧号查找反向页表，即可得到对应的进程号和虚拟页号</em>。这样就避免了每个进程都拥有一个独立的页表，大大减少了页表的大小。</p>
<p>也就是，<strong>反向页表的大小只跟物理地址空间的大小相对应，而与快速增长的虚拟地址空间的大小无关</strong>。</p>
<blockquote>
<p><em>操作系统只需通过物理页帧号查找反向页表，即可得到对应的进程号和虚拟页号</em>：（个人理解）只要遍历查找的虚拟页号和进程号，跟当前的进程的 PID 和虚拟页号匹配上了，那么就可以使用这个物理页帧号来获取对应的物理内存，并访问数据了。</p>
</blockquote>
<h3 id="基于页寄存器（Page-Registers）的方案">基于页寄存器（Page Registers）的方案</h3>
<h4 id="方案">方案</h4>
<p>页表中存储（页帧号，页号），使得页表大小与物理内存大小相关，而与逻辑内存关联减小。</p>
<img src="/images/os-kernel/chapter4/page-registers.png" alt="基于页寄存器的方案" width="80%" height="80%">
<p>每一个页帧和一个页寄存器关联，寄存器内容包括：</p>
<ul>
<li>使用位（resident bit）：此帧是否被进程占用</li>
<li>占用页号（occupier）：对应的页号 p</li>
<li>保护位（protection bits）：保护位</li>
</ul>
<h4 id="页寄存器空间占比">页寄存器空间占比</h4>
<p>有如下一个操作系统：</p>
<ul>
<li>页面大小：4096 bytes = 4KB</li>
<li>页帧数：4096 = 4K</li>
<li>物理内存大小：4096 * 4096 bytes = 4K * 4KB = 16MB</li>
</ul>
<p>则页寄存器使用的空间（假设 8 bytes/register）：8 bytes * 4096 = 32KB</p>
<ul>
<li>每一个页帧和一个页寄存器关联——页寄存器使用的空间即页表中所有页帧号对应页的页寄存器空间</li>
<li>页寄存器带来的额外内存开销占比：32KB / 16MB = 0.195%</li>
<li>虚拟内存大小：任意</li>
</ul>
<h4 id="优势">优势</h4>
<p>从上面的示例可以看出，基于页寄存器的方案有如下优势：</p>
<ul>
<li>转换表的大小相对于物理内存来说很小</li>
<li>转换表的大小跟逻辑地址空间的大小无关</li>
</ul>
<h4 id="劣势">劣势</h4>
<p>需要的信息对调了，即根据帧号可以找到页号。如何转换回来（如何根据页号找到页帧号）？</p>
<p>答：<strong>需要在反向页表中搜索想要的页号，才能得到对应的页帧号</strong>。</p>
<h3 id="基于关联内存（associative-memory）的方案">基于关联内存（associative memory）的方案</h3>
<p>就是在前面 TLB 中提到的相关存储器，并发的、高速的查询，效率很快。</p>
<p>该方案在设计上，页表中存储（页帧号，页号），而不是像 TLB 中存储（页号，页帧号）。</p>
<h4 id="劣势 -v2">劣势</h4>
<p>硬件设计太复杂，容量不可能做大，需要放置在 CPU 中。</p>
<p>在反向页表中搜索一个页对应的页帧号：</p>
<ul>
<li>如果帧数较少，页寄存器可以被放在关联内存中。</li>
<li>在关联内存中查找逻辑页号：
<ul>
<li>成功：页帧号被提取</li>
<li>失败：页错误异常（page fault）</li>
</ul>
</li>
<li>限制因素，大量的关联存储非常昂贵
<ul>
<li>难以在单个时钟周期内完成</li>
<li>耗电</li>
</ul>
</li>
</ul>
<h3 id="基于哈希（hash）的方案">基于哈希（hash）的方案</h3>
<p>基于哈希的方案可以有效缓解页帧号 - 页号的映射的开销，需要硬件帮助，但会出现哈希冲突。哈希冲突是指不同的页号可能映射到相同的页帧号，这会导致冲突和错误的映射。</p>
<h4 id="方案 -v2">方案</h4>
<p>在基于哈希的反向页表中，为了解决哈希冲突，可以利用进程的 <code>PID</code>，在哈希函数的基础上再加一个 <code>PID</code> 参数，标记当前运行程序的编号，根据 <code>hash(PID, p)</code> 哈希函数，算出当前进程的页号所对应的页帧号。</p>
<img src="/images/os-kernel/chapter4/hash-reverse-page-table.png" alt="基于哈希的方案" width="80%" height="80%">
<h4 id="映射过程">映射过程</h4>
<p>基于哈希的反向页表解决哈希冲突示意图（图中 vpn 表示虚拟页号，ppn 表示物理页帧号）：<br>
<img src="/images/os-kernel/chapter4/hash-reverse-page-table-hash-collisions.png" alt="基于哈希的反向页表解决哈希冲突" width="80%" height="80%"></p>
<p>上图为基于哈希的反向页表解决哈希冲突，并搜索一个页对应的页帧号的过程，可以按照以下步骤进行：</p>
<ol>
<li>
<p>对 <code>PID</code> 和页号做哈希计算 <code>hash(PID, p)</code>，并使用它作为页寄存器表的索引，获取对应的页寄存器内容。</p>
<ul>
<li>如果寄存器表项中包含 <code>p</code> 和 <code>PID</code>，则搜索成功，索引号就是页帧号；</li>
<li>如果寄存器表项中不包含 <code>p</code> 和 <code>PID</code>，说明存在哈希冲突。</li>
</ul>
</li>
<li>
<p>如果存在哈希冲突：</p>
<ul>
<li>在表项中寻找 <code>next</code> 提供的页寄存器索引，通过该索引，重复步骤 1，直到寄存器表项中包含 <code>p</code> 和 <code>PID</code> 为止。</li>
</ul>
</li>
<li>
<p>获取页帧号后，根据页帧号和页内偏移可以计算出虚拟地址映射的物理地址，并进行数据访问。</p>
</li>
</ol>
<blockquote>
<p>这样，即使存在哈希冲突，不同的进程会根据不同的 <code>PID</code> 选择不同的页帧号，从而避免了冲突和错误的映射。</p>
</blockquote>
<h4 id="劣势 -v3">劣势</h4>
<p>基于哈希的反向页表还是需要把反向页表放到内存中，做哈希计算时也需要到内存中取值。由于内存访问的时间开销较大，所以还需要有一个类似 TLB 的机制缓存起来，避免频繁地访问内存，提高寻址的效率。</p>
<h4 id="优势 -v2">优势</h4>
<p>目前来说，这种机制只在高端 CPU 中存在，好处：</p>
<ul>
<li>表的容量可以做的很小，只和物理空间关联</li>
<li>反向页表只有一张，它的大小只跟物理地址空间的大小相对应，所以它占的空间节省很多；但它是有代价的，它需要以一种很高速的哈希计算、硬件处理机制、高效函数以及解决冲突的机制才可以使访问的效率得到保障。这种机制由硬件、相应的操作系统软件配合，可以在空间和时间上取得比较好的结果。</li>
</ul>
<blockquote>
<p>参考资料：<br>
1：<a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a><br>
2：<a href="https://blog.csdn.net/weixin_53407527/article/details/124891795">https://blog.csdn.net/weixin_53407527/article/details/124891795</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>非连续内存分配</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>非连续内存分配</tag>
        <tag>页表</tag>
        <tag>反向页表</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter5.1 内存管理之覆盖技术与交换技术</title>
    <url>/posts/231123184526.html</url>
    <content><![CDATA[<p>这篇文章主要介绍操作系统的虚拟内存的起因，并对上世纪 80 年代流行的内存覆盖技术和内存交换技术进行回顾。同时，我们将在下一小节中给出虚拟内存管理技术——虚存技术。</p>
<span id="more"></span>
<h2 id="虚拟内存的起因">虚拟内存的起因</h2>
<p>理想中存储器：更大、更快、更便宜的非易失性存储器。</p>
<p>实际中，操作系统中存储器的层次结构：</p>
<table>
<thead>
<tr>
<th style="text-align:center">存储器层次结构</th>
<th style="text-align:center">典型访问时间</th>
<th style="text-align:center">典型容量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">寄存器（Register）</td>
<td style="text-align:center">1 nsec</td>
<td style="text-align:center">数 KB</td>
</tr>
<tr>
<td style="text-align:center">高速缓存（Cache）</td>
<td style="text-align:center">2 nsec</td>
<td style="text-align:center">数 MB</td>
</tr>
<tr>
<td style="text-align:center">主存储器（Main Memory）</td>
<td style="text-align:center">10 nsec</td>
<td style="text-align:center">数 GB</td>
</tr>
<tr>
<td style="text-align:center">硬盘、磁盘</td>
<td style="text-align:center">10 msec</td>
<td style="text-align:center">数 TB</td>
</tr>
<tr>
<td style="text-align:center">磁带</td>
<td style="text-align:center">100 sec</td>
<td style="text-align:center">数 TB</td>
</tr>
</tbody>
</table>
<p>使用硬盘 / 磁盘，使更多的程序可以在有限的内存中运行。</p>
<h2 id="解决内存不足的方法">解决内存不足的方法</h2>
<p><strong>在计算机系统中，尤其是在多道程序运行的环境下，可能会出现内存不够用的情况，怎么办</strong>？</p>
<ul>
<li>
<p>如果是 <strong> 程序太大 </strong>，超过了内存的容量，可以采用<strong> 手动的覆盖（overlay）技术</strong>，只把需要的指令和数据保存在内存当中；</p>
</li>
<li>
<p>如果是 <strong> 程序太多 </strong>，超过了内存的容量，可以采用<strong> 自动的交换（swapping）技术</strong>，把暂时不能执行的程序送到外存中；</p>
</li>
<li>
<p>如果想要在有限容量的内存中，以更小的页粒度为单位装入更多、更大的程序，可以采用 <strong> 自动的虚拟存储技术</strong>。</p>
</li>
</ul>
<h2 id="覆盖技术">覆盖技术</h2>
<h3 id="目标">目标</h3>
<p>是在较小的可用内存中运行较大的程序。常用于多道程序系统，与分区存储管理配合使用。</p>
<h3 id="原理">原理</h3>
<p>把程序按照其自身逻辑结构，划分为若干个功能上相互独立的程序模块，那些 <strong> 不会同时执行的模块共享同一块内存区域，按时间先后来加载、运行</strong>。</p>
<ul>
<li>
<p>必要部分（常用功能）的代码和数据，放在内存的常驻区；</p>
</li>
<li>
<p>可选部分（不常用功能）在其他程序模块中实现，平时存放在外存中，在需要用到时才装入内存；</p>
</li>
<li>
<p>不存在调用关系的模块不必同时装入到内存，从而可以相互覆盖，即这些模块共用一个分区。</p>
</li>
</ul>
<p>覆盖技术示例：<br>
<img src="../images/os-kernel/chapter5/overlay.png" alt="覆盖技术示例" width="60%" height="60%"></p>
<p>示例中，程序大小为 190K，而整个内存的大小才 110K，内存放不下这个程序。采用覆盖技术，将不会同时执行的模块放在同一个覆盖区（谁执行将谁放在覆盖区中，不执行的先暂存在外存中）。</p>
<p>因此不需要将整个程序 190k 的数据全部放入内存中，而是划分为：常驻区（20k） 覆盖区 0（50k） 覆盖区 1（40k） 压缩至了 110k 的内存空间使用。</p>
<p>另一种覆盖方式：A 在常驻区，B、E 和 F 在覆盖区 0，C 和 D 在覆盖区 1，这样可以压缩至 20 + 50 + 30 = 100K 的内存空间使用。</p>
<blockquote>
<p>程序串行执行，每次只会用到某个分区中的一个模块，不同的模块占用区域的时间不一样，所以可以往同一个分区存放。</p>
</blockquote>
<h3 id="缺点">缺点</h3>
<ul>
<li>需要由程序员来把一个大的程序划分为若干个小的功能模块，并确定各个模块之间的覆盖关系，费时费力，增加了编程的复杂度；</li>
<li>覆盖模块从外存装入内存，实际上是以时间延长来换取空间节省。</li>
</ul>
<h2 id="交换技术">交换技术</h2>
<h3 id="目的">目的</h3>
<p>多道程序在内存时，让正在运行的程序或需要运行的程序获得更多的内存资源。</p>
<h3 id="原理 -v2">原理</h3>
<ul>
<li>可将暂时不能运行的程序送到外存，从而获得空闲内存空间。</li>
<li>操作系统把一个进程的整个地址空间的内容保存到外存中（换出，swap out），而将外存中的某个进程的地址空间读入到内存中（换入，swap in）。
<ul>
<li>换入换出内容的大小为整个程序的地址空间。</li>
</ul>
</li>
</ul>
<blockquote>
<p>换入换出是通过操作系统的内存管理机制来完成的。操作系统会维护一个页表（page table），记录每个进程的虚拟内存和物理内存之间的映射关系。当一个进程被换出时，操作系统会将该进程的所有页面（包括代码、数据和堆栈）从内存复制到外存中的一个交换文件中。而当一个进程需要被换入时，操作系统会将该进程的所有页面从交换文件中复制回内存，并更新页面表中的映射关系。这样就可以实现进程的换入换出。</p>
</blockquote>
<p>交换技术示例：<br>
<img src="../images/os-kernel/chapter5/swap.png" alt="交换技术示例" width="60%" height="60%"></p>
<h3 id="缺点 -v2">缺点</h3>
<p>交换技术实现中的几个问题：</p>
<ul>
<li>
<p>交换时机的确定（何时需要发生交换）：只当内存空间不够或有不够的危险时，才进行换出操作；</p>
</li>
<li>
<p>交换区的大小：外存的交换区必须足够大，以存放所有用户进程的所有内存映像的拷贝，必须能够对这些内存映像进行直接存取；</p>
</li>
<li>
<p>程序换入时的重定位：换出后再换入的内存位置一定要在原来的位置上吗？不一定。最好采用动态地址映射的方法，否则寻址可能出现问题。</p>
<ul>
<li>动态地址映射：程序的虚拟地址一样，物理地址换入后不一样了，这没关系，靠页表映射解决就可以啦。</li>
</ul>
</li>
</ul>
<blockquote>
<p>交换技术是可以由操作系统帮助完成的，对于程序员来说是透明的，减轻了程序员的负担，但是系统的开销变大了。</p>
</blockquote>
<h2 id="覆盖技术与交换技术对比">覆盖技术与交换技术对比</h2>
<table>
<thead>
<tr>
<th style="text-align:center">特点</th>
<th style="text-align:center">覆盖技术</th>
<th style="text-align:center">交换技术</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">适用范围</td>
<td style="text-align:center">仅适用于没有调用关系的程序模块之间</td>
<td style="text-align:center">适用于任意进程之间</td>
</tr>
<tr>
<td style="text-align:center">逻辑覆盖结构</td>
<td style="text-align:center">需要程序员给出各个模块之间的逻辑覆盖结构</td>
<td style="text-align:center">不需要程序员给出各个模块之间的逻辑覆盖结构</td>
</tr>
<tr>
<td style="text-align:center">发生位置</td>
<td style="text-align:center">程序的内部</td>
<td style="text-align:center">内存中程序与管理程序 / 操作系统之间</td>
</tr>
<tr>
<td style="text-align:center">程序员负担</td>
<td style="text-align:center">增加程序员负担</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">处理器开销</td>
<td style="text-align:center">-</td>
<td style="text-align:center">增加处理器开销</td>
</tr>
<tr>
<td style="text-align:center">交换最小单位</td>
<td style="text-align:center">模块为单位</td>
<td style="text-align:center">进程为单位</td>
</tr>
</tbody>
</table>
<blockquote>
<p>参考资料：<br>
1：<a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a><br>
2：<a href="https://blog.csdn.net/weixin_53407527/article/details/124983180">https://blog.csdn.net/weixin_53407527/article/details/124983180</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>内存管理技术</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>覆盖技术</tag>
        <tag>交换技术</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter5.2 内存管理之虚存技术</title>
    <url>/posts/231127193658.html</url>
    <content><![CDATA[<p>在文章 <a href="https://pursue26.github.io/posts/231123184526.html"> 操作系统之 chapter5.1 虚拟内存管理之覆盖技术与交换技术 </a> 中，介绍了内存管理的覆盖技术和交换技术；这篇文章将介绍虚拟内存管理技术（虚存技术），它结合了覆盖技术和交换技术中的优点。</p>
<span id="more"></span>
<h1 id="虚拟内存管理技术">虚拟内存管理技术</h1>
<p>如果想要在有限容量的内存中，以 <strong> 更小的页粒度为单位 </strong> 装入更多、更大的程序，可以采用自动的虚拟存储技术。</p>
<h2 id="目标">目标</h2>
<ul>
<li>
<p>像覆盖技术那样，不是把程序的所有内容都放在内存中，因而能够运行比当前的空闲内存空间还要大的程序。但做的更好，由操作系统自动来完成，无需程序员的干涉。</p>
</li>
<li>
<p>像交换技术那样，能够实现进程在内存与外存之间的交换，因而获得更多的空闲内存空间。但做的更好，只对进程的部分内容在内存和外存之间进行交换。</p>
</li>
</ul>
<img src="/images/os-kernel/chapter5/memory-management.png" alt="操作系统内存管理" width="60%" height="60%">
<h2 id="程序局部性原理">程序局部性原理</h2>
<p>程序的局部性原理（principle of locality）：指程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定的区域。</p>
<ul>
<li>时间局部性：一条指令的一次执行和下次执行、一个数据的一次访问和下次访问都集中在一个较短时期内；</li>
<li>空间局部性：当前指令和邻近的几条指令、当前访问的数据和邻近的几个数据都集中在一个较小区域内。</li>
</ul>
<p>程序的局部性原理表明，从理论上来说，虚拟存储技术是能够实现的。而且在实现了以后应该是能够取得一个满意的效果。</p>
<h3 id="经典实例">经典实例</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目描述：</span></span><br><span class="line"><span class="comment">页面大小为 4KB，分配给每个进程的物理页面是 1。 </span></span><br><span class="line"><span class="comment">在一个进程中，定义了如下的二维数组 int arr[1024][1024]，该数组按行存放在内存，每一行放在一个页面中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">考虑一下程序的编写方法对缺页率的影响？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序编写方法 1：（发生了 1024*1024 次缺页中断）</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">1024</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">        arr[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序编写方法 2：（发生了 1024 次缺页中断）</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">1024</span>; j++) &#123;</span><br><span class="line">        arr[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为数组是「按行」存放在一块连续的内存中的，上面的二维数组每行有 1024 个元素（类型为 <code>int</code> 型），所以该数组的一行数据，占用 4K 字节，正好为一个物理页面的空间。</p>
<ul>
<li>方法一是按列访问的，即访问完第 0 列，再访问第 1 列，每列的不同行处在不同的物理页面中，因此会发生 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>102</mn><msup><mn>4</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">1024^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> 次缺页中断；</li>
<li>方法二是按行访问的，即访问完第 0 行，再访问第 1 行，访问的每行都是在同一个物理页面中，因此只会发生 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1024</mn></mrow><annotation encoding="application/x-tex">1024</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">4</span></span></span></span> 次缺页中断。</li>
</ul>
<h3 id="实例耗时测试">实例耗时测试</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">1024</span>][<span class="number">1024</span>];</span><br><span class="line">    <span class="type">clock_t</span> start, end;</span><br><span class="line">    <span class="type">double</span> cpu_time_used;</span><br><span class="line"></span><br><span class="line">    start = clock();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1024</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">            arr[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    end = clock();</span><br><span class="line">    cpu_time_used = ((<span class="type">double</span>)(end - start)) / CLOCKS_PER_SEC;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 代码执行耗时：%f 秒 \n&quot;</span>, cpu_time_used);</span><br><span class="line"></span><br><span class="line">    start = clock();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1024</span>; j++) &#123;</span><br><span class="line">            arr[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    end = clock();</span><br><span class="line">    cpu_time_used = ((<span class="type">double</span>)(end - start)) / CLOCKS_PER_SEC;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 代码执行耗时：%f 秒 \n&quot;</span>, cpu_time_used);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>连续运行三次的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost xxx]# ./a.out</span><br><span class="line">代码执行耗时：0.008293 秒 </span><br><span class="line"> 代码执行耗时：0.002611 秒 </span><br><span class="line">[root@localhost xxx]# ./a.out</span><br><span class="line"> 代码执行耗时：0.008260 秒 </span><br><span class="line"> 代码执行耗时：0.002613 秒 </span><br><span class="line">[root@localhost xxx]# ./a.out</span><br><span class="line"> 代码执行耗时：0.008252 秒 </span><br><span class="line"> 代码执行耗时：0.002575 秒</span><br></pre></td></tr></table></figure>
<h2 id="基本概念">基本概念</h2>
<p>可以在页式或段式内存管理的基础上实现虚拟内存管理技术。</p>
<ul>
<li>在装入程序时，不必将其全部装入内存，而只需将当前需要执行的部分页面（或段）装入到内存中，就可以让程序开始执行；</li>
<li>一方面，在程序执行过程中，如果需执行的指令或访问的数据尚未在内存中（称为缺页或缺段），则由 CPU 通知操作系统将相应的页面（或段）调入到内存，然后继续执行程序；</li>
<li>另一方面，操作系统将内存中暂时不使用的页面（或段）调出保存在外存上，从而腾出更多空闲内存空间，存放将要装入的程序以及将要调入的页面（或段）。</li>
</ul>
<h2 id="基本特征">基本特征</h2>
<ul>
<li><strong>大的用户空间</strong>：通过把物理内存和外存相结合，提供给用户的虚拟内存空间通常大于实际的物理内存，即实现了这两者的分离。
<ul>
<li>如 32 位的虚拟地址理论上可以访问 4GB，而可能计算机上仅有 256M 的物理内存，但硬盘容量大于 4GB。</li>
</ul>
</li>
<li><strong>部分交换</strong>：与交换技术相比较，虚拟存储的调入和调出是对部分虚拟地址空间进行的（交换粒度更小，效率更高）。</li>
<li><strong>不连续性</strong>：物理内存分配的不连续性，虚拟地址空间使用的不连续性。</li>
</ul>
<h2 id="页式内存管理">页式内存管理</h2>
<p>页表：完成逻辑页到物理页帧的映射。首先，根据页号查找页表对应的索引项；然后，查看该表项对应的 resident bit 的状态，1 表示映射关系存在，确定页帧号；最后，页帧号加上原来的页内偏移，即可获得物理地址。</p>
<blockquote>
<p>resident bit 的值为 0 表示虚拟地址对应的逻辑页当前不在内存中，而是在外存（磁盘）中存储。</p>
</blockquote>
<h2 id="虚拟页式内存管理">虚拟页式内存管理</h2>
<h3 id="实现">实现</h3>
<p>大部分虚拟存储系统都采用虚拟页式存储管理技术，即在页式存储管理的基础上，增加「请求调页」和「页面置换」两个功能。</p>
<h3 id="基本思路">基本思路</h3>
<ul>
<li>当一个用户程序要调入内存运行时，不是将该程序的所有页面都装入内存，而是只装入部分的页面，就可启动程序运行；</li>
<li>在程序运行过程中，如果发现要运行的程序或要访问的数据不在内存中，CPU 将发出缺页的中断请求，操作系统将处理这个中断——将外存中相应的页面调入内存，使得该程序能够继续运行。</li>
</ul>
<blockquote>
<p>页面置换功能实现的好坏决定了整体的效率，后面专门讲这些设计有效的置换算法。</p>
</blockquote>
<h3 id="页表表项">页表表项</h3>
<p>为了实现「请求调页」和「页面置换」功能，我们需要在页表表项中增加一些位 <code>bit</code> 来辅助实现。</p>
<p>页表表项示意图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">逻辑页号 | 访问位 | 修改位 |   保护位   | 驻留位 | 物理页帧号</span><br></pre></td></tr></table></figure>
<ul>
<li>驻留位：表示该页是在内存中还是在外存中。
<ul>
<li>值为 1 表示该页位于内存中，该页表表项有效，物理页帧可以被使用；</li>
<li>值为 0 表示当前页在外存中，访问该页表表项将导致缺页异常。</li>
</ul>
</li>
<li>保护位：表示允许对该页做何种类型的访问，如只读，可读写，可执行等。</li>
<li>修改位：表示此页在内存中是否被修改过。
<ul>
<li>当系统回收该物理页面时，根据此位来决定是否把物理页面的内容写回外存。</li>
</ul>
</li>
<li>访问位：如果该页被访问过（包括读写操作），则设置此位。
<ul>
<li>用于页面置换算法。</li>
</ul>
</li>
</ul>
<h3 id="缺页中断">缺页中断</h3>
<p>缺页中断处理过程：</p>
<ol start="0">
<li>产生缺页中断；</li>
<li>如果在内存中有空闲的物理页面，则分配一物理页帧 <code>f</code>，然后转第 4 步；否则转到第 2 步；</li>
<li>采用某种页面置换算法，选择一个将被替换的物理页帧 <code>f</code>，它所对应的逻辑页为 <code>q</code>。如果该页在内存期间被修改过，则需要把它写回外存；</li>
<li>对 <code>q</code> 所对应的页表项修改，把驻留位置为 <code>0</code>；</li>
<li>将需要访问的页 <code>p</code> 装入到物理页面 <code>f</code> 当中；</li>
<li>修改 <code>p</code> 所对应的页表项的内容，把驻留位置为 <code>1</code>，把物理页帧号置为 <code>f</code>；</li>
<li>重新运行被中断的指令。</li>
</ol>
<p>缺页中断操作系统处理流程：<br>
<img src="/images/os-kernel/chapter5/missing-page-interrupt.png" alt="缺页中断操作系统处理" width="60%" height="60%"></p>
<h3 id="后备存储（backing-store）">后备存储（backing store）</h3>
<p>系统在何处保存未被映射到物理内存中的页呢？</p>
<ul>
<li>能够简单地识别在二级存储器中的页</li>
<li>交换空间（磁盘或者文件）：特殊格式，用于存储未被映射的页面</li>
</ul>
<p>后背存储（二级存储）：一个虚拟地址空间的页面，可以被映射到一个文件（在二级存储中）的某个位置，以便在需要时重新加载到主存储器中。</p>
<p>在操作系统中，不同段可以被映射到不同的文件：</p>
<ul>
<li>代码段：映射到可执行二进制文件；</li>
<li>动态加载的共享库程序段：映射到动态调用的库文件；</li>
<li>其他段：可能被映射到交换文件（swap file）。</li>
</ul>
<blockquote>
<p>操作系统中一般会有主存储器（也称为一级存储器或内存）和辅助存储器（如硬盘、SSD 等）两种类型的存储设备。主存储器用于存储当前正在运行的进程和其所需的数据，而辅助存储器用于存储暂时不需要的进程或数据，辅助存储器也称为后背存储或二级存储。</p>
</blockquote>
<h3 id="虚拟内存性能分析">虚拟内存性能分析</h3>
<p>为了便于理解分页的开销，使用有效存储器访问时间（effective memory access time, EAT）来衡量。</p>
<p>EAT = 访存时间 * 页表命中几率 + page fault 处理时间 * page fault 几率</p>
<p>实例：</p>
<ul>
<li>访问物理内存时间：10 ns</li>
<li>磁盘访问时间：5 ms</li>
<li>参数 p = page fault 几率</li>
<li>参数 q = dirty page 几率</li>
</ul>
<p>则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>A</mi><mi>T</mi><mo>=</mo><mn>10</mn><mo>×</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo stretchy="false">)</mo><mo>+</mo><mn>5</mn><mo>⋅</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup><mo>×</mo><mi>p</mi><mo>×</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">EAT = 10 \times (1-p) + 5 \cdot 10^{6} \times p \times (1+q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span></p>
<p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">1 + q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 表示发生 dirty page 后需要将页面写回外存的耗时。</p>
<blockquote>
<p>dirty page 是指在计算机系统中的内存中的一个页面，其中的数据已经被修改，与磁盘上的对应页面的数据不同步。当进程对内存中的页面进行写操作时，该页面会被标记为“脏页”，表示该页面的数据已经被修改但尚未写回到磁盘。在后续的页面调度或内存回写操作中，操作系统会将脏页的数据写回到磁盘，以确保内存中的数据与磁盘上的数据保持一致性。这样可以防止数据丢失或不一致的情况发生。</p>
</blockquote>
<blockquote>
<p>参考资料：<br>
1：<a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a><br>
2：<a href="https://blog.csdn.net/weixin_53407527/article/details/124983180">https://blog.csdn.net/weixin_53407527/article/details/124983180</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>内存管理技术</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>虚存技术</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter6.1 局部页面置换算法</title>
    <url>/posts/231129182631.html</url>
    <content><![CDATA[<p>本文将介绍页面置换算法中的 <strong> 局部 </strong> 页面置换算法，包括最优页面置换算法（OPT）、先进先出页面置换算法（FIFO）、最近最少使用页面置换算法（LRU）、时钟页面置换算法（Clock）、二次机会页面置换算法（Enhanced Clock）和最不常用页面置换算法（LFU），并介绍了 Belady 现象。</p>
<span id="more"></span>
<h1 id="页面置换算法">页面置换算法</h1>
<h2 id="功能与目标">功能与目标</h2>
<ul>
<li>
<p>功能：当缺页中断发生，需要调入新的页面，而内存已满时，选择内存当中哪个物理页面被置换。</p>
</li>
<li>
<p>目标：尽可能地减少页面的换进换出次数（即缺页中断的次数）。具体来说，把 <strong> 未来 </strong> 不再使用的或短期内较少使用的页面换出，通常只能在局部性原理指导下 <strong> 依据过去的统计数据来进行预测</strong>。</p>
</li>
<li>
<p>页面锁定（frame locking）：用于描述必须常驻内存的操作系统的关键部分或时间关键（time-critical）的应用进程。</p>
<ul>
<li>实现方法：在页表中添加锁定标记位（lock bit）。</li>
</ul>
</li>
</ul>
<h2 id="实验设置与评价方法">实验设置与评价方法</h2>
<p>如何评价一个页面置换算法的优劣？</p>
<p>模拟一个页面置换的行为，并记录产生页缺失的数量。若有更少的缺失，则有更好的性能。</p>
<h1 id="局部页面置换算法">局部页面置换算法</h1>
<h2 id="最优页面置换算法（OPT）">最优页面置换算法（OPT）</h2>
<p>基本思路：当一个缺页中断发生时，对于保存在内存当中的每一个逻辑页面，计算在它的下一次访问之前，还需等待多长时间，从中选择等待时间最长的那个，作为被置换的页面。</p>
<p>缺点：这是一种理想情况，在实际系统中是 <strong> 无法实现 </strong> 的，因为操作系统无法知道每一个页面要等待多长时间以后才会再次被访问。</p>
<p>OPT 算法页面置换示例：<br>
<img src="../images/os-kernel/chapter6/opt-algorithm-demo.png" alt="最优页面置换算法" width="60%" height="60%"></p>
<p>如上图，在 <code>time=0</code> 的初始时刻，内存中有四个物理页 <code>a,b,c,d</code>。在访问到 <code>time=5</code> 时，程序需要访问物理页 <code>e</code>，但它在内存中不存在；从图中可以看到，接下来要访问的物理页分别是 <code>b,a,b,c,d</code>，物理页 <code>d</code> 是将来最长时间才被访问的物理页。所以，在访问物理页 <code>e</code> 时，<strong>最优解 </strong> 是将物理页 <code>d</code> 置换出去。但操作系统无法预知未来，所以这个算法无法实际应用。</p>
<blockquote>
<p>OPT 算法可用作其他算法的性能评价的依据（在一个模拟器上运行某个程序，并记录每一次的页面访问情况，在第二遍运行时即可使用最优算法）。</p>
</blockquote>
<h2 id="先进先出页面置换算法（FIFO）">先进先出页面置换算法（FIFO）</h2>
<p>基本思路：选择在内存中驻留时间最长的页面淘汰。具体来说，系统维护着一个链表，记录了所有位于内存中的逻辑页面。从链表的排列顺序来看，链首页面的驻留时间最长，链尾页面的驻留时间最短。<strong>当发生一个缺页中断时，把链首页面淘汰出去，并把新的页面添加到链表的末尾</strong>。</p>
<blockquote>
<p>如果访问一个页面时，没有产生缺页中断，这时链表会有何动作？<br>
会遍历链表，找出对应的逻辑页面，将它从链表内部删除，并添加在链表尾部（让该页面刷新为驻留时间最短的页面）。</p>
</blockquote>
<p>缺点：涉及到链表遍历，性能较差，置换出的页面有可能是经常要访问的页面，并且有 Belady 现象。FIFO 算法很少单独使用。</p>
<p>FIFO 算法页面置换示例（初始时，假设链表首部为页面 <code>a</code>，尾部为页面 <code>d</code>）：<br>
<img src="../images/os-kernel/chapter6/fifo-algorithm-demo.png" alt="先进先出页面置换算法" width="60%" height="60%"></p>
<h2 id="最近最少使用页面置换算法（LRU）">最近最少使用页面置换算法（LRU）</h2>
<p>基本思路：最近最少使用页面置换算法（Least Recently Used, LRU），当一个缺页中断发生时，选择 <strong> 最近最久未使用 </strong> 的那个页面淘汰。</p>
<p><strong>LRU 算法是对 OPT 算法的一个近似</strong>，其依据是程序的局部性原理，即在最近一小段时间（最近几条指令）内，如果某些页面被频繁地访问，那么在将来的一小段时间内，它们还可能会再一次被频繁地访问。反过来说，如果过去某些页面长时间未被访问，那么在将来它们可能会继续得不到访问。</p>
<p>LRU 算法页面置换示例：<br>
<img src="../images/os-kernel/chapter6/lru-algorithm-demo.png" alt="最近最少使用页面置换算法" width="60%" height="60%"></p>
<blockquote>
<p>LRU 算法需要记录各个页面使用时间的先后顺序，开销比较大。</p>
</blockquote>
<p>该算法两种可能的实现方法是：</p>
<ol>
<li>
<p>系统维护一个页面链表，最新使用过的页面作为首结点，最久未使用的作为尾结点。</p>
<ul>
<li>每一次访问内存时，找出相应的页面，把它从链表中摘下来，再移动到链表的首部；</li>
<li>每次缺页中断发生时，总是淘汰链表末尾的页面，它就是最久未使用的。</li>
</ul>
</li>
<li>
<p>设置一个活动页面栈，栈顶存储最新使用过的页面的页号，栈底存储最久未使用过的页面的页号。</p>
<ul>
<li>当访问某页时，将此页号压入栈顶，并考察栈内是否有与此页面相同的页号，若有则抽出</li>
<li>每次缺页中断发生时，总是淘汰栈底的页面，它就是最久未使用的。</li>
</ul>
</li>
</ol>
<blockquote>
<p>这两种实现在查找某一个页面是否在链表（或栈）中时，都是线性时间复杂度，效率低。<a href="https://pursue26.github.io/posts/231201184542.html">LeetCode 刷题之 146LRU 缓存 </a> 中给出了一种常数时间复杂度的设计，它使用了双向链表 + 哈希表来实现。</p>
</blockquote>
<h2 id="时钟页面置换算法（Clock）">时钟页面置换算法（Clock）</h2>
<blockquote>
<p>Clock 算法是对 LRU 算法的近似，对 FIFO 算法的一种改进。</p>
</blockquote>
<p>基本思想：借助页表项的访问位（access bit），当一个页面被装入内存时，把该位重置为 <code>0</code>，如果这个页面后续被访问（读 / 写操作），则硬件（软件也能置位）把该位置为 <code>1</code>。</p>
<p>在设计上，把各个页面组织成 <strong> 环形链表（类似钟的表面）</strong>，把指针指向最老（最先进来）的页面。当发生缺页中断时，考察指针所指向的最老页面：</p>
<ul>
<li>若它的访问位为 <code>0</code>，则可以立即淘汰；
<ul>
<li>解释：也就是在内存中，但没有被访问过。</li>
</ul>
</li>
<li>若访问位为 <code>1</code>，则将访问位置为 <code>0</code>，然后指针往下移动一格；
<ul>
<li>解释：它是最老的页面，但是被访问过，那就先不淘汰它，如果后续没有未访问过的页面的话，则指针会转一圈再回来，并把它淘汰。</li>
</ul>
</li>
<li>如此下去，直到找到被淘汰的页面，然后把指针移动到下一格。</li>
</ul>
<p>Clock 算法页面置换示意图（used bit 即 access bit）：<br>
<img src="../images/os-kernel/chapter6/clock-algorithm.png" alt="时钟页面置换算法" width="60%" height="60%"></p>
<p>在上图中，维持一个保存在内存中环形页面链表。初始时，假设 resident bit 都为 1，也就是虚拟页对应的物理页面存在；图中指针顺时针移动，下次将被替换的页面为 Page 1。</p>
<p>Clock 算法页面置换示例：<br>
<img src="../images/os-kernel/chapter6/clock-algorithm-demo.png" alt="时钟页面置换算法" width="60%" height="60%"></p>
<blockquote>
<p>上图的置换流程可以参考上面的文字和伪代码。</p>
</blockquote>
<h2 id="改进型的时钟页面置换算法（Enhanced-Clock）">改进型的时钟页面置换算法（Enhanced Clock）</h2>
<p>改进型的时钟页面置换算法，又可称为二次机会算法。</p>
<p>改进原因：因为考虑到时钟页面置换算法，有时候会把一些 dirty bit 为 1（有过写操作）的页面进行置换，这需要把页面写回外存中（而非直接释放），代价会比较大。因此，可以结合 access bit 和 dirty bit，共同决定应该置换哪一页。</p>
<p>换句话说，当页面替换时，可以按照如下的优先级规则进行：</p>
<table>
<thead>
<tr>
<th style="text-align:center">优先级</th>
<th style="text-align:center">access</th>
<th style="text-align:center">dirty</th>
<th style="text-align:center">替换次数</th>
<th style="text-align:center">置位结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">直接替换</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">一次机会</td>
<td style="text-align:center">(0, 0)</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">一次机会</td>
<td style="text-align:center">(0, 0)</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">两次机会</td>
<td style="text-align:center">(0, 1)</td>
</tr>
</tbody>
</table>
<p>根据这个优先级规则，替换时会优先选择优先级较低的页面进行替换，以提高缓存的命中率。</p>
<blockquote>
<p>两次机会时，优先重置 access bit 位。</p>
</blockquote>
<p>改进型 Clock 算法页面置换示例：<br>
<img src="../images/os-kernel/chapter6/enhanced-clock-algorithm-demo.png" alt="改进型时钟页面置换算法" width="60%" height="60%"></p>
<p>在上图中，当 <code>time=4</code> 时刻结束时，内存的 4 个页面均被访问，但是仅有页面 <code>a</code> 和页面 <code>b</code> 被写过，在 <code>time=5</code> 时，根据上述优先级规则，页面 <code>a</code> 和页面 <code>b</code> 有两次机会，页面 <code>c</code> 和页面 <code>d</code> 有一次机会，最后指针会指向页面 <code>c</code> 进行置换，然后指针往下移动一格。</p>
<blockquote>
<p>弹幕中看到大家的两个问题，这个给机会的过程，会将 dirty bit 从 1 重置为 0，那么：<br>
1）被写过的页面，是什么时候写回外存中去的？是每次从 1 重置为 0 后，就随即写回外存，还是本次页面换出时才会写回外存（如果是这种，其它重置为 0 的页面，还怎么知道它有没有被写过）？<br>
2）这里的 access bit 和 dirty bit 的修改是否是直接修改的页表中对应的位？</p>
</blockquote>
<h2 id="最不常用页面置换算法（LFU）">最不常用页面置换算法（LFU）</h2>
<p>基本思路：最不常用页面置换算法（Least Frequently used, LFU），当一个缺页中断发生时，选择 <strong> 访问次数最少 </strong> 的那个页面，并淘汰。</p>
<p>实现方法：对每一个页面设置一个访问计数器，每当一个页面被访问时，该页面的访问计数器加 1。 当发生缺页中断时，淘汰计数值最小的那个页面。</p>
<p>LRU 和 LFU 的对比：LRU 考察的是 <strong> 多久未访问 </strong>，时间越短越好（不会被置换出去）；而 LFU 考察的是<strong> 访问的次数或频度</strong>，访问次数越多越好。</p>
<p>LFU 算法页面置换示例：<br>
<img src="../images/os-kernel/chapter6/lfu-algorithm-demo.png" alt="最不常用页面置换算法" width="60%" height="60%"></p>
<blockquote>
<p>问题：<br>
一个页面在进程开始时使用得很多，但以后就不使用了，LFU 统计的是整体的访问次数，所以此时这个页面还会被保留在内存中。<br>
实现也费时费力，需要对每一个页面加一个计数器。</p>
<p>解决方法：<br>
定期把次数寄存器右移一位。它最主要的问题是只考虑频率而没考虑时间，我们可以隔一段时间砍掉一半的次数，进而改善这个问题。</p>
</blockquote>
<h2 id="Belady 现象">Belady 现象</h2>
<p>在采用 FIFO 算法时，有时会出现在分配的物理页面数增加，缺页率反而提高的异常现象。</p>
<p>原因：FIFO 算法的置换特征与进程访问内存的动态特征是矛盾的，它仅仅按照页面进入内存的顺序进行替换，与置换算法的目标（即替换较少使用的页面）是不一致的，因此，被它置换出去的页面不一定是进程不会访问的。</p>
<blockquote>
<p>Belady 是一个科学家的名字。</p>
</blockquote>
<p>时钟、改进型的时钟页面置换是否有 Belady 现象？</p>
<ul>
<li>没有。</li>
</ul>
<p>为什么 LRU 页面置换算法没有 Belady 现象？</p>
<ul>
<li>简单解释：LRU 符合一类叫称之为「栈算法」的特点。</li>
</ul>
<h1 id="总结与比较">总结与比较</h1>
<h2 id="局部页面算法汇总">局部页面算法汇总</h2>
<table>
<thead>
<tr>
<th>算法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>最优页面置换算法 (OPT)</td>
<td>选择未来最长时间内不再被访问的页面进行置换。</td>
</tr>
<tr>
<td>先进先出页面置换算法 (FIFO)</td>
<td>最早进入内存的页面被置换出去。</td>
</tr>
<tr>
<td>最近最久未使用页面置换算法 (LRU)</td>
<td>根据页面最近被访问的时间进行置换，最久未被使用的页面被置换出去。</td>
</tr>
<tr>
<td>时钟页面置换算法 (Clock)</td>
<td>使用一个指针按顺序扫描页面，如果找到一个未被使用的页面，则置换出去；否则，将指针指向的页面标记为未使用。</td>
</tr>
<tr>
<td>二次机会页面置换算法 (Second-Chance)</td>
<td>类似于时钟算法，但是给予页面第二次机会，如果页面被访问或被写入过，则将其标记为未访问或未被写入，否则置换出去。</td>
</tr>
<tr>
<td>最不常用页面置换算法 (LFU)</td>
<td>根据页面被访问的频率进行置换，最不常被使用的页面被置换出去。</td>
</tr>
</tbody>
</table>
<h2 id="LRU、FIFO 和 Clock 比较">LRU、FIFO 和 Clock 比较</h2>
<table>
<thead>
<tr>
<th style="text-align:center">算法</th>
<th>原理</th>
<th>性能</th>
<th>开销</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">LRU</td>
<td>根据最近访问时间排序页面，动态调整页面顺序</td>
<td>性能较好</td>
<td>系统开销较大</td>
</tr>
<tr>
<td style="text-align:center">FIFO</td>
<td>根据进入时间排序页面，顺序固定不变</td>
<td>可发生 Belady 现象</td>
<td>开销较小</td>
</tr>
<tr>
<td style="text-align:center">Clock</td>
<td>不动态调整页面顺序，仅做标记，缺页时移动到链表末尾</td>
<td>性能适中</td>
<td>系统开销适中</td>
</tr>
</tbody>
</table>
<ul>
<li>LRU 算法可退化为 FIFO 算法。</li>
<li>Clock 算法是对 LRU 算法和 FIFO 算法的折中，不能记录精确访问顺序，可退化为 FIFO 算法。</li>
</ul>
<p>从算法的退化可以看出，不同的算法只是页面替换的一个环节，<strong>如果要有效减少缺页产生的次数，除了算法本身之外，我们还要对访问序列有一定的要求，访问序列最好是具有局部性的访问特征</strong>，那么 LRU、Clock 算法才会发挥特征，如果序列不具有局部性，那么 LRU、Clock、FIFO 就没什么区别了。</p>
<blockquote>
<p>参考资料：<br>
1：<a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a><br>
2：<a href="https://blog.csdn.net/weixin_53407527/article/details/125008097">https://blog.csdn.net/weixin_53407527/article/details/125008097</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>局部页面置换算法</category>
      </categories>
      <tags>
        <tag>页面置换算法</tag>
        <tag>操作系统</tag>
        <tag>局部页面置换算法</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter6.2 全局页面置换算法</title>
    <url>/posts/231207184239.html</url>
    <content><![CDATA[<p>本文将介绍页面置换算法中的 <strong> 全局 </strong> 页面置换算法。首先，介绍了局部页面置换算法的局限性；然后，介绍了工作集模型和工作集、常驻集；最后，介绍了两个全局页面置换算法——工作集页面置换算法和缺页率页面置换算法。</p>
<span id="more"></span>
<h1 id="局部置换算法的问题">局部置换算法的问题</h1>
<h2 id="物理页帧分配角度">物理页帧分配角度</h2>
<p>假设一：<br>
给一个程序分配了一个大小固定为 3 的物理页帧（如 <code>a, b, c</code>），而现在程序 A 需要访问 <code>a, b, c, d, a, b, c, d, ...</code> 的物理页帧。那么，在使用 FIFO 页面置换算法的情况下，从时刻 4（第一次访问 <code>d</code>）开始，每一次访问都会产生一个缺页中断。</p>
<p>假设二：<br>
给一个程序分配了一个大小固定为 4 的物理页帧（如 <code>a, b, c, b</code>），而现在程序 B 需要访问 <code>a, b, c, d, a, b, c, d, ...</code> 的物理页帧。那么，在使用 FIFO 页面置换算法的情况下，不会产生缺页中断。</p>
<p>由此可以看出：<strong>物理页帧的大小确实会对同一个页面置换算法的效果产生很大影响</strong>。这说明，如果对一个程序分配固定的物理页帧、使用指定页面置换算法，其实在某种程度上限制了程序产生缺页的灵活性。</p>
<h2 id="程序内存访问角度">程序内存访问角度</h2>
<p>因为程序在运行过程中可能会有阶段性，它可能一开始访问需要很多内存，中间时候需要很少，结束的时候又需要很多，它是 <strong> 动态变化 </strong> 的过程，它 <strong> 对物理页帧的需求是可变的</strong>。</p>
<p><strong>在局部页面置换算法中，都是假定物理页帧是固定的 </strong>，如果一个系统只跑这一个程序，那我可以把所有物理页帧都分给它；而操作系统可以跑多个程序，这时再给每个程序分配固定的页帧，其实就限制了灵活性，我们能不能根据程序的不同阶段给它动态分配，调整它物理页帧的大小，<strong> 这实际上就是全局页面置换算法所考虑的问题</strong>。</p>
<h2 id="全局 -Vs- 局部">全局 Vs. 局部</h2>
<table>
<thead>
<tr>
<th>算法</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>局部置换算法</td>
<td>- 不考虑进程的访存差异<br>- 固定分配物理页帧，限制了程序的灵活性<br>- 适用于单个程序运行的情况</td>
</tr>
<tr>
<td>全局置换算法</td>
<td>- 考虑进程的访存差异<br>- 动态调整物理页帧的大小，根据程序的不同阶段进行分配<br>- 适用于多个程序运行的情况</td>
</tr>
</tbody>
</table>
<h1 id="全局置换算法要解决的问题">全局置换算法要解决的问题</h1>
<p>进程在不同阶段的内存需求是变化的，这就需要解决以下问题：</p>
<ul>
<li>分配给进程的内存也需要在不同阶段有所变化；</li>
<li>全局置换算法需要确定分配给进程的物理页面数；</li>
</ul>
<h1 id="工作集与常驻集">工作集与常驻集</h1>
<h2 id="工作集模型">工作集模型</h2>
<p>前面介绍的各种局部页面置换算法，都是基于一个前提，即 <strong> 程序的局部性原理</strong>。但是此原理是否成立？</p>
<ul>
<li>如果局部性原理不成立，那么各种页面置换算法就没有什么分别，也没有什么意义。例如：假设进程对逻辑页面的访问顺序是 <code>1,2,3,...</code>，即单调递增，那么在物理页面数量有限的前提下，不管采用何种置换算法，每次的页面访问都必然导致缺页中断。</li>
<li><strong>如果局部性原理是成立的，那么如何来证明它的存在，如何来对它进行定量地分析？这就是工作集模型</strong>！</li>
</ul>
<h2 id="工作集">工作集</h2>
<h3 id="什么是工作集">什么是工作集</h3>
<p>工作集：一个进程当前（过去一段时间内）正在使用的逻辑页面集合，可表示为二元函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo stretchy="false">(</mo><mi>t</mi><mo separator="true">,</mo><mi mathvariant="normal">Δ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">W(t, \Delta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Δ</span><span class="mclose">)</span></span></span></span>。</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span> 是当前的执行时刻；</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span> 称为工作集窗口（working-set window），即一个定长的页面访问时间窗口；</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo stretchy="false">(</mo><mi>t</mi><mo separator="true">,</mo><mi mathvariant="normal">Δ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">W(t, \Delta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Δ</span><span class="mclose">)</span></span></span></span> 是指 <strong> 在当前时刻 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span> 前的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span> 时间窗口中的所有访问页面所组成的集合</strong>；</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>W</mi><mo stretchy="false">(</mo><mi>t</mi><mo separator="true">,</mo><mi mathvariant="normal">Δ</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|W(t, \Delta)|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Δ</span><span class="mclose">)</span><span class="mord">∣</span></span></span></span> 指工作集的大小，即页面数目。</li>
</ul>
<h3 id="工作集示例">工作集示例</h3>
<p>假设一个进程有如下的页面访问顺序，工作集窗为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">\Delta = 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 6 1 5 7 7 7 7 5 1 6 3 4 4 4 3 4 3 4 4 4 1 3 2 7</span><br><span class="line">                   |                     |</span><br><span class="line">&lt;---- Delta ----&gt; t1  &lt;---- Delta ----&gt; t2</span><br></pre></td></tr></table></figure>
<ul>
<li>在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 时刻的工作集为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo stretchy="false">(</mo><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">Δ</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>7</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">W(t_{1}, \Delta) = \{1,2,5,6,7\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Δ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mclose">}</span></span></span></span>。</li>
<li>在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">t_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 时刻的工作集为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo stretchy="false">(</mo><msub><mi>t</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">Δ</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">W(t_{2}, \Delta) = \{3,4\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Δ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">}</span></span></span></span>。</li>
</ul>
<h3 id="工作集访问与程序访问的关联">工作集访问与程序访问的关联</h3>
<ul>
<li>工作集大小的变化：进程开始执行后，随着访问新页面逐步建立较稳定的工作集。</li>
<li><strong>当内存访问的局部性区域的位置大致稳定时，工作集大小也大致稳定</strong>。</li>
<li><strong>局部性区域的位置改变时，工作集快速扩张和收缩，并过渡到下一个稳定值</strong>。</li>
</ul>
<img src="/images/os-kernel/chapter6/working-set.png" alt="工作集变化曲线" width="60%" height="60%">
<h2 id="常驻集">常驻集</h2>
<p>常驻集：在当前时刻（那一瞬间），进程实际驻留在内存当中的页面集合。</p>
<p>工作集与常驻集的关系：</p>
<ul>
<li>工作集是进程在运行过程中固有的性质。</li>
<li>常驻集取决于系统分配给进程的物理页面数目和页面置换算法。</li>
</ul>
<p>缺页率与工作集、常驻集的关系：</p>
<ul>
<li>常驻集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊇</mo></mrow><annotation encoding="application/x-tex">\supseteq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">⊇</span></span></span></span> 工作集时，即一个进程的整个工作集都在内存当中时，缺页较少；</li>
<li>工作集发生剧烈变动（过渡）时，缺页较多；</li>
<li>进程常驻集大小达到一定数目后，再给它分配更多的物理页面，缺页率也不会明显下降。</li>
</ul>
<h1 id="全局页面置换算法">全局页面置换算法</h1>
<h2 id="工作集页面置换算法（Working-set）">工作集页面置换算法（Working-set）</h2>
<p><strong>窗口大小</strong>：当前时刻前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span> 个内存访问的页引用是工作集，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span> 被称为窗口大小。</p>
<p><strong>思路</strong>：在每次的内存访问时，换出不在工作集窗口范围内的页面。</p>
<p><strong>实现方式</strong>：维护工作集窗口内的访存页面链表（访存链表）。</p>
<ul>
<li>在访存时，换出不在工作集的页面，更新访存链表；</li>
<li>在缺页时，换入页面，更新访存链表。</li>
</ul>
<p>工作集页面置换算法示例：</p>
<img src="/images/os-kernel/chapter6/working-set-algorithm-demo.png" alt="工作集页面置换算法示例" width="60%" height="60%">
<p>上图中，在时刻 0，程序已经访问了内存中的 <code>e, d, a</code> 三个物理页面，假设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">\Delta = 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>，此时的工作集为 <code>&#123;e, d, a&#125;</code>：</p>
<ul>
<li>在时刻 1，访存 <code>c</code> 不在工作集中，产生缺页中断，换入页面 <code>c</code>，工作集更新为 <code>&#123;e, d, a, c&#125;</code>；</li>
<li>在时刻 2，访存 <code>c</code> 在工作集中，工作集更新为 <code>&#123;d, a, c&#125;</code>；</li>
<li>在时刻 3，访存 <code>d</code> 在工作集中，工作集更新为 <code>&#123;a, c, d&#125;</code>；</li>
<li>在时刻 4，访存 <code>b</code> 不在工作集中，产生缺页中断，换入页面 <code>b</code>，工作集更新为 <code>&#123;c, d, b&#125;</code>；</li>
<li>…</li>
</ul>
<p>可以看出：</p>
<ul>
<li>工作集窗口在滑动过程中，<strong>如果页面不再在工作集的窗口范围内，则会直接淘汰这个窗口，而不会等待缺页中断产生才淘汰</strong>。</li>
<li>在缺页时，会换入页面，但是更新后的工作集的页面，除了新增的换入页面外，工作集中的页面不一定会改变（因为可能换出了页面 X，但窗口内还有页面 X）。</li>
</ul>
<p><strong>工作集页面置换算法的特点</strong>：</p>
<p>工作集页面置换算法 <strong> 在当前物理内存中放哪些页，取决于是否在工作集窗口之内 </strong>。这样可以确保在物理内存中始终有足够多的页存在，以便为其他运行程序提供更多的内存空间，进一步减少页面置换的次数。通过减少页面置换次数，可以降低多个程序的缺页数，<strong> 提高系统的整体性能</strong>。</p>
<h2 id="缺页率页面置换算法（PFF）">缺页率页面置换算法（PFF）</h2>
<p><strong>可变分配策略：常驻集大小可变</strong>。例如：每个进程在刚开始运行的时候，先根据程序大小给它分配一定数目的物理页面，然后在进程运行过程中，再动态地调整常驻集的大小。</p>
<ul>
<li>可 <strong> 采用全局页面置换的方式</strong>，当发生一个缺页中断时，被置换出的页面可以是其他进程中的页面，各个并发进程竞争地使用物理页面。</li>
<li>优缺点：性能较好，但增加了系统开销。</li>
<li>具体实现：可以 <strong> 使用缺页率算法（PFF，page fault frequency）来动态调整常驻集的大小</strong>。</li>
</ul>
<p><strong>缺页率（page fault rate）</strong>：表示「缺页次数 / 内存访问次数」或 「缺页平均时间间隔的倒数」。</p>
<p>缺页率置换算法通过动态调整常驻集大小，使每个进程的缺页率保持在一个合理的范围内。</p>
<ul>
<li>若进程缺页率过高，则增加常驻集以分配更多的物理页面；</li>
<li>若进程缺页率过低，则减少常驻集以减少它的物理页面数。</li>
</ul>
<p><strong>影响缺页率的因素</strong>：</p>
<ul>
<li>页面置换算法</li>
<li>分配给进程的物理页面数目</li>
<li>页面本身的大小</li>
<li>程序的编写方法</li>
</ul>
<p><strong>算法实现</strong>：保持追踪缺失发生概率，设预定的缺页时间阈值为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>。</p>
<ul>
<li>访存时，设置引用位（access bit）标志；</li>
<li>缺页时，计算从上次缺页时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{last}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 到现在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{current}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的时间间隔：
<ul>
<li>如果发生页缺失之间的时间是「大」的，之后减少常驻集：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow></msub><mo>−</mo><msub><mi>t</mi><mrow><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi></mrow></msub><mo>&gt;</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">t_{current}-t_{last}&gt; T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>，则置换出所有在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msub><mi>t</mi><mrow><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi></mrow></msub><mo separator="true">,</mo><msub><mi>t</mi><mrow><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[t_{last}, t_{current}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 时间内没有被引用的页，并增加缺失页到常驻集中。换句话说，就是只保留在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msub><mi>t</mi><mrow><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi></mrow></msub><mo separator="true">,</mo><msub><mi>t</mi><mrow><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[t_{last}, t_{current}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 时间内被引用的页面。</li>
<li>如果这个发生页缺失的时间是「小」的，之后增加常驻集：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow></msub><mo>−</mo><msub><mi>t</mi><mrow><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi></mrow></msub><mo>⩽</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">t_{current}-t_{last}\leqslant T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.78667em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>，则增加缺失页到常驻集中。</li>
</ul>
</li>
</ul>
<img src="/images/os-kernel/chapter6/pff-algorithm-demo.png" alt="缺页率页面置换算法示例" width="60%" height="60%">
<p>在上图中，时刻 <code>0</code> 的常驻集为 <code>&#123;a, d, e&#125;</code>：</p>
<ul>
<li>在时刻 <code>1</code> 时，页面 <code>c</code> 不在常驻集中，且为首次发生缺页，则增加缺失页到常驻集中，当前的常驻集为 <code>&#123;a, c, d, e&#125;</code>；</li>
<li>在时刻 <code>2, 3</code> 时，页面 <code>c, d</code> 都在常驻集中，没有发生缺页，当前的常驻集为 <code>&#123;a, c, d, e&#125;</code>；</li>
<li>在时刻 <code>4</code> 时，页面 <code>b</code> 不在常驻集中，发生缺页，且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow></msub><mo>−</mo><msub><mi>t</mi><mrow><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi></mrow></msub><mo>=</mo><mn>4</mn><mo>−</mo><mn>1</mn><mo>&gt;</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">t_{current}-t_{last} = 4 - 1 &gt; T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>，则增加缺失页到常驻集中、只保留在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>4</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">]</span></span></span></span> 之间被引用的页面，当前的常驻集 <code>&#123;c, d, b&#125;</code>；</li>
<li>…</li>
</ul>
<blockquote>
<p>我个人觉得图片中的「工作集」应该是「常驻集」，所以文字描述中，也叙述成了「常驻集」。</p>
</blockquote>
<h1 id="内存抖动问题（thrashing）">内存抖动问题（thrashing）</h1>
<p><strong>什么是内存抖动</strong>？</p>
<p>如果分配给一个进程的物理页面太少，不能包含整个的工作集，即常驻集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊂</mo></mrow><annotation encoding="application/x-tex">\subset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">⊂</span></span></span></span> 工作集。那么，进程将会造成很多的缺页中断，需要频繁的在内存与外存之间替换页面，从而使进程的运行速度变得很慢，我们把这种状态称为「抖动」。</p>
<p><strong>产生抖动的原因</strong>？</p>
<p>进程过多：随着驻留内存的进程数目增加，分配给每个进程的物理页面数不断就减小，缺页率不断上升，从而产生抖动。</p>
<p><strong>内存抖动为什么会导致系统性能下降</strong>？</p>
<p>内存抖动导致系统性能下降的原因是因为频繁的页面置换会引起磁盘 I/O 的开销，这是一个相对较慢的操作。此外，频繁的页面置换还会导致 CPU 时间被浪费在页面置换和上下文切换上，从而降低了系统的吞吐量。</p>
<p><strong>如何改善内存抖动</strong>？</p>
<p>操作系统需要在并发水平和缺页率之间达到一个平衡，这需要调整进程的内存分配策略：选择一个恰当的并发进程数量，并为每个进程分配恰当的物理页面数（可以使用动态页面分配算法，根据进程的实时需求动态调整页面的分配情况）。</p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a></li>
<li><a href="https://blog.csdn.net/weixin_53407527/article/details/125008097">https://blog.csdn.net/weixin_53407527/article/details/125008097</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>全局页面置换算法</category>
      </categories>
      <tags>
        <tag>页面置换算法</tag>
        <tag>操作系统</tag>
        <tag>全局页面置换算法</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter7.1 进程描述</title>
    <url>/posts/231207204958.html</url>
    <content><![CDATA[<p>进程是一个具有一定独立功能的 <strong> 程序 </strong> 在一个 <strong> 数据集合 </strong> 上的 <strong> 一次动态执行 </strong> 过程（进程 = 程序 + 数据 + 动态执行）。一个进程包含了程序代码、相关数据以及进程控制块等信息。程序代码定义了进程要执行的操作，数据则是程序在运行过程中使用的变量、数据结构等。动态执行指的是进程在计算机系统中被调度并执行的过程。</p>
<p>本文是进程与线程的第一部分，主要介绍进程的静态部分，包括进程的定义、组成、特点和进程控制结构等。</p>
<span id="more"></span>
<h1 id="进程描述">进程描述</h1>
<h2 id="进程的定义">进程的定义</h2>
<p>进程（process）是一个具有一定独立功能的 <strong> 程序 </strong> 在一个 <strong> 数据集合 </strong> 上的 <strong> 一次动态执行 </strong> 过程。</p>
<blockquote>
<p>保存在磁盘中的静态程序代码文件，通过编译、链接转换成可执行文件，然后被加载到内存中执行，称为一个进程，进行实际的执行操作。</p>
</blockquote>
<h2 id="进程的组成">进程的组成</h2>
<p><strong>一个进程包括</strong>：</p>
<ul>
<li>程序的代码；</li>
<li>程序处理的数据；</li>
<li>程序计数器中的值：用于指示下一条将要运行的指令；</li>
<li>一组通用的寄存器的当前值：用于存储临时数据和中间结果，包括通用寄存器、状态寄存器等。</li>
<li>堆和栈：堆用于动态分配内存，存储动态创建的对象和数据结构；栈用于存储函数调用和局部变量等。</li>
<li>一组系统资源（如打开的文件、网络连接）</li>
</ul>
<p>总之，进程包含了正在运行的一个程序的所有状态信息。</p>
<p><strong>进程和程序的联系</strong>：</p>
<ul>
<li>程序是产生进程的基础；</li>
<li>程序的每次运行构成不同的进程；</li>
<li>进程是程序功能的体现；</li>
<li>通过多次执行，一个程序可以对应多个进程；通过调用关系，一个进程可以包括多个程序。</li>
</ul>
<p><strong>进程和程序的区别</strong>：</p>
<ul>
<li>进程是动态的、程序是静态的。
<ul>
<li>程序是有序代码的集合，进程是程序的执行，进程有核心态（如打开文件是通过系统调用，由操作系统在内核态处理的）、用户态。</li>
</ul>
</li>
<li>进程是暂时的、程序是永久的。
<ul>
<li>进程是一个状态变化的过程，程序可以长久保存。</li>
</ul>
</li>
<li>进程和程序的组成不同：进程的组成包括程序、数据和进程控制块（进程状态信息）。</li>
</ul>
<h2 id="进程的特点">进程的特点</h2>
<ul>
<li><strong>动态性</strong>：可动态地创建和结束进程；</li>
<li><strong>并发性</strong>：进程可以被独立调度并占用 CPU 运行；
<ul>
<li>并发：多个进程在一段时间内交替执行。</li>
<li>并行：在某一时刻，多个进程在同时执行（并行仅在多核设备上才支持）。</li>
</ul>
</li>
<li><strong>独立性</strong>：不同进程的工作不相互影响；
<ul>
<li>内存管理中的页表是保障措施之一（每个进程都有自己的页表，不会访问到对方的页表的地址空间）。</li>
</ul>
</li>
<li><strong>制约性</strong>：因访问共享数据或资源，或进程间同步而产生制约。
<ul>
<li>这可能会导致资源竞争或数据不一致等问题，因此需要采取相应的措施来解决制约问题，如使用互斥锁、信号量等机制来进行进程间的同步与通信。</li>
</ul>
</li>
</ul>
<blockquote>
<p>老师抛出了一个问题：如果你要设计一个 OS, 怎么样来实现其中的进程管理机制？</p>
</blockquote>
<h2 id="进程控制块（PCB）">进程控制块（PCB）</h2>
<h3 id="PCB 概述">PCB 概述</h3>
<p><strong>计算机中有那么多进程，那这些进程是如何被操作系统管理起来的呢</strong>？</p>
<p>进程控制块 （Process Control Block, PCB）：操作系统中用于管理和维护进程的 <strong> 数据结构</strong>。</p>
<p>每个进程在操作系统中都有一个对应的 PCB，它包含了进程的各种属性和状态信息。换句话说，操作系统用 PCB 来描述进程的基本情况以及运行变化的过程。PCB 是进程存在的唯一标志。</p>
<p><strong>使用 PCB</strong>：</p>
<ul>
<li>进程的创建：为该进程生成一个 PCB；</li>
<li>进程的终止：回收它的 PCB；</li>
<li>进程的组织管理：通过对 PCB 的组织管理来实现。</li>
</ul>
<p><strong>PCB 三大类信息</strong>：</p>
<ol>
<li>
<p>进程标志信息：包括进程标志（Process ID）、产生者标志（Parent Process ID）和用户标志（User ID）。这些信息用于唯一标识进程、记录父进程和标识进程所属的用户。</p>
</li>
<li>
<p>CPU 状态信息保存区：保存了进程的运行现场信息，包括用户可见寄存器（用于用户程序的数据、地址等寄存器）、控制和状态寄存器（如程序计数器 PC、程序状态字 PSW）以及栈指针（用于过程调用、系统调用、中断处理和返回时的栈操作）。</p>
</li>
<li>
<p>进程控制信息：包括调度和状态信息（用于操作系统调度和占用 CPU 资源）、进程间通信信息（用于支持进程间通信的标志、信号、信件等）、存储管理信息（包含指向进程映像存储空间的数据结构）、进程所用资源（说明进程打开、使用的系统资源，如打开的文件等）以及有关数据结构的链接信息（用于连接到进程队列或其他相关进程的 PCB）。</p>
</li>
</ol>
<p><strong>PCB 的组织方式</strong>：</p>
<p><strong>多个进程的 PCB 是如何被操作系统有效地管理的呢</strong>？</p>
<p>链表：<strong>同一状态 </strong> 的进程其 PCB 构成 <strong> 一个 </strong> 链表，<strong>多个状态 </strong> 对应 <strong> 多个不同 </strong> 的链表。</p>
<ul>
<li>各状态的进程形成不同的链表：就绪链表、阻塞链表。</li>
</ul>
<p>索引表：<strong>同一状态 </strong> 的进程归入一个 <code>index</code> 表（由 <code>index</code> 指向 PCB），<strong>多个状态 </strong> 对应 <strong> 多个不同 </strong> 的 <code>index</code> 表。</p>
<ul>
<li>各状态的进程形成不同的索引表：就绪索引表、阻塞索引表。</li>
</ul>
<h3 id="PCB 扩展内容">PCB 扩展内容</h3>
<blockquote>
<p>以下内容由 GPT 生成，不保证内容的 100% 准确。</p>
</blockquote>
<p>PCB 通常包含以下重要的信息：</p>
<ol>
<li>
<p>进程标识符（Process ID）：唯一标识该进程的数字或字符串。</p>
</li>
<li>
<p>程序计数器（Program Counter）：存储当前执行指令的地址，用于指示下一条要执行的指令。</p>
</li>
<li>
<p>寄存器集合：保存进程执行过程中的寄存器内容，包括通用寄存器、程序状态字、堆栈指针等。</p>
</li>
<li>
<p>进程状态（Process State）：表示进程当前所处的状态，常见的状态有就绪（Ready）、运行（Running）、阻塞（Blocked）等。</p>
</li>
<li>
<p>进程优先级（Process Priority）：用于确定进程的调度顺序，通常由进程调度算法根据一定的策略进行设置。</p>
</li>
<li>
<p>资源指针（Resource Pointers）：指向进程所拥有的资源的指针，如打开文件列表、内存分配信息等。</p>
</li>
<li>
<p>父进程指针（Parent Process Pointer）：指向该进程的父进程。</p>
</li>
<li>
<p>子进程指针（Child Process Pointer）：指向该进程的子进程。</p>
</li>
<li>
<p>进程控制信息（Process Control Information）：存储了进程的创建时间、运行时间、等待时间等统计信息。</p>
</li>
</ol>
<p>PCB 在操作系统中起到了重要的作用，它记录了进程的基本信息，并且通过操作系统的调度算法，可以根据 PCB 中的信息对进程进行管理和调度。当进程状态发生变化时，PCB 中的相应字段也会随之更新，以便操作系统能够及时响应和处理进程的状态变化。</p>
<p>以下是一个用 C 语言表示 PCB 的数据结构的示例（操作系统实际 PCB 设计可能有所不同）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlock</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> processID;</span><br><span class="line">    <span class="type">int</span> programCounter;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RegisterSet</span> &#123;</span></span><br><span class="line">        <span class="comment">// 寄存器集合，包括通用寄存器、程序状态字、堆栈指针等</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; registers;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">ProcessState</span> &#123;</span></span><br><span class="line">        READY,</span><br><span class="line">        RUNNING,</span><br><span class="line">        BLOCKED</span><br><span class="line">    &#125; state;</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">    <span class="type">void</span> *resourcePointers;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlock</span> *<span class="title">parentProcess</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlock</span> *<span class="title">childProcess</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlInformation</span> &#123;</span></span><br><span class="line">        <span class="comment">// 进程的统计信息，如创建时间、运行时间、等待时间等</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; controlInfo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述的数据结构中，<code>ProcessControlBlock</code>表示进程控制块，包含了进程的各种属性和状态信息。其中，<code>registers</code>表示寄存器集合，<code>state</code>表示进程状态，<code>priority</code>表示进程优先级，<code>resourcePointers</code>表示资源指针，<code>parentProcess</code>和 <code>childProcess</code> 分别表示父进程和子进程的指针，<code>controlInfo</code>表示进程的控制信息。</p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a></li>
<li><a href="https://blog.csdn.net/weixin_53407527/article/details/125027431">https://blog.csdn.net/weixin_53407527/article/details/125027431</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>进程与线程</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter7.2 进程状态</title>
    <url>/posts/231210211306.html</url>
    <content><![CDATA[<p>进程是一个具有一定独立功能的 <strong> 程序 </strong> 在一个 <strong> 数据集合 </strong> 上的 <strong> 一次动态执行 </strong> 过程。</p>
<p>本文是进程与线程的第二部分，主要介绍进程的状态，包括进程的生命周期管理、进程状态变化模型和进程挂起模型，以及操作系统如何管理进程的状态队列。</p>
<span id="more"></span>
<h1 id="进程的生命周期管理">进程的生命周期管理</h1>
<p>一个进程的生命周期包括：进程的创建、就绪、运行、等待（阻塞）、终止。</p>
<h2 id="进程创建">进程创建</h2>
<p>引起进程创建的 3 个主要事件：</p>
<ul>
<li>系统初始化（创建出计算机的首个进程）；</li>
<li>用户请求创建一个新进程；</li>
<li>正在运行的进程执行了创建进程的系统调用。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P_create</span><br></pre></td></tr></table></figure>
<h2 id="进程就绪">进程就绪</h2>
<p>一个进程被创建完成后，便会进入就绪状态，等待操作系统的调度执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P_create -&gt; P_ready</span><br></pre></td></tr></table></figure>
<h2 id="进程运行">进程运行</h2>
<p>内核选择一个 <strong> 就绪 </strong> 的进程，让它占用 CPU 并执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P_create -&gt; P_ready -&gt; P_running</span><br></pre></td></tr></table></figure>
<blockquote>
<p>计算机有那么多进程呢，操作系统如何选择进程？又为何选择这个进程？这由后续要讲解的调度算法控制！</p>
</blockquote>
<h2 id="进程等待（阻塞）">进程等待（阻塞）</h2>
<p>在以下情况下，进程等待（阻塞）：</p>
<ul>
<li>请求并等待系统服务，无法马上完成；</li>
<li>启动某种操作，无法马上完成；</li>
<li>需要的数据没有到达。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P_create -&gt; P_ready -&gt; P_running</span><br><span class="line">                           ↓</span><br><span class="line">                       P_waiting</span><br></pre></td></tr></table></figure>
<p><strong>进程只能自己阻塞自己</strong>，因为只有进程自身才能知道何时需要等待某种事件的发生。</p>
<h2 id="进程唤醒">进程唤醒</h2>
<p>唤醒进程的原因：</p>
<ul>
<li>被阻塞进程需要的资源可被满足；</li>
<li>被阻塞进程等待的事件到达；</li>
<li>将该进程的 PCB 插入到就绪队列。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P_create -&gt; P_ready -&gt; P_running</span><br><span class="line">               ↑           ↓</span><br><span class="line">               &lt;------ P_waiting</span><br></pre></td></tr></table></figure>
<p>被唤醒的进程将进入就绪状态，<strong>进程只能被别的进程或操作系统唤醒</strong>。</p>
<h2 id="进程结束">进程结束</h2>
<p>在以下四种情况下，进程结束：</p>
<ul>
<li>正常退出（自愿的）；</li>
<li>错误退出（自愿的）；</li>
<li>致命错误（强制性的）；</li>
<li>被其他进程所杀死（强制性的）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P_create -&gt; P_ready -&gt; P_running -&gt; Exit</span><br><span class="line">               ↑           ↓</span><br><span class="line">               &lt;------ P_waiting</span><br></pre></td></tr></table></figure>
<h1 id="进程状态变化模型">进程状态变化模型</h1>
<h2 id="三种基本状态">三种基本状态</h2>
<p>进程的三种基本状态（进程在生命结束前处于三种基本状态之一）：</p>
<ul>
<li>运行状态（Running）：当一个进程正在 CPU 上运行时。</li>
<li>就绪状态（Ready）：一个进程获得了除 CPU 之外的一切所需资源，一旦得到 CPU 便可运行。</li>
<li>等待（阻塞）状态（Waiting/Blocked）：一个进程正在等待某一事件而暂停运行时。如等待某资源、等待输入 / 输出完成。</li>
</ul>
<blockquote>
<p>不同操作系统设置的进程状态数目可能不同。</p>
</blockquote>
<h2 id="其它基本状态">其它基本状态</h2>
<p>进程其它的基本状态：</p>
<ul>
<li>创建状态（New）：一个进程正在被创建，还没被转到就绪状态之前的状态；</li>
<li>结束状态（Exit）： 一个进程正在从系统中消失时的状态。</li>
</ul>
<h2 id="进程状态变化">进程状态变化</h2>
<img src="../images/os-kernel/chapter7/process-state.png" alt="进程状态变化图" width="80%" height="80%">
<p>进程可能的状态变化如下：</p>
<ul>
<li><code>NULL -&gt; New</code>：一个新进程被产生出来执行一个程序。</li>
<li><code>New -&gt; Ready</code>：当进程创建并并初始化完成后，一切就绪准备运行时，变为就绪状态。
<ul>
<li>该变化过程是否会持续很久？很快。</li>
</ul>
</li>
<li><code>Ready -&gt; Running</code>：处于就绪态的进程被进程调度程序选中后，就分配到 CPU 上来运行。</li>
<li><code>Running -&gt; Exit</code>：当进程表示它已经完成或者发生异常，当前运行的进程会由操作系统作结束处理。</li>
<li><code>Running -&gt; Ready</code>：处于运行状态的进程在其运行过程中，<strong>由于分配它的 CPU 时间片用完而让出 CPU，或者当一个高优先级的进程就绪时，操作系统可能会抢占当前正在运行的低优先级进程，并将其切换到就绪态，以便优先执行高优先级进程</strong>。</li>
<li><code>Running -&gt; Blocked</code>：当进程请求某个事件且必须等待时。
<ul>
<li>例如，等待一个计时器的到达、读 / 写文件比较慢等。</li>
</ul>
</li>
<li><code>Blocked -&gt; Ready</code>：当进程等待到某个事件到来时，它从阻塞状态变到就绪状态。</li>
</ul>
<h1 id="进程挂起模型">进程挂起模型</h1>
<h2 id="进程挂起">进程挂起</h2>
<p>进程挂起（suspend）是指操作系统进程管理将前台的进程暂停并转入后台的动作。将进程挂起可以让用户在前台执行其他的进程。挂起的进程通常释放除 CPU 以外已经占有的系统资源，如内存等。在需要时用户可以恢复进程的运行，将被挂起的进程从后台转入前台，并从暂停处开始继续运行。（Wikipedia）</p>
<p>进程挂起：为了合理且充分地利用系统资源。</p>
<p>进程在挂起状态时，意味着进程 <strong> 没有占用内存空间</strong>，处在挂起状态的进程映像在磁盘上（把进程放到磁盘上）。</p>
<h2 id="两种挂起状态">两种挂起状态</h2>
<ul>
<li><strong>阻塞挂起状态</strong>：进程在外存，并等待某事件的出现。</li>
<li><strong>就绪挂起状态</strong>：进程在外村，但只要进入内存，即可运行。</li>
</ul>
<h2 id="与挂起相关的状态转换">与挂起相关的状态转换</h2>
<p>带有挂起状态的进程状态转移模型：</p>
<img src="../images/os-kernel/chapter7/process-state-transfer-with-suspend.png" alt="带有挂起状态的进程状态转移模型" width="80%" height="80%">
<p>可以将挂起状态间的转化分为两类，<strong>一类是进程处于内存中时发生的挂起，另一类是进程处于外存时的挂起</strong>。</p>
<h3 id="进程处于内存时的挂起">进程处于内存时的挂起</h3>
<p><strong>阻塞 -&gt; 阻塞挂起</strong>：</p>
<ul>
<li>条件：当没有进程处于就绪状态（即没有可以立即执行的进程）或者就绪进程需要更多的内存资源时，系统会进行阻塞挂起的转换。</li>
<li>目的：为了让其他进程先执行，以便提交新进程或者为就绪进程提供所需的内存资源。换句话说，系统会将当前的进程暂时停止执行，以满足其他进程的需求，直到满足某种条件后再重新唤醒该进程。</li>
</ul>
<p><strong>就绪 -&gt; 就绪挂起</strong>：</p>
<ul>
<li>条件：当有高优先级阻塞（系统认为会很快就绪的）进程和低优先级就绪进程时，系统会选择挂起低优先级就绪进程。</li>
<li>目的：让优先级更高的进程得到更多的资源运行。</li>
</ul>
<blockquote>
<p>通常，<strong>操作系统更倾向于挂起阻塞态进程而不是就绪态进程</strong>，因为就绪态进程可以立即执行，而阻塞态进程占用了内存空间但不能立即执行。<br>
但是，如果释放内存以得到足够空间的 <strong> 唯一方法 </strong> 是挂起一个就绪态进程的话，那么这种转换也是必需的；并且，如果操作系统确信高优先级的阻塞态进程很快就会就绪，那么它可能选择挂起一个低优先级的就绪态进程，而不是一个高优先级的阻塞态进程。</p>
</blockquote>
<p><strong>运行 -&gt; 就绪挂起</strong>：</p>
<ul>
<li>条件：对抢先式分时系统（即可抢占 CPU 资源），当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时，系统可能会把运行进程转到就绪挂起状态。</li>
<li>目的：让优先级更高的进程得到更多的资源运行。</li>
</ul>
<h3 id="进程处于外存时的挂起">进程处于外存时的挂起</h3>
<p><strong>阻塞挂起 -&gt; 就绪挂起</strong>：</p>
<p>条件：当有阻塞挂起因相关事件出现时，系统会把阻塞挂起进程转换为就绪挂起进程。</p>
<h3 id="解挂（激活）">解挂（激活）</h3>
<p>既然有将内存中的进程挂起到外存的，那么也会有解挂重新激活进程的操作：即将一个进程从外存转到内存。</p>
<p><strong>就绪挂起 -&gt; 就绪态</strong>：</p>
<p>条件：内存中没有就绪进程，或挂起的就绪进程优先级高于内存中的就绪进程时，会进行这种转换。但一般情况下也会发生这种转换，不一定是上述两种条件。</p>
<p><strong>阻塞挂起 -&gt; 阻塞态</strong>：</p>
<p>条件：当一个进程释放足够内存时，系统会把一个高优先级阻塞挂起（系统认为会很快出现所等待的事件）进程转换为阻塞进程。</p>
<h1 id="状态队列">状态队列</h1>
<p>状态队列（State Queue）是操作系统中用于管理进程状态的数据结构，用于存储不同状态的进程。</p>
<p><strong>状态队列</strong>：</p>
<ul>
<li>由操作系统来维护 <strong> 一组 </strong> 队列，用来表示系统当中所有进程的当前状态；</li>
<li>不同的状态分别用不同的队列来表示，如就绪队列、各种类型的阻塞队列；</li>
<li>每个进程的 PCB 都根据它的状态加入到相应的队列当中，当一个进程的状态发生变化时，它的 PCB 从一个状态队列中脱离出来，加入到另外一个状态队列中。</li>
</ul>
<details>
  <summary>操作系统如何通过 PCB 和定义的进程状态来管理和调度进程的？</summary>
<ol>
<li>将进程根据其状态放入对应的队列中。</li>
<li>根据调度算法从就绪队列中选择一个进程进行执行。</li>
<li>将选中的进程的 PCB 信息加载到 CPU 寄存器中，设置进程状态为运行态。</li>
<li>执行选中的进程，根据需要进行上下文切换。</li>
<li>如果进程遇到事件（如等待 I/O 完成），将进程状态设置为阻塞态，记录事件信息到 PCB 中。</li>
<li>当事件发生后，将进程状态设置为就绪态，将其放回就绪队列中等待调度。</li>
<li>重复步骤 2 至步骤 6，实现多任务的并发执行和合理的进程调度。【由 GPT 生成】</li>
</ol>
</details>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a></li>
<li><a href="https://blog.csdn.net/weixin_53407527/article/details/125027431">https://blog.csdn.net/weixin_53407527/article/details/125027431</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>进程与线程</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter7.3 线程</title>
    <url>/posts/231215213932.html</url>
    <content><![CDATA[<p>线程（Thread）是计算机程序中的执行单元，是进程中的一条执行流程。一个进程可以包含多个线程，每个线程可以独立执行不同的任务。线程可以并发执行，因此可以提高程序的执行效率。</p>
<span id="more"></span>
<h1 id="为什么使用线程">为什么使用线程</h1>
<p>实例：编写一个 MP3 播放软件，其核心功能为：</p>
<ol>
<li>从 MP3 音频文件中读取数据；</li>
<li>对数据进行解压缩；</li>
<li>把解压缩后的音频数据播放出来。</li>
</ol>
<h2 id="单进程实现">单进程实现</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Read(); <span class="comment">// I/O</span></span><br><span class="line">        Decompress(); <span class="comment">// CPU</span></span><br><span class="line">        Play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Read() &#123;...&#125;</span><br><span class="line">Decompress() &#123;...&#125;</span><br><span class="line">Play() &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    问题：</span></span><br><span class="line"><span class="comment">    分片的读取、解压、播放的话，播放出来的声音能否连贯？</span></span><br><span class="line"><span class="comment">        大概率是不能的，因为从硬盘读取是很慢的。</span></span><br><span class="line"><span class="comment">    各个函数之间不是并发执行，影响资源的使用效率。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="多进程实现">多进程实现</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 程序 1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Read() &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序 2</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Decompress();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Decompress() &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序 3</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Play() &#123;...&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    问题：</span></span><br><span class="line"><span class="comment">    进程之间如何通信、共享数据？另外，维护进程的系统开销较大；</span></span><br><span class="line"><span class="comment">    创建进程时，分配资源，建立 PCB；撤销进程时，回收资源，撤销 PCB；进程切换时，保存当前进程的状态信息。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<details>
  <summary>操作系统为进程分配哪些资源？</summary>
【由 GPT 生成】创建进程时，操作系统需要为进程分配一些资源，其中包括：
<ol>
<li>内存空间：为进程分配一定大小的内存空间，用于存储进程的代码、数据和堆栈等信息。</li>
<li>文件描述符：为进程分配文件描述符，用于访问打开的文件。</li>
<li>I/O 设备：为进程分配所需的 I/O 设备，如键盘、显示器、打印机等。</li>
<li>网络资源：如果进程需要进行网络通信，需要分配网络资源，如 IP 地址、端口等。</li>
<li>CPU 时间片：为进程分配 CPU 时间片，用于执行进程的代码。</li>
<li>进程标识符：为进程分配唯一的进程标识符，用于标识和管理进程。</li>
<li>环境变量：为进程设置环境变量，用于配置进程运行环境。</li>
<li>系统资源：为进程分配其他系统资源，如共享内存、消息队列等。</li>
</ol>
<p>这些资源的分配是由操作系统负责管理和调度的，通过建立进程控制块（PCB）来管理进程的资源和状态。</p>
</details>
<h2 id="如何解决">如何解决</h2>
<p>需要提出一种新的实体，满足以下特征：</p>
<ul>
<li>实体之间可以 <strong> 并发执行</strong>；</li>
<li>实体之间 <strong> 共享相同的地址空间</strong>。</li>
</ul>
<p>这种实体就是线程（Thread）。</p>
<h1 id="什么是线程">什么是线程</h1>
<h2 id="线程定义">线程定义</h2>
<p>线程（Thread）是计算机程序中的执行单元，是 <strong> 进程中的一条执行流程</strong>。一个进程可以包含多个线程，每个线程可以独立执行不同的任务。线程可以并发执行，因此可以提高程序的执行效率。</p>
<p>从两个方面重新理解进程（Process）：</p>
<ul>
<li>从资源组合的角度：进程将一组相关的资源组合在一起，构成了一个资源平台（环境），包括地址空间（代码段、数据段）、打开的文件等各种资源；</li>
<li>从运行的角度：进程是指代码在这个资源平台上执行的一条或多条执行流程（线程）。</li>
</ul>
<h2 id="进程中的多线程">进程中的多线程</h2>
<p>进程中的多线程：</p>
<img src="../images/os-kernel/chapter7/thread.png" alt="进程中的多线程" width="80%" height="80%">
<p>从图中可以看出：</p>
<ul>
<li>每个线程有各自的线程控制块（TCB）、程序计数器（PC）、堆栈指针（SP）、状态寄存器等；</li>
<li>每个线程有共享的资源：代码段、数据段、堆空间等（意味着多个线程都可以访问和修改这些资源）。</li>
</ul>
<img src="../images/os-kernel/chapter7/single-multi-thread.png" alt="单线程 Vs. 多线程" width="80%" height="80%">
<blockquote>
<p>线程 = 进程 - 共享资源</p>
</blockquote>
<h2 id="线程的优缺点">线程的优缺点</h2>
<p>优点：</p>
<ul>
<li>一个进程中可以 <strong> 同时存在多个 </strong> 线程；</li>
<li>各个线程之间可以 <strong> 并发地执行</strong>；</li>
<li>各个线程之间可以 <strong> 共享地址空间和文件资源 </strong> 等。</li>
</ul>
<p>缺点：</p>
<ul>
<li>一个线程崩溃，会导致其所属进程的所有线程崩溃。（给了它「权限」就得有更高的「责任」）</li>
</ul>
<blockquote>
<p>线程的优点也是线程的缺点，由于共享资源，安全性得不到保障。</p>
</blockquote>
<h2 id="线程与进程比较">线程与进程比较</h2>
<ul>
<li>进程是资源分配单位，线程是 CPU 调度单位；</li>
<li>进程拥有一个完整的资源平台，而 <strong> 线程只独享必不可少的资源</strong>（如寄存器、堆栈等）；</li>
<li>线程同样具有「就绪、阻塞、运行」三种基本状态，同样具有状态之间的转换关系；</li>
<li><strong>线程能减少并发执行的时间、空间开销</strong>：
<ul>
<li>线程的 <strong> 创建时间 </strong> 比进程短（因为线程直接利用了所属进程的一些状态信息，如页表、文件描述符等）；</li>
<li>线程的 <strong> 终止时间 </strong> 比进程短（因为线程不需要像进程那样进行资源的清理和释放）；</li>
<li>同一进程内的线程 <strong> 切换时间 </strong> 比进程短（因为同一进程的不同线程的切换不需要切换页表）；</li>
<li>由于同一进程的各个线程之间共享内存和文件资源，可 <strong> 直接进行通信</strong>（直接通过内存地址进行数据传递），而不需要借助内核。</li>
</ul>
</li>
</ul>
<h1 id="线程的实现">线程的实现</h1>
<p>主要有三种线程的实现方式：</p>
<ul>
<li>用户线程：在用户空间实现，操作系统看不到用户线程，由应用程序进行管理。
<ul>
<li>POSIX Pthreads (Mac/Windows/Linux OS)、Mach C-threads (Mach OS)、Solaris threads (Solaris OS)</li>
</ul>
</li>
<li>内核线程：在内核空间实现，操作系统管理的线程。
<ul>
<li>Windows、Linux、Solaris</li>
</ul>
</li>
<li>轻量级进程（LightWeight Process）：在内核中实现，支持用户线程。
<ul>
<li>Solaris、Linux</li>
</ul>
</li>
</ul>
<h2 id="用户线程">用户线程</h2>
<p>操作系统只能看到进程、看不到线程，线程的 TCB 在线程库中实现。</p>
<img src="../images/os-kernel/chapter7/user-thread.png" alt="用户线程" width="80%" height="80%">
<p><strong>在用户空间实现的线程机制，它不依赖于操作系统的内核，由一组用户级的线程库（如 <code>pthread.h</code>）函数来完成线程的管理，包括进程的创建、终止、同步和调度等</strong>。</p>
<ul>
<li>由于用户线程的维护由相应的进程来完成（通过线程库函数），不需要操作系统内核了解用户线程的存在，可用于不支持线程技术的多进程操作系统；</li>
<li>每个进程都需要有它自己私有的 <strong> 线程控制块（TCB）列表</strong>，用来跟踪记录它的各个线程的状态信息（PC、栈指针、寄存器），TCB 由线程库函数来维护；</li>
<li><strong>用户线程的切换也是由线程库函数来完成，无需进行用户态到内核态的切换，速度特别快</strong>；</li>
<li>允许每个进程拥有自定义的线程调度算法。</li>
</ul>
<p><strong>用户线程的缺点</strong>：</p>
<ul>
<li>阻塞性的系统调用如何实现？如果一个线程发起系统调用而阻塞，则整个进程在等待；</li>
<li>当一个线程运行时，除非它主动交出 CPU 使用权，否则它所在的进程中的其他线程将无法运行；</li>
<li>由于时间片分配给进程，所以与其它进程相比，在多线程执行时，每个线程得到的时间片较少，执行会较慢。</li>
</ul>
<h2 id="内核线程">内核线程</h2>
<p>操作系统能够看到进程、也可能看到线程，线程在内核中实现。</p>
<img src="../images/os-kernel/chapter7/kernel-thread.png" alt="内核线程" width="80%" height="80%">
<p><strong>内核线程是指在操作系统的内核当中实现的一种线程机制，由操作系统的内核来完成线程的创建、终止和管理</strong>。</p>
<ul>
<li>在支持内核线程的操作系统中，由 <strong> 内核来维护进程和线程的上下文信息</strong>（PCB 和 TCB）；</li>
<li>线程的创建、终止和切换都是通过系统调用 / 内核函数的方式来进行，由内核来完成，因此系统开销较大；</li>
<li>在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并 <strong> 不会影响 </strong> 其他内核线程在 CPU 上的运行；</li>
<li>时间片分配给线程，多线程的进程获得更多 CPU 时间。</li>
</ul>
<h2 id="轻量级进程">轻量级进程</h2>
<p>它是内核支持的用户线程。一个进程可以有一个或多个轻量化进程，每个轻量级进程由一个单独的内核线程来支持。</p>
<blockquote>
<p>参考资料：<br>
1：<a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a><br>
2：<a href="https://blog.csdn.net/weixin_53407527/article/details/125027431">https://blog.csdn.net/weixin_53407527/article/details/125027431</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>进程与线程</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter7.4 进程控制</title>
    <url>/posts/231218220813.html</url>
    <content><![CDATA[<p>本文主要介绍进程控制中的进程切换（进程的上下文切换）、进程创建 <code>fork()</code>、进程加载与执行 <code>exec()</code>、进程等待与终止 <code>wait(), exit()</code>。</p>
<span id="more"></span>
<h1 id="进程上下文切换">进程上下文切换</h1>
<p>进程的上下文切换（context switch）会停止当前运行的进程（从运行状态变成其它状态），并调度其它进程运行（从就绪状态变成运行状态）。</p>
<ul>
<li>在切换之前，<strong>存储 </strong> 进程的上下文；</li>
<li>在切换之后，<strong>恢复 </strong> 进程的上下文，即进程不能显示它曾经被暂停过；</li>
<li><strong>快速 </strong> 切换（进程的上下文切换非常频繁，通常在 10ms 左右）。</li>
</ul>
<p>需要存储什么上下文？</p>
<ul>
<li>各种寄存器信息（PC, SP, …）；</li>
<li>CPU 状态；</li>
<li>内存地址空间（大部分情况不用保存，因为不同进程的地址空间各占一块独立的区域，不会被别的进程访问）。</li>
</ul>
<p>进程的上下文切换示意图：</p>
<img src="../images/os-kernel/chapter7/context-switch.png" alt="上下文切换示意图" width="80%" height="80%">
<p>操作系统为活跃进程准备了进程控制块（PCB），并将其放在一个合适的队列里：</p>
<ul>
<li>就绪队列；</li>
<li>等待 I/O 队列（不同 I/O 设备对应着不同队列）；</li>
<li>僵尸队列。</li>
</ul>
<h1 id="进程创建">进程创建</h1>
<p>Unix 进程创建的两个 <strong> 系统调用</strong>：<code>fork()</code> 和 <code>exec()</code>：</p>
<ul>
<li><code>fork()</code> 把一个进程复制成二个进程：
<ul>
<li><code>parent(old PID)</code> 和 <code>child(new PID)</code>，两个进程只有 <code>PID</code> 号不一样。</li>
</ul>
</li>
<li><code>exec()</code> 用新程序来重写当前进程，但不改变当前进程的 <code>PID</code> 号：
<ul>
<li><code>exec('program', argc, argv0, argv1, ...);</code></li>
</ul>
</li>
</ul>
<p><strong>用 <code>fork()</code> 和 <code>exec()</code> 创建进程的示例程序</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父进程代码</span></span><br><span class="line"><span class="type">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// child process, Do anything</span></span><br><span class="line">    exec(<span class="string">&#x27;/path/to/program&#x27;</span>, argc, argv0, argv1, ...);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// parent process</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>fork()</code> 创建一个继承的子进程</strong>：</p>
<ul>
<li>它复制了父进程的所有变量、内存；</li>
<li>它复制了父进程的所有 CPU 寄存器（有一个寄存器例外）；</li>
<li><strong>开销昂贵</strong>。</li>
</ul>
<p><code>fork()</code> 的返回值：</p>
<ul>
<li>子进程的 <code>fork()</code> 返回 0，父进程的 <code>fork()</code> 返回子进程的 <code>PID</code> 号；</li>
<li><code>fork()</code> 的返回值可方便后续使用，子进程可使用 <code>getpid()</code> 获取 <code>PID</code> 号。</li>
</ul>
<p><strong><code>fork()</code> 的地址空间复制示意图</strong>：</p>
<img src="../images/os-kernel/chapter7/fork-copy-memory.png" alt="fork 地址空间复制" width="80%" height="80%">
<p>上图中，父进程在执行到 <code>fork()</code> 代码的时候，会复制一个子进程，然后父子进程相继向下执行，但是父进程和子进程的局部变量 <code>childPID</code> 的值不同，会进入不同的 <code>if</code> 分支继续执行。</p>
<p><strong><code>fork()</code> 的实现开销昂贵，在 99% 的情况下，我们在调用 <code>fork()</code> 之后调用<code>exec()</code></strong>，也就是说：</p>
<ul>
<li><code>fork()</code> 操作的内存复制是没有意义的；</li>
<li>子进程可能关闭打开的文件和连接。</li>
</ul>
<p>Unix 的 <code>vfork()</code>，有时也称为轻量级 <code>fork()</code>：</p>
<ul>
<li>一个创建进程的系统调用，<strong>不需要 </strong> 创建一个同样的内存映像；</li>
<li>子进程应该几乎立即调用<code>exec()</code>；</li>
<li>现在已不再使用，取而代之的是 Copy on Write (COW) 技术。</li>
</ul>
<h1 id="进程加载与执行">进程加载与执行</h1>
<p>使用系统调用 <code>exec()</code> 来加载程序，并取代当前运行的程序。</p>
<ul>
<li>它允许一个进程「加载」一个不同的程序，并从 <code>main(int argc, char *argv[])</code> 开始执行；</li>
<li>它允许一个进程指定参数的数量 <code>argc</code> 和字符串参数数组 <code>*argv[]</code>；</li>
</ul>
<p>如果调用成功，则是相同的进程，但是运行了一个不同的程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in the parent process</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// 是子进程</span></span><br><span class="line">        exec_status = exec(<span class="string">&quot;/bin/calc&quot;</span>, argc, argv0, argv1, ...);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123; <span class="comment">// 是父进程</span></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">        child_status = wait(pid);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* error occurred */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// calc main function</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> q = <span class="number">7</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="../images/os-kernel/chapter7/exec-system-call.png" alt="exec 系统调用" width="80%" height="80%">
<p>执行完 <code>exec()</code> 后，<code>pid</code> 改变了，<code>open files</code> 的路径也改变了；PCB 中的代码段完全被新的程序 <code>calc</code> 所替换，且执行地址也发生了变化。</p>
<h1 id="进程等待与终止">进程等待与终止</h1>
<h2 id="进程等待">进程等待</h2>
<p><strong><code>wait()</code> 系统调用的作用是父进程用来等待子进程的结束</strong>：</p>
<ul>
<li>子进程结束时，通过 <code>exit()</code> 向父进程返回一个值，父进程通过 <code>wait()</code> 接收并处理返回值。</li>
</ul>
<blockquote>
<p>子进程无法释放掉自己的 PCB，父进程在子进程执行结束后，接收返回值，帮助子进程释放内存中的 PCB 等资源。</p>
</blockquote>
<p><strong><code>wait()</code> 系统调用的功能</strong>：</p>
<ul>
<li>有子进程存活时，会使父进程进入等待状态，来等待子进程的结束。当子进程调用 <code>exit()</code> 时，操作系统会解锁父进程，并将 <code>exit()</code> 的返回值作为父进程中 <code>wait()</code> 的返回值。</li>
<li>无子进程存活时，<code>wait()</code> 立即返回。</li>
<li>有僵尸进程等待时，<code>wait()</code> 立即返回其中一个僵尸进程的返回值。</li>
</ul>
<blockquote>
<p>僵尸进程（Zombie Process）是指一个已经完成执行（子进程已经终止），但是父进程尚未调用 <code>wait()</code> 或 <code>waitpid()</code> 来获取子进程的终止状态的进程。</p>
</blockquote>
<h2 id="进程终止">进程终止</h2>
<p>进程结束执行时调用 <code>exit()</code>，完成进程资源回收。</p>
<p><strong><code>exit()</code> 系统调用的功能</strong>：</p>
<ul>
<li>将调用参数作为进程的「结果」；</li>
<li>关闭所有打开的文件、链接等占用资源；</li>
<li>释放内存；</li>
<li>释放大部分进程相关的内核数据结构；</li>
<li>检查是否父进程是存活着的：
<ul>
<li>若存活，则保留结果的值知道父进程需要它，进入僵尸（zombie/defunct）状态。</li>
<li>若没有存活，则释放所有的数据结构，进程结束死亡。</li>
</ul>
</li>
<li>清理所有等待的僵尸进程。</li>
</ul>
<blockquote>
<p>进程终止是最终的垃圾收集（资源回收）。</p>
</blockquote>
<h1 id="进程控制 -vs- 进程状态">进程控制 vs. 进程状态</h1>
<img src="../images/os-kernel/chapter7/process-control-vs-process-state.png" alt="进程控制与进程状态" width="80%" height="80%">
<p>执行 <code>exec()</code> 时，进程可能处于不同的状态。</p>
<blockquote>
<p>参考资料：<br>
1：<a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a><br>
2：<a href="https://blog.csdn.net/weixin_53407527/article/details/125027431">https://blog.csdn.net/weixin_53407527/article/details/125027431</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>进程与线程</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>上下文切换</tag>
        <tag>进程控制</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter8 调度</title>
    <url>/posts/231228193143.html</url>
    <content><![CDATA[<p>本文介绍进程的调度算法，包括进程调度的相关背景、调度准则，以及各种调度算法。</p>
<span id="more"></span>
<h1 id="背景">背景</h1>
<h2 id="上下文切换">上下文切换</h2>
<ul>
<li>将 CPU 从一个进程 / 线程切换到另一个进程 / 线程；</li>
<li>在切换过程中，当前进程 / 线程的执行上下文（CPU 状态）被保存到进程 / 线程控制块（PCB/TCB）中；</li>
<li>然后，下一个进程 / 线程的上下文被读取。</li>
</ul>
<h2 id="CPU 调度">CPU 调度</h2>
<ul>
<li>CPU 调度是从就绪队列中选择下一个要运行的进程 / 线程；</li>
<li>调度程序是一个内核函数，通过一些调度策略来选择进程 / 线程；</li>
<li>调度什么时候发生？</li>
</ul>
<h2 id="内核运行调度程序的条件">内核运行调度程序的条件</h2>
<ul>
<li>一个进程从运行状态切换到等待状态。</li>
<li>一个进程被终止。</li>
</ul>
<blockquote>
<p>满足上述其中一个条件，即可运行调度程序。</p>
</blockquote>
<h2 id="不可抢占系统">不可抢占系统</h2>
<ul>
<li>调度程序必须等待事件结束。</li>
</ul>
<h2 id="可以抢占系统">可以抢占系统</h2>
<ul>
<li>调度程序在中断事件被响应后执行。</li>
<li>当前进程从运行状态切换到就绪状态（进程时间片用完），或者一个进程从等待状态切换到就绪状态。</li>
<li>当前运行的进程可以被换出。</li>
</ul>
<h1 id="调度原则">调度原则</h1>
<h2 id="调度策略">调度策略</h2>
<ul>
<li>调度策略：
<ul>
<li>确定如何从就绪队列中选择下一个执行进程。</li>
</ul>
</li>
<li>调度策略要解决的问题：
<ul>
<li>挑选就绪队列中的哪一个进程？</li>
<li>通过什么样的准则来选择？</li>
</ul>
</li>
<li>调度算法：
<ul>
<li>在调度程序中实现的调度策略。</li>
</ul>
</li>
<li>比较调度算法的准则：
<ul>
<li>哪一个策略或算法比较好？</li>
</ul>
</li>
</ul>
<h2 id="程序执行模型">程序执行模型</h2>
<img src="../images/os-kernel/chapter8/cpu-vs-io-model.png" alt="程序执行模型" width="80%" height="80%">
<p>当某进程在进行 I/O 时，没有占用 CPU，此时希望其它进程能有效利用 CPU，使得 CPU 尽可能忙，充分利用资源。</p>
<h2 id="评价指标">评价指标</h2>
<ul>
<li>
<p><strong>CPU 使用率</strong>：CPU 处于忙状态所占时间的百分比。</p>
</li>
<li>
<p><strong>吞吐量</strong>：单位时间内完成的进程数量。</p>
</li>
<li>
<p><strong>周转时间</strong>：一个进程从到达就绪队列到完成（结束）所花费的时间，包括所有等待时间。</p>
<ul>
<li>周转时间 = 完成时间 - 达到时间</li>
<li>带权周转时间 = 周转时间 / 运行时间</li>
</ul>
</li>
<li>
<p><strong>等待时间</strong>：进程在就绪队列中的总时间。</p>
<ul>
<li>等待时间 = 周转时间 - 运行时间，也等于开始执行时间 - 达到时间</li>
</ul>
</li>
<li>
<p><strong>响应时间</strong>：从一个请求被提交到产生第一次响应所花费的总时间。</p>
</li>
</ul>
<h2 id="评价指标不可兼得">评价指标不可兼得</h2>
<p>人们通常需要「更快的」服务，但什么是「更快的」服务？</p>
<ul>
<li>在传输文件时，高带宽是更快的；</li>
<li>在玩游戏时，低延迟是更快的；</li>
<li>这两个因素是独立的。</li>
</ul>
<p>评价指标的期望：</p>
<ul>
<li>减少响应时间：及时处理用户的输出，并尽快将输出提供给用户；</li>
<li>减少平均响应时间的波动：在交互系统中，可预测性比高差异性低平均更重要；</li>
<li>增加吞吐量：减少开销（操作系统开销、上下文切换）、高效利用系统资源（CPU、I/O 设备）；</li>
<li>减少等待时间：减少每个进程的等待时间。</li>
</ul>
<blockquote>
<p>其实这些指标是有矛盾的，比如 <strong> 很难同时满足 </strong> 最小响应时间和最大吞吐量，要么只顾及某一点，要么对两点进行折中。</p>
</blockquote>
<ul>
<li>吞吐量是操作系统的计算带宽。</li>
<li>响应时间是操作系统的计算延迟。</li>
</ul>
<h2 id="将「公平」作为重要指标">将「公平」作为重要指标</h2>
<ul>
<li>保证每个进程占用相同的 CPU 时间。
<ul>
<li>这公平吗？如果一个用户比其他用户运行更多的进程怎么办？</li>
</ul>
</li>
<li>保证每个进程等待相同的时间。</li>
<li>公平通常会增加平均响应时间。</li>
</ul>
<h1 id="调度算法">调度算法</h1>
<h2 id="先来先服务算法（FCFS）">先来先服务算法（FCFS）</h2>
<p>先来先服务算法（First Come First Served, FCFS）为非抢占式算法。</p>
<p><strong>调度策略：依据进程进入就绪状态的先后顺序调度</strong>。</p>
<ul>
<li>如果当前运行的进程进入阻塞或结束状态时，就绪队列中的下一个进程会得到 CPU。</li>
</ul>
<img src="../images/os-kernel/chapter8/fcfs-algorithm.png" alt="先来先服务算法" width="80%" height="80%">
<p>如上图，如果就绪队列前面的进程执行时间较长，周转时间会边长，如果用户请求后面的进程，可能会等待较长时间。</p>
<h3 id="算法特点">算法特点</h3>
<p>优点：简单。</p>
<p>缺点：</p>
<ul>
<li>平均等待时间波动较大；</li>
<li>花费时间少的任务可能排在花费时间长的任务后面；</li>
<li>可能导致 I/O 和 CPU 之间的重叠处理（一起闲、一起忙）：CPU 密集型进程会导致 I/O 设备闲置时，I/O 密集型进程也在等待。</li>
</ul>
<h2 id="短进程优先算法（SPN-SRT）">短进程优先算法（SPN/SRT）</h2>
<p>在 FCFS 算法中可以观察到，如果把短进程排到前面，周转时间会下降。因此，短进程优先调度算法被提出。</p>
<ul>
<li>短进程优先算法：Shortest Process Next, SPN</li>
<li>短作业优先算法：Shortest Job First, SJF</li>
<li>最短剩余时间优先算法：Shortest Remaining Time, SRT</li>
</ul>
<blockquote>
<p>SPN 和 SJF 是同一个算法的两种不同叫法，为非抢占式算法；而 SRT 是可抢占式 SPN 算法。</p>
</blockquote>
<p>短进程优先算法 <strong> 调度策略：按照预测的完成时间来将任务入队</strong>（队列内时间越短的任务越靠前）。</p>
<img src="../images/os-kernel/chapter8/spn-algorithm.png" alt="短进程优先算法" width="80%" height="80%">
<p>如上图，就绪队列中的四个进程 <code>w, x, y, z</code> 的完成时间分别是 <code>9, 12, 34, 62</code>，因此进程 <code>w</code> 在队列头、进程 <code>z</code> 在队列尾。</p>
<blockquote>
<p>在抢占式 SRT 调度算法中，如果发现某个进程比当前进程的剩余时间片还短，则 <strong> 抢占 CPU 并运行该进程</strong>。在 SPN 调度算法中，不可抢占，会将该进程放到就绪队列最前面。</p>
</blockquote>
<h3 id="最优平均周转时间">最优平均周转时间</h3>
<p>短进程优先算法具有最优平均周转时间。</p>
<img src="../images/os-kernel/chapter8/spn-turnaround.png" alt="SPN 最优平均周转时间" width="80%" height="80%">
<p>如上图，如果按进程的完成时间从短到长来调度，可以证明其具有最优的平均周转时间。其它情况下，如将 <code>P3</code> 安排在 <code>P5</code> 后运行，则不具有最优的平均周转时间。</p>
<h3 id="算法特点 -v2">算法特点</h3>
<p>SPN (SJF) 调度算法的问题：</p>
<ul>
<li><strong>可能会导致饥饿</strong>：当有连续的短任务流时，长任务可能会被短任务持续占用 CPU，导致长任务等待时间增加，可能出现饥饿现象。</li>
<li><strong>需要预测下一个 CPU 突发持续时间（进程在一次调度中连续占用 CPU 的时间长度）</strong>。
<ul>
<li>简单的解决：询问用户。但如果用户欺骗呢？就杀死进程！那如果用户不知道怎么办？</li>
</ul>
</li>
</ul>
<h3 id="进程执行时间预估">进程执行时间预估</h3>
<p><strong>用历史 </strong> 的执行时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">t_{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和预估时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>τ</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\tau_{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.1132em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> <strong>来估计未来 </strong> 的执行时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>τ</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\tau_{n+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.1132em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>。其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">t_{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 次 <strong> 实际的 </strong>CPU 突发的持续时间，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>τ</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\tau_{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.1132em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 次<strong> 预估的</strong>CPU 突发的持续时间。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>τ</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>α</mi><msub><mi>t</mi><mi>n</mi></msub><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="false">)</mo><msub><mi>τ</mi><mi>n</mi></msub><mo separator="true">,</mo><mspace width="1em"/><mi>α</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\tau_{n+1} = \alpha t_{n} + (1 - \alpha)\tau_{n}, \quad \alpha \in [0, 1]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.1132em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.1132em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span></p>
<h2 id="最高响应比优先算法（HRRN）">最高响应比优先算法（HRRN）</h2>
<p>最高响应比优先算法（Highest Response Ratio Next, HRRN）为非抢占式调度算法。</p>
<p><strong>调度策略：选择就绪就绪队列中响应比最高的进程</strong>。其中，响应比 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>=</mo><mfrac><mrow><mi>w</mi><mo>+</mo><mi>s</mi></mrow><mi>s</mi></mfrac><mo>=</mo><mn>1</mn><mo>+</mo><mfrac><mi>w</mi><mi>s</mi></mfrac></mrow><annotation encoding="application/x-tex">R = \frac{w + s}{s} = 1 + \frac{w}{s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1473309999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.802331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> 表示等待时间（waiting time），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> 表示服务执行时间（service time）。</p>
<h3 id="算法特点 -v3">算法特点</h3>
<ul>
<li>在短进程优先算法的基础上改进，关注进程的等待时间：
<ul>
<li>不再仅仅考虑执行时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> 参数，也增加了等待时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> 参数。</li>
</ul>
</li>
<li>防止长任务被无限期推迟。</li>
<li><strong>依然需要预估服务执行时间</strong>。</li>
</ul>
<h2 id="时间片轮询算法（RR）">时间片轮询算法（RR）</h2>
<p>时间片轮询算法（Round Robin, RR）将为每个进程被分配一个固定的时间片，<strong>当一个进程的时间片用完后，它会被剥夺 CPU，并放到就绪队列的末尾，等待下一次调度</strong>。</p>
<p>这种方式使得每个进程能够公平地分享 CPU 时间，避免了长时间的饥饿现象。同时，时间片轮转算法也 <strong> 具有抢占性</strong>，因为当一个进程的时间片用完时，它可以被剥夺 CPU，并让其他进程获得执行的机会。</p>
<p>时间片轮询算法 <strong> 调度策略：使用时间片和抢占来轮流执行就绪队列中的任务</strong>。一个进程的时间片用完后，按 FCFS 算法切换到下一个就绪进程。</p>
<img src="../images/os-kernel/chapter8/rr-algorithm.png" alt="时间片轮询算法" width="80%" height="80%">
<h3 id="轮询算法示例">轮询算法示例</h3>
<p>假设有如下进程：</p>
<table>
<thead>
<tr>
<th style="text-align:center">进程</th>
<th style="text-align:center">执行时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">P1</td>
<td style="text-align:center">53</td>
</tr>
<tr>
<td style="text-align:center">P2</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">P3</td>
<td style="text-align:center">68</td>
</tr>
<tr>
<td style="text-align:center">P4</td>
<td style="text-align:center">24</td>
</tr>
</tbody>
</table>
<p>假设为进程分配的时间片为 20，进程没有 I/O 等待，那么进程调度的甘特图为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        | P1  | P2 | P3  | P4  | P1  | P3  | P4 | P1 | P3  | P3 |</span><br><span class="line">    ----|-----|----|-----|-----|-----|-----|----|----|-----|----|---&gt;</span><br><span class="line">time    0    20   28    48    68    88    108  112  125   145  153</span><br><span class="line">gap       20    8    20    20    20    20    4    13   20    8</span><br></pre></td></tr></table></figure>
<p>每个进程的等待时间为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>P</mi><mn>1</mn><mo>=</mo><mo stretchy="false">(</mo><mn>68</mn><mo>−</mo><mn>20</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mn>112</mn><mo>−</mo><mn>88</mn><mo stretchy="false">)</mo><mo>=</mo><mn>72</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>P</mi><mn>2</mn><mo>=</mo><mo stretchy="false">(</mo><mn>20</mn><mo>−</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>20</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>P</mi><mn>3</mn><mo>=</mo><mo stretchy="false">(</mo><mn>28</mn><mo>−</mo><mn>0</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mn>88</mn><mo>−</mo><mn>48</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mn>125</mn><mo>−</mo><mn>108</mn><mo stretchy="false">)</mo><mo>=</mo><mn>85</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>P</mi><mn>4</mn><mo>=</mo><mo stretchy="false">(</mo><mn>48</mn><mo>−</mo><mn>0</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mn>108</mn><mo>−</mo><mn>68</mn><mo stretchy="false">)</mo><mo>=</mo><mn>88</mn></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}
P1 = (68-20) + (112-88) = 72 \\ 
P2 = (20-0) = 20 \\ 
P3 = (28-0) + (88-48) + (125-108) = 85 \\ 
P4 = (48-0) + (108-68) = 88
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.76em;vertical-align:-2.63em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9500200000000008em;"><span style="top:-1.59999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-1.5949900000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-1.8899900000000003em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.1849900000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.2049900000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.1500100000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.29501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.59001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.885010000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.905010000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-5.20002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.1300000000000003em;"><span style="top:-5.130000000000001em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">8</span><span class="mord">8</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">7</span><span class="mord">2</span></span></span><span style="top:-3.6900000000000004em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">2</span><span class="mord">0</span></span></span><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord">8</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">4</span><span class="mord">8</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">2</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">8</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">8</span><span class="mord">5</span></span></span><span style="top:-0.8100000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">0</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">6</span><span class="mord">8</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">8</span><span class="mord">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.63em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>平均等待时间为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>P</mi><mrow><mi>a</mi><mi>v</mi><mi>g</mi></mrow></msub><mo>=</mo><mo stretchy="false">(</mo><mn>72</mn><mo>+</mo><mn>20</mn><mo>+</mo><mn>85</mn><mo>+</mo><mn>88</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>4</mn><mo>=</mo><mn>66.25</mn></mrow><annotation encoding="application/x-tex">P_{avg} = (72+20+85+88)/4 = 66.25
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">7</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">8</span><span class="mord">8</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">6</span><span class="mord">.</span><span class="mord">2</span><span class="mord">5</span></span></span></span></span></p>
<blockquote>
<p>一般 FCFS 算法比 RR 算法的平均等待时间更短——这是因为 FCFS 中没有频繁的上下文切换（一个进程执行完毕后，才会切换一次上下文，执行下一个进程）。但是，FCFS 达不到像 RR 那样及时响应每一个进程。</p>
</blockquote>
<h3 id="算法特点 -v4">算法特点</h3>
<ul>
<li>RR 花销：额外的上下文切换（以保证每个进程都有机会被执行）。</li>
<li>若时间片分配太大：
<ul>
<li>进程等待时间过长；</li>
<li>极限情况下会退化成 FCFS 算法。</li>
</ul>
</li>
<li>若时间片分配太小：
<ul>
<li>反应迅速；</li>
<li>吞吐量因大量的上下文切换开销而受到影响。</li>
</ul>
</li>
</ul>
<p>目标：</p>
<ul>
<li>选择一个合适的时间片大小</li>
<li>经验规则：维持上下文切换的开销在 1% 以内（占程序运行），是可以接受的。</li>
</ul>
<h2 id="多级队列（MQ）">多级队列（MQ）</h2>
<p>多级队列（Multilevel Queues, MQ）<strong>将进程放在多个就绪队列，每个队列具有不同的优先级</strong>。</p>
<p>就绪队列被划分成多个独立的队列：</p>
<ul>
<li>比如，前台（交互）、后台（批处理）</li>
</ul>
<p>每个队列拥有自己的调度策略：</p>
<ul>
<li>比如，前台（RR）、后台（FCFS）</li>
</ul>
<p>调度必须在不同的队列间进行：</p>
<ul>
<li>以固定优先级方式调度：先处理前台队列，再处理后台队列。
<ul>
<li>可能造成饥饿。</li>
</ul>
</li>
<li>以时间片轮询方式调度：每个队列都得到一个确定的能够调度其进程的 CPU 总时间。
<ul>
<li>比如，80% 给使用 RR 的前台，20% 给使用 FCFS 的后台。</li>
</ul>
</li>
</ul>
<h3 id="算法特点 -v5">算法特点</h3>
<ul>
<li>保证公平性的同时，尽量减少进程的等待时间。</li>
<li>高优先级队列中的进程可以立即执行。</li>
<li>低优先级队列中的进程可以获得更多的时间片来执行，从而增加了它们完成的机会。</li>
<li>可以根据进程的行为动态地调整优先级。</li>
</ul>
<h2 id="多级反馈队列（MFQ）">多级反馈队列（MFQ）</h2>
<p>在多级队列中，各个队列之间是没有交互的。进一步改进，<strong>进程可在不同队列间移动的多级队列算法 </strong>，即多级反馈队列（Multilevel Feedback Queues, MFQ）算法，它<strong> 可以根据情况（反馈）调整进程的优先级、队列</strong>。</p>
<ol>
<li>初始时，所有进程都被放入最高优先级的队列中。</li>
<li>当一个进程获得执行时，它被分配一个时间片来执行，如果在时间片用完之前进程没有完成，<strong>它将被移到下一个较低优先级的队列中</strong>。</li>
<li>如果一个进程在一个较低优先级队列中 <strong> 等待了一段时间仍然没有执行，它可以被提升到更高优先级的队列中</strong>。</li>
</ol>
<img src="../images/os-kernel/chapter8/mfq-algorithm.png" alt="多级反馈队列算法" width="80%" height="80%">
<h3 id="算法特点 -v6">算法特点</h3>
<p>优点：</p>
<ul>
<li>CPU 密集型任务的优先级下降很快；</li>
<li>I/O 密集型任务停留在高优先级（这是因为这种进程存在 I/O 等待，分配给它的时间片用不完，不会被降级）。</li>
</ul>
<h1 id="调度算法总结">调度算法总结</h1>
<table>
<thead>
<tr>
<th>调度算法</th>
<th>特点</th>
<th>是否可抢占</th>
<th>是否饥饿</th>
</tr>
</thead>
<tbody>
<tr>
<td>先来先服务（FCFS）</td>
<td>不公平，平均等待时间较长</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>短进程优先（SPN / SRT）</td>
<td>不公平，平均等待时间较短，需要预估进程执行时间</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>最高响应比优先（HRRN）</td>
<td>不公平，考虑等待时间和执行时间的比例，防止长任务被无限期推迟</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>时间片轮循（RR）</td>
<td>公平，但是平均等待时间较长</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>多级反馈队列（MFQ）</td>
<td>结合多种算法，根据进程需求动态调整优先级</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>公平共享调度（FSS）</td>
<td>公平是第一要素</td>
<td>是</td>
<td>否</td>
</tr>
</tbody>
</table>
<blockquote>
<p>参考资料：<br>
1：<a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a><br>
2：<a href="https://blog.csdn.net/weixin_53407527/article/details/125097356">https://blog.csdn.net/weixin_53407527/article/details/125097356</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>调度算法</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>调度算法</tag>
        <tag>进程调度</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之二叉树的遍历</title>
    <url>/posts/230905224335.html</url>
    <content><![CDATA[<h2 id="二叉树的遍历"> 二叉树的遍历 </h2>
<p> 二叉树是一种非常重要的数据结构，很多其它数据结构都是基于二叉树的基础演变而来的。</p>
<p> 所谓遍历 Traversal 是指沿着某条搜索路线，依次对树中每个结点均做一次且仅做一次访问。</p>
<p> 对于二叉树，有深度遍历和广度遍历，深度遍历有前序、中序以及后序遍历三种方法，广度遍历即我们平常所说的层次遍历。因为树的定义本身就是递归定义，因此采用递归的方法去实现树的三种遍历不仅容易理解而且代码很简洁，而对于广度遍历来说，需要其他数据结构的支撑。</p>
<p> 四种遍历的主要思想是：</p>
<ul>
<li>
<p> 前序遍历：根节点 -&gt; 左子树 -&gt; 右子树 </p>
</li>
<li>
<p> 中序遍历：左子树 -&gt; 根节点 -&gt; 右子树 </p>
</li>
<li>
<p> 后续遍历：左子树 -&gt; 右子树 -&gt; 根节点 </p>
</li>
<li>
<p> 层序遍历：依二叉树的深度从左到右（右到左）按层遍历 </p>
</li>
</ul>
<p> 其中，前、中、后续指的是「根节点」的遍历顺序，例如前序遍历是先遍历根节点。</p>
<span id="more"></span>
<p> 以下为一棵二叉树不同的遍历顺序以及实现方法（非递归实现 / 递归实现）：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \   \</span><br><span class="line">4   5   6</span><br><span class="line"></span><br><span class="line"> 层次遍历顺序：[1 2 3 4 5 6] / 非递归实现：队列 + BFS</span><br><span class="line"> 前序遍历顺序：[1 2 4 5 3 6] / 非递归实现：栈，递归实现：DFS</span><br><span class="line"> 中序遍历顺序：[4 2 5 1 3 6] / 非递归实现：栈，递归实现：DFS</span><br><span class="line"> 后序遍历顺序：[4 5 2 6 3 1] / 非递归实现：栈，递归实现：DFS</span><br></pre></td></tr></table></figure>
<p> 层次遍历使用 BFS 实现，利用的就是 BFS 一层一层遍历的特性，而前序、中序、后序遍历利用了 DFS 实现。</p>
<blockquote>
<p> 前序、中序、后序遍只是在对节点访问的顺序有一点不同，其它都相同。</p>
</blockquote>
<p> 下面直接从 Leetcode 练习题，学习二叉树的不同遍历方法。</p>
<h3 id="二叉树的层序遍历"> 二叉树的层序遍历 </h3>
<blockquote>
<p> 题目链接：<a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值 </a></p>
</blockquote>
<p><strong> 题目 </strong>：给定一个非空二叉树，返回一个由每层节点平均值组成的数组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 输入:</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line"> 输出: [3, 14.5, 11]</span><br><span class="line"> 解释: 第 0 层的平均值是 3,  第 1 层是 14.5, 第 2 层是 11. 因此返回 [3, 14.5, 11].</span><br></pre></td></tr></table></figure>
<p><strong> 层序遍历 </strong>：利用队列实现二叉树的层序遍历。</p>
<p>python 双端队列实现二叉树的层序遍历：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">averageOfLevels</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">import</span> collections</span><br><span class="line">    queue = collections.deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        size = <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="built_in">sum</span>, tmp_size = <span class="number">0</span>, size</span><br><span class="line">        <span class="keyword">while</span> size &gt; <span class="number">0</span>:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            size -= <span class="number">1</span></span><br><span class="line">            <span class="built_in">sum</span> += node.val</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">        res.append(<span class="built_in">sum</span> / tmp_size)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>C 语言实现基于链表的队列，然后基于队列实现二叉树的层序遍历：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define the structure for a node in the queue</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define the structure for the queue</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    Node *front;</span><br><span class="line">    Node *rear;</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to create a new node</span></span><br><span class="line">Node *<span class="title function_">createNode</span><span class="params">(<span class="keyword">struct</span> TreeNode *data)</span> &#123;</span><br><span class="line">    Node *newNode = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to create an empty queue</span></span><br><span class="line">Queue* <span class="title function_">createQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    Queue *<span class="built_in">queue</span> = (Queue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to check if the queue is empty</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Queue *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to enqueue an element into the queue</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enQueue</span><span class="params">(Queue *<span class="built_in">queue</span>, <span class="keyword">struct</span> TreeNode *data)</span> &#123;</span><br><span class="line">    Node *newNode = createNode(data);</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear-&gt;next = newNode;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to dequeue an element from the queue</span></span><br><span class="line"><span class="keyword">struct</span> TreeNode *<span class="title function_">deQueue</span><span class="params">(Queue* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *temp = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">data</span> =</span> temp-&gt;data;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;front-&gt;next;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span>* <span class="title function_">averageOfLevels</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    <span class="type">double</span> *ans = (<span class="type">double</span> *)<span class="built_in">malloc</span>(<span class="number">10000</span> * <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">    Queue *<span class="built_in">queue</span> = createQueue();</span><br><span class="line">    enQueue(<span class="built_in">queue</span>, root);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> size = <span class="built_in">queue</span>-&gt;size;</span><br><span class="line">        <span class="type">int</span> tmp_size = size;</span><br><span class="line">        <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">node</span> =</span> deQueue(<span class="built_in">queue</span>);</span><br><span class="line">            sum += node-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">                enQueue(<span class="built_in">queue</span>, node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">                enQueue(<span class="built_in">queue</span>, node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[(*returnSize)++] = sum / tmp_size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之优先队列（堆实现）</title>
    <url>/posts/231019102311.html</url>
    <content><![CDATA[<p>优先队列（priority queue）是最重要的元素始终位于最前面的队列。与普通队列不同的是，优先队列中的元素并不是按照先进先出的顺序进行处理，而是根据其优先级决定处理顺序，具有较高优先级的元素会优先被处理。<br>
优先队列可以是最大优先队列（最大的元素在前）或最小优先队列（最小的元素在先）。优先队列对于需要处理大数据量，并且需要反复确定哪一个现在是最大的或最小（最重要）的数据的算法非常有用。</p>
<span id="more"></span>
<h2 id="优先队列的实现方式">优先队列的实现方式</h2>
<p>在实现上，优先队列可以使用不同的数据结构来实现，例如堆、二叉搜索树、有序动态数组等。</p>
<ol>
<li><strong>使用有序动态数组实现</strong>：将最重要的数据放在数组的末尾。
<ul>
<li>缺点：插入新数据很慢，因为插入的数据必须保证数组依然有序。这就需要利用二分搜索算法确定插入的位置，并使用线性时间向后移动数组，以便新数据插入到那里。</li>
</ul>
</li>
<li><strong>使用平衡二叉树实现</strong>：这对于构建双端优先队列非常有用，因为它同时有效地实现了「查找最小值」和「查找最大值」（最重要和最不重要）。</li>
<li><strong>使用堆实现</strong>：堆是实现优先队列的天然数据结构。事实上，堆和优先队列这两个术语经常被用作同义词。
<ul>
<li>优点：堆比有序动态数组更有效，因为堆只需部分排序，堆的插入和删除操作都是 <code>O(log n)</code> 时间复杂度。</li>
</ul>
</li>
</ol>
<blockquote>
<p>使用堆来实现优先队列是最常见和高效的方式。</p>
</blockquote>
<h2 id="基于堆实现优先队列">基于堆实现优先队列</h2>
<p><a href="https://pursue26.github.io/posts/231018102559.html">数据结构之堆基础与堆结构（数组实现）</a>介绍了堆的基本理论知识和最大堆的实现。因此，我们基于这篇文章中实现的最大堆，进行简单的修改，实现优先队列这种数据结构。</p>
<h3 id="优先队列结构定义">优先队列结构定义</h3>
<p>为了体现堆中数据的复杂性，不再使用整形数值作为堆中的数据，而是使用结构体作为堆中的数据节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义堆中的数据, 不同优先级的待学习课程</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">    <span class="type">char</span> *course;</span><br><span class="line">&#125; Node_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Heap</span> &#123;</span></span><br><span class="line">    Node_t *heap;   <span class="comment">// 堆的数组</span></span><br><span class="line">    <span class="type">int</span> size;       <span class="comment">// 堆的当前大小</span></span><br><span class="line">    <span class="type">int</span> capacity;   <span class="comment">// 堆的容量</span></span><br><span class="line">&#125; PriorityQueue_t;</span><br></pre></td></tr></table></figure>
<h3 id="优先队列完整代码">优先队列完整代码</h3>
<p>这里，我们直接给出优先队列数据结构的完整代码，不明白的函数可以参考 <a href="https://pursue26.github.io/posts/231018102559.html"> 数据结构之堆基础与堆结构（数组实现）</a>中对应的小节。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义堆中的数据, 不同优先级的待学习课程</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">    <span class="type">char</span> *course;</span><br><span class="line">&#125; Node_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Heap</span> &#123;</span></span><br><span class="line">    Node_t *heap;   <span class="comment">// 堆的数组</span></span><br><span class="line">    <span class="type">int</span> size;       <span class="comment">// 堆的当前大小</span></span><br><span class="line">    <span class="type">int</span> capacity;   <span class="comment">// 堆的容量</span></span><br><span class="line">&#125; PriorityQueue_t;</span><br><span class="line"></span><br><span class="line">PriorityQueue_t* <span class="title function_">initPriorityQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PriorityQueue_t *<span class="built_in">queue</span> = (PriorityQueue_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(PriorityQueue_t));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;heap = (Node_t *)<span class="built_in">malloc</span>(capacity * <span class="keyword">sizeof</span>(Node_t));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;capacity = capacity;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getParentIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (index - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getLeftChildIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getRightChildIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (index &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(Node_t *s1, Node_t *s2)</span> &#123;</span><br><span class="line">    Node_t temp = *s1;</span><br><span class="line">    <span class="built_in">memcpy</span>(s1, s2, <span class="keyword">sizeof</span>(Node_t));</span><br><span class="line">    <span class="built_in">memcpy</span>(s2, &amp;temp, <span class="keyword">sizeof</span>(Node_t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">siftUp</span><span class="params">(PriorityQueue_t *<span class="built_in">queue</span>, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    Node_t *heap = <span class="built_in">queue</span>-&gt;heap;</span><br><span class="line">    <span class="type">int</span> parentIndex = getParentIndex(index);</span><br><span class="line">    <span class="keyword">while</span> ((index &gt; <span class="number">0</span>) &amp;&amp; (heap[index].priority &gt; heap[parentIndex].priority)) &#123;</span><br><span class="line">        swap(&amp;(heap[index]), &amp;(heap[parentIndex]));</span><br><span class="line">        index = parentIndex;  <span class="comment">// 交换节点后, 更新当前节点的位置</span></span><br><span class="line">        parentIndex = getParentIndex(index);  <span class="comment">// 重新获取父节点位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">siftDown</span><span class="params">(PriorityQueue_t* <span class="built_in">queue</span>, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxIndex = index;</span><br><span class="line">    <span class="type">int</span> leftChildIndex = getLeftChildIndex(index);</span><br><span class="line">    <span class="type">int</span> rightChildIndex = getRightChildIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来的两个判断为找出具有更大值的孩子的索引</span></span><br><span class="line">    <span class="keyword">if</span> (leftChildIndex &lt; <span class="built_in">queue</span>-&gt;size &amp;&amp; <span class="built_in">queue</span>-&gt;heap[leftChildIndex].priority &gt; <span class="built_in">queue</span>-&gt;heap[maxIndex].priority) &#123;</span><br><span class="line">        maxIndex = leftChildIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rightChildIndex &lt; <span class="built_in">queue</span>-&gt;size &amp;&amp; <span class="built_in">queue</span>-&gt;heap[rightChildIndex].priority &gt; <span class="built_in">queue</span>-&gt;heap[maxIndex].priority) &#123;</span><br><span class="line">        maxIndex = rightChildIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index != maxIndex) &#123;</span><br><span class="line">        swap(&amp;(<span class="built_in">queue</span>-&gt;heap[index]), &amp;(<span class="built_in">queue</span>-&gt;heap[maxIndex]));</span><br><span class="line">        siftDown(<span class="built_in">queue</span>, maxIndex);  <span class="comment">// 递归方式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(PriorityQueue_t *<span class="built_in">queue</span>, Node_t *node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;size &gt;= <span class="built_in">queue</span>-&gt;capacity) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Queue is full!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;heap[<span class="built_in">queue</span>-&gt;size] = *node;  <span class="comment">// 存储在堆数组的最后一个索引后面</span></span><br><span class="line">    siftUp(<span class="built_in">queue</span>, <span class="built_in">queue</span>-&gt;size);  <span class="comment">// 进行堆化中的上浮操作</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">peek</span><span class="params">(PriorityQueue_t *<span class="built_in">queue</span>, Node_t* top)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(top, <span class="number">0</span>, <span class="keyword">sizeof</span>(Node_t));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Queue is empty!\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(top, &amp;(<span class="built_in">queue</span>-&gt;heap[<span class="number">0</span>]), <span class="keyword">sizeof</span>(Node_t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop</span><span class="params">(PriorityQueue_t *<span class="built_in">queue</span>, Node_t* top)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(top, <span class="number">0</span>, <span class="keyword">sizeof</span>(Node_t));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Queue is empty!\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(top, &amp;(<span class="built_in">queue</span>-&gt;heap[<span class="number">0</span>]), <span class="keyword">sizeof</span>(Node_t));</span><br><span class="line">        <span class="built_in">queue</span>-&gt;heap[<span class="number">0</span>] = <span class="built_in">queue</span>-&gt;heap[<span class="built_in">queue</span>-&gt;size - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">queue</span>-&gt;size--;</span><br><span class="line">        siftDown(<span class="built_in">queue</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printPriorityQueue</span><span class="params">(PriorityQueue_t *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Priority queue:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">queue</span>-&gt;size; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;    %s: %d\n&quot;</span>, <span class="built_in">queue</span>-&gt;heap[i].course, <span class="built_in">queue</span>-&gt;heap[i].priority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyPriorityQueue</span><span class="params">(PriorityQueue_t *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">queue</span>-&gt;heap);</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">10</span>, capacity = <span class="number">10</span>;</span><br><span class="line">    Node_t node[] = &#123;</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="string">&quot;Computer Science&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">7</span>, <span class="string">&quot;Discrete Mathematics&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">26</span>, <span class="string">&quot;Data Structures and Algorithms&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">25</span>, <span class="string">&quot;Operating Systems&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">19</span>, <span class="string">&quot;C Programming Languages&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">17</span>, <span class="string">&quot;Computer Networks&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="string">&quot;Database Management Systems&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">90</span>, <span class="string">&quot;Artificial Intelligence&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, <span class="string">&quot;Linear Algebra&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">36</span>, <span class="string">&quot;Calculus&quot;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    PriorityQueue_t *<span class="built_in">queue</span> = initPriorityQueue(capacity);</span><br><span class="line">    Node_t *topNode = (Node_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node_t));</span><br><span class="line">    <span class="built_in">memset</span>(topNode, <span class="number">0</span>, <span class="keyword">sizeof</span>(Node_t));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        push(<span class="built_in">queue</span>, &amp;(node[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    printPriorityQueue(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    peek(<span class="built_in">queue</span>, topNode);</span><br><span class="line">    <span class="keyword">if</span> (topNode-&gt;course &amp;&amp; topNode != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Priority queue top course: %s\n&quot;</span>, topNode-&gt;course);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pop(<span class="built_in">queue</span>, topNode);</span><br><span class="line">    <span class="keyword">if</span> (topNode-&gt;course &amp;&amp; topNode != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Priority queue pop course: %s\n&quot;</span>, topNode-&gt;course);</span><br><span class="line">    &#125;</span><br><span class="line">    printPriorityQueue(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        pop(<span class="built_in">queue</span>, topNode);</span><br><span class="line">        <span class="keyword">if</span> (topNode-&gt;course &amp;&amp; topNode != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Priority queue pop course: %s\n&quot;</span>, topNode-&gt;course);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(topNode);</span><br><span class="line">    destroyPriorityQueue(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Priority queue:</span><br><span class="line">    Artificial Intelligence: 90</span><br><span class="line">    Calculus: 36</span><br><span class="line">    Computer Networks: 17</span><br><span class="line">    Operating Systems: 25</span><br><span class="line">    Data Structures and Algorithms: 26</span><br><span class="line">    Discrete Mathematics: 7</span><br><span class="line">    Database Management Systems: 1</span><br><span class="line">    Computer Science: 2</span><br><span class="line">    Linear Algebra: 3</span><br><span class="line">    C Programming Languages: 19</span><br><span class="line">Priority queue top course: Artificial Intelligence</span><br><span class="line">Priority queue pop course: Artificial Intelligence</span><br><span class="line">Priority queue:</span><br><span class="line">    Calculus: 36</span><br><span class="line">    Data Structures and Algorithms: 26</span><br><span class="line">    Computer Networks: 17</span><br><span class="line">    Operating Systems: 25</span><br><span class="line">    C Programming Languages: 19</span><br><span class="line">    Discrete Mathematics: 7</span><br><span class="line">    Database Management Systems: 1</span><br><span class="line">    Computer Science: 2</span><br><span class="line">    Linear Algebra: 3</span><br><span class="line">Priority queue pop course: Calculus</span><br><span class="line">Priority queue pop course: Data Structures and Algorithms</span><br><span class="line">Priority queue pop course: Operating Systems</span><br><span class="line">Priority queue pop course: C Programming Languages</span><br><span class="line">Priority queue pop course: Computer Networks</span><br><span class="line">Priority queue pop course: Discrete Mathematics</span><br><span class="line">Priority queue pop course: Linear Algebra</span><br><span class="line">Priority queue pop course: Computer Science</span><br><span class="line">Priority queue pop course: Database Management Systems</span><br><span class="line">Queue is empty!</span><br></pre></td></tr></table></figure>
<p>在这个代码中，你可能已经注意到函数 <code>peek</code> 和 <code>pop</code> 的返回值类型是 <code>void</code>，且增加了一个入参 <code>Node_t *</code>。这是因为，这里实现的堆优先队列中存储的是复杂的结构体，我们在获取堆顶数据或弹出堆顶数据时，需要保存数据的所有内容。完成这个目的可以考虑以下两种方式：</p>
<ol>
<li>增加一个 <code>Node_t *</code> 入参：将外部申请的一块空间的地址传进来，用于保存堆顶数据，同时也可以处理堆优先队列为空的分支。这种方式，在读取数据及时的情况下，可以实现重复利用这块空间。</li>
<li>将函数 <code>peek</code> 和 <code>pop</code> 的返回值修改为 <code>Node_t *</code>：这种方式需要在函数内部 <code>malloc</code> 一块空间用于保存返回的数据块，后续需要由用户手动释放每次函数调用所申请的空间，避免内存泄漏。
<ul>
<li>这种方式，需要多次 <code>malloc</code> 申请空间和多次 <code>free</code> 释放空间，且没有尽可能地遵循谁申请谁释放的原则。</li>
<li><strong>我们不能将堆顶的地址直接作为函数的返回值，因为堆顶的地址的数据是不固定的（在堆化时会被修改）</strong>。</li>
</ul>
</li>
</ol>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://github.com/kodecocodes/swift-algorithm-club/tree/master/Priority%20Queue">Priority Queue in swift-algorithm-club</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>优先队列</category>
      </categories>
      <tags>
        <tag>优先队列</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之单调栈</title>
    <url>/posts/231127185207.html</url>
    <content><![CDATA[<p> 何为单调栈？顾名思义，单调栈即满足单调性的栈结构，可以是单调递增或单调递减。在单调栈中，栈顶元素是栈内最大（或最小）的元素，而栈底元素是栈内最小（或最大）的元素。</p>
<p><strong> 单调栈在解决一些与区间相关的问题时非常有用 </strong>。它可以帮助我们快速找到每个元素左边或右边第一个比它大或小的元素：通过维护一个单调递增栈，我们可以找到每个元素右边第一个比它小的元素；通过维护一个单调递减栈，我们可以找到每个元素右边第一个比它大的元素。</p>
<span id="more"></span>
<h2 id="单调栈"> 单调栈 </h2>
<p> 单调栈（monotonic stack）是一种特殊的栈数据结构，常用于解决与区间相关的问题。它的特点是栈内元素具有单调性，可以是单调递增或单调递减。</p>
<blockquote>
<p> 这里的「单调」为广义上的单调，即为非严格单调性，包括「等于」的情况。</p>
</blockquote>
<h3 id="基本操作"> 基本操作 </h3>
<p> 单调栈支持以下操作：</p>
<ul>
<li> 入栈（push）：将元素压入栈顶。</li>
<li> 出栈（pop）：将栈顶元素弹出。</li>
<li> 获取栈顶元素（top）：返回栈顶元素的值，但不弹出栈顶元素。</li>
<li> 判断栈是否为空（isEmpty）：返回栈是否为空的布尔值。</li>
</ul>
<h3 id="应用场景"> 应用场景 </h3>
<p><strong> 单调栈在解决一些与区间相关的问题时非常有用 </strong>，例如：</p>
<ul>
<li> 寻找每个元素右边第一个比它大（或小）的元素。</li>
<li> 寻找数组中的下一个更大（或更小）元素。</li>
<li> 寻找数组中的最大矩形面积（矩阵是以数组中的值为高度、宽度指定）。</li>
</ul>
<h3 id="算法思想"> 算法思想 </h3>
<p> 单调栈的基本思想是维护一个单调递增或单调递减的栈。具体操作如下：</p>
<ul>
<li> 对于每个元素，如果栈为空或当前元素大于（或小于）栈顶元素，则将当前元素入栈。</li>
<li> 如果当前元素小于（或大于）栈顶元素，说明找到了栈顶元素的右边第一个小于（或大于）它的元素。此时，可以对栈进行出栈操作，直到栈为空或新元素大于（或小于）栈顶元素。</li>
<li> 继续将当前元素入栈。</li>
</ul>
<h3 id="维护单调栈示例过程"> 维护单调栈示例过程 </h3>
<p> 对于数组 <code>[2,1,5,6,2,3]</code>，我们维护一个单调递增栈（栈底元素最小、栈顶元素最大）的过程如下：</p>
<p> 第一步，栈为空，入栈新元素 <code>2</code>，此时单调递增栈（左侧为栈底、右侧为栈顶）的状态为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">monoStack: [2]</span><br></pre></td></tr></table></figure>
<p> 第二步，栈不为空，新元素 <code>1</code> 小于栈顶元素 <code>2</code>，弹出元素 <code>2</code> 后，栈为空，入栈新元素 <code>1</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">monoStack: [1]</span><br></pre></td></tr></table></figure>
<p> 第三步，栈不为空，新元素 <code>5</code> 大于栈顶元素 <code>1</code>，入栈新元素 <code>5</code>；栈不为空，新元素 <code>6</code> 大于栈顶元素 <code>5</code>，入栈新元素 <code>6</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">monoStack: [1, 5, 6]</span><br></pre></td></tr></table></figure>
<p> 第四步，栈不为空，新元素 <code>2</code> 小于栈顶元素 <code>6</code>，栈顶元素 <code>6</code> 出栈；栈不为空，新元素 <code>2</code> 小于栈顶元素 <code>5</code>，栈顶元素 <code>5</code> 出栈：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">monoStack: [1]</span><br></pre></td></tr></table></figure>
<p> 第五步，栈不为空，新元素 <code>2</code> 大于栈顶元素 <code>1</code>，新元素入栈后满足单调性，新元素 <code>2</code> 入栈：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">monoStack: [1, 2]</span><br></pre></td></tr></table></figure>
<p> 第六步，栈不为空，新元素 <code>3</code> 大于栈顶元素 <code>2</code>，新元素入栈后满足单调性，新元素 <code>3</code> 入栈：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">monoStack: [1, 2, 3]</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 由第二步可知，元素 <code>2</code> 右侧第一个比它小的元素是元素 <code>1</code>；由第四步可知，元素 <code>5</code> 和元素 <code>6</code> 右侧第一个比它小的元素都是元素 <code>2</code>；由最后一步可知，元素 <code>1,2,3</code> 右侧没有比它小的元素。</p>
</blockquote>
<h3 id="伪代码"> 伪代码 </h3>
<h4 id="单调递增栈"> 单调递增栈 </h4>
<p> 单调递增栈的栈顶元素最大，新插入的元素要不小于栈顶元素，否则只能把栈顶元素一个一个地弹出栈，直到满足为止。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// insert x</span></span><br><span class="line"><span class="keyword">while</span> (!monoStack.empty() &amp;&amp; x &lt; monoStack.top()) &#123;</span><br><span class="line">    monoStack.pop()</span><br><span class="line">&#125;</span><br><span class="line">monoStack.push(x)</span><br></pre></td></tr></table></figure>
<h4 id="单调递减栈"> 单调递减栈 </h4>
<p> 单调递减栈的栈顶元素最小，新插入的元素要不大于栈顶元素，否则只能把栈顶元素一个一个地弹出栈，直到满足为止。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// insert x</span></span><br><span class="line"><span class="keyword">while</span> (!monoStack.empty() &amp;&amp; x &gt; monoStack.top()) &#123;</span><br><span class="line">    monoStack.pop()</span><br><span class="line">&#125;</span><br><span class="line">monoStack.push(x)</span><br></pre></td></tr></table></figure>
<h3 id="复杂度"> 复杂度 </h3>
<p> 每个元素最多只会进栈、出栈一次，故时间复杂度为 <code>O(n)</code>，空间复杂度为 <code>O(n)</code>，<code>n</code> 为元素数量。</p>
<h2 id="单调栈应用场景实现"> 单调栈应用场景实现 </h2>
<p> 题目：寻找数组中每个元素右边比它小的第一个元素。</p>
<h3 id="实现代码"> 实现代码 </h3>
<p> 这可以使用单调递增栈找到每个元素右边第一个比它小的元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">findNextSmaller</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> n, <span class="type">int</span> res[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> monoStack[n], size = <span class="number">0</span>; <span class="comment">// 使用数组模拟栈结构 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        res[i] = <span class="number">-1</span>; <span class="comment">// 初始化结果数组，-1 表示右侧没有比我小的元素 </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt; nums[monoStack[size - <span class="number">1</span>]]) &#123;  <span class="comment">// monoStack.top()</span></span><br><span class="line">            res[monoStack[--size]] = nums[i];  <span class="comment">// monoStack.pop()</span></span><br><span class="line">        &#125;</span><br><span class="line">        monoStack[size++] = i;  <span class="comment">// monoStack.push(x)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> nums[] = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(nums) / <span class="keyword">sizeof</span>(nums[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> res[n];</span><br><span class="line"></span><br><span class="line">    findNextSmaller(nums, n, res);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d next smaller: %d\n&quot;</span>, nums[i], res[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试结果"> 测试结果 </h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 next smaller: 1</span><br><span class="line">1 next smaller: -1</span><br><span class="line">5 next smaller: 2</span><br><span class="line">6 next smaller: 2</span><br><span class="line">2 next smaller: -1</span><br><span class="line">3 next smaller: -1</span><br></pre></td></tr></table></figure>
<p> 这个结果与上面的“维护单调栈示例过程”中的举例的结果一致。</p>
<h3 id="代码分析"> 代码分析 </h3>
<p> 在代码实现中，我们并没有直接在单调栈 <code>monoStack</code> 中存储数组元素的值，而是存储了数组元素对应的索引：</p>
<ol>
<li> 这方便了通过索引向结果数组 <code>res</code> 的对应位置，填充右边第一个比它小的值；</li>
<li> 因为原始数组 <code>nums</code> 的索引对应的值不会改变，我们依然可以通过 <code>monoStack</code> 中维护的索引，获取对应的值，保证栈的单调性。</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>单调栈</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之双端队列（链表实现）</title>
    <url>/posts/231017154121.html</url>
    <content><![CDATA[<p>队列提供了一种先进先出（FIFO, First-In First-Out）的存储结构。在 <a href="https://pursue26.github.io/posts/231017105123.html"> 数据结构之队列（链表实现）</a>中，我们介绍了链表实现的队列数据结构，但这种普通的队列只能从尾部插入节点、从首部删除节点。</p>
<p>双端队列（Deque, double-ended queue）是普通队列的扩展，是指允许两端都可以进行入队和出队操作的队列，它不遵循 FIFO 原则。这篇文章扩展了 <a href="https://pursue26.github.io/posts/231017105123.html"> 数据结构之队列（链表实现）</a>，实现了基于链表的双端队列。</p>
<span id="more"></span>
<h2 id="FIFO 队列结构和接口">FIFO 队列结构和接口</h2>
<p>下面是 <a href="https://pursue26.github.io/posts/231017105123.html"> 数据结构之队列（链表实现）</a>中实现的普通队列的数据结构和 API 接口。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagTreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagTreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagTreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagLinkedNode</span> &#123;</span></span><br><span class="line">    TreeNode_t *data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagLinkedNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LinkedNode_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagQueue</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    LinkedNode_t *front;</span><br><span class="line">    LinkedNode_t *rear;</span><br><span class="line">&#125; Queue_t;</span><br><span class="line"></span><br><span class="line">Queue_t *<span class="title function_">createQueue</span><span class="params">(<span class="type">int</span> max_size)</span>;</span><br><span class="line">LinkedNode_t *<span class="title function_">createNode</span><span class="params">(TreeNode_t *data)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Queue_t *<span class="built_in">queue</span>)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Queue_t *<span class="built_in">queue</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">enQueue</span><span class="params">(Queue_t *<span class="built_in">queue</span>, TreeNode_t *data)</span>;</span><br><span class="line">TreeNode_t *<span class="title function_">deQueue</span><span class="params">(Queue_t* <span class="built_in">queue</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(Queue_t* <span class="built_in">queue</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">freeQueue</span><span class="params">(Queue_t* <span class="built_in">queue</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>为了实现双端队列，我们需要在普通队列的基础上，增加两个操作：</p>
<ol>
<li>一个就是在队列首部执行入队操作（插入节点），我们使用接口 <code>void enQueueFront(Queue_t *queue, TreeNode_t *data)</code>；</li>
<li>另一个就是在队列尾部执行出队操作（删除节点），我们使用接口 <code>TreeNode_t *deQueueRear(Queue_t* queue)</code>。</li>
</ol>
<p>下面就来实现这两个接口。为了一致，这里不再修改队列结构体的别名从 <code>Queue_t</code> 到 <code>Deque_t</code>。</p>
<h2 id="双端队列之队首入队操作">双端队列之队首入队操作</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">enQueueFront</span><span class="params">(Queue_t *<span class="built_in">queue</span>, TreeNode_t *data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;queue is full.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LinkedNode_t *newNode = createNode(data);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">            <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newNode-&gt;next = <span class="built_in">queue</span>-&gt;front;  <span class="comment">// 新节点指向队列头结点</span></span><br><span class="line">            <span class="built_in">queue</span>-&gt;front = newNode;  <span class="comment">// 新节点成为队列头结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;size += <span class="number">1</span>;  <span class="comment">// 更新队列大小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>普通队列在队尾入队的过程是：队列尾指针指向新入队的节点，然后更新队列尾指针为该节点地址。与普通队列在队尾入队操作不同的是，双端队列在队首入队的过程是：新节点指向队列头指针，然后更新队列头指针为新节点地址。</p>
<h2 id="双端队列之队尾出队操作">双端队列之队尾出队操作</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode_t *<span class="title function_">deQueueRear</span><span class="params">(Queue_t* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedNode_t *prev = <span class="literal">NULL</span>;</span><br><span class="line">    LinkedNode_t *curr = <span class="built_in">deque</span>-&gt;front;</span><br><span class="line">    <span class="keyword">while</span> (curr-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode_t *data = curr-&gt;data;</span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        prev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">deque</span>-&gt;rear = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">deque</span>-&gt;front = <span class="built_in">deque</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">deque</span>-&gt;size -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(curr);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>普通队列执行出队操作的时间复杂度为 <code>O(1)</code>，而这里双端队列在队尾出队的操作的时间复杂度为 <code>O(n)</code>。这是因为普通队列在队首出队后，可以直接通过 <code>queue-&gt;front-&gt;next</code> 操作确定新的头指针，而双端队列在队尾出队后，只能通过遍历队列中的节点，找到倒数第二个节点，才能确定新的尾指针。</p>
<p>那么，如何提高双端队列的队尾出队操作的时间复杂度呢？</p>
<p>可以通过将链表修改为双端链表，即不再只有一个 <code>next</code> 指针，同时还有一个 <code>prev</code> 指针，用于指向链表中当前节点的上一个节点。这样就可以实现 <code>O(1)</code> 时间复杂度的双端队列的队尾出队操作。</p>
<h2 id="双端链表实现的双端队列">双端链表实现的双端队列</h2>
<h3 id="结构示意图">结构示意图</h3>
<p>下面是一个示意双端队列的线条图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">front                                               rear</span><br><span class="line">  ↓                                                  ↓</span><br><span class="line">+---+            +---+            +---+            +---+</span><br><span class="line">|   | ← prev   ← |   | ← prev   ← |   | ← prev   ← |   |</span><br><span class="line">|   |            |   |            |   |            |   |</span><br><span class="line">|   | → next   → |   | → next   → |   | → next   → |   |</span><br><span class="line">+---+            +---+            +---+            +---+</span><br></pre></td></tr></table></figure>
<p>在双端队列中，有两个方向：从头 <code>front</code> 到尾 <code>rear</code> 和从尾到头。每个节点都有一个指向前一个节点的指针 <code>prev</code> 和一个指向后一个节点的指针 <code>next</code>。<code>front</code> 指向队列的头部节点，<code>rear</code> 指向队列的尾部节点。</p>
<img src="../images/data-structure/deque-struct.png" alt="双端队列数据结构" width="80%" height="80%">
<h3 id="完整代码">完整代码</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagTreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagTreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagTreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagLinkedNode</span> &#123;</span></span><br><span class="line">    TreeNode_t *data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagLinkedNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagLinkedNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LinkedNode_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagQueue</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    LinkedNode_t *front;</span><br><span class="line">    LinkedNode_t *rear;</span><br><span class="line">&#125; Deque_t;</span><br><span class="line"></span><br><span class="line">Deque_t *<span class="title function_">createDeque</span><span class="params">(<span class="type">int</span> max_size)</span> &#123;</span><br><span class="line">    Deque_t *<span class="built_in">deque</span> = (Deque_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Deque_t));</span><br><span class="line">    <span class="built_in">deque</span>-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">deque</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">deque</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">deque</span>-&gt;max = max_size;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">deque</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LinkedNode_t *<span class="title function_">createNode</span><span class="params">(TreeNode_t *data)</span> &#123;</span><br><span class="line">    LinkedNode_t *newNode = (LinkedNode_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkedNode_t));</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Deque_t *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">deque</span>-&gt;size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Deque_t *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">deque</span>-&gt;size &gt;= <span class="built_in">deque</span>-&gt;max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enDeque</span><span class="params">(Deque_t *<span class="built_in">deque</span>, TreeNode_t *data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;deque is full.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LinkedNode_t *newNode = createNode(data);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">            <span class="built_in">deque</span>-&gt;front = <span class="built_in">deque</span>-&gt;rear = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LinkedNode_t *curRear = <span class="built_in">deque</span>-&gt;rear;</span><br><span class="line">            curRear-&gt;next = newNode;  <span class="comment">// 尾指针链接新数据</span></span><br><span class="line">            <span class="built_in">deque</span>-&gt;rear = newNode;  <span class="comment">// 尾指针指向新数据</span></span><br><span class="line">            <span class="built_in">deque</span>-&gt;rear-&gt;prev = curRear;  <span class="comment">// !! 双端队列!!, 尾指针的上一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">deque</span>-&gt;size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enDequeFront</span><span class="params">(Deque_t *<span class="built_in">deque</span>, TreeNode_t *data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;deque is full.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LinkedNode_t *newNode = createNode(data);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">            <span class="built_in">deque</span>-&gt;front = <span class="built_in">deque</span>-&gt;rear = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newNode-&gt;next = <span class="built_in">deque</span>-&gt;front;  <span class="comment">// 新节点指向队列头结点</span></span><br><span class="line">            <span class="built_in">deque</span>-&gt;front-&gt;prev = newNode;  <span class="comment">// !! 双端队列!!, 头指针的上一个节点</span></span><br><span class="line">            <span class="built_in">deque</span>-&gt;front = newNode;  <span class="comment">// 新节点成为队列头结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">deque</span>-&gt;size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode_t *<span class="title function_">deDeque</span><span class="params">(Deque_t* <span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedNode_t *node = <span class="built_in">deque</span>-&gt;front;</span><br><span class="line">    TreeNode_t *data = node-&gt;data;</span><br><span class="line">    <span class="comment">// 根据当前队列中节点的数量，决定是否同步更新队列的尾指针</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">deque</span>-&gt;size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">deque</span>-&gt;front = <span class="built_in">deque</span>-&gt;front-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">deque</span>-&gt;front = <span class="built_in">deque</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">deque</span>-&gt;size -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode_t *<span class="title function_">deDequeRear</span><span class="params">(Deque_t* <span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedNode_t *node = <span class="built_in">deque</span>-&gt;rear;</span><br><span class="line">    TreeNode_t *data = node-&gt;data;</span><br><span class="line">    <span class="comment">// 根据当前队列中节点的数量，决定是否同步更新队列的尾指针</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">deque</span>-&gt;size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">deque</span>-&gt;rear = <span class="built_in">deque</span>-&gt;rear-&gt;prev;</span><br><span class="line">        <span class="built_in">deque</span>-&gt;rear-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">deque</span>-&gt;front = <span class="built_in">deque</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">deque</span>-&gt;size -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printDeque</span><span class="params">(Deque_t* <span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Deque is empty\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Deque: &quot;</span>);</span><br><span class="line">        LinkedNode_t *node = <span class="built_in">deque</span>-&gt;front;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;data-&gt;val);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeDeque</span><span class="params">(Deque_t* <span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">deque</span> &amp;&amp;(!isEmpty(<span class="built_in">deque</span>)))&#123;</span><br><span class="line">        LinkedNode_t *node = <span class="built_in">deque</span>-&gt;front;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            LinkedNode_t *tmp = node-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(node);</span><br><span class="line">            node = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(<span class="built_in">deque</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    Deque_t *<span class="built_in">deque</span> = createDeque(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一些测试用的树节点</span></span><br><span class="line">    TreeNode_t *node = (TreeNode_t *)<span class="built_in">malloc</span>(<span class="number">5</span> * <span class="keyword">sizeof</span>(TreeNode_t));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        node[i].val = <span class="number">10</span> + i;</span><br><span class="line">        node[i].left = <span class="literal">NULL</span>;</span><br><span class="line">        node[i].right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printDeque(<span class="built_in">deque</span>);</span><br><span class="line"></span><br><span class="line">    enDequeFront(<span class="built_in">deque</span>, &amp;node[<span class="number">0</span>]);</span><br><span class="line">    enDequeFront(<span class="built_in">deque</span>, &amp;node[<span class="number">1</span>]);</span><br><span class="line">    enDeque(<span class="built_in">deque</span>, &amp;node[<span class="number">2</span>]);</span><br><span class="line">    printDeque(<span class="built_in">deque</span>);</span><br><span class="line"></span><br><span class="line">    enDequeFront(<span class="built_in">deque</span>, &amp;node[<span class="number">3</span>]);</span><br><span class="line">    enDeque(<span class="built_in">deque</span>, &amp;node[<span class="number">4</span>]);</span><br><span class="line">    printDeque(<span class="built_in">deque</span>);</span><br><span class="line"></span><br><span class="line">    TreeNode_t *data1 = deDeque(<span class="built_in">deque</span>);</span><br><span class="line">    TreeNode_t *data2 = deDequeRear(<span class="built_in">deque</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Removed data: %d %d\n&quot;</span>, data1-&gt;val, data2-&gt;val); <span class="comment">// 实际工程中要先判非空再取数据</span></span><br><span class="line">    TreeNode_t *data3 = deDequeRear(<span class="built_in">deque</span>);</span><br><span class="line">    TreeNode_t *data4 = deDeque(<span class="built_in">deque</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Removed data: %d %d\n&quot;</span>, data3-&gt;val, data4-&gt;val);</span><br><span class="line">    printDeque(<span class="built_in">deque</span>);</span><br><span class="line"></span><br><span class="line">    freeDeque(<span class="built_in">deque</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放测试用的树节点内存</span></span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Deque is empty</span><br><span class="line">Deque: 11 10 12</span><br><span class="line">Deque: 13 11 10 12 14</span><br><span class="line">Removed data: 13 14</span><br><span class="line">Removed data: 12 11</span><br><span class="line">Deque: 10</span><br></pre></td></tr></table></figure>
<p>在上述代码中，与 <a href="https://pursue26.github.io/posts/231017105123.html#%20%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C"> 普通队列中的入队操作 </a> 的两点区别是：</p>
<ol>
<li>在双端链表实现的双端队列中，在 <strong> 队尾入队 </strong> 操作中增加了队尾指针的前一个节点的代码 <code>deque-&gt;rear-&gt;prev = curRear</code>，服务于队尾出队的操作。</li>
<li>在双端链表实现的双端队列中，在 <strong> 队首入队 </strong> 操作中增加了队首指针的前一个节点的代码 <code>deque-&gt;front-&gt;prev = newNode</code>，服务于队尾出队的操作。</li>
</ol>
<p>为什么序号 2 中的那行代码也服务于队尾出队操作呢？</p>
<p>设想以下操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">enDequeFront(<span class="built_in">deque</span>, &amp;node[<span class="number">0</span>]);</span><br><span class="line">enDequeFront(<span class="built_in">deque</span>, &amp;node[<span class="number">1</span>]);</span><br><span class="line">deDequeRear(<span class="built_in">deque</span>);</span><br></pre></td></tr></table></figure>
<p>一开始就往队首插入节点，如果没有代码 <code>deque-&gt;front-&gt;prev = newNode</code>，那么尾结点的前一个节点地址将为 <code>NULL</code>，则无法更新指定尾结点。</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>队列</category>
      </categories>
      <tags>
        <tag>队列</tag>
        <tag>双端队列</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之堆栈（数组实现）</title>
    <url>/posts/231016161508.html</url>
    <content><![CDATA[<p>栈与数组类似，但功能受限，只能通过 push 将新元素添加到栈的顶部，通过 pop 从栈中移除顶部的元素，并通过 peek 查看顶部的元素而不将其弹出。栈提供了后进先出（LIFO, last-in first-out）的顺序，最后推入的元素将在下一次弹出时首先出栈。</p>
<span id="more"></span>
<h2 id="堆栈的实现方式">堆栈的实现方式</h2>
<p>在 C 语言中，可以使用以下方法来实现堆栈（stack）数据结构：</p>
<ol>
<li>
<p>使用数组：可以使用一个固定大小的数组来表示堆栈。堆栈有两个重要的指针：一个是指向栈顶的指针，另一个是指向栈底的指针。在数组中，栈顶指针指向最新添加的元素，栈底指针指向最旧的元素。可以使用数组的索引来实现栈的推入 (push) 和弹出 (pop) 操作。</p>
</li>
<li>
<p>使用链表：可以使用链表来表示堆栈。链表中的每个节点包含一个元素和一个指向下一个节点的指针。栈顶指针指向链表的第一个节点，栈底指针指向链表的最后一个节点。入栈操作将创建一个新节点，并将其插入链表的开头；出栈操作将删除链表的第一个节点。</p>
</li>
</ol>
<blockquote>
<p>链表实现堆栈时，<strong>采用头插法</strong>，即在链表头结点前插入新节点、删除节点。这样做，方便 push 和 pop 操作；如果在链表的最后插入新节点，那么在 pop 操作时，更新栈顶的节点指针将会很麻烦 &amp; 费时。</p>
</blockquote>
<p>这篇文章将介绍使用数组实现堆栈这种数据结构。</p>
<h2 id="数组实现堆栈">数组实现堆栈</h2>
<h3 id="定义并初始化堆栈结构">定义并初始化堆栈结构</h3>
<p>使用一个固定长度的数组来实现具有先进先出的堆栈结构。为了将不同的堆栈和栈顶位置对应起来，这里使用一个结构体来组合堆栈和栈顶位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE (3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCEPTION_VALUE (-1) </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data[MAX_SIZE];  <span class="comment">// 数组实现堆栈</span></span><br><span class="line">    <span class="type">int</span> top;  <span class="comment">// 初始化栈顶位置</span></span><br><span class="line">&#125; Stack;</span><br></pre></td></tr></table></figure>
<h3 id="初始化堆栈">初始化堆栈</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// memset(stack-&gt;data, 0, MAX_SIZE * sizeof(int));</span></span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断堆栈是否为空">判断堆栈是否为空</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断堆栈是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断堆栈是否已满">判断堆栈是否已满</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断堆栈是否已满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == MAX_SIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="入栈操作">入栈操作</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元素入栈</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">push</span><span class="params">(Stack *<span class="built_in">stack</span>, <span class="type">int</span> element)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is full\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;data[++(<span class="built_in">stack</span>-&gt;top)] = element;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="出栈操作">出栈操作</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元素出栈</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[(<span class="built_in">stack</span>-&gt;top)--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了区分栈空时的返回值与正常出栈的数据，需要定义异常值为不会出现在正常数据中的值；或者修改函数的返回值为指针类型，返回值不为空时对应着有效数据。</p>
<h3 id="获取栈顶元素">获取栈顶元素</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取栈顶元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="打印堆栈数据">打印堆栈数据</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印堆栈中的元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printStack</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">stack</span>-&gt;top; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">stack</span>-&gt;data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组实现堆栈完整代码">数组实现堆栈完整代码</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE (3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCEPTION_VALUE (-1) </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data[MAX_SIZE];  <span class="comment">// 数组实现堆栈</span></span><br><span class="line">    <span class="type">int</span> top;  <span class="comment">// 初始化栈顶位置</span></span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// memset(stack-&gt;data, 0, MAX_SIZE * sizeof(int));</span></span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == MAX_SIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">push</span><span class="params">(Stack *<span class="built_in">stack</span>, <span class="type">int</span> element)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is full\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;data[++(<span class="built_in">stack</span>-&gt;top)] = element;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[(<span class="built_in">stack</span>-&gt;top)--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printStack</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">stack</span>-&gt;top; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">stack</span>-&gt;data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> *argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    Stack stack1;</span><br><span class="line">    initStack(&amp;stack1);</span><br><span class="line"></span><br><span class="line">    printStack(&amp;stack1);</span><br><span class="line">    push(&amp;stack1, <span class="number">1</span>);</span><br><span class="line">    push(&amp;stack1, <span class="number">2</span>);</span><br><span class="line">    push(&amp;stack1, <span class="number">3</span>);</span><br><span class="line">    printStack(&amp;stack1);</span><br><span class="line">    push(&amp;stack1, <span class="number">4</span>);</span><br><span class="line">    printStack(&amp;stack1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Pop element: %d\n&quot;</span>, pop(&amp;stack1));</span><br><span class="line">    printStack(&amp;stack1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Top element: %d\n&quot;</span>, peek(&amp;stack1));</span><br><span class="line">    printStack(&amp;stack1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stack is empty</span><br><span class="line">Stack: 1 2 3</span><br><span class="line">Stack is full</span><br><span class="line">Stack: 1 2 3</span><br><span class="line">Pop element: 3</span><br><span class="line">Stack: 1 2</span><br><span class="line">Top element: 2</span><br><span class="line">Stack: 1 2</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>堆栈</category>
      </categories>
      <tags>
        <tag>堆栈</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之堆栈（链表实现）</title>
    <url>/posts/231016184406.html</url>
    <content><![CDATA[<p>堆栈提供了一种后进先出（LIFO, last-in first-out）存储结构。在 <a href="https://pursue26.github.io/posts/231016161508.html"> 数据结构之堆栈（数组实现）</a>中，我们介绍了数组实现的堆栈，这篇文章将介绍通过链表的方式实现堆栈这种数据结构。</p>
<span id="more"></span>
<h2 id="堆栈的实现方式">堆栈的实现方式</h2>
<p>在 C 语言中，可以使用以下方法来实现堆栈（stack）数据结构：</p>
<ol>
<li>
<p>使用数组：可以使用一个固定大小的数组来表示堆栈。堆栈有两个重要的指针：一个是指向栈顶的指针，另一个是指向栈底的指针。在数组中，栈顶指针指向最新添加的元素，栈底指针指向最旧的元素。可以使用数组的索引来实现栈的推入 (push) 和弹出 (pop) 操作。</p>
</li>
<li>
<p>使用链表：可以使用链表来表示堆栈。链表中的每个节点包含一个元素和一个指向下一个节点的指针。栈顶指针指向链表的第一个节点，栈底指针指向链表的最后一个节点。入栈操作将创建一个新节点，并将其插入链表的开头；出栈操作将删除链表的第一个节点。</p>
</li>
</ol>
<blockquote>
<p>链表实现堆栈时，<strong>采用头插法</strong>，即在链表头结点前插入新节点、删除节点。这样做，方便 push 和 pop 操作；如果在链表的最后插入新节点，那么在 pop 操作时，更新栈顶的节点指针将会很麻烦 &amp; 费时。</p>
</blockquote>
<h2 id="链表实现堆栈的优点">链表实现堆栈的优点</h2>
<p>链表实现堆栈相比于数组实现堆栈有以下几个优点：</p>
<ol>
<li>动态大小：链表实现的堆栈可以根据需要动态调整大小，而数组实现的堆栈需要预先指定大小。这意味着链表实现的堆栈可以根据实际需求进行扩展或缩小，而不会浪费内存或导致栈溢出。</li>
<li>内存管理：链表实现的堆栈只使用必要的内存空间，而数组实现的堆栈在创建时需要一定大小的连续内存空间。这意味着链表实现的堆栈可以更好地处理内存管理，避免浪费内存或导致内存溢出。</li>
</ol>
<p>总的来说，链表实现的堆栈更加灵活和动态，适用于需要频繁插入和删除操作的场景，而数组实现的堆栈更适用于事先知道栈大小且不需要频繁调整大小的场景。</p>
<h2 id="链表实现堆栈">链表实现堆栈</h2>
<h3 id="定义并初始化堆栈结构">定义并初始化堆栈结构</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;  <span class="comment">// 堆栈的数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span>  <span class="comment">// 下一个弹出的数据的存储地址</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;  <span class="comment">// 数据量大小</span></span><br><span class="line">    <span class="type">int</span> max;   <span class="comment">// 最大容量</span></span><br><span class="line">    Node *top;  <span class="comment">// 堆栈的头指针</span></span><br><span class="line">&#125; Stack;</span><br></pre></td></tr></table></figure>
<p>在这里，我们使用一个结构体实现具有先进先出的堆栈结构，其中的两个成员标记这堆栈中的数据量和最大存储数据量大小，另一个成员标记着栈顶地址。</p>
<ul>
<li>这里的栈顶地址，即为链表的头结点地址，所有这个成员的数据类型为链表结构：
<ul>
<li>链表结构中需要包含存放的数据和指向下一个数据的地址。</li>
</ul>
</li>
</ul>
<p>其中，成员 <code>size</code> 和成员 <code>max</code> 主要用于执行堆栈是否为空和堆栈是否已满操作，<code>top</code>指针主要用于执行堆栈的入栈、出栈和栈顶查询等操作。</p>
<h3 id="初始化堆栈">初始化堆栈</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EXCEPTION_VALUE (-1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> max_size = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">Stack *<span class="title function_">initStack</span><span class="params">(<span class="type">int</span> max_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    Stack *<span class="built_in">stack</span> = (Stack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    <span class="built_in">stack</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;max = max_size;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断堆栈是否为空">判断堆栈是否为空</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断堆栈是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断堆栈是否已满">判断堆栈是否已满</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断堆栈是否已满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;size &gt;= <span class="built_in">stack</span>-&gt;max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="入栈操作">入栈操作</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元素入栈</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">push</span><span class="params">(Stack *<span class="built_in">stack</span>, <span class="type">int</span> element)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is full\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node *node = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        node-&gt;data = element;</span><br><span class="line">        node-&gt;next = <span class="built_in">stack</span>-&gt;top;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;size++;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;top = node;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="出栈操作">出栈操作</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元素出栈</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> topVal = <span class="built_in">stack</span>-&gt;top-&gt;data;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;top = <span class="built_in">stack</span>-&gt;top-&gt;next;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;size--;</span><br><span class="line">        <span class="keyword">return</span> topVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了区分栈空时的返回值与正常出栈的数据，需要定义异常值为不会出现在正常数据中的值；或者修改函数的返回值为指针类型，返回值不为空时对应着有效数据。</p>
<h3 id="获取栈顶元素">获取栈顶元素</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取栈顶元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="打印堆栈数据">打印堆栈数据</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印堆栈中的元素, 从栈顶打印到栈底</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printStack</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack: &quot;</span>);</span><br><span class="line">        Node *head = <span class="built_in">stack</span>-&gt;top;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, head-&gt;data);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链表实现堆栈完整代码">链表实现堆栈完整代码</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCEPTION_VALUE (-1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    Node *top;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line">Stack *<span class="title function_">initStack</span><span class="params">(<span class="type">int</span> max_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    Stack *<span class="built_in">stack</span> = (Stack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    <span class="built_in">stack</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;max = max_size;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;size &gt;= <span class="built_in">stack</span>-&gt;max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">push</span><span class="params">(Stack *<span class="built_in">stack</span>, <span class="type">int</span> element)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is full\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node *node = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        node-&gt;data = element;</span><br><span class="line">        node-&gt;next = <span class="built_in">stack</span>-&gt;top;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;size++;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;top = node;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> topVal = <span class="built_in">stack</span>-&gt;top-&gt;data;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;top = <span class="built_in">stack</span>-&gt;top-&gt;next;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;size--;</span><br><span class="line">        <span class="keyword">return</span> topVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printStack</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack: &quot;</span>);</span><br><span class="line">        Node *head = <span class="built_in">stack</span>-&gt;top;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, head-&gt;data);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> *argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    Stack *stack1 = <span class="literal">NULL</span>;</span><br><span class="line">    stack1 = initStack(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    printStack(stack1);</span><br><span class="line">    push(stack1, <span class="number">1</span>);</span><br><span class="line">    push(stack1, <span class="number">2</span>);</span><br><span class="line">    push(stack1, <span class="number">3</span>);</span><br><span class="line">    printStack(stack1);</span><br><span class="line">    push(stack1, <span class="number">4</span>);</span><br><span class="line">    printStack(stack1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Pop element: %d\n&quot;</span>, pop(stack1));</span><br><span class="line">    printStack(stack1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Top element: %d\n&quot;</span>, peek(stack1));</span><br><span class="line">    printStack(stack1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stack is empty</span><br><span class="line">Stack: 3 2 1</span><br><span class="line">Stack is full</span><br><span class="line">Stack: 3 2 1</span><br><span class="line">Pop element: 3</span><br><span class="line">Stack: 2 1</span><br><span class="line">Top element: 2</span><br><span class="line">Stack: 2 1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>堆栈</category>
      </categories>
      <tags>
        <tag>堆栈</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之并查集（数组实现）</title>
    <url>/posts/231023164532.html</url>
    <content><![CDATA[<p>并查集（Union-Find Disjoint Sets, UFDS）是一种用于处理一些不相交集合的数据结构，实现为一个森林，其中的每棵树表示一个集合，树中的节点表示对应集合中的元素。</p>
<p>顾名思义，并查集支持两种操作：</p>
<ul>
<li>合并（Union）：合并两个元素所属集合（合并对应的树），通常是将两个集合的根节点连接在一起。</li>
<li>查找（Find）：查找某个元素所属集合，通常是找到该元素所在集合的根节点，这可以用于判断两个元素是否属于同一集合。</li>
</ul>
<span id="more"></span>
<p>下图是一个具有四个不相交集合的树构成的森林。</p>
<p><img src="../images/data-structure/UFDS-demo3.png" alt=""></p>
<h2 id="并查集应用场景">并查集应用场景</h2>
<p>并查集数据结构最常见的应用是跟踪无向图的连接组件。它还用于实现 Kruskal 算法的高效版本，以查找图的最小生成树。</p>
<p>关于并查集的应用，后面的学习中再做整理~</p>
<h2 id="并查集实现">并查集实现</h2>
<p>上面介绍了什么是并查集，并给出了并查集支持的一些操作。下面开始，逐步实现基于数组的并查集。</p>
<h3 id="初始化">初始化</h3>
<p><strong>并查集的实现可以使用数组来表示每个元素所属的集合</strong>，其中：</p>
<ul>
<li>数组的索引表示元素的值；</li>
<li>数组的值表示该元素所属的集合的代表元素。</li>
</ul>
<blockquote>
<p>一般用树的根节点作为该集合的代表元素。</p>
</blockquote>
<p>初始时，每个元素都是独立的集合，它属于它自己（表示为一棵只有根节点的树），即每个元素的值和索引相同（将根节点的父亲设为自己）。</p>
<p>初始化时，就像这样，自己指向自己，树的高度为 0。</p>
<p><img src="../images/data-structure/UFDS-init.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化并查集</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> rank[], <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">        rank[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里 <code>rank[i]</code> 的值是以顶点 <code>i</code> 为根的子树高度的上限，它用作后面 <code>UnionSet(i, j)</code> 操作的引导启发式。先不用管 <code>rank[i]</code> 了，后面还会遇到。</p>
</blockquote>
<h3 id="查找">查找</h3>
<p>就像文章一开头说的那样，并查集的查找操作，是查找某个元素所属集合，通常是找到该元素所在集合的根节点。具体地，</p>
<ul>
<li>查找当前元素的父元素，若父元素不是自己，则更新它为当前元素，并查找它的父元素，直到当前元素的父元素是自己为止。</li>
</ul>
<h4 id="并查集查找（迭代实现）">并查集查找（迭代实现）</h4>
<p>朴素的并查集查找操作（迭代实现）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找元素所属的集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (parent[x] != x) &#123;</span><br><span class="line">        x = parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="并查集查找（递归实现）">并查集查找（递归实现）</h4>
<p>朴素的并查集查找操作（递归实现）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找元素所属的集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[x] == x) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findSet(parent, parent[x]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="并查集查找（带路径压缩）">并查集查找（带路径压缩）</h4>
<p>想一想，一个集合中的所有元素，虽然有共同的代表元素，但是这棵树可能呈现不同的形状。</p>
<p><img src="../images/data-structure/UFDS-same-set.png" alt=""></p>
<p>上面这张图中，左边与右边集合中的元素一致，且代表元素都是 1，<strong>但是树的形状不同</strong>。这样的话，对于同一个元素（比如 4），查找到其代表元素 1 的迭代（递归）次数是不一样的，左边需要 3 次才能完成，而右边只需要 1 次就能完成。</p>
<p>因此，<strong>为了提高效率，就需要尽可能降低迭代（递归）次数。这就需要进行「路径压缩」</strong>。</p>
<p>想一想，上面递归方式实现的查找操作 <code>findSet(int parent[], int x)</code> 中，是查找元素 <code>x</code> 的代表元素并返回。在这个函数内部，如果当前元素的父元素不是代表元素，函数会递归的查找其父元素的代表元素（我们被划分在同一个集合中了，假如我的代表元素是 R，那么我的父元素的代表元素也是 R 呀）。</p>
<p>因此，我们可以 <strong> 在递归的过程中，更新当前元素的代表元素，从而实现「路径压缩」</strong>，以加快后续查找。</p>
<p>并查集查找操作（带路径压缩的递归实现）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找元素所属的集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[x] == x) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 路径压缩，findSet() 返回的就是参数 2 的最终代表元素，</span></span><br><span class="line">        <span class="comment">// 所以，在递归过程中传入的不同参数 2 的最终代表元素都是 findSet() 的返回值</span></span><br><span class="line">        parent[x] = findSet(parent, parent[x]);</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并查集查找操作（带路径压缩的迭代实现）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找元素所属的集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> rootOfx = x;  <span class="comment">// 初始时，暂定 x 的代表元素是自己</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找 x 的代表元素，存储在 rootOfx 中</span></span><br><span class="line">    <span class="keyword">while</span> (parent[rootOfx] != rootOfx) &#123;</span><br><span class="line">        rootOfx = parent[rootOfx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在 rootOfx 已经是 x 真正的代表元素了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代地进行路径压缩</span></span><br><span class="line">    <span class="keyword">while</span> (parent[x] != x) &#123;</span><br><span class="line">        x = parent[x];</span><br><span class="line">        <span class="comment">// 逐级更新路径上的节点，它们有共同的最终代表元素 rootOfx</span></span><br><span class="line">        parent[x] = rootOfx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rootOfx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="路径压缩查找示例">路径压缩查找示例</h4>
<p>假如，我们有如下的不相交集合：</p>
<p><img src="../images/data-structure/UFDS-demo1.png" alt=""></p>
<p>现在，我们使用带路径压缩的并查集查找函数，查找元素 1 的代表元素，这一过程可以可视化为下面的动画。</p>
<p><img src="../images/data-structure/UFDS-demo2.gif" alt=""></p>
<blockquote>
<p>图中 <code>r</code> 就是 <code>rank</code> 的缩写，<code>s</code> 代表的是元素的数量。</p>
</blockquote>
<h3 id="合并">合并</h3>
<p>要合并两棵树（集合），我们只需要将一棵树的根节点连到另一棵树的根节点。要完成这一操作，我们需要：</p>
<ol>
<li>查找一个元素 <code>x</code> 的代表元素；</li>
<li>查找另一个元素 <code>y</code> 的代表元素；</li>
<li>若两者的代表元素不同，则将其中一棵树的根节点连接到另一棵树的根节点上；若两者的代表元素相同，则无需合并。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 合并两个集合</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unionSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> rootX = findSet(parent, x);</span><br><span class="line">    <span class="type">int</span> rootY = findSet(parent, y);</span><br><span class="line">    <span class="comment">// 属于不同集合</span></span><br><span class="line">    <span class="keyword">if</span> (rootX != rootY) &#123;</span><br><span class="line">        <span class="comment">// 将前者所在的树的根节点连接到后者所在的树的根节点上</span></span><br><span class="line">        parent[rootX] = rootY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="启发式合并">启发式合并</h3>
<p>合并时，选择哪棵树的根节点作为新树的根节点会影响未来操作的复杂度。我们可以 <strong> 将节点较少或深度（树高）较小的树连接到另一棵</strong>，以免发生退化。</p>
<blockquote>
<p>这样做的目的是尽量避免将较大的树作为子树合并到较小的树上，从而保持树的平衡，减小树的高度。</p>
<p>在并查集中，「退化」指的是树结构变得非常不平衡，即树的高度非常大，接近于线性结构（如链表）。</p>
</blockquote>
<p>因此，在初始化小节中，数组 <code>rank[i]</code> 就是用来维护以顶点 <code>i</code> 为根的子树高度的上限，它就是在这里被使用的啦。</p>
<h4 id="启发式合并（以树高为标准）">启发式合并（以树高为标准）</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">unionSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> rank[], <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> rootX = findSet(parent, x);</span><br><span class="line">    <span class="type">int</span> rootY = findSet(parent, y);</span><br><span class="line">    <span class="comment">// 属于不同集合</span></span><br><span class="line">    <span class="keyword">if</span> (rootX != rootY) &#123;</span><br><span class="line">        <span class="comment">// 将深度较小的树连到另一棵树</span></span><br><span class="line">        <span class="keyword">if</span> (rank[rootX] &lt; rank[rootY]) &#123;</span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootX] &gt; rank[rootY]) &#123;</span><br><span class="line">            parent[rootY] = rootX;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将前者所在的树的根节点连接到后者所在的树的根节点上</span></span><br><span class="line">            <span class="comment">// 被连接的树的高度将会加一, 对应的 rank 值加一</span></span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">            rank[rootY]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化时，每个元素都是一个独立的集合，每个树的高度都为 0：</p>
<ul>
<li>在进行第一次集合合并时（比如元素 1 和元素 3），则 <code>unionSet(parent, rank, 1, 3)</code> 操作，会合并为一棵 <code>3-&gt;1</code> 的树，其中 3 为根节点，这棵新树会长高一个单位；</li>
<li>在进行第二次集合合并时（比如元素 1 和元素 4），则 <code>unionSet(parent, rank, 1, 4)</code> 操作，会合并为一棵 <code>4&lt;-3-&gt;1</code> 的树，其中 3 为根节点，由于 1 所在的树高大于 4 所在的树高，因此在合并后，树高不会变得更高，因此不会更新 <code>rank</code> 值。</li>
</ul>
<blockquote>
<p><strong>注意：在启发式合并的过程中，只能保证根节点对应 <code>rank</code> 值是正确的，不能保证其它位置的 <code>rank</code> 值的正确性</strong>。</p>
</blockquote>
<h4 id="启发式合并示例">启发式合并示例</h4>
<p>假如，我们有如下几个不相交集合：</p>
<p><img src="../images/data-structure/UFDS-demo3.png" alt=""></p>
<p>现在，我们使用以树高为标准的启发式合并，执行 <code>unionSet(parent, rank, 10, 8)</code>，这一过程可以可视化为下面的动画。</p>
<p><img src="../images/data-structure/UFDS-demo4.gif" alt=""></p>
<p>这里 <code>x = 10, y = 8</code> 与 <code>x = 8, y = 10</code> 执行后，得到的树是不一样的哦。</p>
<blockquote>
<p>你可能已经发现了：在执行合并的过程中，树也会被路径压缩，这是因为并查集的合并接口调用了查找接口。</p>
</blockquote>
<h3 id="相同集合">相同集合</h3>
<p>判断两个元素是否属于同一集合。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isSameSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> findSet(parent, x) == findSet(parent, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并查集复杂度">并查集复杂度</h2>
<p>时间复杂度：</p>
<ul>
<li>初始化：<code>O(n)</code></li>
<li>朴素查找：<code>O(n)</code></li>
<li>带路径压缩的查找：<code>O(h)</code>，可以优化至 <code>O(α(n))</code>，其中 <code>h</code> 是树的高度，足够平衡时 <code>h = log(n)</code>，<code>α</code> 是阿克曼函数</li>
<li>带路径压缩的合并：<code>O(h)</code>，可以优化至 <code>O(α(n))</code></li>
</ul>
<p>空间复杂度：<code>O(n)</code></p>
<blockquote>
<p>这里的并查集数据结构的实现，是采用的 Quick Union 方式，而不是 Quick Find 方式。</p>
</blockquote>
<h2 id="并查集完整代码测试">并查集完整代码测试</h2>
<h3 id="完整代码">完整代码</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> rank[], <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">        rank[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[x] == x) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 路径压缩</span></span><br><span class="line">        parent[x] = findSet(parent, parent[x]);</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unionSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> rank[], <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> rootX = findSet(parent, x);</span><br><span class="line">    <span class="type">int</span> rootY = findSet(parent, y);</span><br><span class="line">    <span class="comment">// 属于不同集合</span></span><br><span class="line">    <span class="keyword">if</span> (rootX != rootY) &#123;</span><br><span class="line">        <span class="comment">// 将深度较小的树连到另一棵树</span></span><br><span class="line">        <span class="keyword">if</span> (rank[rootX] &lt; rank[rootY]) &#123;</span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootX] &gt; rank[rootY]) &#123;</span><br><span class="line">            parent[rootY] = rootX;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将前者所在的树的根节点连接到后者所在的树的根节点上</span></span><br><span class="line">            <span class="comment">// 被连接的树的高度将会加一, 对应的 rank 值加一</span></span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">            rank[rootY]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isSameSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> findSet(parent, x) == findSet(parent, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试代码">测试代码</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE (101)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> rank[], <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">findSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unionSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> rank[], <span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">isSameSet</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> parent[MAX_SIZE];</span><br><span class="line">    <span class="type">int</span> rank[MAX_SIZE];</span><br><span class="line">    <span class="type">int</span> size = <span class="number">10</span>; <span class="comment">// 假设有 10 个元素，从 0 到 9 编号</span></span><br><span class="line"></span><br><span class="line">    init(parent, rank, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 findSet 函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(0): %d\n&quot;</span>, findSet(parent, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(1): %d\n&quot;</span>, findSet(parent, <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(2): %d\n&quot;</span>, findSet(parent, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 unionSet 函数</span></span><br><span class="line">    unionSet(parent, rank, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    unionSet(parent, rank, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    unionSet(parent, rank, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    unionSet(parent, rank, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">    unionSet(parent, rank, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(0): %d\n&quot;</span>, findSet(parent, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(1): %d\n&quot;</span>, findSet(parent, <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(2): %d\n&quot;</span>, findSet(parent, <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(3): %d\n&quot;</span>, findSet(parent, <span class="number">3</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(4): %d\n&quot;</span>, findSet(parent, <span class="number">4</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(5): %d\n&quot;</span>, findSet(parent, <span class="number">5</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(6): %d\n&quot;</span>, findSet(parent, <span class="number">6</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(7): %d\n&quot;</span>, findSet(parent, <span class="number">7</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(8): %d\n&quot;</span>, findSet(parent, <span class="number">8</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(9): %d\n&quot;</span>, findSet(parent, <span class="number">9</span>));</span><br><span class="line"></span><br><span class="line">    unionSet(parent, rank, <span class="number">6</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(6): %d\n&quot;</span>, findSet(parent, <span class="number">6</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;findSet(8): %d\n&quot;</span>, findSet(parent, <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 isSameSet 函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;isSameSet(0, 1): %d\n&quot;</span>, isSameSet(parent, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;isSameSet(2, 3): %d\n&quot;</span>, isSameSet(parent, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;isSameSet(1, 3): %d\n&quot;</span>, isSameSet(parent, <span class="number">1</span>, <span class="number">3</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;isSameSet(6, 9): %d\n&quot;</span>, isSameSet(parent, <span class="number">6</span>, <span class="number">9</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试结果">测试结果</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">findSet(0): 0</span><br><span class="line">findSet(1): 1</span><br><span class="line">findSet(2): 2</span><br><span class="line">findSet(0): 1</span><br><span class="line">findSet(1): 1</span><br><span class="line">findSet(2): 3</span><br><span class="line">findSet(3): 3</span><br><span class="line">findSet(4): 5</span><br><span class="line">findSet(5): 5</span><br><span class="line">findSet(6): 7</span><br><span class="line">findSet(7): 7</span><br><span class="line">findSet(8): 9</span><br><span class="line">findSet(9): 9</span><br><span class="line">findSet(6): 9</span><br><span class="line">findSet(8): 9</span><br><span class="line">isSameSet(0, 1): 1</span><br><span class="line">isSameSet(2, 3): 1</span><br><span class="line">isSameSet(1, 3): 0</span><br><span class="line">isSameSet(6, 9): 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://visualgo.net/en/ufds">https://visualgo.net/en/ufds</a></li>
<li><a href="https://oi-wiki.org/ds/dsu">https://oi-wiki.org/ds/dsu</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>Disjoint-Set</tag>
        <tag>Union-Find</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之拓扑排序</title>
    <url>/posts/230916094606.html</url>
    <content><![CDATA[<h2 id="什么是拓扑排序">什么是拓扑排序</h2>
<p>引用百度百科的拓扑排序定义：</p>
<blockquote>
<p>对一个有向无环图（Directed Acyclic Graph, DAG）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> 进行拓扑排序，是将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> 中所有顶点排成一个 <strong> 线性序列 </strong>，使得图中任意一对顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>，若边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>&gt;</mo><mo>∈</mo><mi>E</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">&lt;u,v&gt; \in E(G)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span></span></span></span> <strong> 在线性序列中出现在 </strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 之前。通常，这样的线性序列称为满足拓扑次序（Topological Order）的序列，简称<strong> 拓扑序列</strong>。</p>
</blockquote>
<p>拓扑排序可以被理解为对一个有向无环图进行排序的操作。在这个排序中，图中的顶点被排列成一个线性序列，<strong>满足以下条件：对于图中的任意一对顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>，如果存在一条边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;u,v&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span>，那么在线性序列中，顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span></span></span></span> 出现在顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 之前</strong>。</p>
<p>换句话说，拓扑排序可以将有向无环图中的顶点按照它们的依赖关系排序，使得所有的依赖关系都被满足。这对于处理任务的依赖关系非常有用，例如工程项目中的任务调度，编译器中的源代码依赖等。</p>
<span id="more"></span>
<p>例如，下图中 <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code> 是一个正确的拓扑排序，每个节点都在它所依赖的节点后面。而 <code>1-&gt;2-&gt;4-&gt;3-&gt;5</code> 则不满足拓扑排序的要求，<code>4</code> 依赖于 <code>3</code>，却出现在了 <code>3</code> 前面。</p>
<p><img src="../images/data-structure/topo-sort.png" alt=""></p>
<h2 id="拓扑排序基本原理">拓扑排序基本原理</h2>
<p>拓扑排序（Topological Sorting）是一种用于有向无环图（DAG）的排序算法，它将图中的节点按照依赖关系进行排序，使得所有的依赖关系都被满足。</p>
<p>拓扑排序的一些重要知识点：</p>
<ol>
<li>
<p>有向无环图（DAG）：拓扑排序只能应用于没有环的有向图，因为有环的图存在循环依赖，无法进行拓扑排序。</p>
</li>
<li>
<p>入度和出度：在拓扑排序中，入度表示指向某个节点的边的数量，出度表示从某个节点发出的边的数量。</p>
</li>
<li>
<p>拓扑排序算法：拓扑排序算法可以通过深度优先搜索或广度优先搜索（Kahn 算法）来实现。<strong>DFS 通常使用递归或栈来实现，而 BFS 则使用队列来实现</strong>。</p>
</li>
<li>
<p>多个拓扑排序结果：一个有向图可能存在多种不同的拓扑排序结果，这取决于节点的访问顺序。一种常见的方法是使用优先队列或字典序来选择节点的顺序，以得到特定的排序结果。</p>
</li>
</ol>
<h3 id="要解决的问题">要解决的问题</h3>
<p>对于有向图进行拓扑排序要解决两个问题：</p>
<ul>
<li>一是要判断待排序的有向图是不是无环；</li>
<li>二是按照依赖关系生成正确的序列。</li>
</ul>
<h3 id="基本思想">基本思想</h3>
<p>拓扑排序的基本思想是：</p>
<ul>
<li>
<p>入度思想：首先找到图中没有前驱节点的节点（即入度为 0 的节点），将其 <strong> 顺序 </strong> 加入结果列表中，并将其从图中删除。然后，继续寻找新的没有前驱节点的节点，并重复以上过程，直到所有的节点都被加入结果列表中或者无法再找到没有前驱节点的节点为止。</p>
</li>
<li>
<p>出度思想：首先找到图中没有后驱节点的节点（即出度为 0 的节点），将其 <strong> 逆序 </strong> 加入结果列表中，并将其从图中删除。然后，继续寻找新的没有后驱节点的节点，并重复以上过程，直到所有的节点都被加入结果列表中或者无法再找到没有后驱节点的节点为止。</p>
</li>
</ul>
<h3 id="BFS-Kaha 拓扑排序算法">BFS/Kaha 拓扑排序算法</h3>
<p>拓扑排序的具体步骤：</p>
<ol>
<li>初始化一个结果列表（或者称为拓扑序列）和一个队列。</li>
<li>遍历图中的所有节点（对），统计每个节点的入度（即有多少条边指向该节点）。</li>
<li>将入度为 0 的节点加入队列中。</li>
<li>当队列不为空时，执行以下操作：
<ul>
<li>取出队首节点，并将其加入结果列表中。</li>
<li>遍历该节点的所有邻接节点（即该节点指向的节点）：
<ul>
<li>将邻接节点的入度减 1。</li>
<li>如果邻接节点的入度减为 0，将其加入队列中。</li>
</ul>
</li>
</ul>
</li>
<li>如果结果列表的长度等于图中的节点数，则说明拓扑排序成功，返回结果列表，表示拓扑序列。</li>
<li>如果结果列表的长度小于图中的节点数，则说明图中存在环，无法进行拓扑排序。</li>
</ol>
<p>通过循环找到入度为 0 的节点，并将其加入结果列表，然后更新与该节点相邻的节点的入度，重复此过程，最终得到一个满足拓扑次序的序列，或者判断出图中存在环。</p>
<blockquote>
<p>BFS / Kaha 拓扑排序算法是从入度的角度着手的，这种方法可称之为 <strong> 入度方法</strong>。</p>
</blockquote>
<h3 id="BFS 拓扑排序实现">BFS 拓扑排序实现</h3>
<p>以 <a href="https://leetcode.cn/problems/course-schedule-ii/">Leetcode 课程表 II</a> 为例，给出 BFS 拓扑排序算法的实现过程。</p>
<p>题目大意：一共有 n 门课程，课程之间存在依赖关系，比如先修完 A 课程，才能修 B 课程。问这个学生能不能修完所有课程，能的话则返回一种可能的课程学习顺序。</p>
<p>代码实现中的关键变量：</p>
<ul>
<li><code>indegree[]</code>：初始化每个节点的入度，并随着节点出队更新入度值；</li>
<li><code>edges[][]</code>：记录每个节点影响的其它节点，用于该节点的入度变为 0 时更新“影响的其它节点”的入度值；</li>
<li><code>queue</code>：队列用于入队、出队所有入度为 0 的节点；</li>
<li><code>ans[]</code>：结果队列用于保存出队的节点；</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ELEM_TYPE int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Define the structure for a node in the queue</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ELEM_TYPE data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define the structure for the queue</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    Node* front;</span><br><span class="line">    Node* rear;</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to create a new node</span></span><br><span class="line">Node* <span class="title function_">createNode</span><span class="params">(ELEM_TYPE data)</span> &#123;</span><br><span class="line">    Node* newNode = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to create an empty queue</span></span><br><span class="line">Queue* <span class="title function_">createQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    Queue* <span class="built_in">queue</span> = (Queue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to check if the queue is empty</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Queue* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to enqueue an element into the queue</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enQueue</span><span class="params">(Queue* <span class="built_in">queue</span>, ELEM_TYPE data)</span> &#123;</span><br><span class="line">    Node* newNode = createNode(data);</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear-&gt;next = newNode;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to dequeue an element from the queue</span></span><br><span class="line">ELEM_TYPE <span class="title function_">deQueue</span><span class="params">(Queue* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* temp = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">    ELEM_TYPE data = temp-&gt;data;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;front-&gt;next;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">findOrder</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>** prerequisites, <span class="type">int</span> prerequisitesSize, <span class="type">int</span>* prerequisitesColSize, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> indegree[numCourses];  <span class="comment">// 每个节点的入度，入度为 0 表示不受其它节点影响 </span></span><br><span class="line">    <span class="type">int</span> **edges = (<span class="type">int</span> **)<span class="built_in">malloc</span>(numCourses * <span class="keyword">sizeof</span>(<span class="type">int</span> *));  <span class="comment">// 二维数组, 记录每个节点影响的节点们</span></span><br><span class="line">    <span class="type">int</span> edgeNums[numCourses];  <span class="comment">// 记录每个节点影响的节点数量, 用于动态扩展空间</span></span><br><span class="line">    <span class="type">int</span> *ans = (<span class="type">int</span> *)<span class="built_in">malloc</span>(numCourses * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">        indegree[i] = <span class="number">0</span>;</span><br><span class="line">        edgeNums[i] = <span class="number">0</span>;</span><br><span class="line">        edges[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">0</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 后续按需扩展</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历所有节点对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prerequisitesSize; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> suff = prerequisites[i][<span class="number">0</span>], pre = prerequisites[i][<span class="number">1</span>];</span><br><span class="line">        edgeNums[pre]++;  <span class="comment">// suff 受到了 pre 影响, 故 pre 节点影响的节点数量 +1</span></span><br><span class="line">        indegree[suff]++;  <span class="comment">// suff 受到了 pre 影响，其入度要 +1</span></span><br><span class="line">        edges[pre] = (<span class="type">int</span> *)<span class="built_in">realloc</span>(edges[pre], edgeNums[pre] * <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 扩展内存</span></span><br><span class="line">        edges[pre][edgeNums[pre] - <span class="number">1</span>] = suff;  <span class="comment">// 在索引(pre, 最后位置) 记录 suff</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue* <span class="built_in">queue</span> = createQueue();</span><br><span class="line">    <span class="comment">// 入度所有不受影响的节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            enQueue(<span class="built_in">queue</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        ELEM_TYPE cur = deQueue(<span class="built_in">queue</span>);</span><br><span class="line">        ans[count++] = cur;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历出队的节点影响的所有节点, 它们的受影响度将 -1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edgeNums[cur]; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> x = edges[cur][i];</span><br><span class="line">            indegree[x]--;</span><br><span class="line">            <span class="keyword">if</span> (indegree[x] == <span class="number">0</span>) &#123;</span><br><span class="line">                enQueue(<span class="built_in">queue</span>, x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">        <span class="built_in">free</span>(edges[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(edges);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断结果队列长度，确定是否可以完成拓扑排序</span></span><br><span class="line">    <span class="keyword">if</span> (count == numCourses) &#123;</span><br><span class="line">        (*returnSize) = count;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (*returnSize) = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DFS 拓扑排序算法">DFS 拓扑排序算法</h3>
<p>DFS 拓扑排序算法的思想和 BFS 拓扑排序算法相似，但在具体步骤上有所不同。</p>
<p>DFS 拓扑排序算法的基本思想是：通过递归遍历图中的节点，<strong>从一个起始节点开始</strong>，当遍历到一个节点时，先将其所有未访问的邻居节点进行递归遍历，之后将当前节点添加到结果列表中。如果在递归的过程中，发现当遍历到一个节点时，存在已经被访问过的邻居节点，则说明途中存在环，无法进行拓扑排序。</p>
<p>DFS 拓扑排序的具体步骤如下：</p>
<ol>
<li>初始化一个空的结果列表和一个空的访问状态列表。</li>
<li>对于图中的每个节点，如果该节点未被访问，则调用 DFS 函数进行遍历。</li>
<li>在 DFS 函数中，首先将当前节点标记为正在访问。</li>
<li>递归遍历当前节点的所有未访问的邻居节点，将每个邻居节点作为新的起始节点进行递归遍历。</li>
<li>当没有未访问的邻居节点时，将当前节点的访问状态更新为已访问，并逆序添加到结果列表中。</li>
<li>最终，结果列表中的节点正序顺序即为 DFS 拓扑排序的结果。</li>
</ol>
<blockquote>
<p>需要注意的是：在进行 DFS 拓扑排序的过程中，如果发现某个节点的邻居节点已经被访问过（即已经在结果列表中），那么说明存在环，无法进行拓扑排序。在这种情况下，可以中断排序过程并返回一个表示存在环的标志。</p>
</blockquote>
<p>代码实现中的关键变量：</p>
<ul>
<li><code>visited[]</code>：记录每个节点的访问状态，0 表示未访问，1 表示正在访问，2 表示访问完成；</li>
<li><code>edges[][]</code>：记录每个节点所有邻居节点；</li>
<li><code>ans[]</code>：结果队列；</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span>* visited, <span class="type">int</span>** edges, <span class="type">int</span>* edgeNums, <span class="type">int</span>* ans, <span class="type">int</span>* cnt, <span class="type">bool</span>* valid)</span> &#123;</span><br><span class="line">    visited[node] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edgeNums[node]; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> neigNode = edges[node][i];</span><br><span class="line">        <span class="keyword">if</span> (visited[neigNode] == <span class="number">0</span>) &#123;</span><br><span class="line">            dfs(neigNode, visited, edges, edgeNums, ans, cnt, valid);</span><br><span class="line">            <span class="comment">// 这行代码测试发现不是必须的, 为什么不是必须的？加上可以有剪枝（提前终止）的作用</span></span><br><span class="line">            <span class="keyword">if</span> (!(*valid)) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (visited[neigNode] == <span class="number">1</span>) &#123;</span><br><span class="line">            *valid = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    visited[node] = <span class="number">2</span>;</span><br><span class="line">    ans[--(*cnt)] = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">findOrder</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>** prerequisites, <span class="type">int</span> prerequisitesSize, <span class="type">int</span>* prerequisitesColSize, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span>* visited = (<span class="type">int</span> *)<span class="built_in">malloc</span>(numCourses * <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 记录每一个节点的访问状态</span></span><br><span class="line">    <span class="type">int</span>** edges = (<span class="type">int</span> **)<span class="built_in">malloc</span>(numCourses * <span class="keyword">sizeof</span>(<span class="type">int</span> *));  <span class="comment">// 二维数组, 记录每个节点所有邻居节点</span></span><br><span class="line">    <span class="type">int</span>* edgeNums = (<span class="type">int</span> *)<span class="built_in">malloc</span>(numCourses * <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 记录每个节点的邻居节点数量</span></span><br><span class="line">    <span class="type">int</span>* ans = (<span class="type">int</span> *)<span class="built_in">malloc</span>(numCourses * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span> cnt = numCourses;</span><br><span class="line">    <span class="type">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, numCourses * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">memset</span>(edgeNums, <span class="number">0</span>, numCourses * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">        edges[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">0</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建邻接表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prerequisitesSize; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> suff = prerequisites[i][<span class="number">0</span>], pre = prerequisites[i][<span class="number">1</span>];  <span class="comment">// edge: pre-&gt;suff</span></span><br><span class="line">        edges[pre] = (<span class="type">int</span> *)<span class="built_in">realloc</span>(edges[pre], (edgeNums[pre] + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        edges[pre][edgeNums[pre]] = suff;</span><br><span class="line">        edgeNums[pre]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// DFS 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            dfs(i, visited, edges, edgeNums, ans, &amp;cnt, &amp;valid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">        <span class="built_in">free</span>(edges[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(edges);</span><br><span class="line">    <span class="built_in">free</span>(visited);</span><br><span class="line">    <span class="built_in">free</span>(edgeNums);</span><br><span class="line">    </span><br><span class="line">    *returnSize = (cnt &gt; <span class="number">0</span> || !valid) ? <span class="number">0</span> : numCourses;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考链接：<a href="https://jingsam.github.io/2020/08/11/topological-sort.html">https://jingsam.github.io/2020/08/11/topological-sort.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之链表（数组实现）</title>
    <url>/posts/231007174854.html</url>
    <content><![CDATA[<p>线性表是一组 <strong> 按线性顺序排列的、具有相同特征的数据元素的有限序列</strong>，其中的数据元素之间存在一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的（这句话只适用大部分线性表，而不是全部，如循环链表把最后一个数据元素的尾指针指向了首位结点）。线性表可以用于表示一串有序的数据，例如数组、链表、栈和队列等都是线性表的实现方式。</p>
<p>线性表中的「单链表」的实现，包括单链表的顺序存储（数组实现）和单链表的链式存储。这篇文章主要介绍单链表的顺序存储（数组实现）。</p>
<span id="more"></span>
<h2 id="数组和链表的特点">数组和链表的特点</h2>
<p>首先介绍一下数组和链表的特点。</p>
<p>数组：创建数组时会在内存空间中划分出一块连续的内存，然后数据进入时会将数据按顺序存储在这块连续的内存中。因为数组在存储数据时是按顺序存储的，存储数据的内存也是连续的。所以，<strong>数组的特点就是寻址读取数据容易，插入和删除比较困难 / 费时</strong>。</p>
<p>链表：链表不同于数组，不会先划分出一块连续的内存，链表中的数据并不是连续的，链表在存储数据的内存中有两块区域，一块区域用来存储数据，一块区域用来记录下一个数据保存在哪里。虽然链表是线性表，但是并不会按线性的顺序存储数据。所以，<strong>链表在插入和删除时比较容易，在读取数据时比较麻烦</strong>。</p>
<blockquote>
<p>这里的容易，即意味着时间复杂度低；麻烦，即意味着时间复杂度高。</p>
</blockquote>
<h2 id="链表的顺序存储（数组实现）">链表的顺序存储（数组实现）</h2>
<p>链表的 API 主要包括：</p>
<ul>
<li>创建并初始化链表</li>
<li>查找链表中的元素</li>
<li>向链表中插入元素</li>
<li>删除链表中的元素</li>
<li>获取链表的长度</li>
</ul>
<h3 id="链表结构定义">链表结构定义</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE (100)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data[MAX_SIZE];  <span class="comment">// 存储元素的数组</span></span><br><span class="line">    <span class="type">int</span> length;  <span class="comment">// 链表的长度</span></span><br><span class="line">&#125; ArrayList;</span><br></pre></td></tr></table></figure>
<p>这段代码定义了一个名为 <code>ArrayList</code> 的结构体，用来表示一个数组实现的链表。</p>
<p>该结构体包含两个成员变量：</p>
<ol>
<li><code>int data[MAX_SIZE]</code>：一个整型数组，用来存储链表中的元素。</li>
<li><code>int length</code>：一个整型变量，表示链表的长度。</li>
</ol>
<p>通过使用这个结构体，我们可以创建一个顺序存储结构的链表，其中元素按照顺序存储在数组中，并且可以通过索引来访问和修改链表中的元素。</p>
<h3 id="创建并初始化链表">创建并初始化链表</h3>
<p>使用动态申请内存空间的方式创建并初始化一个链表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ArrayList *<span class="title function_">initArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    ArrayList *<span class="built_in">list</span> = (ArrayList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArrayList));</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">list</span>-&gt;data, <span class="number">0</span>, MAX_SIZE * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">list</span>-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// printf(&quot;ArrayList size is %d bytes, data size is %d bytes.\n&quot;, sizeof(list), sizeof(list-&gt;data));</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找链表中的元素">查找链表中的元素</h3>
<p>在链表中查找目标元素第一次出现时的索引，不存在则返回 -1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findArrayList</span><span class="params">(ArrayList *<span class="built_in">list</span>, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">/* 查找成功的平均比较次数为(n+1)/2 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>-&gt;length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;data[i] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;  <span class="comment">// 返回元素在链表中的索引</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 没有找到元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么查找成功的平均比较次数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac {n+1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 呢？</p>
</blockquote>
<p>假设链表的长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>，若元素在链表中存在，在最坏情况下，需要比较 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 次才能找到元素；在最好情况下，只需要比较 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 次就能找到元素。因此，平均比较次数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac {n+1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。</p>
<h3 id="向链表中插入元素">向链表中插入元素</h3>
<p>向链表中指定的索引位置插入一个元素，可以在有效数据的最前面和最后面插入元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">insertArrayList</span><span class="params">(ArrayList *<span class="built_in">list</span>, <span class="type">int</span> index, <span class="type">int</span> element)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;length == MAX_SIZE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;List is full! Unable to insert element.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="built_in">list</span>-&gt;length) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid index! Unable to insert element.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">list</span>-&gt;length - <span class="number">1</span>; i &gt;= index; i--) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;data[i + <span class="number">1</span>] = <span class="built_in">list</span>-&gt;data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;data[index] = element;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length++;  <span class="comment">// 更新链表的长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除链表中的元素">删除链表中的元素</h3>
<p>删除链表中指定索引位置的元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deleteArrayList</span><span class="params">(ArrayList *<span class="built_in">list</span>, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;List is empty! Unable to delete element.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">list</span>-&gt;length) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid index! Unable to delete element.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; <span class="built_in">list</span>-&gt;length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;data[i] = <span class="built_in">list</span>-&gt;data[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length--;  <span class="comment">// 更新链表的长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取链表的长度">获取链表的长度</h3>
<p>获取链表中有效数据元素的长度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getArrayListLength</span><span class="params">(ArrayList *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>-&gt;length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="释放链表空间">释放链表空间</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freeArrayList</span><span class="params">(ArrayList *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链表的数组实现完整代码">链表的数组实现完整代码</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE (100)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data[MAX_SIZE];  <span class="comment">// 存储元素的数组</span></span><br><span class="line">    <span class="type">int</span> length;  <span class="comment">// 链表的长度</span></span><br><span class="line">&#125; ArrayList;</span><br><span class="line"></span><br><span class="line">ArrayList *<span class="title function_">initArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    ArrayList *<span class="built_in">list</span> = (ArrayList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArrayList));</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">list</span>-&gt;data, <span class="number">0</span>, MAX_SIZE * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">list</span>-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ArrayList size is %d bytes, data size is %d bytes.\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="built_in">list</span>), <span class="keyword">sizeof</span>(<span class="built_in">list</span>-&gt;data));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findArrayList</span><span class="params">(ArrayList *<span class="built_in">list</span>, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>-&gt;length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;data[i] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;  <span class="comment">// 返回元素在链表中的索引</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 没有找到元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertArrayList</span><span class="params">(ArrayList *<span class="built_in">list</span>, <span class="type">int</span> index, <span class="type">int</span> element)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;length == MAX_SIZE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;List is full! Unable to insert element.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="built_in">list</span>-&gt;length) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid index! Unable to insert element.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">list</span>-&gt;length - <span class="number">1</span>; i &gt;= index; i--) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;data[i + <span class="number">1</span>] = <span class="built_in">list</span>-&gt;data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;data[index] = element;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length++;  <span class="comment">// 更新链表的长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteArrayList</span><span class="params">(ArrayList *<span class="built_in">list</span>, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;List is empty! Unable to delete element.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">list</span>-&gt;length) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid index! Unable to delete element.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; <span class="built_in">list</span>-&gt;length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;data[i] = <span class="built_in">list</span>-&gt;data[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length--;  <span class="comment">// 更新链表的长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getArrayListLength</span><span class="params">(ArrayList *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>-&gt;length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printArrayList</span><span class="params">(ArrayList *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>-&gt;length; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">list</span>-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeArrayList</span><span class="params">(ArrayList *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    ArrayList *<span class="built_in">list</span> = initArrayList();</span><br><span class="line"></span><br><span class="line">    insertArrayList(<span class="built_in">list</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    insertArrayList(<span class="built_in">list</span>, <span class="number">1</span>, <span class="number">20</span>);</span><br><span class="line">    insertArrayList(<span class="built_in">list</span>, <span class="number">2</span>, <span class="number">30</span>);</span><br><span class="line">    printArrayList(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    insertArrayList(<span class="built_in">list</span>, <span class="number">2</span>, <span class="number">40</span>);</span><br><span class="line">    insertArrayList(<span class="built_in">list</span>, <span class="number">0</span>, <span class="number">15</span>);</span><br><span class="line">    printArrayList(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Length of list: %d\n&quot;</span>, getArrayListLength(<span class="built_in">list</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> index = findArrayList(<span class="built_in">list</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">if</span> (index != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Element 20 is found at index %d\n&quot;</span>, index);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Element 20 is not found\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deleteArrayList(<span class="built_in">list</span>, <span class="number">1</span>);</span><br><span class="line">    printArrayList(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Length of list: %d\n&quot;</span>, getArrayListLength(<span class="built_in">list</span>));</span><br><span class="line"></span><br><span class="line">    freeArrayList(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的输出结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ArrayList size is 8 bytes, data size is 400 bytes.</span><br><span class="line">10 20 30</span><br><span class="line">15 10 20 40 30</span><br><span class="line">Length of list: 5</span><br><span class="line">Element 20 is found at index 2</span><br><span class="line">15 20 40 30</span><br><span class="line">Length of list: 4</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之链表（链式实现）</title>
    <url>/posts/231008213450.html</url>
    <content><![CDATA[<p>线性表中的「单链表」的实现，包括单链表的顺序存储（数组实现）和单链表的链式存储。<a href="https://pursue26.github.io/posts/231007174854.html">上篇文章 </a> 介绍了单链表的顺序存储（数组实现），这篇文章主要介绍单链表的链式存储（结构体指针实现）。</p>
<span id="more"></span>
<h2 id="链表的链式存储（结构体指针实现）">链表的链式存储（结构体指针实现）</h2>
<p>链表的 API 主要包括：</p>
<ul>
<li>创建并初始化链表</li>
<li>查找链表中的元素</li>
<li>向链表中插入元素</li>
<li>删除链表中的元素</li>
<li>获取链表的长度</li>
</ul>
<h3 id="链表结构定义">链表结构定义</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义链表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; Linked_t;</span><br></pre></td></tr></table></figure>
<p>这段代码定义了一个名为 <code>Linked_t</code> 的结构体，用来表示一个结构体实现的链表。</p>
<p>该结构体包含两个成员变量：</p>
<ol>
<li><code>int data</code>：一个整形变量，用来存储链表中的元素。</li>
<li><code>struct Node* next</code>：一个链表结构体指针，用于指向链表中当前结点的下一个结点的指针（地址）。</li>
</ol>
<p>链表中的不同元素，通过节点之间的指针首尾连接起来。</p>
<h3 id="创建并初始化链表">创建并初始化链表</h3>
<p>使用动态申请内存空间的方式创建并初始化一个链表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Linked_t *<span class="title function_">createNode</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Linked_t *linked = (Linked_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linked_t));</span><br><span class="line">    linked-&gt;data = data;</span><br><span class="line">    linked-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// printf(&quot;Linked_t size is %d bytes.\n&quot;, sizeof(linked));</span></span><br><span class="line">    <span class="keyword">return</span> linked;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找链表中的元素">查找链表中的元素</h3>
<p>在链表中查找目标元素第一次出现时的结点，不存在则返回空。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Linked_t *<span class="title function_">findNode</span><span class="params">(Linked_t *linked, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    Linked_t *curNode = linked;</span><br><span class="line">    <span class="keyword">while</span> (curNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curNode-&gt;data == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> curNode;</span><br><span class="line">        &#125;</span><br><span class="line">        curNode = curNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 没有找到元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="向链表末尾插入元素">向链表末尾插入元素</h3>
<p>在链表末尾插入新结点，插入成功时返回链表头结点，失败时返回空地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Linked_t *<span class="title function_">insertTailNode</span><span class="params">(Linked_t *linked, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (linked == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;linked is NULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Linked_t *curNode = linked;</span><br><span class="line">    <span class="keyword">while</span> (curNode-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        curNode = curNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Linked_t *newNode = createNode(data);</span><br><span class="line">    curNode-&gt;next = newNode;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> linked;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="向链表指定结点前插入元素">向链表指定结点前插入元素</h3>
<p>在链表的指定结点前插入新结点，如果指定的结点为空，则在末尾插入结点，最后返回插入新结点后链表的头结点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Linked_t *<span class="title function_">insertNode</span><span class="params">(Linked_t *linked, Linked_t *node, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (linked == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;linked is NULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node == linked) &#123;  <span class="comment">// 在链表头结点前插入新结点</span></span><br><span class="line">        Linked_t *newNode = createNode(data);</span><br><span class="line">        newNode-&gt;next = linked;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> insertTailNode(linked, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Linked_t *preNode = linked;</span><br><span class="line">    Linked_t *curNode = preNode-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (curNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curNode == node) &#123;  <span class="comment">// 在链表结点中间插入新结点</span></span><br><span class="line">            Linked_t *newNode = createNode(data);</span><br><span class="line">            preNode-&gt;next = newNode;</span><br><span class="line">            newNode-&gt;next = curNode;</span><br><span class="line">            <span class="keyword">return</span> linked;</span><br><span class="line">        &#125;</span><br><span class="line">        preNode = curNode;</span><br><span class="line">        curNode = curNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The specified node does not exist in the linked list.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> linked;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除链表中的元素">删除链表中的元素</h3>
<p>删除链表中指定索引位置的元素，并返回新的链表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Linked_t *<span class="title function_">deleteNode</span><span class="params">(Linked_t *linked, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (linked == <span class="literal">NULL</span> || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> linked;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">        Linked_t *newHead = linked-&gt;next;</span><br><span class="line">        linked-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(linked);</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        Linked_t *preNode = linked, *curNode = preNode-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (curNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span> (cnt == index) &#123;</span><br><span class="line">                Linked_t *curNext = curNode-&gt;next;</span><br><span class="line">                curNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="built_in">free</span>(curNode);</span><br><span class="line">                preNode-&gt;next = curNext;</span><br><span class="line">                <span class="keyword">return</span> linked;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                preNnode = curNode;</span><br><span class="line">                curNode = curNode-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The specified index is illegal.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> linked;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取链表的长度">获取链表的长度</h3>
<p>获取链表中有效数据元素的长度（结点的数量）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getLinkedLength</span><span class="params">(Linked_t *linked)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (linked != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        linked = linked-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="释放链表空间">释放链表空间</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freeLinked</span><span class="params">(Linked_t *linked)</span> &#123;</span><br><span class="line">    Linked_t *curNode = linked;</span><br><span class="line">    Linked_t *tmpNode = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (curNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        tmpNode = curNode-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(curNode);</span><br><span class="line">        curNode = tmpNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链表的数组实现完整代码">链表的数组实现完整代码</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE (100)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; Linked_t;</span><br><span class="line"></span><br><span class="line">Linked_t *<span class="title function_">createNode</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Linked_t *linked = (Linked_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linked_t));</span><br><span class="line">    linked-&gt;data = data;</span><br><span class="line">    linked-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// printf(&quot;Linked_t size is %d bytes.\n&quot;, sizeof(linked));</span></span><br><span class="line">    <span class="keyword">return</span> linked;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Linked_t *<span class="title function_">findNode</span><span class="params">(Linked_t *linked, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    Linked_t *curNode = linked;</span><br><span class="line">    <span class="keyword">while</span> (curNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curNode-&gt;data == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> curNode;</span><br><span class="line">        &#125;</span><br><span class="line">        curNode = curNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 没有找到元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Linked_t *<span class="title function_">insertTailNode</span><span class="params">(Linked_t *linked, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (linked == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;linked is NULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Linked_t *curNode = linked;</span><br><span class="line">    <span class="keyword">while</span> (curNode-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        curNode = curNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Linked_t *newNode = createNode(data);</span><br><span class="line">    curNode-&gt;next = newNode;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> linked;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Linked_t *<span class="title function_">insertNode</span><span class="params">(Linked_t *linked, Linked_t *node, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (linked == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;linked is NULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node == linked) &#123;  <span class="comment">// 在链表头结点前插入新结点</span></span><br><span class="line">        Linked_t *newNode = createNode(data);</span><br><span class="line">        newNode-&gt;next = linked;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> insertTailNode(linked, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Linked_t *preNode = linked;</span><br><span class="line">    Linked_t *curNode = preNode-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (curNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curNode == node) &#123;  <span class="comment">// 在链表结点中间插入新结点</span></span><br><span class="line">            Linked_t *newNode = createNode(data);</span><br><span class="line">            preNode-&gt;next = newNode;</span><br><span class="line">            newNode-&gt;next = curNode;</span><br><span class="line">            <span class="keyword">return</span> linked;</span><br><span class="line">        &#125;</span><br><span class="line">        preNode = curNode;</span><br><span class="line">        curNode = curNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The specified node does not exist in the linked list.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> linked;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Linked_t *<span class="title function_">deleteNode</span><span class="params">(Linked_t *linked, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (linked == <span class="literal">NULL</span> || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> linked;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">        Linked_t *newHead = linked-&gt;next;</span><br><span class="line">        linked-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(linked);</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        Linked_t *preNode = linked, *curNode = preNode-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (curNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span> (cnt == index) &#123;</span><br><span class="line">                Linked_t *curNext = curNode-&gt;next;</span><br><span class="line">                curNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="built_in">free</span>(curNode);</span><br><span class="line">                preNode-&gt;next = curNext;</span><br><span class="line">                <span class="keyword">return</span> linked;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                preNnode = curNode;</span><br><span class="line">                curNode = curNode-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The specified index is illegal.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> linked;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getLinkedLength</span><span class="params">(Linked_t *linked)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (linked != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        linked = linked-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeLinked</span><span class="params">(Linked_t *linked)</span> &#123;</span><br><span class="line">    Linked_t *curNode = linked;</span><br><span class="line">    Linked_t *tmpNode = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (curNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        tmpNode = curNode-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(curNode);</span><br><span class="line">        curNode = tmpNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printLinked</span><span class="params">(Linked_t *linked)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Linked List: &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (linked) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, linked-&gt;data);</span><br><span class="line">        linked = linked-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Linked_t *linked = createNode(<span class="number">10</span>);</span><br><span class="line">    printLinked(linked);</span><br><span class="line"></span><br><span class="line">    linked = insertTailNode(linked, <span class="number">20</span>);</span><br><span class="line">    printLinked(linked);</span><br><span class="line"></span><br><span class="line">    linked = insertTailNode(linked, <span class="number">30</span>);</span><br><span class="line">    printLinked(linked);</span><br><span class="line"></span><br><span class="line">    linked = insertNode(linked, linked, <span class="number">5</span>);</span><br><span class="line">    printLinked(linked);</span><br><span class="line"></span><br><span class="line">    linked = insertNode(linked, linked-&gt;next, <span class="number">15</span>);</span><br><span class="line">    printLinked(linked);</span><br><span class="line"></span><br><span class="line">    linked = insertNode(linked, <span class="literal">NULL</span>, <span class="number">40</span>);</span><br><span class="line">    printLinked(linked);</span><br><span class="line"></span><br><span class="line">    linked = deleteNode(linked, <span class="number">0</span>);</span><br><span class="line">    printLinked(linked);</span><br><span class="line"></span><br><span class="line">    linked = deleteNode(linked, <span class="number">2</span>);</span><br><span class="line">    printLinked(linked);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> length = getLinkedLength(linked);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Linked List Length: %d\n&quot;</span>, length);</span><br><span class="line"></span><br><span class="line">    freeLinked(linked);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的输出结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Linked List: 10</span><br><span class="line">Linked List: 10 20</span><br><span class="line">Linked List: 10 20 30</span><br><span class="line">Linked List: 5 10 20 30</span><br><span class="line">Linked List: 5 15 10 20 30</span><br><span class="line">Linked List: 5 15 10 20 30 40</span><br><span class="line">Linked List: 15 10 20 30 40</span><br><span class="line">Linked List: 15 10 30 40</span><br><span class="line">Linked List Length: 4</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之队列（链表实现）</title>
    <url>/posts/231017105123.html</url>
    <content><![CDATA[<p> 队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，在表的后端（rear）进行插入操作。与堆栈一样，队列也是一种操作受限制的线性表，进行插入操作的端称为队尾，进行删除操作的端称为队头。数据的入队和出队遵循先进先出（FIFO, First-In First-Out）的原则。</p>
<span id="more"></span>
<p> 这篇文章主要介绍通过链表实现队列，但会首先介绍一下队列的几种实现方式和各自的特点、适用场景。</p>
<h2 id="队列的实现方式"> 队列的实现方式 </h2>
<p> 在 C 语言中，FIFO 队列的实现方式有以下几种：</p>
<ol>
<li>
<p> 数组实现：使用一个固定大小的数组作为队列的存储空间，使用两个指针 front 和 rear 分别指向队列的头部和尾部，通过不断移动指针和调整数组元素的位置来实现入队和出队操作。</p>
</li>
<li>
<p> 链表实现：使用链表作为队列的存储结构，通过定义一个链表节点结构体来存储队列元素的值和指向下一个节点的指针。通过调整链表节点的指针关系来实现入队和出队操作。</p>
</li>
<li>
<p> 循环队列实现：使用一个固定大小的数组作为队列的存储空间，同时使用两个指针 front 和 rear 分别指向队列的头部和尾部。当 rear 指针到达数组末尾时，再次从数组头部开始存储元素，实现循环利用数组空间的效果。</p>
</li>
</ol>
<h2 id="不同实现方式适用的场景"> 不同实现方式适用的场景 </h2>
<p> 数组实现队列、链表实现队列和循环队列实现，都有各自的特点和适用场景，以下是不同实现方式的一些适用场景：</p>
<ol>
<li>
<p> 数组实现适用于以下场景：</p>
<ul>
<li> 队列大小固定，不需要频繁进行大小调整。</li>
<li> 元素个数相对较少，不会造成数组空间的浪费。</li>
<li> 需要快速随机访问队列元素。</li>
</ul>
</li>
<li>
<p> 链表实现适用于以下场景：</p>
<ul>
<li> 队列大小不确定，会频繁进行大小调整。</li>
<li> 元素个数可能非常大，链表能够动态分配内存。</li>
<li> 需要频繁进行插入和删除操作。</li>
</ul>
</li>
<li>
<p> 循环队列实现适用于以下场景：</p>
<ul>
<li> 队列大小固定，不需要频繁进行大小调整。</li>
<li> 队列元素个数可能会超过数组大小，但是可以接受覆盖旧元素的方式。</li>
<li> 需要快速入队和出队操作。</li>
</ul>
</li>
</ol>
<p> 根据实际需求和对性能的要求，可以选择适合的实现方式。例如，如果队列大小固定且元素个数不会超过数组大小，可以选择数组实现；如果队列大小不确定且需要频繁进行插入和删除操作，可以选择链表实现；如果队列大小固定但元素个数可能超过数组大小且需要快速入队和出队操作，可以选择循环队列实现。</p>
<h2 id="链表实现队列"> 链表实现队列 </h2>
<h3 id="定义基于链表的队列结构"> 定义基于链表的队列结构 </h3>
<p><strong> 为了体现队列中数据的复杂性 </strong>，这里不再使用基本数据类型（如整形、字符型）作为队列中的数据，而是使用了二叉树结构，即在队列中保存的数据是一个二叉树节点，节点中包含节点值、节点的左子树指针和节点的右子树指针。</p>
<img src="../images/data-structure/fifo-queue-struct.png" alt="FIFO 队列数据结构" width="80%" height="80%">
<p> 首先，定义二叉树的结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagTreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagTreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagTreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode_t;</span><br></pre></td></tr></table></figure>
<p> 然后，定义链表的结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Define the structure for a node in the queue</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagLinkedNode</span> &#123;</span></span><br><span class="line">    TreeNode_t *data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagLinkedNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LinkedNode_t;</span><br></pre></td></tr></table></figure>
<p> 在这里，链表中的成员就是：用于存储二叉树节点数据的结构体和指向下一个链表节点的指针。</p>
<p> 最后，定义队列的结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Define the structure for the queue</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagQueue</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    LinkedNode_t *front;</span><br><span class="line">    LinkedNode_t *rear;</span><br><span class="line">&#125; Queue_t;</span><br></pre></td></tr></table></figure>
<p> 在这里，队列中的成员就是：队头指针和队尾指针，以及一个记录队列中数据数量的成员变量和一个标记队列可以容纳的最大数据量的成员变量。</p>
<h3 id="队列的创建与初始化"> 队列的创建与初始化 </h3>
<p> 首先，创建一个空队列（队列中还没有存储数据），并初始化成员变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function to create an empty queue</span></span><br><span class="line">Queue_t *<span class="title function_">createQueue</span><span class="params">(<span class="type">int</span> max_size)</span> &#123;</span><br><span class="line">    Queue_t *<span class="built_in">queue</span> = (Queue_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue_t));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;max = max_size;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 然后，对于空队列，后续入队操作会有数据存储到队列中，数据需要必要的存储空间来存储。在这里，我们创建并初始化一段空间用于存储数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function to create a new node</span></span><br><span class="line">LinkedNode_t *<span class="title function_">createNode</span><span class="params">(TreeNode_t *data)</span> &#123;</span><br><span class="line">    LinkedNode_t *newNode = (LinkedNode_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkedNode_t));</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断队列是否为空"> 判断队列是否为空 </h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function to check if the queue is empty</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Queue_t *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 当然，也可以使用 <code>(!queue-&gt;front) &amp;&amp; (queue-&gt;front == queue-&gt;rear)</code> 判断队列是否为空。</p>
<h3 id="判断队列是否已满"> 判断队列是否已满 </h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function to check if the queue is full</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Queue_t *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;size &gt;= <span class="built_in">queue</span>-&gt;max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="入队操作"> 入队操作 </h3>
<p> 入队操作，即在队列的尾部插入一个数据。</p>
<ul>
<li> 如果队列已满，则无法继续执行入队操作；</li>
<li> 如果队列为空，则队列的头指针（front）和尾指针（rear）都指向新插入的数据的存放地址；</li>
<li> 否则，链接并更新队列的尾指针（rear）为新插入的数据的存放地址。</li>
</ul>
<p> 入队操作后需要更新队列的大小。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function to enqueue an element into the queue</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enQueue</span><span class="params">(Queue_t *<span class="built_in">queue</span>, TreeNode_t *data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;queue is full.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LinkedNode_t *newNode = createNode(data);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">            <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">queue</span>-&gt;rear-&gt;next = newNode;  <span class="comment">// 尾指针链接新数据 </span></span><br><span class="line">            <span class="built_in">queue</span>-&gt;rear = newNode;  <span class="comment">// 尾指针指向新数据 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;size += <span class="number">1</span>;  <span class="comment">// 更新队列大小 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="出队操作"> 出队操作 </h3>
<p> 出队操作，即在队列的头部删除一个数据。出队操作需要依次执行以下操作：</p>
<ol>
<li> 获取头指针地址 &amp; 数据；</li>
<li> 更新队列头指针；</li>
<li> 更新队列大小；</li>
<li> 释放原头指针内存空间；</li>
<li> 返回数据。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function to dequeue an element from the queue</span></span><br><span class="line">TreeNode_t *<span class="title function_">deQueue</span><span class="params">(Queue_t* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedNode_t *node = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">    TreeNode_t *data = node-&gt;data;</span><br><span class="line">    <span class="comment">// 根据当前队列中节点的数量，决定是否同步更新队列的尾指针 </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;front-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips：出队操作在在更新队列头指针时，需要根据当前队列中节点的数量，决定是否同步更新队列的尾指针。</p>
</blockquote>
<blockquote>
<p> 释放 <code>node</code> 内存空间后，不会造成 <code>data</code> 数据无法访问吗？<br>
不会。这是因为，在释放节点之前，我们先将数据指针 <code>node-&gt;data</code> 保存到一个新的变量 <code>data</code> 中，然后释放节点，最后返回保存的数据指针。这样可以确保返回的数据指针依然有效。</p>
</blockquote>
<h3 id="打印队列数据"> 打印队列数据 </h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function to print all elements from the queue</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(Queue_t* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Queue is empty\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Queue: &quot;</span>);</span><br><span class="line">        LinkedNode_t *node = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;data-&gt;val);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="释放队列"> 释放队列 </h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function to free all memory from the queue</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeQueue</span><span class="params">(Queue_t* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>) &#123;</span><br><span class="line">        LinkedNode_t *node = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">        <span class="keyword">while</span> (node) &#123;</span><br><span class="line">            LinkedNode_t *temp = node;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 释放队列内存空间时，需要依次释放队列中的每一个节点的空间，最后再释放队列结构本身的数据空间。</p>
<h2 id="链表实现队列完整代码"> 链表实现队列完整代码 </h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagTreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagTreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagTreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagLinkedNode</span> &#123;</span></span><br><span class="line">    TreeNode_t *data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagLinkedNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LinkedNode_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagQueue</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    LinkedNode_t *front;</span><br><span class="line">    LinkedNode_t *rear;</span><br><span class="line">&#125; Queue_t;</span><br><span class="line"></span><br><span class="line">Queue_t *<span class="title function_">createQueue</span><span class="params">(<span class="type">int</span> max_size)</span> &#123;</span><br><span class="line">    Queue_t *<span class="built_in">queue</span> = (Queue_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue_t));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;max = max_size;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LinkedNode_t *<span class="title function_">createNode</span><span class="params">(TreeNode_t *data)</span> &#123;</span><br><span class="line">    LinkedNode_t *newNode = (LinkedNode_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkedNode_t));</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Queue_t *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Queue_t *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;size &gt;= <span class="built_in">queue</span>-&gt;max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enQueue</span><span class="params">(Queue_t *<span class="built_in">queue</span>, TreeNode_t *data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;queue is full.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LinkedNode_t *newNode = createNode(data);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">            <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">queue</span>-&gt;rear-&gt;next = newNode;  <span class="comment">// 尾指针链接新数据 </span></span><br><span class="line">            <span class="built_in">queue</span>-&gt;rear = newNode;  <span class="comment">// 尾指针指向新数据 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;size += <span class="number">1</span>;  <span class="comment">// 更新队列大小 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode_t *<span class="title function_">deQueue</span><span class="params">(Queue_t* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedNode_t *node = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">    TreeNode_t *data = node-&gt;data;</span><br><span class="line">    <span class="comment">// 根据当前队列中节点的数量，决定是否同步更新队列的尾指针 </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;front-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(Queue_t* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Queue is empty\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Queue: &quot;</span>);</span><br><span class="line">        LinkedNode_t *node = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;data-&gt;val);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeQueue</span><span class="params">(Queue_t* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>) &#123;</span><br><span class="line">        LinkedNode_t *node = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">        <span class="keyword">while</span> (node) &#123;</span><br><span class="line">            LinkedNode_t *temp = node;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    Queue_t *<span class="built_in">queue</span> = createQueue(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一些测试用的树节点 </span></span><br><span class="line">    TreeNode_t *node = (TreeNode_t *)<span class="built_in">malloc</span>(<span class="number">4</span> * <span class="keyword">sizeof</span>(TreeNode_t));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        node[i].val = <span class="number">10</span> + i;</span><br><span class="line">        node[i].left = <span class="literal">NULL</span>;</span><br><span class="line">        node[i].right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printQueue(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    enQueue(<span class="built_in">queue</span>, &amp;node[<span class="number">0</span>]);</span><br><span class="line">    enQueue(<span class="built_in">queue</span>, &amp;node[<span class="number">1</span>]);</span><br><span class="line">    enQueue(<span class="built_in">queue</span>, &amp;node[<span class="number">2</span>]);</span><br><span class="line">    printQueue(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    enQueue(<span class="built_in">queue</span>, &amp;node[<span class="number">3</span>]);</span><br><span class="line">    printQueue(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    TreeNode_t *data1 = deQueue(<span class="built_in">queue</span>);</span><br><span class="line">    TreeNode_t *data2 = deQueue(<span class="built_in">queue</span>);</span><br><span class="line">    TreeNode_t *data3 = deQueue(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Dequeued data: %d %d %d\n&quot;</span>, data1-&gt;val, data2-&gt;val, data3-&gt;val); <span class="comment">// 实际工程中要先判非空再取数据 </span></span><br><span class="line">    printQueue(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    freeQueue(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 程序的输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Queue is empty</span><br><span class="line">Queue: 10 11 12</span><br><span class="line">queue is full.</span><br><span class="line">Queue: 10 11 12</span><br><span class="line">Dequeued data: 10 11 12</span><br><span class="line">Queue is empty</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>队列</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法之 Dijkstra 单源最短路径（原理部分）</title>
    <url>/posts/231117095232.html</url>
    <content><![CDATA[<p>戴克斯特拉算法（Dijkstra’s algorithm），又称迪杰斯特拉算法、Dijkstra 算法，是由荷兰计算机科学家艾兹赫尔·戴克斯特拉在 1956 年发现的算法。戴克斯特拉算法使用类似广度优先搜索的方法解决赋权图的 <strong> 单源 </strong> 最短路径问题。它可以应用于有向图和无向图，常被应用于网络路由、交通规划等领域。但对于带有负权边的图，Dijkstra 算法无法正确计算最短路径，需要使用其他算法，如 Bellman-Ford 算法。</p>
<span id="more"></span>
<h2 id="Dijkstra 基本思想">Dijkstra 基本思想</h2>
<p>Dijkstra 算法可以计算从图中的一个节点出发到其他所有节点的最短路径。它的基本思想是从源节点开始，通过选择当前距离源节点最近的未访问节点，不断更新和调整节点的最短路径和距离值，直到找到所有节点的最短路径为止。</p>
<blockquote>
<p>Dijkstra 算法属于贪心策略（算法执行完后，才能得到全局最优解）。</p>
</blockquote>
<h2 id="Dijkstra 具体步骤">Dijkstra 具体步骤</h2>
<h3 id="Dijkstra 步骤描述">Dijkstra 步骤描述</h3>
<p>Dijkstra 算法的具体步骤如下：</p>
<ol>
<li>创建一个距离数组<code>dist[]</code>，用于存储源节点到各个节点的最短路径长度。初始时，将源节点的距离设为 0，与源节点直接相连的节点的距离设为边的权重，其他节点的距离设为无穷大。</li>
<li>创建一个标记数组<code>visited[]</code>，用于标记是否已经访问过该节点。初始时，将源节点标记为已访问，其他节点标记为未访问。</li>
<li>以源节点为基准，遍历所有与其相邻的、未访问过的节点，计算「源节点」到这些相邻节点的距离，并从未访问的节点中选择距离「源节点」最近的节点，作为基准节点。</li>
<li>以这个基准节点为中间节点，更新从源节点经过中间节点到达其它节点的距离到 <code>dist[]</code> 数组中，并将这个基准节点标记为已访问。
<ul>
<li>更新的方式是：如果「从新的中间节点」到「该节点」的距离小于原本到它的距离，则更新它的值（你要从这个节点走才更近哦），并将这个中间节点作为它的前驱节点。</li>
</ul>
</li>
<li>重复步骤 3 和步骤 4，直到所有节点都被访问过。</li>
<li>最终，<code>dist[]</code>数组中存储的就是源节点到其他所有节点的最短路径长度。</li>
</ol>
<blockquote>
<p>步骤三中的「相邻」节点包括直接与源节点相邻、通过已访问的节点间接与源节点相邻这两大类。换句话说，也就是 <code>dist[]</code> 数组中只要不是无穷大，就与源节点直接或间接相邻。</p>
</blockquote>
<h3 id="Dijkstra 复杂度">Dijkstra 复杂度</h3>
<p>Dijkstra 算法的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|V|^{2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|V|^{2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，主要为二维邻接矩阵、一维的距离矩阵、访问矩阵、前驱矩阵，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 是点集。</p>
<h2 id="Dijkstra 算法图解">Dijkstra 算法图解</h2>
<p>假设有下面这个图：<br>
<img src="../images/algorithm/dijkstra-0.png" alt=""></p>
<p>Dijkstra 算法将会寻找出图中节点 <code>0</code> 到所有其他节点的最短路径。</p>
<h3 id="初始化 dist 数组">初始化 dist 数组</h3>
<p>创建一个距离数组<code>dist[]</code>，用于存储源节点到各个节点的最短路径长度。初始时，源节点到自己的距离为 0，与源节点直接相连的节点的距离设为边的权重，到其它节点的距离还没有确定，所以先标记为无穷大。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node:   [0, 1, 2, 3, 4, 5, 6]</span><br><span class="line">dist:   [0, 2, 6, ∞, ∞, ∞, ∞]</span><br></pre></td></tr></table></figure>
<h3 id="初始化 visited 数组">初始化 visited 数组</h3>
<p>创建一个标记数组<code>visited[]</code>，用于标记是否已经访问过该节点。初始时，将源节点标记为已访问，其他节点标记为未访问。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node:   [0, 1, 2, 3, 4, 5, 6]</span><br><span class="line">dist:   [0, 2, 6, ∞, ∞, ∞, ∞]</span><br><span class="line">visted: [1, 0, 0, 0, 0, 0, 0]</span><br></pre></td></tr></table></figure>
<h3 id="初始化 prev 数组">初始化 prev 数组</h3>
<p>创建一个前驱数组<code>prev[]</code>，用于存储到达该节点的最短路径上的倒数第二个节点（通过哪个节点到达的该节点）。初始时，与源节点直接相连的节点的前驱节点就是源节点，其它节点的前驱节点无法确定，先标记为无效节点（源节点到源节点的路径，没有倒数第二个节点，也标记为无效节点）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node:   [0, 1, 2, 3, 4, 5, 6]</span><br><span class="line">dist:   [0, 2, 6, ∞, ∞, ∞, ∞]</span><br><span class="line">visted: [1, 0, 0, 0, 0, 0, 0]</span><br><span class="line">prev:  [-1, 0, 0,-1,-1,-1,-1]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>记住，当所有节点都被标记为已访问（被添加到路径中）时，算法的计算过程就完成了。</p>
</blockquote>
<h3 id="遍历相邻节点">遍历相邻节点</h3>
<p>我们选择了从节点 <code>0</code> 出发，可以直接将它标记为「已访问」，并在图中给它加上红色的边框：</p>
<p><img src="../images/algorithm/dijkstra-1.png" alt=""></p>
<hr>
<p>以源节点 <code>0</code> 为基准，遍历所有与其相邻的、未访问过的节点（节点 <code>1</code> 和 <code>2</code>），计算源节点到这些相邻节点的距离，并更新 <code>dist[]</code> 数组中的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node:   [0, 1, 2, 3, 4, 5, 6]</span><br><span class="line">dist:   [0, 2, 6, ∞, ∞, ∞, ∞]</span><br><span class="line">visted: [1, 0, 0, 0, 0, 0, 0]</span><br><span class="line">prev:  [-1, 0, 0,-1,-1,-1,-1]</span><br></pre></td></tr></table></figure>
<p>从表格中可以看出，当前：</p>
<ul>
<li>从源节点 <code>0</code> 到节点 <code>1</code> 的最短距离为 2（通过源节点 <code>0</code> 到达节点 <code>1</code>）；</li>
<li>从源节点 <code>0</code> 到节点 <code>2</code> 的最短距离为 6（通过源节点 <code>0</code> 到达节点 <code>2</code>）。</li>
</ul>
<p>然后，我们 <strong> 从未访问的节点（节点 <code>1</code> 和节点 <code>2</code>）中选择距离源节点最近的节点（节点 <code>1</code>），作为下一个基准节点，并将其标记为已访问</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node:   [0, 1, 2, 3, 4, 5, 6]</span><br><span class="line">dist:   [0, 2, 6, ∞, ∞, ∞, ∞]</span><br><span class="line">visted: [1, 1, 0, 0, 0, 0, 0]</span><br><span class="line">prev:  [-1, 0, 0,-1,-1,-1,-1]</span><br></pre></td></tr></table></figure>
<p>因此，节点 <code>1</code> 标记为已访问（节点 <code>2</code> 不标记为已访问），并更新节点 <code>1</code> 的上一个节点为节点 <code>0</code>。</p>
<p>图中给已访问的节点 <code>1</code> 加上红色的边框，上一个节点 <code>0</code> 到该节点 <code>1</code> 的路径（边）被染红：</p>
<p><img src="../images/algorithm/dijkstra-2.png" alt=""></p>
<p>然后，节点 <code>1</code> 将作为下一个基准节点，重复上述遍历相邻节点的操作。</p>
<hr>
<p>以节点 <code>1</code> 为基准，遍历所有与其相邻的、未访问过的节点（节点 <code>3</code>），计算源节点到这些相邻节点的距离，并更新 <code>dist[]</code> 数组中的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node:   [0, 1, 2, 3, 4, 5, 6]</span><br><span class="line">dist:   [0, 2, 6, 7, ∞, ∞, ∞]</span><br><span class="line">visted: [1, 1, 0, 0, 0, 0, 0]</span><br><span class="line">prev:  [-1, 0, 0,-1,-1,-1,-1]</span><br></pre></td></tr></table></figure>
<p>从表格中可以看出，当前：</p>
<ul>
<li>从源节点 <code>0</code> 到节点 <code>3</code> 的最短距离为 7（通过中间节点 <code>1</code> 到达节点 <code>3</code>）。</li>
<li>从源节点 <code>0</code> 到节点 <code>2</code> 的最短距离为 6（通过源节点 <code>0</code> 到达节点 <code>2</code>）。</li>
</ul>
<blockquote>
<p>注意，往轮遍历中未被标记为已访问的节点（这里是节点 <code>2</code>）也需要参与距离比较、也可作为下一个基准节点哦！</p>
</blockquote>
<p>然后，我们 <strong> 从未访问的节点（节点 <code>2</code> 和节点 <code>3</code>）中选择距离源节点 <code>0</code> 最近的节点（节点 <code>2</code>），作为下一个基准节点，并将其标记为已访问</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node:   [0, 1, 2, 3, 4, 5, 6]</span><br><span class="line">dist:   [0, 2, 6, 7, ∞, ∞, ∞]</span><br><span class="line">visted: [1, 1, 1, 0, 0, 0, 0]</span><br><span class="line">prev:  [-1, 0, 0,-1,-1,-1,-1]</span><br></pre></td></tr></table></figure>
<p>因此，节点 <code>2</code> 标记为已访问（节点 <code>3</code> 不标记为已访问），并更新节点 <code>2</code> 的上一个节点为节点 <code>0</code>。</p>
<p>图中给已访问的节点 <code>2</code> 加上红色的边框，上一个节点 <code>0</code> 到该节点 <code>2</code> 的路径（边）被染红：</p>
<p><img src="../images/algorithm/dijkstra-3.png" alt=""></p>
<p>然后，节点 <code>2</code> 将作为下一个基准节点，重复上述遍历相邻节点的操作。</p>
<hr>
<p>以节点 <code>2</code> 为基准，遍历所有与其相邻的、未访问过的节点（节点 <code>3</code>），计算源节点到这些相邻节点的距离，并更新 <code>dist[]</code> 数组中的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node:   [0, 1, 2, 3, 4, 5, 6]</span><br><span class="line">dist:   [0, 2, 6, 7, ∞, ∞, ∞]</span><br><span class="line">visted: [1, 1, 1, 0, 0, 0, 0]</span><br><span class="line">prev:  [-1, 0, 0,-1,-1,-1,-1]</span><br></pre></td></tr></table></figure>
<p>从表格中可以看出，当前：</p>
<ul>
<li>从源节点 <code>0</code> 到节点 <code>3</code> 的最短距离为 14（通过中间节点 <code>2</code> 到达节点 <code>3</code>）。</li>
<li>从源节点 <code>0</code> 到节点 <code>3</code> 的最短距离为 7（通过另一个中间节点 <code>1</code> 到达节点 <code>3</code>）。</li>
</ul>
<p>然后，我们 <strong> 从未访问的节点（节点 <code>3</code>）中选择距离源节点 <code>0</code> 最近的节点（节点 <code>3</code>），作为下一个基准节点，并将其标记为已访问</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node:   [0, 1, 2, 3, 4, 5, 6]</span><br><span class="line">dist:   [0, 2, 6, 7, ∞, ∞, ∞]</span><br><span class="line">visted: [1, 1, 1, 1, 0, 0, 0]</span><br><span class="line">prev:  [-1, 0, 0, 1,-1,-1,-1]</span><br></pre></td></tr></table></figure>
<p>因此，节点 <code>3</code> 标记为已访问，并更新节点 <code>3</code> 的 <strong> 上一个节点为节点 <code>1</code></strong>（而不是节点 <code>2</code>）。</p>
<p>图中给已访问的节点 <code>3</code> 加上红色的边框，上一个节点 <code>1</code> 到该节点 <code>3</code> 的路径（边）被染红：</p>
<p><img src="../images/algorithm/dijkstra-4.png" alt=""></p>
<p>然后，节点 <code>3</code> 将作为下一个基准节点，重复上述遍历相邻节点的操作。</p>
<hr>
<p>经过多次选择新的基准节点，并进行遍历相邻节点的操作后，所有节点都被标记为已访问（被添加到路径中），算法的计算过程就完成了。现在，<code>dist[]</code>数组中存储的就是源节点到其他所有节点的最短路径长度。</p>
<p>最终的表格为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node:   [0,  1,  2,  3,  4,  5,  6]</span><br><span class="line">dist:   [0,  2,  6,  7, 17, 22, 19]</span><br><span class="line">visted: [1,  1,  1,  1,  1,  1,  1]</span><br><span class="line">prev:  [-1,  0,  0,  1,  3,  3,  4]</span><br></pre></td></tr></table></figure>
<p>最终表格对应的可视化图：</p>
<p><img src="../images/algorithm/dijkstra-n.png" alt=""></p>
<p>从表格或图中可以看出：</p>
<ul>
<li>源节点 <code>0</code> 到节点 <code>1, 2, 3, 4, 5, 6</code> 的最短距离分别为 <code>2, 6, 7, 17, 22, 19</code>；</li>
<li>源节点 <code>0</code> 到节点 <code>6</code> 的最短路径为 <code>0-&gt;1-&gt;3-&gt;4-&gt;6</code>，这可以通过表格中的 <code>prev[]</code> 数组得出最短路径：节点 <code>6</code> 的上一个节点为 <code>4</code>，节点 <code>4</code> 的上一个节点为 <code>3</code>，节点 <code>3</code> 的上一个节点为 <code>1</code>，节点 <code>1</code> 的上一个节点为 <code>0</code>。</li>
</ul>
<p>最后，再回顾一下本文开头的《具体步骤》吧~</p>
<blockquote>
<p>参考资料 &amp; 图源：</p>
<ol>
<li><a href="https://www.freecodecamp.org/chinese/news/dijkstras-shortest-path-algorithm-visual-introduction/">https://www.freecodecamp.org/chinese/news/dijkstras-shortest-path-algorithm-visual-introduction/</a></li>
<li><a href="https://b23.tv/XWF7K0p">https://b23.tv/XWF7K0p</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>图算法</category>
      </categories>
      <tags>
        <tag>Dijkstra算法</tag>
        <tag>单源最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法之 Dijkstra 单源最短路径（实现部分）</title>
    <url>/posts/231121152713.html</url>
    <content><![CDATA[<p>在文章 <a href="/posts/231117095232.html"> 数据结构算法之 Dijkstra 单源最短路径（原理部分）</a>中，给出了 Dijkstra 算法求单源最短路径的图文步骤，本文将给出该算法的代码实现。</p>
<span id="more"></span>
<h2 id="Dijkstra 算法步骤">Dijkstra 算法步骤</h2>
<p>回顾一下 <a href="/posts/231117095232.html"> 数据结构算法之 Dijkstra 单源最短路径（原理部分）</a>中给出的 Dijkstra 算法的具体步骤：</p>
<ol>
<li>创建一个距离数组<code>dist[]</code>，用于存储源节点到各个节点的最短路径长度。初始时，将源节点的距离设为 0，与源节点直接相连的节点的距离设为边的权重，其他节点的距离设为无穷大。</li>
<li>创建一个标记数组<code>visited[]</code>，用于标记是否已经访问过该节点。初始时，将源节点标记为已访问，其他节点标记为未访问。</li>
<li>以源节点为基准，遍历所有与其相邻的、未访问过的节点，计算「源节点」到这些相邻节点的距离，并从未访问的节点中选择距离「源节点」最近的节点，作为基准节点。</li>
<li>以这个基准节点为中间节点，更新从源节点经过中间节点到达其它节点的距离到 <code>dist[]</code> 数组中，并将这个基准节点标记为已访问。
<ul>
<li>更新的方式是：如果「从新的中间节点」到「该节点」的距离小于原本到它的距离，则更新它的值（你要从这个节点走才更近哦），并将这个中间节点作为它的前驱节点。</li>
</ul>
</li>
<li>重复步骤 3 和步骤 4，直到所有节点都被访问过。</li>
<li>最终，<code>dist[]</code>数组中存储的就是源节点到其他所有节点的最短路径长度。</li>
</ol>
<blockquote>
<p>步骤三中的「相邻」节点包括直接与源节点相邻、通过已访问的节点间接与源节点相邻这两大类。换句话说，也就是 <code>dist[]</code> 数组中只要不是无穷大，就与源节点直接或间接相邻。</p>
</blockquote>
<h2 id="Dijkstra 算法实现">Dijkstra 算法实现</h2>
<h3 id="定义图结构">定义图结构</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">graph</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> vexs[MAX];        <span class="comment">// 顶点集合</span></span><br><span class="line">    <span class="type">int</span> vexnum;            <span class="comment">// 顶点数</span></span><br><span class="line">    <span class="type">int</span> edgenum;           <span class="comment">// 边数</span></span><br><span class="line">    <span class="type">int</span> matrix[MAX][MAX];  <span class="comment">// 邻接矩阵</span></span><br><span class="line">&#125; Graph;</span><br></pre></td></tr></table></figure>
<p><code>Graph</code> 是图的邻接矩阵对应的结构体：</p>
<ul>
<li><code>vexs</code> 用于保存顶点的集合，<code>vexnum</code> 是顶点数量，<code>edgenum</code> 是边数；</li>
<li><code>matrix</code> 用于保存邻接点信息的二维数组，<code>matrix[i][j]</code> 表示顶点 <code>vexs[i]</code> 和顶点 <code>vexs[j]</code> 之间的边的权重，若 <code>matrix[i][j] = INF</code>，则表示这两个顶点之间没有边（不是邻接点）。</li>
</ul>
<h3 id="定义边结构">定义边结构</h3>
<p>实际中，一般给出的信息都是哪两个顶点之间有边，边的权重是多少，所有我们给出一个结构体用于存储边的数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 边的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">edgeData</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> start;  <span class="comment">// 边的起点</span></span><br><span class="line">    <span class="type">char</span> end;    <span class="comment">// 边的终点</span></span><br><span class="line">    <span class="type">int</span> weight;  <span class="comment">// 边的权重</span></span><br><span class="line">&#125; EData;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在编码中，图结构体变量的数据将会从边结构体变量的数据中获取。</p>
</blockquote>
<h3 id="获取顶点的索引">获取顶点的索引</h3>
<p>这里的顶点是字符型（而非整数型），所以需要获取字符型顶点对应的索引——它在顶点集合中的位置。这样，才方便后续将邻接点存储在图结构的成员 <code>matrix</code> 中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取顶点在顶点集合中的索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getIndexOfVex</span><span class="params">(Graph *pGraph, <span class="type">char</span> vex)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pGraph-&gt;vexnum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pGraph-&gt;vexs[i] == vex) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构建图数据">构建图数据</h3>
<p>就像上面说的，图结构体变量的数据将会从边结构体变量的数据中获取。所以，我们在这里实现了从给定的边数据来初始化图数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建图</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">createGraph</span><span class="params">(Graph *pGraph, <span class="type">char</span> vexs[], <span class="type">int</span> vexnum, EData edges[], <span class="type">int</span> edgenum)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化顶点数、边数、顶点集合</span></span><br><span class="line">    pGraph-&gt;vexnum = vexnum;</span><br><span class="line">    pGraph-&gt;edgenum = edgenum;</span><br><span class="line">    <span class="built_in">memcpy</span>(pGraph-&gt;vexs, vexs, vexnum * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pGraph-&gt;vexnum; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; pGraph-&gt;vexnum; j++) &#123;</span><br><span class="line">            pGraph-&gt;matrix[i][j] = (i == j ? <span class="number">0</span> : INF);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加边数据到图中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pGraph-&gt;edgenum; i++) &#123;</span><br><span class="line">        <span class="comment">// 这里要保证顶点的索引有效</span></span><br><span class="line">        <span class="type">int</span> start = getIndexOfVex(pGraph, edges[i].start);</span><br><span class="line">        <span class="type">int</span> end = getIndexOfVex(pGraph, edges[i].end);</span><br><span class="line">        <span class="type">int</span> weight = edges[i].weight;</span><br><span class="line">        pGraph-&gt;matrix[start][end] = weight;</span><br><span class="line">        pGraph-&gt;matrix[end][start] = pGraph-&gt;matrix[start][end];  <span class="comment">// 无向图加这行，有向图不加这行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于无向图，要多加一行代码 <code>pGraph-&gt;matrix[end][start] = pGraph-&gt;matrix[start][end]</code> 哦。</p>
</blockquote>
<h3 id="Dijkstra 算法">Dijkstra 算法</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dijkstra 算法，找到源顶点到各顶点的最短路径</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dijkstra</span><span class="params">(Graph *pGraph, <span class="type">char</span> start, <span class="type">int</span> dist[], <span class="type">int</span> prev[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">int</span> visited[MAX]; <span class="comment">// 标记顶点是否已被访问</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> startIdx = getIndexOfVex(pGraph, start);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤一 &amp; 二：初始化访问数组、距离数组、路径数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pGraph-&gt;vexnum; i++) &#123;</span><br><span class="line">        visited[i] = <span class="number">0</span>; <span class="comment">// 顶点未被访问</span></span><br><span class="line">        dist[i] = pGraph-&gt;matrix[startIdx][i]; <span class="comment">// 初始化源顶点到各顶点的距离</span></span><br><span class="line">        prev[i] = (dist[i] != INF ? startIdx : <span class="number">-1</span>); <span class="comment">// 如果源顶点到该顶点有边，则设置前驱顶点为源顶点</span></span><br><span class="line">    &#125;</span><br><span class="line">    visited[startIdx] = <span class="number">1</span>; <span class="comment">// 源顶点已被访问</span></span><br><span class="line">    prev[startIdx] = <span class="number">-1</span>;  <span class="comment">// 源顶点没有前驱顶点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤五：遍历 N-1 次，每次找到一个顶点的最短路径</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; pGraph-&gt;vexnum; i++) &#123;</span><br><span class="line">        <span class="type">int</span> min = INF;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 步骤三：找到未被访问的顶点中距离最小的顶点 k</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; pGraph-&gt;vexnum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[j] &amp;&amp; dist[j] &lt; min) &#123;</span><br><span class="line">                min = dist[j];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤四：更新 dist 数组和 prev 数组</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; pGraph-&gt;vexnum; j++) &#123;</span><br><span class="line">            <span class="type">int</span> distk2j = min + pGraph-&gt;matrix[k][j]; <span class="comment">// 溢出风险, 所以定义的 INF 为一半的最大值</span></span><br><span class="line">            <span class="comment">// 如果「从新的中间节点」到「该节点」的距离小于原本到它的距离，则更新它的值</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[j] &amp;&amp; distk2j &lt; dist[j]) &#123;</span><br><span class="line">                dist[j] = distk2j;</span><br><span class="line">                prev[j] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[k] = <span class="number">1</span>; <span class="comment">// 将基准节点标记为已访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一次遍历可以访问一个顶点，源节点在初始化时被访问；所以，遍历 N-1 次后，所有顶点就都被访问过了。</p>
</blockquote>
<h3 id="打印最短路径">打印最短路径</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印给定起点和终点的最短路径</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printPath</span><span class="params">(Graph *pGraph, <span class="type">char</span> start, <span class="type">char</span> end, <span class="type">int</span> dist[], <span class="type">int</span> prev[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> startIdx = getIndexOfVex(pGraph, start);</span><br><span class="line">    <span class="type">int</span> endIdx = getIndexOfVex(pGraph, end);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = endIdx, count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> path[MAX];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逆序将路径顶点存入 path 数组</span></span><br><span class="line">    <span class="keyword">while</span> (i != startIdx) &#123;</span><br><span class="line">        path[count++] = pGraph-&gt;vexs[i];</span><br><span class="line">        i = prev[i];  <span class="comment">// 顶点 i 的前驱顶点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印路径顶点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c -&gt; %c: %c&quot;</span>, pGraph-&gt;vexs[startIdx], pGraph-&gt;vexs[endIdx], pGraph-&gt;vexs[startIdx]);</span><br><span class="line">    <span class="keyword">for</span> (i = count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %c&quot;</span>, path[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;, minDist: %d\n&quot;</span>, dist[endIdx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Dijkstra 算法测试">Dijkstra 算法测试</h2>
<h3 id="测试代码">测试代码</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX (100)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF ((~(0x1U <span class="string">&lt;&lt; 31)) &gt;</span>&gt; 1) <span class="comment">// 最大值 0X7FFFFFFF 的一半</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">graph</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> vexs[MAX];        <span class="comment">// 顶点集合</span></span><br><span class="line">    <span class="type">int</span> vexnum;            <span class="comment">// 顶点数</span></span><br><span class="line">    <span class="type">int</span> edgenum;           <span class="comment">// 边数</span></span><br><span class="line">    <span class="type">int</span> matrix[MAX][MAX];  <span class="comment">// 邻接矩阵</span></span><br><span class="line">&#125; Graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">edgeData</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> start;  <span class="comment">// 边的起点</span></span><br><span class="line">    <span class="type">char</span> end;    <span class="comment">// 边的终点</span></span><br><span class="line">    <span class="type">int</span> weight;  <span class="comment">// 边的权重</span></span><br><span class="line">&#125; EData;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getIndexOfVex</span><span class="params">(Graph *pGraph, <span class="type">char</span> vex)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">createGraph</span><span class="params">(Graph *pGraph, <span class="type">char</span> vexs[], <span class="type">int</span> vexnum, EData edges[], <span class="type">int</span> edgenum)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dijkstra</span><span class="params">(Graph *pGraph, <span class="type">char</span> start, <span class="type">int</span> dist[], <span class="type">int</span> prev[])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">printPath</span><span class="params">(Graph *pGraph, <span class="type">char</span> start, <span class="type">char</span> end, <span class="type">int</span> dist[], <span class="type">int</span> prev[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> vexs[] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> vexnum = <span class="keyword">sizeof</span>(vexs) / <span class="keyword">sizeof</span>(vexs[<span class="number">0</span>]);</span><br><span class="line">    EData edges[] = &#123;</span><br><span class="line">        &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="number">5</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="number">8</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">15</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="number">10</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> edgenum = <span class="keyword">sizeof</span>(edges) / <span class="keyword">sizeof</span>(edges[<span class="number">0</span>]);</span><br><span class="line">    Graph graph;</span><br><span class="line">    <span class="type">int</span> dist[MAX]; <span class="comment">// 存储最短路径长度</span></span><br><span class="line">    <span class="type">int</span> prev[MAX]; <span class="comment">// 存储前驱节点</span></span><br><span class="line"></span><br><span class="line">    createGraph(&amp;graph, vexs, vexnum, edges, edgenum);</span><br><span class="line">    dijkstra(&amp;graph, <span class="string">&#x27;A&#x27;</span>, dist, prev);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vexnum; i++) &#123;</span><br><span class="line">        printPath(&amp;graph, <span class="string">&#x27;A&#x27;</span>, vexs[i], dist, prev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个数加上无穷大会溢出，所以定义的 INF 为最大值的一半，防止溢出风险。</p>
</blockquote>
<h3 id="测试结果">测试结果</h3>
<p>这是测试用例中构建的图：</p>
<p><img src="/images/algorithm/dijkstra-n.png" alt=""></p>
<p>测试结果，打印从起点到终点的最短路径上的节点和最短距离：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A -&gt; A: A, minDist: 0</span><br><span class="line">A -&gt; B: A B, minDist: 2</span><br><span class="line">A -&gt; C: A C, minDist: 6</span><br><span class="line">A -&gt; D: A B D, minDist: 7</span><br><span class="line">A -&gt; E: A B D E, minDist: 17</span><br><span class="line">A -&gt; F: A B D F, minDist: 22</span><br><span class="line">A -&gt; G: A B D E G, minDist: 19</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://www.cnblogs.com/skywang12345/p/3711512.html">https://www.cnblogs.com/skywang12345/p/3711512.html</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>图算法</category>
      </categories>
      <tags>
        <tag>Dijkstra算法</tag>
        <tag>单源最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法之 Floyd 多源最短路径</title>
    <url>/posts/231116150205.html</url>
    <content><![CDATA[<p>Floyd-Warshall 算法，中文亦称弗洛伊德算法或佛洛依德算法，是一种利用动态规划的思想解决多源（任意两点间）最短路径的算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。 Floyd-Warshall 算法的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><msup><mi mathvariant="normal">∣</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|V|^{3})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|V|^{2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 是点集（来自维基百科的定义）。</p>
<span id="more"></span>
<blockquote>
<ol>
<li>「负权」指的是图中存在具有负权值的边，负权边表示从一个顶点到另一个顶点的距离是负值。Floyd-Warshall 算法可以正确处理包含负权边的图的最短路径问题。</li>
<li>「闭包」是指图中的传递关系。在有向图中，如果存在一条路径从顶点 A 到顶点 B，那么就说顶点 A 可以到达顶点 B。传递闭包就是将所有可以通过路径到达的顶点对进行标记，形成一个闭包集合。Floyd-Warshall 算法可以用来计算有向图的传递闭包，即找出所有顶点对之间是否存在路径。</li>
<li>「多源」指的是任意两点间的最短距离均可求出，「单源」指的是只能求一个顶点到其他点的最短距离，而不能求任意两点的最短距离。</li>
</ol>
</blockquote>
<h2 id="Floyd 基本思想">Floyd 基本思想</h2>
<p>Floyd 算法的基本思想是通过 <strong> 中转节点来逐步优化路径长度 </strong>。该算法维护一个二维矩阵<code>D</code>，其中<code>D[i][j]</code> 表示节点 <code>i</code> 到节点 <code>j</code> 的最短路径长度。算法的核心是通过遍历所有节点 <code>k</code>，将节点<code>k</code> 作为中转节点，更新矩阵 <code>D</code> 的值。</p>
<h2 id="Floyd 具体步骤">Floyd 具体步骤</h2>
<h3 id="Floyd 步骤描述">Floyd 步骤描述</h3>
<p>Floyd 算法的具体步骤如下：</p>
<ol>
<li>初始化矩阵 <code>D</code>，使得<code>D[i][j]</code> 表示节点 <code>i</code> 到节点 <code>j</code> 的直接距离，如果 <code>i</code> 和<code>j</code>之间没有直接边相连，则 <code>D[i][j]</code> 为无穷大，如果 <code>i</code> 和<code>j</code>相同，则 <code>D[i][j]</code> 为<code>0</code>，否则为直接相连的边的权值。</li>
<li>对于每个节点 <code>k</code>，遍历所有的节点<code>i</code> 和节点 <code>j</code>，如果<code>D[i][k] + D[k][j]</code> 的值小于 <code>D[i][j]</code>，则更新<code>D[i][j]</code> 为<code>D[i][k] + D[k][j]</code>。</li>
<li>重复步骤 2，直到遍历完所有节点<code>k</code>。</li>
<li>最终得到的矩阵 <code>D</code> 即为所有节点对之间的最短路径长度。</li>
</ol>
<p>步骤二利用的是动态规划的思想，其状态转移方程为：<code>D[i][j] = min(D[i][j], D[i][k] + D[k][j])</code>；步骤一中则给出了如何初始化矩阵 <code>D</code> 和<code>D[i][j]</code>的定义。</p>
<h3 id="Floyd 复杂度">Floyd 复杂度</h3>
<p>Floyd 算法的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><msup><mi mathvariant="normal">∣</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|V|^{3})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|V|^{2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 是点集。它的优点是可以处理带有负权边的图，并且可以同时求解任意两个节点之间的最短路径。然而，由于其时间复杂度较高，当节点数量较大时，可能会导致算法的运行时间较长。</p>
<h2 id="Floyd 算法图解">Floyd 算法图解</h2>
<h3 id="初始化距离矩阵">初始化距离矩阵</h3>
<p><code>D[i][j]</code>表示节点 <code>i</code> 到节点 <code>j</code> 的直接距离。初始化时，如果 <code>i</code> 和<code>j</code>之间没有直接边相连，则 <code>D[i][j]</code> 为无穷大，如果 <code>i</code> 和<code>j</code>相同，则 <code>D[i][j]</code> 为<code>0</code>，否则为直接相连的边的权值。</p>
<p>例如，节点 A 和节点 B 直接相连，权值为 2，节点 B 和节点 C 没有直接相连，权值为无穷大。</p>
<p><img src="/images/algorithm/floyd-init.png" alt="Floyd 距离矩阵初始化"></p>
<h3 id="更新距离矩阵">更新距离矩阵</h3>
<p>对于每个节点 <code>k</code>，遍历所有的节点<code>i</code> 和节点 <code>j</code>，如果<code>D[i][k] + D[k][j]</code> 的值小于 <code>D[i][j]</code>，则更新<code>D[i][j]</code> 为<code>D[i][k] + D[k][j]</code>。</p>
<p><img src="/images/algorithm/floyd-update.png" alt="Floyd 距离矩阵更新"></p>
<p>例如，当遍历节点 A 时：</p>
<ul>
<li>A 和 B 直接相连、A 和 C 直接相连、B 和 C 没有直接相连，因此可以通过中转节点 A 更新节点 B 和节点 C 的距离为 2+3=5。</li>
<li>A 和 C 直接相连、A 和 D 直接相连、C 和 D 也直接相连，因此也可以通过中转节点 A 更新节点 C 和节点 D 的距离，但是更新的值不小于 C 和 D 直接相连的值，所有不进行更新。</li>
</ul>
<h2 id="Floyd 算法实现">Floyd 算法实现</h2>
<h3 id="Floyd 算法编码">Floyd 算法编码</h3>
<p>假设任意两点的间的距离，存储在邻接矩阵 <code>graph</code> 中，如果两点之间不直接相连，则该位置的值为无穷大 <code>inf</code>，否则为相应的距离值。</p>
<blockquote>
<p>当然，也可以通过数组直接存储直接相连的边的信息，如 <code>[[nodeA, nodeB, distAB], ..., [nodeC, nodeZ, distCZ]]</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf (INT_MAX)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> n (4)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">floydWarshall</span><span class="params">(<span class="type">int</span> graph[n][n])</span> &#123;</span><br><span class="line">    <span class="type">int</span> dist[n][n];</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤一：初始化结果矩阵，使其等于输入图的邻接矩阵 </span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dist[i][j] = graph[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤二 &amp; 三：对每个节点 k 进行遍历，作为中转节点</span></span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        <span class="comment">// 遍历所有节点对(i, j)</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 加入这个判断，防止后面的加法运算溢出</span></span><br><span class="line">                <span class="keyword">if</span> (dist[i][k] == inf || dist[k][j] == inf) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果通过节点 k 可以缩短路径长度，则更新 dist[i][j] 的值</span></span><br><span class="line">                <span class="keyword">if</span> (dist[i][k] + dist[k][j] &lt; dist[i][j]) &#123;</span><br><span class="line">                    dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤四：打印最短路径矩阵</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 最短路径矩阵为：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[i][j] == inf) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;inf &quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, dist[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> graph[n][n] = &#123;&#123;<span class="number">0</span>, <span class="number">5</span>, inf, <span class="number">10</span>&#125;,</span><br><span class="line">                       &#123;inf, <span class="number">0</span>, <span class="number">3</span>, inf&#125;,</span><br><span class="line">                       &#123;inf, inf, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                       &#123;inf, inf, inf, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    floydWarshall(graph);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码实现了 Floyd 算法，最终输出的结果是最短路径矩阵，显示了所有节点对之间的最短路径长度。</p>
<blockquote>
<p>注意处理 <code>inf + inf</code> 和 <code>x + inf</code> 相加会造成的数据溢出。</p>
</blockquote>
<h3 id="程序运行结果">程序运行结果</h3>
<p>无向图 <code>graph</code> 中直接相连的节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0]---5---[1]</span><br><span class="line"> |         |</span><br><span class="line"> 10        3</span><br><span class="line"> |         |</span><br><span class="line">[3]---1---[2]</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最短路径矩阵为：</span><br><span class="line">0 5 8 9</span><br><span class="line">inf 0 3 4</span><br><span class="line">inf inf 0 1</span><br><span class="line">inf inf inf 0</span><br></pre></td></tr></table></figure>
<h3 id="Floyd 算法优化">Floyd 算法优化</h3>
<p>对于无向图，节点对 <code>(i, j)</code> 和节点对 <code>(j, i)</code>具有相同的权值（距离）。当遍历每一个中转节点时，<code>D[i][j]</code>的值的更新，只跟三个位置有关，即 <code>i, j, k</code>；而此时 <code>k</code> 固定，在 <code>i, j</code> 的双重循环下，会产生重复操作，因此我们可以只遍历矩阵右上三角部分即可，即 <code>j</code> 从 <code>i + 1</code> 开始遍历。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; n; j++) &#123;  <span class="comment">// 去掉重复的计算 </span></span><br><span class="line">            <span class="keyword">if</span> (dist[i][k] == inf || dist[k][j] == inf) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dist[i][k] + dist[k][j] &lt; dist[i][j]) &#123;</span><br><span class="line">                dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line">                dist[j][i] = dist[i][j];  <span class="comment">// 一并更新反向节点(j, i) 的距离</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Floyd 算法，俗称插点法，不就一个点 <code>k</code> 一个点 <code>k'</code> 地插进去，作为中转节点，更新节点对之间的距离嘛</strong>！</p>
<blockquote>
<p>参考资料 &amp; 图源：<a href="https://www.cnblogs.com/bigsai/p/15213511.html">https://www.cnblogs.com/bigsai/p/15213511.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>图算法</category>
      </categories>
      <tags>
        <tag>Floyd算法</tag>
        <tag>多源最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法之二分查找</title>
    <url>/posts/231124181658.html</url>
    <content><![CDATA[<p>二分查找算法是一种在有序数组中查找特定元素的常用算法，它的时间复杂度为 <code>O(log n)</code>；由于每次查找都将数组规模减半，因此算法的效率非常高。本文记录了二分查找的常见场景，给出在升序数组中：</p>
<ul>
<li>查找给定目标值的索引；</li>
<li>查找大于等于目标值的最小索引、查找大于目标值的最小索引；</li>
<li>查找小于等于目标值的最大索引、查找小于目标值的最大索引。</li>
</ul>
<span id="more"></span>
<h2 id="二分查找难点">二分查找难点</h2>
<p>二分查找最难把握的就是：</p>
<ol>
<li><code>while</code> 循环的条件到底要不要加等于号：</li>
<li>不同的 <code>if</code> 判断下，要不要加、减一。</li>
</ol>
<blockquote>
<p>记住，在 <code>while</code> 条件不加「等号」时，<code>l</code> 和 <code>r</code> 只有一个加（或减）一；在 <code>while</code> 条件加「等号」时，<code>l</code> 和 <code>r</code> 都有加一（或减）一。然后，再梳理清楚其它细节即可。</p>
</blockquote>
<h2 id="查找目标值的索引">查找目标值的索引</h2>
<p>例如，升序数组为 <code>[1, 3, 5, 7, 12, 12, 12, 13, 16]</code>，目标值为 <code>12</code>，那么可能返回索引 <code>4, 5, 6</code> 中的一个。若目标值不存在，则返回 <code>-1</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分查找给定目标值的索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> target, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123; <span class="comment">// 等于</span></span><br><span class="line">        <span class="type">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>; <span class="comment">// 右值减一</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找大于等于目标值的最小索引（下限）">查找大于等于目标值的最小索引（下限）</h2>
<p>例如，升序数组为 <code>[1, 3, 5, 7, 12, 12, 12, 13, 16]</code>，目标值为 <code>12</code>，那么应该返回索引 <code>4</code>。若数组中不存在大于等于目标值的数，则返回 <code>-1</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找大于等于目标值的最小索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findGreateEq</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> target, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123; <span class="comment">// 不加等于</span></span><br><span class="line">        <span class="type">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid; <span class="comment">// 右值不减</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[l] &gt;= target ? l : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为查找的是「<strong>大于等于 </strong> 目标值的最小索引」，所以在 <code>mid</code> 位置：</p>
<ul>
<li>小于目标值时，最小索引应该落在区间 <code>[mid + 1, r]</code>，所以 <code>l</code> 更新为 <code>l = mid + 1</code>。</li>
<li><strong>大于等于 </strong> 目标值时，最小索引应该落在区间 <code>[l, mid]</code>，所以 <code>r</code> 更新为 <code>r = mid</code>，而不是 <code>r = mid - 1</code>；</li>
</ul>
<h2 id="查找大于目标值的最小索引">查找大于目标值的最小索引</h2>
<p>例如，升序数组为 <code>[1, 3, 5, 7, 12, 12, 12, 13, 16]</code>，目标值为 <code>12</code>，那么应该返回索引 <code>7</code>。若数组中不存在大于目标值的数，则返回 <code>-1</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找大于目标值的最小索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findGreate</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> target, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123; <span class="comment">// 不加等于</span></span><br><span class="line">        <span class="type">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt;= target) &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid; <span class="comment">// 右值不减</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[l] &gt; target ? l : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为查找的是「<strong>大于 </strong> 目标值的最小索引」，所以在 <code>mid</code> 位置：</p>
<ul>
<li>小于等于目标值时，最小索引应该落在区间 <code>[mid + 1, r]</code>，所以 <code>l</code> 更新为 <code>l = mid + 1</code>。</li>
<li><strong>大于 </strong> 目标值时，最小索引应该落在区间 <code>[l, mid]</code>，所以 <code>r</code> 更新为 <code>r = mid</code>，而不是 <code>r = mid - 1</code>；</li>
</ul>
<h2 id="查找小于等于目标值的最大索引（上限）">查找小于等于目标值的最大索引（上限）</h2>
<p>例如，升序数组为 <code>[1, 3, 5, 7, 12, 12, 12, 13, 16]</code>，目标值为 <code>12</code>，那么应该返回索引 <code>6</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找小于等于目标值的最大索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findLessEq</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> target, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;  <span class="comment">// 不加等于</span></span><br><span class="line">        <span class="comment">// 加一是为了向上取整，防止 while 死循环</span></span><br><span class="line">        <span class="type">int</span> mid = l + ((r + <span class="number">1</span> - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt;= target) &#123;</span><br><span class="line">            l = mid; <span class="comment">// 左值不加</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[r] &lt;= target ? r : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为查找的是「<strong>小于等于 </strong> 目标值的最大索引」，所以在 <code>mid</code> 位置：</p>
<ul>
<li><strong>小于等于 </strong> 目标值时，最大索引应该落在区间 <code>[mid, r]</code>，所以 <code>l</code> 更新为 <code>l = mid</code>，而不是 <code>l = mid + 1</code>；</li>
<li>大于目标值时，最大索引应该落在区间 <code>[l, mid - 1]</code>，所以 <code>r</code> 更新为 <code>r = mid - 1</code>。</li>
</ul>
<h2 id="查找小于目标值的最大索引">查找小于目标值的最大索引</h2>
<p>例如，升序数组为 <code>[1, 3, 5, 7, 12, 12, 12, 13, 16]</code>，目标值为 <code>12</code>，那么应该返回索引 <code>3</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找小于目标值的最大索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findLess</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> target, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;  <span class="comment">// 不加等于</span></span><br><span class="line">        <span class="comment">// 加一是为了向上取整，防止 while 死循环</span></span><br><span class="line">        <span class="type">int</span> mid = l + ((r + <span class="number">1</span> - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">            l = mid; <span class="comment">// 左值不加</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[r] &lt; target ? r : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为查找的是「<strong>小于 </strong> 目标值的最大索引」，所以在 <code>mid</code> 位置：</p>
<ul>
<li><strong>小于 </strong> 目标值时，最大索引应该落在区间 <code>[mid, r]</code>，所以 <code>l</code> 更新为 <code>l = mid</code>，而不是 <code>l = mid + 1</code>；</li>
<li>大于等于目标值时，最大索引应该落在区间 <code>[l, mid - 1]</code>，所以 <code>r</code> 更新为 <code>r = mid - 1</code>。</li>
</ul>
<h2 id="功能测试">功能测试</h2>
<h3 id="测试代码">测试代码</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr1[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">16</span>&#125;;</span><br><span class="line">    <span class="type">int</span> arr2[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">17</span>&#125;;</span><br><span class="line">    <span class="type">int</span> size1 = <span class="keyword">sizeof</span>(arr1) / <span class="keyword">sizeof</span>(arr1[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> size2 = <span class="keyword">sizeof</span>(arr2) / <span class="keyword">sizeof</span>(arr2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;t\tidx\tgeqIdx\tgIdx\tleqIdx\tlIdx\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size2; i++) &#123;</span><br><span class="line">        <span class="type">int</span> target = arr2[i];</span><br><span class="line">        <span class="type">int</span> targetIdx = binarySearch(arr1, target, <span class="number">0</span>, size1 - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> greateEqIdx = findGreateEq(arr1, target, <span class="number">0</span>, size1 - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> greateIdx = findGreate(arr1, target, <span class="number">0</span>, size1 - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> lessEqIdx = findLessEq(arr1, target, <span class="number">0</span>, size1 - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> lessIdx = findLess(arr1, target, <span class="number">0</span>, size1 - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t%d\t%d\t%d\t%d\t%d\n&quot;</span>, target, targetIdx, greateEqIdx, greateIdx, lessEqIdx, lessIdx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试结果">测试结果</h3>
<p>上述测试代码的测试结果如下，可以发现结果是正确的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t       idx     geqIdx  gIdx    leqIdx  lIdx</span><br><span class="line">0       -1      0       0       -1      -1</span><br><span class="line">1       0       0       1       0       -1</span><br><span class="line">3       1       1       2       1       0</span><br><span class="line">5       2       2       3       2       1</span><br><span class="line">7       3       3       4       3       2</span><br><span class="line">11      -1      4       4       3       3</span><br><span class="line">12      4       4       7       6       3</span><br><span class="line">13      7       7       8       7       6</span><br><span class="line">16      8       8       -1      8       7</span><br><span class="line">17      -1      -1      -1      8       8</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法之堆排序</title>
    <url>/posts/231107171607.html</url>
    <content><![CDATA[<p>堆排序是一种基于二叉堆数据结构的排序算法。它的主要思想是将待排序的序列构建成一个大顶堆（或小顶堆），然后 <strong> 依次取出堆顶元素，将其与堆中最后一个元素交换，并调整堆，使得剩余元素仍满足堆的性质</strong>。重复这个过程，直到堆中只剩下一个待调整元素，即可得到一个有序序列。</p>
<p>上面说，大顶堆依次将堆顶（当前最大）元素与堆中最后一个元素交换。因此，基于大顶堆的堆排序后的结果是一个升序序列，基于小顶堆的堆排序后的结果是一个降序序列。</p>
<span id="more"></span>
<blockquote>
<p>上面调整堆的堆化过程，是将「剩余的元素」重新构造成一个堆（通过交换的方式放在堆尾的元素不再参与堆化调整）。</p>
</blockquote>
<h2 id="堆排序步骤">堆排序步骤</h2>
<p>按文章开头的描述，堆排序的过程可以分为两个主要步骤：<strong>构建堆和调整堆</strong>。下面以大顶堆的堆排序来进行描述。</p>
<ol>
<li>
<p>构建堆：<br>
首先，将待排序的序列构建成一个初始堆。可以 <strong> 从最后一个非叶子节点开始，依次向前遍历 </strong>，对每个节点进行调整，使得该节点的值大于其子节点的值。这个过程称为堆化，可以使用<strong> 下沉操作 </strong> 来实现。</p>
</li>
<li>
<p>调整堆：<br>
将堆顶元素与堆中最后一个元素交换位置，<strong>并将堆的大小减一 </strong>。然后对堆顶元素进行<strong> 下沉操作</strong>，使得剩余元素仍满足堆的性质。重复这个过程，直到堆中只剩下一个元素，即可得到一个有序序列。</p>
</li>
</ol>
<p>堆排序在实际应用中具有较高的效率和稳定性，尤其适用于大规模数据的排序。</p>
<blockquote>
<p>堆化的两个主要操作是下沉（弹出堆顶元素时使用）和上浮（往堆中添加新元素时使用）操作，可以参考 <a href="https://pursue26.github.io/posts/231018102559.html"> 数据结构之堆基础与堆结构（数组实现）</a>。</p>
</blockquote>
<h2 id="堆排序复杂度">堆排序复杂度</h2>
<p>堆排序的时间复杂度为 <code>O(nlogn)</code>，其中 <code>n</code> 是待排序序列的长度。由于堆排序只需要常数的辅助空间，因此它是一种原地排序算法，空间复杂度为 <code>O(1)</code>。但 <strong> 堆排序是不稳定的排序算法，即相同元素的顺序可能会发生改变</strong>。</p>
<h2 id="堆排序实现">堆排序实现</h2>
<h3 id="从无序序列构建堆">从无序序列构建堆</h3>
<p>对于给定的长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 的无序序列进行堆排序的第一个过程是：构建堆——将无序序列构建成一个二叉堆数据结构。</p>
<p>上面说「从最后一个非叶子节点开始，依次向前遍历」，最后一个非叶子节点的数组索引（从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 开始）为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n/2 - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p>
<p>为了完成从无序序列构建堆的这一过程。我们首先给出堆化中的下沉操作。<strong>假设，我们现在已经有一个满足堆属性的数组，当我们修改了数组某一个索引位置的值时，就需要重新对这个位置，以及之前的所有位置都进行堆化调整</strong>。</p>
<p>例如，对于下面的大顶堆：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    60</span><br><span class="line">   /  \</span><br><span class="line">  30  40</span><br><span class="line"> / \</span><br><span class="line">25 28</span><br></pre></td></tr></table></figure>
<p>如果把索引 1 位置的值 30 修改为 70，那么索引 1 和 索引 0 都需要进行堆化调整。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 调整索引 1 位置</span><br><span class="line">        60</span><br><span class="line">       /  \</span><br><span class="line">      70  40</span><br><span class="line">     / \</span><br><span class="line">    25 28</span><br><span class="line"></span><br><span class="line">// 调整索引 0 位置</span><br><span class="line">        70</span><br><span class="line">       /  \</span><br><span class="line">      60  40</span><br><span class="line">     / \</span><br><span class="line">    25 28</span><br></pre></td></tr></table></figure>
<p>如果把索引 1 位置的值 30 修改为 15，那么索引 1 和 索引 0 也都需要进行堆化调整。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 调整索引 1 位置</span><br><span class="line">        60</span><br><span class="line">       /  \</span><br><span class="line">      28  40</span><br><span class="line">     / \</span><br><span class="line">    25 15</span><br><span class="line"></span><br><span class="line">// 调整索引 0 位置（满足堆属性，随即退出）</span><br><span class="line">        60</span><br><span class="line">       /  \</span><br><span class="line">      28  40</span><br><span class="line">     / \</span><br><span class="line">    25 15</span><br></pre></td></tr></table></figure>
<p>对于给定的长度为 <code>n</code> 的数组（满足堆属性），当修改了索引 <code>i</code> 位置的值时，堆化调整以索引 <code>i</code> 为根节点的子树，使这棵以索引 <code>i</code> 为根节点的树重新满足堆属性（但不再能保证整个数组满足堆属性，若需要整棵树都满足堆属性，还需要按顺序对以索引 <code>i-1</code> 到以索引 <code>0</code>为根的子树进行堆化调整）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下沉操作，使以索引 i 为根节点的子树满足堆属性</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="type">int</span> largest = i;  <span class="comment">// 初始化根节点为最大值</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;  <span class="comment">// 左子节点</span></span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;  <span class="comment">// 右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子节点大于根节点，则更新最大值</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果右子节点大于根节点，则更新最大值</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果最大值不是根节点，则进行交换，并递归调整子堆</span></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="type">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[largest];</span><br><span class="line">        arr[largest] = temp;</span><br><span class="line"></span><br><span class="line">        heapify(arr, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在开始从最后一个非叶子节点，依次向前遍历进行下沉堆化。每遍历一个节点，都会使得以这个节点为根节点的树满足堆属性，那么当遍历完索引为 <code>0</code> 的位置后，整个数组将满足堆属性，构成一棵二叉堆。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建堆（从最后一个非叶子节点开始，依次向前遍历进行下沉堆化）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    heapify(arr, n, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调整堆">调整堆</h3>
<p>将堆顶元素与堆中最后一个元素交换位置，<strong>并将堆的大小减一 </strong>。然后对堆顶元素进行<strong> 下沉操作</strong>，使得剩余元素仍满足堆的性质。重复这个过程，直到堆中只剩下一个元素，即可得到一个有序序列。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 依次取出堆顶元素，并调整这个更小的堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="type">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">    arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">    arr[i] = temp;</span><br><span class="line">    heapify(arr, i, <span class="number">0</span>);  <span class="comment">// 将堆的大小减小为 i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序完整代码">堆排序完整代码</h2>
<h3 id="堆排序代码">堆排序代码</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> i)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(arr, n, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">        heapify(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆排序测试代码">堆排序测试代码</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> i)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 原始数组：&quot;</span>);</span><br><span class="line">    printArray(arr, n);</span><br><span class="line"></span><br><span class="line">    heapSort(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 排序后数组：&quot;</span>);</span><br><span class="line">    printArray(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试结果">测试结果</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原始数组：12 11 13 5 6 7</span><br><span class="line">排序后数组：5 6 7 11 12 13</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>堆排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法之字符串哈希函数</title>
    <url>/posts/240313193201.html</url>
    <content><![CDATA[<p>哈希函数的作用是将一个较大的输入空间映射到一个较小的输出空间，且尽可能保证均匀映射。在哈希表中，输入空间是所有 <code>key</code>，输出空间是所有哈希桶（数组索引）。换句话说，对于一个输入 <code>key</code>，可以通过哈希函数得到该 <code>key</code> 在数组中的位置。哈希函数应尽可能保证映射后的输出空间尽可能均匀、分散，以减少哈希冲突的发生。</p>
<span id="more"></span>
<p>本文重点分析字符串哈希函数，即输入是字符串的哈希函数。评价 Hash 函数性能的一个重要指标就是冲突，在相关资源允许的条件下冲突越少，Hash 函数的性能就越好。显然，<strong>对于字符串哈希函数，尽可能使每个字符都影响哈希值可以减少冲突</strong>。</p>
<h1 id="哈希函数性质">哈希函数性质</h1>
<p>具体来说，Hash 函数最重要的性质可以概括为下面两条：</p>
<ol>
<li>在 Hash 函数值不一样的时候，两个字符串一定不一样；</li>
<li>在 Hash 函数值一样的时候，两个字符串不一定一样（但大概率一样，且我们当然希望它们总是一样的）。</li>
</ol>
<p>我们将 Hash 函数值一样、但原字符串不一样的现象称为哈希碰撞。</p>
<p><strong>哈希函数设计的关注点</strong>：时间复杂度（尽可能低）和 Hash 的准确率（哈希碰撞的概率尽可能低）。</p>
<h1 id="字符串哈希函数">字符串哈希函数</h1>
<p>常用字符串哈希函数有 BKDRHash，APHash，DJBHash，JSHash，RSHash，SDBMHash，PJWHash，ELFHash 等等。对于以上几种哈希函数，<a href="https://blog.csdn.net/wanglx_/article/details/40300363">这篇文章 </a> 对其进行了一个小小的评测。</p>
<style> table {font-size: 14px;} </style>
<table>
<thead>
<tr>
<th>Hash 函数</th>
<th>数据 1</th>
<th>数据 2</th>
<th>数据 3</th>
<th>数据 4</th>
<th>数据 1 得分</th>
<th>数据 2 得分</th>
<th>数据 3 得分</th>
<th>数据 4 得分</th>
<th>平均分</th>
</tr>
</thead>
<tbody>
<tr>
<td>BKDRHash</td>
<td>2</td>
<td>0</td>
<td>4774</td>
<td>481</td>
<td>96.55</td>
<td>100</td>
<td>90.95</td>
<td>82.05</td>
<td>92.64</td>
</tr>
<tr>
<td>APHash</td>
<td>2</td>
<td>3</td>
<td>4754</td>
<td>493</td>
<td>96.55</td>
<td>88.46</td>
<td>100</td>
<td>51.28</td>
<td>86.28</td>
</tr>
<tr>
<td>DJBHash</td>
<td>2</td>
<td>2</td>
<td>4975</td>
<td>474</td>
<td>96.55</td>
<td>92.31</td>
<td>0</td>
<td>100</td>
<td>83.43</td>
</tr>
<tr>
<td>JSHash</td>
<td>1</td>
<td>4</td>
<td>4761</td>
<td>506</td>
<td>100</td>
<td>84.62</td>
<td>96.83</td>
<td>17.95</td>
<td>81.94</td>
</tr>
<tr>
<td>RSHash</td>
<td>1</td>
<td>0</td>
<td>4861</td>
<td>505</td>
<td>100</td>
<td>100</td>
<td>51.58</td>
<td>20.51</td>
<td>75.96</td>
</tr>
<tr>
<td>SDBMHash</td>
<td>3</td>
<td>2</td>
<td>4849</td>
<td>504</td>
<td>93.1</td>
<td>92.31</td>
<td>57.01</td>
<td>23.08</td>
<td>72.41</td>
</tr>
<tr>
<td>PJWHash</td>
<td>30</td>
<td>26</td>
<td>4878</td>
<td>513</td>
<td>0</td>
<td>0</td>
<td>43.89</td>
<td>0</td>
<td>21.95</td>
</tr>
<tr>
<td>ELFHash</td>
<td>30</td>
<td>26</td>
<td>4878</td>
<td>513</td>
<td>0</td>
<td>0</td>
<td>43.89</td>
<td>0</td>
<td>21.95</td>
</tr>
</tbody>
</table>
<ul>
<li>数据 1 为 100k 个字母和数字组成的随机串哈希冲突个数。</li>
<li>数据 2 为 100k 个有意义的英文句子的哈希冲突个数。</li>
<li>数据 3 为数据 1 的哈希值与 1000003(大素数)求模后存储到线性表中冲突的个数。</li>
<li>数据 4 为数据 1 的哈希值与 10000019(更大素数)求模后存储到线性表中冲突的个数。</li>
</ul>
<p>经过比较，得出以上平均得分（平均数为平方平均数）。可以发现，BKDRHash 无论是在实际效果还是编码实现中，效果都是最突出的。APHash 也是较为优秀的算法。DJBHash，JSHash，RSHash 与 SDBMHash 各有千秋。PJWHash 与 ELFHash 效果最差，但得分相似，其算法本质是相似的。</p>
<h2 id="PolynomialHash 算法">PolynomialHash 算法</h2>
<p><strong>数学模型</strong>：对于一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> 的字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> 来说，可以这样定义多项式 Hash 函数：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>l</mi></munderover><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>×</mo><msup><mi>b</mi><mrow><mi>l</mi><mo>−</mo><mi>i</mi></mrow></msup><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mi>M</mi></mrow><annotation encoding="application/x-tex">f(s) = \sum_{i=1}^{l} s[i-1] \times b^{l-i} \bmod M
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.1137820000000005em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8361130000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8991079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span></span></p>
<p>例如，对于字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>y</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">xyz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>，其哈希函数值为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><msup><mi>b</mi><mn>2</mn></msup><mo>+</mo><mi>y</mi><mi>b</mi><mo>+</mo><mi>z</mi><mo stretchy="false">)</mo><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mi>M</mi></mrow><annotation encoding="application/x-tex">(xb^{2}+yb+z) \bmod M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>。</p>
<p><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 的选择</strong>：一个质数（至少要比最大的字符要大），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> 可以任意选择。</p>
<p><strong>求解多项式 </strong>：我们可以利用秦九韶算法（又称 Horner 算法）以<code>O(n)</code> 的时间复杂度求解多项式的和。</p>
<p>一般地，一元 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 次多项式的求值需要经过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n(n+1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 次乘法和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 次加法，而秦九韶算法只需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 次乘法和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 次加法。</p>
<p>原多项式公式：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>a</mi><mi>n</mi></msub><msup><mi>x</mi><mi>n</mi></msup><mo>+</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><msup><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><mo>…</mo><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mi>x</mi><mo>+</mo><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">f(x) = a_nx^n + a_{n-1}x^{n-1} + \ldots + a_1x + a_0
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8643919999999999em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.072439em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p><strong>秦九韶算法展开式</strong>：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mo>…</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mi>n</mi></msub><mi>x</mi><mo>+</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mi>x</mi><mo>+</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msub><mo stretchy="false">)</mo><mi>x</mi><mo>+</mo><mo>…</mo><mo stretchy="false">)</mo><mi>x</mi><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mi>x</mi><mo>+</mo><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">f(x) = (((\ldots(((a_nx + a_{n-1})x + a_{n-2})x + \ldots)x + a_1)x + a_0
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mopen">(</span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner">…</span><span class="mclose">)</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p><strong>实现代码</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;  <span class="comment">// 用跟元素个数最接近的质数作为散列表的大小</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">PolyHash</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> b = <span class="number">233</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*s) &#123;</span><br><span class="line">        hash = ((ull)hash * b + *(s++)) % MOD;  <span class="comment">// 秦九韶算法展开式</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BKDRHash 算法">BKDRHash 算法</h2>
<p>BKDRHash 算法是由 Brian Kernighan 与 Dennis Ritchie 的《The C Programming Language》一书被展示而得名，是一种简单快捷的 hash 算法，也是 Java 目前采用的字符串的 Hash 算法（累乘因子为 31）。</p>
<p>BKDRHash 算法的 <strong> 原理是遍历字符串中的每个字符，将前一个字符的哈希值乘以一个固定的素数，然后加上当前字符整形值。最后，对得到的哈希值进行位运算，确保其在特定的整数范围内</strong>。</p>
<p><strong>实现代码</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">BKDRHash</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> seed = <span class="number">131</span>;  <span class="comment">// 31 131 1313 13131 131313 etc..</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*s) &#123;</span><br><span class="line">        hash = hash * seed + *(s++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash &amp; <span class="number">0x7FFFFFFF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>BKDRHash 算法和 PolynomialHash 算法并不是同一个算法，但好像很相似。</p>
</blockquote>
<h2 id="APHash 算法">APHash 算法</h2>
<p>Arash Partow 提出了这个算法，声称具有很好地分布性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">APHash</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> hash = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; *s; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            hash ^= ((hash &lt;&lt; <span class="number">7</span>) ^ (*s++) ^ (hash &gt;&gt; <span class="number">3</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hash ^= (~((hash &lt;&lt; <span class="number">11</span>) ^ (*s++) ^ (hash &gt;&gt; <span class="number">5</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hash &amp; <span class="number">0x7FFFFFFF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DJBHash 算法">DJBHash 算法</h2>
<p>Daniel J. Bernstein 在 comp.lang.c 邮件列表中发表的，是距今为止比较高效的哈希函数之一。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">DJBHash</span><span class="params">(<span class="type">char</span>* str)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> hash = <span class="number">5381</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*str) &#123;</span><br><span class="line">        hash += (hash &lt;&lt; <span class="number">5</span>) + (*str++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hash &amp; <span class="number">0x7FFFFFFF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://oi-wiki.org/string/hash/">https://oi-wiki.org/string/hash/</a></li>
<li><a href="https://blog.csdn.net/wanglx_/article/details/40300363">https://blog.csdn.net/wanglx_/article/details/40300363</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>字符串哈希</category>
      </categories>
      <tags>
        <tag>字符串哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法之归并排序</title>
    <url>/posts/231218181635.html</url>
    <content><![CDATA[<p>归并排序（Merge Sort）是一种分治算法，它 <strong> 将一个待排序的数组分成两个子数组，然后递归地对子数组进行排序 </strong>，最后将两个有序的子数组<strong> 合并 </strong> 成一个有序的数组。</p>
<p>例如，对于两个有序的子数组 A 和 B，我们借助一个 <em> 长度等于原数组 </em> 的临时数组 C，并为每个数组维护一个指针。通过指针的滑动比较，将 A 和 B 中较小的值填充到 C 中，完成一次合并（不同批次的归并过程，填充了临时数组 C 中的不同范围），最后再将数组 C 中的数据拷贝回原始数组，即可完成排序。</p>
<p>归并排序是经典的分治（divide-and-conquer）策略，它将问题分为一些小的问题，然后递归求解；而治的阶段则将分的阶段解得的各个答案修补到一起。</p>
<span id="more"></span>
<h1 id="归并排序实现">归并排序实现</h1>
<h2 id="归并排序">归并排序</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> tempArr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        mergeSort(arr, tempArr, left, mid);        <span class="comment">// 归</span></span><br><span class="line">        mergeSort(arr, tempArr, mid + <span class="number">1</span>, right);   <span class="comment">// 归</span></span><br><span class="line">        merge(arr, tempArr, left, mid + <span class="number">1</span>, right); <span class="comment">// 并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并过程">并过程</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* leftPos = start of left half, rightPos = start of right half, rightEnd = end of right half */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> tempArr[], <span class="type">int</span> leftPos, <span class="type">int</span> rightPos, <span class="type">int</span> rightEnd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> leftEnd = rightPos - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> leftPtr = leftPos, rightPtr = rightPos, tempPtr = leftPos; <span class="comment">// 三个指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个有序的子数组 A 和 B，填充到临时数组 C 中</span></span><br><span class="line">    <span class="keyword">while</span> (leftPtr &lt;= leftEnd &amp;&amp; rightPtr &lt;= rightEnd) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[leftPtr] &lt;= arr[rightPtr]) &#123;</span><br><span class="line">            tempArr[tempPtr++] = arr[leftPtr++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tempArr[tempPtr++] = arr[rightPtr++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (leftPtr &lt;= leftEnd) &#123;</span><br><span class="line">        tempArr[tempPtr++] = arr[leftPtr++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (rightPtr &lt;= rightEnd) &#123;</span><br><span class="line">        tempArr[tempPtr++] = arr[rightPtr++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将临时数组 C 拷贝回原始数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = leftPos; i &lt; rightEnd + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        arr[i] = tempArr[i]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果在 <code>merge()</code> 的每次递归调用内部申请临时数组，那么在任一时刻就可能有 <code>logN</code> 个临时数组处在活动期，这对于小内存的机器是致命的；且频繁的分配空间并释放空间的时间占用也会很多。所以，最好在 <code>mergeSort()</code> 开始之前申请好临时数组，并在排序完成后释放。</p>
</blockquote>
<h2 id="归并排序测试">归并排序测试</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> *tempArr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    mergeSort(arr, tempArr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After mergeSort: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); <span class="comment">// After mergeSort: 1 1 2 3 3 4 5 5 5 6 9</span></span><br><span class="line">    <span class="built_in">free</span>(tempArr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="归并排序分析">归并排序分析</h1>
<h2 id="时空复杂度">时空复杂度</h2>
<ul>
<li>最坏时间复杂度：<code>O(NlogN)</code>；</li>
<li>空间复杂度：<code>O(N)</code>，在「并」的过程中需要一个临时数组。</li>
</ul>
<h2 id="时间复杂度分析">时间复杂度分析</h2>
<p>假设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的幂，从而我们总可以将原数组（假设长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span>）分裂成大小相同的两部分（大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>）。</p>
<ul>
<li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，归并排序所用时间是常数，记为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">T(1) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>；</li>
<li>否则，对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个数归并排序的用时，等于完成两个大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>N</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{N}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 的递归排序所用的时间，再加上合并的时间（它是线性的），记为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mo>×</mo><mi>T</mi><mo stretchy="false">(</mo><mfrac><mi>N</mi><mn>2</mn></mfrac><mo stretchy="false">)</mo><mo>+</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">T(N) = 2 \times T(\frac{N}{2}) + N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>。</li>
</ul>
<p><strong>求解 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 方法一，用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 去除递推关系式的两边</strong>：</p>
<p>因为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mo>×</mo><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">T(N) = 2 \times T(N/2) + N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>，两边同时除以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>，有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><mi>N</mi></mfrac><mo>=</mo><mfrac><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><mrow><mi>N</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></mfrac><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\frac{T(N)}{N} = \frac{T(N/2)}{N/2} + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mord mtight">/</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，持续下去：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><mrow><mi>N</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mi mathvariant="normal">/</mi><mn>4</mn><mo stretchy="false">)</mo></mrow><mrow><mi>N</mi><mi mathvariant="normal">/</mi><mn>4</mn></mrow></mfrac><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\frac{T(N/2)}{N/2} = \frac{T(N/4)}{N/4} + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mord mtight">/</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mord mtight">/</span><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mord mtight">/</span><span class="mord mtight">4</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mi mathvariant="normal">/</mi><mn>4</mn><mo stretchy="false">)</mo></mrow><mrow><mi>N</mi><mi mathvariant="normal">/</mi><mn>4</mn></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mi mathvariant="normal">/</mi><mn>8</mn><mo stretchy="false">)</mo></mrow><mrow><mi>N</mi><mi mathvariant="normal">/</mi><mn>8</mn></mrow></mfrac><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\frac{T(N/4)}{N/4} = \frac{T(N/8)}{N/8} + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mord mtight">/</span><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mord mtight">/</span><span class="mord mtight">4</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mord mtight">/</span><span class="mord mtight">8</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mord mtight">/</span><span class="mord mtight">8</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mi mathvariant="normal">/</mi><mn>8</mn><mo stretchy="false">)</mo></mrow><mrow><mi>N</mi><mi mathvariant="normal">/</mi><mn>8</mn></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mi mathvariant="normal">/</mi><mn>16</mn><mo stretchy="false">)</mo></mrow><mrow><mi>N</mi><mi mathvariant="normal">/</mi><mn>16</mn></mrow></mfrac><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\frac{T(N/8)}{N/8} = \frac{T(N/16)}{N/16} + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mord mtight">/</span><span class="mord mtight">8</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mord mtight">/</span><span class="mord mtight">8</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mord mtight">/</span><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mord mtight">/</span><span class="mord mtight">1</span><span class="mord mtight">6</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mi mathvariant="normal">/</mi><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">)</mo></mrow><mrow><mi>N</mi><mi mathvariant="normal">/</mi><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>T</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>1</mn></mfrac><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\frac{T(N/2^{k-1})}{N/2^{k-1}} = \frac{T(1)}{1} + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.66634em;vertical-align:-0.5324199999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.13392em;"><span style="top:-2.6425799999999997em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mord mtight">/</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7820285714285714em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mord mtight">/</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9270285714285714em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5324199999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p>上面系列等式的左边之和等于右边之和，化简有：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><mi>N</mi></mfrac><mo>=</mo><mfrac><mrow><mi>T</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>1</mn></mfrac><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">\frac{T(N)}{N} = \frac{T(1)}{1} + logN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></p>
<p>因此，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>=</mo><mi>N</mi><mo>×</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>+</mo><mi>N</mi><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo>×</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(N) = N \times log(N) + N = O(N \times logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p>
<p><strong>求解 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 方法二，在右边连续地代入递归关系</strong>：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mo>×</mo><mi>T</mi><mo stretchy="false">(</mo><mfrac><mi>N</mi><mn>2</mn></mfrac><mo stretchy="false">)</mo><mo>+</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">T(N) = 2 \times T(\frac{N}{2}) + N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mn>2</mn><mo>×</mo><mo stretchy="false">(</mo><mn>2</mn><mo>×</mo><mi>T</mi><mo stretchy="false">(</mo><mfrac><mi>N</mi><mn>4</mn></mfrac><mo stretchy="false">)</mo><mo>+</mo><mfrac><mi>N</mi><mn>2</mn></mfrac><mo stretchy="false">)</mo><mo>+</mo><mi>N</mi><mo>=</mo><msup><mn>2</mn><mn>2</mn></msup><mo>×</mo><mi>T</mi><mo stretchy="false">(</mo><mfrac><mi>N</mi><msup><mn>2</mn><mn>2</mn></msup></mfrac><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mi>N</mi></mrow><annotation encoding="application/x-tex">= 2 \times (2 \times T(\frac{N}{4}) + \frac{N}{2}) + N = 2^2 \times T(\frac{N}{2^2}) + 2N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><msup><mn>2</mn><mn>2</mn></msup><mo>×</mo><mo stretchy="false">(</mo><mn>2</mn><mo>×</mo><mi>T</mi><mo stretchy="false">(</mo><mfrac><mi>N</mi><mn>8</mn></mfrac><mo stretchy="false">)</mo><mo>+</mo><mfrac><mi>N</mi><mn>4</mn></mfrac><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mi>N</mi><mo>=</mo><msup><mn>2</mn><mn>3</mn></msup><mo>×</mo><mi>T</mi><mo stretchy="false">(</mo><mfrac><mi>N</mi><msup><mn>2</mn><mn>3</mn></msup></mfrac><mo stretchy="false">)</mo><mo>+</mo><mn>3</mn><mi>N</mi></mrow><annotation encoding="application/x-tex">= 2^2 \times (2 \times T(\frac{N}{8}) + \frac{N}{4}) + 2N = 2^3 \times T(\frac{N}{2^3}) + 3N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">= ...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.10556em;vertical-align:0em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><msup><mn>2</mn><mi>k</mi></msup><mo>×</mo><mi>T</mi><mo stretchy="false">(</mo><mfrac><mi>N</mi><msup><mn>2</mn><mi>k</mi></msup></mfrac><mo stretchy="false">)</mo><mo>+</mo><mi>k</mi><mo>×</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">= 2^k \times T(\frac{N}{2^k}) + k \times N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.2297509999999998em;vertical-align:-0.3574199999999999em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.64258em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7820285714285713em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3574199999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></p>
<p>利用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">k = logN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>，可以得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>=</mo><mi>N</mi><mo>×</mo><mi>T</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>×</mo><mi>N</mi><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo>×</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(N) = N \times T(1) + log(N) \times N = O(N \times logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p>
<h2 id="排序效率分析">排序效率分析</h2>
<p>虽然归并排序的运行时间是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo>×</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N \times logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，但它很难用于主存排序，主要问题在于：</p>
<ol>
<li>合并两个排序的表需要线性附加内存；</li>
<li>在整个算法中还要花费时间将数据拷贝到临时数组，再拷贝回原始数组的一些附加工作，其结果严重放慢了排序的速度。</li>
</ol>
<p>参考资料：<a href="https://awesome-programming-books.github.io/algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9AC%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89.pdf">数据结构与算法分析：C 语言描述（第 2 版）</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法之快速排序</title>
    <url>/posts/231108163339.html</url>
    <content><![CDATA[<p>快速排序是一种常用的排序算法，它基于分治的思想，通过将数组划分为较小的子数组，然后递归地排序这些子数组来达到排序整个数组的目的。</p>
<p>快速排序的基本思想是从数组中选择一个基准元素，然后通过一趟排序将数组分成两部分，以基准元素为轴，使得左边的元素都小于等于基准元素，右边的元素都大于基准元素。然后对这两部分分别进行递归排序，最终将整个数组排序。</p>
<span id="more"></span>
<h2 id="快速排序步骤">快速排序步骤</h2>
<p>快速排序具体步骤如下：</p>
<ol>
<li>选择一个基准元素 <code>pivot</code>，可以是数组的第一个元素或最后一个元素；</li>
<li>设置两个指针，一个指向数组的起始位置 <code>left</code>，一个指向数组的结束位置 <code>right</code>；</li>
<li>从 <code>left</code> 指针开始向右遍历，找到下一个大于 <code>pivot</code> 的元素，记其索引为 <code>i</code>；</li>
<li>从 <code>right</code> 指针开始向左遍历，找到下一个小于等于 <code>pivot</code> 的元素，记其索引为 <code>j</code>；</li>
<li>如果 <code>i&lt;j</code>，交换 <code>i</code> 和 <code>j</code> 处的元素；</li>
<li>重复步骤 3-5，直到 <code>left</code> 指针和 <code>right</code> 指针相遇；</li>
<li>将基准元素 <code>pivot</code> 与指针相遇处的元素交换。</li>
<li>递归地对基准元素左边的子数组和右边的子数组进行快速排序。</li>
</ol>
<h2 id="快速排序复杂度">快速排序复杂度</h2>
<p>快速排序的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为数组的长度。它是一种 <strong> 原地排序算法，不需要额外的存储空间</strong>，但是在最坏情况下可能会出现时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的情况，需要进行优化。</p>
<h2 id="快速排序实现">快速排序实现</h2>
<h3 id="交换两个元素">交换两个元素</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="划分数组为两部分">划分数组为两部分</h3>
<p>通过一趟排序将数组分成两部分，以基准元素为轴，使得左边的元素都小于等于基准元素，右边的元素都大于基准元素，最后返回基准元素在数组中的索引。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[left];</span><br><span class="line">    <span class="type">int</span> i = left + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到下一个大于 pivot 的元素</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j &amp;&amp; arr[i] &lt;= pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到下一个小于等于 pivot 的元素</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= i &amp;&amp; arr[j] &gt; pivot) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不是在对方遍历过的区间找到的, 就交换并自增自减指针</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            swap(&amp;arr[i++], &amp;arr[j--]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(&amp;arr[left], &amp;arr[j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的倒数第二行代码中，为什么基准元素是与索引为 <code>j</code> 的元素进行交换呢？</p>
<p>这是因为，我们选择了区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo separator="true">,</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[left, right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mclose">]</span></span></span></span> 的 <strong> 左边界 </strong> 的元素作为了基准元素。划分后，<strong>左边都是小于等于基准元素的元素</strong>，而索引 <code>j</code> 右边都是大于基准元素的元素，所以基准元素是与索引为 <code>j</code> 的元素进行交换。</p>
<p>同样地，如果我们选择区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo separator="true">,</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[left, right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mclose">]</span></span></span></span> 右边界的元素作为了基准元素，那么代码就该这样写了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> pivot = arr[right];</span><br><span class="line"><span class="type">int</span> i = left;</span><br><span class="line"><span class="type">int</span> j = right - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">swap(&amp;arr[right], &amp;arr[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> i;</span><br></pre></td></tr></table></figure>
<h3 id="递归实现快速排序">递归实现快速排序</h3>
<p>递归地对基准元素左边的子数组和右边的子数组进行快速排序。快速排序接口的入参为 <code>left=0</code> 和 <code>right=n-1</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> pivot = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, pivot - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, pivot + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序测试">快速排序测试</h2>
<h3 id="快速排序代码">快速排序代码</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[left];</span><br><span class="line">    <span class="type">int</span> i = left + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到下一个大于 pivot 的元素</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j &amp;&amp; arr[i] &lt;= pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到下一个小于等于 pivot 的元素</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= i &amp;&amp; arr[j] &gt; pivot) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不是在对方遍历过的区间找到的, 就交换并自增自减指针</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            swap(&amp;arr[i++], &amp;arr[j--]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(&amp;arr[left], &amp;arr[j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> pivot = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, pivot - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, pivot + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序测试代码">快速排序测试代码</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    quickSort(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After quickSort: &quot;</span>);</span><br><span class="line">    printArray(arr, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试结果">测试结果</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">After quickSort: 1 1 2 3 3 4 5 5 5 6 9</span><br></pre></td></tr></table></figure>
<h2 id="进阶 1：基准元素的选择">进阶 1：基准元素的选择</h2>
<h3 id="首尾基准元素">首尾基准元素</h3>
<p>上文说，基准元素可以是「数组的第一个元素或最后一个元素」，这其实是非常不可取的，<strong>在某些情况下可能导致最差的性能</strong>。因为：</p>
<ol>
<li>假如，初始数组就已经是一个升序数组：我们每次都选择第一元素作为基准元素，那么右指针 <code>j</code> 会向左遍历整个数组，但不会进行任何交换操作。这一轮划分操作的时间复杂度为 <code>O(n)</code>，整个排序过程的时间复杂度为 <code>O(n^2)</code>。</li>
<li>同样地，初始数组就已经是一个降序数组：我们每次都选择最后一个元素作为基准元素，那么左指针 <code>i</code> 会向右遍历整个数组，但不会进行任何交换操作。这一轮划分操作的时间复杂度为 <code>O(n)</code>，整个排序过程的时间复杂度为 <code>O(n^2)</code>。</li>
</ol>
<h3 id="随机基准元素">随机基准元素</h3>
<p>随机基准元素，避免了上述问题，可谓是一种再好不过的基准元素的选择办法。但是，<strong>随机数的产生是有时间成本的，不一定会使得快速排序的更快</strong>。</p>
<h3 id="三数中值基准元素">三数中值基准元素</h3>
<p><strong>三数中值是一种常用的基准元素选择方式 </strong>。它通过比较数组的第一个、中间和最后一个元素，<strong> 选择它们的中位数作为基准元素</strong>。这种方式可以在一定程度上避免最差情况的发生，并提高算法的性能。</p>
<p>如何选出三数的中位数在数组中的对应索引呢？多轮比较！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getMedianIdx</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> min = (arr[left] &lt; arr[mid]) ? left : mid;</span><br><span class="line">    min = (arr[min] &lt; arr[right]) ? min : right;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max = (arr[left] &gt; arr[mid]) ? left : mid;</span><br><span class="line">    max = (arr[max] &gt; arr[right]) ? max : right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (min == left) &#123;</span><br><span class="line">        <span class="keyword">return</span> max == right ? mid : right;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (min == right) &#123;</span><br><span class="line">        <span class="keyword">return</span> max == left ? mid : left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> max == right ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进阶 2：何时停止进行交换">进阶 2：何时停止进行交换</h2>
<p>上文的划分代码中，当左指针等于基准元素的时候并没有停止（<code>while (i &lt;= j &amp;&amp; arr[i] &lt;= pivot) &#123;i++;&#125;</code>），当右指针等于基准元素的时候却停止了（<code>while (j &gt;= i &amp;&amp; arr[j] &gt; pivot) &#123;j--;&#125;</code>）。那么左、右指针是否应该停止呢？</p>
<p>假设，未排序的初始数组的所有元素都相同，那么试想一下左、右指针指向的元素等于基准元素时的情况：</p>
<ol>
<li><strong>左、右指针都不停止</strong>：那么先执行 <code>while</code> 循环的那个指针会一直移动，直到与另一个指针相遇（另一个指针一步也没移动）。这一轮移动划分的时间复杂度为 <code>O(n)</code>，最后基准元素的位置还是在某一侧。下一次移动还是同样的情况，每次划分的数组的长度都是减少 1（另一个数组长度为 0）。整个排序过程的时间复杂度为 <code>O(n^2)</code>。</li>
<li><strong>左、右指针都停止</strong>：那么两个指针会交换着各自指向的元素，来到数组中间，并将基准元素放在中间，结束本轮划分。下次划分时，左右子数组的长度都会减半。整个排序过程的时间复杂度为 <code>O(nlogn)</code>。</li>
<li><strong>一个指针不停止、一个指针停止</strong>：等价于「左、右指针都不停止」的情况，因为情况 1 中，另一个指针就没有机会移动（就相当于停止啊）。</li>
</ol>
<p>综上，<strong>当指针指向的元素等于基准元素时，应该停止</strong>。</p>
<h2 id="优化后的快速排序代码">优化后的快速排序代码</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 arr[left], arr[mid], arr[right] 三数中值的索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getMedianIdx</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> min = (arr[left] &lt; arr[mid]) ? left : mid;</span><br><span class="line">    min = (arr[min] &lt; arr[right]) ? min : right;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max = (arr[left] &gt; arr[mid]) ? left : mid;</span><br><span class="line">    max = (arr[max] &gt; arr[right]) ? max : right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (min == left) &#123;</span><br><span class="line">        <span class="keyword">return</span> max == right ? mid : right;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (min == right) &#123;</span><br><span class="line">        <span class="keyword">return</span> max == left ? mid : left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> max == right ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 将选中的基准元素与数组末尾元素交换,  并指定基准元素为「数组末尾元素」</span></span><br><span class="line">    <span class="type">int</span> pivotIdx = getMedianIdx(arr, left, right);</span><br><span class="line">    swap(&amp;arr[right], &amp;arr[pivotIdx]);</span><br><span class="line">    <span class="type">int</span> pivot = arr[right];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = left, j = right - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j &amp;&amp; arr[i] &lt; pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= i &amp;&amp; arr[j] &gt; pivot) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            swap(&amp;arr[i++], &amp;arr[j--]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(&amp;arr[right], &amp;arr[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> pivot = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, pivot - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, pivot + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最后留一个问题：快速排序为什么叫「快速」排序？</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title>模运算（求余运算）</title>
    <url>/posts/231010144856.html</url>
    <content><![CDATA[<p>两数相加、两数相乘怎么求余数，负数求余数到底等于多少，如何高效求余数？这篇文章将记录这些知识，方便后续查阅。</p>
<span id="more"></span>
<h2 id="正数求余">正数求余</h2>
<p>自然数对正数求余是指将一个自然数除以另一个正整数后得到的余数。</p>
<p>例如，对于自然数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> 和正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>，求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">a/m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord">/</span><span class="mord mathnormal">m</span></span></span></span> 的余数，可以用符号「%」表示，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi mathvariant="normal">%</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">a \% m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord mathnormal">a</span><span class="mord">%</span><span class="mord mathnormal">m</span></span></span></span>。</p>
<p>假设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mi>k</mi><mi>m</mi><mo>+</mo><mi>r</mi><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>a</mi><mo>&gt;</mo><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>m</mi><mo>&gt;</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a=km+r, (a&gt;=0, m&gt;0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">a/m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord">/</span><span class="mord mathnormal">m</span></span></span></span> 等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>k</mi><mo>&gt;</mo><mo>=</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k, (k&gt;=0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi mathvariant="normal">%</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">a \% m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord mathnormal">a</span><span class="mord">%</span><span class="mord mathnormal">m</span></span></span></span> 等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>0</mn><mo>&lt;</mo><mo>=</mo><mi>r</mi><mo>&lt;</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r, (0&lt;=r&lt;m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>。</p>
<h2 id="两数相加求余">两数相加求余</h2>
<p>结论：一般地，两个整数相加后求余数，有如下等式：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>m</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>=</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>m</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>b</mi><mi mathvariant="normal">%</mi><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>m</mi></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}
(a + b) \% m \\ 
= ((a \% m) + (b \% m)) \% m \\ 
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathnormal">m</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord">%</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mord">%</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathnormal">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>证明：根据 <strong> 带余除法</strong>，任意整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> 都可以表示为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mi>k</mi><mi>m</mi><mo>+</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">a=km+r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>，这里 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 相当于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi mathvariant="normal">%</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">a \% m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord mathnormal">a</span><span class="mord">%</span><span class="mord mathnormal">m</span></span></span></span>。那么设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><msub><mi>k</mi><mn>1</mn></msub><mi>m</mi><mo>+</mo><msub><mi>r</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>b</mi><mo>=</mo><msub><mi>k</mi><mn>2</mn></msub><mi>m</mi><mo>+</mo><msub><mi>r</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">a=k_{1}m+r_{1}, b=k_{2}m+r_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则有</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>m</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>=</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><msub><mi>k</mi><mn>1</mn></msub><mo>+</mo><msub><mi>k</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mi>m</mi><mo>+</mo><msub><mi>r</mi><mn>1</mn></msub><mo>+</mo><msub><mi>r</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>m</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>=</mo><mo stretchy="false">(</mo><msub><mi>r</mi><mn>1</mn></msub><mo>+</mo><msub><mi>r</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>m</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>=</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>m</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>b</mi><mi mathvariant="normal">%</mi><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>m</mi></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}
(a + b) \% m \\ 
= ((k_{1} + k_{2})m + r_{1} + r_{2}) \% m \\ 
= (r_{1} + r_{2}) \% m \\ 
= ((a \% m) + (b \% m)) \% m \\ 
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.76em;vertical-align:-2.63em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9500200000000008em;"><span style="top:-1.59999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-1.5949900000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-1.8899900000000003em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.1849900000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.2049900000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.1500100000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.29501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.59001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.885010000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.905010000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-5.20002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.1300000000000003em;"><span style="top:-5.130000000000001em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathnormal">m</span></span></span><span style="top:-3.6900000000000004em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathnormal">m</span></span></span><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathnormal">m</span></span></span><span style="top:-0.8100000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord">%</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mord">%</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathnormal">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.63em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>证毕。</p>
<h2 id="两数相乘求余">两数相乘求余</h2>
<p>结论：一般地，两个整数相乘后求余数，有如下等式：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>×</mo><mi>b</mi><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>m</mi><mo>=</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>m</mi><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mi>b</mi><mi mathvariant="normal">%</mi><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">(a \times b) \% m = ((a \% m) \times (b \% m)) \% m
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord">%</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mord">%</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathnormal">m</span></span></span></span></span></p>
<p>证明：根据 <strong> 带余除法</strong>，任意整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> 都可以表示为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mi>k</mi><mi>m</mi><mo>+</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">a=km+r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>，这里 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 相当于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi mathvariant="normal">%</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">a \% m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord mathnormal">a</span><span class="mord">%</span><span class="mord mathnormal">m</span></span></span></span>。那么设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><msub><mi>k</mi><mn>1</mn></msub><mi>m</mi><mo>+</mo><msub><mi>r</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>b</mi><mo>=</mo><msub><mi>k</mi><mn>2</mn></msub><mi>m</mi><mo>+</mo><msub><mi>r</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">a=k_{1}m+r_{1}, b=k_{2}m+r_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则有</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>×</mo><mi>b</mi><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>m</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>=</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><msub><mi>k</mi><mn>1</mn></msub><msub><mi>k</mi><mn>2</mn></msub><mo stretchy="false">)</mo><msup><mi>m</mi><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><msub><mi>k</mi><mn>1</mn></msub><msub><mi>r</mi><mn>2</mn></msub><mo>+</mo><msub><mi>k</mi><mn>2</mn></msub><msub><mi>r</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mi>m</mi><mo>+</mo><msub><mi>r</mi><mn>1</mn></msub><msub><mi>r</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>m</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>=</mo><mo stretchy="false">(</mo><msub><mi>r</mi><mn>1</mn></msub><msub><mi>r</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>m</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>=</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>m</mi><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mi>b</mi><mi mathvariant="normal">%</mi><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>m</mi></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}
(a \times b) \% m \\ 
= ((k_{1}k_{2})m^{2} + (k_{1}r_{2} + k_{2}r_{1})m + r_{1}r_{2}) \% m \\ 
= (r_{1}r_{2}) \% m \\ 
= ((a \% m) \times (b \% m)) \% m \\ 
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.76em;vertical-align:-2.63em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9500200000000008em;"><span style="top:-1.59999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-1.5949900000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-1.8899900000000003em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.1849900000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.2049900000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.1500100000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.29501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.59001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.885010000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.905010000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-5.20002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.1300000000000003em;"><span style="top:-5.130000000000001em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathnormal">m</span></span></span><span style="top:-3.6900000000000004em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathnormal">m</span></span></span><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathnormal">m</span></span></span><span style="top:-0.8100000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord">%</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mord">%</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathnormal">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.63em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>证毕。</p>
<h2 id="负数求余">负数求余</h2>
<h3 id="不同语言的负数求余">不同语言的负数求余</h3>
<ol>
<li>一个负数对一个正数求余数：</li>
</ol>
<ul>
<li>C、C++ 和 Java 的结果是商尽可能大（在坐标轴上尽可能靠右），余数的正负号与被除数的正负号保持一致，即为负数。</li>
<li>Python、Google 计算器和百度计算器的结果是商尽可能小（在坐标轴上尽可能靠左），余数的正负号与除数的正负号保持一致，为正数。</li>
</ul>
<table>
<thead>
<tr>
<th>语言</th>
<th>语句</th>
<th>输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>C/C++</td>
<td><code>cout &lt;&lt; (-7) % 3;</code></td>
<td>-1</td>
</tr>
<tr>
<td>Java（1.6）</td>
<td><code>System.out.println((-7) % 3);</code></td>
<td>-1</td>
</tr>
<tr>
<td>Python 2.6</td>
<td><code>(-7) % 3</code></td>
<td>2</td>
</tr>
<tr>
<td>百度计算器</td>
<td><code>(-7) mod 3</code></td>
<td>2</td>
</tr>
<tr>
<td>Google 计算器</td>
<td><code>(-7) mod 3</code></td>
<td>2</td>
</tr>
</tbody>
</table>
<ol start="2">
<li>一个正数对一个负数求余数：</li>
</ol>
<ul>
<li>C、C++ 和 Java 的结果是商尽可能大（在坐标轴上尽可能靠右），余数的正负号与被除数的正负号保持一致，即为正数。</li>
<li>Python、Google 计算器和百度计算器的结果是商尽可能小（在坐标轴上尽可能靠左），余数的正负号与除数的正负号保持一致，为负数。</li>
</ul>
<table>
<thead>
<tr>
<th>语言</th>
<th>语句</th>
<th>输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>C/C++</td>
<td><code>cout &lt;&lt; 7 % (-3);</code></td>
<td>1</td>
</tr>
<tr>
<td>Java (1.6)</td>
<td><code>System.out.println(7 % (-3));</code></td>
<td>1</td>
</tr>
<tr>
<td>Python 2.6</td>
<td><code>7 % (-3)</code></td>
<td>-2</td>
</tr>
<tr>
<td>百度计算器</td>
<td><code>7 mod (-3)</code></td>
<td>-2</td>
</tr>
<tr>
<td>Google 计算器</td>
<td><code>7 mod (-3)</code></td>
<td>-2</td>
</tr>
</tbody>
</table>
<ol start="3">
<li>一个负数对一个负数求余数：</li>
</ol>
<ul>
<li>C、C++ 和 Java 以及 Python、Google 计算器和百度计算器的结果都是商尽可能小（在坐标轴上尽可能靠左），余数为负数。</li>
</ul>
<table>
<thead>
<tr>
<th>语言</th>
<th>语句</th>
<th>输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>C/C++</td>
<td><code>cout &lt;&lt; -7 % (-3);</code></td>
<td>-1</td>
</tr>
<tr>
<td>Java (1.6)</td>
<td><code>System.out.println(-7 % (-3));</code></td>
<td>-1</td>
</tr>
<tr>
<td>Python 2.6</td>
<td><code>-7 % (-3)</code></td>
<td>-1</td>
</tr>
<tr>
<td>百度计算器</td>
<td><code>-7 mod (-3)</code></td>
<td>-1</td>
</tr>
<tr>
<td>Google 计算器</td>
<td><code>-7 mod (-3)</code></td>
<td>-1</td>
</tr>
</tbody>
</table>
<h3 id="总结">总结</h3>
<ol>
<li>在被除数与除数 <strong> 正负号相同时 </strong>，所有语言<strong> 都期望商尽可能小 </strong>（<s> 余数的正负号与被除数、除数的正负号一致</s>）。</li>
<li>在被除数与除数 <strong> 正负号相反时</strong>：</li>
</ol>
<ul>
<li>对于 C、C++ 和 Java，<strong>期望商尽可能大 </strong>（<s> 余数的正负号与 <strong> 被除数 </strong> 的正负号保持一致</s>）；</li>
<li>对于 Python、Google 计算器和百度计算器，<strong>还是期望商尽可能小 </strong>（<s> 余数的正负号与 <strong> 除数 </strong> 的正负号保持一致</s>）。</li>
</ul>
<h2 id="位运算求余数">位运算求余数</h2>
<p>对于自然数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> 和正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>，在某些情况下，当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">m=2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> 时，有如下替换公式：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>a</mi><mi mathvariant="normal">%</mi><mi>m</mi><mo>=</mo><mi>a</mi><mi mathvariant="normal">&amp;</mi><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a \% m = a \&amp; (m - 1)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord mathnormal">a</span><span class="mord">%</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord">&amp;</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
<p>即:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>a</mi><mi mathvariant="normal">%</mi><msup><mn>2</mn><mi>n</mi></msup><mo>=</mo><mi>a</mi><mi mathvariant="normal">&amp;</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a \% 2^{n} = a \&amp; (2^{n} - 1)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord mathnormal">a</span><span class="mord">%</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord">&amp;</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
<p>希望这次看起来更清晰了！</p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://leetcode.cn/problems/movement-of-robots/solutions/2304680/nao-jin-ji-zhuan-wan-pai-xu-tong-ji-pyth-we55/?envType=daily-question&amp;envId=2023-10-10">灵茶山艾府 Leetcode2731 移动机器人题解</a></li>
<li><a href="http://ceeji.net/blog/mod-in-real/">实数范围内的求模（求余）运算：负数求余究竟怎么求</a></li>
<li><a href="https://blog.csdn.net/lonyw/article/details/80519652">使用位操作（&amp; 运算）代替求余操作</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>模运算</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程之 checksum 计算</title>
    <url>/posts/240903191243.html</url>
    <content><![CDATA[<p>本文讲解如何计算报文头部的 checksum。</p>
<span id="more"></span>
<h1 id="UDP-checksum 计算">UDP checksum 计算</h1>
<h2 id="计算方法">计算方法</h2>
<p>关于传输层 UDP 头部的介绍可以查看 <a href="/posts/240329202002.html#UDP-%20%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F"> 这里</a>。</p>
<p>如何计算 UDP 的 checksum 值？</p>
<ol>
<li><strong>创建伪头部（对于 IPv4 报文，占 12 字节）</strong>：把伪头部添加到 UDP 头部前面。</li>
<li><strong>准备 UDP 头部（8 字节）</strong>：计算前将头部的 checksum 字段 <strong> 清零</strong>。</li>
<li><strong>将 UDP 头部和数据扩展到偶数字节的总长度</strong>：一般 UDP 头部字节数为偶数，如果 UDP 数据部分的长度为奇数，则需要在末尾“添加”一个字节的填充值（通常为 0），以确保总长度为偶数。注意，不需要修改 UDP 头部中的长度字段的值。</li>
<li>计算 checksum：
<ul>
<li>把所有字段（伪头部、UDP 头部和数据）看作是（划分为）按顺序排列的 16 位字（2 字节），如果数据长度为奇数，补充的一个 0 字节（在报文地址的最高位）也需要包含在内。</li>
<li><strong>将所有 16 位字相加，如果有进位（超过 16 位），则将进位加回到最低有效位</strong>。</li>
<li><strong>对结果按位取反，得到最终的 checksum 值</strong>。</li>
</ul>
</li>
</ol>
<blockquote>
<p>如果按位取反后的结果为 0，则需要将 checksum 设置为 0xFFFF，这是一种特殊情况，用于表示 checksum 为 0。因为，若发送方不愿意计算 checksum，它可以将 checksum 字段设置为 0x0000。接收方在接收这样的包时，会按照协议规定，忽略该包的 checksum 的验证。</p>
</blockquote>
<h2 id="实现">实现</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Macro to handle carry when sum exceeds 16 bits</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_CARRY_OVERFLOW</span></span><br><span class="line"><span class="comment">// Macro to handle carry when the highest bit is set</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_CARRY_HIGHEST_BIT</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* UDP 伪头部 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pseudo_header</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">src_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">dst_addr</span>;</span></span><br><span class="line">    <span class="type">uint8_t</span> reserved;  <span class="comment">// 保留，设置为 0</span></span><br><span class="line">    <span class="type">uint8_t</span> protocol;  <span class="comment">// 协议号，UDP 为 17</span></span><br><span class="line">    <span class="type">uint16_t</span> length;   <span class="comment">// UDP 长度（头部 + 数据）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* UDP 头部 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">udp_header</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> src_port;</span><br><span class="line">    <span class="type">uint16_t</span> dst_port;</span><br><span class="line">    <span class="type">uint16_t</span> length;    <span class="comment">// UDP 长度（头部 + 数据）</span></span><br><span class="line">    <span class="type">uint16_t</span> checksum;  <span class="comment">// UDP 校验和</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">calc_checksum</span><span class="params">(<span class="type">void</span>* data, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> sum = <span class="number">0</span>;  <span class="comment">// 由于累加过程中可能会产生超过 16 位的数值，因此用 uint32 存储中间结果</span></span><br><span class="line">    <span class="type">uint16_t</span>* ptr = (<span class="type">uint16_t</span>*)data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        sum += *ptr;  <span class="comment">// 将所有 16 位字相加</span></span><br><span class="line">        ptr++;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HANDLE_CARRY_OVERFLOW</span></span><br><span class="line">        <span class="comment">/* 若大于 0xffff，则立即处理进位 */</span></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; <span class="number">0xffff</span>) &#123;</span><br><span class="line">            sum = (sum &amp; <span class="number">0xffff</span>) + (sum &gt;&gt; <span class="number">16</span>);  <span class="comment">// 将进位加回最低有效位</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="comment">/* 若 uint32 的最高位为 1，为了防止下次累加时溢出，通过进位操作来处理 */</span></span><br><span class="line">        <span class="keyword">if</span> (sum &amp; <span class="number">0x80000000</span>) &#123;</span><br><span class="line">            sum = (sum &amp; <span class="number">0xffff</span>) + (sum &gt;&gt; <span class="number">16</span>);  <span class="comment">// 将进位加回最低有效位</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        length -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 处理剩余数据长度为 1 的情况：在末尾（高地址）添加一个字节的填充值 -&gt; 0x00**，也就是 0x** */</span></span><br><span class="line">    <span class="keyword">if</span> (length) &#123;</span><br><span class="line">        sum += *((<span class="type">uint8_t</span>*)ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果非最低 16bits 有数据，即有进位 */</span></span><br><span class="line">    <span class="keyword">while</span> (sum &gt;&gt; <span class="number">16</span>) &#123;</span><br><span class="line">        sum = (sum &amp; <span class="number">0xffff</span>) + (sum &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint16_t</span>)(~sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">src_addr</span>, <span class="title">dst_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    (<span class="type">void</span>)inet_aton(<span class="string">&quot;10.20.111.10&quot;</span>, &amp;src_addr);</span><br><span class="line">    (<span class="type">void</span>)inet_aton(<span class="string">&quot;10.20.11.11&quot;</span>, &amp;dst_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> data[] = &#123;<span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x56</span>, <span class="number">0x78</span>, <span class="number">0x9a</span>, <span class="number">0xbc</span>, <span class="number">0xde</span>, <span class="number">0xf0</span>, <span class="number">0xf1</span>, <span class="number">0xf2</span>, <span class="number">0xf3</span>&#125;;  <span class="comment">// 13 bytes of data</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">udp_header</span> <span class="title">udp</span>;</span></span><br><span class="line">    udp.src_port = htons(<span class="number">0xaaaa</span>);</span><br><span class="line">    udp.dst_port = htons(<span class="number">0xbbbb</span>);</span><br><span class="line">    udp.length = htons(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> udp_header) + <span class="keyword">sizeof</span>(data));</span><br><span class="line">    udp.checksum = <span class="number">0</span>;  <span class="comment">// Initial value</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pseudo_header</span> <span class="title">pseudo</span>;</span></span><br><span class="line">    pseudo.src_addr = src_addr;</span><br><span class="line">    pseudo.dst_addr = dst_addr;</span><br><span class="line">    pseudo.reserved = <span class="number">0</span>;</span><br><span class="line">    pseudo.protocol = IPPROTO_UDP;</span><br><span class="line">    pseudo.length = udp.length;  <span class="comment">// 伪头部的长度即位头部中的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Combine pseudo header, UDP header and data for checksum calculation</span></span><br><span class="line">    <span class="type">uint8_t</span> buffer[<span class="keyword">sizeof</span>(<span class="keyword">struct</span> pseudo_header) + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> udp_header) + <span class="keyword">sizeof</span>(data)];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(buffer, &amp;pseudo, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pseudo_header));</span><br><span class="line">    <span class="built_in">memcpy</span>(buffer + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pseudo_header), &amp;udp, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> udp_header));</span><br><span class="line">    <span class="built_in">memcpy</span>(buffer + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pseudo_header) + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> udp_header), data, <span class="keyword">sizeof</span>(data));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate checksum</span></span><br><span class="line">    udp.checksum = calc_checksum(buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;UDP Checksum: 0x%4X\n&quot;</span>, ntohs(udp.checksum)); <span class="comment">// 0x43D7</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，有 HANDLE_CARRY_OVERFLOW 和 HANDLE_CARRY_HIGHEST_BIT 两种处理进位的逻辑，这是怎么回事？</p>
<p>在网络协议实现中，尤其是校验和计算时，有些实现会在特定条件下进行进位处理（如最高位为 1 时），而有些实现则会在累计和超过 16 位时进行处理（如 sum &gt; 0xFFFF 时）。</p>
<p>最高位为 1（0x80000000）的处理：</p>
<p>这种处理方式是在累加过程中，立即检测是否出现了可能的溢出情况（累加值达到或超过 2^31）。<strong>这是为了在处理大数据包时，避免过早处理进位</strong>。虽然这种方式在实现上较为简单直接，但在一般的 UDP/TCP 校验和计算中，不如传统的进位处理方式常见。</p>
<p>累计和超过 16 位（sum &gt; 0xFFFF）的处理：</p>
<p>这种处理方式更符合大多数校验和算法（如互联网校验和）的习惯：每次累加之后，立即检查总和是否超过 16 位。如果超过 16 位（即高于 0xFFFF），则将高位进位添加到低位部分，符合循环进位的概念。该方法确保每次累加后的数值都保持在 16 位以内，从而 <strong> 避免逐字节累加大数值时可能出现的溢出情况</strong>。</p>
<h2 id="增量计算方法">增量计算方法</h2>
<p>在网络设备中，通常会修改某些字段，而这些字段一般只有几个字节（如源 IP、源 PORT），如果再次通过遍历完整的头部、数据部分重新计算 checksum，效率不高。通过比较修改的几个字节，进行增量计算 checksum，更高效。下面的代码是 RFC1624 中给出了计算方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 通过原 checksum 和修改前后的 uint16 值计算新的 checksum</span></span><br><span class="line"><span class="comment"> * 注意：入参都是网络序、返回值也是网络序</span></span><br><span class="line"><span class="comment"> * 修改前后的 uint16 值是报文中的偶数字节与后面的奇数字节，不能是奇数字节与后面的偶数字节</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">update_checksum</span><span class="params">(<span class="type">uint16_t</span> cur_cksum, <span class="type">uint16_t</span> old_val, <span class="type">uint16_t</span> new_val)</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RFC1624_EFFICIENT_CHECKSUM</span></span><br><span class="line">    <span class="type">uint32_t</span> new_cksum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (old_val == new_val) &#123;</span><br><span class="line">        <span class="keyword">return</span> cur_cksum;</span><br><span class="line">    &#125;</span><br><span class="line">    cur_cksum = ntohs(cur_cksum);</span><br><span class="line">    old_val = ntohs(old_val);</span><br><span class="line">    new_val = ntohs(new_val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 根据 RFC1624, new_cksum = (~cur_cksum) + (~old_val) + new_val */</span></span><br><span class="line">    new_cksum = ((~cur_cksum) &amp; <span class="number">0xffff</span>) + ((~old_val) &amp; <span class="number">0xffff</span>) + new_val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 计算后可能有进位，需要处理，处理完后次处理潜在的进位 */</span></span><br><span class="line">    new_cksum = (new_cksum &amp; <span class="number">0xffff</span>) + (new_cksum &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    new_cksum += (new_cksum &gt;&gt; <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint16_t</span>)(~new_cksum);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">int32_t</span> new_cksum = <span class="number">0</span>;  <span class="comment">// 有符号数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (old_val == new_val) &#123;</span><br><span class="line">        <span class="keyword">return</span> cur_cksum;</span><br><span class="line">    &#125;</span><br><span class="line">    cur_cksum = ntohs(cur_cksum);</span><br><span class="line">    old_val = ntohs(old_val);</span><br><span class="line">    new_val = ntohs(new_val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 根据 RFC1624, new_cksum = cur_cksum - (~old_val) - new_val，更高效 */</span></span><br><span class="line">    new_cksum = (cur_cksum &amp; <span class="number">0xffff</span>) - ((~old_val) &amp; <span class="number">0xffff</span>) - new_val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若减出负值，如 new_cksum=0xffff35d6，则处理完后的 checksum 应为 0x35d5 */</span></span><br><span class="line">    new_cksum = (new_cksum &amp; <span class="number">0xffff</span>) + (new_cksum &gt;&gt; <span class="number">16</span>);  <span class="comment">// 算术右移</span></span><br><span class="line">    new_cksum += (new_cksum &gt;&gt; <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint16_t</span>)(new_cksum);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">uint16_t</span> cksum = update_checksum(<span class="number">0x43D7</span>, <span class="number">0xf1f2</span>, <span class="number">0xe0e3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;UDP Checksum: 0x%4X\n&quot;</span>, ntohs(cksum));  <span class="comment">// 0x54E6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于右移操作，通常需要区分的是算术右移（也称为符号右移）和逻辑右移：</p>
<ul>
<li>算术右移：保留符号位，<strong>右移时高位用符号位填充</strong>。例如，负数右移后仍然是负数。</li>
<li>逻辑右移：不保留符号位，<strong>右移时高位用 0 填充</strong>。</li>
</ul>
<p>在 C 语言中，对于有符号类型（比如 int32_t），右移操作通常被实现为算术右移（具体取决于编译器）。对于无符号类型（比如 uint32_t），右移操作是逻辑右移。</p>
<h1 id="TCP-checksum 计算">TCP checksum 计算</h1>
<p>TCP 和 UDP 的 checksum 计算方式基本相同。TCP checksum 计算 <strong> 涉及到 TCP 伪头部、TCP 头部和 TCP 数据三部分</strong>。TCP 伪头部的构成与 UDP 伪头部的构成完全一致，只是填充的成员值不同，如 TCP 的 protocol=6、UDP 的 protocol=17。</p>
<h1 id="IPv4-checksum 计算">IPv4 checksum 计算</h1>
<p>IPv4 的 checksum 计算方法与 TCP 和 UDP 的 checksum 计算方式相似，不同之处在于：IPv4 仅使用 IPv4 头部计算 checksum、不使用数据部分。</p>
<p>不管是 TCP、UDP 还是 IPv4，在计算其 checksum 前，都需要将头部中的原 checksum 字段清零。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机中的寄存器</title>
    <url>/posts/231210181853.html</url>
    <content><![CDATA[<p>在计算机中，寄存器是一种 <strong> 小型而快速的存储器件 </strong>，用于存储处理器需要<strong> 快速访问 </strong> 的数据。它们是计算机体系结构中的关键组成部分，对于计算机的性能和功能至关重要。</p>
<blockquote>
<p>计算机体系结构：CPU + 内存 + 外设。其中，CPU 内部包括控制器、寄存器、cache 和 MMU 等。</p>
</blockquote>
<span id="more"></span>
<h1 id="什么是寄存器？">什么是寄存器？</h1>
<p>在计算机中，寄存器是一种 <strong> 小型而快速的存储器件 </strong>，用于存储处理器需要<strong> 快速访问 </strong> 的数据。它们是计算机体系结构中的一部分，<strong>通常被集成在处理器芯片中</strong>。寄存器是计算机中最快的存储器件之一，它们的访问速度比主存储器和辅助存储器要快得多。</p>
<p><strong>寄存器通常被用于存储处理器需要快速访问的数据</strong>，如程序计数器、指令寄存器、状态寄存器、通用寄存器等。它们还可以用于存储函数调用时的参数和返回值，以及存储中间计算结果等。</p>
<h1 id="寄存器的作用">寄存器的作用</h1>
<p>寄存器在计算机中有许多重要的作用。以下是其中的一些：</p>
<h2 id="提高计算机的性能">提高计算机的性能</h2>
<p>寄存器是计算机中最快的存储器件之一，它们的访问速度比主存储器和辅助存储器要快得多。因此，<strong>将需要快速访问的数据存储在寄存器中可以大大提高计算机的性能</strong>。</p>
<h2 id="存储处理器需要快速访问的数据">存储处理器需要快速访问的数据</h2>
<p>处理器需要快速访问的数据通常存储在寄存器中，如程序计数器、指令寄存器、状态寄存器、通用寄存器等。这些数据对于处理器的运行至关重要，因此它们需要快速访问。</p>
<h2 id="存储函数调用时的参数和返回值">存储函数调用时的参数和返回值</h2>
<p>在 <strong> 函数调用时，参数和返回值通常存储在寄存器中 </strong>。这是因为寄存器的访问速度比主存储器要快得多，可以<strong> 提高函数调用的效率</strong>。</p>
<h2 id="存储中间计算结果">存储中间计算结果</h2>
<p>在计算机中，一些中间计算结果需要被存储下来以便后续使用。这些中间计算结果通常存储在寄存器中，因为寄存器的访问速度比主存储器要快得多。</p>
<h1 id="寄存器的种类">寄存器的种类</h1>
<h2 id="程序计数器（PC）">程序计数器（PC）</h2>
<p>程序计数器是一种特殊的寄存器，用于存储下一条要执行的指令的内存地址。当处理器执行程序时，它会不断地从程序计数器中读取指令并执行它们。</p>
<h2 id="指令寄存器（IR）">指令寄存器（IR）</h2>
<p>指令寄存器是一种特殊的寄存器，用于存储当前正在执行的指令。<strong>处理器从指令寄存器中读取指令并执行它们</strong>。</p>
<blockquote>
<p>（个人理解）程序计数器和指令寄存器共同完成对下一条指令的执行。首先，CPU 通过程序计数器获取下一条将要执行的指令的内存地址；然后，CPU 通过这个内存地址，从内存中读取指令数据，并将其二进制表示存储在指令寄存器中；最后，控制器解析并执行指令寄存器中的指令。</p>
</blockquote>
<h2 id="状态寄存器（SR）">状态寄存器（SR）</h2>
<p>状态寄存器是一种特殊的寄存器，用于存储处理器的状态信息。状态寄存器中的不同「位」表示了处理器的不同状态，如进位标志、零标志、负数标志等。</p>
<h2 id="通用寄存器">通用寄存器</h2>
<p>通用寄存器是一种通用的寄存器，<strong>用于存储处理器需要快速访问的数据</strong>。它们可以用于存储函数调用时的参数和返回值，以及存储中间计算结果等。</p>
<h3 id="累加器（ACC）">累加器（ACC）</h3>
<p>累加器是一种比较特殊的通用寄存器，用于存储算术和逻辑操作的结果。</p>
<h3 id="数据寄存器（DR）">数据寄存器（DR）</h3>
<p>数据寄存器是一种通用寄存器，用于存储计算机中的数据。它可以用于暂时存储从内存中读取的数据，或者存储需要写入内存的数据。</p>
<h2 id="地址寄存器（AR）">地址寄存器（AR）</h2>
<p>地址寄存器是一种特殊的寄存器，用于存储内存地址。它通常用于指示将要读取或写入数据的内存位置。</p>
<h2 id="堆栈指针寄存器（SP）">堆栈指针寄存器（SP）</h2>
<p>堆栈指针寄存器是一种特殊的寄存器，用于指示栈顶的位置。栈是一种常用的数据结构，用于存储临时数据、函数调用的参数和返回地址等。</p>
<h2 id="基址寄存器（BR）">基址寄存器（BR）</h2>
<p>基址寄存器是一种特殊的寄存器，用于存储数据段的基地址。它通常与偏移寄存器配合使用，用于计算实际内存地址。</p>
<h2 id="偏移寄存器（OR）">偏移寄存器（OR）</h2>
<p>偏移寄存器是一种特殊的寄存器，用于存储相对于基址的偏移量。它通常与基址寄存器配合使用，用于计算实际内存地址。</p>
<blockquote>
<p>通用寄存器和特殊寄存器的区别：通用寄存器用于存储数据和中间结果，具有灵活的使用方式；而特殊寄存器具有特定的用途，功能固定，不能直接访问或修改其内容。</p>
</blockquote>
<h1 id="寄存器分类总结">寄存器分类总结</h1>
<table>
<thead>
<tr>
<th>寄存器名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>程序计数器（PC）</td>
<td>存储下一条要执行的指令的内存地址</td>
</tr>
<tr>
<td>指令寄存器（IR）</td>
<td>存储当前正在执行的指令</td>
</tr>
<tr>
<td>状态寄存器（SR）</td>
<td>存储计算机的运行状态和控制信息</td>
</tr>
<tr>
<td>累加器（ACC）</td>
<td>存储算术和逻辑操作的结果</td>
</tr>
<tr>
<td>数据寄存器（DR）</td>
<td>存储计算机中的数据</td>
</tr>
<tr>
<td>地址寄存器（AR）</td>
<td>存储内存地址</td>
</tr>
<tr>
<td>堆栈指针寄存器（SP）</td>
<td>指示栈顶位置</td>
</tr>
<tr>
<td>基址寄存器（BR）</td>
<td>存储数据段的基地址</td>
</tr>
<tr>
<td>偏移寄存器（OR）</td>
<td>存储相对于基址的偏移量</td>
</tr>
</tbody>
</table>
<blockquote>
<p>参考资料：<a href="https://blog.csdn.net/weixin_73567058/article/details/130185612">https://blog.csdn.net/weixin_73567058/article/details/130185612</a></p>
</blockquote>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>寄存器</tag>
      </tags>
  </entry>
  <entry>
    <title>计网 CyC2018 之传输层</title>
    <url>/posts/240329202002.html</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="计算机网络 - 传输层">计算机网络 - 传输层</h1>
<!-- GFM-TOC -->
<ul>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E4%BC%A0%E8%BE%93%E5%B1%82">计算机网络 - 传输层</a>
<ul>
<li><a href="#UDP-%20%E5%92%8C%20-TCP-%20%E7%9A%84%E7%89%B9%E7%82%B9">UDP 和 TCP 的特点</a></li>
<li><a href="#UDP-%20%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F">UDP 首部格式</a></li>
<li><a href="#TCP-%20%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F">TCP 首部格式</a></li>
<li><a href="#TCP-%20%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">TCP 的三次握手</a></li>
<li><a href="#TCP-%20%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">TCP 的四次挥手</a></li>
<li><a href="#TCP-%20%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93">TCP 可靠传输</a></li>
<li><a href="#TCP-%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">TCP 滑动窗口</a></li>
<li><a href="#TCP-%20%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">TCP 流量控制</a></li>
<li><a href="#TCP-%20%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">TCP 拥塞控制</a>
<ul>
<li><a href="#1-%20%E6%85%A2%E5%BC%80%E5%A7%8B%E4%B8%8E%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D">1. 慢开始与拥塞避免</a></li>
<li><a href="#2-%20%E5%BF%AB%E9%87%8D%E4%BC%A0%E4%B8%8E%E5%BF%AB%E6%81%A2%E5%A4%8D">2. 快重传与快恢复</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- GFM-TOC -->
<p>网络层只把 <strong> 分组 </strong> 发送到目的主机，但是真正通信的并不是主机而是主机中的进程。</p>
<p>传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</p>
<h2 id="UDP- 和 -TCP- 的特点">UDP 和 TCP 的特点</h2>
<ul>
<li>
<p>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，<strong>面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部）</strong>，支持一对一、一对多、多对一和多对多的交互通信。</p>
</li>
<li>
<p>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，<strong>面向字节流（把应用层传下来的报文看成 <u> 字节流</u>，把字节流组织成大小不等的报文段）</strong>，每一条 TCP 连接只能是点对点的（一对一）。</p>
</li>
</ul>
<blockquote>
<p><strong>何为无连接、何为面向连接</strong>？</p>
<p>UDP 的 <strong> 无连接 </strong> 意味着在通信之前 <strong> 不需要建立连接 </strong>（无需握手），数据包<strong> 可以直接发送 </strong> 给目标地址。<br>
TCP 的 <strong> 面向连接 </strong> 意味着通信双方需要按序 <strong> 建立连接 </strong>（三次握手）、传输数据、<strong> 终止连接</strong>（四次挥手），保证数据的可靠传输。</p>
</blockquote>
<h2 id="UDP- 首部格式">UDP 首部格式</h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d4c3a4a1-0846-46ec-9cc3-eaddfca71254.jpg" width="600"/> </div><br>
<p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的 <strong> 伪首部是为了计算检验和临时添加的</strong>，即在实际的网络传输中，只有 UDP 报文段本身被传输，不包括伪头部。</p>
<p><strong>伪头部的作用：仅仅是为了增加校验的准确性，提高数据传输的可靠性</strong>。在接收端，接收到的数据包中的 checksum 会与计算得到的 checksum 进行比较，以验证数据包的完整性和准确性。</p>
<p>需要注意的是，伪首部中的报文长度与首部中的报文长度字段一致，<strong>均表示整个 UDP 报文的长度，包括 UDP 首部长度和数据部分</strong>。</p>
<h2 id="TCP- 首部格式">TCP 首部格式</h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/55dc4e84-573d-4c13-a765-52ed1dd251f9.png" width="700"/> </div><br>
<ul>
<li>
<p><strong>序号 seq</strong>：用于对 <u> 字节流 </u> 进行编号。例如序号为 301，表示第一个字节的编号为 seq=301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p>
</li>
<li>
<p><strong>确认号 ack</strong>：期望收到的下一个报文段的序号 seq。例如 B 正确收到 A 发送来的一个报文段，序号为 seq=501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 ack=701。</p>
</li>
<li>
<p><strong>数据偏移（TCP 首部长度）</strong>：指的是数据 payload 部分距离报文段起始处的偏移量，即 TCP 首部的长度（1 个单位为 4 字节）。</p>
</li>
<li>
<p><strong>确认 ACK</strong>：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传输的报文段都必须把 ACK 置 1。</p>
</li>
<li>
<p><strong>同步 SYN</strong>：在 <u> 连接建立时 </u> 用来 <strong> 同步序号 seq</strong>。当 SYN=1, ACK=0 时表示这是一个连接请求报文段（第一次握手）。若对方同意建立连接，则响应报文中 SYN=1, ACK=1（第二次握手）。</p>
</li>
<li>
<p><strong>终止 FIN</strong>：用来释放一个连接。当 FIN=1 时，表示此报文段的 <u> 发送方的数据已发送完毕，并要求释放连接</u>。</p>
</li>
<li>
<p><strong>窗口 window</strong>：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为 <strong> 接收方的数据缓存队列是有限的</strong>。</p>
</li>
</ul>
<blockquote>
<p>发送窗口的大小（接收方可接收的序号范围）是从接收方发送给发送方的确认报文段中的「确定号 ~ 确认号 + 窗口大小」之间的数据。</p>
</blockquote>
<h2 id="TCP- 的三次握手">TCP 的三次握手</h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e92d0ebc-7d46-413b-aec1-34a39602f787.png" width="600"/> </div><br>
<p>假设 A 为客户端，B 为服务端。</p>
<ul>
<li>
<p>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</p>
</li>
<li>
<p><strong>第一次握手</strong>：A 向 B 发送连接请求报文，SYN=1, ACK=0，选择一个初始的序号 x。</p>
</li>
<li>
<p><strong>第二次握手</strong>：B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1, ACK=1, ack=x+1，同时也选择（随机）一个初始的 seq=y。</p>
</li>
<li>
<p><strong>第三次握手</strong>：A 收到 B 的连接确认报文后，还要向 B 发出确认，ACK=1, ack=y+1, seq=x+1。</p>
</li>
<li>
<p>B 收到 A 的确认后，还会回复一个确认信号，表明服务端已经准备好开始传输数据了，连接建立。</p>
</li>
</ul>
<blockquote>
<p>一般确认报文段中的 ack=seq+data_len，但三次握手过程中，ack=seq+1，这是因为 <u> 建立连接时的第一次、二次握手不携带应用层数据（第三次握手可以携带应用层数据）</u>。</p>
</blockquote>
<p><strong>三次握手的原因</strong></p>
<p>原因一：第三次握手是 <mark> 为了防止客户端已失效（过时）的连接请求报文又到达服务端，让服务端错误地二次打开连接</mark>。</p>
<p>如果客户端发送的连接请求报文在网络中因各种原因导致了滞留，那么客户端就会隔很长一段时间才能收到服务端发回的连接确认。<u>在客户端等待一个超时重传时间之后，就会重新请求连接 </u>。但是，这个滞留的连接请求最后还是会到达服务端，服务端会认为这是一个<strong> 新的 </strong> 连接请求。</p>
<p>如果不进行三次握手，服务端此时发送了确认报文段之后，就又建立了一个新的连接，并等待客户端发送数据。如果有第三次握手，客户端会忽略服务端后续发送的对滞留连接请求的连接确认，不再进行第三次握手，因此就不会再次打开连接。</p>
<p>原因二：如果没有第三次握手，<u>服务端不知道自己的连接确认报文段是否有成功发送给客户端</u>。三次握手，服务端会等待客户端的第三次握手，如果第三次握手迟迟不来，服务端就会释放相关资源（分配的队列缓存、变量等）。</p>
<h2 id="TCP- 的四次挥手">TCP 的四次挥手</h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" width="600"/> </div><br>
<p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p>
<ul>
<li>
<p>A 发送连接释放报文，<strong>FIN=1</strong>。</p>
</li>
<li>
<p>B 收到之后发出确认，此时 TCP 属于 <u> 半关闭状态，B 能向 A 发送数据，但是 A 不能向 B 发送数据</u>。</p>
</li>
<li>
<p>当 B 不再需要连接时，发送连接释放报文，<strong>FIN=1</strong>。</p>
</li>
<li>
<p>A 收到之后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</p>
</li>
<li>
<p>B 收到 A 的确认后释放连接。</p>
</li>
</ul>
<p><strong>四次挥手的原因</strong></p>
<p>客户端发送了 FIN 连接释放报文之后，服务端收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是 <mark> 为了让服务端发送还未传送完毕的数据</mark>，传送完毕之后，服务端会发送 FIN 连接释放报文。</p>
<p><strong>TIME_WAIT</strong></p>
<p>客户端接收到服务端的 FIN 报文后进入该状态，此时并不是直接进入 CLOSED 状态，还需要等待 2 倍最长 segment 生命期 2MSL。这么做有两个理由：</p>
<ul>
<li>
<p><mark>可靠地实现 TCP 全双工连接的终止（彻底终止某个连接上两个方向的数据流），即确保最后一个 ACK 确认报文能够到达服务端</mark>。如果服务端没收到客户端发送来的 ACK 确认报文，那么服务端就会重新发送 FIN 连接释放请求报文，客户端等待一段时间就是为了处理这种情况的发生。</p>
</li>
<li>
<p>等待一段时间也是为了 <mark> 让本连接持续时间内所产生的所有报文都从网络中消失</mark>，使得下一个新的连接不会出现旧的连接请求报文。</p>
</li>
</ul>
<h2 id="TCP- 可靠传输">TCP 可靠传输</h2>
<p><strong>TCP 使用超时重传来实现可靠传输</strong>：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p>
<p>一个报文段从发送再到接收到服务端的确认报文段，所经过的时间称为 <strong> 往返时间</strong>（Round Trip Time, RTT），加权平均往返时间 RTTs 计算如下：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mi>T</mi><mi>T</mi><mi>s</mi><mo>:</mo><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><mover accent="true"><mrow><mi>R</mi><mi>T</mi><mi>T</mi><mi>s</mi></mrow><mo stretchy="true">‾</mo></mover><mo stretchy="false">)</mo><mo>+</mo><mi>α</mi><mo>∗</mo><mi>R</mi><mi>T</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">RTTs := (1-\alpha)*(\overline{RTTs})+\alpha*RTT
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.13333em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">s</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></span></p>
<p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>R</mi><mi>T</mi><mi>T</mi><mi>s</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{RTTs}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">s</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span> 为多个 RRT 的平均值，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> 的典型值为 0.125。</p>
<p><strong>重传超时时间</strong>（Retransmission Time Out, RTO）应该略大于 RTTs，TCP 使用的超时时间计算如下：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mi>T</mi><mi>O</mi><mo>=</mo><mi>R</mi><mi>T</mi><mi>T</mi><mi>s</mi><mo>+</mo><mn>4</mn><mo>∗</mo><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>d</mi></msub></mrow><annotation encoding="application/x-tex">RTO=RTTs+4*RTT_d
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>d</mi></msub><mo>:</mo><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>β</mi><mo stretchy="false">)</mo><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>d</mi></msub><mo>+</mo><mi>β</mi><mi mathvariant="normal">∣</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>−</mo><mi>R</mi><mi>T</mi><mi>T</mi><mi>s</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">RTT_d := (1-\beta)RTT_d + \beta |RTT-RTTs|
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">s</span><span class="mord">∣</span></span></span></span></span></p>
<p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>d</mi></msub></mrow><annotation encoding="application/x-tex">RTT_d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为偏差的加权平均值。</p>
<h2 id="TCP- 滑动窗口">TCP 滑动窗口</h2>
<p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，<strong>接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小</strong>。</p>
<p>发送窗口内的字节 <u> 都允许被发送 </u>，接收窗口内的字节<u> 都允许被接收 </u>。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，<u> 直到左部第一个字节不是已发送并且已确认的状态</u>；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a3253deb-8d21-40a1-aae4-7d178e4aa319.jpg" width="800"/> </div><br>
<p>接收窗口 <u> 只会对窗口内最后一个按序到达的字节进行确认</u>。例如，接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p>
<blockquote>
<p>对于未被确认的字节 {34, 35} ，接收方会将它们存储在接收缓冲区中，并等待后续的字节按序到达。</p>
<ul>
<li><u>一旦后续的字节按序到达，接收方就可以继续处理这些字节</u>。</li>
<li>如果接收方在一定时间内 <u> 没有收到后续字节或者发生了丢包等问题，那么接收方可以选择 <strong> 发送一个重传请求</strong>，要求发送方重新发送这些未被确认的字节</u>。这样可以确保数据的可靠传输。</li>
</ul>
</blockquote>
<h2 id="TCP- 流量控制">TCP 流量控制</h2>
<p>流量控制是为了 <u> 控制发送方发送速率，保证接收方来得及接收</u>。</p>
<p><u>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率</u>。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h2 id="TCP- 拥塞控制">TCP 拥塞控制</h2>
<p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此 <u> 当出现拥塞时，应当控制发送方的速率 </u>。这一点和流量控制很像，但是出发点不同。<u> 流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度</u>。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/51e2ed95-65b8-4ae9-8af3-65602d452a25.jpg" width="500"/> </div><br>
<p><mark>TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复</mark>。</p>
<p><u>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量 </u>。注意拥塞窗口与发送方窗口的区别：<u> 拥塞窗口只是一个状态变量</u>，实际决定发送方能发送多少数据的是发送方窗口大小。</p>
<p>为了便于讨论，做如下假设：</p>
<ul>
<li>接收方有足够大的接收缓存，因此不会发生流量控制；</li>
<li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/910f613f-514f-4534-87dd-9b4699d59d31.png" width="800"/> </div><br>
<h3 id="1- 慢开始与拥塞避免">1. 慢开始与拥塞避免</h3>
<p><u>发送的最初执行 <strong> 慢开始</strong></u>，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p>
<p>注意到 <u> 慢开始每个轮次都将 cwnd 加倍 </u>，这样会让 cwnd 增长速度非常快，从而使得发送方的发送速度增长过快，网络拥塞的可能性也就更高。<u> 设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，<strong>进入拥塞避免</strong>，每个轮次只将 cwnd 加 1</u>。</p>
<p>如果出现了 <u> 超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始</u>。</p>
<h3 id="2- 快重传与快恢复">2. 快重传与快恢复</h3>
<p>在接收方，<u>要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认 </u>。例如已经接收到 M<sub>1</sub> 和 M<sub>2</sub>，此时收到 M<sub>4</sub>，应当<em> 依旧 </em> 发送对 M<sub>2</sub> 的确认。</p>
<p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时 <strong> 执行快重传</strong>，立即重传下一个报文段。例如收到三个 M<sub>2</sub>，则 M<sub>3</sub> 丢失，立即重传 M<sub>3</sub>。</p>
<p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此 <strong> 执行快恢复</strong>，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。&lt;- 上图 5-25 的序号 ④ ⑤ 及之后。</p>
<blockquote>
<p>慢开始和快恢复的 <u> 快慢指的是 cwnd 的设定值</u>，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p>
</blockquote>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f61b5419-c94a-4df1-8d4d-aed9ae8cc6d5.png" width="600"/> </div><br>
<blockquote>
<p>本文修改自：<a href="https://github.com/CyC2018/CS-Notes">https://github.com/CyC2018/CS-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>CyC2018</tag>
      </tags>
  </entry>
  <entry>
    <title>计网 CyC2018 之应用层</title>
    <url>/posts/240329202001.html</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="计算机网络 - 应用层"> 计算机网络 - 应用层 </h1>
<!-- GFM-TOC -->
<ul>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E5%BA%94%E7%94%A8%E5%B1%82"> 计算机网络 - 应用层 </a>
<ul>
<li><a href="#%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F"> 域名系统 </a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AE"> 文件传送协议 </a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE"> 动态主机配置协议 </a></li>
<li><a href="#%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%8D%8F%E8%AE%AE"> 远程登录协议 </a></li>
<li><a href="#%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%8D%8F%E8%AE%AE"> 电子邮件协议 </a>
<ul>
<li><a href="#1-SMTP">1. SMTP</a></li>
<li><a href="#2-POP3">2. POP3</a></li>
<li><a href="#3-IMAP">3. IMAP</a></li>
</ul>
</li>
<li><a href="#%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3"> 常用端口 </a></li>
<li><a href="#Web%20%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B">Web 页面请求过程 </a>
<ul>
<li><a href="#1-DHCP-%20%E9%85%8D%E7%BD%AE%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF">1. DHCP 配置主机信息 </a></li>
<li><a href="#2-ARP-%20%E8%A7%A3%E6%9E%90%20-MAC-%20%E5%9C%B0%E5%9D%80">2. ARP 解析 MAC 地址 </a></li>
<li><a href="#3-DNS-%20%E8%A7%A3%E6%9E%90%E5%9F%9F%E5%90%8D">3. DNS 解析域名 </a></li>
<li><a href="#4-HTTP-%20%E8%AF%B7%E6%B1%82%E9%A1%B5%E9%9D%A2">4. HTTP 请求页面 </a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- GFM-TOC -->
<h2 id="域名系统"> 域名系统 </h2>
<p>DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。</p>
<p> 域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b54eeb16-0b0e-484c-be62-306f57c40d77.jpg"/> </div><br>
<p>DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输：</p>
<ul>
<li> 如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。</li>
<li> 区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。</li>
</ul>
<h2 id="文件传送协议"> 文件传送协议 </h2>
<p>FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：</p>
<ul>
<li> 控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。</li>
<li> 数据连接：用来传送一个文件数据。</li>
</ul>
<p> 根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：</p>
<ul>
<li> 主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/03f47940-3843-4b51-9e42-5dcaff44858b.jpg"/> </div><br>
<ul>
<li> 被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/be5c2c61-86d2-4dba-a289-b48ea23219de.jpg"/> </div><br>
<p> 主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。</p>
<h2 id="动态主机配置协议"> 动态主机配置协议 </h2>
<p>DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。</p>
<p>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。</p>
<p>DHCP 工作过程如下：</p>
<ol>
<li> 客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。</li>
<li>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。</li>
<li> 如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。</li>
<li>DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</li>
</ol>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/23219e4c-9fc0-4051-b33a-2bd95bf054ab.jpg"/> </div><br>
<h2 id="远程登录协议"> 远程登录协议 </h2>
<p>TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。</p>
<p>TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</p>
<h2 id="电子邮件协议"> 电子邮件协议 </h2>
<p> 一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。</p>
<p> 邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7b3efa99-d306-4982-8cfb-e7153c33aab4.png" width="700"/> </div><br>
<h3 id="1-SMTP">1. SMTP</h3>
<p>SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ed5522bb-3a60-481c-8654-43e7195a48fe.png" width=""/> </div><br>
<h3 id="2-POP3">2. POP3</h3>
<p>POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。</p>
<h3 id="3-IMAP">3. IMAP</h3>
<p>IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。</p>
<h2 id="常用端口"> 常用端口 </h2>
<table>
<thead>
<tr>
<th style="text-align:center"> 应用 </th>
<th style="text-align:center"> 应用层协议 </th>
<th style="text-align:center"> 端口号 </th>
<th style="text-align:center"> 传输层协议 </th>
<th style="text-align:center"> 备注 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"> 域名解析 </td>
<td style="text-align:center">DNS</td>
<td style="text-align:center">53</td>
<td style="text-align:center">UDP/TCP</td>
<td style="text-align:center"> 长度超过 512 字节时使用 TCP</td>
</tr>
<tr>
<td style="text-align:center"> 动态主机配置协议 </td>
<td style="text-align:center">DHCP</td>
<td style="text-align:center">67/68</td>
<td style="text-align:center">UDP</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"> 简单网络管理协议 </td>
<td style="text-align:center">SNMP</td>
<td style="text-align:center">161/162</td>
<td style="text-align:center">UDP</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"> 文件传送协议 </td>
<td style="text-align:center">FTP</td>
<td style="text-align:center">20/21</td>
<td style="text-align:center">TCP</td>
<td style="text-align:center"> 控制连接 21，数据连接 20</td>
</tr>
<tr>
<td style="text-align:center"> 远程终端协议 </td>
<td style="text-align:center">TELNET</td>
<td style="text-align:center">23</td>
<td style="text-align:center">TCP</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"> 超文本传送协议 </td>
<td style="text-align:center">HTTP</td>
<td style="text-align:center">80</td>
<td style="text-align:center">TCP</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"> 简单邮件传送协议 </td>
<td style="text-align:center">SMTP</td>
<td style="text-align:center">25</td>
<td style="text-align:center">TCP</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"> 邮件读取协议 </td>
<td style="text-align:center">POP3</td>
<td style="text-align:center">110</td>
<td style="text-align:center">TCP</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"> 网际报文存取协议 </td>
<td style="text-align:center">IMAP</td>
<td style="text-align:center">143</td>
<td style="text-align:center">TCP</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="Web- 页面请求过程">Web 页面请求过程 </h2>
<h3 id="1-DHCP- 配置主机信息">1. DHCP 配置主机信息 </h3>
<ul>
<li>
<p> 假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。</p>
</li>
<li>
<p> 主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。</p>
</li>
<li>
<p> 该报文段则被放入在一个具有广播 IP 目的地址 (255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。</p>
</li>
<li>
<p> 该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:&lt;zero-width space&gt;FF:&lt;zero-width space&gt;FF:&lt;zero-width space&gt;FF:&lt;zero-width space&gt;FF:FF，将广播到与交换机连接的所有设备。</p>
</li>
<li>
<p> 连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。</p>
</li>
<li>
<p> 该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。</p>
</li>
<li>
<p> 主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。</p>
</li>
</ul>
<h3 id="2-ARP- 解析 -MAC- 地址">2. ARP 解析 MAC 地址 </h3>
<ul>
<li>
<p> 主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。</p>
</li>
<li>
<p> 主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。</p>
</li>
<li>
<p> 该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。</p>
</li>
<li>
<p> 该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。</p>
</li>
<li>
<p>DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。</p>
</li>
<li>
<p> 主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:&lt;zero-width space&gt;FF:&lt;zero-width space&gt;FF:&lt;zero-width space&gt;FF:&lt;zero-width space&gt;FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。</p>
</li>
<li>
<p> 网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。</p>
</li>
</ul>
<h3 id="3-DNS- 解析域名">3. DNS 解析域名 </h3>
<ul>
<li>
<p> 知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。</p>
</li>
<li>
<p> 网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。</p>
</li>
<li>
<p> 因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。</p>
</li>
<li>
<p> 到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。</p>
</li>
<li>
<p> 找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</p>
</li>
</ul>
<h3 id="4-HTTP- 请求页面">4. HTTP 请求页面 </h3>
<ul>
<li>
<p> 有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。</p>
</li>
<li>
<p> 在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。</p>
</li>
<li>
<p>HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。</p>
</li>
<li>
<p> 连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</p>
</li>
<li>
<p>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</p>
</li>
<li>
<p> 浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</p>
</li>
</ul>
<blockquote>
<p> 本文修改自：<a href="https://github.com/CyC2018/CS-Notes">https://github.com/CyC2018/CS-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>CyC2018</tag>
      </tags>
  </entry>
  <entry>
    <title>计网 CyC2018 之概述</title>
    <url>/posts/240329202000.html</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="计算机网络 - 概述">计算机网络 - 概述</h1>
<!-- GFM-TOC -->
<ul>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E6%A6%82%E8%BF%B0">计算机网络 - 概述</a>
<ul>
<li><a href="#%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BD%91%E7%BB%9C">网络的网络</a></li>
<li><a href="#isp">ISP</a></li>
<li><a href="#%E4%B8%BB%E6%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F">主机之间的通信方式</a></li>
<li><a href="#%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2%E4%B8%8E%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2">电路交换与分组交换</a>
<ul>
<li><a href="#1-%20%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2">1. 电路交换</a></li>
<li><a href="#2-%20%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2">2. 分组交换</a></li>
</ul>
</li>
<li><a href="#%E6%97%B6%E5%BB%B6">时延</a>
<ul>
<li><a href="#1-%20%E6%8E%92%E9%98%9F%E6%97%B6%E5%BB%B6">1. 排队时延</a></li>
<li><a href="#2-%20%E5%A4%84%E7%90%86%E6%97%B6%E5%BB%B6">2. 处理时延</a></li>
<li><a href="#3-%20%E4%BC%A0%E8%BE%93%E6%97%B6%E5%BB%B6">3. 传输时延</a></li>
<li><a href="#4-%20%E4%BC%A0%E6%92%AD%E6%97%B6%E5%BB%B6">4. 传播时延</a></li>
</ul>
</li>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">计算机网络体系结构</a>
<ul>
<li><a href="#1-%20%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE">1. 五层协议</a></li>
<li><a href="#2-OSI">2. OSI</a></li>
<li><a href="#3-TCP-IP">3. TCP/IP</a></li>
<li><a href="#4-%20%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%90%84%E5%B1%82%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E9%80%92%E8%BF%87%E7%A8%8B">4. 数据在各层之间的传递过程</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- GFM-TOC -->
<h2 id="网络的网络">网络的网络</h2>
<p>网络把主机连接起来，而互连网（internet）是把多种不同的网络连接起来，因此互连网是网络的网络。而互联网（Internet）是全球范围的互连网。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/network-of-networks.gif" width="450"/> </div><br>
<h2 id="ISP">ISP</h2>
<p>互联网服务提供商（Internet Service Provider, ISP），如中国移动、联通和电信，可以从互联网管理机构 <strong> 获得许多 IP 地址</strong>，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网（即可用于访问互联网的公网 IP 地址）。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/72be01cd-41ae-45f7-99b9-a8d284e44dd4.png" width="500"/> </div><br>
<p>目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为第一层 ISP、区域 ISP 和接入 ISP。互联网交换点（Internet eXchange Point, IXP）允许两个 ISP 直接相连而不用经过第三个 ISP。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/3be42601-9d33-4d29-8358-a9d16453af93.png" width="500"/> </div><br>
<h2 id="主机之间的通信方式">主机之间的通信方式</h2>
<ul>
<li>客户 - 服务器（Client/Server, C/S）：客户是服务的请求方，服务器是服务的提供方。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/914894c2-0bc4-46b5-bef9-0316a69ef521.jpg" width="240px"> </div><br>
<ul>
<li>对等（Peer to Peer, P2P）：不区分客户和服务器，即图中每一个节点既可以是 client，也可以是 server。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/42430e94-3137-48c0-bdb6-3cebaf9102e3.jpg" width="200px"> </div><br>
<h2 id="电路交换与分组交换">电路交换与分组交换</h2>
<h3 id="1- 电路交换">1. 电路交换</h3>
<p>电路交换用于 <strong> 电话通信系统 </strong>，两个用户要通信之前需要建立<strong> 一条专用的物理链路 </strong>，并且在整个通信过程中<strong> 始终占用 </strong> 该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。</p>
<blockquote>
<p>可以在主干链路上利用 <strong> 多路复用技术</strong>，只占用链路的部分带宽，如使用按频率、按时隙占用等，让不同通信信号在同一条链路上进行传输而不互相干扰。</p>
</blockquote>
<h3 id="2- 分组交换">2. 分组交换</h3>
<p><strong>每个分组都有首部和尾部 </strong>，包含了源地址和目的地址等控制信息，<strong> 在同一个传输线路上同时传输多个分组互相不会影响 </strong>，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换<strong> 不需要占用 </strong> 传输线路。</p>
<blockquote>
<p>在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。</p>
</blockquote>
<h2 id="时延">时延</h2>
<p>总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4b2ae78c-e254-44df-9e37-578e2f2bef52.jpg" width="380"/> </div><br>
<h3 id="1- 排队时延">1. 排队时延</h3>
<p>分组 <strong> 在路由器 </strong> 的输入队列和输出 <strong> 队列中排队等待的时间</strong>，取决于网络当前的通信量。</p>
<h3 id="2- 处理时延">2. 处理时延</h3>
<p>主机或 <strong> 路由器收到分组时，在设备内部进行处理的时间</strong>，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。</p>
<h3 id="3- 传输时延">3. 传输时延</h3>
<p>主机或 <strong> 路由器传输数据 </strong> 帧所需要的时间。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>e</mi><mi>l</mi><mi>a</mi><mi>y</mi><mo>=</mo><mfrac><mrow><mi>l</mi><mo stretchy="false">(</mo><mi>b</mi><mi>i</mi><mi>t</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><mrow><mi>v</mi><mo stretchy="false">(</mo><mi>b</mi><mi>i</mi><mi>t</mi><mi>s</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">delay=\frac{l(bits)}{v(bits/s)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> 表示数据帧的长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 表示传输速率。</p>
<h3 id="4- 传播时延">4. 传播时延</h3>
<p>电磁波 <strong> 在信道中传播 </strong> 所需要花费的时间，电磁波传播的速度接近光速。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>e</mi><mi>l</mi><mi>a</mi><mi>y</mi><mo>=</mo><mfrac><mrow><mi>l</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><mrow><mi>v</mi><mo stretchy="false">(</mo><mi>m</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">delay=\frac{l(m)}{v(m/s)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> 表示信道长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 表示电磁波在信道上的传播速度。</p>
<h2 id="计算机网络体系结构">计算机网络体系结构</h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0fa6c237-a909-4e2a-a771-2c5485cd8ce0.png" width="450"/> </div><br>
<h3 id="1- 五层协议">1. 五层协议</h3>
<ul>
<li><strong>应用层 </strong>：<strong> 为特定应用程序 </strong> 提供数据传输服务，例如 HTTP、DNS 等协议。<strong>数据单位为报文 message</strong>。</li>
<li><strong>传输层 </strong>：<strong> 为主机中的进程 </strong> 提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。传输层包括两种协议：
<ul>
<li>传输控制协议 TCP：提供面向连接、可靠的数据传输服务，<strong>数据单位为报文段 segment</strong>。</li>
<li>用户数据报协议 UDP：提供无连接、尽最大努力的数据传输服务，<strong>数据单位为报文段 segment</strong>。</li>
<li>TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li>
</ul>
</li>
<li><strong>网络层 </strong>：<strong> 为主机 </strong> 提供数据传输服务。网络层把传输层传递下来的报文段 segment 封装成 <strong> 分组 packet (packet = segment/datagram)</strong>。</li>
<li><strong>数据链路层 </strong>：<strong> 为同一链路的主机 </strong> 提供数据传输服务。数据链路层把网络层传下来的分组封装成 <strong> 帧 frame</strong>。</li>
<li><strong>物理层 </strong>：考虑的是怎样在传输媒体上<strong> 传输数据比特流 bit</strong>，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li>
</ul>
<blockquote>
<p>个人理解，每层的数据单位就是看报文封装、解封装时的头部信息，如在链路层时，可识别的头部是以太头 [DMAC | SMAC | TYPE]，称为帧。</p>
</blockquote>
<h3 id="2-OSI">2. OSI</h3>
<p>其中表示层和会话层用途如下：</p>
<ul>
<li>
<p><strong>表示层</strong>  ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</p>
</li>
<li>
<p><strong>会话层</strong>  ：建立及管理会话。</p>
</li>
</ul>
<p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p>
<h3 id="3-TCP-IP">3. TCP/IP</h3>
<p>它只有四层，相当于五层协议中 <strong> 数据链路层和物理层合并为网络接口层</strong>。</p>
<p>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/48d79be8-085b-4862-8a9d-18402eb93b31.png" width="250"/> </div><br>
<h3 id="4- 数据在各层之间的传递过程">4. 数据在各层之间的传递过程</h3>
<p>在 <strong> 向下 </strong> 的过程中，需要 <strong> 封装 </strong> 下层协议所需要的首部或者尾部，而在 <strong> 向上 </strong> 的过程中不断 <strong> 解封装</strong>（拆开）首部和尾部。</p>
<p><strong>路由器只有物理层、数据链路层、网络层三层协议</strong>，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</p>
<blockquote>
<p>本文修改自：<a href="https://github.com/CyC2018/CS-Notes">https://github.com/CyC2018/CS-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>CyC2018</tag>
      </tags>
  </entry>
  <entry>
    <title>计网 CyC2018 之链路层</title>
    <url>/posts/240329202004.html</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="计算机网络 - 链路层">计算机网络 - 链路层</h1>
<!-- GFM-TOC -->
<ul>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E9%93%BE%E8%B7%AF%E5%B1%82">计算机网络 - 链路层</a>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98">基本问题</a>
<ul>
<li><a href="#1-%20%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7">1. 封装成帧</a></li>
<li><a href="#2-%20%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93">2. 透明传输</a></li>
<li><a href="#3-%20%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B">3. 差错检测</a></li>
</ul>
</li>
<li><a href="#%E4%BF%A1%E9%81%93%E5%88%86%E7%B1%BB">信道分类</a>
<ul>
<li><a href="#1-%20%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93">1. 广播信道</a></li>
<li><a href="#2-%20%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93">2. 点对点信道</a></li>
</ul>
</li>
<li><a href="#%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF">信道复用技术</a>
<ul>
<li><a href="#1-%20%E9%A2%91%E5%88%86%E5%A4%8D%E7%94%A8">1. 频分复用</a></li>
<li><a href="#2-%20%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8">2. 时分复用</a></li>
<li><a href="#3-%20%E7%BB%9F%E8%AE%A1%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8">3. 统计时分复用</a></li>
<li><a href="#4-%20%E6%B3%A2%E5%88%86%E5%A4%8D%E7%94%A8">4. 波分复用</a></li>
<li><a href="#5-%20%E7%A0%81%E5%88%86%E5%A4%8D%E7%94%A8">5. 码分复用</a></li>
</ul>
</li>
<li><a href="#CSMA-CD-%20%E5%8D%8F%E8%AE%AE">CSMA/CD 协议</a></li>
<li><a href="#PPP-%20%E5%8D%8F%E8%AE%AE">PPP 协议</a></li>
<li><a href="#MAC-%20%E5%9C%B0%E5%9D%80">MAC 地址</a></li>
<li><a href="#%E5%B1%80%E5%9F%9F%E7%BD%91">局域网</a></li>
<li><a href="#%E4%BB%A5%E5%A4%AA%E7%BD%91">以太网</a></li>
<li><a href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA">交换机</a></li>
<li><a href="#%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91">虚拟局域网</a></li>
</ul>
</li>
</ul>
<!-- GFM-TOC -->
<h2 id="基本问题">基本问题</h2>
<h3 id="1- 封装成帧">1. 封装成帧</h3>
<p>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/29a14735-e154-4f60-9a04-c9628e5d09f4.png" width="300"/> </div><br>
<h3 id="2- 透明传输">2. 透明传输</h3>
<p>透明表示一个实际存在的事物看起来好像不存在一样。</p>
<p>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e738a3d2-f42e-4755-ae13-ca23497e7a97.png" width="500"/> </div><br>
<h3 id="3- 差错检测">3. 差错检测</h3>
<p>目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。</p>
<h2 id="信道分类">信道分类</h2>
<h3 id="1- 广播信道">1. 广播信道</h3>
<p>一对多通信，一个节点发送的数据能够被广播信道上的所有节点接收到。</p>
<p>所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。</p>
<p>主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。</p>
<h3 id="2- 点对点信道">2. 点对点信道</h3>
<p>一对一通信。因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。</p>
<h2 id="信道复用技术">信道复用技术</h2>
<h3 id="1- 频分复用">1. 频分复用</h3>
<p>频分复用的所有主机 <u> 在相同的时间占用不同的频率带宽资源</u>。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4aa5e057-bc57-4719-ab57-c6fbc861c505.png" width="350"/> </div><br>
<h3 id="2- 时分复用">2. 时分复用</h3>
<p>时分复用的所有主机 <u> 在不同的时间占用相同的频率带宽资源</u>。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/67582ade-d44a-46a6-8757-3c1296cc1ef9.png" width="350"/> </div><br>
<p>使用 <u> 频分复用和时分复用进行通信 </u>，在通信的过程中<u> 主机会一直占用一部分信道资源</u>。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高。</p>
<h3 id="3- 统计时分复用">3. 统计时分复用</h3>
<p>是对时分复用的一种改进，<u>不固定每个用户在时分复用帧中的位置</u>，只要有数据就集中起来组成统计时分复用帧，然后发送。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6283be2a-814a-4a10-84bf-9592533fe6bc.png" width="350"/> </div><br>
<p><strong>IP 网络是面向无连接的统计时分复用网络</strong>，来自于网络设备（如路由器）不同入接口的报文，在出接口上将根据报文抵达出接口队列的时机决定发送的顺序。结合统计时分复用的特征，每个报文在出接口上得到队列调度的机会均等，可以充分利用网络带宽。</p>
<h3 id="4- 波分复用">4. 波分复用</h3>
<p>光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。</p>
<h3 id="5- 码分复用">5. 码分复用</h3>
<p>为每个用户分配 m bit 的码片，并且所有的码片正交，对于任意两个码片 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>S</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{S}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>T</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{T}</annotation></semantics></math></span><span class="katex-html"aria-hidden="true"><span class="base"><span class="strut"style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist"style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut"style="height:3em;"></span><span class="mord"><span class="mord mathnormal"style="margin-right:0.13889em;">T</span></span></span><span style="top:-3.25233em;"><span class="pstrut"style="height:3em;"></span><span class="accent-body"style="left:-0.15216em;"><span class="overlay"style="height:0.714em;width:0.471em;"><svg width='0.471em'height='0.714em'style='width:0.471em'viewBox='0 0 471 714'preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span> 有</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mn>1</mn><mi>m</mi></mfrac><mover accent="true"><mi>S</mi><mo>⃗</mo></mover><mo>⋅</mo><mover accent="true"><mi>T</mi><mo>⃗</mo></mover><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\frac{1}{m} \vec{S} \cdot \vec{T} = 0
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mspace"style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace"style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut"style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist"style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut"style="height:3em;"></span><span class="mord"><span class="mord mathnormal"style="margin-right:0.13889em;">T</span></span></span><span style="top:-3.25233em;"><span class="pstrut"style="height:3em;"></span><span class="accent-body"style="left:-0.15216em;"><span class="overlay"style="height:0.714em;width:0.471em;"><svg width='0.471em'height='0.714em'style='width:0.471em'viewBox='0 0 471 714'preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mspace"style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace"style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut"style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p>
<p>为了讨论方便，取 m=8，设码片 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>S</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{S}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span> 为 00011011。在拥有该码片的用户 <u> 发送比特 1 时就发送该码片，发送比特 0 时就发送该码片的反码</u>。</p>
<p>在计算时将 00011011 记作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>S</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{S}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span> = [-1, -1, -1, +1, +1, -1, +1, +1]，可以得到</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mn>1</mn><mi>m</mi></mfrac><mover accent="true"><mi>S</mi><mo>⃗</mo></mover><mo>⋅</mo><mover accent="true"><mi>S</mi><mo>⃗</mo></mover><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\frac{1}{m} \vec{S} \cdot \vec{S} = 1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mspace"style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace"style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut"style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist"style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut"style="height:3em;"></span><span class="mord"><span class="mord mathnormal"style="margin-right:0.05764em;">S</span></span></span><span style="top:-3.25233em;"><span class="pstrut"style="height:3em;"></span><span class="accent-body"style="left:-0.15216em;"><span class="overlay"style="height:0.714em;width:0.471em;"><svg width='0.471em'height='0.714em'style='width:0.471em'viewBox='0 0 471 714'preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mspace"style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace"style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut"style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mn>1</mn><mi>m</mi></mfrac><mover accent="true"><mi>S</mi><mo>⃗</mo></mover><mo>⋅</mo><mover accent="true"><msup><mi>S</mi><msup><mrow></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msup><mo>⃗</mo></mover><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\frac{1}{m} \vec{S} \cdot \vec{S^{&#x27;}} = -1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mspace"style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace"style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut"style="height:1.04998em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist"style="height:1.04998em;"><span style="top:-3em;"><span class="pstrut"style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal"style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist"style="height:0.76698em;"><span style="top:-2.789em;margin-right:0.05em;"><span class="pstrut"style="height:2.5em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist"style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut"style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.33598em;"><span class="pstrut"style="height:3em;"></span><span class="accent-body"style="left:-0.2355em;"><span class="overlay"style="height:0.714em;width:0.471em;"><svg width='0.471em'height='0.714em'style='width:0.471em'viewBox='0 0 471 714'preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mspace"style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace"style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut"style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span></span></p>
<p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><msup><mi>S</mi><msup><mrow></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msup><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{S^{&#x27;}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04998em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.04998em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.76698em;"><span style="top:-2.789em;margin-right:0.05em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.33598em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>S</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{S}</annotation></semantics></math></span><span class="katex-html"aria-hidden="true"><span class="base"><span class="strut"style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist"style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut"style="height:3em;"></span><span class="mord"><span class="mord mathnormal"style="margin-right:0.05764em;">S</span></span></span><span style="top:-3.25233em;"><span class="pstrut"style="height:3em;"></span><span class="accent-body"style="left:-0.15216em;"><span class="overlay"style="height:0.714em;width:0.471em;"><svg width='0.471em'height='0.714em'style='width:0.471em'viewBox='0 0 471 714'preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span> 的反码。</p>
<p>利用上面的式子我们知道，<strong>当接收端使用码片 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>S</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{S}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span> 对接收到的数据进行内积运算时，结果为 0 的是其它用户发送的数据，结果为 1 的是用户发送的比特 1，结果为 -1 的是用户发送的比特 0</strong>。</p>
<p>码分复用需要发送的数据量为原先的 m 倍。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/99b6060e-099d-4201-8e86-f8ab3768a7cf.png" width="500px"> </div><br>
<h2 id="CSMA-CD- 协议">CSMA/CD 协议</h2>
<p>CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p>
<ul>
<li><strong>多点接入</strong>  ：说明这是总线型网络，许多主机以多点的方式连接到总线上。</li>
<li><strong>载波监听</strong>  ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li>
<li><strong>碰撞检测</strong>  ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</li>
</ul>
<p>记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为   <strong>争用期</strong>  。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p>
<p>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用   <strong>截断二进制指数退避算法</strong>   来确定。从离散的整数集合 {0, 1, …, (2<sup>k</sup>-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/19d423e9-74f7-4c2b-9b97-55890e0d5193.png" width="400"/> </div><br>
<h2 id="PPP- 协议">PPP 协议</h2>
<p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，点对点协议（Point-to-Point Protocol, PPP）是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e1ab9f28-cb15-4178-84b2-98aad87f9bc8.jpg" width="300"/> </div><br>
<p>PPP 的帧格式：</p>
<ul>
<li>F 字段为帧的定界符</li>
<li>A 和 C 字段暂时没有意义</li>
<li>FCS 字段是使用 CRC 的检验序列</li>
<li>信息部分的长度不超过 1500</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/759013d7-61d8-4509-897a-d75af598a236.png" width="400"/> </div><br>
<h2 id="MAC- 地址">MAC 地址</h2>
<p>MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。</p>
<p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</p>
<h2 id="局域网">局域网</h2>
<p>局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。</p>
<p>主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。</p>
<p>可以按照网络拓扑结构对局域网进行分类：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/807f4258-dba8-4c54-9c3c-a707c7ccffa2.jpg" width="800"/> </div><br>
<h2 id="以太网">以太网</h2>
<p>以太网是一种 <u> 星型拓扑结构 </u> 局域网。</p>
<p>早期使用集线器进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。</p>
<p>目前 <u> 以太网使用交换机替代了集线器</u>，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。</p>
<p>以太网帧格式：</p>
<ul>
<li><strong>类型</strong>  ：标记上层使用的协议；</li>
<li><strong>数据</strong>  ：长度在 46-1500 之间，如果太小则需要填充；</li>
<li><strong>FCS</strong>  ：帧检验序列，使用的是 CRC 检验方法；</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/164944d3-bbd2-4bb2-924b-e62199c51b90.png" width="500"/> </div><br>
<h2 id="交换机">交换机</h2>
<p><mark>交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射</mark>。</p>
<p>正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。</p>
<p>下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a4444545-0d68-4015-9a3d-19209dc436b3.png" width="800"/> </div><br>
<h2 id="虚拟局域网">虚拟局域网</h2>
<p>虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。</p>
<p>例如下图中 (A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。</p>
<p>使用 VLAN 干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连 VLAN 交换机。IEEE 定义了一种扩展的以太网帧格式 802.1Q，它 <u> 在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网</u>。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e98e9d20-206b-4533-bacf-3448d0096f38.png" width="500"/> </div><br>
<blockquote>
<p>本文修改自：<a href="https://github.com/CyC2018/CS-Notes">https://github.com/CyC2018/CS-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>CyC2018</tag>
      </tags>
  </entry>
  <entry>
    <title>计网之 ACL 访问控制列表</title>
    <url>/posts/240306203742.html</url>
    <content><![CDATA[<p>访问控制列表 ACL（Access Control List）是一系列用于识别报文流的规则集合。这里的规则是指描述报文匹配条件的判断语句，匹配条件可以是报文的源地址、目的地址、端口号等。设备依据 ACL 规则识别出特定的报文，并根据预先设定的策略对其进行处理，从而可以实现堆网络访问行为的控制、限制网络流量、提高网络性能、防止网络攻击等。</p>
<span id="more"></span>
<h1 id="ACL 应用场景">ACL 应用场景</h1>
<h2 id="允许或拒接流量通过">允许或拒接流量通过</h2>
<p>ACL 可以通过定义规则来允许（permit）或拒绝（deny）流量的通过。例如，下图允许主机 A 和 B 访问互联网、不允许访问服务器，主机 C 和 D 与其相反。</p>
<img src="../images/computer-network/acl-1.png" alt="ACL 允许或拒接流量通过" width="80%" height="80%">
<p>我们可以使用如下 basic ACL 规则实现，并对接口 G0/0/0 和 G0/0/1 出方向上的报文进行过滤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[RTA]acl basic 2000                                                             </span><br><span class="line">[RTA-acl-ipv4-basic-2000]rule permit source 192.168.1.0 0.0.0.255               </span><br><span class="line">[RTA-acl-ipv4-basic-2000]rule deny source 192.168.2.0 0.0.0.255                 </span><br><span class="line">[RTA]interface GigabitEthernet 0/0/0                                            </span><br><span class="line">[RTA-GigabitEthernet0/0/0]packet-filter 2000 outbound                           </span><br><span class="line">[RTA]interface GigabitEthernet 0/0/1                                            </span><br><span class="line">[RTA-GigabitEthernet0/0/1]packet-filter 2000 outbound                           </span><br></pre></td></tr></table></figure>
<h2 id="匹配后执行特定行为">匹配后执行特定行为</h2>
<p>ACL 可以根据需求来定义过滤的条件以及匹配条件后所执行的动作。例如，下图对主机 C 和 D 在入方向（inbound）进行匹配，并对匹配到的感兴趣流量进行加密之后再转发。</p>
<img src="../images/computer-network/acl-2.png" alt="ACL 匹配后执行特定行为" width="80%" height="80%">
<h1 id="ACL 分类">ACL 分类</h1>
<p>根据不同的划分规则，ACL 可以有不同的分类。最常见的三种分类是基本 ACL、高级 ACL 和二层 ACL，其中高级 ACL 可以定义比基本 ACL 更准确、更丰富、更灵活的规则。</p>
<table>
<thead>
<tr>
<th><div style="width: 100px">ACL 类型</div></th>
<th><div style="width: 100px">编号范围</div></th>
<th>规则制定依据</th>
</tr>
</thead>
<tbody>
<tr>
<td>基本 ACL</td>
<td>2000-2999</td>
<td>报文的源 IP 地址</td>
</tr>
<tr>
<td>高级 ACL</td>
<td>3000-3999</td>
<td>报文的源 / 目的 IP 地址、源 / 目的端口号以及协议类型等信息</td>
</tr>
<tr>
<td>二层 ACL</td>
<td>4000-4999</td>
<td>报文的源 / 目的 MAC 地址、链路层协议类型等二层信息</td>
</tr>
</tbody>
</table>
<h1 id="ACL 规则">ACL 规则</h1>
<img src="../images/computer-network/acl-3.png" alt="根据 ACL 规则过滤流量" width="80%" height="80%">
<p>一个 ACL 由多条 deny 或 permit 语句组成。设备逐条匹配规则，<strong>找到匹配的规则后执行对应动作，不再继续匹配后续规则</strong>。</p>
<blockquote>
<p>本示例中，RTA 收到了来自两个网络的报文。默认情况下，RTA 会依据 ACL 的配置顺序来匹配这些报文。网络 172.16.0.0/24 发送的数据流量将被 RTA 上配置的 ACL2000 的规则 15 匹配，因此会被拒绝；而来自网络 172.17.0.0/24 的报文不能匹配访问控制列表中的任何规则，因此 RTA 对报文不做任何处理，而是正常转发。</p>
</blockquote>
<p>需要注意的是，ACL 中定义的这些 <strong> 规则可能存在重复或矛盾</strong>，规则的匹配顺序决定了规则的优先级，ACL 通过设置规则的优先级（这里是 ACL ID 越小优先级越高）来处理规则之间重复或矛盾的情形。</p>
<p>ACL 的规则匹配顺序有以下两种：</p>
<ul>
<li><strong>配置顺序</strong>：按照规则编号由小到大进行匹配。默认情况按编号步长为 5 添加规则，用户也可指定编号添加规则，若指定的编号已经存在对应的规则，则替换它。</li>
<li><strong>自动排序</strong>：按照「深度优先」原则由深到浅进行匹配，各类 ACL 的「深度优先」排序法则如表所示。</li>
</ul>
<table>
<thead>
<tr>
<th>ACL 类型</th>
<th>排序原则</th>
</tr>
</thead>
<tbody>
<tr>
<td>基本 ACL</td>
<td>a. 先判断规则的匹配条件中是否包含 VPN 实例，包含者优先 <br> b. 如果 VPN 实例的包含情况相同，再比较源 IPv4 (IPv6) 地址范围，较小者优先 <br> c. 如果源 IPv4 (IPv6) 地址范围也相同，再比较配置的先后次序，先配置者优先</td>
</tr>
<tr>
<td>高级 ACL</td>
<td>a. 先判断规则的匹配条件中是否包含 VPN 实例，包含者优先 <br> b. 如果 VPN 实例的包含情况相同，再比较协议范围，指定有 IPv4 (IPv6) 承载的协议类型者优先 <br> c. 如果协议范围也相同，再比较源 IPv4 (IPv6) 地址范围，较小者优先 <br> d. 如果源 IPv4 地址范围也相同，再比较目的 IPv4 (IPv6) 地址范围，较小者优先 <br> e. 如果目的 IPv4 (IPv6) 地址范围也相同，再比较四层端口号的覆盖范围，较小者优先 <br> f. 如果四层端口号的覆盖范围无法比较，再比较配置的先后次序，先配置者优先</td>
</tr>
<tr>
<td>二层 ACL</td>
<td>a. 先比较源 MAC 地址范围，较小者优先 <br> b. 如果源 MAC 地址范围相同，再比较目的 MAC 地址范围，较小者优先 <br> c. 如果目的 MAC 地址范围也相同，再比较配置的先后次序，先配置者优先</td>
</tr>
</tbody>
</table>
<blockquote>
<p>比较 IPv4 地址范围，就是比较通配符掩码（反向掩码）中 “0” 位的多少，“0” 位越多，范围越小。比较 IPv6 地址范围，就是比较地址前缀长度，前缀越长，范围越小。比较 MAC 地址范围，就是比较掩码中 “1” 位的多少，“1” 位越多，范围越小。</p>
</blockquote>
<h1 id="高级 ACL">高级 ACL</h1>
<p>高级 ACL 可以定义比基本 ACL 更准确、更丰富、更灵活的规则。假设下图中，我们要求主机 A 不可以访问 SFTP 服务器的 FTP 服务，主机 B 不可以访问私有服务器。</p>
<img src="../images/computer-network/acl-4.png" alt="高级 ACL 规则" width="80%" height="80%">
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[RTA]acl advanced 3000                                                          </span><br><span class="line">[RTA-acl-ipv4-adv-3000]rule deny tcp source 192.168.1.0 0.0.0.255 destination 17</span><br><span class="line">2.16.10.1 0.0.0.0 destination-port eq 21                                        </span><br><span class="line">[RTA-acl-ipv4-adv-3000]rule deny tcp source 192.168.2.0 0.0.0.255 destination 17</span><br><span class="line">2.16.10.2 0.0.0.0                                                               </span><br><span class="line">[RTA-acl-ipv4-adv-3000]rule permit ip                                           </span><br><span class="line">[RTA]interface GigabitEthernet 0/0/0                                            </span><br><span class="line">[RTA-GigabitEthernet0/0/0]packet-filter 3000 outbound                           </span><br></pre></td></tr></table></figure>
<p>上述进行了高级 ACL 的配置：</p>
<ul>
<li>rule 5 拒绝了主机 A 访问 SFTP 服务器的 FTP 服务，但 telnet 服务（目的端口为 23）和 ping（ICMP 协议）访问不受限制；</li>
<li>rule 10 拒接了主机 B 访问私有服务器的所有 tcp 流量；</li>
<li>rule 15 作为最低优先级，允许了任意 ip 协议。</li>
<li>最后，在流量的出方向进行包过滤。</li>
</ul>
<p>tcp 流量有握手机制，假如我们 <strong> 仅在</strong>RTA 的 G0/0/0 方向限制 SFTP 服务器或私有服务器的流量进入（inbound），这会影响到 tcp 握手的建立，导致主机 A 的 tcp 流量无法连接到服务器。</p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://www.bilibili.com/video/BV1zy4y1t7Fj/">https://www.bilibili.com/video/BV1zy4y1t7Fj/</a></li>
<li><a href="https://www.h3c.com/cn/d_201905/1181948_30005_0.htm">https://www.h3c.com/cn/d_201905/1181948_30005_0.htm</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>访问控制列表</category>
      </categories>
      <tags>
        <tag>ACL</tag>
        <tag>访问控制列表</tag>
      </tags>
  </entry>
  <entry>
    <title>计网之 OSI 模型</title>
    <url>/posts/231011192359.html</url>
    <content><![CDATA[<p> 本文介绍了 OSI 参考模型中，各层代表的设备、数据单元、服务对象以及 OSI 模型和 TCP/IP 模型的比较。从物理层到应用层，介绍了不同层次的功能和服务对象，以及数据单元在各层之间的传输和封装过程。</p>
<span id="more"></span>
<h2 id="计算机网络各层代表设备"> 计算机网络各层代表设备 </h2>
<ul>
<li> 物理层：网卡、网线、光纤、atm 线缆等 </li>
<li> 数据链路层：二层交换机 </li>
<li> 网络层：路由器、三层交换机、防火墙 </li>
<li> 传输层：代表协议，如 TCP &amp; UDP</li>
<li> 应用层：各种协议，如 HTTP &amp; SMTP &amp; FTP</li>
</ul>
<h2 id="OSI 模型中各层单位">OSI 模型中各层单位 </h2>
<p> 在计算机网络中，有许多不同的概念用于描述数据在不同层次的传输和封装。以下是这些概念的简要介绍：</p>
<table>
<thead>
<tr>
<th><div style="width: 80px"> 数据单元 </div></th>
<th><div style="width: 80px"> 所在层次 </div></th>
<th> 描述 </th>
</tr>
</thead>
<tbody>
<tr>
<td>message</td>
<td> 应用层 </td>
<td> 在应用层发送和接收的数据单元，它可以是任意大小的数据块 </td>
</tr>
<tr>
<td>segment</td>
<td> 传输层 </td>
<td> 在传输层（如 TCP）中使用的数据单元，segment 包含了源端口号和目的端口号，并提供可靠的、有序的数据传输 </td>
</tr>
<tr>
<td>datagram</td>
<td> 网络层 </td>
<td> 在网络层（如 IP）中使用的数据单元，datagram 包含了源 IP 和目的 IP，并提供不可靠的、无序的数据传输 </td>
</tr>
<tr>
<td>packet</td>
<td> 网络层通用 </td>
<td> 在网络层中使用的通用术语，用于表示在网络中传输的数据单元，可以指代 segment 或 datagram</td>
</tr>
<tr>
<td>frame</td>
<td> 数据链路层 </td>
<td> 在数据链路层中使用的数据单元，frame 包含了物理地址（如 MAC 地址）和错误检测码，用于在物理网络中传输数据 </td>
</tr>
<tr>
<td>bit</td>
<td> 物理层 </td>
<td> 是计算机网络中最小的数据单位，用于表示二进制的 0 或 1</td>
</tr>
</tbody>
</table>
<h2 id="OSI 模型中各层的服务对象">OSI 模型中各层的服务对象 </h2>
<p> 不同层之间是在为谁提供服务呢？</p>
<p> 应用层为应用程序提供服务，传输层为应用层提供端到端的数据传输服务，网络层为传输层提供网络间的数据传输服务，数据链路层为网络层提供主机到主机的数据传输服务。</p>
<ol>
<li> 应用层为应用程序提供服务。</li>
<li> 传输层主要为进程提供端到端的通信服务。
<ul>
<li> 传输层使用端口号来标识不同的进程，将应用层的数据划分为较小的数据单元（segment），并通过网络传输到目的地。</li>
<li> 传输层可以提供可靠的数据传输，保证数据的完整性和顺序性。</li>
<li> 此外，传输层还负责多个进程间的数据分发和复用，可以同时为多个进程提供服务。</li>
</ul>
</li>
<li> 网络层主要为主机提供服务。
<ul>
<li> 网络层负责将传输层的数据单元（segment）打包成网络层的数据单元（datagram），并通过网络进行传输。</li>
<li> 网络层使用 IP 地址来标识主机和网络，通过路由选择算法将数据传输到目的地，实现主机间的通信。</li>
</ul>
</li>
<li> 数据链路层主要为同一链路上的主机或设备提供服务。
<ul>
<li> 数据链路层负责将网络层的数据单元（datagram）打包成数据链路层的数据单元（frame），并通过物理链路进行传输。</li>
<li> 数据链路层使用 MAC 地址来标识主机或设备，通过帧的发送和接收来实现同一链路上的通信。</li>
</ul>
</li>
</ol>
<p> 总结成表格如下：</p>
<table>
<thead>
<tr>
<th><div style="width: 80px"> 所在层级 </div></th>
<th> 功能 </th>
<th><div style="width: 80px"> 服务的对象 </div></th>
</tr>
</thead>
<tbody>
<tr>
<td> 应用层 </td>
<td> 为应用程序提供服务 </td>
<td> 应用程序 </td>
</tr>
<tr>
<td> 传输层 </td>
<td> 为进程提供端到端的通信服务，划分数据单元，保证数据传输可靠性和顺序性，数据分发和复用 </td>
<td> 进程 </td>
</tr>
<tr>
<td> 网络层 </td>
<td> 为主机提供服务，将传输层的数据单元打包成网络层的数据单元，通过网络进行传输，寻址和路由选择，实现主机间通信 </td>
<td> 主机 </td>
</tr>
<tr>
<td> 数据链路层 </td>
<td> 为同一链路上的主机或设备提供服务，将网络层的数据单元打包成数据链路层的数据单元，通过物理链路进行传输，帧的封装和解封装，帧的传输和错误检测，介质访问控制 </td>
<td> 同一链路上的主机或设备 </td>
</tr>
<tr>
<td> 物理层 </td>
<td> 通过物理链路进行数据传输，数据的编码和解码，数据的传输和接收 </td>
<td> 物理链路上的设备和传输介质等 </td>
</tr>
</tbody>
</table>
<h2 id="OSI-vs-TCP-IP 模型">OSI vs. TCP/IP 模型 </h2>
<p><img src="../images/computer-network/OSI-TCP-model.png" alt="OSI vs. TCP/IP 模型"></p>
<h2 id="OSI 模型数据封装与解封装过程">OSI 模型数据封装与解封装过程 </h2>
<p><img src="../images/computer-network/OSI-data-encapsulation-unpacking.png" alt="OSI 模型数据封装与解封装过程"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>OSI模型</tag>
      </tags>
  </entry>
  <entry>
    <title>计网之 VXLAN 网络虚拟化技术</title>
    <url>/posts/231221200716.html</url>
    <content><![CDATA[<p>本文介绍 VLAN 和 VXLAN 网络虚拟化技术，并同时给出了 <code>Access</code>、<code>Trunk</code> 和 <code>Hybrid</code> 端口的区别，以及它们对 VLAN 报文的处理方式。</p>
<span id="more"></span>
<h1 id="VLAN- 封装">VLAN 封装</h1>
<p>要使网络设备能够分辨不同的 VLAN 报文，需要在报文中添加标识 VLAN 的字段。由于 <strong> 二层交换机工作在数据链路层</strong>，只能对报文的数据链路层封装进行识别。因此，如果添加识别字段，也需要添加到数据链路层封装中。</p>
<p>IEEE 802.1Q 协议规定，在以太网报文的目的 MAC 地址和源 MAC 地址之后、协议类型字段之前 <strong> 加入 4 个字节的 VLAN Tag，用以标识 VLAN 的相关信息</strong>。</p>
<img src="../images/computer-network/vlan-tag.png" alt="VLAN 数据帧" width="80%" height="80%">
<ul>
<li><code>TPID</code> 用来表示报文是否带有 VLAN Tag，长度为 16 bits，缺省情况下，<code>TPID</code> 取值为 <code>0x8100</code>，表示数据帧中包括 VLAN Tag，但各设备厂商可以自定义该字段的值。</li>
<li><code>VID</code> 用来表示该报文所属 VLAN 的编号，长度为 12 bits，取值范围可为 <code>[0, 4095]</code>。由于 <code>0</code> 和 <code>4095</code> 为协议保留取值，所以 <code>VID</code> 的实际取值范围为 <code>[1, 4094]</code>。</li>
</ul>
<p>网络设备根据报文是否携带 VLAN Tag 以及携带的 VLAN Tag 信息，来对报文进行处理，<strong>利用 <code>VID</code> 来识别报文所属的 VLAN</strong>。</p>
<blockquote>
<p>因为 <code>VID</code> 的实际取值范围为 <code>[1, 4094]</code>，所以最多可以划分 4094 个不同的 VLAN 网络。</p>
</blockquote>
<h1 id="基于端口的 VLAN">基于端口的 VLAN</h1>
<p>基于端口划分 VLAN 是最简单、最有效的 VLAN 划分方法。它按照设备端口来定义 VLAN 成员，将指定端口加入到指定 VLAN 中之后，该端口就可以转发该 VLAN 的报文。</p>
<h2 id="Access-Trunk-Hybird 端口区别">Access&amp;Trunk&amp;Hybird 端口区别</h2>
<p>端口的链路类型分为三种，端口的链路类型决定了端口能否加入多个 VLAN。不同链路类型的端口在转发报文时对 VLAN Tag 的处理方式不同。</p>
<ul>
<li>
<p><code>Access</code> 端口：只能发送一个 VLAN 的报文，不带 VLAN Tag。</p>
<ul>
<li>一般用于和不能识别 VLAN Tag 的用户终端设备相连，或者不需要区分不同 VLAN 成员时使用。</li>
</ul>
</li>
<li>
<p><code>Trunk</code> 端口：可以发送多个 VLAN 的报文，缺省 VLAN 的报文不带 VLAN Tag，其他 VLAN 的报文必须带 VLAN Tag。</p>
<ul>
<li>通常用于网络传输设备之间的互连。</li>
</ul>
</li>
<li>
<p><code>Hybrid</code> 端口：可以发送多个 VLAN 的报文，并可根据需要配置某些 VLAN 的报文带 VLAN Tag，某些 VLAN 的报文不带 VLAN Tag。</p>
<ul>
<li>在一些应用场景下，需要使用 <code>Hybrid</code> 端口的功能。比如在 1:2 VLAN 映射中，服务提供商网络的多个 VLAN 的报文在进入用户网络前，需要剥离外层 VLAN Tag，此时 <code>Trunk</code> 端口不能实现该功能，因为 <code>Trunk</code> 端口只能使该端口缺省 VLAN 的报文不带 VLAN Tag 通过。</li>
</ul>
</li>
</ul>
<h2 id="端口缺省 -VLAN">端口缺省 VLAN</h2>
<p>端口缺省 VLAN 简称为 PVID（Port VLAN ID）。当端口收到 <code>Untagged</code> 报文时，会认为该报文所属的 VLAN 为 PVID。</p>
<ul>
<li><code>Access</code> 端口的 PVID 就是它所在的 VLAN。</li>
<li><code>Trunk</code> 端口和 <code>Hybrid</code> 端口可以允许多个 VLAN 通过，能够配置端口 PVID。</li>
</ul>
<h2 id="端口对报文的处理方式">端口对报文的处理方式</h2>
<p>端口对报文的接收和发送的处理有几种不同情况。</p>
<p><strong><code>Access</code> 端口</strong>：</p>
<ul>
<li>接收：
<ul>
<li>接收的报文不带 TAG：为报文添加端口 PVID 的 Tag；</li>
<li>接收的报文带 TAG：当报文的 VLAN ID 与端口的 PVID 相同（不同）时，接收（丢弃）该报文。</li>
</ul>
</li>
<li>发送：去掉 TAG，发送该报文。</li>
</ul>
<p><strong><code>Trunk</code> 端口</strong>：</p>
<ul>
<li>接收：
<ul>
<li>接收的报文不带 TAG：当端口的 PVID 在（不在）端口允许通过的 VLAN ID 列表里时，接收该报文，给报文添加 PVID 的 Tag（丢弃该报文）。</li>
<li>接收的报文带 TAG：当报文的 VLAN ID 在（不在）端口允许通过的 VLAN ID 列表里时，接收（丢弃）该报文。</li>
</ul>
</li>
<li>发送：当报文的 VLAN ID 与端口的 PVID 相同（不同），且是该端口允许通过的 VLAN ID 时：去掉 Tag（保持原有 Tag），发送该报文。</li>
</ul>
<p><strong><code>Hybird</code> 端口</strong>：</p>
<ul>
<li>接收：
<ul>
<li>接收的报文不带 TAG：当端口的 PVID 在（不在）端口允许通过的 VLAN ID 列表里时，接收该报文，给报文添加 PVID 的 Tag（丢弃该报文）。</li>
<li>接收的报文带 TAG：当报文的 VLAN ID 在（不在）端口允许通过的 VLAN ID 列表里时，接收（丢弃）该报文。</li>
</ul>
</li>
<li>发送：当报文的 VLAN ID 是端口允许通过的 VLAN ID 时，发送该报文，并可以配置端口在发送该 VLAN 的报文时是否携带 Tag。</li>
</ul>
<h1 id="VXLAN">VXLAN</h1>
<h2 id="VXLAN- 简介">VXLAN 简介</h2>
<p>VXLAN（Virtual eXtensible LAN，可扩展虚拟局域网络）是一种基于 IP 网络构建逻辑拓扑、采用 MAC in UDP 封装的 <strong> 二层 VPN 技术 </strong>。VXLAN 可以基于已有的服务提供商或企业 IP 网络，为分散的物理站点提供二层和三层互联，并能为不同用户提供业务隔离服务。VXLAN 主要应用于数据中心网络，能够创建<strong> 更多 </strong> 的虚拟网络。</p>
<h2 id="VXLAN- 技术价值">VXLAN 技术价值</h2>
<ul>
<li>
<p>VXLAN 支持大量租户：支持多达 1600 万个相互隔离的二层网络，解决了传统二层网络 VLAN 资源不足问题。</p>
</li>
<li>
<p>VXLAN 网络易于维护：基于 IP 网络构建大二层网络，将原始二层数据帧封装成 VXLAN 报文，在 IP 网络中透传，充分利用现有 IP 网络技术，部署和维护更容易。</p>
</li>
<li>
<p>VXLAN 网络保证虚拟机动态迁移：采用 MAC in UDP 的封装方法，保证虚拟机迁移前后的 IP 和 MAC 不变。</p>
</li>
</ul>
<h2 id="VXLAN- 网络模型">VXLAN 网络模型</h2>
<p>VXLAN 技术将已有的三层物理网络作为 Underlay 网络，在其上构建出虚拟的二层网络，即 Overlay 网络。Overlay 网络通过封装技术、利用 Underlay 网络提供的三层转发路径，实现租户二层报文跨越三层网络在不同站点间传递。</p>
<p>对于租户来说，Underlay 网络是透明的，同一租户的不同站点就像工作在一个局域网中。Underlay 网络既可以是 IPv4 网络，也可以是 IPv6 网络。</p>
<p><img src="https://pic1.zhimg.com/80/v2-cd8549811c9630cb8e385fca11f53718_720w.webp" alt="VXLAN 网络模型示意图"></p>
<ul>
<li>
<p>VTEP（VXLAN Tunnel End Point，VXLAN 隧道端点）：VXLAN 的边缘设备。VXLAN 的相关处理都在 VTEP 上进行，例如识别以太网数据帧所属的 VXLAN、基于 VXLAN 对数据帧进行二层转发、封装 / 解封装报文等。VTEP 可以是网络设备（比如交换机），也可以是一台机器（比如虚拟化集群中的宿主机）。</p>
</li>
<li>
<p>VNI（VXLAN Network Identifier，VXLAN 网络标识符）：VNI 是每个 VXLAN 段的标识，是个 24 位整数，一共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>24</mn></msup><mo>=</mo><mn>16777216</mn></mrow><annotation encoding="application/x-tex">2^{24} = 16777216</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord">7</span><span class="mord">7</span><span class="mord">7</span><span class="mord">2</span><span class="mord">1</span><span class="mord">6</span></span></span></span>，一般每个 VNI 对应一个租户，也就是说使用 VXLAN 搭建的公有云可以理论上可以支撑千万级别的租户。</p>
</li>
<li>
<p>Tunnel（VXLAN 隧道）：两个 VTEP 之间的点到点逻辑隧道，负责在 IP 网络中转发 VXLAN 报文。VTEP 为数据帧封装 VXLAN 头、UDP 头和 IP 头后，通过 VXLAN 隧道将封装后的报文转发给远端 VTEP，远端 VTEP 对其进行解封装。</p>
</li>
</ul>
<p>上图所示为 VXLAN 的工作模型，它创建在原来的 IP 网络（三层）上，只要是三层可达（能够通过 IP 相互通信）的网络就能部署 VXLAN。在 VXLAN 网络的每个端点都有一个 VTEP 设备，负责 VXLAN 协议报文的解包和封包。</p>
<p>物理网络上可以创建多个 VXLAN 网络，可以将这些 VXLAN 网络看成一个隧道，不同节点上的虚拟机 / 容器能够通过隧道直连。通过 VNI 标识不同的 VXLAN 网络，使得不同的 VXLAN 可以相互隔离。</p>
<h2 id="VXLAN- 封装">VXLAN 封装</h2>
<p>MAC in UDP 封装：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Eth-Layer(14) + IP-Layer(20/40) + UDP-Layer(8) + VXLAN-Layer(8) + </span><br><span class="line">Eth-Layer(14/18) +  IP-Layer(20/40) + L4-Layer(8/20) + Payload // 封装三层报文</span><br><span class="line"></span><br><span class="line">Eth-Layer(14) + IP-Layer(20/40) + UDP-Layer(8) + VXLAN-Layer(8) + </span><br><span class="line">Eth-Layer(14/18) + Payload // 封装二层报文</span><br></pre></td></tr></table></figure>
<img src="../images/computer-network/vxlan-format.png" alt="VXLAN 数据帧格式" width="80%" height="80%">
<ul>
<li>
<p>VXLAN Header：在原始二层帧的前面添加 8 字节的 VXLAN 的头部，其中最主要的是 <code>VNID</code>，占用 3 个字节（即 24 bit），类似 VLAN ID，可以具有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>24</mn></msup></mrow><annotation encoding="application/x-tex">2^{24}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span> 个网段。</p>
</li>
<li>
<p>UDP Header：在 VXLAN 和原始二层帧的前面使用 8 字节 UDP 头部进行封装（MAC IN UDP），<strong>目的端口号缺省使用 4789 作为 VXLAN 的默认目的端口号</strong>，源端口按流随机分配（通过 MAC、IP、四层端口号进行 hash 操作）， 这样可以更好的做 ECMP。</p>
</li>
</ul>
<blockquote>
<p>在上面「添加的二层封装」之后，再添加底层网络的 IP 头部（20 字节 / 40 字节）和 MAC 头部（<code>Access</code> 端口为 14 字节、<code>Trunk</code> 端口为 18 字节），这里的 IP 和 MAC 是宿主机的 IP 地址和 MAC 地址。</p>
</blockquote>
<p>VXLAN 封装的报文示例：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">5c dd 70 b4 b6 5e 48 73 97 2b eb 7b 08 00 45 00 01 4c 06 ac 00 00</span><br><span class="line">ff 11 03 22 0a 14 06 1e 50 50 50 51 c9 56 12 b5 01 38 00 00 08 00</span><br><span class="line">00 00 00 00 0a 00 00 00 67 a5 ab 3f 00 00 67 a5 ab 3e 08 00 45 00 </span><br><span class="line">01 1a 00 00 00 00 40 11 15 6c 32 00 00 02 32 00 00 66 04 27 08 0f </span><br><span class="line">01 06 f6 bb 00 02 00 04 83 dc 89 76 00 00 00 00 00 00 00 01 00 00 </span><br><span class="line">00 00 01 bd 0d 28 00 00 00 00 00 04 47 90 00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 93 1c 05 cc 22 14 31 5c 49 78 69 60 a0 00 </span><br><span class="line">00 00 10 11 12 13 69 d7 15 de 00 b2 1a 1b 1c 1d 1e 1f 20 21 22 23 </span><br><span class="line">24 25 26 27 28 29 2a 2b 2c 2d 2e 2f 30 31 32 33 34 35 36 37 38 39 </span><br><span class="line">3a 3b 3c 3d 3e 3f 40 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f </span><br><span class="line">50 51 52 53 54 55 56 57 58 59 5a 5b 5c 5d 5e 5f 60 61 62 63 64 65 </span><br><span class="line">66 67 68 69 6a 6b 6c 6d 6e 6f 70 71 72 73 74 75 76 77 78 79 7a 7b </span><br><span class="line">7c 7d 7e 7f 80 81 82 83 84 85 86 87 88 89 8a 8b 8c 8d 8e 8f 90 91 </span><br><span class="line">92 93 94 95 96 97 98 99 9a 9b 9c 9d 9e 9f a0 a1 a2 a3 a4 a5 a6 a7 </span><br><span class="line">a8 a9 aa ab ac ad ae af b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 ba bb bc bd </span><br><span class="line">be bf c0 c1 c2 c3 c4 c5 c6 c7 c8 c9 ca cb 86 d4</span><br></pre></td></tr></table></figure>
<img src="../images/computer-network/vxlan-packet.png" alt="VXLAN 报文" width="80%" height="80%">
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>VXLAN</tag>
      </tags>
  </entry>
  <entry>
    <title>计网之路由表、转发表与快速转发工作原理</title>
    <url>/posts/240130190208.html</url>
    <content><![CDATA[<p>本文介绍路由表（Routing Information Base, RIB）、转发表（Forwarding Information Base, FIB）和快速转发（Fast Forwarding）的相关概念和工作原理。</p>
<span id="more"></span>
<h1 id="相关概念">相关概念</h1>
<h2 id="路由表">路由表</h2>
<p>路由表（Routing Information Base, RIB）：路由表是网络设备（如路由器）中存储的一张表格，<strong>记录了网络中各个目的地的网络地址、下一跳地址 </strong> 以及其他相关信息。路由表中的每一条路由记录都包含了目的地址（Destination/Mask）和相应的下一跳（NextHop）信息，<strong>用于确定数据的转发路径</strong>。例如，发往目的地 <code>10.20.1.10</code> 的数据将会匹配到 <code>10.20.1.0/24</code> 这条路由，其下一跳地址是 <code>10.20.1.11</code>，数据将从出口接口 <code>GE0/0/0</code> 转发出去。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[RTA]display ip routing-table                                                   </span><br><span class="line">                                                                                </span><br><span class="line">Destinations : 8 Routes : 8                                                     </span><br><span class="line">                                                                                </span><br><span class="line">Destination/Mask   Proto   Pre Cost        NextHop         Interface            </span><br><span class="line">0.0.0.0/32         Direct  0   0           127.0.0.1       InLoop0              </span><br><span class="line">10.20.1.0/24       Direct  0   0           10.20.1.11      GE0/0/0              </span><br><span class="line">10.20.1.11/32      Direct  0   0           127.0.0.1       InLoop0              </span><br><span class="line">10.20.1.255/32     Direct  0   0           10.20.1.11      GE0/0/0              </span><br><span class="line">127.0.0.0/8        Direct  0   0           127.0.0.1       InLoop0              </span><br><span class="line">127.0.0.1/32       Direct  0   0           127.0.0.1       InLoop0              </span><br><span class="line">127.255.255.255/32 Direct  0   0           127.0.0.1       InLoop0              </span><br><span class="line">255.255.255.255/32 Direct  0   0           127.0.0.1       InLoop0              </span><br><span class="line">[RTA]</span><br><span class="line"></span><br><span class="line">[RTA]dis interface brief                                                        </span><br><span class="line">Brief information on interfaces in route mode:                                  </span><br><span class="line">Link: ADM - administratively down; Stby - standby                               </span><br><span class="line">Protocol: (s) - spoofing                                                        </span><br><span class="line">Interface                         Link Protocol Primary IP        Description   </span><br><span class="line"></span><br><span class="line">GE0/0/0                           UP   UP       10.20.1.11</span><br></pre></td></tr></table></figure>
<h2 id="转发表">转发表</h2>
<p>转发表（Forwarding Information Base, FIB）：转发表是路由器或交换机中的一个数据结构，用于存储 <strong> 从路由表中提取的转发信息 </strong>。FIB 中的记录是根据路由表中的路由信息进行<strong> 提取和优化的，以方便快速转发数据包</strong>。FIB 中的每一条记录都包含了目的地址和相应的出口接口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[RTA]display fib                                                                </span><br><span class="line">Route destination count: 8                                                      </span><br><span class="line">Directly-connected host count: 0                                                </span><br><span class="line">Entries issued to hardware: 6                                                   </span><br><span class="line">                                                                                </span><br><span class="line">Flag:                                                                           </span><br><span class="line">  U:Usable    G:Gateway   H:Host   B:Blackhole   D:Dynamic   S:Static           </span><br><span class="line">  R:Relay     F:FRR</span><br><span class="line">  # 依次是可用路由、网关路由、主机路由、黑洞路由、动态理由、静态路由              </span><br><span class="line">  # 迭代路由、快速重路由                                                         </span><br><span class="line">                   下一跳地址    路由标志   转发接口 / LSP 索引号                 </span><br><span class="line">Destination/Mask   Nexthop         Flag     OutInterface/Token       Label      </span><br><span class="line">0.0.0.0/32         127.0.0.1       UH       InLoop0                  Null       </span><br><span class="line">10.20.1.0/24       10.20.1.11      U        GE0/0/0                  Null       </span><br><span class="line">10.20.1.11/32      127.0.0.1       UH       InLoop0                  Null       </span><br><span class="line">10.20.1.255/32     10.20.1.11      UBH      GE0/0/0                  Null       </span><br><span class="line">127.0.0.0/8        127.0.0.1       U        InLoop0                  Null       </span><br><span class="line">127.0.0.1/32       127.0.0.1       UH       InLoop0                  Null       </span><br><span class="line">127.255.255.255/32 127.0.0.1       UH       InLoop0                  Null       </span><br><span class="line">255.255.255.255/32 127.0.0.1       UH       InLoop0                  Null       </span><br><span class="line">[RTA]</span><br></pre></td></tr></table></figure>
<h2 id="快速转发表">快速转发表</h2>
<p>快速转发表（Fast Forwarding Table）：快速转发表是 <strong> 在 FIB 的基础上进行进一步优化 </strong> 的数据结构。它是网络设备中的 <strong> 一个高速缓存 </strong>，用于存储<strong> 最常用 </strong> 的转发信息。快速转发表中的记录是经过优化和加速的，<strong>以提高数据包的转发速度</strong>。快速转发表中的每一条记录都包含了目的地地址和相应的出口接口。</p>
<blockquote>
<p>转发表和快速转发表都是基于路由表的衍生物，用于加速数据包的转发过程。</p>
</blockquote>
<h2 id="路由转发分组">路由转发分组</h2>
<p>路由转发分组：路由转发分组是指网络设备（如路由器）根据接收到的数据包的目的地址，通过查询 <s> 路由表 </s>FIB 表，选择合适的出口接口将数据包转发到下一跳<strong> 的过程 </strong>。<s> 路由表</s>FIB 表是路由转发分组的基础和依据。</p>
<h1 id="路由表工作原理">路由表工作原理</h1>
<p>在一张路由表中，当存在多个路由项可同时匹配目的地址时，路由查找进程会 <strong> 选择掩码（Mask）最长的路由项用于转发</strong>，即最长匹配原则。因为掩码越长，所处的网段范围就越小，网段的范围越小，就越能快速的定位到 PC 机的具体位置，从而加快转发效率。</p>
<p>例子：在运行了 RIP (Routing Information Protocol，一种用于路由选择的动态路由协议) 的路由器上看到如下路由信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;RTA&gt;display ip routing-table 6.6.6.6</span><br><span class="line"></span><br><span class="line">Routing Table: Public</span><br><span class="line"></span><br><span class="line">Summary Count: 2</span><br><span class="line"></span><br><span class="line">Destination/Mask Proto Pre Cost  NextHop  Interface</span><br><span class="line"></span><br><span class="line">6.6.6.0/24       RIP   100   1  100.1.1.1  GE0/0</span><br><span class="line">6.0.0.0/8       Static 60    0  100.1.1.1  GE0/0</span><br><span class="line">&lt;RTA&gt;</span><br></pre></td></tr></table></figure>
<p>此时路由器收到一个目的地址为 <code>6.6.6.6</code> 的数据包，那么（A）。</p>
<ul>
<li>A. 该数据包将优先匹配路由表中的 RIP 路由，因为其掩码 Mask 最长。</li>
<li>B. 该数据包将优先匹配路由表中的 RIP 路由，因为其优先级 Pre 高。</li>
<li>C. 该数据包将优先匹配路由表中的静态路由，因为其花费 Cost 小。</li>
<li>D. 该数据包将优先匹配路由表中的静态路由，因为其掩码 Mask 最短。</li>
</ul>
<p>尽管如此，路由表中 <strong> 路由项数量越多 </strong>，所需查找及匹配的次数就越多，其<strong> 转发效率就会降低</strong>。为了实现控制平面与转发平面完全分离，就需要系统构建一张专注于数据报文转发的表，即转发表。</p>
<h1 id="转发表 -v2">转发表</h1>
<h2 id="转发表生成方式">转发表生成方式</h2>
<p>FIB 表的生成有 2 种方式，一种是源于路由表项，另外一种是通过 ARP 解析获得。</p>
<h3 id="源于路由表项">源于路由表项</h3>
<p>第一种方式，当开始计算路由信息的时候，因为在一个网络拓扑结构中，可能会运行多个路由协议，而不同路由协议所计算出的路径可能会不同。</p>
<p>当出现这种情况时，路由器会 <strong> 选择较高路由优先级的路由协议所发现的路由 </strong> 作为最优路由，即比较路由的优先级将其选出，置为 Active（活跃）状态；而其他路由作为备份路由，置为 Inactive（非活跃）状态。<strong>系统会再把 Active 状态的路由表项导入至 FIB 表中，作为系统转发的依据</strong>。</p>
<h3 id="通过 ARP 解析">通过 ARP 解析</h3>
<p>第二种方式，通过 ARP 解析，得到 MAC 地址与目的 IP 地址的映射关系。为了将这个映射关系添加到 FIB 表中，主机需要将目标 IP 地址与对应的 MAC 地址加入到本地网段内的主机路由信息中。最后将主机路由信息添加到 FIB 表中。</p>
<h2 id="转发表工作原理">转发表工作原理</h2>
<p>在 FIB 表生成过程中，需要注意的一点是，<strong>FIB 表与路由表是同步更新的 </strong>。系统的控制平面会发现<em> 新的 </em> 路由信息，根据路由信息更新到自己的路由表中，生成新的 Active 状态的路由表项，再更新至 FIB 表。</p>
<p>路由表属于控制平面，FIB 表属于转发平面，这样便做到了 <strong> 控制平面与转发平面的分离</strong>。如果原路由表中处于 Active 状态的路由表项失效，系统也会删除相关 FIB 表项。</p>
<p>由于 FIB 表 <strong> 全是 </strong> 处于 Active 状态的路由，所以 FIB 表项的 <strong> 数量远远小于 </strong> 路由表项。基于这种特性，在设计的时候，<strong>系统可以将 FIB 表项加载到硬件中，从而加快数据转发速度 </strong>。例如，在某些高端交换机启动后，FIB 表被系统加载到接口业务板的硬件中，<strong> 数据报文再通过硬件转发，不需要再通过 CPU 转发</strong>，可以大大降低转发时延。</p>
<blockquote>
<p>控制平面与转发平面的物理（或逻辑）分离，使得主控板上的 CPU 不负责报文转发，专注于系统的控制；而业务板则专注于数据报文转发。如果主控板损坏，业务板仍然能够转发报文。</p>
</blockquote>
<h1 id="快速转发">快速转发</h1>
<p>路由器常规转发报文的流程：</p>
<p>路由器接收到一个报文后，将它从接口存储器拷贝至 CPU 中，CPU 会根据报文的目的地址寻找 FIB 表中与之匹配的转发项，最终确定一条最佳的路径。与此同时，再将报文按照数据链路层上使用的协议进行封装，最后，封装后的链路层帧通过 DMA（Direct Memory Access，直接内存访问）拷贝至输出队列中进行报文转发。这一个过程经过了 2 次系统总线，每一个报文都要重复这个过程。</p>
<p>路由器性能因素：</p>
<p>衡量路由器性能因素之一是报文的转发效率，报文的转发效率越高，性能就越强。所以，需要再用到快速转发表来进行转发，<strong>快速转发表采用高速缓存来处理报文，使用基于数据流的技术来处理</strong>。</p>
<p>什么是基于数据流？</p>
<p>数据流是指在计算机系统中，数据在各个组件（如程序、模块、子系统等）之间传输和处理的过程。在数据流中，数据经过一系列处理后，输出到下一个组件或者最终输出到终端用户。例如，访问 HTTP 服务的一次操作。</p>
<p>在计算机网络中，一般 <strong> 用一个五元组来描述一个数据流，源 IP 地址、源端口号、目的 IP 地址、目的端口号、协议号 </strong>。当一个数据流的第一个报文通过查找 FIB 表转发后，在高速缓存中生成相应的转发信息，该数据流<strong> 后续报文的转发 </strong> 就可以通过直接查找高速缓存来实现。</p>
<p>例如，<strong>当一个主机需要访问服务器时，主机发出的第一个报文到达路由器的接口后，路由器会查找快速转发表实现快速转发。但由于这个报文是第一个报文，快速转发表中并没有这条数据流的转发信息高速缓存，所以系统无法进行快速转发。便会退而求其次，将报文移交至普通的 FIB 表，由 CPU 负责在 FIB 表中查找相关转发项，然后进行封装，再从接口转发出去。与此同时，系统记录报文中的五元组信息，再高速缓存中会生成相应的快速转发信息</strong>。</p>
<p>系统会根据五元组信息生成相应的快速转发信息缓存。与此同时，也会记录转发时的 <strong> 封装信息及接口信息 </strong>。在当后续报文来到后，系统会查看报文中的五元组，如果命中了快速转发缓存，则会根据缓存中的封装信息<strong> 直接进行 </strong> 二层数据帧的封装。然后，在中断中直接送到出接口发送。这样，<strong>就不需要上报 CPU 进行查表操作，也不需要内存访问操作，更不用占用系统总线资源</strong>。</p>
<p>快速转发技术就在很大程度上缩减了 IP 报文的排队流程，也减少了报文的转发时间。</p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://blog.csdn.net/qq_42603841/article/details/134569517">https://blog.csdn.net/qq_42603841/article/details/134569517</a></li>
<li><a href="https://blog.csdn.net/lynnucas/article/details/78814365">https://blog.csdn.net/lynnucas/article/details/78814365</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>路由转发</category>
      </categories>
      <tags>
        <tag>路由表</tag>
        <tag>转发表</tag>
        <tag>快速转发</tag>
      </tags>
  </entry>
  <entry>
    <title>项目之聊天服务器</title>
    <url>/posts/240904203605.html</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="数据结构设计">数据结构设计</h2>
<p>聊天服务器，有一个服务端和多个客户端。因此，有一个表示聊天服务器的结构<code>chatState</code>，其内维护着每一个客户端的数据，对应结构为<code>client</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This structure represents a connected client. There is very little</span></span><br><span class="line"><span class="comment"> * info about it: the socket descriptor and the nick name, if set, otherwise</span></span><br><span class="line"><span class="comment"> * the first byte of the nickname is set to 0 if not set.</span></span><br><span class="line"><span class="comment"> * The client can set its nickname with /nick &lt;nickname&gt; command. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd;      <span class="comment">// Client socket.</span></span><br><span class="line">    <span class="type">char</span>* nick;  <span class="comment">// Nickname of the client. 客户端名称，默认为 \0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This global structure encapsulates the global state of the chat. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chatState</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> serversock;  <span class="comment">// Listening server socket.</span></span><br><span class="line">    <span class="type">int</span> numclients;  <span class="comment">// Number of connected clients right now.</span></span><br><span class="line">    <span class="type">int</span> maxclient;   <span class="comment">// The greatest &#x27;clients&#x27; slot populated. 最大的 clients fd 值，用于 select()的第一个参数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">client</span>* <span class="title">clients</span>[<span class="title">MAX_CLIENTS</span>];</span>  <span class="comment">// 以 client&#x27;s fd 作为 clients 槽位索引</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="../images/projects/smallchat/1.png" alt="数据结构设计" width="80%" height="80%">
<h2 id="服务端">服务端</h2>
<h3 id="整体流程">整体流程</h3>
<p>首先，定义一个 <code>chatState</code> 类型的全局聊天服务变量 <code>Chat</code>，并申请对应的内存资源，包含指向 MAX_CLIENTS 个客户端的指针数组（当每有客户端连接到服务器时，调用<code>createClient</code> 创建对应的客户端），并初始化各个成员、创建一个服务端的监听 socket（指向 <code>serversock</code> 成员）。</p>
<p>然后，在无限循环的每次循环开始时，将监听 socket 和已连接 socket 添加到可读事件集合中、并进行监听。</p>
<p>最后，当有监听事件就绪时，根据就绪事件的类别（监听 socket、已连接 socket）进行各自的业务处理（接收客户端连接、修改昵称、广播消息）。</p>
<img src="../images/projects/smallchat/2.png" alt="服务端整体流程" width="80%" height="80%">
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>项目模块解析之命令行</title>
    <url>/posts/240327203211.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，这个密码看着不太对，请再试试。" data-whm="抱歉，这个文章不能被校验，不过您还是能看看解密后的内容。">
  <script id="hbeData" type="hbeData" data-hmacdigest="a435883eafe36f14be9b8a3794e1573b7906386bf5d19593470e8049eaf8e22c">296e0e11e5707115aade5aa86d82978cc8e0b187f577349bdaaf317eeb18ec71692c0618a0cdc98c0bcb22471815d4e533b49238edf2f1531c1b11a644a323191c0bee1f676c892bface0ae3e20ec0c8f9097fb02e972982906c5e777683b97f0c046641101a091110b46e6808bc008906cb29d6ef9746036f8af617cd9b7f93146b02a69828706ae7286bf1b2b69929ac4b88c78d179bdd1947a35f3dd02406f2937b6285ca576bbb8ca0b8a2c6b17e343616d4041a6580ec43c633945a08473def43184db7be104371d5073c735711e50ac013b72a236f82e44f4f78cd27a1d6d5f004b714b60b70aa06cf0cf7d00384322a6678022a408849f918e62b09f1bee7685cc7c1109177deb80b39c1ca152252beb85fe18399cdc3f39418a6dcca6050425d8e216777bf8144cf94211e2192f57a66ba4f676fd70f014d218ce2e12d7efe7215f97724c78f00bc70e1785a7327a565a352e7ac3fcf60428177c5d163843d693b99167462a99e1fbf8cc4c0c251d34c3f4257a192a307cfd70126c4c3f6d872312107ef5fac3beb3cf88f86b5b91ff4f71fa39931fa41bd1ac557547d0896296cece8ffaee41ecb1d6459a24d9221056813f84a2f31cbe480bf692324f622de3946e52f920561060dd58966113a4246a72d4147259c00421c1264846551dd7ff8da57a200424e5fa8015b1c8dc35f2f9aa76898146ddb32a9d27f690a97e03e1672bcbd9cc5f20ee84fba6aa853b12e3acbbad7b311c3b72ca12aa1efd9f062581ac410673aa0afa65c438ea54f97326d525738658e04ffd697119b91587824408a8dcd0600a2e20da45936106ad939aa3e1d9a95cda1283e06ef098194508ca48c916141106fd64660c3c120ffdbb01f6ff6f17a9b2586b68ad35c0a6a8efd4a3892af0f2fcaebfc09c3d6e41271fbe8eb1dc7c2a3f9de3c080f634318d286297d02b08edc21f152ce63265927b3a418e1098a99c7fc9a8d6099eb1c4353fd5a4358f8869730e1f458cd4005d24bcbd6ab03ee6436207e0e827a8ad92a3493ff12404bb85fca42447ced2c17ef5f7a33ce9590b4e5ca64f80a16b46bfbf82ba06a3b763f8ec1c6ab1949a3e76366dfc95f3f5f058872342ed38a683294f72b440d681913e2d4eed088ab53932990a8d41e706accbab3f4d482ea24d69b9620252b3337c7f2374fbe70312eea9c16c9e6d7c8e075f75b17354e5139b40d5580fb370d700452917c4db552191359fab78dc29eb35569c737a97768be15aacf24d647e5d177170a50d5f391563e5bd38c67d792c713029e4c135c28be61bfd201b213bf9611a89558b8b18ae5b586ae115b928b6b05dac58573987f00a1d9fa562189640886c708e2d047ba79de701004e981a8f72f7c723d738b3df57450b42ecf47f7d97ed7db4a5ea0fb54387a82019c9c61e91665d078da1c7b58498dd88dc643a76839a4e1972776914f9735824540a879d73a95b192c31665a91a5054307e6d6d458739dfde07e5bc649d522c4d6e2cdf45e4e6baf12252e832cbc40ff6b2c42907df5c60f0418097a20159c2a2733452fe8aba369e184d0fd2afdd285d2ccaefd5161de2de709296966e5ee558038147e2c7ca1c1c4bf848f9ed0827d1fbb85ee3e434a74507ec96a0e5f1d7a68cbd223411b80eecfbf1ff2087599c0897bc256165744b1aa6f0a28d79b47d7f3e67867448682c8543d9326636991a207369388c5d21d23c602fc3fb6989b319723ee2ed5aabbb3691bcec4987a990c195d933d22f7fcfb820ae8a9a8605aed6f0e014d839cdfe43d82a463aa89fe6e94c7fd92730e56b130ab1b60523c4063e962786ab635e3d3c70ecd42800a542dd191e3e0e879967e8e23822cd0227e120541756da41d3b0c9a164f977daf35a6dfd2fdcfc876e6f0c55d4edea8d1e3b552eca9667fee100e872339ba0872db4b15592cddbbdebbf23f972a834fc451053f96cb0093f29f90871692231dd5bd736e686b05df23136adc5d44f7de3c8a4dce287605e3f3a047b58d87d6c47461cf302f3702c3c8809aa582933856b1de4e30f66f765c3d9710c5dbf406a4ac01d821fd2f9e9d1d9e894d25479a8e87adb21f794180f4e684c51aff66a6f68cab618e2d82a3028111612de4f2610c32f4e5ded12fff86f949a14d4ee43c432e38dbef0a394ef7feeee5e1c91e4f0396c9f00e419dada4be43da97a9d6e3988315df96f34b2084f70262d84740e3cfaed6bfa78859ada6cbf052eb05c3c5405251ab7319617ca7b81e0bda403715a79c0886b2ab761b3e50cada7c2b35f155bd761d121de0d7a9497f01a2c4143d57ebd9920fb84646ee43f21e36e791c2d8580702db9672b99a769f1fd53a9b150a76a30493574e0d083217fbe3f7ed301c273b13696da6195a00c47798224e8dfa50fe265f9fac16821afca7b480421a77df98f816f9339d408d3e4fd9b186f8db9bc2696388991b62f9fc9fce3f2a50684d502f4df0174dbf855d50636c91dc91c1c495e3cec3a7b12b9cefbedae52608ca8e2d6f0838de54ea611311f54335454c83c1cb4edefef1c570d0be28061db2a391ed4ee0cd1d7166f08ca8849fa8bd49dc7fb23b5384a1bd08c8da807648f7d8d23cf214a91e803cc5047a4498a1b316b484234efbe6e283d31bdbf43d0601e873701c2e95bc15f2453438017d8c848d0f905d477906e08af7f10595aae98f1aeda7f1e36845cc117f581c50a4d9aca1ca1c84120c61d7e109b1384dfce86f744e8227b106b222465abdb216404522e33a7eefefa9a82f9b0be82007637142a1c96aef40c08d70aaaa8d6024001ad8e8d60cd33e8bd20cd42c5f299f31fc4de26ac8217c5aeed1e0a78b6e6ff8323040759430c9595440fa95be9719518745bcb7c89939ac50167d5c17da8e3c79bc0526802081a836ae90b3d1963ef706de952e0cd2a5dcb483cc50cea812611c7aaf926e10a534ab27eba315eaa74230b82463ac271bfb637df34f93d7ede2878d74364086b3427f42aaa3df222c29aec913cd99f386b2d8599de6f99962c73cd1c31e99a2ed818dbccd1d317017066dbc7a362cd1ddaf1bc3b53c1a6107517e57749df6655065c6072f20a35bfd48ffad3e9f02c3c11e4a4d8c1efba41eeca267071b5515ab8522c4217bf2e2604a4ffc2083b8d1f2986df3beb77ee8cc9ca0bf99187063226db15d1f7398eb74ea5820bad391c54d1969acf95bf317a1a17ee38ec1b0457cec3e6357a09fef8853dae9b2045aff6aebd55d088e55fde188722db0d6a3ca2c57370e6622f836fd074883741418322fc9dee03b4691fcadab717b25f0576739f98c057acb3122ed52dcb6f8b5c0eb6d4c1bd4e361b3a1b771528626989a88c6baaed66c0ff2a124fce08de540c9b9ec1d8ad5116c27b17027e01a89da76619e142cfa23063f2354c382308ae807acb0b9d7f61ca993415b91762d2e20b9ebfdf9fe1ef34cec421ea3ddfa0a82c07821efc163c3d999ea076a44fa1b737c7b1a2839bd6de5b2650a5ed57959e4fe0d6959a61deb8718e107121d77428332d873c8ba41eed1d91417584f248648178b352b0bb3db871e050b97b3f2d1ef86736122bd509135f01274068f551dbde1f272096cc0d47ca536a27f3f0a39062fbd8d195c0f04c37a973c5be321b14304140bfca2088613912ae169d73fa61ff91b8e0c6aaaa75af43abb0fc40d0668e190bfa9b6830966dcb3dd84fe391be1634d3e51fbac4ab03cd4d8270068e320c34ca4cdcd7d4bdea6d796203dfb3bbc34a9279ed61f75fb7d6ce7c7db2735af3670144e79bdd2106c65cb9a6c0b77afd5767aa3d961ea91f45857fbff1853b65ad5a0fc4112916d35d0c5baf6f5d69a5c4ce68d11f20dae4f00d9fef453a86cb1c51a4d4a98361d9bfb20dbd8f4b59f0ddefb6e86ae8a12c7640aad58841cfbb9f0d9573820dc99efe486cc1b956e4fd585d02fd7b2052f8e1b8ee4dc42d2ff04aef1e798cf517e39b7cb8b998a5212ebcbcfcbd0c998d3a66126b2636bc46b84f9520f36c1e90de492d42ce0d3bbea041d3fa7bfb6d8607e38ddb72fbbdc2fedd6cbed2952d4109524cccf0b66093a5540cb7d329a79f0a6a80a9868d3f087f5e3b4b8b4fd3af712c4c0b08302405e3153e8758a1990fd9d1885d084448a012314246e3c6c90027665e605339ad8bfe04336d27e7f876c6ba3a74f5c65ba07726afc021574e9db52128e4cb001f772bda138bfa7703666f1ebde228a069fa29b2dcd28fffa8cc8760b7e65ca7f29636a4eebb4ab8ba653ed4d8724a8f2c5c426806936b9e451741f94e5450d6bf42c7ac4a92506b2c2ed751f5c6102299919ba4afffc72081ebc4eb51170eaaca2a64ebec8fb828b25729dbd09ed62ddf18ff1b0f38385fed56f20562ed9e4809679716a9aa8c923b0b131457b33882c9743c7c7efa301696d9b1c63aa546d038b5961c7155dce4d751d33a4032b9d53d999a8aa5c9a303b4735c86aa18ebe9d290c5e6b626a0add57cb6531652adb0e23adfe334df03334cfd036e4d116a6a7cc10b708cb3b8f84ae661b5a56feb85d1e4d027704d89cbab38a5eebe24712820c4b3a8421b2a19fadaf1e3f47c5d23b1aedb9fb9896a558489fa54d021043f08b262970c031c47dac2430e14ee06f1a681e562df70646d72ce8cb185c90e767ea1dfa188701c85b3aa9657c3ee12d25ca681ac5ef9773ee68067c33047f6ded15bd81e50d96a102bf9e3cb510009360b0a125eeb17951f74356f1e98503572578c7f1d29e9f48f7c2d3453e0caa771e0388fbc8d6f5653693a2b34d818defc463dc379dacd2e64f3cfde8e43a8a33ddd5899985baafb3131f3f14a2460955058eab5e217f8969c7b983f4ad21c9b671e7102f565a197001e970b9f6bf376709a3868098a41ac1606ddac82f8319a8817331e585e0ea8196befec4385ed2586031aa6431c884a08e7d97376a15f3f47c4fdc7893ef17019e49699a96da7752eb1ca7c5d8981415a727375ec1dad606f8a0f28de01f54ed55bfb8f21f5d10d8bdb54730423e6f74e5f2077dce9bf560fc7cac69bedae293c306cdd3da37b5865620ebc8adb8585ff565bb0b29011cdf43f6840bddcc4fbe4a53cf3255a059fbcf1cd567ecd190c6ed182a17247cbf8e03c94804d87519820cbb3c15069b5e697627d4812072d8b15a9678c7bb1d95decb2534ffbfe1e59ba2c79b3d86156b9e965ab87ec8ab40cd0ff3cc49be59c559910c8ab3620f2bdaf3ca52d769779b9480ad673324334f4cb35ef355e4b91cc0f6e7416b7dd4e8b12458bb84d79e7e079c8e29a6c327c3b2024a6dee2d64aa385e2d77a7bc3d8608e137777cbb69b2f7d4cdf55f687fe2fe39172435103fedec3e3d02433a916c7ba862f5e3390c6f6ecb9d0f8f771794cb59a445568477e71e1f0e7b42a1efb6d01f66c1a8df2b119beffb263ede0c6a35de887fbbfc12352496a235e2f9731e91c08a440125fff8fd5302eb32632210eb8f7216b25a27e64b0c5b433ca3bc4e214ed95af07d9c23bf7895f3746ee4b42a2ec5a5cde02a2038eb1626b56fceab8530e9fbc058aaf7a330a7ebd21972e0155f72d83374601648cb7c747c8d9b1dae0c5c746b5faf8d7b494251c34e091b3f0127adbbaf7a4a4154010b145e7b567828d129f471f87bc8b908cc5e058dc329b29bc42a09767987477e5e2721aee550374a79551c1c4dfc062a68af4cb787d32eebcb53932c9db072546c6450260c6432ea131501471f03fea88c90e6da875e2c6feed3c3210f0c95ce52dde1f057d15fbc4c06c4b8559843f41d7cd840427a7e5f4a1874997fc0c8e1af6dce1565b0e99b98afabe6007118d7362e7cef04da15d9a99894cf20bcd22fe5e9a2cf0bbd127eccf246a8bcf1975352fef963d1ec2f477af24b9645521f1268d6736b13801ac161843bf68f88f11ee67cf170f4cf6d76116fdb98a7c5154a0eb67934f37beff8c2677ff8aa3441d73ce6caa4a9c573e0c580703dcc7b36eb3c1f03e629e45b960c788d2f075561b07f8bbcb207e68923e1fdefce0c1c2663b595883f5ba0089f9ae5b34d9a9fe553b0777ca410f96d43991c007c51336f122812b6a27a36e8e3dfbbe19c5a72a4f3cf2ed6b1a0dcfe0c30eff4b335154d710023b71633d0f0a32d3b5db203af71d95f7056eee5bfd8d92bb257a25450be3c21211a95fe9e4173e64fce1b9a0020cf40952c773397f9fbce60fc5382f76992d2284745ccba183ad6f7424af4da5b5b95c6bb1da16ea35f929de10df57a42276565f02cd7f8c1c7e1bc36f6e7eb308ca20b4e55a7999a5ecbd3b83f8baeefe158c10eca1a092e328cec89afeb5afd9b1ca2d07a30a4e9b969157f20fb3d8dcb812438da27583094d79990f14114aec7fadaeef7b1565c5fd7c26d02cd869d8bb82d08c5ca32c2f482bc6d7193534c5aaac1152b3ad3b22be2952ffd4bd760e967defe2265121b17872f9e38e7467e190b8954dc9c164299ff6f5ccf3912bf44d9fc3694bb60b13f3b73cde7ea56e1af0cab5cb3479f3fba6597c3f6c756a1e8b75158a0ac2798ca14a90ae70af36e083bc99f471a7281642fbcdd7665e9192adc96b7901cb0c8d68ffb48cd8fa68ff2d437c8b21ee7633640f6e9c233daead03cdd6d04d6175a9fe7ab2ebb6f40505f20a19eaf48e9ca3535a8cec9f721794b4c95d3b71edb74b29b31cd970f5b82a6417a4f513d6e7a0d1a034b6ac57e475fc82c2d495fdc785a46cf6b22db1e9c76d6138d5ef1660d07ee8b4db3996b849291f66909be15a61a0e68ca6099e0ccc4757b5c753a88f94993a484f51200ff2d79330989affba40d11debbfaa25e89dc5433c1fc0a5fa4285fdef2c2869a2cdf2b4bd10d22f19c04cb2c70e90704f9b7ec8363cac80217477ab152472c0cec805518d92fb7fd30a6dda7b4d8a4c469364df71e5d89f08081e0ffbcdd4eeefdeb50260384781995cb8057a55bdd445225f03357b9bb1702ab9b9b996a55269b02d764ec84f3b552fb0d8cd2747016aeae9565647f27526f3e88a96a3063e2ab2e7554095f7dd5b10a4921f503e05e10547bd938f8d027aef56855ffcd3965f21ee8021436ee98fcf15081e1e57d97c45b808be83d7725ec09e6d03d2f536931f0244606b9b773129d19d19717925baa4779f2282411b17d8450355c9d52ff868d9b401ec3551bc120e0e984c6a3c46cbdb6e748616d27e9b18dde94b05f62dca772689a740754a067d938fb7046894fec152c0cd48d5188ceba43f2a2148aa623c2938dcc3875a7ee915802c257a66bac94ff4c199bc544e233ba99cd9cc04fe9e82de9e3a74ea8f91fadc240a806b6e55fc68811e9cc90273fb725caab6b56322b4472e64b32734707d0a15903c7e14beeec08997d8b5be4e8c0d075ef1c1b9e8abc5ed127d9dc6f916232975636209b557201fc209921e4cf969bf368e28fae12258ea9c11ca11d5d87aedc093adfd3a1162582ca6ecfd8122446adeeef54a60e31fbaeea2ecd561cb47de2ca717e1ff68491667ef6e46c1d0b06d60196c5fcc204d96ec9e6a029256a84a548320e1458fc2b9f714c39c8c5bf8efe39bfb7b50c354ec0be75b8d2780ea257252c015da2daaaa2cebcca3b811ab69a0fbfa37cef6feceb7fcf48c7b472771b7b18fc259f25f954d7818dfdab4d86dd27ff8401725f1640878684097ed9d0ce72df11968948dd4a932aeaed12464b65cb95a013251e6b5250b4dadd5df2fec6ae5ea96ef68a49231a094488f26decd5a25c8584598d658d61a16775c6b9c4fda8d1b1698bfa2cf8c4b9c51ace967c3856b7fc7c01e9b9a8ac5dd091a884232f257f180bfe85281b0891d39bda4ed94fcf2a6b3b8c2eb7aed2e8da360aa9569cafd5d2c1c2a1599e9d080f6af1f651d0855ec8ca9d3439e60de073adf7c622869df0b843b1c3c6a747f82f49f0e8d3ff2b361817092bb0963be5d6c456044affef27b71c50d415c49e353f4e477e31fa17e3ad5cd7b8cc10ce7d5ede475b9611d294d53802f747f52001d88a6eabe407044356c01f7cf0254cda2fbee07d9ae85bea3269ee3fe0764011ca581f822508bb93337bb18257f5d644401ef90c67a1276cdaff8cd02b760ce1dc6ea5645227e6187549387f7152b87bf5a0af2ca85a3181a7e21246cd12015debf2af4e1d1648f081be9df08ab59a313a2c42c0787cd357a6a48f45b63dd7fc4b6b9212a936f61548420ea094aa4403b06018935ecea9a585519d96c3d205f690e3ee909bafb734784facf6b4fa2bf92ce557d679969fcccea6386dfcbf09e53e34e61bbf2d7f397d25a0817b0c681fe7a166dc1315e8a341ba516f5bdeff5bcedf9852fdc3d5dd16cfe826426f4f00a3d9bd9dba76ad079552ffa55245ecb9d4fcf15ad9dbb58145f5c115406915bd53d7b4ba23266e523b3af3e9f1088623ea5c4fe40872d1b8e10a8f777ec43b70feddb6848c62f14fa2eb40b95f3302603a8fd424b4b6ebc2d7decbe4fe376d363a79936952cec2ec0d786d1bab520fd982576fa6b5a4967113ce66cf4f78972fbc647b63034dfa0f458bc8129b77eca621bba55f6bb3040dfad5bae878f35d59757af395e827fe6f2d476c69a1d33eb45a6f81fec399b8aabaf3aae60569157c81b79c912b354ca7366bb05e98e5b29272008d9aa3915c079906f21a04e8c9a261e8f472615b24039b8f61da4303de41a8eaa67dae78366c83a9ec74ab25af5789c6c2d65c14d11a987edf34e72cea7b568adbb0ec6de00f8c913bf2cdbcc66013cb348f3abbea4d4c3947e7230f1ef297a2ba1b420a6768ca4afc34118fd953d1f7f9714cc5e33e0feac5c7d4ea843efc5fcba1884ec62eee0088e880ff16416b51d77bede91649c54b3b199c5a6d34ee65e03339bfb6640fab9ec3af149f07d9c1f116bafada27da3291d615868f1893c16299a03801eadb270d95b07320226a77f053a8afa0e2b83ce343a2a9ffcabc1cc09811e38f9f50f2303cfdb1c6e1505cfd927799fe5f7a03f5af23dd34368266ed382057befb339137678ee4063424a83e484db34fe2a63438113a6653c2528ca7027c847c5294fc1097c49ff0886d0dfdf9abe4062f83ad22028c1dbd72dc0fc7357bdebf5f1139a24a24d55da797ec34a31222e014bf5c356ada0bf9a27c847f8ff9dfbd15a961b6a36d2cb522aef042d64545913f6e873a5f1c8bc445a2fce752042337391474218c72eb4b391e0204ada25dc67570434d0e51bb4e190960c29ba64cd037bcfba61a6306fd6e4915c8b0dc7ab39c6fb149e871b4977cb60556c25c7897180933a1d47f402e0c03730ee4ee02e12babdf6ed59f3ca1c9b026f1898c1ded1da36b8cbca69ec7a5bceb8dd6cff8a02f0a48171e43a8158bbb92f1f6c63c7bd95bb2c34773b599514f3079a5832e816c709483c1b9a549f03bccc0ba5011d82dc455f21e04612a3e12423d1a7de2c01c69bc2ba7f7a283e993e4ef04f7f4f0a5790f66ae189c7dbf388a94556525ab400a8d247cf78f629ddfa36b0bfc456bfa0c92fd75693a5c4c784950d5dfcac15ce9c2fde016e9e796ae98501570cdd09ac697d74691982ed2ab0c15f89efa380642c089d762151218b985565d80dde1bcfd2fc52250e836dde25d3034b0ddf72ccc49969ba14de6139f6bc83f48db42a545253790edcf21946e52e4ae4991044a96cd8c38ab479c7fa24e423c38f7c26cfee2dc5a60fc84563ec77bb8f75a37440a37fee8a3f1359199dbb303a862a70b37d4b8b9652ea033d116bc75ad1bce4aacb4349d0dbd93114756860c9f53481df8259d7711992a6ad98e6a78722e1e2f61450bcb329fe8cbbf6bf471d49a100560b9a4b561423e1639f082e46426255a963fb7d152223a377b49cb73895abb4bf0634b5ca23dec519002096b5f1a4aebbaeae355be89e68e7b9a0880b3a051bbd6ddef5f7d861d6efd11bc6a228cc6ba439ee202ad4897c926c0298727c7f1725e921a6947bede70fda090a8cbd93b58c5396a162819eeff6264f4d1a3559ac1fc19b7bfd995bed17e045d23eeae5aa9c1b6bdecd813d899ff653ca5ae4b02f050c9e163298a9c923d490086fb305259a3135648c483229cc219096d72dfd12d410002cf582ce24c655f2f4199557a68395e369ade47c9cc0bc3f2d66c549363a9154b297b521c7cc316498d98bb7ed846fb6d0e06e309855fd252675ad01df8fc9547489bc8bc670e3e222788802b8f9ac73239aa534853abd33a58c4f32fbc0b5dfba640b4017bb547bdc2f347a6d3fbec7dc50da97bb8ec2da54eb05b4a1448e638f9dedb1dc7fabe18e00f64b138559857c128475dda49b99c5252b6bb2cce29b21cc054df81b51e5aab1b3c57b59fb3c089270890d9abcba0eca5db6c71d8b1e649777d728fa4adf9572b286d86aa9cdf22ea989ecc1550e81303b2a55cc66532fb1a0549a9ce8a484c6ce3b5e582b9ed1d130fefb9c2c7b468da23ad518a07bfde8d5bb9cbf40be23735dd15aced4a6ad007c4dda3083e2ed855f71b48bd1ff48b02e89fbbd7c0617a0ecee839341cedc8f0a6acdb807cf69b8ce9f2cc07d0a849ac995f0e67d921ad5efcae41e64668ae88b555cace653056654a6cc2e056329d005ebebf2b1011fd293012a8cb63dc769b5b655fc944c78d8fea4a30e943889300194308d51534f9afb1ce9a8b85e70bc1aa7750c9d08222d8371ed8ca841ceb295caefddba3c2a6e5ee43110fbfde5861756109f59af34a6fb6cd68c9b657b7b34bab3a862c63fff9d5db237b7589f10d6eebe406dcbf30758df47c57a2fc79efeed15fe9900b290d61f3bd621451ed687a791d1f1e78c14e26a8f139ff05ac6051a4c42b6dd338b7ebc97fbce3b8fc61d0399908294af0e4802bcff9331e9d86412a9d079746cd935d36255db99527e7d74ca6d9836a8689c469d581f50228f3009c59ecf32fd213bcd872a446bdca8aa71b4853b9712b06c2e52627d2874567272a378c321276dc52beb350419b597240e2240a64c94d2c0d92ba852162b4852567a5e8a307b11221ed4566759d20b6e48b34995299815da4018b380958f2a8182301ed0252e01c8d3d56d55bd245e8c7d3267bd7fe2d372e366740da7586fd87cf58da73d89a01cfd4f9bc13a75c564be68a1b210c78d2c2475b7bebefb1e6e48c87a6eb26c4122197591f86afded64e4219c4d7fa75e244e064522b2d15d1f65cfa0828a2bc2815a5dc3f94d1e57c00b54b107d58064929e9a815447b4bd16dc9723a90be0502e357ef542486a5697112184abe25318f6c3c599cba9b10eee4d39e028241fd89aa7cd15680b48d387d22a489d19e09945bdba40861279fd7e433a9b091335695507e796bee956df4fd714d72b554f506064b7e78320ecd73ee8768ef32a9f290a32507207eed7c467739a2f2e67f39d827dcb04ae972c42d3910c0e4e7ad657dba5826ec21e5c65a373a1762cb8059735a1c90c5b67746d1e1042dc4f418af5dda0b7324ed41b4148051689692966d5ddfa7e9c2f65dd3b4cf16959ec3f68982ca40ec27426146742e89c875ae52688574a60e76af4496e277abf9f9ebc656322cc29a333f0ef81d0013ec7595fb692ad48d551fdbc3b1375909c2def3cdf07082e924808d62e92bd06320712ffa459b3a39d187a662486b328966eb323cabb2d7634979028d837f04efa4ea3d9b708df70c08b6f58b4ac42b634b8d8bcca2bd0d707b5af2f7e2bf3ff367ed4388b733f4fc59ff80bfef04a8310c375b94022eb9c228d952d3094fbc5ec57f2e9f82a26a490b646c1f0ba1f68b14fea4ceece443159eb573be1a3cb43040c4bd958dd738cdfc355957a60955b6a59c1d3e0c8f3801e29a84294b5fc204137813c31bc70e88a7419a571dd9131dd64f0bceb3731b220368a1ffb41c8b30f518454c9fa142c1484bd310fd3922342fd004c05b6b21611fdbbafe0151d8ba15cd8e8cb87b04796d89e2a4336264e59fe005b90f1f569d97a9ebb5187433a068874fb9b368e6b0e86de21b3e37d1c4471f33c828cb6d78048f42b76cd41b9cf772d3f50403c4afcb3cebfa86f0cd5ee2eccd5231688f2045522eeca3dcd0bf0a3661eee4366b3bd4080b00cc392a3e4de4f2c026e935646d49389425c53f93edcc208185e7129e07ed81c3742d32c3215596b913dc00583f0b9e5db6898e34d5f0acea87ec0fcd7e2fb2c09009418c1e3a465abc961993f89d9fd184b7bbef4b90cd43e958156add46be10c620a24dbfbcb8eb0e11ca494904f3d368e85f6585137e8cd1f13db5cea9d702249e9b4ba032c0ddcc45f7768c6b145732c85442193036c16d001162357210c38f537f8325cbe4ee06d002e375a388020c4a68848288445c6c74ac2999753080a5d2f43afa275a5054947885e6b7081d3465ba2587e2596798dd47efa468f8e7f935b0d654761689a57a08acd10f7c506ae50794d0af4eab82fc7d316408f7340f380acd947480298774e1f18572ce567c7486a9a5466a8e7be5819ce286425cfb8845fe7c64117ac446b6ca138d7503ee7e73fb57fd8a40b509894fd7db75b1679526613c7116b3f5279d2938ecdb8c89d84487f6ea97ae00fb2a30fd477bf4811eda1be1525c32d00e6a30ae89de98e96b5cb8e9d80da6b6460277f6fa339947b05ccf8add54f2f91f2eee01fd6d365ca09b450b8f5991b6ec20b550dfde5335416901e44c9da0050c9f3114535e9a5bb7b9fb486d7bff7a0556d896b1bf1984b185e8c300bce2c8ef66c3ddf321f13fbc2abf3e45c7892f84017c9261a528c46b9ec7eed32b2be9a6385cf1c8b10a371a06b535f08033a022ae245afd5060990cb2829a8449fb91a3565081b92e1f7ec4c360972618a9b23cfc64388720776fde6eae82a8b7269953e527a0623206ae1f9078f5258ce2cbaa35da9aeebe971d5761bc43d4f10e3158b192cf9f5913d6891fa555b357270e20dc09b84af8c076ee9c291b051c0f2fc0df8d03a7492ee410012a93d3f740d688077553415244c091dc091264f833b154b5e457a6af2ea6ce2b026ec577cdb995cf52b44d35a228f068587f6cde58ed45f659500ef5ed260a9c35b13ec43a9de7814857c7a0b813bab05c1d590e3508eeea20421e25924365315ad16513aaf71e9e8e7bbbda17e066a8e5a62003e0d8f30d7cb4c7940554a3f725f7a4e5ebec18e72963807aa38d55b7ad2f8630f2f7ad26457aa4a74301b0401779dcd4a3181803a4678dd22fa89577f23fb3ccd0b5700ae49ed67448e921609c808f4c5f0157eeeb094b360cfd6646cc9185a9dad3e30211a0001a412c93ff8bb6d4e0ed843225f30c106e7f629a1920ab9a7aa71deb75e1508df4df0bbadcf07394071721bb2bc9ea3e9c40c2981295fea9f8bece7b37a033ea4af83b0a5a90d53d0947fbf1b3b872f8bd89735eeaf480151812e1fd9051838f66d09b18393bc5399fafc07f73c7020734f4c93ee3b709d194770ba154aee7fd6694d6b0e0293310eda5f124e1db77cec5398b0342186f5136279d0dd1e1d22fbfd7cd42ae381be20062b74e0a76791221228e43bdcd443c24781c1ccada603222768de0cbcdc9c12e7e45037665d5829cc4ccede9bc7124659c4150a5f0cf3cbcf6ca8f6e3c69ff0c3035ec98c5243eb827cb0ab66f27fb7e1d4481da0c79985dded2509d9d812652923ac05f6d2e20df2cb2db32b5ebc942f81bc83f972e1923d6198a870115db6006fc433ac94bb75c6601a7ed363a25a33c81ed31cf4d7e659783ce930e89f26fe9c328e3784ba28e3088552ec8ffa4698678a160e7f9e2ffb1ffc1670425eac9f32d959cc21ee5302f51d736a2b190349375a465364ca2f766b97392b601f85fbf1b71486686fc29fda76b83db1a2f0862317c696e37bb0e1542852a812ea91651a7d35a4341634c37594e9a9798b35b139fefd0b7b6d869bafc728694f5f3f22e6d1c303cef9b825e7e9af9193cde650da610ccd55b8bb1b067f62b102c1cff8566c2eec5c54eb3a20fface5904bf25175e80c04bb290b88c28d7bc2701da9a67b7361e21a28481d6b27634d79b1759ef40bc04776e1cac217da8b0147c0cd15601ae32e2e80635a952d8f8b94e3ee7b318454c43a80eba023bbb7763ae31ca840dc19560e9ca1cccf7ca769f48a9d1366aa5557f29204531bb29d9d62bce19a95858a21749154bd890a115cdc22eebaa02c6c7f5202cfb5250cea53c1664085b59fa8171abb0429d69453069ffd15d2f83bf323f705214b7390bd362efef56583c052c294d5b906564a215d93ea76bdd00bb819a7b31c3c3404b68de833ac6a7d6ef1356e738a94afe0c9f8c9f7e4ea1c133635874f93b8e679aa49a90cc3f110efe0f2c34fc5b32f011d51ef77f89294398099f74f8a5192fcefe9afbb076ed0e348b42b730ea68813fb7010192b80c3231486b37c8491afbbd9384ecbc2bf209237fe98962f006136e410c30bbe663244e21e14e8371edbc22325006b74251414cc22f3b49f1ca081b67986867faa1af1de9471d1941f3b82f8b512fa5d4830e973b4d2cea13db7ac85cb0a71bfb2e61eb7a4feda480987aa69a20ef6f81ea4578eadd68c6b4e4d54aa24279dc65eb559c77d423e3fdfef5d5c904210741091459ca46692cc549d6acd05188733b6c376e5471893fc1ae0881464a658f4e8620ea2f5d2ac417c8fd08601fb1fedf8c99e6d48217bb505dd37adea316dad3369e883d3b73e5eeda1393c194fa00dc49ade7f1a15e62289e7dc54c3e7df77738e2de6eb5c0ce7f7353ac27e5d0d4a92ea9513a569da52a149db56d4c5eb8026968054f82ff9e78620337837c997d092485a850af14e0a919e072d406ca013c1c1904b825423bcf1fd86ac15fc1f4fe1989ae09a8a320033f20d5d58c63e641b6e4b4a8e598bdcb68a63661a5923e5fd19dd6dab161aa3fa5fe9c6c45efd7685d8cec31f8487a9a9aef7554e60576e9c85f103423263c67e1609de2c0e06efaf02d6752e8fd3920fa6f1ca0207d560dca8236775ef671ec01571fc940951adb0e86bcbba130e116c9662275faf2c23f96b47dda67304bbfd7d319813a7d57ca92abab94f4259048a320fb1533edb85dad9ebff54f758063561a7190c2fa403296542d559ceb5c90e687cd7b3c57575e0f4ae62c3ab02e4e6fc41b6ac4a6fccb07fd7107b79eb592f22612f1c9e58fa84110ce8ef3155df82918d16a55550169177d82aeae0809f7eece34539184d3f64dc1a5d2ac335c91cceb35e71cc8798fda30924658ad5b9ac2e7e4d05e58ead6b059579d93672e5b3b9b4f4b89c8fcb9bc713ed5083229341c90620c7346c1ec49df813851ffd72018198e4235c4e2506e722566d7b71154530ceb07f54af4327b6400477f71f5ca32c3d4d7ed681e07dbe27f0eaa41565780aa40fab3e61fca9806d774c598da544f76363d3bbacd2d9c698ea53043fd91f5c72eae26181058f802de451a54121a6e46241e7a692ea1f5c44f2ba0eb161fd0a58b9b5bb80e11532255776d9654be6d39e0f52330e463c10060095227b9625eb5da9b241c6782ca9813058fa57980c6b5778788db008ca737403300df720e6e4d8b119a62773ce91e1c5d164c53f206a25dbbbb98741af5924edcbff4996a5c78378b83aa9075e95c80139a2648b7f4f61e4a41abe80aecf6f9197e9eb91345a704cb66429e7cbde154bb83fe8df3e8df1d77c7dd4029c2a7f653ebeb9427060218bbf90ea7bd22a18a0ff23aa669124389b6e0d71cbe16c6996cc13397cb764b2b5dccea987bcf3e48e9396cb50331fdadfd19282c8f64310e80270b7586a1d1ea3cfddb1455d20697239962abd3053d3ffbc7390af71e0118cea5d5861a8a3ef32da002ea0d5df9ca222b0a86eaa3d692134749d8a562612e7e9f7f7b828de31ea17f7c09acf93a6c25d9a00916eb07812208b145b136a1baf6c1873b760b03583b6de433a9e443dbd67da887cb58dbe5710c74a60c74b10a8d9cb8c0a4fe1820b522de6e18e69e7aa8b8f47ee8efcf65ce8ee000321f6469854649ed8b99f29dbe6c22f3bc0928aa01d44032ca1a44d6fc80531ea2f26dd2cbdf88460d8354d7a8e46c603447eb12e9c7b3f93a2c987d05dd64a6ee7c8500eda569711f60b88f143356a5350a76c05111fa657833f338a3ee9a11ce402335d784666945e1a7b9f2f116626c3d067e7c9b0eb229af2277d85661ec3350fab0af2d450baec1933030ff07d4d4bbbf3d1227c3289362d4cb56032e75b80b3626bb21fc57ec0789ee895960dfddb06c1bd6b671279daffb879bf3a4cb2afa9d12cc62e23171ba40edd092cad83d5afba57c129b14348515ba99f292d701e2a3a0ad8f90636ba7f370a16979ad66134c435196d8ef391b5b35dce2c5e811f633c7e8f80545b1c8a62e405e00973bcacd660a8b2a854da9d26e0253d03e837896a0983b9114a89edc838afa7d137544a53b87325c47a0c12666720fbb78a43c953f67087a0913224bca06d701616ac370be83779ea4794a5ab9de5addb8f05c8237081dacbfb1c11985b904dac58e0065fbd589eb81c37ef3a26690ae1970f22435a51331fca2f96836c75210538877405fcdaad7cc7cd39173c50e15eea6b616bafb48d0f2455c6da3dd15ae9ce50dc2574e4e03af450fffa18caa69aa42fd3228bbbac17b6709eb405f99764582213eab37a190a2db29f36ee9b9b041c5251c13ea2ed8168152c7d5f66d87b0f1d427834651c833547185e0d18f8ea87b93bf96e5d82db960d8ee25d419cde9628614ee571814fff55771b1a15bac4beaab4e0bcd3edbea4be8489fd5a64788c0408832cccf6508a40f417e125d0d13f44fd9e80b49f94bcc35e610b9a9da55f199e4c181ca224eed9b6ef9de789bac4d087fe5a4383195e63f7233ea3b173f63ce2db3755443e8f0711f0316a726a1121a8505e5e9c379093cc7439920ba1c4706dbf8b41d201a9512ef907eb7a50351da4b0558dd00d0430c9ed9ec771e92c1a79b77750f04f6c8015e8ca130966c71732a352a6b80ec72a082d89f3005e7f8ce0487d9180a6ee3a24c642c82a6ee7ad10274a9bb158d0166aca49c57d42bc9d0624dbeafca5bde7167301a11fd9145c2ecd2fa855f88f99500cbcc9106b1a1ed2788e21afc86e3ee24a3c400acfe3017c4dba306aab25313cc51a2952ada82cfe25472e381856f38e850fa0ba061f3fc90f7f55cf5242792e8a6c6f28c6ca263e9562f5c55f72dac4d2b1962b517150df45e4179e14a806ee248c8d4948a685e6c4cfb3cd113d4ca472c9ce7b4b6efbb9b159668803d3dae0dd802dccf04fe59cf6dc4a55f0f044185449867c9e78a681755ed891410aac2a0935ab5300b50aa2eac9fea1432a590d61b10be76403edef863ee73160bca0a4db05d5409ff649bf76a91450be7262ef9fd2d0394d78af5097929f347add8e6c7a2a9ab1bd2ce40465388c24de772fcefb4ae0238a01a7101197afb929af08d20e7ee5cc3aea582a453bdd5aef4f6a7501f47b6f6319c0a655594e2ec2dc4189f34debe522920bf7077568b480f5ab5a8a71b1fa52fd235fd62c109a434bd35dbd9ea084d57b8f1591c13885beda4f1117630e1950f4485137294a6e7eef0edc4424e7d46ef070916c8630313f0ff8d9421564fe44f591c1007d167e45d0b27a7e6d2dd05451bdf64f3fb5063bfe2062485d6c2ff1e5f27b79fc9c9129a4d60c058be7d1ccd620db26a278c6e9ee50eb722c179416cc72539e2f6d6b93d1798c817e91d0b7a29d96fb2e10e1beac19e2fb20282276d3f9eaa3778153deffc005bec82a052a49243f9810e6b34faa92d27ec13d79c30f5e4765f939eb59a74fdde87a2fbf1f53b64e7250ab8420308859dee79265086b23bf492f5ef6f261a43dda0fb6ea5c14d81fa164a4814bcded640e7198c7c9903e442c9d649719e6cc4f17bfc3a89b7b709b8f855d547f49e5084e6159acf23ddd7800c1b2e4b368a3e0e12a77da77a09558bad7070b833c86e8411c072cd95e23e4be5712c78efd71fc4803ae93d4e25a4c8a654b908bc0496e3829b1aa2e73fc8acea4c216ce9fb0bacf2d8c51afcf98993fc967fe64f355901ee68c56816379e6facb81a8243228c27d852359eec1ad9c68ea18b7ab729441b3b8fdd5e7e032f62ba646ad1e331de37699c22ec0c2eaaa8300dd252904a048c215597d5162209c5f63c355b413345ce1dace99768e31ebac57e642caea130003e6b2e03f5c3ae3334cd1dd41ab90d9232022709b86ae1670c7c99d61a7a92b2c30be2c98bfae68857e755aceadb7a655642eb501037ef8318076265a4001d1d09901c2a3b80555b92cbe259aa2ae1626be62be019068c558b514f853b975522aff82c86c3f5b5a648e685c5a9d2c41e3f3cc473d7abd50c007fca6ca2b8ed2c2a4b8d4683c3cb0be9b19e95ffcd7630178071178f47f170e2074a394cfd2b91a5b8265f3eea723a286b8d1e79438d3abd9a353b0d20d4ce45749354d6dd80cdaf78b0787a92ee15a8ac551514910800846bcb15f5514e8c9d715715c152d11c8028af2f84db252900c7e370ff5064aaa69d123c30e1671a285f094b7a83b4b329273a74d5073429f255d0085b8470b9dc694fdd20d5064725c9c7564bf2e3f1d74f5fe05cf1aca4625ce241eeed312dc7c3d86a050b1fd85b6cef89975597b6e8b3aa134a0dcba8b181966ce9dfe34fb04aa989880d661d1579d73c35fbf1104de04c5a539d8818bc3aed86d774f013c862f386cc142bebc8a2a6089c5b1ef648b1ba56387639affba719ea7b4e9ae0bfd92b2a9e659af79614fea58ab52f32d1cc816a34f803031881e68ea272464b6587497044c990dc2ff1b2470dfaee6bed0d70f3f063317e568414e4da52fa94177b8ff6e6f215ed43ead35b4f8ba53161a36878267011f51c5d089bba666087da4d0bf4002dc322eac8a856560b5eb17355c9c3b8bcc0b3891a7a4c92fea63f279f971d2cffdf42896d824d404b5ab1c4255fc44db2b4a2b78599d9cd6d00367732e2906277fe882423928d4ae56a3c9f373a85748a5d1fb9a9d4537ccefbfee31793c37f41111fbafc5f3c292e84f1fbb276cb3e9a4333d10077834bd90f0c9e77e9dd58a3dcaf4c79efacdf77415739a90960bf7ef59c22deeaf927704d70e01160f3fd8933039f82f2f9da0dba07b98506bfa0448045962d61c5a45260a6d75334ca9cd07f751bb49884800413cedf60ac3bdf95871c11b3b293d0f91bd59e418cee6a9bee930ea3f8534d28980491c3fd57303ef64aa80e199c6e9136c5fd6299675955e9cc711e551d5185c33aaf0c9211d59a6d31058154d7ce166a3df2ad5b5e4686d12dba8eb4083a244ccba17f2645d91f2c718f874754d93fe9e3b44aeb7454cfcf52e0b39f43eabf46c45bfe1d6d73d33b1fc3ca816d1b909df8f82458bd0426d53bf553795832b065e9c4cda1d9aeb85ed5fe1e670352a886b885b24053cb40e555848bdd206d57a6f4eb1ef8237969820075582ae8fb1a214007008d3438e1c1a2174c3b9db8d4c256d2b46ca8587526bd8ccbb79d3dd482771a0f63afa9beae42135b80dd32f5cd41a8cc8946198db30e8a64960c2b90253cc1759716bc60d7e04033bc0192fdf26df9976fca27e88d20b6b14cf631da35a179f066ebb5c91e108d58a78e0743aa9856bd320b6874172bc195db1eca49f855287701dc5eab42b4951703a91eb7c73caf6722c75cced6d5d462d734557f7407d38272e31d251a169be011626b07f36e99a587f3db1ff0fbd37c6c29ae5ad8b13fd8409f88fdac7cfccc25b7614a3c8941281eab6d80d986ae23a9d7a9f976b6636de2d1bbdce2b217a4b476d56882c9a320a78efd077cd553b45822b25940d05cda0c04d525f651f43d8b59b26c958fa0bf2de70c832786ed667b475c00974ac092e4afdbc2919f8f050e711e3e814b7b9254bcafc6e8698f12177fcd738f0056278c9f10a4894b6489257a1709643c6dfab37cdc69b01adc7b2c145c6326058caee13d0775942a5213ad6e7829b3dac098b6d9adba1cc14b69ed1fa0a5fb0824ea34de51bb55477b7002ffa2c53c29baa687f63ed8324c363bf53c9e6b9690f7a9b603084c746920198f729db178366195a740d624fbef8113acf9038c739e0dd1e505ee94e741ed8fe6f210632009f25d2f2dbd884ab24dc95bc3d7a90210596b2d480c2fa1bf6cf9c281ee78aa178a20ce3809c8ff11da4dd00de1125d16fef3bc5504b08d4c761b3e599b0955eff5a4af9cdfc934739355b18ad175591d797ad8395c21f69a398d31bbee7f4e6b0cf9c4f6d10facf7ab73426b94ddba4d548c15ec7eb1810c7eb5e6d3a01c24d34dc6661f36d684e52a759f1bcfc573caabae4dbb0923c21c0e7998d8f97a71c708cc9de38119509ed94bf162036215e665e4871079452b687ed57917e625526021f91d1e68dd1d3dd97c34ece898f4fefa9e716762a9d8376d8f00a09f08f8d4fb6946adbcf952925ed0b9d68546c9d49ede7cb41f0e9f5b394affeed618bcbd6928e0da97a20d58d68471466187f5e382fc9e6a3c21edcdd832b28c1f0c64456692c3f1c3a7ed4b6628ddc33d07cfcbe042fd2657f2fa4e90e63037c2d66b3c4c8895677ede7df48c97da6ca4435dc6a8d9f89646e5892bc2803a11a7d076bad0cf2c8da87ae99fbfd1c2410522eefb90f4c6c01517d26cad4a9c388f70171459fcb2b9007dcbffc596a89ce7c5ac133fd6fc3881253883c025adc77cc149b18ad17b17b3970212c2423b98e864b403e6379f6c9b07dfed55239392dd77dcf6ac6bfc361a5c109153ce2569f63af78e9bfa297a3961b671848aadf1122480acd17a38360152bd8ca690e91bfb92c5bc0bbbbafc2924b5e7a98f0331e1ea98ba6c18b566683573cfd2bb8b8eaf343e84b5f65afad78314b4804171f894103c8147a4405c946f3f084de4fbf212695f9cae2e0547b3fc182528bcfceb94813d77a9b7b6f0bb0fb208d44d96f25f00003dfeadff913762e19e03953bbc29f0db8d86c9c1c37e277e212d7f88a1210e8f37f07ae9b1e399eb1c03e08256a0cba755a528573d1c4be973c3bbc160a42bb0d9df709e9fb6bb821b04492ce6658a3540adcd23145b065c993858c8e0be466b709566559e72f1fb0f210e222e67c6d3e3d72c5cf48fce79d9dfc940b6219a0397dc6d604a8b1643f5be1f23c3451717388dc48b6385509c0295d2bcb572cb657b956308557b851feeb23cbfaeb1b8ef34aed164d844fbdb6054ff536a4db7af0d6245b622ed1c4f22560863295f82ca2e67fc47889fc902d7571b5db1f9cd0c8f7ca565d57996532dc6eef8d3472d2f604be0ce6c854f271e398faba15955fb96dc71db96cc0c8afc8379bc7c2c90aa19629ee2d88c82c8fd7e00ea8aa992c65a7d6dc77e71f98eba8de61dda3e028fb5069c9b1ef7dd2e558ca8f5894080c15efbf7d7f13c204866a447bebb0f106925cb04b4431abb0d50ad4ce4e5d0edeb0e642cb22a1287598df50a8dda440493f87d4fd9831f602d3de0099fc66e4aa811868c3ddf74f12df5778a9c6db16d7b8a6c34db67517f5b57d2980ca0c6e943cb9e516709357cb9b79246c6598644ce6b0382d6b5c732a4099bf57d49cb86f644f4f9aad03901bc1c0d69c2d01ba011c59c7a144ade1216cebafe75feb686b2d252ecc87d968830e7c570bf7af83caa68fd1f88e5a8c074742e4cc592c927a5ea0742499a6b1493d971855641d55441f22cac897e0693a7d8254a7561091ff33ddb38aa4dc13c6042f959dee33794f0ff149231c06c63602f6e5cfffc944f0aadd01fd94dd532f52e006347cd837db55f5f495bac1e45e71ab649e387278a61971a820bb1053a129d57f2aca05d9161a76ceaecd36a0caaad5d7cd8364ffde2beb7ee95e899270d57d7627ed3d8f49b0a153811740785729e6017080975ff8cb67a2980cf5df9b1642b7574521ed5bd85e3eb174891a27884a187485c7c6b07e2f98468fa7335e3247591b71acb6253a5178572394af5bbb668cfb7b0ca494540c2edc927c2b5d3927ab4ccb7b85b058825d92b7413bccadff172d31157b46d62699d740d33754ded3f5f656058483fe46130ee186ba2d148f29ff1081f02583525c342d76acd23ca815f613fc772adb5c0a8da2f7f72bbaef00a6cf2da33329271097f89788dd4fb52d7418e37786ed8a6440d174a53fe8830b1e1749190f880ebd641272b1cae674d8bcf8a1822d8a319c51278c00d73b981ae5ff490c06ce1876a15f34ecf6a702039106fa467267d3f33e2f7dda56569c386579e591855b20a3e6df320df1b264cac184354c49347fd870cf93ae3c4668e6d154d04e6ce94de7d4c2fd2c0afa884ed5c7a9defedf305acd43ba4d437bf1e4d219196d40c73e59cdf977afcbd66daf4c0b112a349b337c45cc353ed85c9c49f1ce6f52a24ab3bf19e8bbfa9ac5e2f128fdcae3c089e3f6d560630ef4c1d31bb00eb5410cddac0b7b0e79ed1659533b9b145ccb89e1bc466eecf451ca1dc6a4d4db849b6cec5199c13df4e39a66d0624d87b36b49d80e52cce752225e0d202bc3635b6e7cdd61e506aad0b03bcf393aaef7b1e6a19ccaf596419d51a9f25a726cc8ccaf186898dd16eaaec87703552cd1c7480623c77e082811faefea5631f29a1b18a87b86d8dfc3d7eaae10c5dc20c93441e906f56ad3ae2a078f0f29e670f08e72130be6a9b82ec89fe80cd6e2b76db6a1360220f34dd036165891e518d0c86dd6dc0a7b74380a56acf511c71d9d6a7ae0d15f5777b0c7e99673a24b3f175699d768ff35f93497c8f23e12b9d0956908d7f7da4fdd61cdab39112ed591be91a62bebdcf47977861add5cdff84b9ca63e885b82c74b7762def2473075e8a52a58775c636e49cd58e4b34065bb8cc4be80af306d7a42477e862e2e1c059d9089520efc13d06a525f2be680d0f257d0f99488b531cdcfe1b1a37d46128821e4461028af42249ba557549ca67dfc5003b436ce69e7a9d6c9b5ace6f8142cf68cd05cbbb792ff64bd688934ecfe2ff8e017ff06dff7013111fd440af186f512c1c32f8aea7c9977e20e68cb5ea1a4a0a17806cadb3498a1bad77fadfb4fee4b5ef64fdc3205b0cbe8c6f38c7d78c889bb2bbf7f37f55dc833eacf0c5d94708422e3d8302f2681c0145dcbe9891c7b17e88d4e8f6c55cf83eafa09552d25b87e8cd7b84a4befe543bffd932363ea7d14712a21d8aea60a08a6a98c0dab1a2079fe3d23d3b222e852c7b8446c5f87f69b056a351e7ffab0402b8da2742aaa2b5e794c47374f9846b5cc705183c56a1202f9def46c2200f21dc7d2f36d6c6c05c9590e5017f50886384086ee0dd0a271c6caa06ef168c1636ec1970567c8e8617327189a06f6318479c89027f5ec7293921d497f9340c0e1a38be83adf4362ef1b740cca00666a5cea9276677920cd8e3cb4c6539d4fd85f17df2b0da746a413891a9c019e9aff2639ca2b8a91b6405ca88c6ceb0de6363284bd7b3577d625a33cf85f4b6ff3908b20cfeb5d99465f6b81f6cbef2fd3bb903351507e62d637fda555e175f62db7687d5f994a78f8a5109b75ca9cb834c7e96f667d9c67cf47b77cc39b5fd42a46b8cdf3d9ce6048c184cacbd84f6a34b595adedb2adb5694f6d149be168858869348060037058ff3381d6cdd80e6e2f304776c2e22c9a79513872c43d08bd308d9b71e111b1ee557dbf4fad0d6a160ed709d8378077ef40593a5ffa40c02bd9717935739dd166b950b14a34c4408478641afb4b01b158ea13aa6074ee74021c929e9a7ebddcaf04bd1244208e99f6e86c2bda28e6cf112909eb330aef1a963eeb3bd6a73dedd6c090983d971e16d8e2fc17c289babdcc88da68f28ab002d83a619494b5204936e2c07f8e4acd8c2ed9a8a1b91a79a28fc54e03f9632f1e680b1a028b7981b6fcd38cdf9a466655d439c92f35f3119bdb48db08a2cc85d1020a6c90c3986757f6ae1ab7b7d00d2da78cf0f0b8de69cc195fbb917eec938dd4800b345e0231f1faef42077541179409a7484bc8f491a60d15446bd0942e14f576080c7e2ce70e533ce57202728151be89e5c6f948cfc9318779da12f1ceb4f13ae6524c71f330dd06b22a5ce2480737569a199c820644705a05141e647f3046ba222fed20aae7ce265743849b2be8ea0ca4965a6c8b699a9ab9bd767d4f11295a347f7a2218aa4876304a7259b376704d9dc915ba9c9ae4f65d394716acf37b1a98bcd33e9162b515622bf57247d99b996de261c366e31f54249478b8c50b68fc209e6766d1b4ecfc9e9f7829ecae793d73306904c399a330a953eb6b8b706679da8794aebdc57561255e7e09d451338b04992b94ed1a789648cd43aad40aa9e6658d5365da2b11a7a284b40e7ddf47ce317fffdd997ecd14c35c84dcc41fe8bb5f05a221f9bf0578fd3878ed9fac15006bbe145a7d46629b09595482348be3ecc631595fa919674a6d5176fd4a48ec339588e5afa94e2e320b3603560e80be3aa27c1cffaca466b6efad827458de98691ecc78505db2e962d938a58f3d48d1887c311ea09d931973f1d805fbafe942b04b62a991a68dacd3c776b9cbc8fbf40c520301c18e8188579bb69e9431c1301e007e31821ff5e054a7bbb8c07f206136f2bf011fda38b6c12bd023e5f909e96439925ae6f27d552f2f2b1d356f18eef6014528eb33384db0f1ac7cad876eb72a16a01f83f2da5e24c9f7ffc3df5e82026c9da009d25ba8cfbf9bab3d60365170bba6718628d028b5aa1e0ee288d18cb3403cbc7ff3812d213367cc8318f5d66203a7fca8f0fc42d8e9074988169116cfb4bab5e0f98303c66669285fb1df41d436c6e88c4e011a2dfec7395d39c6615d1c05954001a10314c69f0e8af985712215b4286e72c9f0c20c4bb41d791302592306a41c7e4a7fe0f2f8afd5cb322d4a4ee3188bcad737fc2d882aa8fd83c1f516dfd104728a8ab550ec6ad43fcabfeb9bdac94999cdb8c60fd87b5983375e0c51c7d5d5223a703303831199be7672c3cc9620cdd160f7bf7719603c2ab531a9285c42a16089351edb1ebbaa47a74ac86c11f78dac7af61010599de13fe5a0f5559bc32b1bc3d4fc3cdcf649faf8cd5ef219c01ce06176ba721e1545c6e74f52ebf420a4f89952eec73df90a539f165092e4e55e5d5fba7e4d87d0f7ef2e81075725362f71a45e3597baed56615a4afa81b331f08f9a9194f27b323ec4926101c62fe4790a50c1d1009d9247dbacd25cac49948ca52bdf0371fcb6bb8e158708c9b30f9dc4ca4fe4dbb5f20b8eaf919286aa8de71ef209ef08ebbe7f7e94079dc0ea5a06ec1471305687996833f069918fe0032a8be4eb86a062f6a1e764b61f72ef25d61e7850cc6b434fa44b4ab0393d61c34bc03c058306127003d6d9cb004ddf8ea1124c65e0f45cce0482c1ef8b61c59139463a1c82d96e7161a328c4036aef10e986752a5b7c0e520eac0c949047f46b2b51d3d4592d75689ce288b4ba64684c0cd0f85808a33c57232b78d7624f48bdc06e90dcc15047396cacb8fb1a4af25620d44f690ea2d67156c6e5ed2b66f4d72b6bf4856c46dcf757fb0ebe2e5ea0ed3aadd0f18b06ff8cc63c0f2a63ecb0736b6980015300090f79867f8634f864436fe8b1a5e80b166c80ab88772225272614d4be7a29dc223d354714a88fb374673e006aaac039cb2f906f453ac1a951299005d55026baa98f6d198ab3dea31896664bc391ae65f4d7b70b136d95e4b4d539316c1d8cbe3fb0a257f14c7c295b8b5c7d90e589d6428d4f51f81fb7285d77f88ab66c85c7cdd40519e08427448c42b9065b92c3a4d0ef488a4cc22b4a416d3195c17da55557e26c7c5ff3b6f3e4eb568f80b1b74b8c65d0585787850edf32c54685dbe0177440457b5efe5581d3b47c25d5989516c85448f300a3cb97fd55336f0476145a365e3b21431930450fc64244e02c7c04396f81246332978d04eccd23403a98c55f79ff7abaad5dc134417156386f96dd1385964d08197bbf0dd8cd34bad1a062c87c066ffda23e92f5caf99d6d376a39b327213977fcd26d53055759147e72522c18dc2c69dab48a30f622f5e9bbb8046fc7d3d138328c85f73c2636abc83776d1d25449f30a22fc7791d9a977ffeff659ad8b444e0719f2b6f06189e94163113ac83541aab5a199ce0949d652b6c899b01f5d50069569a5bfdd02fd3a945f96dcbbc5b7884f4edc848cab7b2c3c7b38181de86fa01ec85aa59b326e01fdea556618fd3ae930c9e9a25d647fa762ad145125fd16dd3978b347b2f22fc55441a4f177cf22e29e7f202090413d6ec653a8fb6088bd27ae338167dcf8057afc9c4d1ed68ecf50d985804625337ce92d94f8d06f3da58d83d924f91a1d946753d7c57ef1ee9be1aba56bea45fcd2b900057f0e233fba2838f15304bc03eb11b9303ded3cc155b7cf29d9ecfd7576aa9d8f817630a44b65c301b3d38148ab7bc94efa6c264a08c4bad048701164a52c3f51fa13fbefe76a106710840b94298cac277dbd8c27a817da7df44ce1b6fe92d916375dc5f2a90fadeadb51284b1274fba78960f75a5a6759054a5b099dae2726bafe112fc72010a87578175aba7af1d331d41d646bddd528f2212c6cf27e73469c2e5a48e2bef0ffef479abe680154c0842fbf6dd84f1be396a8a4cf86d29e6eb1706cd4b0545e67c9a06767660c9196d937e30491730b9564587da82c1caa7cf8ed0b2891fdb651521dd6971006fcc390e672297b5ebaf18c8aff76def8b6ab450410baf2b785a3f41830e1cc0125a1ca04371fd89bb94734a769ff310730ccda9316bb8eafe0bba4bf3d3061a01844280683e5846262e2ee66175372f505c9e165bd8c394a26ce7aa0bc5b8c584bee5d2d710ba6e4d183713e80ef4a840d9e21e7761bab8aaf72da5ae3b48c3d7edb2ecd4652f61d188f30a2718f2340e69df03c0fc24da668cfae7545780baf6dd258813e80b9513eace79bcfdd84d18b3027e4aafa4d2f5fdd05f2279147412c8b458b2c5f2dd5ba50ef2fe85b96c0830df585fbbe54da6ff42c2d62fd7c888974fb8c8f4b14d7bd3b915caa2223542729df7b26830ea7b108edc42fd61154d5f94fe59266faec2a1330dda20032d31ace531c822f3dde1b7ef0f6866ac00c68d0ccac2be23a4cefba9dbb14e189781980593b5e8431a0947df2fdab7c3373fa86bf09c4ad92841a8a833f18de05bab13898cc5f040285960ef3a72eb68d0b9fecde7f0a50eeb2040a3a5711bee185d5ee02f0037a0d23d8e1435a8da56468d6f82536e807693e5126b6971b820c33c349482bfde019d977968a7ee1ed44129922b06a14876d5873d0d174c2124a38adf32082ce52c40fe2a924707c36c7a69319d69a5b42a47e2e27bf55d622f6f90b3e33dbea334f1aaf78b0270eef87d3ddb1094376ad7c54954a85e08654d62bf9bee84edfe5a3e7e4252ded11cbe9c11e157f0397c39092f56feeffaab12b937b381ccf40532bc2b941760785bee3379a909422d507bf05781f2206a381e106c0c7da4f04e63e3db25dfccd1667f9fdc3aaf81671a11a2800d18590b396cdcf2dd3715f3803f1026f4a5af111203732f33f021e6f57df0bd2cd684538a057d44505dfe0a676511d6a3e4b0174650f6c074b14f67470cf22bf4a1ca9c734e54e2a216befd8203d85228d12cba43d33d81c3ced80da2f4cbb426e6b2b705419c39814f992d34f64be8146cf30f787bf8114ede57ec2284cddba02670d97aff9bca5cd991a48922bb029e4508ad87b28ea590a333e7de515b615e1c7b081d33eac44a171b68f94f0b01481db5fe9b74c974c1e4d889ece19961315a335be6766a6f74c70087786732390c882aef0e9a335a871a53e376a91078b4fae6d2a405ca2848d0524a17c87eaf0748ebf70f6d831e5710d3a3a041c3127d3325ed3915a11958c5b7fe790058b3aafdc4347f3d4c13c584fe0f58f3ee65ba6f932c45003385ac5fdc83d9c66c741fe4d3741d9dcb3b3336c6c264a9ccb866e62bcc4bb6455f75a7a63e1de461b55f601590a8183f0806c3ac9486b46066c453cf93c053d3a9cf2d80de600a252479dcf1845bb43de102ddd3d5e1fb726abf2afea858a86776c674a5969e16b6d455344f6649df6abafbe614d3b4e94fbb97d5f07d48b97743275039847a7fb9582d4e7c0d9e3b4b14bfade1120d6f62cb2dd97c5ac7cd040010aa56c2d33abaea767cdabbd7cee3d6e904eade706f7d0e1ec084157eaba9e1a44c060a6d8861175635d7331576373916459b90e73c52a2628124548ec1538e73ac3b56423a615d8893082a3bffb6008ba594f1518f4644c83c6646834d9dc6c9fd750960d3fcb7e4abd7dad06a2c26a950a38bd16052b21f6e99c722ecea339b6cd75c6ad1530d80febd6662b3c40834ebd6721723764c9dfc84578057c04ae6bd539492afd799b236dae070be0ad682f9c68f83d457935c54f2d1540a6eb564faa713d4aa397022e3bc0fadb842953e519e1a3ef4b6564c662e9662c040496f146852eb7b6749195e2bb5ac7692863279d1d1794626b6a0739d981518a80f8e36e56ef723c4390f7b3534e1a265f19e2764eb0297f8c943e9d8ceb2dcec662059cbbf1c7c22df1c6e852394e313a254fa9fcf47d86df75b16e040ecb8f15a6de42cabe9ad5548f13d8655462265b92c8d2c72a2b1867e53a586ddad0f248e56f3883416e7b3e1344720cc717c1cb08ceadf7116a5af3d2b1277e58294cc5080106e53c9f38325d7621123ea906d9aeda61f6a3820f15df19518b4436da9df510a3e92c6afc1c55864212ab275787bc75b19e6b8d0b4a2b53504cabd2a7603ef0b5caace65f07af050d6824bfe43f1c5c10a1eb6e79dd73d7f8bdc1bba86b8dbf7163bad09828dd98c7c851e16ec972d425fa92197837515139f75ef5ef932212835b97d83dfe2e5a0c164fc5e737ce96ca1d7f11c0eedb7de13d2a4a20c89c635798fbf285660830160359aa4e0a89f11ba6f5032015cf61d423725c2300c7ddf5874a10355e8dc2b44db921c32e8b1124583fe97d7619f9c081d4aab657dc8b8dae7db5523697050b2d5b20ab37e1cc8864015c5ce5a0ea0aef0d38532d394d2f634b501cf884f82da7f637269fb8197110e66642b80ad902a801fd513360130eaa976be4c908d69b585df0021a58346980674600fba77c4b354bedea1c193d3709fd473bfc4ddca6b33f9f5f693164a092199defd5e835c237b80a32bdfe910d0958e085175165f09adf16f18c3dda0704464f2766d3b97d7d496adef8e2fb7dd5820c150748a98c4be1a6a3e811991ccf76dc8244632701d197c9eb7ba72d6a25f6ffd9082297d9dc4fb8a65633ff1e4938605fa8269b84c100155e38d96a8d9ce0e8ca73fcf07547a4bcff61ee22f6802c1aa3a12d90e4bd168c629b4ea9b07d0528613542b28750babf3e6bff4d861b3579fb0a6c905d7e3e802f1f353a5247f85d5ec4143187c062772a5156d7e40abd437c8e98537eeb9ebb805aa6382afb22722d45f1e0d95791022bec3ed87d34a89e99cdc2b4be08d6510392546aed5e0c854a9fbb6837875eabd5d207069cf5645e0c17b0039831048cdbc196413944bc27c5caba45f8593b9c9813501006c4fed8839d8d1aaee417eef629d297deb0ff2d0b47cf02453f3cee9ec66ce1a92a6d5e99e943d36507fd63f495ca4715b98377c63a10bb81d9cf38c8c493ec6b372431d9915e785b2a414f792506db3004803a73f4b4c54f7c80ad4f35701d27691418b227c0268bde16d6e6c5401814145746761be67fca42361436d18077c102ebefd1476e7987698c7bb35433b84cb9869d7aec5a0e68ab5022b54723888233003a07d2e98dcba8cb563b1f1e8091b6afcb90a42d55f8e2766f510ce46618a3b7baa504a02d3c351bd66a91cbca1b63130d7f7f17bb550597d7ece84cb62b1b1c28c6f292d67e89c9e26fff0a601d321093d5cb6b16cacde59f86fb156bf76e2cea4aed57ca6f3110745ac97d7a3995a25c4c7c2ec771662bcaab36a2473f6b7738d5298007d9d589ca0111e880c0bde5c058ef997832f6939eeefebb71c28f46d7d3a633485ddcdec3afdd812c7b7bdca7ea95ef923103aeda35db943922e22dda2ea618233825d5b3e90fb31509be653adf84f4c1fcc797937710dfd944291447c7cb0dd962f49a7db72d11692932ead76ae297d86ff627febbeafcd145036c8704cf43d33f539f61aa540dd28400ac74f90e290aac884fad43b63270b3b364449932e60c1e85b6ad6ae5fbe41ac84d16ebd60c487399a5f45af40c6b0ac4e9aaf7b6ce14be193a0c95420c38c3d1548c441d035cba47cfb855bc8b664f38a8b8a1b7bde127dd0184402069b48076a19a9ccdeda6de91e66a5b92a164a78cbf9311938dcb08b54712b8343a7dd32013d79bc6591041a38faf9ff3fe172ad4bf9861b07c83ed7e5d413506304e579347d9354f05a33122fc9e3e95f375d8923293c2666e45227ff4df6372151e857b1cd86282569dfc6684fab9d365d94e37098414950d09b85047cb1e08de20f1ff8ce5326ca7499518304c5b5bedbcdf38022474a450b7f7223db4b01289c846d1fdb0f3255a777e3f389b5830969600e9767bc416254b488fd84f5bda1031b906dabcc02ebd726fcddc1f9877c50edf326da418c371bdcbf4aa5da45053b8450100d18fbf1015fbfd676651afe82a5f3e2611c45fd029a81bb2fc2353513a0fcc7ac41ed7e6b7a6c0e40cdddf54f74f6344515880f49e74cde1e5dd53ed575d4d5da72e05161f28be35192b22b521d35efcdf1a974b191b8c2351a9a84145e5675b9260c5e99914af7f41096c82a068788892d0e3fe055b03cce4fc5e67cbacaad0ab54dab56092d912333f107497280a64fbced4fb43a536ed22a8e2124f009bb51f97089ef318a8e2d7c2bd5c053583bd8a7494ec69582e5d9683c33c88f1acb5328a9445e2d80c67331f156647d4930dab815ed2f42b428fe8606bad50282a8b199bb606a04e8db177fe91e291de6364b7c2364ec92d31a4a642bcb3e50c612a7be3250d76159f4d2d992bf07930cde1ec94838e13feb2e88c30b7d03a456595516571c7dd120b3da19bae86eed4941d9a1ae22885b725ef2a2ebaf2b2ec068010964119ad286a21dabf2b859e80eb089555b97382d7a2d17258d1e3f9d2ec54f6abf2d99bc748f95b3d2292189d494ea14538849a54fb5c22c95907911d630f07265ebe04a066e01b309fc5bee3c77a4341672692e779fa2aa638dfeb5cfcbfd2ceb0dfaff880cf38387e366c3290826e3fdd54b69249c619cb7e5c9830d9b756521f60ee71c74fd7f8a55af1165044d049590c728c3f9d0d5a56ab451dee8e67094d078221bb75111d442a6d17585af49300a35d27a2d6cb7878afa7c847fad54e4013055b34c403a5025130ea8e2a26aac2b866f1eb7383a0e4901b1c0a7eadf01d7b89b7a25c1d70478c0346d1e69773a8fd803eadff84610ed8d2d5465eebdb50eed315b6e2fb4de396401c14a3191273f9f00d96cae5ccb44922104b2d029fa80acec9e63bed8b30955a0c7a38bdef9b22769927e4b591e35941f7abefa22186919d4efd4cfa0663c0ed52be9998a5baeb53cf7fa4521b5d01d04a046e0b0f891254a069e6a03632c11302bb6de3684d470b757ab4f78972f8177b9955e6e7b55f4e38a8211a9562236d04d31350d3fdafd43c6c87889ee6552a1e6e4f9fef569a2fb74cbad5a749ea6212bbc53881597d3012946d553d4b57a791aded1a98df000b478f1f06d9ced3e44a0bc9f256a241d204d66fbe37a88a4ee0cbc80d836918b29d81de5500f9031c33cd40798e727b19360660bea68555eb2ff1df5b6c6bb8f46f3c465e63061305fae838bfd8a66705923b1d6250abfc59817d6ad15d8d6fb1d209f25cdf05d88e774c46b94d3359afae175852c2c42c5e0df7d02b43770aa23c8221cd28833408df068b96922fc238c1fb51a1b3ce3494fd8d78be91d75892c1fa21486c8791e64b62c90be10551e52534dc3fe9106ba4c42c946c3936a1cc7a74f022289b11877879f6bf3c2eb6879a408e21b054065ddf3627af2ca7878fbc5fce6646e2f3b78f7602957e322c061239d8a06f44a3a77cb26c47c0cff1a1240509adcfe71dc397c652f112070c3d553d1cebcdcce7dff683bf484ecd4bdf9cbf037d54f89a7f04ab87453181a4c7f903e2294f0038f99ced06510ba66cf62924cbd34b79c6b2e866ea362129ab109678a3e904910834854bcfcc350b2eba36df8b05ffb5cd8f28a073e2f8525058428d3d0c3a3710c397a117ef349878d5338d92fcfc37964a148ab70d28333b37c5c5888db1a7976a0f5521c36442b08571cf9ca219ab53d33fd6fd202b4088f7ab4b82a7b57ea667139a6374de6df8b5d6f680a9169d42582e4ebc2178054fdeaa4c746d535835315e70d6dcd19bf62d1e3867ca61f2ac01b3b983b203ccabb9ab925168cfa6d253db3034b48e1b901baf1885b7d9a899cf533e9e3631a412af84749caded9938248ac0222230add8193481b9392f4a4c07e8a8fce7839567551fbe6eeb731f0ffe04cfdcc852bf1467ed4ca31d418e80b0c74e7007121ba98faf61ea3585d80481690a91c4a1237ea98897e4a31afb4530583e1dc0df114e1e763247ad20397b1bc964613a316b0f563b98df6b14497f0d1111dd4a0e65cab7c442562852911a62451a2a84c2aac6adef5d0c146b62223adecda74e1dc3ebbbd564466220838a5cbf79c4d86313f323034f3e11f528b3a1bcff1995ad9cd615b9e75491faa574511dd87ebf40ee60528f9f7c88ee28dac4ab2114c9cdb2c0bd8218817e81b21122bc812259208d8c746a973451d43c1a0af6d795e3c4013f524d6b874b8228518531c5fb6bbd4e808e0538715d6c1c38b55a517af75b6e879f280d54ab8508b6c6e3aaa298e3fe5f7e13f8438d6b97bfa94a726b7e03781744f4d6ff3a1f9e058d9d03031609d7b313b3ecade5c34be3abe0ac4e239518a4ba2f1ab73807af99372c33029f2d114ffcfbd47b6bd0e2affcd3fe1edd660494a1c49220c073cf99095d644d43bc40053f2a76c7a2b56d8d3b52e5b00087cb6b6c8451c1f431e8f9ede882599b53985e569127e583a09f2b8fefca952f0d8e444b9e8b1f9ef6f96d0c4f3d501e9a987be3204664d460ee602240a9a3b3b345be47776d0aecb5364429f9ff5c2072acbe31d841c7b775b8c4e29096040fa90371e73c17d3c447b0f85b320aa1af8c9abb5ff3d44b869335355f76175c58e453f8bafa57e04a5545d056834a3ea3fef3ce62c72050c4043ab58eb902d9cc61d323a3ace8ccf9b4ba052a94ecb3fc396e2ae0878dc1f6e297614ff6e3e16f83ef18fc2f9c19e0c558561209a8874bc0a6cfffd150d839037dc45d6564f0216c412a732a882f4f414b24fbebc0daefe4aace8c5666e0b0e5c02fa4df16f87c22f410709984dbd1896b7b50d32881db141e690e8de344cb63e8f356dde472296aef0153f545f95e34b2e84975ff4d9907efda055feea24f595e948a1ac00c2bf9a5bfd9e2ae62a278f1236337d78a488a12a546064d1e7b2940a2d9943e9d89e3a123c5e9de6512642a109fdde463122c95bc44942d0483ece053d6b356993369f0617cdf0cb8279d37473b69713def29c5f18be443ef6e0bda3b1aeaa244019e4da85b3934e0e2f09fbef94c22a3109d408b629e07d8eecea2bff86b0aac0a406326357438b3c79a21ee59fc10f2ed0fc7b9df07e1c95e11bc4ae6b70a66750090929fee39959822accb297c7067f90596be63c735867c6e427333f5edbb47bfd7934804318ec6d37fb0d1ecf50227e68232a671018ba4060ec0fa26d2bd7354a543d679525cad17d9c85a8d51aad6d65852e36cf52d62b67c58f395bfadac8be05c58f6890df9cce2a5f3761a601655aa46f7b0c2df35af90a9b9888dd699d4178a1d605a49fcfbef938c9c3c07ae50180be633269571be498c225ba285ab404e26c069fc95f3e8d584ead88510ce3bfbe0fd799f4c0e8c2c9dae4694155b718a0d87b4b36c9eaf3d3030913ea36f501be63eccd9ef5bf02d1a59f7f2f6cd24e584f8dc5b18845420bd1136738d17e35995d7d5de35341d8bc896517351de79378330c660a0d11a39d04d2777e6e9f25d9a15891922833ac7d4b448d097a2fe3a4f1bdcbad2987fc7594adf1fd685a8494b97ecb969dc69cba6757fde0e391dc2483838af42f66d02d4f8721b03a9a80b3887c7aeee985fb2b0d1e5336209ce4b7c80b22aedccd6f892c44b86ee85e685e2aeb7aec28a82a081bbde48f2a520ccbbfc785dd6c7b615256871ce9a227262580a3ac2ff95b59f4b2fcf7655bc149ade30db0b1a040c123b5ef9350cc6aeb30b7e2296e2862ea2828548e66b5b9a3b9b77fe702e478b9e2887beb43010e139d27bd535e6a976cec065ae728ce369a0107eba3e955e566609f2c4cd5e41793836f922fc93852e9eb70057ce4e80f4675ae184508cfe3881d6c2c574e848096b210ff09fc72407ef9cbef7d6cc7bb81880b265cef1a932c2e097dd7125c2be990d8dd6664e11d73adb63472f9aefb6e3068371d8795928e249412f585b4ff9ec370b5f2439ec29b5705468ccf3d0943735ce92311220ebc05b5eb178c451ddc9ad647bcbae89ea2f8b2e544a47d19ce02d3be01e38ade2529345efa3888edbe84ddb8f17fd558ac5028f22ebd08ff3bef8a5eb316c172617652512861197a6dc5f10b62c9d98913eceaf94033923e8de4cb23963b14bddd27ba25f14f407b086480086f4dc06b85541c28d02a424003a48a02a71b33256e356f2c4e1d16638f3e15187149397454217512879bddf540eb727dd15850685fae65426972ef32d84a4b3e3720954c1dfb1fb4d6501e5beb30b016940b3f0f46113a52f84973c70d015f1cf4191278227b526f072467fb3f556b3e0b17e891040d0427c03b32c5bd3bf558294793eb9640a8fbb9f0a90254e3ff9436b52051a877ec8f8b94c0a17cc46b2dd0674c79be32cb8196d666f227ab3b474a394cb9100793476a2148799e16397d5e1995fc04f2c73cd69cb3eda748b980b7182d0d7b2e6fc3c54382e2c3bf17667cbbff6db6fe8584f91035beefe3d6e6ccc34521fe46a9a3f73bb8fd5ba23b68f386bb324bebf0c9afee68e2e8dc0bea78be0ebb07a21bf2b006564c2cdc4e808f7ee65fc74a3583463c009b03d1d7602ff2420aa5fafa604a512c98b7c9c0b409efc518fe7714b9bea4c7263c2911c08eca56414e458cbdbde5a5a862a4199eae35d1c5f87425f7cfe467f3ada971bf00abd159fd7d2f819b30c995e4b25d68d2bab6180f07167d5591b39d763710130c55bcdb4b5f3331817cb037a1a3d6decea0d987e2b04d202da03ad1678c191db44b6acef061d3e361a4c2ade6b2a26a28e0d6d733a58887ad4dd1028962d79f41a2c99d4b313b88e66aeae3c46dc92ca6b22ed66fc4c9d1502b3723962843af79d79d4e06abbb17be9d015d7a68ca887aec50a61cafcea66d7af5524fc8b3dcbef886574c42becd019cac512a75cfc842e21debb511893d85c453b998c444f30542fe971850386bb88ed5b06cda9cf3c82b27071d7621524c366573e477319b154f9f1b39a821fd6ea21867b1b04dda319d9f20c0c9030f49c072d77db759233101d24567e1943075e3132a33cfc27f4d2b4bbb43bab230cc42c086024b2abd5bd30aaf2f60b2f3da6a567fd1c015c6d53d0863441b4e739b4d81b4d789a5043381e74634261ec76e67d5c25e9fac0d5237f55a57a9cc4f27913a7596ed2b931685880c5824e96b94a85f95c9d8469e4b11ddc4a956fd712dde49f50f44b2e7eaf8c77f3796534ae7a1809bb3ef4d023e1393655c68d4a88f8a24b7aaa7df1804f507086ae250398b631c9e965971f70661a2d32251de3f96d803a45bb85e8e0a5e09652f077eb46bbcda0c5f8eb770b24233e432ad4de87523905d67e314c2d361dba150179f38e2239f407f02aef1ffd0ce3477da90a8761a4c18ad49e47a58841f43f25b91bb4bdf28ed737cf1d3996d3ed27ec13a3f570388722e4d0087cc777e6ff4f5369186f6b24c25613442b2d51f889f92f37bff23611b2e6953b61a80118649bc269cca82cacb4fb13adee840a8d426ec3ddcc8c8ee083347c57fbef911bc92b5e82fc4b448fd8b43a5775f58496b943da8286fdce469ef8c02364767d785a93cddb2be1e387ec95c2463c82b34b2cf4e807b0923131e12c8e5ea27f9fba125f7daeda8091462ccdaadb8ac5159cd3d0756c22f57960a0ad0a199a32a9b17663ae73c95b69e770ab68dfd1d08f1df8a48e40d0ea0ac2ee575045b2f47d15e0af24112d435cf2babe95c9dfc021ad291ef2cc2307b9cd4a974d0602b2b5587f0ee187cef3ef37364e0be9fd64e90d46df797c9a380595db6a5666eed0110e6278f36386e4fbba1f9332872f5e555c4fb0ce1d3aa2a64c5efd3db70ad10376547beb9b51ef6a5eb2c6e72313410b9d7e7def170dd1b231e43cd5442f3053b71fcb9f5a396523630925ec748aea2ca5f999e3a67851f25e7b31c6ff0e1f383ff360bd5ed082032992d906c1e386aa95e3987b327ac8c469dd188075d902623cff2d4dcefcd5e0e4343f34c57170b9c2ddaf6500a0a29adcb02f3c5f1abef5a18636deedfec97b6303ff0dfa53e58319e035884397946a03c51d543ab5a216584aa1e43f673e8a94521cc15f91c99c6254ad2b591e4ece9cf3ed096f498482a3ff81d77cc54a0d6b61c1ca17a64e9a9460ce4a2bb43773d18e8f278d354677c5cec0ccd72b583a71ea34c6d613b6d69a036f7846f14d45f3b2b8837a07acf9ee9b64ea6b975b17cd9d8867a00ee3fa9fbb7e30f6c7c6b3cce9102605cbb99793de9dba925e12c11b0e0696205fdd72a5d3ae31a480fa82a758ec29074b96d339ebde84db382cb77e1e405edfe6d6bec08b86f7d0f3e3a985ef17b61b03c79ca11c6ba4797e21532c06d34dc409b0cbc5ef86c72fbe9ec635036b4dad9b4163823a0f7d78acfc02bc5efb951ae0078781fbe6c25d2ac7a672c135cc09ddb1e6a3c506ad985fbca38cb4c77188bbe7f1e8ab54a16a7db21aecec373f942d76214f2775d9abc617570f2b703bb9fb316197160083cff154e1403b5db642d27d35826005f398fd8852d55e722142b95145e7fdf35127224ad27269b1dd52b534fe089dbb45d287e60bc42c6da66c1e1c223dafa77cf7b0ac47a77d1f7043e0dd8f8462bb900c1de7aff72c92eef96658b936bba0650a0f580d698dac5557996552159d17e725031b5709ef876e899fabe16fc41646f6a5f327192b5cd31e146c332a44938d0df05a8e4bcd3645b4e8065adc0a932c33bbee2e3764b09a7debdcc9a680bea2dc6d331c99f191034c3e2bbfd881c436ae7efb2647ddff37e01f078dc088f3e1604d9e3d9dd03a1e16a233208f4ea8eb9f03a7f7976bb4be0146bcef0b9b7c21835ba1aa6a408832265e96443906b470b4938cc0f17d32e80a0ec0520e9199580954212c508faec09aab4f5c42a823d228bb46fba234a386dcd1d7fe991a02338c03eadc8413254663cc005f4296df401641bb9a585b845b35118bcc7f69f73d8e755749c6d966dc6e6220a5084c90a8ff6d2bceb11cdad91dca8b30014dd200f1b3724f12e65ec79df0ed70bcf06b69f5d45d8657e59dd5ed42eeebc31dc28658eade4536e40d6869e1d8380bb02d15efb231d247a4ae679a57d5266075ce77e17abae9f32a83c4d11e2488341f0a87ea3f6dd327399863fb7611b98448d7ed87b533934d997f1fc9b5f15fa8da3ad0f5a540e89b80f0b31f61b4f818f2ef16cd6e1552ba421c15bd3d6a744ebed56f5d79fc68ce4a5b9563f4d1361845687ae21f44392aca5682bdf1fbf5b1b2fb1723790ebd9413f5379ce03a4b37d1423261a09ee5d3562817ca57fb8fbd055865876d9179d1f8fe7f6b5ea42026c220dd9b92dc238fcedb197b6c7aaa9c6118e55379ca0a2e66be989bd7440af92071379e6edcb30ac6492a959d9b23dd3ac055af498dab1730800039fcd6298ba110a35306c8e17f86e236dfd9a154e3812ae410abc85395be07c50c956a8bf3ede99122560ce91e45738a0c6e4b8db0543301c2fefe907301ae054f7a749d5aa3e57ecc96b5d8480a6fabff07d4ff484b7b79c89e0ff26608060a41f8bbad01c6f89622e717652a2e49fcf603143940199e906fcddb373c4967fa1fa60ebb5d863ac4365150d0683e541dc193bd594f3074ab4e8b8ed9a9592209ba30c783bf138699cb62c4495041d0f011cc2c18983d86b9e4dd1b2f97f90eb63d8903b77ebc7964fb105515dcdd5a04582f68ec9c0f78df3fb0de248df4445d67d724c348acbcd34cad4cb033610e4e857e8716167235b54fa658d74a0bb5a20040dab4f4bc2dd87632924bc0eef2381d1ed016a591f174181a860ac5051aab2530eabb742f439391b3b43b152e1bcc290a135e3a41276a6a3cdccceb596d1f6fd3ed18632d893222c37bb9fef1f33d893e722ae09025858fa750e45e7fed03b5eb154a645a84ce581328ed92cd889db7c5a523d7b45722603e19d42413f48d80ddbcc782da15f2570ee3e013c930c0c9ff06ece5335da69364bd789b59f4b5bcbe2b0d04a4394916b907f888299c59af773a9c37e7bc4e666cde0ce8eeb0f097ffa00c6583c5b9236a840d242d0d4b05da3f5e523ceb48159b1482f3b9d9abf834dbde97c103a644974f5ffb972f6e48e655a05aa509c1a2ab1b6c32795e9c1684ca43e3adb50008f7267f85e9eef88626ec8ea6dd6facfe016707d01ca9037d3563fb481bbdb4e0b1e7294bb443758b042b1571d9ccd297d54674091b93b3a3eb899baf273e40d280a0fe199968900d4c75b639c797d3cb97f7a03d6f3ae865dde7c202ab5445beca8be6cfdce8d7008249ea40132357212b7f993ea131382f7d112dce437e3f48765ec2d444d4558baebb66347f85fbca195e3cf564badaf07764feae2230dafbf8377b9facae0e9190f37d4df7768bde0c7f799965ce02b6b748de88ea32eb464557f039a135e887eb48f7b7f1c791cb3c82df3e66e9e649e22c24cebfdf9e4d97ddc6326cb1d80c6cc53160b0f788f3564a7693e126d9a5d9b511afff3579f1bb4d2d7e6f8b862c811c0e0d3828f80498540dcb49daf067936069b84439ca363e40178677b5942f1a70870962a7db180990cc8f3f4aea4c9364f59a99bd8bad6a18c8ad9f486bfdcaf2670a6039f8e7f84d8aacf2de0972bd5f2a8eda35c7a5b058a2ecd43ecf581c3c30e369432b513b71e5489dd15c16f1f06bc5be4f239c790a182ac5367d2f21a5e10212bf0f87528eedbf534a6b66455d62e7266d8f62dddc973330c83a3ea1fad8edf06424ff6c16dd147662c9aa9937b83717d2ee137f0ed71d5389c2733055e59f9e9cf439e4ff61d9ecb244d65a19d49bcc290e4902b868fb69972a302e635ff5ec342f9ea24e6eaf95e472ac557dc69cd2d5abb4a66b7555f296bbba2a8ef219d485daa1fc0dd262ae6e7fa6dae58f627edb8d9cba71af186bfbeabf0fe6aa2ee45520740ef6d6456623602b26a9aad5d6017fff052cdf02e16cff4b105c06ede31adbac4dc176e2c3b0c1a1d00977df0c1080877b71045f1af4bc7bf0692e7bde008c573555e32afde8047173d14e3317ab17720b675e61e8a651681dbeee19ca40eed9d76910ae7ce07f09b11963bf923fa0444eb8de5bab7b90f6ad42990103ebce98a6f2ff8008a902c849cf9829fadb405f1e5d00e6ecf4d3b569c2ebfd4a6b7a45e2cf47a0ee5d9ce240ad9e5185a1bcda1e29f799e4b3a5d063c6e8d4098352281559176db08857a8b59b5a19ba52fe58c178b1d0fdb3e7e626484228c97801254402e90885852661a88d7ba0db401b7c2d354292f1089303ca0e83d714eb65d9c0c62c0c879b29a14adfeffb078c544bd91482a43c60aff1ffed4298c6a8e16ef1a5d49178231034acac1f45359bda89e340ef5f4e930339ed08b26464a485d46308dd17a3877b74f22e21f23aa7fa7ff304e4e1071e6b9b787f7fe24270b028c579364e0a10e6c452b8c3e367bddb41db78ad633a50a0a90a56c85194b60fc937284ccdf9958970e3eccc1ee58aa94f2044f9685e098b0891ffcb56e6175c3276be32b9d615301c78bfb81caa6a741b3a14930d86b253f48a4b5dfdbb1a37e12009fb6242ac5364be489a177f3ad6a6b112445c6a74cb4426ecfb7b8275954c4254ae1f95f8d942387aea12ef387043209516c5ebf5aec8b7d00b2bd7bc780744129b7e84808c3153edc4d0ceafe2fa587a3dc0f7f06c42ae072a69ca270a3057670a5fc8a52c2649fe540b9ec2327e5b9c3077baedf4a890793975431c6b110b8b3aa3f8622a6fbf434a30fc3882c2bc0076f0f9e455957c487a2132d2237f8571eb8e6767f89153fa65b6a32f89939f07f8e779c83fa8f01ad7b0ed89da68f370ad181a162b36d89e6060b0e5363d3c26b203da139be88f2969a2d6dfc942f7484955fdfe45ad2ab41baa8a642ecbc0b873a7b72cc4f78c8a04c6062d9c702223d6738b5bbd784f8ac412b2d9ec93b6648ced5e845968f131b4c8b23212c3be542069c4c3734656e3226068a0729185d381d19ee569238a2e59139bd2a184cfb6b98f94a6140be180f01bd765e9cf8ea3f5a3614fb75a6b658308867ea5715ab6d57a4d47d52554a90efe9fa42e4e6756dd8454ec57111173843157f464d0c94a0c8931b8ee17b29b3d851aa483cd1a8f02b2e05c2d3ee390ce086f7964fc3c60d9b62fc4044114c3fb5f12ea6490593cf218f8f962d7f40c7809421b13f014eee69578a4ef3305ef4cecf48c552f6e3ec120d966f97c8b5263983013bdd6e885652218e77eb11f4152dd4e5a8c10e2dc462b431ffbcc83e90c0fbb69e020aaa44e3a8ce66285ff6511c05cb1c63342ab7048fa696c945328842de8967107a1db031f90d08e361e621916ef93440416f98c0f4867a1cc6f4311c1d2ca8f485770baed8fc70c13b7a154b902c5aeba64e868ea89a07fe088cbe1096115b14464c6dab4482bab7f9d9f78f3fc7cded0566a1a12987d9066de8698e44132b42a8969fbf56c155824274291128f68d8264b1d7bcb40773f0620e788e4009be7193f589f041b66150677f704820d475b06b80a14869468ceb500856ce72ed9378fc679691c7361413920da5e11737c9367372d72031be380a3761a2983f06f673edcd774ccd14581c2e7805ef2f5469cae07ab5a48ba6a10853ab5ed4c0081aa59c1d639b90e19b9081e7f1b0b0fbfc6bf92f6856946a65da822f0fe039061c6cfb1f3f16cb0da08c50853ab6949b8cef0db7bcf6cc601df0d6808b39808c1434787151e199ddc3e373408a52278cca987863bae5aa9aca12fcce16aa3ff2dc543bf70ea7e2f05072d50ac2e03fd0fb6083aacd893732d24c0a689fa44ae9efbdcf44cf729ca79051cb982726498e8a174ec1d2118ec11b232931022bf01ee8c9f0dc3b41b70a61742b3a8230d5a77a7e53d1a2510ba8c2ecd67206a76f1f32bb2edaef778a513604adc21fb121acf305f585cd7de2aac33f26c2c12a79ae5eaa33cb4d29ba6e8749d3b5462f7eee4d56236507030a253a84d4e66b67914263ee698b10b17b04be5b307e2fa743874ba84405a2491982a5e5d276b3b50c5f6a8e1c2c26eb9f13a728d5b33fcdfb7e08b030fe1fbd1d479b5a6b055db6d7b703044797c1c29a9fef5c52c4ec1a1c81f452193f46da87dda3ee4ce362603bb5bcae71ee6a9d20d46559a055d9bd78a1146c062463d0dfe4fdc3f85737757f8c1986ab2eb46d7100c6d71bfef515ebdefbc3f302e51c7a92ea0672c278251a84f6ef4721f15f2afbafed81b00e320a902a7f8f9d5ba1c3e486e2101bda544eec46e6dfd94c76545e6f580fa21297a7e1977d78920c1c000bc12b999b1733ebfe3cb867fd7cc8b2b2c47f81596d6934228eb490a31a91dc034a9477d7925a2b1563cfe16f4150318eae2d72f2b6b145229b374e2fbcad38f049c76052e44ff5707a38458e1f2933d3e4d44e635123e18f4c5e282ffdf0e3ae0ebf7e642f6ebfc5ab1d95b8ad8bd833d66242db5d94bf5e5d50d141c021ad8b4b3e138b50c4c812f0e5b7748540a49630d177d774f64275eecdcea4e8d24cc2e9cf483c976e419e211dba4e32f52bff6a22e874e176613a3ad7a648f61509aceae55e0b0217f8abaea41ebd426354f8ba638e6e2f637512fab8d5f7a35de3e9e835e16c3e1ed0fe2e807601db88e2b60378c8a061f8db7db4fdbb4dd451e925c1dbdb06b2b98616f6c318ff2fa5dd5fc46d6858e688986ded3e516c4448bd8d42dcc4b47e78be5c15ee000cc097ac65e8e1bc20b0e57fdcbe3c1ac27538a0673d156e7d35bc5d47a8d4f8a95382e962eb3bdda89ee19ca7c39764ec94bccec1e19108c6ed42e5d0d5c5b81f4936ce10174fa210698548bcae7e43259b30243e899449da13001429b118108ec9598effe22da36ebda06029632ebeba7571b7961ab97fd01c2c7c99e3577947ce7447fd660adf9a13f069f6a14f31f797f9a3ea688b076098233bd5fca8814b5bffd5e71ae56305aec43093fdedf71b0e7985abc2ce3c3009d90fdef09fa0f64e4240d0656f9e9b3f2148b37386b1955b058e81f4b73ebf44a0c0c349cd728194721396947a59bb33c49f562c71db2ccf4fc68d9660488b54b9d9418e108208b143a9e07503c3d46c45a94bd8f0eaef9f5ecce06b0e3448cfb10ddf72c21f9401f3b449e8ee0f4ee4c746b34faccaa56908ba394b13f12792dfb4a3db6b59793abe23889321b2b5d8ee00c5ec50cd905342aef29cc650425a9e1b9673446c0f897e8172bfa23ef50ddb733e0f0e9b4afd5853c45435958c7ddd22d89c115eb2897561b2a778884a5917a66659a1458fcc34e33c2a1b636e99954b4d7c76404a8e99b0a2743cb75ca6bc926abdcbf44968592ddb9d9f47d97d41ca0078350b09b609d32833f0c8317981bd80b9c5c8296aafb69bf0414eb87bb35a6c7f6f33a439159906dadcd9afade56541831a15d02b1d911e5ad659165ab67310971f0c15de7d7ae1a06655dc49fc68d17b2d498bac9eab193e2a9413702c0b141ff1fc386e491336d76cf01a537da0139743007fb0c9a3e6177e874cdb9863bf2768119c5984a9159e99bc007b0e8251725d204d666504f9fb9a953f5b143bb426cb0704ce1f6caf7a4fe1b4dc10d9969ee5cc9f9e6e7313dfc6e97df57bef835072348dbd5224fb0d7437d145773df391a213f80bf4ddcd52368951dac3f0bf35a160e31b09a5217699d15e94fa5d3311270633f3d05fa848b6a375207b0622c34fb612c20abbd0f498fccf48e5f33adee270037473a338fb626846933a5953eaa0bb83c9c7746a8b6afb9a7718338904c7f7a1f82b1360beea6db41c200f76221bc7aee7eb423336de7476f7c6e901c7a18deb3d9735457313682fc3645194b0a26875b80e75103c4c84ec7ed95c48e65799bc265e398df9825213abcc11ba9741003815847b5b57f22164026eb0f18866aae0a097b94ed0b159115fc52332b0eef2200308fb8f3ac1e03d7220e61464f9bcb16c77bc0e95eaf542286ea27503209905588d3bac79c152e5291f08e0a1a8fb6cc662e57fdb9e1d1fad64108cc7f5a6b546dc9ff43e8a5371de11f175cd85334071bcf5311d5529e6d9d63fd0f125e3521028952b553c6b2be344d0138b823d55c8ff4842288e22405298c26ec0b68cae3de37411aa3053ecef5ec19e8c1f653b658deaf035c06cd40ab8ce182403b03127762d0ba94a8e29229ec20403b84dd3feabb4db36a04bbcad6985875e086ffcd5b30904500c71ecc4331f6655d00884507c8372d1f918f046580cabf515d8f903d084090c94807baeafc6a9b0d864d4a4dc9b010d53bfae16499c4902d5d58088db58264e613a20abb1406ad0ef76bc5aaf5812aad71e10cc7985f7af1eb69a66334ae310d1266547a1b0fa0d84922f8d258342b559666fe4ca7e075cd05f9575f681066606b1a8639f2b9622f770c6291961bdcc5bb4561017b036bca68b3e3b245e4b64422dcf04c5c8c3d7d22d9093dfb899d01c4200c310f779b6062318a1daa94b92017e9721d5131794ec5da65a1a137e69600cb7b8b702a0ebe7360e9caeeafe4069d5dadfd706336d8aa16eb72be5a1857a2e4be28a5e3877d1f7a63bdfaa92e8977627a44c68f9598e3a6aec0cfb5b76bb781ff6e04d71584b6c90fabce53bd35786805ea8bc998b15495efbf33a651fd3af94da1c1f074e186a2975947c8f4d656aca13bb201365f97d7602fcfcbe6db2aa15d6a3e7b504c6a3a1238371efc1324047e43b82068ab7a2d89ad1950cb8d3c794215ad7d0a6d4907d0523a7872b10ca9dad0b5334a21c199406a1812c1cc34b2f70baba4ab37a3c64e2bbd11001d3eb204bd21b758500387a2220550a0e1fc3f228f4cf3e58cb2d7f57b76a81f7c92414053061e3864d2fa73d51e4b5fc04e759d2e4b2d50f96562d2beb0e584ac0c173cde72cf840b6634a738f08e0f200423c59f03e00757495f2009e9a020db71df7e75fc1edc5732659dc275eeed70aec4b0c7d7d000b3985fe74fec6fc00d1b0de10d3c9f73fbdc24bfcd34f6b3d2b7eea02eeed944ae9c1eef810ec99b18769c83ca83aa5caff0b8e8f119fb82b5cdf5fd565aed96be880041c1ff90b6c3d057bf9441dccb895253562eb4f89ebe1cded666648b0ab24d7d495465b4352a8667d459cfae3c712ddbd3ab5bb1c235690b747343bc5b7b9db9e4c2158c86b58bb85d73732a3613fca80e8f6fd1b129b479510031d1e33f2ef9f994d0435e8812eacb8b31bc452b03df95b49636341e884b71aacc13768a7a89b6fe2b2dca2c997200ddbd8927d4fd1d5bc64ef74d7dfad5beccfc18bd3b76d0a575d4628f1c328102a69a78d7b33d433fb756aac68cb79a80cc25345ad6a8fc7bca6c5e4dcf5e6fc3ece5b515b27c38186c4e75179bfaf5eed8ba9b9e342b338df9fb63eabe5ffece40bfec8e0b6847048874eb6c423e675af9ffe92a6ddf95a7a0e39e3ee6954cc01d4232e6bfe80d1400cb4f8f7e8bc083a028e118108de9f64633333ff264105ca95748de6316770c3fa4d1831e6082b4a06dccff4837817c0e7a071035e0d842ec600afa510d1804461e06d4c7e47873c0ad5cdc99667dec114c22cb46cf9740719f4522a0037000f51b7c1a8e660065181d4e7549ace8c4fd57ffce06b4c640ae71bd1fe1226916b582663ee4d95dfe5bde38c5aecd7a66b02bb1b37d1440b2593d5bacc28af842e1770a7e987e39e9efe421bfe2179af2fb1f01daa24c4ceb1a12ab625e1bbd915ea8ac52b02cc03a50673ba1c59c92c2b44900a0701dda1d376c74cde66aeff7f9199b64ee9a13c3b159a634a8ccb4ea1fb0d79e817052e79baf056abcad07d199cfad54121aa38d51731aeea2ec4acb26d64285f21ac337c21b85e93849edfd478ef9d6946e1a1cdc16db98e1d89cad16867a7f2cd2716e64d2054efb6eec85e20fcfd30d90847eeee7ef4a21bfd4b38a30c6fac3d68e8294ecb497613baac7aec2f1ad7dcdf8465d3425b4f4dedf1cdb60687191e7674336e12f960c9ca75af00a914cdcfacd4436c49144f01f60bb7ee162159d5766e35982faeb62f9b40008ee1cf2bb8aaf2dce5aa7762f49450992259aeac2d77cabfb623c1939fc7da1d8f8777d30945255b9788277172c9da834747cf772c5af36325e16e83a3701c77763d7d12c058fbb4e50a2a29a0e5cffa46b8b4d5c7e6ca067f52261ca658289a2dc646f4b1248571ab9091692c9fb0bf7c91d7bf677bd73bcd02a597c5a3ab65f03a65ead3df4c8c795fc42e66036b31404f9ddf696144e87502b68d6edbd50adc3501ced8b97e48414e016ecef5aaa13e596276e822bbb7ef0c865ed754f1823a95e19eb72f87f9e088b5d84999fcefed6272f526b257dca3d4993f0ca742dc34b3c3432d4bc85985cacb3332b8a6d29dcd74b7781985063d0bcc4054cceedc9836ecc7970f4125f2141f89a8b4fab598bf56c46b56229f522c2133f055b4da5eac6724fd70f4e948ef80271f48f6c11009cee9c3046b78b23635a15313f2d724b7ace9eada6a732d2b291b3ab04f3de25c354fb95435b79b2f929c870dbaa38f7cddcf7249e04a889a8a7778f349d70fee63a420d297dd32b610c873d836bd2c8d83bb1de5938f33314944521e7265c5ff706fde18652dbd011b7a513536083a642270c52b21d9434bdbe975d11861cb52748e22b43df78821a0917a99a9e01911c1bb096b08ef8e34259516651cf29e2e8d9a37646afb3f420b4c84c14d5d4a999463302744498301a24e9e5a85c849e3d9d2d125bafeaa4c7a5874e08bad8003ed7eefee2a19919b6e50ec9d985f581a43fdcdf70948e31ad0d2ec48e1d60eeecc4f2660075d6e470e6f49a689fe357bc02b1df487dad158bc1be517c72223483a3e56cd8e0996b6c5fe594ee51553b968dbcd97c7a40a48ec3417046bf500ac316e471ebba9baf8ce8f2203f9d6d8760a593840486ee3a6281c7b63112544ee478e8ffddad3e497318c912dc3f1f92165f40dae1f809002858b6257545039f54be3277fbc1fc35da84d4c3cf55abb13a343db05b9e487c7edf4a0dd1e989c192ae72ac571cccef29d95b9698f99a4c7eb6e66dacfea06759c2b673b599c832d619ddbbffb390739dd5b16a71b1595d27bddf1e5ad21a55e3220359888b40679df797e7a1f63ebc659f43878c1b48216266c88357b8717622a7b1c30a53a7413e67101b1f0849b8820f9418dd6a5f880ba7e6ea0a61657dce08e8ba39c33f200c862f9acdfab6c5479bcce7b3a33a986bba7fe4cc2d117021b502e2fc3d92a78e110c1aabcf5e0f3e11b68c926d6fa7ce8c2c4cd7c6c9e65bc49d8191f126b288322759e0b4e9d0ed50cc673f2baaa4c0eb92eb8afcc12caacbda9d82525e9545ffa32a101cf31fdfe38dc9bfdb6cd401a82264b82c108e956361a0455a7049f0e37444ff1cc77cee7314973b9c37c2bcceea089cdd3aecbcd6a56e726014205135b4ddca7a2749139d4eabf48fc1d29d452618420c908efba77d91dd05114ca44de5e8b52ee771c32bf9e12229c54547bbd3b9b10e55f964097aadbd594e5a4bace8c3ed493dcbe85a5b0647979639eb529772d089f0ab0fef75be9e7d09db5086dfd5722cdad524a306ad9ea65e71ad73e3d1e1f208ac54f100f13ed6fb3f5722060e9c0836c4b12456d72d1e6682c94e7d92062e2715ee266cb23b2515c824ee1dbe22abbcb783201ffe66fb70e46854cc620684d4525ebc625759bbf4855c8bcbfefc50a4a090d2f2b4a74cfe3624fd4f5f59d7949b239f29c4caf053e2f749be7478d7872bb9c524167ad07804124135ac6576027626990bca903e0926199cad95c52a26802c6c38c58bc387cd2e1bc1e49b47004314715fef1a221908d13f532deba7064b3b2ba0ad6e10e14481d6aa65120cf934acdeea38e5d4a5c206140aa013720d4d5e1d149623af20d9512a6cf7e13c3b29eb2e67a8374d20d48dbace9de4aa993a60a6fdd84ab67a3e020a170d1de6403b95f5d13db7b1a38577a9ae8543162dd318bea8c7d4adb8a38ae8066ebe8cdf09a5fd98e4282d8b5b93af06f4260f28f00846014382621f6e8ec15fe6bd9f07a2555eedfb4c8113d5e3ba21a242447533a4128035256115265ed67e3cfac00b67c9f64029fb0f7ac497784731f3a42f5ce9285fe5594a224f8312f39c4a104f61077af7f4213332411f553523406e158034eb148949a68f9785e6be5175389071befb8444871019777564fd30533c62f50f007f1fe7facc992c04df74</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-xray">
      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好，这里需要密码。</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>项目</category>
        <category>确定性网络</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>确定性网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 学习笔记</title>
    <url>/posts/230909171809.html</url>
    <content><![CDATA[<h2 id="1- 什么是 Docker？">1. 什么是 Docker？</h2>
<p>Docker 是一个开源的容器化平台，用于构建、打包和部署应用程序。它允许开发人员将应用程序和它们的依赖项打包成一个轻量级、可移植的容器，然后在任何支持 Docker 的环境中运行。</p>
<h3 id="1-1-Docker 的核心概念">1.1 Docker 的核心概念</h3>
<p>在深入学习 Docker 之前，了解以下几个核心概念是很重要的：</p>
<ul>
<li>
<p><strong>容器（Container）</strong>：一个 <strong> 独立 </strong> 运行的沙箱（sandboxed）应用程序实例，包含应用程序及其所有依赖项。容器是 Docker 的基本构建块，有以下特点：</p>
<ul>
<li>
<p>利用 <a href="https://medium.com/@saschagrunert/demystifying-containers-part-i-kernel-space-2c53d6979504">kernel namespaces and cgroups</a> 实现隔离 / 独立。</p>
</li>
<li>
<p>是一个可运行的镜像的实例，可以使用 DockerAPI 或 CLI 创建、开始、停止、移动、删除一个容器。</p>
</li>
<li>
<p>可以运行在本地机器上、虚拟机上或者部署在云上。</p>
</li>
<li>
<p>可移植的（能运行在任何操作系统上）。</p>
</li>
<li>
<p>与其它容器隔离并运行自己的软件、二进制文件和配置。</p>
</li>
</ul>
</li>
<li>
<p><strong>镜像（Image）</strong>：一个只读的模板，用于创建容器。镜像包含了运行应用程序所需的一切，例如代码、运行时环境、库和依赖项。</p>
</li>
<li>
<p><strong>仓库（Repository）</strong>：用于存储和组织 Docker 镜像的地方。可以将仓库看作是镜像的集合。</p>
</li>
<li>
<p><strong>Dockerfile</strong>：一个文本文件，包含了一系列命令和指令，用于从头开始构建 Docker 镜像。</p>
</li>
</ul>
<span id="more"></span>
<h3 id="1-2-Dcoker-registry">1.2 Dcoker registry</h3>
<p>Docker Registry 是用于 <strong> 存储、管理和分发 Docker 镜像的中央仓库</strong>。它允许用户将自己创建的镜像上传到仓库，或者从仓库中拉取他人创建的镜像。在 Docker 中，默认使用 Docker 官方的公共注册服务器，称为 Docker Hub。此外，还可以在本地或私有云环境中搭建自己的 Docker Registry。</p>
<p>以下是 Docker Registry 的一些重要概念：</p>
<ol>
<li>
<p>镜像（Image）：Docker 镜像是一个包含了应用程序、运行时环境、库和依赖的只读模板。镜像是构建和运行容器的基础。在 Docker Registry 中，镜像被存储和管理。</p>
</li>
<li>
<p>仓库（Repository）：仓库是包含多个镜像的集合。仓库可以用于组织和管理镜像。每个镜像都有一个唯一的标签（tag），用于标识不同版本或变体的镜像。</p>
</li>
<li>
<p>注册服务器（Registry Server）：注册服务器是存储和分发镜像的服务器。Docker Hub 是 Docker 官方提供的公共注册服务器。除了 Docker Hub，还可以搭建私有的注册服务器，例如 Docker 官方提供的开源项目 Docker Registry 或第三方的解决方案。</p>
</li>
<li>
<p>仓库名称（Repository Name）：仓库名称用于唯一标识一个仓库。它由用户名（如果是私有仓库还包括域名）、斜杠和仓库名称组成，例如 <code>username/repository</code> 或<code>domain.com/username/repository</code>。</p>
</li>
<li>
<p>标签（Tag）：标签用于标识仓库中的镜像的不同版本或变体。通过标签，可以区分不同的镜像，并拉取特定的版本。</p>
</li>
</ol>
<p>常见的 Docker Registry 操作包括：</p>
<ul>
<li>
<p>拉取镜像（Pull Image）：从注册服务器上拉取镜像到本地，以供使用或进一步构建容器。</p>
</li>
<li>
<p>推送镜像（Push Image）：将本地创建的镜像推送到注册服务器，以便其他人可以访问和使用。</p>
</li>
<li>
<p>搜索镜像（Search Image）：在注册服务器上搜索和浏览可用的镜像，以找到感兴趣的镜像。</p>
</li>
<li>
<p>删除镜像（Delete Image）：从注册服务器上删除不再需要的镜像，释放存储空间。</p>
</li>
</ul>
<p>使用 Docker Registry，你可以方便地共享和分发镜像，构建自己的镜像仓库，并进行版本控制和管理。无论是使用公共注册服务器还是搭建私有的注册服务器，Docker Registry 都是 Docker 生态系统中重要的组成部分之一。</p>
<blockquote>
<p>什么叫分发镜像？<br>
分发镜像是指将 Docker 镜像从一个地方复制到另一个地方，以便其他用户可以访问和使用该镜像。</p>
<p>分发镜像的过程一般包括以下步骤：1）Dockerfile 构建镜像；2）打标签；3）推送到 Registry；4）拉取镜像。</p>
<p>分发镜像的好处包括：1）共享性；2）可移植性；3）版本控制：使用标签来管理镜像的不同版本，可以轻松回退到先前的版本或升级到新的版本。</p>
</blockquote>
<h2 id="2-Docker 的安装和配置">2. Docker 的安装和配置</h2>
<h3 id="2-1- 安装 Docker">2.1 安装 Docker</h3>
<p>首先，需要安装 Docker 引擎。以下是在常见操作系统上安装 Docker 的步骤：</p>
<p><strong>Ubuntu</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install docker.io</span></span><br></pre></td></tr></table></figure>
<p><strong>Windows</strong></p>
<ol>
<li>前往 <a href="https://www.docker.com/products/docker-desktop">Docker 官方网站</a> 下载 Docker Desktop。</li>
<li>双击安装包并按照指示完成安装。可能需要更新 WSL，<strong>需要把 Windows 的更新计划打开</strong>，否则可能无法更新 WSL。</li>
</ol>
<h3 id="2-2- 配置 Docker">2.2 配置 Docker</h3>
<p>安装完成后，你可能需要进行一些配置。例如，你可以设置 Docker 镜像加速器以加快下载速度。以下是一个示例：</p>
<ol>
<li>打开 Docker 配置文件：</li>
</ol>
<ul>
<li><strong>Ubuntu</strong>：<code>/etc/docker/daemon.json</code></li>
<li><strong>MacOS</strong> / <strong>Windows</strong>：Docker Desktop 应用程序 &gt; Preferences &gt; Docker Engine</li>
</ul>
<ol start="2">
<li>如果文件不存在，创建它。然后，将以下内容添加到配置文件中：</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;https://your-mirror.example.com&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;insecure-registries&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>保存配置文件并重启 Docker 服务：</li>
</ol>
<ul>
<li><strong>Ubuntu</strong>：
<ul>
<li><code>sudo systemctl daemon-reload</code></li>
<li><code>sudo systemctl restart docker</code></li>
</ul>
</li>
<li><strong>MacOS</strong> / <strong>Windows</strong>：在 Docker Desktop 应用程序中点击重启按钮。</li>
</ul>
<h2 id="3- 使用 Docker">3. 使用 Docker</h2>
<h3 id="3-1- 运行容器">3.1 运行容器</h3>
<p>要运行一个容器，首先需要一个 Docker 镜像。可以从 Docker 仓库中获取现有的镜像，或者自己创建一个。以下是一个运行基于 Ubuntu 的容器的示例：</p>
<ol>
<li>拉取 Ubuntu 镜像：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker pull ubuntu</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>运行容器：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -it ubuntu /bin/bash</span></span><br></pre></td></tr></table></figure>
<p>这将以交互式终端的方式在 Ubuntu 容器中运行一个 bash shell。你可以在容器中执行任意命令。</p>
<ol start="3">
<li>退出容器：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">exit</span></span></span><br></pre></td></tr></table></figure>
<h3 id="3-2- 构建自定义镜像">3.2 构建自定义镜像</h3>
<p>使用 Dockerfile 可以构建自定义的 Docker 镜像。以下是一个简单的示例：</p>
<ol>
<li>
<p>创建一个新目录，例如 <code>myapp</code>，并在其中创建一个名为<code>Dockerfile</code> 的文件。</p>
</li>
<li>
<p>在 <code>Dockerfile</code> 中添加以下内容：</p>
</li>
</ol>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用较小的基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 维护者信息</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=<span class="string">&quot;Your Name &lt;your.email@example.com&gt;&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Vim 编辑器</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get install -y vim &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get clean &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装所需的软件包, 将多个 RUN 指令合并为一个（减小 image 的体积）</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install --no-cache-dir --upgrade pip setuptools wheel &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    pip install --no-cache-dir \</span></span><br><span class="line"><span class="language-bash">    langchain==0.0.162 \</span></span><br><span class="line"><span class="language-bash">    openai \</span></span><br><span class="line"><span class="language-bash">    fastapi \</span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地项目文件复制到容器中</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./ /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> ENV_VARIABLE_NAME=value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;/app/src/main.py&quot;</span>, <span class="string">&quot;--extra-arg&quot;</span>, <span class="string">&quot;value&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p>以上示例使用了 python 作为基础镜像，并在容器中安装了一些软件包，设置了工作目录，复制了本地文件，并设置了环境变量和默认运行命令。</p>
<ol start="3">
<li>在 <code>Dockerfile</code> 所在的目录中打开终端，并构建镜像：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker build -t aigc/plugins:v1.0.0 .</span></span><br></pre></td></tr></table></figure>
<p>这将使用 <code>Dockerfile</code> 创建一个名为 <code>aigc/plugins</code> 的镜像，版本号为<code>v1.0.0</code>。</p>
<ol start="4">
<li>运行容器：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --restart=always -d --name aigc_plugins -p 8385:8385 \</span></span><br><span class="line"><span class="language-bash">    -v /home/aigc/mount/plugins/data/store:/app/store \</span></span><br><span class="line"><span class="language-bash">    -v /home/aigc/mount/plugins/data/cfg:/app/cfg aigc/plugins:v1.0.0 python /app/src/main.py \</span></span><br><span class="line"><span class="language-bash">    --ip 0.0.0.0 --port 8385 --url http://0.0.0.0:8383/v1/completions</span></span><br></pre></td></tr></table></figure>
<p>现在你可以在自定义镜像的容器中运行你的应用程序。</p>
<ol start="5">
<li>进入容器：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> -it aigc_plugins bash</span></span><br></pre></td></tr></table></figure>
<ol start="6">
<li>删除容器：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">rm</span> -f aigc_plugins</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">rm</span> -f &lt;container-id&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="7">
<li>查看容器运行的日志，并保存到文件中：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker logs -f aigc_plugins | <span class="built_in">tee</span> -a aigc_plugins_logs.txt</span></span><br></pre></td></tr></table></figure>
<ol start="8">
<li>打包保存镜像：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker save -o aigc_plugins.tar aigc/plugins:v1.0.0</span></span><br></pre></td></tr></table></figure>
<ol start="9">
<li>加载本地镜像包：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker load -i aigc_plugins.tar</span></span><br></pre></td></tr></table></figure>
<h2 id="4-Docker-Volumes 与 Mount">4. Docker Volumes 与 Mount</h2>
<p>Docker Volumes（卷）是 Docker 中用于 <strong> 持久化数据 </strong> 的一种机制，它允许将主机上的目录或文件与容器内的路径进行映射，从而实现数据在容器和主机之间的共享和持久化存储。</p>
<h3 id="4-1- 创建 -Volume">4.1 创建 Volume</h3>
<p>使用 <code>docker volume create</code> 命令可以创建一个新的 Volume。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume create my-volume</span></span><br></pre></td></tr></table></figure>
<p>上述命令将创建一个名为 <code>my-volume</code> 的新 Volume。Docker 会在宿主机的默认 Volume 存储位置上创建一个目录，用于保存 Volume 的数据。</p>
<blockquote>
<p>Where is Docker storing my data when I use a volume?</p>
</blockquote>
<p>使用 <code>docker volume inspect</code> 命令查看 Volume 存储位置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume inspect my-volume</span></span><br></pre></td></tr></table></figure>
<p>接着，你将看到如下信息：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;CreatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021-06-01T16:18:36Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Labels&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Mountpoint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/volumes/my-volume/_data&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my-volume&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Mountpoint 是数据在磁盘上的实际位置。请注意，在大多数机器上，您需要具有根访问权限才能从主机访问此目录。但是，这就是它所在的位置。</p>
</blockquote>
<h3 id="4-2- 容器中使用 -Volume">4.2 容器中使用 Volume</h3>
<p>在运行容器时，可以使用 <code>-v</code> 或 <code>--mount</code> 参数将 Volume 挂载到容器内的路径上。</p>
<h4 id="4-2-1-v 参数卷挂载">4.2.1 -v 参数卷挂载</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d -v my-volume:/path/in/container my-image</span></span><br></pre></td></tr></table></figure>
<p>上述命令将创建一个基于 <code>my-image</code> 镜像的容器，并将名为 <code>my-volume</code> 的 Volume 挂载到容器内的 <code>/path/in/container</code> 路径上。</p>
<h4 id="4-2-2-mount 参数卷挂载">4.2.2 --mount 参数卷挂载</h4>
<p>使用 <code>--mount</code> 参数可以更细粒度地配置容器中的 Volume 挂载。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d --mount <span class="built_in">type</span>=volume,<span class="built_in">source</span>=my-volume,target=/path/in/container my-image</span></span><br></pre></td></tr></table></figure>
<p>在上述命令中，我们使用了 <code>--mount</code> 参数来指定挂载的类型和配置。<code>type=volume</code> 表示挂载类型为 Volume，<code>source=my-volume</code> 指定了要挂载的 Volume 的名称为 <code>my-volume</code>，<code>target=/path/in/container</code> 指定了挂载到容器内的路径为 <code>/path/in/container</code>。</p>
<p>除了指定挂载类型、Volume 名称和路径外，<code>--mount</code> 参数还可以接受其他选项，例如读写权限、文件系统类型等。下面是一个更详细的示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d --mount <span class="built_in">type</span>=volume,<span class="built_in">source</span>=my-volume,target=/path/in/container,ro,volume-opt=option=value my-image</span></span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们添加了一些额外的选项。<code>ro</code> 表示将 Volume 挂载为只读（read-only），<code>volume-opt=option=value</code> 表示指定了额外的 Volume 选项。你可以根据需要使用适当的选项来满足挂载的要求。</p>
<p>使用 <code>--mount</code> 参数进行 Volume 挂载可以提供更多的灵活性和配置选项，例如指定挂载类型、读写权限、Volume 选项等。这使得我们能够更好地控制容器与 Volume 之间的数据交互。</p>
<h3 id="4-3- 挂载主机目录作为 -Volume">4.3 挂载主机目录作为 Volume</h3>
<p>除了使用命名 Volume，还可以直接将主机上的目录或文件挂载为 Volume，即 <strong> 绑定挂载（Bind mounts）</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d -v /path/on/host:/path/in/container my-image</span></span><br></pre></td></tr></table></figure>
<p>上述命令将主机上的 <code>/path/on/host</code> 目录挂载到容器内的 <code>/path/in/container</code> 路径上。</p>
<blockquote>
<p>绑定挂载（Bind mounts）允许将主机文件系统上的特定路径直接挂载到容器内的路径上。<br>
卷挂载（Volume mounts）通过使用 Docker 卷 (Volume) 将容器内的路径与主机上的路径进行关联。</p>
</blockquote>
<h3 id="4-4- 查看 -Volume">4.4 查看 Volume</h3>
<p>使用 <code>docker volume ls</code> 命令可以列出所有已创建的 Volumes。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume <span class="built_in">ls</span></span></span><br></pre></td></tr></table></figure>
<p>上述命令将显示所有已创建的 Volumes 的列表，包括它们的名称和所在的路径。</p>
<h3 id="4-5- 删除 -Volume">4.5 删除 Volume</h3>
<p>要删除一个不再需要的 Volume，可以使用 <code>docker volume rm</code> 命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume <span class="built_in">rm</span> my-volume</span></span><br></pre></td></tr></table></figure>
<p>上述命令将删除名为 <code>my-volume</code> 的 Volume。请注意，只有在没有任何容器使用该 Volume 时，才能成功删除。</p>
<h3 id="4-6-Volume-Mounts-Vs-Bind-Mounts">4.6 Volume Mounts Vs Bind Mounts</h3>
<h4 id="4-6-1-Volume-Mounts 的特性">4.6.1 Volume Mounts 的特性</h4>
<p>卷挂载通过使用 Docker 卷 (Volume) 将容器内的路径与主机上的路径进行关联。Docker 卷是一种特殊的目录，用于存储容器中的数据。卷挂载具有以下特点：</p>
<ul>
<li>
<p><strong>主机位置</strong>：Docker 选择卷的主机位置，通常在宿主机上的特定目录中。</p>
</li>
<li>
<p><strong>数据持久化</strong>：Volume 提供了一种持久化存储数据的方式。即使容器被删除或重新创建，Volume 中的数据仍然保持不变。</p>
</li>
<li>
<p><strong>容器间数据共享</strong>：多个容器可以共享同一个 Volume，使得它们可以轻松地共享数据。</p>
</li>
<li>
<p><strong>与主机文件系统交互</strong>：通过将主机上的目录挂载为 Volume，容器可以访问主机的文件系统，方便与容器之外的环境交互。</p>
</li>
<li>
<p><strong>备份和迁移</strong>：使用 Volumes 可以方便地备份和迁移容器的数据，通过备份或迁移 Volume，可以快速复制或迁移整个容器的数据。</p>
</li>
<li>
<p><strong>卷驱动程序支持</strong>：卷挂载支持使用不同的卷驱动程序，例如本地主机文件系统、网络存储或其他存储后端。</p>
</li>
</ul>
<h4 id="4-6-2-Bind-Mounts 的特性">4.6.2 Bind Mounts 的特性</h4>
<p>绑定挂载允许将主机文件系统上的特定路径直接挂载到容器内的路径上。绑定挂载具有以下特点：</p>
<ul>
<li>
<p><strong>主机位置</strong>：您可以自行选择要挂载的主机路径，它可以是任何主机上的目录或文件。</p>
</li>
<li>
<p><strong>与主机文件系统实时同步</strong>：容器中的更改会实时反映在绑定挂载的主机路径上，反之亦然。</p>
</li>
<li>
<p><strong>灵活性</strong>：绑定挂载允许容器与宿主机之间进行更紧密的交互，方便开发人员对文件进行编辑、调试或测试。</p>
</li>
<li>
<p><strong>支持权限和访问控制</strong>：绑定挂载可以继承主机文件系统的权限设置，以控制容器对文件的读写权限。</p>
</li>
</ul>
<h4 id="4-6-3- 选择使用卷挂载还是绑定挂载">4.6.3 选择使用卷挂载还是绑定挂载</h4>
<table>
<thead>
<tr>
<th></th>
<th>命名卷 (Named Volumes)</th>
<th>绑定挂载 (Bind Mounts)</th>
</tr>
</thead>
<tbody>
<tr>
<td>主机位置</td>
<td>由 Docker 选择</td>
<td>由您决定</td>
</tr>
<tr>
<td>挂载示例 (使用 <code>--mount</code>)</td>
<td><code>type=volume,src=my-volume,target=/usr/local/data</code></td>
<td><code>type=bind,src=/path/to/data,target=/usr/local/data</code></td>
</tr>
<tr>
<td>容器内容填充新卷</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>支持卷驱动程序</td>
<td>是</td>
<td>否</td>
</tr>
</tbody>
</table>
<p>在选择使用卷挂载还是绑定挂载时，可以根据具体需求和场景来进行决策：</p>
<ul>
<li>
<p>如果需要数据持久性、跨容器共享和卷驱动程序支持，则应选择卷挂载。</p>
</li>
<li>
<p>如果需要与主机文件系统实时同步、灵活的文件访问和交互，则应选择绑定挂载。</p>
</li>
</ul>
<p>在实际应用中，根据不同的需求，卷挂载和绑定挂载可以结合使用，以满足容器与主机之间数据共享和交互的需求。</p>
<blockquote>
<p>容器内容填充新卷是指在使用卷挂载（Volume Mounts）时，如果目标卷是新创建的并且为空（即没有初始数据），<strong>容器启动时会将容器内的内容填充到新创建的卷中</strong>。</p>
<p>这意味着，如果使用一个新的、空的卷挂载到容器内的路径上，并且容器内的路径中有预先存在的数据，那么在容器启动时，这些数据会被复制到新的卷中，以便卷中具有与容器内部相同的初始数据。这样可以确保在容器重新创建或迁移时，新创建的卷具有与原始容器相同的初始状态。</p>
</blockquote>
<h2 id="5-Container-networking">5. Container networking</h2>
<blockquote>
<p>请记住，默认情况下，容器是独立运行的，对同一台机器上的其他进程或容器一无所知。那么，如何让一个容器与另一个容器通信呢？答案是网络（network）。如果将两个容器放在同一个网络上，它们就可以相互通信。</p>
</blockquote>
<h3 id="5-1- 容器网络特性">5.1 容器网络特性</h3>
<p>容器网络是 Docker 中一个重要的概念，它允许 <strong> 在容器之间建立网络连接和通信</strong>。通过容器网络，可以实现容器间的数据传输、服务发现和跨主机的容器通信等功能。以下是容器网络的一些关键点和特性：</p>
<ul>
<li>
<p><strong>网络命名空间 (Network Namespace)</strong>：每个容器都有自己独立的网络命名空间，使得容器可以拥有自己的网络栈，包括网络接口、IP 地址和路由表等。这样可以实现容器之间的网络隔离，避免网络冲突和干扰。</p>
</li>
<li>
<p><strong>虚拟以太网桥 (Virtual Ethernet Bridge)</strong>：Docker 使用虚拟以太网桥来连接容器和宿主机的网络。每个宿主机上的 Docker 守护进程会创建一个名为 docker0 的桥接接口，<strong>通过该接口与容器的网络命名空间相连</strong>。</p>
</li>
<li>
<p><strong>网络驱动程序 (Network Drivers)</strong>：Docker 提供了多种网络驱动程序，用于实现不同的网络功能和配置选项。默认情况下，Docker 使用桥接网络驱动程序 (Bridge Network Driver)，但还支持其他驱动程序，如 Overlay、Host、Macvlan 等，以满足不同的网络需求。</p>
</li>
<li>
<p><strong>容器间通信 </strong>：容器可以通过使用网络连接和端口来实现相互通信。<strong> 可以使用容器的 IP 地址、端口号或容器名称来访问其他容器上的服务</strong>。容器网络还支持多个容器共享同一个网络端口的负载均衡和服务发现功能。</p>
</li>
<li>
<p><strong>跨主机容器通信</strong>：通过使用网络驱动程序中的 Overlay 网络模式，可以在多个主机上创建一个虚拟网络，使得不同主机上的容器可以直接通信。这为构建分布式应用和容器编排平台（如 Docker Swarm 和 Kubernetes）提供了基础。</p>
</li>
<li>
<p><strong>外部网络访问</strong>：容器可以通过端口映射 (Port Mapping) 的方式将容器内部的服务暴露给外部网络。通过将容器的特定端口映射到宿主机上的端口，可以使得外部网络能够访问容器中的应用程序或服务。</p>
</li>
</ul>
<p>容器网络是 Docker 中实现容器间通信和与外部网络交互的重要机制。通过灵活配置和管理容器网络，可以构建具有高可用性、可伸缩性和弹性的容器化应用程序。</p>
<h3 id="5-2- 容器网络实践命令">5.2 容器网络实践命令</h3>
<h4 id="5-2-1- 创建自定义容器网络">5.2.1 创建自定义容器网络</h4>
<p>使用 <code>docker network create</code> 命令可以创建自定义的 Docker 网络。例如，创建一个名为 <code>my-network</code> 的自定义网络：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker network create my-network</span></span><br></pre></td></tr></table></figure>
<p>这将在 Docker 中创建一个新的网络，供容器使用。</p>
<h4 id="5-2-2- 运行容器并连接到网络">5.2.2 运行容器并连接到网络</h4>
<p>在创建容器时，可以使用 <code>--network</code> 参数将容器连接到指定的网络。例如，将一个容器连接到 <code>my-network</code> 网络：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --network my-network my-image</span></span><br></pre></td></tr></table></figure>
<p>这将在启动容器时将其连接到 <code>my-network</code> 网络，使得容器可以与该网络中的其他容器进行通信。</p>
<h4 id="5-2-3- 查看容器网络信息">5.2.3 查看容器网络信息</h4>
<p>使用 <code>docker network inspect</code> 命令可以查看特定网络的详细信息。例如，查看名为 <code>my-network</code> 的网络信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker network inspect my-network</span></span><br></pre></td></tr></table></figure>
<p>这将显示与 <code>my-network</code> 相关的网络配置和容器列表等信息。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my-network&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;000f5e28bfcafa18622593e04dba1bc70c1bc9480a055c0a0bb2b8ec13039138&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Created&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-06-01T22:51:27.366486209-04:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bridge&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;EnableIPv6&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;IPAM&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;default&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Config&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;Subnet&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.18.0.0/16&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;Gateway&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.18.0.1&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Internal&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Attachable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Ingress&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ConfigFrom&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Network&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ConfigOnly&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Containers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Labels&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<h4 id="5-2-4- 容器间通信">5.2.4 容器间通信</h4>
<p>容器可以通过使用容器名称或 IP 地址进行互相通信。例如，通过容器名称进行通信：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --name container1 --network my-network my-image</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --name container2 --network my-network my-image</span></span><br></pre></td></tr></table></figure>
<p>在上述示例中，<code>container1</code> 和 <code>container2</code> 这两个容器可以通过彼此的名称进行通信。例如，通过 <code>ping</code> 命令测试容器之间的连通性：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> container1 ping container2</span></span><br></pre></td></tr></table></figure>
<p>在上述示例中，<code>container1</code> 容器使用 <code>ping container2</code> 的命令来 ping <code>container2</code> 容器。由于容器名称在容器网络中被解析为相应容器的 IP 地址，因此可以直接使用容器名称来实现容器间的通信。</p>
<blockquote>
<p>通过使用容器名称进行通信，可以减少对容器 IP 地址的依赖，提高容器间通信的灵活性。注意，容器名称必须在同一网络中才能相互解析，因此需要将容器都连接到同一个网络中。</p>
</blockquote>
<h4 id="5-2-5- 端口映射">5.2.5 端口映射</h4>
<p>使用 <code>-p</code> 参数可以将容器内的端口映射到宿主机上，以使得外部网络可以访问容器中的服务。例如，将容器的 8080 端口映射到宿主机的 80 端口：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -p 80:8080 my-image</span></span><br></pre></td></tr></table></figure>
<p>这将使得宿主机上的 80 端口转发到容器内的 8080 端口，从而允许外部网络通过宿主机的 80 端口访问容器中的服务。</p>
<p>以上是一些与容器网络相关的实践命令和示例。通过灵活运用这些命令，可以有效管理和配置容器网络，实现容器间的通信和与外部网络的交互。</p>
<h2 id="6-Docker-Compose">6. Docker Compose</h2>
<p>Docker Compose 是一个用于定义和运行 <strong> 多个容器 </strong> 的工具。它使用一个 <code>docker-compose.yml</code> 文件来配置应用程序的服务、网络和卷。以下是一个示例：</p>
<ol>
<li>创建一个名为 <code>docker-compose.yml</code> 的文件，并在其中定义服务：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.9&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">aigc/plugins:v1.0.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">aigc_plugins</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my_network</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">python</span> <span class="string">/app/src/main.py</span> </span><br><span class="line">        <span class="string">--ip</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> </span><br><span class="line">        <span class="string">--port</span> <span class="number">8385</span> </span><br><span class="line">        <span class="string">--url</span> <span class="string">http://0.0.0.0:8383/v1/completions</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8385</span><span class="string">:8385</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/aigc/mount/plugins/data/store:/app/store</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/aigc/mount/plugins/data/cfg:/app/cfg</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">cpus:</span> <span class="string">&quot;0.5&quot;</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">1024M</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">my_network:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">plugins_net</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure>
<p>以上示例定义了一个名为 <code>plugins</code> 的服务，使用当前目录中的 <code>Dockerfile</code> 构建镜像。它将主机的 <code>8385</code> 端口映射到容器的 <code>8385</code> 端口，并将本地的 <code>./</code> 目录挂载到容器的 <code>/app</code> 目录，还设置了一个环境变量。</p>
<ol start="2">
<li>在包含 <code>docker-compose.yml</code> 文件的目录中打开终端，并运行服务：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker-compose up</span></span><br></pre></td></tr></table></figure>
<p>Docker Compose 将自动构建镜像并运行服务。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 内核 kfifo 环形队列</title>
    <url>/posts/240626192803.html</url>
    <content><![CDATA[<p>Linux 内核 kfifo 环形队列。</p>
<span id="more"></span>
<h1 id="前置知识">前置知识</h1>
<h2 id="2 的幂次方数">2 的幂次方数</h2>
<p>在二进制中，2 的幂次方很容易表示：一个数只有最高 bit 位是 1，其余全为 0。</p>
<p><strong>如何判断某个数是否是 2 的幂次方，如果不是，则更新该数为大于该数的最小的 2 的幂次方的数</strong>。</p>
<ul>
<li><strong>判断一个数是不是 2 的幂次方</strong>：判断 <code>n &amp; (n - 1)</code> 是否非零，非零则不是 2 的幂次方。如 3 不是（0b11 &amp; 0b10）、4 是（0b100 &amp; 0b011）。</li>
<li><strong>大于等于某数的最小的 2 的幂次方的数</strong>：<code>1UL &lt;&lt; fls(n - 1)</code>。</li>
</ul>
<p>fls(x) 即找到 x 的二进制表示中最高置 1 位的索引（索引从 1 开始），如 fls(0b101) = 3，则 <code>1UL &lt;&lt; fls(6 - 1) = 0b1000</code>。fls 函数如何实现？</p>
<p>fls 即 find the last bit set，查找最后一个置 1 的 bit 位。32 位数则从 bit31 开始找，64 位数则从 bit63 开始找。检查完 bit0 后停止。</p>
<p>可以假想一下，第一个置 1bit 的前面 bit 都是 0 的，而第一个置 1bit 后面的位是不关心的（不管是 0 还是 1），就可以 <strong> 转化为查找一堆 bit 中是否有置 1 的 bit 位，所以这里是可以使用二分法查找</strong>。</p>
<p>以 32 位数 fls 为例，首先看前 16bit 是否是全 0，是全 0 就把后 16bit 移到前面，此时第一个置 1 的 bit 不在前 16bit，所以 n 要减去 16。如果前 16bit 非 0，那就说明置 1 的 bit 包含在前面 16bit 里了，继续下一步，即在包含 1 的那 16bit 中使用二分查找。</p>
<p>32 位数，按照二分法查找算法步骤需要 log(32)=5 步。64 位数，log(64)=6 步。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// find last bit set, binary search</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fls</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!v) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(v &amp; <span class="number">0xFFFF0000</span>)) &#123; v &lt;&lt;= <span class="number">16</span>; n -= <span class="number">16</span>; &#125; <span class="comment">// 确定在不在 32bits 数中的高 16bits 位</span></span><br><span class="line">    <span class="keyword">if</span> (!(v &amp; <span class="number">0xFF000000</span>)) &#123; v &lt;&lt;=  <span class="number">8</span>; n -= <span class="number">8</span>;  &#125; <span class="comment">// 确定在不在过滤后的 16bits 数中的高 8bits 位</span></span><br><span class="line">    <span class="keyword">if</span> (!(v &amp; <span class="number">0xF0000000</span>)) &#123; v &lt;&lt;=  <span class="number">4</span>; n -= <span class="number">4</span>;  &#125; <span class="comment">// 确定在不在过滤后的 8bits 数中的高 4bits 位</span></span><br><span class="line">    <span class="keyword">if</span> (!(v &amp; <span class="number">0xC0000000</span>)) &#123; v &lt;&lt;=  <span class="number">2</span>; n -= <span class="number">2</span>;  &#125; <span class="comment">// 确定在不在过滤后的 4bits 数中的高 2bits 位</span></span><br><span class="line">    <span class="keyword">if</span> (!(v &amp; <span class="number">0x80000000</span>)) &#123; v &lt;&lt;=  <span class="number">1</span>; n -= <span class="number">1</span>;  &#125; <span class="comment">// 确定在不在过滤后的 2bits 数中的高 1bits 位</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &amp; (size - <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// roundup_pow_of_two(): 向上取大于等于某数的最小的 2 的幂次方的数</span></span><br><span class="line">        size = (<span class="number">1UL</span> &lt;&lt; fls(size - <span class="number">1</span>));  <span class="comment">// 减一是避免传进来的数本就是 2 的幂次方数，达到返回结果还是这个数（而不是乘一倍）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size = 0x%x\r\n&quot;</span>, size);  <span class="comment">// 0x400 = 1024</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对 2 的幂次方取模">对 2 的幂次方取模</h2>
<p><strong>假设 size 等于 2 的幂次方（前置条件），则表达式 <code>in &amp; (size - 1)</code> 的作用相当于 <code>in % size</code></strong>。</p>
<p>解释：</p>
<p>考虑 size 等于 2 的幂次方，那么 size 的二进制可以表示为 1 后面跟着 n 个 0 的形式。例如：size = 2^3 表示为 1000，size = 2^4 表示为 10000。则 size - 1 的二进制可以表示为 n 个 1。</p>
<p>对任何整数 in 进行 <code>in &amp; (size - 1)</code> 按位与操作会 <strong> 保留 in 的二进制表示中的最低的 n 位，而将其余的高位置为 0。也就是运算后的结果在 0~size-1 之间</strong>。</p>
<p>模运算 <code>in % size</code> 也是保留 in 对 size 的余数，<strong>这个余数正好是 in 二进制表示中的最低的 n 位 </strong>。因此表达式 <code>in &amp; (size - 1)</code> 与 <code>in % size</code> 等价，但是前者的位运算效率更高。</p>
<h2 id="原码反码补码">原码反码补码</h2>
<p>在计算机科学中，原码、反码和补码是三种用于表示整数的方法，<strong>特别是有符号整数 </strong>。它们主要<strong> 用于二进制系统中</strong>。无符号数不涉及补码的概念。</p>
<h3 id="原码">原码</h3>
<p>原码是最直接的一种表示方法，<strong>它使用一个符号位和一个数值位来表示整数。最高位（最左边一位）表示符号，剩余位表示数值</strong>。</p>
<ul>
<li>符号位：<strong>0 表示正数，1 表示负数</strong>。</li>
<li>数值位：直接表示数值的大小。</li>
</ul>
<p><strong>示例（char 类型数据）</strong>：</p>
<ul>
<li><code>+5</code> 的原码表示为：<code>0 0000101</code></li>
<li><code>-5</code> 的原码表示为：<code>1 0000101</code></li>
</ul>
<p>原码表示的一个问题是存在两个零（正零和负零），即 <code>0 0000000</code> 和 <code>1 0000000</code>。</p>
<h3 id="反码">反码</h3>
<p>反码通过对原码的数值位取反来表示负数。正数的反码与其原码相同，负数的反码则是将其原码的数值位逐位取反。</p>
<p><strong>示例（char 类型数据）</strong>：</p>
<ul>
<li><code>+5</code> 的反码表示为：<code>0 0000101</code></li>
<li><code>-5</code> 的反码表示为：<code>1 1111010</code></li>
</ul>
<p>反码表示也存在两个零：<code>0 0000000</code>（正零）和 <code>1 1111111</code>（负零）。</p>
<h3 id="补码">补码</h3>
<p>补码是现代计算机中 <strong> 最常用 </strong> 的有符号整数表示方法，<strong>负数在计算机中是以补码形式表示 </strong>。它通过将数值按二进制加法计算机的模数（通常是 2 的幂）进行减法来表示负数。具体来说，<strong> 负数的补码表示为原码数值位取反并加 1</strong>。</p>
<p><strong>示例（char 类型数据）</strong>：</p>
<ul>
<li><code>+5</code> 的补码表示为：<code>0 0000101</code></li>
<li><code>-5</code> 的补码表示为：<code>1 1111011</code>（将 <code>0 0000101</code> 取反为 <code>1 1111010</code>，然后加 1）</li>
</ul>
<p>补码表示的优点是只有一个零（<code>0 0000000</code>），且在硬件电路中，加法和减法运算可以使用相同的电路实现，这使得运算更加高效。</p>
<h3 id="总结和比较">总结和比较</h3>
<ol>
<li>
<p><strong>原码</strong>：</p>
<ul>
<li>符号位表示正负，数值位表示大小。</li>
<li>存在两个零（正零和负零）。</li>
</ul>
</li>
<li>
<p><strong>反码</strong>：</p>
<ul>
<li>正数与原码相同，负数取原码数值位的反。</li>
<li>存在两个零（正零和负零）。</li>
</ul>
</li>
<li>
<p><strong>补码</strong>：</p>
<ul>
<li>正数与原码相同，负数取（负数）原码数值位的反 <strong> 并加 1</strong>。</li>
<li>只有一个零，运算更高效。</li>
</ul>
</li>
</ol>
<p><strong>示例对比</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">值       原码      反码      补码</span><br><span class="line">+5     00000101  00000101  00000101</span><br><span class="line">-5     10000101  11111010  11111011</span><br><span class="line">+0     00000000  00000000  00000000</span><br><span class="line">-0     10000000  11111111  00000000 （注意：补码没有负零）</span><br></pre></td></tr></table></figure>
<p><mark><strong>正数的原码、反码与补码表示都一样。负数的补码表示是其对应的（负数）原码的数值位取反并加 1，或者是（正数）原码的符号位和数值位均取反并加 1</strong></mark>。</p>
<p>计算有符号数 <code>3 - 5 = -2</code> 的过程：</p>
<ul>
<li>正数 3 在计算机中的表示：补码，其值为 0000 0011</li>
<li>负数 -5 在计算机中的表示：补码，其值为 <strong> 正数的原码的符号位和数值位均取反 </strong> 并加 1，即 5 的原码 0000 0101，均取反 1111 1010，加一 1111 1011</li>
<li>3-5 等于 +3 的补码 + (-5 的补码)，即 0000 0011 + 1111 1011 = 1111 1110，减一得到反码 1111 1101，取反得到原码 1000 0010 = (-2)</li>
</ul>
<h2 id="无符号整数溢出回绕">无符号整数溢出回绕</h2>
<p>在 C 语言中，无符号整数的溢出行为是 <strong> 定义良好的 </strong>（最大值 +1 后必定是 0）。当一个无符号整数在加法、减法、乘法或其他操作中超过其表示范围时，它会发生<strong> 溢出回绕（也称为模数回绕）</strong>。具体来说，结果会被截断为适合该类型的最大值，并从零重新开始。这种行为基于二进制算术模数。</p>
<p><strong>何为溢出回绕行为</strong>：当无符号整数的运算结果超过其表示范围时，结果会模数化。例如，对于一个 8 位的 unsigned char 类型，它的范围是 0 到 255。如果结果大于 255，它会回绕到从 0 开始的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a = <span class="number">0xfffffffa</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b = a + <span class="number">10</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> c = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %u, 0x%08x\n&quot;</span>, a, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %u, 0x%08x\n&quot;</span>, b, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b - a = %u, 0x%08x\n&quot;</span>, b - a, b - a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c - a = %u, 0x%08x\n&quot;</span>, c - a, c - a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a = 4294967290, 0xfffffffa</span></span><br><span class="line"><span class="comment">b = 4, 0x00000004</span></span><br><span class="line"><span class="comment">    -&gt;  a + 10 = 0x1 00 00 00 04 溢出</span></span><br><span class="line"><span class="comment">    因为 uint32 共计 32 位，溢出时的最高位无法获取，只能获取低 32 位，即 0x00000004</span></span><br><span class="line"><span class="comment">b - a = 10, 0x0000000a</span></span><br><span class="line"><span class="comment">    -&gt; b - a = 4 + (-4294967290 的补码) = 0x04 + (~(0xfffffffa)+1)</span></span><br><span class="line"><span class="comment">             = 0x04 + 0x00000006 = 0x0a = 10</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    -&gt; b - a = 0x04 - 0xfffffffa = -4294967286 + 2^32 = 0x0000000a = 10</span></span><br><span class="line"><span class="comment">    因为 4 - 4294967290 将变成一个负值，这在无符号整数表示中是不允许的。</span></span><br><span class="line"><span class="comment">    为了处理这种情况，结果会被加上一个模数（即 2^32），以得到正确的无符号结果。</span></span><br><span class="line"><span class="comment">c - a = 10, 0x0000000a</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h1 id="Linux 内核 kfifo 环形队列">Linux 内核 kfifo 环形队列</h1>
<p>Linux 内核中有一个先进先出的数据结构，采用环形队列的数据结构来实现，提供一个无边界的字节流服务。最重要的是，这个队列采用的是无锁的方式来实现。<strong>即当它用于只有一个入队线程和一个出队线程的场景时，两个线程可以并发操作，而不需要任何加锁行为，就可以保证 kfifo 的线程安全</strong>。这个队列名为 kfifo。</p>
<h2 id="数据结构">数据结构</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kfifo</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *buffer;	<span class="comment">/* the buffer holding the data */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size;	<span class="comment">/* the size of the allocated buffer */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> in;	<span class="comment">/* data is added at offset (in % size) */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> out;	<span class="comment">/* data is extracted from off. (out % size) */</span></span><br><span class="line">	<span class="type">spinlock_t</span> *lock;	<span class="comment">/* protects concurrent modifications */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>buffer: 存放数据的缓存表</li>
<li>size: 缓存空间的大小，<strong>要求为 2 的幂次方</strong></li>
<li>in: 指向 buffer 队列的队头，代码中计数持续增长（未取模）</li>
<li>out: 指向 buffer 队列的队尾，代码中计数持续增长（未取模）</li>
<li>lock: 多生产者 / 多消费者场景中用于同步互斥的锁</li>
</ul>
<h2 id="注意事项">注意事项</h2>
<p>对于 Linux 内核 kfifo 环形队列：</p>
<ul>
<li class="checkbox-item"><input type="checkbox" id="checkbox0" checked="true"><label for="checkbox0">单生产者、单消费者无需使用锁进行同步</label></li>
<li class="checkbox-item"><input type="checkbox" id="checkbox1" checked="true"><label for="checkbox1">未使用加锁的 kfifo_reset()函数</label></li>
<li class="checkbox-item"><input type="checkbox" id="checkbox2" checked="true"><label for="checkbox2">只在消费者端使用了 kfifo_reset_out()函数</label></li>
</ul>
<p>以上三种条件都满足的情况下，可以使用 kfifo 无锁队列。相反，如果存在多个生产者或多个消费者，则需要通过锁来进行同步：</p>
<ul>
<li class="checkbox-item"><input type="checkbox" id="checkbox3" checked="true"><label for="checkbox3">多个生产者、单个消费者模式，生产者端加锁同步</label></li>
<li class="checkbox-item"><input type="checkbox" id="checkbox4" checked="true"><label for="checkbox4">单个生产者、多个消费者模式，消费者端加锁同步</label></li>
</ul>
<h2 id="buffer 大小为 2 的幂次方">buffer 大小为 2 的幂次方</h2>
<p>为什么 buffer 大小要求为 2 的幂次方？为了使用位运算，达到快、快、不择手段的快。</p>
<p>如果用户给定的 size 大小不是 2 的幂次方会怎么样？程序会自动向上取到大于它的 2 的幂次方数作为 size。</p>
<h2 id="kfifo-alloc 初始化">kfifo_alloc 初始化</h2>
<p>kfifo 的初始化是指为 kfifo 分配空间、初始化 kfifo 中的各项参数等操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kfifo_alloc - allocates a new FIFO and its internal buffer</span></span><br><span class="line"><span class="comment"> * @size: the size of the internal buffer to be allocated.</span></span><br><span class="line"><span class="comment"> * @gfp_mask: get_free_pages mask, passed to kmalloc()</span></span><br><span class="line"><span class="comment"> * @lock: the lock to be used to protect the fifo buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The size will be rounded-up to a power of 2.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> kfifo *<span class="title function_">kfifo_alloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">unsigned</span> <span class="type">int</span> __nocast gfp_mask, <span class="type">spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *buffer;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kfifo</span> *<span class="title">ret</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * round up to the next power of 2, since our &#x27;let the indices</span></span><br><span class="line"><span class="comment">	 * wrap&#x27; tachnique works only in this case.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (size &amp; (size - <span class="number">1</span>)) &#123;  <span class="comment">// 如果不是 2 的幂次方，则向上取到 2 的幂次方</span></span><br><span class="line">		BUG_ON(size &gt; <span class="number">0x80000000</span>);</span><br><span class="line">		size = roundup_pow_of_two(size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	buffer = kmalloc(size, gfp_mask);</span><br><span class="line">	<span class="keyword">if</span> (!buffer)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	ret = kfifo_init(buffer, size, gfp_mask, lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(ret))</span><br><span class="line">		kfree(buffer);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kfifo_init - allocates a new FIFO using a preallocated buffer</span></span><br><span class="line"><span class="comment"> * @buffer: the preallocated buffer to be used.</span></span><br><span class="line"><span class="comment"> * @size: the size of the internal buffer, this have to be a power of 2.</span></span><br><span class="line"><span class="comment"> * @gfp_mask: get_free_pages mask, passed to kmalloc()</span></span><br><span class="line"><span class="comment"> * @lock: the lock to be used to protect the fifo buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Do NOT pass the kfifo to kfifo_free() after use ! Simply free the</span></span><br><span class="line"><span class="comment"> * struct kfifo with kfree().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> kfifo *<span class="title function_">kfifo_init</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buffer, <span class="type">unsigned</span> <span class="type">int</span> size,</span></span><br><span class="line"><span class="params">			 <span class="type">unsigned</span> <span class="type">int</span> __nocast gfp_mask, <span class="type">spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kfifo</span> *<span class="title">fifo</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* size must be a power of 2 */</span></span><br><span class="line">	BUG_ON(size &amp; (size - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	fifo = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> kfifo), gfp_mask);</span><br><span class="line">	<span class="keyword">if</span> (!fifo)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	fifo-&gt;buffer = buffer;</span><br><span class="line">	fifo-&gt;size = size;</span><br><span class="line">	fifo-&gt;in = fifo-&gt;out = <span class="number">0</span>;</span><br><span class="line">	fifo-&gt;lock = lock;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> fifo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="kfifo-put 入队（无锁）">__kfifo_put 入队（无锁）</h2>
<p><code>__kfifo_put()</code>是 kfifo 的入队函数（无锁版本），源码实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __kfifo_put - puts some data into the FIFO, no locking version</span></span><br><span class="line"><span class="comment"> * @fifo: the fifo to be used.</span></span><br><span class="line"><span class="comment"> * @buffer: the data to be added.</span></span><br><span class="line"><span class="comment"> * @len: the length of the data to be added.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function copies at most &#x27;len&#x27; bytes from the &#x27;buffer&#x27; into</span></span><br><span class="line"><span class="comment"> * the FIFO depending on the free space, and returns the number of</span></span><br><span class="line"><span class="comment"> * bytes copied.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that with only one concurrent reader and one concurrent</span></span><br><span class="line"><span class="comment"> * writer, you don&#x27;t need extra locking to use these functions.</span></span><br><span class="line"><span class="comment"> * 注意，对于仅一个并发的读者和写者，使用这些功能不需要额外的锁 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> __kfifo_put(<span class="keyword">struct</span> kfifo *fifo,</span><br><span class="line">			 <span class="type">unsigned</span> <span class="type">char</span> *buffer, <span class="type">unsigned</span> <span class="type">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> l;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* (in-out) 表示已使用的空间，size-(in-out)表示剩余的空间。通过 min 来防止写越界 */</span></span><br><span class="line">	len = min(len, fifo-&gt;size - fifo-&gt;in + fifo-&gt;out);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 下面的设计考虑了：从队列尾部填充一部分、从队列首部填充剩余的部分的情况 */</span></span><br><span class="line">	<span class="comment">/* first put the data starting from fifo-&gt;in to buffer end */</span></span><br><span class="line">	<span class="comment">/* fifo-&gt;buffer = |0........in....size-1| 首先将前半部分数据缓存放在 in~size-1 所在的区间 */</span></span><br><span class="line">	l = min(len, fifo-&gt;size - (fifo-&gt;in &amp; (fifo-&gt;size - <span class="number">1</span>)));</span><br><span class="line">	<span class="built_in">memcpy</span>(fifo-&gt;buffer + (fifo-&gt;in &amp; (fifo-&gt;size - <span class="number">1</span>)), buffer, l);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* then put the rest (if any) at the beginning of the buffer */</span></span><br><span class="line">	<span class="comment">/* 若 l&lt;len，则表明上面 in~size-1 区间不够放下 len 长度，此时要将剩余后半部分数据从环的开始端继续放 */</span></span><br><span class="line">	<span class="built_in">memcpy</span>(fifo-&gt;buffer, buffer + l, len - l);</span><br><span class="line"></span><br><span class="line">	fifo-&gt;in += len; <span class="comment">/* 从这里可以说明，指针 in 一直在增加，其值未曾对 size 取模 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据前面的《无符号整数溢出回绕》小节可知，无符号数 in 相当于 b，无符号数 out 相当于 a，当 out 很大、in 溢出回绕时，in-out(b-a) 的距离仍为正确值。无论何时，即使发生整数回绕，kfifo 中的指针都有如下关系：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>k</mi><mi>f</mi><mi>i</mi><mi>f</mi><mi>o</mi><mi mathvariant="normal">.</mi><mi>i</mi><mi>n</mi><mo>−</mo><mi>k</mi><mi>f</mi><mi>i</mi><mi>f</mi><mi>o</mi><mi mathvariant="normal">.</mi><mi>o</mi><mi>u</mi><mi>t</mi><mo>&lt;</mo><mo>=</mo><mi>k</mi><mi>f</mi><mi>i</mi><mi>f</mi><mi>o</mi><mi mathvariant="normal">.</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">kfifo.in - kfifo.out &lt;= kfifo.size
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">o</span><span class="mord">.</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">o</span><span class="mord">.</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">o</span><span class="mord">.</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord mathnormal">e</span></span></span></span></span></p>
<h2 id="kfifo-get 出队（无锁）">__kfifo_get 出队（无锁）</h2>
<p><code>__kfifo_get()</code>是 kfifo 的出队函数（无锁版本），源码实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __kfifo_get - gets some data from the FIFO, no locking version</span></span><br><span class="line"><span class="comment"> * @fifo: the fifo to be used.</span></span><br><span class="line"><span class="comment"> * @buffer: where the data must be copied.</span></span><br><span class="line"><span class="comment"> * @len: the size of the destination buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function copies at most &#x27;len&#x27; bytes from the FIFO into the</span></span><br><span class="line"><span class="comment"> * &#x27;buffer&#x27; and returns the number of copied bytes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that with only one concurrent reader and one concurrent</span></span><br><span class="line"><span class="comment"> * writer, you don&#x27;t need extra locking to use these functions.</span></span><br><span class="line"><span class="comment"> * 注意，对于仅一个并发的读者和写者，使用这些功能不需要额外的锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> __kfifo_get(<span class="keyword">struct</span> kfifo *fifo,</span><br><span class="line">			 <span class="type">unsigned</span> <span class="type">char</span> *buffer, <span class="type">unsigned</span> <span class="type">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> l;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 这里 in-out 可能会发生整数溢出回绕，如 in-out=0x04-0xfffffffa，</span></span><br><span class="line"><span class="comment">	 * 但不影响正确性，其结果为正确值 10，正好对应 abcdef0123 十处 */</span></span><br><span class="line">	len = min(len, fifo-&gt;in - fifo-&gt;out);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 后面的原理跟__kfifo_put 的原理一致 */</span></span><br><span class="line">	<span class="comment">/* first get the data from fifo-&gt;out until the end of the buffer */</span></span><br><span class="line">	l = min(len, fifo-&gt;size - (fifo-&gt;out &amp; (fifo-&gt;size - <span class="number">1</span>)));</span><br><span class="line">	<span class="built_in">memcpy</span>(buffer, fifo-&gt;buffer + (fifo-&gt;out &amp; (fifo-&gt;size - <span class="number">1</span>)), l);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* then get the rest (if any) from the beginning of the buffer */</span></span><br><span class="line">	<span class="built_in">memcpy</span>(buffer + l, fifo-&gt;buffer, len - l);</span><br><span class="line"></span><br><span class="line">	fifo-&gt;out += len; <span class="comment">/* 从这里可以说明，指针 out 一直在增加，其值未曾对 size 取模 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="kfifio-reset 重置队列">__kfifio_reset 重置队列</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __kfifo_reset - removes the entire FIFO contents, no locking version</span></span><br><span class="line"><span class="comment"> * @fifo: the fifo to be emptied.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __kfifo_reset(<span class="keyword">struct</span> kfifo *fifo)</span><br><span class="line">&#123;</span><br><span class="line">	fifo-&gt;in = fifo-&gt;out = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="入队出队加锁版本">入队出队加锁版本</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kfifo_reset - removes the entire FIFO contents</span></span><br><span class="line"><span class="comment"> * @fifo: the fifo to be emptied.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">kfifo_reset</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(fifo-&gt;lock, flags);</span><br><span class="line">	__kfifo_reset(fifo);</span><br><span class="line">	spin_unlock_irqrestore(fifo-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kfifo_put - puts some data into the FIFO</span></span><br><span class="line"><span class="comment"> * @fifo: the fifo to be used.</span></span><br><span class="line"><span class="comment"> * @buffer: the data to be added.</span></span><br><span class="line"><span class="comment"> * @len: the length of the data to be added.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function copies at most &#x27;len&#x27; bytes from the &#x27;buffer&#x27; into</span></span><br><span class="line"><span class="comment"> * the FIFO depending on the free space, and returns the number of</span></span><br><span class="line"><span class="comment"> * bytes copied.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">kfifo_put</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo,</span></span><br><span class="line"><span class="params">				     <span class="type">unsigned</span> <span class="type">char</span> *buffer, <span class="type">unsigned</span> <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(fifo-&gt;lock, flags);</span><br><span class="line">	ret = __kfifo_put(fifo, buffer, len);</span><br><span class="line">	spin_unlock_irqrestore(fifo-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kfifo_get - gets some data from the FIFO</span></span><br><span class="line"><span class="comment"> * @fifo: the fifo to be used.</span></span><br><span class="line"><span class="comment"> * @buffer: where the data must be copied.</span></span><br><span class="line"><span class="comment"> * @len: the size of the destination buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function copies at most &#x27;len&#x27; bytes from the FIFO into the</span></span><br><span class="line"><span class="comment"> * &#x27;buffer&#x27; and returns the number of copied bytes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">kfifo_get</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo,</span></span><br><span class="line"><span class="params">				     <span class="type">unsigned</span> <span class="type">char</span> *buffer, <span class="type">unsigned</span> <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(fifo-&gt;lock, flags);</span><br><span class="line">	ret = __kfifo_get(fifo, buffer, len);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * optimization: if the FIFO is empty, set the indices to 0</span></span><br><span class="line"><span class="comment">	 * so we don&#x27;t wrap the next time</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (fifo-&gt;in == fifo-&gt;out)</span><br><span class="line">		fifo-&gt;in = fifo-&gt;out = <span class="number">0</span>;</span><br><span class="line">	spin_unlock_irqrestore(fifo-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://blog.csdn.net/suz_cheney/article/details/112456368">https://blog.csdn.net/suz_cheney/article/details/112456368</a></li>
<li><a href="https://juejin.cn/post/6983865054147903518">https://juejin.cn/post/6983865054147903518</a></li>
<li><a href="https://elixir.bootlin.com/linux/v2.6.12/source/kernel/kfifo.c">https://elixir.bootlin.com/linux/v2.6.12/source/kernel/kfifo.c</a></li>
<li><a href="https://blog.csdn.net/u012630961/article/details/80974857">https://blog.csdn.net/u012630961/article/details/80974857</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程编程之 pthread 库</title>
    <url>/posts/230911151334.html</url>
    <content><![CDATA[<h1 id="进程与线程">进程与线程</h1>
<p><strong>进程</strong>：是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单元，是应用程序运行的载体。进程一般由程序、数据集合和进程控制块三部分组成：</p>
<ul>
<li>
<p>程序：描述进程的功能，控制进程的指令集（写论文的目的和手段）</p>
</li>
<li>
<p>数据集：程序在执行时所需要的数据和工作区（写论文的材料）</p>
</li>
<li>
<p>进程控制块：跟踪每个进程的状态，操作系统会为进程保留进程列表（写作者）</p>
</li>
</ul>
<p><strong>线程 </strong>：线程是程序执行中的一个单一的<strong> 顺序控制流程</strong>，是程序执行流的最小单元，是处理器调度和分派的基本单位。</p>
<ul>
<li>
<p>一个进程至少有一个线程，一个进程也可以有多个线程。（一个父亲可以有一个、多个孩子）</p>
</li>
<li>
<p>各个线程之间共享程序的内存空间，即所在进程的内存空间。（多个孩子共享一个家庭空间）</p>
</li>
<li>
<p>一个标准的线程由线程 ID、当前指令指针 PC、寄存器和堆栈组成。（每个孩子有其自身的成长轨迹）</p>
</li>
</ul>
<span id="more"></span>
<p><strong>进程与线程的区别</strong>：</p>
<ul>
<li>
<p>线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位。</p>
</li>
<li>
<p>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线。</p>
</li>
<li>
<p>进程之间相互独立，但 <strong> 同一进程下的各个线程之间共享程序的内存空间 </strong>（代码段、数据集、堆等）以及一些<strong> 进程级的资源</strong>（如打开文件和信号等），某进程内的线程在其他进程中不可见。</p>
</li>
<li>
<p><strong>线程上下文切换比进程上下文切换要快得多</strong>。</p>
</li>
</ul>
<h1 id="上下文切换">上下文切换</h1>
<h2 id="时间片">时间片</h2>
<p>多任务系统往往需要同时执行多道作业。作业数往往大于机器的 CPU 数，然而一颗 CPU 同时只能执行一项任务，如何让用户感觉这些任务正在同时进行呢? 操作系统的设计者巧妙地利用了 <strong> 时间片轮转的方式</strong>。</p>
<p><strong>时间片是 CPU 分配给各个任务（线程）的时间</strong>。</p>
<blockquote>
<p>思考：单核 CPU 为何也支持多线程呢？</p>
<p>虽然单核 CPU 只有一个物理处理单元，但它可以 <strong> 通过时间分片的方式支持多线程</strong>。在单核 CPU 中，操作系统通过时间片轮转算法将 CPU 时间划分为多个时间片段，每个时间片段分配给一个线程执行。当一个线程的时间片用完后，操作系统会暂停该线程的执行，并切换到下一个线程继续执行。这种切换是非常快速的，以至于我们感觉多个线程在同时执行。</p>
<p>需要注意的是，在单核 CPU 上并发执行的多线程是通过时间片轮转调度实现的，在任意给定的时间点上 <strong> 只能有一个 </strong> 线程在执行。而在多核 CPU 上，可以实现真正的并行执行，每个核心可以同时执行一个线程，从而提高并发性能。</p>
</blockquote>
<h2 id="上下文切换 -v2">上下文切换</h2>
<p><strong>线程上下文 </strong>：是指某一时间点 CPU <strong> 寄存器和程序计数器的内容</strong>，CPU 通过时间片分配算法来循环执行任务（线程），因为时间片非常短，所以 CPU 通过不停地切换线程执行。</p>
<p>换言之，单 CPU 这么频繁，多核 CPU 一定程度上可以减少上下文切换。</p>
<p><strong>上下文切换 </strong>：CPU 切换前把当前任务的状态保存下来（以便下次切换回这个任务时可以再次加载这个任务的状态），然后加载下一任务的状态并执行。<strong> 任务的状态保存及再加载</strong>，这段过程就叫做上下文切换。</p>
<h2 id="多线程编程">多线程编程</h2>
<ul>
<li>
<p>多进程模式：启动多个进程，每个进程虽然只有一个线程，但是多个进程可以一块执行多个任务。</p>
</li>
<li>
<p><strong>多线程模式</strong>：启动一个进程，在一个进程内启动多个线程，多个线程一起执行多个任务。</p>
</li>
<li>
<p>多进程 + 多线程模式：启动多个进程，每个进程再启动多个线程，这样同时执行的任务就更多了。</p>
</li>
</ul>
<p>其实创建线程之后，线程并不是始终保持一个状态的，其状态大概如下：</p>
<ol>
<li>New 创建</li>
<li>Runnable 就绪，等待调度</li>
<li>Running 运行</li>
<li>Blocked 阻塞，阻塞可能在 Wait / Locked / Sleeping 阶段</li>
<li>Dead 消亡</li>
</ol>
<p>线程有着不同的状态，也有不同的类型。大致可分为：</p>
<ul>
<li>
<p>主线程：主线程是程序启动时自动创建的线程，它负责执行程序的主要逻辑。主线程通常负责处理用户交互、调度其他线程的创建和管理等任务。</p>
</li>
<li>
<p>子线程：子线程是由主线程创建的额外线程，用于执行并发任务。子线程可以并行地执行任务，从而提高程序的效率和响应性。</p>
</li>
<li>
<p>守护线程（后台线程）：守护线程是一种特殊类型的线程，它在后台运行，<strong>不会阻止程序的退出</strong>。当所有的非守护线程都退出时，守护线程也会自动结束。守护线程通常用于执行一些后台任务，如日志记录、定时任务等。</p>
</li>
<li>
<p>前台线程：前台线程是与守护线程相对的概念，它是指 <strong> 会阻止程序退出的线程</strong>。当所有的前台线程都退出时，程序才会结束。</p>
</li>
</ul>
<h1 id="pthread 多线程">pthread 多线程</h1>
<p>POSIX 线程（Pthreads）是一套标准的线程 API，用于多线程编程。该库定义了一组 C 语言函数，允许程序员创建和管理多个线程，并提供同步和互斥机制，以确保线程之间的正确协调。</p>
<p>Pthreads 库是 POSIX 标准的一部分，其全称是“Portable Operating System Interface”，旨在为 Unix-like 操作系统（如 Linux、FreeBSD、Mac OS X 等）提供一致的接口。由于该标准的广泛接受和实现，因此 Pthreads 库现在在许多不同的平台上都可用。</p>
<p>Pthreads 库的一个优点是它允许程序员创建轻量级线程（LWT），这些线程比进程更轻量级，因此在创建和销毁它们时所需的开销较小。此外，由于它是标准的 POSIX 接口，因此 Pthreads 库可在不同的操作系统上重用，从而提高了代码的可移植性。</p>
<p>Pthread 库需要头文件：<code>pthread.h</code></p>
<p>gcc 编译链接参数：<code>lpthread</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc ./demo.c -o demo -lpthread</span><br></pre></td></tr></table></figure>
<h2 id="创建线程相关">创建线程相关</h2>
<h3 id="pthread-create">pthread_create</h3>
<p><code>pthread_create</code>是一个用于创建线程的函数，它的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pthread_t 类型的原型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="type">pthread_t</span>;</span><br></pre></td></tr></table></figure>
<p>该函数接收四个参数，分别是：</p>
<ol>
<li>
<p><code>thread</code>：一个指向线程标识符的指针，由函数创建并返回。</p>
</li>
<li>
<p><code>attr</code>：一个指向线程属性的指针，用于设置线程的属性。如果不需要设置属性，传入 <code>NULL</code> 即可。</p>
</li>
<li>
<p><code>start_routine</code>：线程执行的函数指针，该函数接受一个 <code>void *</code> 类型的参数，并返回一个 <code>void *</code> 类型的值。</p>
</li>
<li>
<p><code>arg</code>：传递给线程执行函数的参数，如果有多个参数，可以传递一个指向参数结构体的指针。</p>
</li>
</ol>
<p>当调用 <code>pthread_create</code> 函数时，它会创建一个新的线程，并将其标识符存储在 <code>thread</code> 指针中。新线程的执行将从 <code>start_routine</code> 函数开始，<code>arg</code>参数将作为 <code>start_routine</code> 的参数传递给它。</p>
<p>创建线程时，可以选择使用默认线程属性，也可以使用 <code>pthread_attr_t</code> 结构体来设置一些属性，例如线程的调度策略、栈大小、优先级等等。如果不需要设置属性，可以将 <code>attr</code> 参数设置为<code>NULL</code>。</p>
<p><code>pthread_create</code>函数成功时返回 0，否则返回一个错误码。如果返回非零错误码，可以使用 <code>perror</code> 函数或 <code>strerror</code> 函数打印出错误信息。</p>
<h3 id="pthread-self">pthread_self</h3>
<p><code>pthread_self</code>函数返回调用线程的线程 ID，即等于线程创建中返回给 <code>*thread</code> 的值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="pthread-equal">pthread_equal</h3>
<p><code>pthread_equal</code>函数通过线程 ID 比较线程是否相等，如果两个线程相等，返回非 0 值，如果不相等，返回 0：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="pthread-detach">pthread_detach</h3>
<p><code>pthread_detach</code> 函数用于将指定的线程分离出去，所谓分离出去就是指 <strong> 主线程不再需要 </strong> 通过 <code>pthread_join</code> 方式，等待该线程的结束并回收其线程控制块（TCB）资源，<strong>被分离的线程结束后由操作系统负责其资源的回收</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure>
<p>其中，<code>thread</code> 参数是要分离的线程的标识符，返回值为 0 表示成功，非 0 值表示出错。</p>
<blockquote>
<p>需要注意的是，如果一个线程被分离了，就不能再对它调用 <code>pthread_join</code> 函数，否则会出错。因此，在调用 <code>pthread_detach</code> 函数之前，必须确保不会再调用 <code>pthread_join</code> 函数。</p>
</blockquote>
<p>一般来说，主线程是要负责创建出来的子线程的资源回收工作的：</p>
<ul>
<li>
<p>如果主线程先于子线程退出，并且子线程没有设置为分离状态，那么子线程结束后其资源是无法得到回收的，会造成资源浪费和系统臃肿。</p>
</li>
<li>
<p>如果主线程先于子线程退出，但是子线程是分离状态，那么子线程退出的时候操作系统会自动回收其资源。</p>
</li>
</ul>
<p>分离线程并不是分离了之后，就跟主线程没有一点关系了。<strong>主线程退出了，分离线程还是一样退出</strong>，只是分离线程的资源是由系统回收的。</p>
<h2 id="终止线程相关">终止线程相关</h2>
<p>终止线程的三种方式：</p>
<ol>
<li>
<p>线程从启动例程（线程创建接口中的函数指针<code>start_routine</code>）返回，返回值就是线程的退出码；</p>
</li>
<li>
<p>线程可以被同一进程中的其他线程取消（通过<code>pthread_cancel()</code>）；</p>
</li>
<li>
<p>线程自身调用 <code>pthread_ exit()</code> 函数终止。</p>
</li>
</ol>
<h3 id="pthread-cancel">pthread_cancel</h3>
<p><code>pthread_cancel</code> 函数是一个用于取消 POSIX 线程的函数。该函数向目标线程发送一个取消请求，如果该线程允许取消，则会在处理该请求时终止该线程的执行。</p>
<blockquote>
<p>线程可以设置为允许取消（默认情况下）或者禁止取消。如果线程允许取消，它将在收到取消请求后 <strong> 尽快取消</strong>，并执行一些清理工作；如果线程禁止取消，它将继续运行，直到完成其任务或者显式地调用 <code>pthread_exit</code> 函数。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure>
<p><code>pthread_cancel</code> 函数有以下两种用法：</p>
<ol>
<li>
<p><code>int pthread_cancel(pthread_t thread);</code> 此用法向线程 ID 为 <code>thread</code> 的线程发送取消请求。如果请求成功发送，则返回 0。如果线程 ID 无效或请求无法发送，则返回一个非零错误码。</p>
</li>
<li>
<p><code>void pthread_testcancel(void);</code> 此用法可以在线程执行期间调用，用于测试是否有取消请求已经发送给该线程。如果是，则在线程执行期间发生取消动作，该线程的执行将立即停止。</p>
</li>
</ol>
<p>需要注意的是，<code>pthread_cancel</code> 函数并不保证能够成功地取消目标线程的执行。当目标线程正在执行某些不可取消的操作（例如某些系统调用）时，取消请求可能会被暂时挂起，直到目标线程离开这些操作为止。另外，使用 <code>pthread_cancel</code> 函数需要注意线程同步问题，避免出现死锁等问题。</p>
<p>总的来说，<code>pthread_cancel</code> 函数可以用于线程的优雅终止，但是需要谨慎使用，避免出现意外的问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread is running...\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 在循环中调用 pthread_testcancel 函数检查是否有取消请求</span></span><br><span class="line">        pthread_testcancel();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread_id;</span><br><span class="line">    <span class="comment">// 创建一个线程并启动它</span></span><br><span class="line">    pthread_create(&amp;thread_id, <span class="literal">NULL</span>, &amp;thread_func, <span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 在主线程中调用 pthread_cancel 函数向子线程发送取消请求</span></span><br><span class="line">    pthread_cancel(thread_id);</span><br><span class="line">    <span class="comment">// 等待子线程结束</span></span><br><span class="line">    pthread_join(thread_id, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread has been canceled.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">root@fw:~/ccodes# ./demo</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread has been canceled.</span><br><span class="line">root@fw:~/ccodes#</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，首先创建了一个子线程并启动它，在子线程的循环中不断输出信息，同时在循环中调用 <code>pthread_testcancel</code> 函数检查是否有取消请求。在主线程中等待 5 秒钟后，调用 <code>pthread_cancel</code> 函数向子线程发送取消请求，然后等待子线程结束并输出一条信息表示子线程已经被成功取消。</p>
<p><strong>调用与不调用 <code>pthread_testcancel()</code> 的区别</strong>：</p>
<ol>
<li>调用 <code>pthread_testcancel</code> 函数可以让线程在循环或其他 <em> 可取消的操作中 </em> 主动检查是否有取消请求，并在检测到取消请求时 <em> 及时终止 </em> 线程的执行。这样可以增加线程的可靠性，<strong>确保线程在可以取消的时候及时响应取消请求</strong>。</li>
<li>如果不调用 <code>pthread_testcancel</code> 函数，线程可能会在某些不可取消的操作中被阻塞（例如在 <code>sleep</code> 等待时），无法及时响应取消请求，导致取消请求被暂时挂起。</li>
</ol>
<p>因此，为了保证线程及时响应取消请求，<strong>通常建议 </strong> 在线程的循环或其他可取消的操作中调用 <code>pthread_testcancel</code> 函数，以便让线程在合适的时机进行取消。但是需要注意的是，在使用 <code>pthread_testcancel</code> 函数时，必须确保线程的同步操作是线程安全的，否则可能会导致程序出现不可预期的错误。</p>
<p>当然，在某些情况下，如果线程不会进入可取消状态或在处理临界区时不能被取消，那么调用 <code>pthread_testcancel</code> 函数可能会导致线程被错误地取消。在这种情况下，可以通过设置线程的取消状态为 <code>PTHREAD_CANCEL_DISABLE</code> 来禁用取消操作，以避免意外的取消。</p>
<p>总之，调用 <code>pthread_testcancel</code> 函数可以让线程更加及时地、可靠地响应取消请求，从而增加程序的安全性和稳定性，但需要注意线程同步的问题，以避免出现错误。</p>
<h3 id="pthread-exit">pthread_exit</h3>
<p><code>pthread_exit()</code>是一个线程终止函数，它允许一个线程在它的 <strong> 任意位置退出</strong>。该函数接受一个参数，表示线程的返回值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure>
<p>调用 <code>pthread_exit()</code> 函数会立即终止当前线程的执行，并将传递的参数作为线程的返回值。如果该线程被其他线程等待，那么该返回值可以被其他线程获取。</p>
<blockquote>
<p>注意：指针 <code>retval</code> 指向的内容不能为函数中局部变量，因为一旦线程函数终止，它们将不再存在。</p>
</blockquote>
<p><code>pthread_exit()</code>函数通常在以下情况下使用：</p>
<ol>
<li>
<p>在线程执行完任务后，主动结束自己的执行。</p>
</li>
<li>
<p>当线程执行出现错误时，使用该函数退出线程。</p>
</li>
<li>
<p>在主线程中调用 <code>pthread_exit()</code> 函数来结束整个程序的执行。</p>
</li>
</ol>
<blockquote>
<p>注意：如果在主线程中调用了<code>pthread_exit(NULL)</code>，则主线程退出，而不是退出进程。因此，如果子线程存在，会继续执行。</p>
<p>需要注意的是，当一个线程调用 <code>pthread_exit()</code> 函数后，该线程会 <strong> 立即终止，不会再执行任何其他操作 </strong>。因此，如果线程需要进行一些清理工作，比如释放内存、关闭文件等，就需要在调用<code>pthread_exit()</code> 函数之前完成这些操作。</p>
</blockquote>
<h2 id="等待线程结束">等待线程结束</h2>
<h3 id="pthread-join">pthread_join</h3>
<p><code>pthread_join</code>函数用于 <strong> 等待一个指定线程结束，并回收其占用的资源</strong>。它的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>thread</code>：要等待的线程标识符，即线程创建时传递给 <code>pthread_t *</code> 类型的值。</li>
<li><code>retval</code>：用于存储线程的返回值的指针，该参数是一个指向指针的指针。这是因为 <strong> 线程的返回值类型是不确定的，可能是一个整型、浮点型或者指针等类型</strong>。</li>
</ol>
<p>函数返回时，线程的返回值的指针将会被存储在二级指针 <code>retval</code> 所指向的内存空间中。</p>
<blockquote>
<p>需要注意的是，如果不需要获取线程的返回值，可以将其设置为 <code>NULL</code>。另外，如果线程没有返回值，或者<strong> 在线程函数中没有显式地调用 <code>pthread_exit</code> 函数退出线程 </strong>，那么<code>retval</code> 参数将被忽略。</p>
</blockquote>
<p><strong>该函数会阻塞当前线程，直到指定的线程 <code>thread</code> 结束执行 </strong>。具体来说，当我们调用<code>pthread_join</code> 函数时：</p>
<ul>
<li>如果指定的线程 <code>thread</code> 还在运行中，当前线程就会被阻塞，等待该线程结束；</li>
<li>如果线程 <code>thread</code> 已经结束了，那么 <code>pthread_join</code> 函数会立即返回，并将线程的返回值存储在 <code>retval</code> 中。</li>
</ul>
<p>此外，<code>pthread_join</code>函数会自动回收线程占用的资源，避免了资源泄露的问题。</p>
<p>以下是一个简单的示例代码，用于演示如何使用 <code>pthread_join</code> 函数等待线程结束并获取其返回值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *num = (<span class="type">int</span> *)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread is running, parameter is %d\n&quot;</span>, *num);</span><br><span class="line">    <span class="type">int</span> *res = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 线程退出的返回值不能是局部变量，这是 malloc 的原因</span></span><br><span class="line">    *res = (*num) * (*num);</span><br><span class="line">    pthread_exit((<span class="type">void</span> *)res);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="type">int</span> param = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *res;</span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, thread_func, (<span class="type">void</span> *)&amp;param);</span><br><span class="line">    pthread_join(thread, (<span class="type">void</span> **)&amp;res);  <span class="comment">// 通过二级指针 (&amp;res) 在函数内改变指向的地址 (res) 下的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread returned: %d\n&quot;</span>, *res);</span><br><span class="line">    <span class="built_in">free</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread is running, parameter is 10</span></span><br><span class="line"><span class="comment">// Thread returned: 100</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果在线程函数中不调用 <code>pthread_exit</code> 函数退出线程，而是直接返回，那么该线程的返回值将是一个未定义的值，可能会导致程序出现不可预料的错误。因此，<strong>在需要线程返回值时，一定要在线程函数中调用 <code>pthread_exit</code> 函数退出线程</strong>。</p>
<h1 id="多线程示例">多线程示例</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">my_thread_func</span><span class="params">(<span class="type">void</span>* ptr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> val = *(<span class="type">int</span>*)ptr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread #%lu running, param val = %d, iter &quot;</span>, pthread_self(), val);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%dth &quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> threadId[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span>* ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        *ptr = i;  <span class="comment">// 注意一</span></span><br><span class="line">        pthread_create(&amp;threadId[i], <span class="literal">NULL</span>, my_thread_func, (<span class="type">void</span>*)(ptr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        pthread_join(threadId[i], (<span class="type">void</span>**)(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread end\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于注意一的解释：在 <code>main</code> 函数中循环创建 5 个线程时，每个线程的 <code>my_thread_func</code> 函数都被传递了指向 <code>i</code> 的指针，而 <code>i</code> 是一个 <em> 自动变量 </em>，其生命周期仅在循环内部。<strong> 由于线程的创建和调度是异步的</strong>，因此当线程实际运行时，<code>i</code> 可能已经被更新成另一个值，这会导致线程使用了错误的数据。</p>
<p>正确做法：使用 <code>malloc</code> 申请临时变量来保存自动变量 <code>i</code> 的值，每个线程函数都被传递了一个指向分配的临时变量的指针，该变量保存了正确的 <code>i</code> 值。在线程函数中，使用 <code>*(int *)pointer</code> 获取 <code>i</code> 的值，并在使用完后释放该临时变量的内存空间。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">thread #140021109618240 running, param val = 0, iter 0th 1th 2th 3th</span><br><span class="line">thread #140021101225536 running, param val = 1, iter 0th 1th 2th 3th</span><br><span class="line">thread #140020958615104 running, param val = 2, iter thread #140021092832832 running, param val = 3, iter 0th 1th 2th 3th</span><br><span class="line">0th 1th 2th 3th</span><br><span class="line">thread #140021084440128 running, param val = 4, iter 0th 1th 2th 3th</span><br><span class="line">main thread end</span><br></pre></td></tr></table></figure>
<p>由于线程之间是异步执行的，<strong>无法保证互斥执行（线程的临界资源要么不执行、要么全部执行）</strong>。如上面打印中，线程 15104 还没来得及迭代，就被线程 32832 抢占了 CPU 执行权。因此，如果需要保证互斥执行，可以使用互斥锁来实现。</p>
<h1 id="多线程互斥访问示例">多线程互斥访问示例</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">my_thread_func</span><span class="params">(<span class="type">void</span>* ptr)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="type">int</span> val = *(<span class="type">int</span>*)ptr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread #%lu running, param val = %d, iter &quot;</span>, pthread_self(), val);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%dth &quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> threadId[<span class="number">5</span>];</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span>* ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        *ptr = i;  <span class="comment">// 注意一</span></span><br><span class="line">        pthread_create(&amp;threadId[i], <span class="literal">NULL</span>, my_thread_func, (<span class="type">void</span>*)(ptr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        pthread_join(threadId[i], (<span class="type">void</span>**)(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread end\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在修改后的代码中，我们使用 <code>pthread_mutex_t</code> 类型定义了一个互斥锁，并在 <code>main</code> 函数中初始化了它。在 <code>my_thread_func</code> 函数中，我们在循环前加锁（某一个线程获取了锁），循环结束后解锁（该线程释放了锁，此时其它线程可以获取锁了），以保证线程的互斥访问（先获取锁的线程，会执行完锁之间的内容，不再会出现上面未加锁的示例中，执行到一半，便去执行其它线程的内容）。最后在 <code>main</code> 函数结束前销毁互斥锁。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">thread #140354695198272 running, param val = 0, iter 0th 1th 2th 3th</span><br><span class="line">thread #140354678412864 running, param val = 2, iter 0th 1th 2th 3th</span><br><span class="line">thread #140354686805568 running, param val = 1, iter 0th 1th 2th 3th</span><br><span class="line">thread #140354661627456 running, param val = 4, iter 0th 1th 2th 3th</span><br><span class="line">thread #140354670020160 running, param val = 3, iter 0th 1th 2th 3th</span><br><span class="line">main thread end</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>多线程编程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>进程与线程</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程编程之读者写者问题</title>
    <url>/posts/240319195609.html</url>
    <content><![CDATA[<p>读者写者问题是并发程序设计中的经典问题。问题描述为：对于同一块共享资源，读 - 写操作互斥，写 - 写操作互斥，读 - 读操作允许（读操作可以同时并行）。本文是对 <a href="/posts/240205182643.html"> 操作系统之经典同步问题 </a> 文章中读写问题的具体代码实现。</p>
<span id="more"></span>
<p><strong>读者 - 写者问题的读、写操作限制（仅读者优先或写者优先）</strong>：</p>
<ul>
<li>写 - 写互斥：即不能有两个写者同时进行写操作。</li>
<li>读 - 写互斥：即不能同时有一个线程在读，而另一个线程在写。</li>
<li>读 - 读允许：即可以有一个或多个读者线程在读。</li>
</ul>
<h1 id="读者优先信号量实现">读者优先信号量实现</h1>
<h2 id="模型分析">模型分析</h2>
<p><strong>读者优先定义</strong>：只要有一个读者正在读取共享资源，后来的读者都会被接纳（即使这些读者是在正在等待的写者之后到来的，也会优先让这些读者读取共享资源）。如果读者源源不断的出现，那么写者将始终处于阻塞状态（可能会出现饿死）。</p>
<p>例如有以下访问序列：</p>
<ul>
<li>到达时刻：读者 1 -&gt; 读者 2 -&gt; 写者 a -&gt; 读者 3，且写者 a 到达时有读者正在访问共享资源。</li>
<li>访问顺序：读者 1 -&gt; 读者 2 -&gt; 读者 3 -&gt; 写者 a，即写者后的读者 3 可以插队到先来的写者 a 之前，访问共享资源。</li>
</ul>
<p><strong>读者优先允许同时有多个读者在读取资源</strong>。若将这些读者分为第一个读者、中间的读者和最后一个读者，那么这三类读者有不同的动作：</p>
<ul>
<li>第一个读者：尝试读 -&gt; 可以读 + <strong>不可以写</strong> -&gt; 读操作 -&gt; 结束读；</li>
<li>中间的读者：尝试读 -&gt; 可以读 -&gt; 读操作 -&gt; 结束读；</li>
<li>最后的读者：尝试读 -&gt; 可以读 -&gt; 读操作 -&gt; 结束读 + <strong>可以写</strong>。</li>
</ul>
<p>也就是，<strong>第一个读者要负责禁止写者执行写操作，最后一个读者负责恢复写者执行写操作</strong>。</p>
<p>写者线程就简单了，只要你能拿到锁，你就能执行写操作。能拿到锁的场景：没有读者了（一直没有或最后一个读者结束读）。</p>
<img src="../images/sys-net-program/rdFirst-sem.png" alt="多线程读者优先的信号量实现（代码在后面）" width="60%" height="60%">
<h2 id="模拟数据">模拟数据</h2>
<p>测试数据文件包括多行测试数据，每行数据从左到右依次为线程标识、读写类型、动作前等待时间、动作持续时间。其中，</p>
<ul>
<li>动作前等待时间：即线程创建后，延迟相应时间（单位为秒）后发出对共享资源的读写申请。</li>
<li>动作持续时间：一旦线程读写申请成功，开始对共享资源进行读写操作，该操作持续相应时间后结束，并释放共享资源。</li>
</ul>
<table>
<thead>
<tr>
<th>线程标识</th>
<th>读写类型</th>
<th>动作前等待时间 (秒)</th>
<th>动作持续时间 (秒)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>R</td>
<td>1</td>
<td>5</td>
</tr>
<tr>
<td>1</td>
<td>R</td>
<td>3</td>
<td>5</td>
</tr>
<tr>
<td>2</td>
<td>W</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>3</td>
<td>R</td>
<td>5</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>R</td>
<td>6</td>
<td>5</td>
</tr>
<tr>
<td>5</td>
<td>W</td>
<td>7</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>例如，第四行表示一个读者线程 3，在它被创建 5 秒后，尝试申请读操作；申请成功后，读取资源 2 秒并释放资源、退出线程。</p>
<h2 id="功能实现">功能实现</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_THREAD_NR (100)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线程的动作信息：依次为线程标识、类型、动作前等待时间、动作持续时间 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagThreadAction</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uiTid;</span><br><span class="line">    <span class="type">char</span> cRwType;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uiDelay;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uiDuration;</span><br><span class="line">&#125; THREAD_ACTION_S;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读者优先的锁结构：读者计数器、计数器信号量、写者信号量 ⭐ */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uiRdCnt;</span><br><span class="line">    <span class="type">sem_t</span> stRdCntMutex;</span><br><span class="line">    <span class="type">sem_t</span> stWrMutex;</span><br><span class="line">&#125; READ_FIRST_LOCK_S;</span><br><span class="line"></span><br><span class="line">READ_FIRST_LOCK_S g_stRdFirstLock;  <span class="comment">// 多个线程共享的全局资源 ⭐</span></span><br><span class="line"></span><br><span class="line"><span class="type">time_t</span> stStartTime;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">writer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    THREAD_ACTION_S* pstThrAction = (THREAD_ACTION_S*)arg;</span><br><span class="line"></span><br><span class="line">    sleep(pstThrAction-&gt;uiDelay);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%02.0lf 秒] 写者 #%d 等待写入 \n&quot;</span>, difftime(time(<span class="literal">NULL</span>), stStartTime), pstThrAction-&gt;uiTid);</span><br><span class="line"></span><br><span class="line">    sem_wait(&amp;g_stRdFirstLock.stWrMutex);  <span class="comment">// wait-W ⭐</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%02.0lf 秒] 写者 #%d 开始写入 \n&quot;</span>, difftime(time(<span class="literal">NULL</span>), stStartTime), pstThrAction-&gt;uiTid);</span><br><span class="line">    sleep(pstThrAction-&gt;uiDuration);       <span class="comment">// 模拟写入操作（这期间要持有写锁）</span></span><br><span class="line">    sem_post(&amp;g_stRdFirstLock.stWrMutex);  <span class="comment">// post-W ⭐</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%02.0lf 秒] 写者 #%d 写入结束 \n&quot;</span>, difftime(time(<span class="literal">NULL</span>), stStartTime), pstThrAction-&gt;uiTid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">reader</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    THREAD_ACTION_S* pstThrAction = (THREAD_ACTION_S*)arg;</span><br><span class="line"></span><br><span class="line">    sleep(pstThrAction-&gt;uiDelay);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%02.0lf 秒] 读者 #%d 等待读取 \n&quot;</span>, difftime(time(<span class="literal">NULL</span>), stStartTime), pstThrAction-&gt;uiTid);</span><br><span class="line"></span><br><span class="line">    sem_wait(&amp;g_stRdFirstLock.stRdCntMutex);   <span class="comment">// wait-R-START ⭐</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == g_stRdFirstLock.uiRdCnt) &#123;        <span class="comment">// 第一个读者</span></span><br><span class="line">        sem_wait(&amp;g_stRdFirstLock.stWrMutex);  <span class="comment">// wait-W ⭐</span></span><br><span class="line">    &#125;</span><br><span class="line">    g_stRdFirstLock.uiRdCnt++;  <span class="comment">// 拿读锁是为了修改共享的读计数变量、释放读锁是为了其它读者可以拿到</span></span><br><span class="line">    sem_post(&amp;g_stRdFirstLock.stRdCntMutex);  <span class="comment">// post-R-START ⭐</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%02.0lf 秒] 读者 #%d 开始读取 \n&quot;</span>, difftime(time(<span class="literal">NULL</span>), stStartTime), pstThrAction-&gt;uiTid);</span><br><span class="line">    sleep(pstThrAction-&gt;uiDuration);  <span class="comment">// 模拟读取操作（这期间不用持有读锁、只需要有任一读者持有写锁即可）</span></span><br><span class="line"></span><br><span class="line">    sem_wait(&amp;g_stRdFirstLock.stRdCntMutex);  <span class="comment">// wait-R-END ⭐</span></span><br><span class="line">    g_stRdFirstLock.uiRdCnt--;  <span class="comment">// 拿读锁是为了修改共享的读计数变量、以及最后一个读者释放写锁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == g_stRdFirstLock.uiRdCnt) &#123;        <span class="comment">// 最后一个读者</span></span><br><span class="line">        sem_post(&amp;g_stRdFirstLock.stWrMutex);  <span class="comment">// post-W ⭐</span></span><br><span class="line">    &#125;</span><br><span class="line">    sem_post(&amp;g_stRdFirstLock.stRdCntMutex);  <span class="comment">// post-R-END ⭐</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%02.0lf 秒] 读者 #%d 读取结束 \n&quot;</span>, difftime(time(<span class="literal">NULL</span>), stStartTime), pstThrAction-&gt;uiTid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread[MAX_THREAD_NR];</span><br><span class="line">    THREAD_ACTION_S stThrAction[MAX_THREAD_NR];</span><br><span class="line">    THREAD_ACTION_S stArg;  <span class="comment">// 用于输入参数的存储</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uiThrNr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读者优先锁结构初始化 ⭐ */</span></span><br><span class="line">    g_stRdFirstLock.uiRdCnt = <span class="number">0</span>;</span><br><span class="line">    sem_init(&amp;g_stRdFirstLock.stWrMutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;g_stRdFirstLock.stRdCntMutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 从文件读取每个线程的数据 */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">4</span> == <span class="built_in">scanf</span>(<span class="string">&quot;%d %c %d %d&quot;</span>, &amp;stArg.uiTid, &amp;stArg.cRwType, &amp;stArg.uiDelay, &amp;stArg.uiDuration)) &#123;</span><br><span class="line">        stThrAction[uiThrNr].uiTid = stArg.uiTid;</span><br><span class="line">        stThrAction[uiThrNr].cRwType = stArg.cRwType;</span><br><span class="line">        stThrAction[uiThrNr].uiDelay = stArg.uiDelay;</span><br><span class="line">        stThrAction[uiThrNr].uiDuration = stArg.uiDuration;</span><br><span class="line">        uiThrNr++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stStartTime = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建线程，并根据动作类型，绑定线程函数 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; uiThrNr; i++) &#123;</span><br><span class="line">        pthread_create(&amp;thread[i], <span class="literal">NULL</span>, <span class="string">&#x27;R&#x27;</span> == stThrAction[i].cRwType ? reader : writer, (<span class="type">void</span>*)(&amp;stThrAction[i]));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%02.0lf 秒] 创建线程 #%d\n&quot;</span>, difftime(time(<span class="literal">NULL</span>), stStartTime), stThrAction[i].uiTid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待线程结束 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; uiThrNr; i++) &#123;</span><br><span class="line">        pthread_join(thread[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 销毁信号量 */</span></span><br><span class="line">    sem_destroy(&amp;g_stRdFirstLock.stRdCntMutex);</span><br><span class="line">    sem_destroy(&amp;g_stRdFirstLock.stWrMutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试分析">测试分析</h2>
<p>上述读者优先代码执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[00 秒] 创建线程 #0</span><br><span class="line">[00 秒] 创建线程 #1</span><br><span class="line">[00 秒] 创建线程 #2</span><br><span class="line">[00 秒] 创建线程 #3</span><br><span class="line">[00 秒] 创建线程 #4</span><br><span class="line">[00 秒] 创建线程 #5</span><br><span class="line">[01 秒] 读者 #0 等待读取</span><br><span class="line">[01 秒] 读者 #0 开始读取</span><br><span class="line">[03 秒] 读者 #1 等待读取</span><br><span class="line">[03 秒] 读者 #1 开始读取</span><br><span class="line">[04 秒] 写者 #2 等待写入</span><br><span class="line">[05 秒] 读者 #3 等待读取</span><br><span class="line">[05 秒] 读者 #3 开始读取</span><br><span class="line">[06 秒] 读者 #4 等待读取</span><br><span class="line">[06 秒] 读者 #4 开始读取</span><br><span class="line">[06 秒] 读者 #0 读取结束</span><br><span class="line">[07 秒] 写者 #5 等待写入</span><br><span class="line">[07 秒] 读者 #3 读取结束</span><br><span class="line">[08 秒] 读者 #1 读取结束</span><br><span class="line">[11 秒] 读者 #4 读取结束</span><br><span class="line">[11 秒] 写者 #2 开始写入</span><br><span class="line">[16 秒] 写者 #2 写入结束</span><br><span class="line">[16 秒] 写者 #5 开始写入</span><br><span class="line">[19 秒] 写者 #5 写入结束</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>：</p>
<p>所有线程均在 0 秒时被创建，然后 <strong> 第一个尝试访问共享资源的是读者 #0</strong>，此时所有锁都是释放状态。读者 #0 顺利地拿到计数锁、<strong>写锁（禁止写入）</strong>，开始访问资源，并在第 6 秒结束。</p>
<p>第 3 秒时，读者 #1 尝试访问共享资源，因为它是一个读者，且没有写者在访问共享资源。所以，读者 #1 顺利地开始访问资源，并在第 8 秒结束。</p>
<p>第 4 秒时，写者 #2 尝试访问共享资源，但此时写锁被读者线程持有。所以，写者 #2 开始等待写锁被释放。</p>
<p>第 5 秒时，读者 #3 尝试访问共享资源，因为它是一个读者，且没有写者在访问共享资源。所以，读者 #3 顺利地开始访问资源，并在第 7 秒结束。</p>
<p>第 6 秒时，读者 #4 尝试访问共享资源，因为它是一个读者，且没有写者在访问共享资源。所以，读者 #4 顺利地开始访问资源，并在第 11 秒结束。<strong>此时刻，它是最后一个读者（前面没有读者正在访问者共享资源），它负责通知等待在写锁上的线程（恢复写者执行写操作）</strong>。</p>
<p>第 7 秒时，写者 #5 尝试访问共享资源，但此时写锁被读者线程持有。所以，写者 #5 开始等待锁被释放。</p>
<p>第 11 秒，<strong>由于读者 #4 作为最后一个读者，释放了写锁</strong>。因此，写者 #2 开始执行写操作，5 秒后写操作结束，写者 #5 继而开始执行写操作，直到结束。</p>
<p><strong>结论</strong>：</p>
<p>即使写者请求访问共享资源的时间靠前，但由于写者请求时有其它读者正在访问共享资源，并在其访问结束前来了新的读者请求。这时，后来的读者访问资源的时间比先来的写者早，这便是读者优先。</p>
<h1 id="写者优先（非立即访问）管程实现">写者优先（非立即访问）管程实现</h1>
<h2 id="模型分析 -v2">模型分析</h2>
<p><strong>写者优先定义</strong>：只要有一个写者处于活跃状态，后来的写者都会被接纳（即使这些写者是在正在等待的读者之后到来的，也会优先让这些写者修改共享资源）。如果写者源源不断的出现，那么读者始终处于阻塞状态（可能会出现饿死）。</p>
<p>例如有以下访问序列：</p>
<ul>
<li>到达时刻：读者 1 -&gt; 读者 2 -&gt; 写者 a -&gt; 读者 3 -&gt; 写者 b，且写者 b 到达时有写者正在访问共享资源。</li>
<li>访问顺序：读者 1 -&gt; 读者 2 -&gt; 写者 a -&gt; 写者 b -&gt; 读者 3，即首个等待的写者要等正在访问的所有读者结束后才能访问（换句话说，首个等待的写者不能插队、立即访问，但也不会先让后来的读者先访问），但能在写者访问期间优先处理后续等待的写者、滞后读者。</li>
</ul>
<p>读者写者问题的写者优先可以 <strong> 抽象为两个方法</strong>：</p>
<ul>
<li>读者线程：等待没有写者 -&gt; 读取数据集 -&gt; 检查：唤醒等待的写者。</li>
<li>写者线程：等待没有读者、写者 -&gt; 往数据集写入数据 -&gt; 检查：唤醒等待的读者或写者。</li>
</ul>
<p>具体的实现原理，可以参考 <a href="/posts/240205182643.html#%E7%AE%A1%E7%A8%8B%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%86%99%E8%80%85%E4%BC%98%E5%85%88"> 这篇文章</a>。</p>
<h2 id="功能实现 -v2">功能实现</h2>
<p>管程方式实现中的数据结构是 <code>WRITE_FIRST_LOCK_S</code>，并基于这个数据结构实现了多个方法：</p>
<ul>
<li><code>wrFirstLockInit()</code>：数据结构初始化；</li>
<li><code>startRead()</code>：读取共享资源前的动作；</li>
<li><code>doneRead()</code>：读取共享资源后的动作；</li>
<li><code>startWrite()</code>：修改共享资源前的动作；</li>
<li><code>doneWrite()</code>：修改共享资源后的动作；</li>
<li><code>wrFirstLockDestroy()</code>：数据结构销毁。</li>
</ul>
<p>假设这些方法已经正确实现，那么：</p>
<ul>
<li>读者线程的一次执行过程就是：<code>startRead()</code> -&gt; 读取共享资源 -&gt; <code>doneRead()</code>。</li>
<li>读者线程的一次执行过程就是：<code>startWrite()</code> -&gt; 修改共享资源 -&gt; <code>doneWrite()</code>。</li>
</ul>
<blockquote>
<p>特别注意：假如现在前面已经有 100 个读者正在访问着共享资源，此时来了一个写者，接着又来了 10 个读者和 20 个写者。下面实现的代码效果是 <strong> 要等这 100 个读者访问结束后，这个写者才能访问（不能插队、立即访问）</strong>；当这个写者访问完后，先让后面那 20 个写者访问，再让那 10 个读者访问。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_THREAD_NR (100)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线程的动作信息：依次为线程标识、类型、动作前等待时间、动作持续时间 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagThreadAction</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uiTid;</span><br><span class="line">    <span class="type">char</span> cRwType;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uiDelay;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uiDuration;</span><br><span class="line">&#125; THREAD_ACTION_S;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uiAr;  <span class="comment">// active reader count</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uiAw;  <span class="comment">// active writer count</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uiWr;  <span class="comment">// waiting reader count</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uiWw;  <span class="comment">// waiting writer count</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> stOkToRead;</span><br><span class="line">    <span class="type">pthread_cond_t</span> stOkToWrite;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> stCntMutex;</span><br><span class="line">&#125; WRITE_FIRST_LOCK_S;  <span class="comment">// ⭐</span></span><br><span class="line"></span><br><span class="line">WRITE_FIRST_LOCK_S g_stWrFirstLock;  <span class="comment">// 多个线程共享的全局资源 ⭐</span></span><br><span class="line"></span><br><span class="line"><span class="type">time_t</span> stStartTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写者优先锁结构初始化 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wrFirstLockInit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    g_stWrFirstLock.uiAr = <span class="number">0</span>;</span><br><span class="line">    g_stWrFirstLock.uiAw = <span class="number">0</span>;</span><br><span class="line">    g_stWrFirstLock.uiWr = <span class="number">0</span>;</span><br><span class="line">    g_stWrFirstLock.uiWw = <span class="number">0</span>;</span><br><span class="line">    pthread_cond_init(&amp;g_stWrFirstLock.stOkToRead, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;g_stWrFirstLock.stOkToWrite, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;g_stWrFirstLock.stCntMutex, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 销毁条件变量和互斥锁 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wrFirstLockDestroy</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    pthread_cond_destroy(&amp;g_stWrFirstLock.stOkToRead);</span><br><span class="line">    pthread_cond_destroy(&amp;g_stWrFirstLock.stOkToWrite);</span><br><span class="line">    pthread_mutex_destroy(&amp;g_stWrFirstLock.stCntMutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 准备读：等待没有写者 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">startRead</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    WRITE_FIRST_LOCK_S* pstWrFirstLock = &amp;g_stWrFirstLock;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;pstWrFirstLock-&gt;stCntMutex);  <span class="comment">// 请求计数锁 ⭐</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要有写者（活跃 / 等待），读者就要等待 ⭐</span></span><br><span class="line">    <span class="keyword">while</span> (pstWrFirstLock-&gt;uiAw + pstWrFirstLock-&gt;uiWw &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        pstWrFirstLock-&gt;uiWr++;</span><br><span class="line">        pthread_cond_wait(&amp;pstWrFirstLock-&gt;stOkToRead,</span><br><span class="line">                          &amp;pstWrFirstLock-&gt;stCntMutex);  <span class="comment">// 释放锁，并等待条件变量的唤醒 ⭐</span></span><br><span class="line">        <span class="comment">// 某一个等待的读者可以去读取共享资源了（阻塞结束，必定不会有写者），while 循环结束 ⭐</span></span><br><span class="line">        pstWrFirstLock-&gt;uiWr--;</span><br><span class="line">    &#125;</span><br><span class="line">    pstWrFirstLock-&gt;uiAr++;  <span class="comment">// 这个读者将是活跃状态 ⭐</span></span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;pstWrFirstLock-&gt;stCntMutex);  <span class="comment">// 释放计数锁（以便其它读者可以一起读）⭐</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取结束：检查、（条件满足时）唤醒等待的写者 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">doneRead</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    WRITE_FIRST_LOCK_S* pstWrFirstLock = &amp;g_stWrFirstLock;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;pstWrFirstLock-&gt;stCntMutex);  <span class="comment">// 请求计数锁 ⭐</span></span><br><span class="line"></span><br><span class="line">    pstWrFirstLock-&gt;uiAr--;  <span class="comment">// 读完退出，活跃读者减一 ⭐</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == pstWrFirstLock-&gt;uiAr &amp;&amp; pstWrFirstLock-&gt;uiWw &gt; <span class="number">0</span>) &#123;  <span class="comment">// 在没有活跃的读者时，才有可能唤醒写者 ⭐</span></span><br><span class="line">        pthread_cond_signal(&amp;pstWrFirstLock-&gt;stOkToWrite);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;pstWrFirstLock-&gt;stCntMutex);  <span class="comment">// 释放计数锁 ⭐</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 准备写：等待没有读者和写者 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">startWrite</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    WRITE_FIRST_LOCK_S* pstWrFirstLock = &amp;g_stWrFirstLock;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;pstWrFirstLock-&gt;stCntMutex);  <span class="comment">// 请求计数锁 ⭐</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有活跃的写者或读者，新写者必须等待 ⭐</span></span><br><span class="line">    <span class="keyword">while</span> (pstWrFirstLock-&gt;uiAw + pstWrFirstLock-&gt;uiAr &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        pstWrFirstLock-&gt;uiWw++;</span><br><span class="line">        pthread_cond_wait(&amp;pstWrFirstLock-&gt;stOkToWrite,</span><br><span class="line">                          &amp;pstWrFirstLock-&gt;stCntMutex);  <span class="comment">// 释放锁，并等待条件变量的唤醒 ⭐</span></span><br><span class="line">        pstWrFirstLock-&gt;uiWw--;  <span class="comment">// 新写者可以去修改共享资源了，while 循环结束 ⭐</span></span><br><span class="line">    &#125;</span><br><span class="line">    pstWrFirstLock-&gt;uiAw++;  <span class="comment">// 新写者将是活跃状态 ⭐</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放计数锁（不会出现后续写者也能写，因为上面的 while 将会出现 Aw&gt;0，新写者会被阻塞）⭐</span></span><br><span class="line">    pthread_mutex_unlock(&amp;pstWrFirstLock-&gt;stCntMutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写结束：检查、（条件满足时）唤醒等待的写者（优先）或所有读者 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">doneWrite</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    WRITE_FIRST_LOCK_S* pstWrFirstLock = &amp;g_stWrFirstLock;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;pstWrFirstLock-&gt;stCntMutex);  <span class="comment">// 请求计数锁 ⭐</span></span><br><span class="line"></span><br><span class="line">    pstWrFirstLock-&gt;uiAw--;  <span class="comment">// 写完退出，活跃写者减一 ⭐</span></span><br><span class="line">    <span class="keyword">if</span> (pstWrFirstLock-&gt;uiWw &gt; <span class="number">0</span>) &#123;  <span class="comment">// 优先唤醒等待的写者，其次广播唤醒所有等待的读者 ⭐</span></span><br><span class="line">        pthread_cond_signal(&amp;pstWrFirstLock-&gt;stOkToWrite);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pstWrFirstLock-&gt;uiWr &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        pthread_cond_broadcast(&amp;pstWrFirstLock-&gt;stOkToRead);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;pstWrFirstLock-&gt;stCntMutex);  <span class="comment">// 释放计数锁 ⭐</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">reader</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    THREAD_ACTION_S* pstThrAction = (THREAD_ACTION_S*)arg;</span><br><span class="line"></span><br><span class="line">    sleep(pstThrAction-&gt;uiDelay);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%02.0lf 秒] 读者 #%d 等待读取 \n&quot;</span>, difftime(time(<span class="literal">NULL</span>), stStartTime), pstThrAction-&gt;uiTid);</span><br><span class="line">    startRead();  <span class="comment">// ⭐</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%02.0lf 秒] 读者 #%d 开始读取 \n&quot;</span>, difftime(time(<span class="literal">NULL</span>), stStartTime), pstThrAction-&gt;uiTid);</span><br><span class="line">    sleep(pstThrAction-&gt;uiDuration);  <span class="comment">// 模拟读取操作</span></span><br><span class="line"></span><br><span class="line">    doneRead();  <span class="comment">// ⭐</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%02.0lf 秒] 读者 #%d 读取结束 \n&quot;</span>, difftime(time(<span class="literal">NULL</span>), stStartTime), pstThrAction-&gt;uiTid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">writer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    THREAD_ACTION_S* pstThrAction = (THREAD_ACTION_S*)arg;</span><br><span class="line"></span><br><span class="line">    sleep(pstThrAction-&gt;uiDelay);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%02.0lf 秒] 写者 #%d 等待写入 \n&quot;</span>, difftime(time(<span class="literal">NULL</span>), stStartTime), pstThrAction-&gt;uiTid);</span><br><span class="line">    startWrite();  <span class="comment">// ⭐</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%02.0lf 秒] 写者 #%d 开始写入 \n&quot;</span>, difftime(time(<span class="literal">NULL</span>), stStartTime), pstThrAction-&gt;uiTid);</span><br><span class="line">    sleep(pstThrAction-&gt;uiDuration);  <span class="comment">// 模拟写入操作</span></span><br><span class="line"></span><br><span class="line">    doneWrite();  <span class="comment">// ⭐</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%02.0lf 秒] 写者 #%d 写入结束 \n&quot;</span>, difftime(time(<span class="literal">NULL</span>), stStartTime), pstThrAction-&gt;uiTid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread[MAX_THREAD_NR];</span><br><span class="line">    THREAD_ACTION_S stThrAction[MAX_THREAD_NR];</span><br><span class="line">    THREAD_ACTION_S stArg;  <span class="comment">// 用于输入参数的存储</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uiThrNr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    wrFirstLockInit();</span><br><span class="line">    <span class="comment">// 同上一个程序，省略...</span></span><br><span class="line">    wrFirstLockDestroy();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试分析 -v2">测试分析</h2>
<p>还是使用上面的模拟数据，上述写者优先代码执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[01 秒] 读者 #0 等待读取</span><br><span class="line">[01 秒] 读者 #0 开始读取</span><br><span class="line">[03 秒] 读者 #1 等待读取</span><br><span class="line">[03 秒] 读者 #1 开始读取</span><br><span class="line">[04 秒] 写者 #2 等待写入</span><br><span class="line">[05 秒] 读者 #3 等待读取</span><br><span class="line">[06 秒] 读者 #0 读取结束</span><br><span class="line">[06 秒] 读者 #4 等待读取</span><br><span class="line">[07 秒] 写者 #5 等待写入</span><br><span class="line">[08 秒] 读者 #1 读取结束</span><br><span class="line">[08 秒] 写者 #2 开始写入</span><br><span class="line">[13 秒] 写者 #2 写入结束</span><br><span class="line">[13 秒] 写者 #5 开始写入</span><br><span class="line">[16 秒] 写者 #5 写入结束</span><br><span class="line">[16 秒] 读者 #4 开始读取  // 因为广播唤醒，这里也可能是读者 #3 先读取</span><br><span class="line">[16 秒] 读者 #3 开始读取</span><br><span class="line">[18 秒] 读者 #3 读取结束</span><br><span class="line">[21 秒] 读者 #4 读取结束</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>：</p>
<p>所有线程均在 0 秒时被创建，然后 <strong> 第一个尝试访问共享资源的是读者 #0</strong>，此时所有锁都是释放状态。读者 #0 顺利地拿到计数锁，开始访问资源，并在第 6 秒结束。</p>
<p>第 4 秒时，写者 #2 尝试访问共享资源，但此时 <strong> 有活跃的读者 #0, #1</strong>。所以，写者 #2 释放锁并等待条件变量的唤醒。</p>
<p>第 5, 6 秒时，读者 #3, #4 尝试访问共享资源，因为 <strong> 有等待的写者 #2。所以，读者 #3, #4 也必须停下来等待</strong>。</p>
<p>第 7 秒时，写者 #5 尝试访问共享资源，但此时 <strong> 有活跃的读者 #1</strong>。所以，写者 #5 释放锁并等待条件变量的唤醒。</p>
<p>第 8 秒时，读者 #1 离开共享资源，并 <strong> 唤醒等待在写条件变量上的写者线程 </strong>。这时<strong> 按照写者优先 + FIFO 队列</strong>，依次是写者 #2, #5 访问共享资源。</p>
<p>第 16 秒时，没有写者、但有多个等待的读者。此时，通过广播唤醒所有读者，但只有一把锁，谁先拿到谁先访问共享资源（但真正开始访问共享资源时，会释放锁——这时锁已经可以被其它读者线程持有了，所有第 16 秒时一前一后有两个读者线程开始访问共享资源）。</p>
<p><strong>结论</strong>：</p>
<p>即使读者（#3, #4）请求访问共享资源的时间靠前，但由于读者请求时有其它写者（#2）正在等待或访问共享资源，并在其访问结束前来了新的写者（#5）请求。这时，后来的写者（#5）访问资源的时间比先来的读者（#3, #4）早，<strong>这便是写者优先、但写者不能插队以求立即访问</strong>。</p>
<blockquote>
<p><strong>抛出一个问题</strong>？如何达到真正的写者优先——允许写者插队以立即访问？</p>
<p>如果能 <strong> 保持最多一个（而不是多个）读者在同时 </strong> 访问共享资源，就能实现写者立即访问。这就需要加锁来约束读者只能一个、一个地访问共享资源。</p>
</blockquote>
<h1 id="写者优先（立即访问）管程实现">写者优先（立即访问）管程实现</h1>
<p>保持最多一个（而不是多个）读者在同时访问共享资源，从而实现写者立即访问。</p>
<h2 id="改造代码">改造代码</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uiAr, uiAw, uiWr, uiWw;</span><br><span class="line">    <span class="type">pthread_cond_t</span> stOkToRead, stOkToWrite;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> stCntMutex;</span><br><span class="line">    <span class="type">sem_t</span> stHasReader;  <span class="comment">// 是否有读者正在访问共享资源 ⭐</span></span><br><span class="line">&#125; WRITE_FIRST_LOCK_S;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wrFirstLockInit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sem_init(&amp;g_stWrFirstLock.stHasReader, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wrFirstLockDestroy</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sem_destroy(&amp;g_stWrFirstLock.stHasReader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">startRead</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    WRITE_FIRST_LOCK_S* pstWrFirstLock = &amp;g_stWrFirstLock;</span><br><span class="line"></span><br><span class="line">    sem_wait(&amp;pstWrFirstLock-&gt;stHasReader);  <span class="comment">// 有读者正在访问则等待 ⭐</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">doneRead</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sem_post(&amp;pstWrFirstLock-&gt;stHasReader);  <span class="comment">// 唤醒可能等待访问的读者 ⭐</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，就约束了同一时间只有一个读者可以访问。其访问结束后，若有等待读者和写者，别管谁先来的，写者会先访问共享资源（即立即访问）。</p>
<h2 id="测试分析 -v3">测试分析</h2>
<p>还是使用上面的模拟数据，上述写者优先（立即访问）代码执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[01 秒] 读者 #0 等待读取</span><br><span class="line">[01 秒] 读者 #0 开始读取</span><br><span class="line">[03 秒] 读者 #1 等待读取</span><br><span class="line">[04 秒] 写者 #2 等待写入</span><br><span class="line">[05 秒] 读者 #3 等待读取</span><br><span class="line">[06 秒] 读者 #4 等待读取</span><br><span class="line">[06 秒] 读者 #0 读取结束</span><br><span class="line">[06 秒] 写者 #2 开始写入</span><br><span class="line">[07 秒] 写者 #5 等待写入</span><br><span class="line">[11 秒] 写者 #2 写入结束</span><br><span class="line">[11 秒] 写者 #5 开始写入</span><br><span class="line">[14 秒] 写者 #5 写入结束</span><br><span class="line">[14 秒] 读者 #4 开始读取  // 因为广播唤醒，这里可能是读者 #4/#3/#1 先读取</span><br><span class="line">[19 秒] 读者 #4 读取结束</span><br><span class="line">[19 秒] 读者 #3 开始读取</span><br><span class="line">[21 秒] 读者 #3 读取结束</span><br><span class="line">[21 秒] 读者 #1 开始读取</span><br><span class="line">[26 秒] 读者 #1 读取结束</span><br></pre></td></tr></table></figure>
<h1 id="读写公平管程实现">读写公平管程实现</h1>
<h2 id="模型分析 -v3">模型分析</h2>
<p><strong>读写公平定义 </strong>：读操作可以同时进行，多个读操作之间不会互相阻塞，<strong> 读、写操作按到达顺序访问共享资源</strong>。</p>
<p>例如有以下访问序列：</p>
<ul>
<li>到达时刻：读者 1 -&gt; 读者 2 -&gt; 写者 a -&gt; 读者 3 -&gt; 写者 b -&gt; 写者 c -&gt; 读者 4</li>
<li>访问顺序：读者 1 -&gt; 读者 2 -&gt; 写者 a -&gt; 读者 3 -&gt; 写者 b -&gt; 写者 c -&gt; 读者 4</li>
</ul>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uiRdCount;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> stCntMutex;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> stOkToWrite;</span><br><span class="line">    <span class="type">sem_t</span> stWantVisit;  <span class="comment">// 访问者想访问共享资源</span></span><br><span class="line">&#125; RW_FAIR_LOCK_S; <span class="comment">// ⭐</span></span><br><span class="line"></span><br><span class="line">RW_FAIR_LOCK_S g_stRwFairLock;</span><br><span class="line"></span><br><span class="line"><span class="type">time_t</span> stStartTime;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwFairLockInit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    g_stRwFairLock.uiRdCount = <span class="number">0</span>;</span><br><span class="line">    pthread_mutex_init(&amp;g_stRwFairLock.stCntMutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;g_stRwFairLock.stOkToWrite, <span class="literal">NULL</span>);</span><br><span class="line">    sem_init(&amp;g_stRwFairLock.stWantVisit, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwFairLockDestroy</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    pthread_mutex_destroy(&amp;g_stRwFairLock.stCntMutex);</span><br><span class="line">    pthread_mutex_destroy(&amp;g_stRwFairLock.stOkToWrite);</span><br><span class="line">    sem_destroy(&amp;g_stRwFairLock.stWantVisit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">startRead</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    RW_FAIR_LOCK_S* pstRwFairLock = &amp;g_stRwFairLock;</span><br><span class="line"></span><br><span class="line">    sem_wait(&amp;pstRwFairLock-&gt;stWantVisit);  <span class="comment">// 有访问者正在访问则等待 ⭐</span></span><br><span class="line">    pthread_mutex_lock(&amp;pstRwFairLock-&gt;stCntMutex);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == pstRwFairLock-&gt;uiRdCount) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;pstRwFairLock-&gt;stOkToWrite);</span><br><span class="line">    &#125;</span><br><span class="line">    pstRwFairLock-&gt;uiRdCount++;</span><br><span class="line">    pthread_mutex_unlock(&amp;pstRwFairLock-&gt;stCntMutex);</span><br><span class="line">    sem_post(&amp;pstRwFairLock-&gt;stWantVisit);  <span class="comment">// 唤醒一个等待访问的访问者 ⭐</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">doneRead</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    RW_FAIR_LOCK_S* pstRwFairLock = &amp;g_stRwFairLock;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;pstRwFairLock-&gt;stCntMutex);</span><br><span class="line">    pstRwFairLock-&gt;uiRdCount--;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == pstRwFairLock-&gt;uiRdCount) &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;pstRwFairLock-&gt;stOkToWrite);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;pstRwFairLock-&gt;stCntMutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">startWrite</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    RW_FAIR_LOCK_S* pstRwFairLock = &amp;g_stRwFairLock;</span><br><span class="line"></span><br><span class="line">    sem_wait(&amp;pstRwFairLock-&gt;stWantVisit);  <span class="comment">// 先表明访问想法，从而阻塞后续的读者 ⭐</span></span><br><span class="line">    pthread_mutex_lock(&amp;pstRwFairLock-&gt;stOkToWrite);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">doneWrite</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    RW_FAIR_LOCK_S* pstRwFairLock = &amp;g_stRwFairLock;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;pstRwFairLock-&gt;stOkToWrite);</span><br><span class="line">    sem_post(&amp;pstRwFairLock-&gt;stWantVisit);  <span class="comment">// 唤醒一个等待访问的访问者 ⭐</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试分析 -v4">测试分析</h2>
<p>还是使用上面的模拟数据，上述读写公平代码执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[01 秒] 读者 #0 等待读取</span><br><span class="line">[01 秒] 读者 #0 开始读取</span><br><span class="line">[03 秒] 读者 #1 等待读取</span><br><span class="line">[03 秒] 读者 #1 开始读取</span><br><span class="line">[04 秒] 写者 #2 等待写入</span><br><span class="line">[05 秒] 读者 #3 等待读取</span><br><span class="line">[06 秒] 读者 #0 读取结束</span><br><span class="line">[06 秒] 读者 #4 等待读取</span><br><span class="line">[07 秒] 写者 #5 等待写入</span><br><span class="line">[08 秒] 读者 #1 读取结束</span><br><span class="line">[08 秒] 写者 #2 开始写入</span><br><span class="line">[13 秒] 写者 #2 写入结束</span><br><span class="line">[13 秒] 读者 #3 开始读取  // 按 FIFO 顺序访问</span><br><span class="line">[13 秒] 读者 #4 开始读取</span><br><span class="line">[15 秒] 读者 #3 读取结束</span><br><span class="line">[18 秒] 读者 #4 读取结束</span><br><span class="line">[18 秒] 写者 #5 开始写入</span><br><span class="line">[21 秒] 写者 #5 写入结束</span><br></pre></td></tr></table></figure>
<h1 id="读者写者实现比较">读者写者实现比较</h1>
<table>
<thead>
<tr>
<th>读者优先</th>
<th>写者优先（不可插队）</th>
<th>写者优先（立即访问）</th>
<th>读写公平</th>
</tr>
</thead>
<tbody>
<tr>
<td>[01 秒] 读者 #0 等待读取</td>
<td>[01 秒] 读者 #0 等待读取</td>
<td>[01 秒] 读者 #0 等待读取</td>
<td>[01 秒] 读者 #0 等待读取</td>
</tr>
<tr>
<td>[01 秒] 读者 #0 开始读取</td>
<td>[01 秒] 读者 #0 开始读取</td>
<td>[01 秒] 读者 #0 开始读取</td>
<td>[01 秒] 读者 #0 开始读取</td>
</tr>
<tr>
<td>[03 秒] 读者 #1 等待读取</td>
<td>[03 秒] 读者 #1 等待读取</td>
<td>[03 秒] 读者 #1 等待读取</td>
<td>[03 秒] 读者 #1 等待读取</td>
</tr>
<tr>
<td>[03 秒] 读者 #1 开始读取</td>
<td>[03 秒] 读者 #1 开始读取</td>
<td>[04 秒] 写者 #2 等待写入</td>
<td>[03 秒] 读者 #1 开始读取</td>
</tr>
<tr>
<td>[04 秒] 写者 #2 等待写入</td>
<td>[04 秒] 写者 #2 等待写入</td>
<td>[05 秒] 读者 #3 等待读取</td>
<td>[04 秒] 写者 #2 等待写入</td>
</tr>
<tr>
<td>[05 秒] 读者 #3 等待读取</td>
<td>[05 秒] 读者 #3 等待读取</td>
<td>[06 秒] 读者 #4 等待读取</td>
<td>[05 秒] 读者 #3 等待读取</td>
</tr>
<tr>
<td>[05 秒] 读者 #3 开始读取</td>
<td>[06 秒] 读者 #0 读取结束</td>
<td>[06 秒] 读者 #0 读取结束</td>
<td>[06 秒] 读者 #0 读取结束</td>
</tr>
<tr>
<td>[06 秒] 读者 #4 等待读取</td>
<td>[06 秒] 读者 #4 等待读取</td>
<td>[06 秒] 写者 #2 开始写入</td>
<td>[06 秒] 读者 #4 等待读取</td>
</tr>
<tr>
<td>[06 秒] 读者 #4 开始读取</td>
<td>[07 秒] 写者 #5 等待写入</td>
<td>[07 秒] 写者 #5 等待写入</td>
<td>[07 秒] 写者 #5 等待写入</td>
</tr>
<tr>
<td>[06 秒] 读者 #0 读取结束</td>
<td>[08 秒] 读者 #1 读取结束</td>
<td>[11 秒] 写者 #2 写入结束</td>
<td>[08 秒] 读者 #1 读取结束</td>
</tr>
<tr>
<td>[07 秒] 写者 #5 等待写入</td>
<td>[08 秒] 写者 #2 开始写入</td>
<td>[11 秒] 写者 #5 开始写入</td>
<td>[08 秒] 写者 #2 开始写入</td>
</tr>
<tr>
<td>[07 秒] 读者 #3 读取结束</td>
<td>[13 秒] 写者 #2 写入结束</td>
<td>[14 秒] 写者 #5 写入结束</td>
<td>[13 秒] 写者 #2 写入结束</td>
</tr>
<tr>
<td>[08 秒] 读者 #1 读取结束</td>
<td>[13 秒] 写者 #5 开始写入</td>
<td>[14 秒] 读者 #4 开始读取</td>
<td>[13 秒] 读者 #3 开始读取</td>
</tr>
<tr>
<td>[11 秒] 读者 #4 读取结束</td>
<td>[16 秒] 写者 #5 写入结束</td>
<td>[19 秒] 读者 #4 读取结束</td>
<td>[13 秒] 读者 #4 开始读取</td>
</tr>
<tr>
<td>[11 秒] 写者 #2 开始写入</td>
<td>[16 秒] 读者 #4 开始读取</td>
<td>[19 秒] 读者 #3 开始读取</td>
<td>[15 秒] 读者 #3 读取结束</td>
</tr>
<tr>
<td>[16 秒] 写者 #2 写入结束</td>
<td>[16 秒] 读者 #3 开始读取</td>
<td>[21 秒] 读者 #3 读取结束</td>
<td>[18 秒] 读者 #4 读取结束</td>
</tr>
<tr>
<td>[16 秒] 写者 #5 开始写入</td>
<td>[18 秒] 读者 #3 读取结束</td>
<td>[21 秒] 读者 #1 开始读取</td>
<td>[18 秒] 写者 #5 开始写入</td>
</tr>
<tr>
<td>[19 秒] 写者 #5 写入结束</td>
<td>[21 秒] 读者 #4 读取结束</td>
<td>[26 秒] 读者 #1 读取结束</td>
<td>[21 秒] 写者 #5 写入结束</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>多线程编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>读者写者问题</tag>
      </tags>
  </entry>
  <entry>
    <title>工具之 CMake</title>
    <url>/posts/250629214430.html</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="基础知识简介">基础知识简介</h1>
<h2 id="最基础知识">最基础知识</h2>
<h3 id="最低版本要求">最低版本要求</h3>
<p>这是每个 <code>CMakeLists.txt</code> 都必须包含的第一行：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.1</span>) <span class="comment"># 指定该工程最低支持的版本号</span></span><br></pre></td></tr></table></figure>
<p>从 CMake 3.12 开始，版本号可以声明为一个范围，例如 <code>VERSION 3.1...3.15</code>；这意味着这个工程最低可以支持 3.1 版本，但是也最高在 3.15 版本上测试成功过。</p>
<p>当你开始一个新项目，起始推荐这么写：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.7</span>...<span class="number">3.21</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$&#123;CMAKE_VERSION&#125;</span> <span class="keyword">VERSION_LESS</span> <span class="number">3.12</span>) <span class="comment"># CMake 3.12 开始支持版本范围</span></span><br><span class="line">    <span class="keyword">cmake_policy</span>(VERSION <span class="variable">$&#123;CMAKE_MAJOR_VERSION&#125;</span>.<span class="variable">$&#123;CMAKE_MINOR_VERSION&#125;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
<p>如果 CMake 的版本低于 3.12，CMake 将会被设置为当前版本；否则，将会遵守 <code>cmake_minimum_required</code> 中的规定，程序将继续正常运行。</p>
<h3 id="设置一个项目">设置一个项目</h3>
<p>接下来，每一个顶层 <code>CMakelists.txt</code> 文件都应该加入下面这一行：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">project</span>(MyProject</span><br><span class="line">        VERSION <span class="number">1.6</span>.<span class="number">2</span></span><br><span class="line">        DESCRIPTION <span class="string">&quot;Very nice project&quot;</span></span><br><span class="line">        LANGUAGES C)</span><br></pre></td></tr></table></figure>
<p>现在我们看到了更多的语法。项目名称是这里的第一个参数。所有的关键字参数都可选的。语言可以是 C, CXX, …，默认是 C 和 CXX。</p>
<p>项目名称就没有什么特别要注意的。目前为止，我们还没有添加任何的目标 (target)。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ grep <span class="string">&quot;VERSION&quot;</span> ./CMakeCache.txt</span><br><span class="line">CMAKE_PROJECT_VERSION:STATIC=1.6.2      <span class="comment"># 完整版本号</span></span><br><span class="line">CMAKE_PROJECT_VERSION_MAJOR:STATIC=1    <span class="comment"># 主版本号，重大变更或可能不兼容 API 修改</span></span><br><span class="line">CMAKE_PROJECT_VERSION_NINOR:STATIC=6    <span class="comment"># 次版本号，向后兼容的功能新增或改进</span></span><br><span class="line">CMAKE_PROJECT_VERSION_PATCH:STATIC=2    <span class="comment"># 修订号，向后兼容的问题修复</span></span><br><span class="line">CMAKE_PROJECT_VERSION_TWEAK:STATIC=     <span class="comment"># 微调整号，可选，极小调整</span></span><br><span class="line">$ grep <span class="string">&quot;MyProject&quot;</span> ./CMakeCache.txt</span><br><span class="line">CMAKE_PROJECT_NAME:STATIC=MyProject</span><br></pre></td></tr></table></figure>
<h3 id="生成一个可执行文件">生成一个可执行文件</h3>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(one two.cpp three.h)</span><br></pre></td></tr></table></figure>
<p>这里有一些语法需要解释。one 既是生成的可执行文件的名称，<strong>也是创建的 CMake 目标 (target) 的名称</strong>。紧接着是源文件的列表，你想列多少个都可以。</p>
<blockquote>
<p>CMake 很聪明，它根据拓展名只编译源文件。在大多数情况下，头文件将会被忽略；列出它们的唯一原因是为了让它们在 IDE 中被展示出来，目标文件在许多 IDE 中被显示为文件夹。</p>
</blockquote>
<h3 id="生成一个库">生成一个库</h3>
<p>制作一个库是通过 <code>add_library</code> 命令完成的，并且非常简单：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(one STATIC two.cpp three.h)</span><br></pre></td></tr></table></figure>
<p>你可以选择库的类型，可以是 <code>STATIC</code>, <code>SHARED</code>, <code>MODULE</code>。如果你不选择它，CMake 将会通过 <code>BUILD_SHARED_LIBS</code> 的值来选择构建 <code>STATIC</code> 还是 <code>SHARED</code> 类型的库。</p>
<p>你经常需要生成一个 <strong> 虚构的目标，也就是说，一个不需要编译的目标</strong>。例如，只有一个头文件的库。这被叫做 <code>INTERFACE</code> 库，这是另一种选择，和上面唯一的区别是后面不能有文件名。</p>
<p>【虚拟目标示例 - 只有一个头文件的库：目录树】</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ tree ./interface-lib/ --dirsfirst -a</span><br><span class="line">./interface-lib/</span><br><span class="line">├── app</span><br><span class="line">│   └── main.c</span><br><span class="line">├── include</span><br><span class="line">│   └── only_header_lib <span class="comment"># 仅包含头文件的库</span></span><br><span class="line">│       └── utils.h</span><br><span class="line">└── CMakeLists.txt</span><br></pre></td></tr></table></figure>
<p>【虚拟目标示例 - 只有一个头文件的库：CMakeLists.txt】</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>.<span class="number">2</span>)</span><br><span class="line"><span class="keyword">project</span>(learn-cmake-interface-lib</span><br><span class="line">        VERSION <span class="number">1.0</span>.<span class="number">0</span></span><br><span class="line">        DESCRIPTION <span class="string">&quot;good good study, day day up.&quot;</span></span><br><span class="line">        LANGUAGES C)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 INTERFACE 库，它不会编译生成任何 .so 或 .a 文件，仅用于向其它依赖传递属性</span></span><br><span class="line"><span class="keyword">add_library</span>(only_header_lib INTERFACE)</span><br><span class="line"><span class="comment"># 添加头文件目录到 INTERFACE 属性中（供其它目标使用），任何链接此库的目标会自动获得该头文件搜索路径</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(only_header_lib</span><br><span class="line">    INTERFACE</span><br><span class="line">    <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include/only_header_lib&quot;</span>) <span class="comment"># 将该目录暴露给依赖项</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个可执行文件并链接到 INTERFACE 库，以继承该库的头文件路径以及编译选项（如有）</span></span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="string">&quot;app/main.c&quot;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(app PRIVATE only_header_lib)</span><br></pre></td></tr></table></figure>
<p>【虚拟目标示例 - 只有一个头文件的库：源代码】</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $ cat include/only_header_lib/utils.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEST_DEFINE (10)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $ cat app/main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utils.h&quot;</span> <span class="comment">// 已经获得了该头文件搜索路径</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TEST_DEFINE=%d\n&quot;</span>, TEST_DEFINE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【虚拟目标示例 - 一个虚拟的编译选项目标：CMakeLists.txt】</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>.<span class="number">2</span>)</span><br><span class="line"><span class="keyword">project</span>(learn-cmake-interface-lib</span><br><span class="line">    VERSION <span class="number">1.0</span>.<span class="number">0</span></span><br><span class="line">    DESCRIPTION <span class="string">&quot;good good study, day day up.&quot;</span></span><br><span class="line">    LANGUAGES C)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(compiler_flags INTERFACE)</span><br><span class="line"><span class="keyword">target_compile_options</span>(compiler_flags INTERFACE</span><br><span class="line">    <span class="string">&quot;$&lt;$&lt;CONFIG:DEBUG&gt;:-O0;-g;-std=gnu11;-Wall&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;$&lt;$&lt;CONFIG:RELEASE&gt;:-O2;-std=gnu11;-Wall&gt;&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">NOT</span> CMAKE_SYSTEM_NAME <span class="keyword">MATCHES</span> <span class="string">&quot;Windows&quot;</span>)</span><br><span class="line">    <span class="keyword">target_compile_options</span>(compiler_flags INTERFACE <span class="string">&quot;-Werror;-Wno-unused;-Wno-pointer-sign&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="string">&quot;app/main.c&quot;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(app PRIVATE compiler_flags)</span><br></pre></td></tr></table></figure>
<h3 id="目标时常伴随着你">目标时常伴随着你</h3>
<p>现在我们已经指定了一个目标，那我们如何添加关于它的信息呢？例如，它可能需要包含一个目录：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(one PUBLIC <span class="string">&quot;include&quot;</span>) <span class="comment"># 为目标添加了一个目录</span></span><br></pre></td></tr></table></figure>
<p><code>PUBLIC</code> 对于一个可执行文件目标没有什么含义；<strong>但对于库来说，它让 CMake 知道，任何链接到这个目标的目标也必须包含这个目录。其他选项还有 <code>PRIVATE</code>（只影响当前目标，不影响依赖），以及 <code>INTERFACE</code>（只影响依赖）</strong>。</p>
<p>接下来，我们可以将目标之间链接起来：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(another STATIC another.c another.h)</span><br><span class="line"><span class="comment"># 这里使用 PUBLIC，也就是目标 anthor 也会包含 include 这个目录</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(another PUBLIC one) <span class="comment"># 为目标链接另一个目标</span></span><br></pre></td></tr></table></figure>
<p><code>target_link_libraries</code> 可能是 CMake 中最有用也最令人迷惑的命令。这个命令需要指定一个目标 another，并且在给出该目标的名字（another）后为此目标添加一个依赖 one。</p>
<p>如果 CMake 项目中不存在名称为 one 的目标（没有定义该 target），那它会直接添加名字为 one 的库到依赖中（一般而言，会去 /usr、CMake 项目指定寻找库的路径等所有能找的路径找到叫 one 的库——译者注）（这也是命令叫 <code>target_link_libraries</code> 的原因）。或者你可以给定一个库的完整路径，或者是链接器标志。</p>
<blockquote>
<p>链接的目标可以有包含的目录、链接库（或链接目标）、编译选项、编译定义、编译特性等等。</p>
</blockquote>
<h3 id="更进一步">更进一步</h3>
<p>看看你是否能理解以下文件。它生成了一个简单的 C11 的库并且在程序中使用了它。没有依赖。代码中使用的是 CMake 3.8。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.8</span>)</span><br><span class="line"><span class="keyword">project</span>(Calculator LANGUAGES C)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(calclib STATIC <span class="string">&quot;src/calclib.c&quot;</span> <span class="string">&quot;include/calc/lib.h&quot;</span>)</span><br><span class="line"><span class="keyword">target_include_directories</span>(calclib PUBLIC <span class="string">&quot;include&quot;</span>)</span><br><span class="line"><span class="keyword">target_compile_features</span>(calclib PUBLIC c_std_11)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(calc <span class="string">&quot;apps/calc.c&quot;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(calc PUBLIC calclib)</span><br></pre></td></tr></table></figure>
<h2 id="实用函数">实用函数</h2>
<p>获取一个目录的父目录（上级目录）：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get_filename_component</span>(PARENT_DIR <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;</span> DIRECTORY)</span><br></pre></td></tr></table></figure>
<p>目录存在性检查：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">EXISTS</span> <span class="string">&quot;$&#123;PARENT_DIR&#125;&quot;</span>/testfile.txt)</span><br><span class="line">    <span class="comment"># do something</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
<h2 id="变量与缓存">变量与缓存</h2>
<h3 id="本地变量">本地变量</h3>
<p>我们首先讨论变量。你可以这样声明一个本地 (local) 变量：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_VARIABLE <span class="string">&quot;value&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>变量名通常全部用大写，变量值跟在其后。你可以通过 <code>$&#123;&#125;</code> 来解析一个变量，例如 <code>$&#123;MY_VARIABLE&#125;</code>。</p>
<blockquote>
<p>CMake 有作用域的概念，在声明一个变量后，你只可以在它的作用域内访问这个变量。如果你将一个函数或一个文件放到一个子目录中，这个变量将不再被定义。你可以通过在变量声明末尾添加 <code>PARENT_SCOPE</code> 来将它的作用域指定为当前的上一级作用域。</p>
</blockquote>
<p>列表就是简单地包含一系列变量：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_LIST <span class="string">&quot;one&quot;</span> <span class="string">&quot;two&quot;</span> <span class="string">&quot;three&quot;</span>) <span class="comment"># 也可以这样写: set(MY_LIST &quot;one;two;three&quot;)</span></span><br></pre></td></tr></table></figure>
<p>有一些和列表进行协同的命令，<code>separate_arguments</code> 可以把一个以空格分隔的字符串分割成一个列表。当一个变量用 <code>$&#123;&#125;</code> 括起来的时候，空格的解析规则和上述相同。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(ARGS_STRING <span class="string">&quot;hello world &#x27;CMake example&#x27; 123&quot;</span>)</span><br><span class="line"><span class="keyword">separate_arguments</span>(SPLIT_ARGS UNIX_COMMAND <span class="string">&quot;$&#123;ARGS_STRING&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(arg IN LISTS SPLIT_ARGS)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;- $&#123;arg&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于路径来说要特别小心，路径很有可能会包含空格，因此你应该总是将解析变量得到的值用引号括起来，也就是，应该这样 <code>&quot;$&#123;MY_PATH&#125;&quot;</code> 。</p>
</blockquote>
<h3 id="缓存变量（从命令行中设置变量）">缓存变量（从命令行中设置变量）</h3>
<p>CMake 提供了一个缓存变量，来允许你从命令行中设置变量。CMake 中已经有一些预置的变量，像 <code>CMAKE_BUILD_TYPE</code>。如果一个变量还没有被定义，你可以这样声明并设置它。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CACHE_VAR <span class="string">&quot;VALUE&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;Description info for the cache variable&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CACHE_ENABLE_DEBUG <span class="keyword">ON</span> CACHE BOOL <span class="string">&quot;enable debug&quot;</span>)</span><br><span class="line"><span class="comment"># 还可以用 option 来设置 BOOL 类型的变量</span></span><br><span class="line"><span class="keyword">option</span>(MY_OPTION <span class="string">&quot;This is settable from the command line&quot;</span> <span class="keyword">OFF</span>)</span><br></pre></td></tr></table></figure>
<p>这么写不会覆盖 <code>CMakeCache.txt</code> 中已定义的值——这是为了让你只能在命令行中设置这些变量，而不会在 CMake 文件执行的时候被重新覆盖。这是什么意思呢？</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ cmake -L .                            <span class="comment"># 不设置该缓存值（执行时还不存在 CMakeCache.txt 文件）</span></span><br><span class="line">CACHE_VAR:STRING=VALUE</span><br><span class="line">$ grep <span class="string">&quot;CACHE_VAR&quot;</span> ./CMakeCache.txt</span><br><span class="line">./CMakeCache.txt:CACHE_VAR:STRING=VALUE <span class="comment"># 缓存中读出了 CMakeLists.txt 中的默认值</span></span><br><span class="line">$ </span><br><span class="line">$ cmake -L -DCACHE_VAR=ABCD .           <span class="comment"># 设置了新值</span></span><br><span class="line">CACHE_VAR:STRING=ABCD</span><br><span class="line">$ grep <span class="string">&quot;CACHE_VAR&quot;</span> ./CMakeCache.txt</span><br><span class="line">./CMakeCache.txt:CACHE_VAR:STRING=ABCD  <span class="comment"># 缓存中读出了新值</span></span><br><span class="line">$ </span><br><span class="line">$ cmake -L -DCACHE_VAR=xyz .            <span class="comment"># 又设置了新值，缓存中更新了其值</span></span><br><span class="line">CACHE_VAR:STRING=xyz</span><br><span class="line">$ </span><br><span class="line">$ cmake -L .                            <span class="comment"># 不设置该缓存值</span></span><br><span class="line">CACHE_VAR:STRING=xyz</span><br><span class="line">$ grep <span class="string">&quot;CACHE_VAR&quot;</span> ./CMakeCache.txt</span><br><span class="line">./CMakeCache.txt:CACHE_VAR:STRING=xyz   <span class="comment"># 缓存中读出的是上一次从命令行中设置的值，不会是 CMakeLists.txt 中的默认值</span></span><br></pre></td></tr></table></figure>
<p>如果你想把这些变量作为一个临时的全局变量，你可以这样做：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CACHE_VAR_FORCE <span class="string">&quot;VALUE_FORCE&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line"><span class="keyword">mark_as_advanced</span>(CACHE_VAR)</span><br><span class="line"><span class="comment"># 你也可以通过 `INTERNAL` 这个类型来达到同样的目的</span></span><br><span class="line"><span class="keyword">set</span>(CACHE_VAR_FORCE <span class="string">&quot;VALUE_FORCE&quot;</span> CACHE INTERNAL <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>【示例 - 缓存变量：CMakeLists.txt】：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CACHE_VAR <span class="string">&quot;VALUE&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;Description info for the cache variable&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CACHE_ENABLE_DEBUG <span class="keyword">ON</span> CACHE BOOL <span class="string">&quot;enable debug&quot;</span>)</span><br><span class="line"><span class="keyword">option</span>(MY_OPTION <span class="string">&quot;This is settable from the command line&quot;</span> <span class="keyword">OFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CACHE_VAR_FORCE1 <span class="string">&quot;VALUE_FORCE1&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line"><span class="keyword">mark_as_advanced</span>(CACHE_VAR_FORCE)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CACHE_VAR_FORCE2 <span class="string">&quot;VALUE_FORCE1&quot;</span> CACHE INTERNAL <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>【示例 - 缓存变量：cmake 输出】：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每次都从命令行设置缓存变量的值，就不会使用 CMakeCache.txt 中已经缓存的旧值了</span></span><br><span class="line">$ cmake -DCACHE_VAR=<span class="string">&quot;VALUE_FROM_CMD&quot;</span> -DMY_OPTION=ON -L .</span><br><span class="line">-- Cache values <span class="comment"># 没有 CACHE_VAR_FORCE1/2 哦</span></span><br><span class="line">CMAKE_BUILD_TYPE:STRING=</span><br><span class="line">CMAKE_INSTALL_PREFIX:PATH=/usr/local</span><br><span class="line">CACHE_ENABLE_DEBUG:BOOL=ON</span><br><span class="line">CACHE_VAR:STRING=VALUE_FROM_CMD</span><br><span class="line">MY_OPTION:BOOL=ON</span><br></pre></td></tr></table></figure>
<h3 id="环境变量">环境变量</h3>
<p>你也可以通过 <code>set(ENV&#123;variable_name&#125; value)</code> 和 <code>$ENV&#123;variable_name&#125;</code> 来设置和获取环境变量，不过一般来说，我们最好避免这么用。</p>
<h3 id="缓存">缓存</h3>
<p>缓存实际上就是个文本文件（CMakeCache.txt），当你运行 CMake 构建目录时会创建它。 CMake 可以通过它来记住你设置的所有东西，因此你可以在不重新运行 CMake 的情况下，再次列出所有的选项。</p>
<h3 id="属性">属性</h3>
<p>CMake 也可以通过属性来存储信息。这就像是一个变量，但它被附加到一些其他的物体 (item) 上，<strong>像是一个目录或者是一个目标</strong>。</p>
<p>一个全局的属性可以是一个有用的、非缓存的全局变量。许多目标属性都是被以 <code>CMAKE_</code> 为前缀的变量来初始化的。例如你设置 <code>CMAKE_CXX_STANDARD</code> 这个变量，这意味着你之后创建的所有目标的 <code>CXX_STANDARD</code> 都将被设为 <code>CMAKE_CXX_STANDARD</code> 变量的值。</p>
<p>你可以这样来设置属性：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该方法可以一次性设置多个目标、文件</span></span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> TargetName</span><br><span class="line">             PROPERTY CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="comment"># 该方法可以为一个目标设置多个属性</span></span><br><span class="line"><span class="keyword">set_target_properties</span>(TargetName PROPERTIES</span><br><span class="line">                      CXX_STANDARD <span class="number">11</span>)</span><br></pre></td></tr></table></figure>
<p>第一种方式更加通用 (general) ，它可以一次性设置多个目标、文件、或测试，并且有一些非常有用的选项。第二种方式是为一个目标设置多个属性的快捷方式。此外，你可以通过类似于下面的方式来获得属性：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get_property</span>(ResultVariable <span class="keyword">TARGET</span> TargetName PROPERTY CXX_STANDARD)</span><br></pre></td></tr></table></figure>
<h2 id="用 -CMake- 进行编程">用 CMake 进行编程</h2>
<h3 id="控制流程">控制流程</h3>
<p>如果你的 CMake 版本不大于 3.1：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(variable)</span><br><span class="line">    <span class="comment"># If variable is `ON`, `YES`, `TRUE`, `Y`, or non zero number</span></span><br><span class="line"><span class="keyword">elseif</span>(variable2)</span><br><span class="line">    <span class="comment"># allow multiple elseif </span></span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="comment"># If variable is `0`, `OFF`, `NO`, `FALSE`, `N`, `IGNORE`, `NOTFOUND`, `&quot;&quot;`, or ends in `-NOTFOUND`</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="comment"># If variable does not expand to one of the above, CMake will expand it then try again</span></span><br></pre></td></tr></table></figure>
<p>如果你的 CMake 版本大于 3.1 ，那么你也可以这么写：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">&quot;$&#123;variable&#125;&quot;</span>)</span><br><span class="line">    <span class="comment"># True if variable is not false-like</span></span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="comment"># Note that undefined variables would be `&quot;&quot;` thus false</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
<p>这里还有一些关键字可以设置，例如：</p>
<ul>
<li>一元的: <code>NOT</code>, <code>TARGET</code>, <code>EXISTS</code> (文件), <code>DEFINED</code> 等。</li>
<li>二元的: <code>STREQUAL</code>, <code>AND</code>, <code>OR</code>, <code>MATCHES</code> (正则表达式), <code>VERSION_LESS</code>, <code>VERSION_LESS_EQUAL</code> (CMake 3.7+) 等。</li>
<li>括号可以用来分组</li>
</ul>
<h3 id="宏定义与函数">宏定义与函数</h3>
<p>CMake 函数和宏只有作用域上存在区别，宏没有作用域的限制。所以说，如果你想让函数中定义的变量对外部可见，你需要使用 <code>PARENT_SCOPE</code> 来改变其作用域。</p>
<p>如果是在嵌套函数中，这会变得异常繁琐，因为你必须在想要变量对外的可见的所有函数中添加 <code>PARENT_SCOPE</code> 标志。但是这样也有好处，函数不会像宏那样对外“泄漏”所有的变量。接下来用函数举一个例子：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>(SIMPLE REQUIRED_ARG)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Simple arguments: $&#123;REQUIRED_ARG&#125;, followed by $&#123;ARGN&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(<span class="variable">$&#123;REQUIRED_ARG&#125;</span> <span class="string">&quot;From SIMPLE&quot;</span> PARENT_SCOPE)</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br><span class="line"></span><br><span class="line">simple(This Foo Bar)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;Output: $&#123;This&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- Simple arguments: This, followed by Foo;Bar</span><br><span class="line">Output: From SIMPLE</span><br></pre></td></tr></table></figure>
<p>如果你想要有一个指定的参数，你应该在列表中明确的列出，除此之外的所有参数都会被存储在 <code>ARGN</code> 这个变量中（ <code>ARGV</code> 中存储了所有的变量，包括你明确列出的 ）。</p>
<p>CMake 的函数没有返回值，你可以通过设定变量值的形式来达到同样地目的。在上面的例子中，你可以通过指定变量名来设置一个变量的值。</p>
<h3 id="参数的控制">参数的控制</h3>
<p>CMake 拥有一个变量命名系统。你可以通过 <code>cmake_parse_arguments</code> 函数来对变量进行命名与解析。如果你想在低于 3.5 版本的 CMake 系统中使用它，你应该包含 <code>CMakeParseArguments</code> 模块，此函数在 CMake 3.5 之前一直存在于上述模块中。这是使用它的一个例子：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>(COMPLEX)</span><br><span class="line">    <span class="keyword">cmake_parse_arguments</span>(</span><br><span class="line">        COMPLEX_PREFIX              <span class="comment"># 变量前缀</span></span><br><span class="line">        <span class="string">&quot;SINGLE;ANOTHER&quot;</span>            <span class="comment"># 布尔类型变量，默认全为 FALSE</span></span><br><span class="line">        <span class="string">&quot;ONE_VALUE;ALSO_ONE_VALUE&quot;</span>  <span class="comment"># 多个单一变量</span></span><br><span class="line">        <span class="string">&quot;MULTI_VALUES&quot;</span>              <span class="comment"># 一个可变参数变量</span></span><br><span class="line">        <span class="variable">$&#123;ARGN&#125;</span>                     <span class="comment"># 可变参数列表</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;COMPLEX_PREFIX_SINGLE = $&#123;COMPLEX_PREFIX_SINGLE&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;COMPLEX_PREFIX_ANOTHER = $&#123;COMPLEX_PREFIX_ANOTHER&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;COMPLEX_PREFIX_ONE_VALUE = $&#123;COMPLEX_PREFIX_ONE_VALUE&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;COMPLEX_PREFIX_ALSO_ONE_VALUE = $&#123;COMPLEX_PREFIX_ALSO_ONE_VALUE&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;COMPLEX_PREFIX_MULTI_VALUES = $&#123;COMPLEX_PREFIX_MULTI_VALUES&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你在调用函数的同级下打印这些变量，看到的全是未定义，因为它们的作用域在函数内</span></span><br><span class="line">complex(SINGLE ONE_VALUE value MULTI_VALUES some other values)</span><br></pre></td></tr></table></figure>
<p>在调用这个函数后，会生成以下变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COMPLEX_PREFIX_SINGLE = TRUE</span><br><span class="line">COMPLEX_PREFIX_ANOTHER = FALSE</span><br><span class="line">COMPLEX_PREFIX_ONE_VALUE = &quot;value&quot;</span><br><span class="line">COMPLEX_PREFIX_ALSO_ONE_VALUE = &lt;UNDEFINED&gt;</span><br><span class="line">COMPLEX_PREFIX_MULTI_VALUES = &quot;some;other;values&quot;</span><br></pre></td></tr></table></figure>
<p>你可以通过 <code>set</code> 来避免在 list 中使用分号。此外，其他剩余的参数（因此参数的指定是可选的）都会被保存在 <code>COMPLEX_PREFIX_UNPARSED_ARGUMENTS</code> 变量中。</p>
<h2 id="与你的代码交互">与你的代码交互</h2>
<h3 id="通过 -CMake- 配置文件">通过 CMake 配置文件</h3>
<p>CMake 允许你在代码中使用 <code>configure_file</code> 来访问 CMake 变量。该命令将一个文件（ 一般以 <code>.in</code> 结尾 ）的内容复制到另一个文件中，并替换其中它找到的所有 CMake 变量。如果你想要在你的输入文件中避免替换掉使用 <code>$&#123;&#125;</code> 包含的内容，你可以使用 <code>@ONLY</code> 关键字。</p>
<p>这个功能在 CMake 中使用的相当频繁，例如在下面的 <code>Version.h.in</code> 中：</p>
<p>Version.h.in:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_VERSION_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_VERSION_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APP_NAME <span class="string">&quot;@PROJECT_NAME@&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_VERSION_MAJOR @PROJECT_VERSION_MAJOR@</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_VERSION_MINOR @PROJECT_VERSION_MINOR@</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_VERSION_PATCH @PROJECT_VERSION_PATCH@</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_VERSION <span class="string">&quot;@PROJECT_VERSION@&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHELL_VAR <span class="string">&quot;$&#123;SHEEL_VAR&#125;&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特性开关</span></span><br><span class="line"><span class="meta">#cmakedefine ENABLE_LOGGING</span></span><br><span class="line">#cmakedefine01 USE_GPU_ACCELERATION</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MY_VERSION_H</span></span></span><br></pre></td></tr></table></figure>
<p>CMake lines:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.22</span>.<span class="number">1</span>)</span><br><span class="line"><span class="keyword">project</span>(MyApp VERSION <span class="number">1.2</span>.<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span>(ENABLE_LOGGING <span class="string">&quot;Enable logging&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">option</span>(USE_GPU_ACCELERATION <span class="string">&quot;Use GPU&quot;</span> <span class="keyword">OFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 Version.h</span></span><br><span class="line"><span class="keyword">configure_file</span> (</span><br><span class="line">    <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/Version.h.in&quot;</span>        <span class="comment"># input file</span></span><br><span class="line">    <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;/include/Version.h&quot;</span>   <span class="comment"># output file</span></span><br><span class="line">    @ONLY                                       <span class="comment"># 避免变量 $&#123;&#125; 被替换</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在构建你的项目时，你也应该包括二进制头文件路径（将生成的头文件目录加入包含路径）</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;/include&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>cmake 后在 include 目录下生成的 Version.h 头文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_VERSION_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_VERSION_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APP_NAME <span class="string">&quot;MyApp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_VERSION_MAJOR 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_VERSION_MINOR 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_VERSION_PATCH 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_VERSION <span class="string">&quot;1.2.3&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHELL_VAR <span class="string">&quot;$&#123;SHEEL_VAR&#125;&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特性开关</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENABLE_LOGGING</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USE_GPU_ACCELERATION 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MY_VERSION_H</span></span></span><br></pre></td></tr></table></figure>
<p>总结：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>用法</th>
<th>示例输入</th>
<th>示例输出</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>普通变量替换</strong></td>
<td><code>@VAR@</code></td>
<td><code>&quot;@PROJECT_NAME@&quot;</code></td>
<td><code>&quot;MyApp&quot;</code></td>
</tr>
<tr>
<td><strong>条件定义</strong></td>
<td><code>#cmakedefine VAR</code></td>
<td><code>#cmakedefine FOO</code></td>
<td><code>#define FOO</code> 或 <code>/* #undef FOO */</code></td>
</tr>
<tr>
<td><strong>强制 0/1 定义</strong></td>
<td><code>#cmakedefine01 VAR</code></td>
<td><code>#cmakedefine01 BAR</code></td>
<td><code>#define BAR 1</code> 或 <code>#define BAR 0</code></td>
</tr>
<tr>
<td><strong>避免 <code>$&#123;&#125;</code> 替换</strong></td>
<td><code>@ONLY</code> 选项</td>
<td><code>$&#123;SHELL_VAR&#125;</code></td>
<td>保留 <code>$&#123;SHELL_VAR&#125;</code></td>
</tr>
</tbody>
</table>
<h3 id="读入文件">读入文件</h3>
<p>另外一个方向也是行得通的， 你也可以从源文件中读取一些东西（例如版本号）。例如，你有一个仅包含头文件的库，你想要其在无论有无 CMake 的情况下都可以使用，上述方式将是你处理版本的最优方案。可以像下面这么写：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Assuming the canonical version is listed in a single line</span></span><br><span class="line"><span class="comment"># This would be in several parts if picking up from MAJOR, MINOR, etc.</span></span><br><span class="line"><span class="keyword">set</span>(VERSION_REGEX <span class="string">&quot;#define MY_VERSION[\t]+\&quot;(.+)\&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Read in the line containing the version</span></span><br><span class="line"><span class="keyword">file</span>(STRINGS <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include/My/Version.h&quot;</span></span><br><span class="line">    VERSION_STRING REGEX <span class="variable">$&#123;VERSION_REGEX&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pick out just the version</span></span><br><span class="line"><span class="keyword">string</span>(REGEX REPLACE <span class="variable">$&#123;VERSION_REGEX&#125;</span> <span class="string">&quot;\\1&quot;</span> VERSION_STRING <span class="string">&quot;$&#123;VERSION_STRING&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Automatically getting PROJECT_VERSION_MAJOR, My_VERSION_MAJOR, etc.</span></span><br><span class="line"><span class="keyword">project</span>(My LANGUAGES CXX VERSION <span class="variable">$&#123;VERSION_STRING&#125;</span>)</span><br></pre></td></tr></table></figure>
<p>如上所示，<code>file(STRINGS file_name variable_name REGEX regex)</code> 选择了与正则表达式相匹配的行，并且使用了相同的正则表达式来匹配出其中版本号的部分。</p>
<h3 id="一个简单的例子">一个简单的例子</h3>
<p>这是一个简单、完整并且合理的 <code>CMakeLists.txt</code> 的例子。对于这个程序，我们有一个带有头文件与源文件的库文件（MyLibExample），以及一个带有源文件的应用程序（MyExample）。</p>
<p>目录树结构：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ tree ./simple-project/ --dirsfirst -a</span><br><span class="line">./simple-project/</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── simple_example.c</span><br><span class="line">├── simple_lib.c</span><br><span class="line">└── simple_lib.h</span><br></pre></td></tr></table></figure>
<p>CMakeLists.txt:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMake simple example</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## [main]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Almost all CMake files should start with this</span></span><br><span class="line"><span class="comment"># You should always specify a range with the newest</span></span><br><span class="line"><span class="comment"># and oldest tested versions of CMake. This will ensure</span></span><br><span class="line"><span class="comment"># you pick up the best policies.</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.1</span>...<span class="number">3.21</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># This is your project statement. You should always list languages;</span></span><br><span class="line"><span class="comment"># Listing the version is nice here since it sets lots of useful variables</span></span><br><span class="line"><span class="keyword">project</span>(</span><br><span class="line">  ModernCMakeExample</span><br><span class="line">  VERSION <span class="number">1.0</span></span><br><span class="line">  DESCRIPTION <span class="string">&quot;a nice example&quot;</span></span><br><span class="line">  LANGUAGES C)</span><br><span class="line"></span><br><span class="line"><span class="comment"># If you set any CMAKE_ variables, that can go here.</span></span><br><span class="line"><span class="comment"># (But usually don&#x27;t do this, except maybe for C++ standard)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Find packages go here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You should usually split this into folders, but this is a simple example</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This is a &quot;default&quot; library, and will match the *** variable setting.</span></span><br><span class="line"><span class="comment"># Other common choices are STATIC, SHARED, and MODULE</span></span><br><span class="line"><span class="comment"># Including header files here helps IDEs but is not required.</span></span><br><span class="line"><span class="comment"># Output libname matches target name, with the usual extensions on your system</span></span><br><span class="line"><span class="keyword">add_library</span>(MyLibExample STATIC simple_lib.c simple_lib.h)  <span class="comment"># 生成静态库</span></span><br><span class="line"><span class="comment">#add_library(MyLibExample SHARED simple_lib.c simple_lib.h) # 生成动态库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Link each target with other targets or add options, etc.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Adding something we can run - Output name matches target name</span></span><br><span class="line"><span class="keyword">add_executable</span>(MyExample simple_example.c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make sure you link your targets with this command. It can also link libraries and</span></span><br><span class="line"><span class="comment"># even flags, so linking a target that does not exist will not give a configure-time error.</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(MyExample PRIVATE MyLibExample)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装规则 - 这会在 `make install` 时将文件复制到指定目录（默认可能是系统目录，可以通过 CMAKE_* 变量重新指定）</span></span><br><span class="line"><span class="keyword">install</span>(TARGETS MyLibExample</span><br><span class="line">  ARCHIVE DESTINATION lib    <span class="comment"># 静态库 (.a)</span></span><br><span class="line">  LIBRARY DESTINATION lib    <span class="comment"># 动态库 (.so)</span></span><br><span class="line">  RUNTIME DESTINATION bin    <span class="comment"># Windows DLL</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>(TARGETS MyExample</span><br><span class="line">  RUNTIME DESTINATION bin    <span class="comment"># 可执行文件</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选：安装头文件</span></span><br><span class="line"><span class="keyword">install</span>(FILES simple_lib.h DESTINATION <span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## [main]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This part is so the Modern CMake book can verify this example builds. For your code,</span></span><br><span class="line"><span class="comment"># you&#x27;ll probably want tests too</span></span><br><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"><span class="keyword">add_test</span>(NAME MyExample <span class="keyword">COMMAND</span> MyExample)</span><br></pre></td></tr></table></figure>
<p>其它源文件的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $ cat simple_lib.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">simple_lib_function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Compiled in library.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $ cat simple_lib.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SIMPLE_LIB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIMPLE_LIB_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">simple_lib_function</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// SIMPLE_LIB_H</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $ cat simple_example.c</span></span><br><span class="line"><span class="comment">// This is an example file as part of Modern-CMake</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;simple_lib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Simple example C compiled correctly and ran.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Output of calling lib function: %s&quot;</span>, simple_lib_function());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建构建目录并编译：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">$ cmake -DCMAKE_INSTALL_PREFIX=./output ..</span><br><span class="line">$ make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>生成静态库的可执行文件执行方式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> output &amp;&amp; ./bin/MyExample</span><br><span class="line">Simple example C compiled correctly and ran.</span><br><span class="line">Output of calling lib <span class="keyword">function</span>: Compiled <span class="keyword">in</span> library.</span><br></pre></td></tr></table></figure>
<p>生成动态库的可执行文件执行方式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> LD_LIBRARY_PATH=/home/simple-project/build/output/lib/:<span class="variable">$&#123;LD_LIBRARY_PATH&#125;</span></span><br><span class="line">$ <span class="built_in">cd</span> output &amp;&amp; ./bin/MyExample -L./lib -I./include</span><br></pre></td></tr></table></figure>
<h3 id="如何组织你的项目">如何组织你的项目</h3>
<p>下面的说法可能存在一些偏见，但我认为这是一种好的组织方式。我将会讲解如何组织项目的目录结构，这是基于以往的惯例来写的，这么做对你有以下好处：</p>
<ul>
<li>可以很容易阅读以相同模式组织的项目</li>
<li>避免可能造成冲突的组织形式</li>
<li>避免使目录结构变得混乱和复杂</li>
</ul>
<p>首先，如果你创建一个名为 project 的项目，它有一个名为 lib 的库，有一个名为 app 的可执行文件，那么目录结构应该如下所示：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ tree ./project/ --dirsfirst -a</span><br><span class="line">./project/</span><br><span class="line">├── apps</span><br><span class="line">│   ├── app.c</span><br><span class="line">│   └── CMakeLists.txt</span><br><span class="line">├── cmake</span><br><span class="line">│   ├── FindSomeLib.cmake</span><br><span class="line">│   └── something_else.cmake</span><br><span class="line">├── docs</span><br><span class="line">│   └── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── project</span><br><span class="line">│       └── lib.h</span><br><span class="line">├── scripts</span><br><span class="line">│   └── helper.py</span><br><span class="line">├── src</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   └── lib.c</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── .gitignore</span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure>
<p>其中，文件的名称不是绝对的，并且应用程序所在的文件夹可能为其他的名称（或者一个项目只有库文件）。你也许也会看到 cmake 文件夹用于存储如 <code>Find&lt;library&gt;.cmake</code> 这样的 .cmake 辅助文件。但是一些比较基础的东西都在上面包括了。</p>
<p>可以注意到一些很明显的问题， <code>CMakeLists.txt</code> 文件被分割到除了 <code>include</code> 目录外的所有源代码目录下。这是为了能够将 <code>include</code> 目录下的所有文件拷贝到 <code>/usr/include</code> 目录或其他类似的目录下，因此为了避免冲突等问题，其中不能有除了头文件外的其他文件。这也是为什么在 <code>include</code> 目录下有一个名为项目名的目录。顶层 <code>CMakeLists.txt</code> 中应使用 <code>add_subdirectory</code> 命令来添加一个包含 <code>CMakeLists.txt</code> 的子目录。</p>
<p>你经常会需要一个 cmake 文件夹，里面包含所有用到的辅助模块。你可以通过以下语句将 cmake 目录添加到你的 CMake Path 中：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_MODULE_PATH <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/cmake&quot;</span> <span class="variable">$&#123;CMAKE_MODULE_PATH&#125;</span>)</span><br></pre></td></tr></table></figure>
<p>你应该在 <code>.gitignore</code> 中添加形如 <code>build*</code> 的规则，这样用户就可以在源代码目录下创建 <code>build</code> 目录来构建项目，而不用担心将生成的目标文件添加到 <code>.git</code> 中。</p>
<p>如果你想要避免构建目录在有效的源代码目录中，你可以在顶层 <code>CMakeLists.txt</code> 文件头部添加如下语句：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">### Require out-of-source builds</span></span><br><span class="line"><span class="keyword">file</span>(TO_CMAKE_PATH <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;/CMakeLists.txt&quot;</span> LOC_PATH)</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">EXISTS</span> <span class="string">&quot;$&#123;LOC_PATH&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;You cannot build in a source directory (or any directory with a CMakeLists.txt file). </span></span><br><span class="line"><span class="string">                         Please make a build subdirectory. Feel free to remove CMakeCache.txt and CMakeFiles.&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
<h3 id="一个完整的例子">一个完整的例子</h3>
<p>略。</p>
<h1 id="为 CMake 项目添加特性">为 CMake 项目添加特性</h1>
<h2 id="默认的构建类型">默认的构建类型</h2>
<p>CMake 通常会设置一个 “既不是 Release 也不是 Debug” 的空构建类型来作为默认的构建类型，如果你想要自己设置默认的构建类型，可以参考如下方法：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Set a default build type if none was specified</span></span><br><span class="line"><span class="keyword">set</span>(default_build_type <span class="string">&quot;Release&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">EXISTS</span> <span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/.git&quot;</span>) <span class="comment"># 当然，这里可以有其它处理逻辑</span></span><br><span class="line">  <span class="keyword">set</span>(default_build_type <span class="string">&quot;Debug&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> CMAKE_BUILD_TYPE <span class="keyword">AND</span> <span class="keyword">NOT</span> CMAKE_CONFIGURATION_TYPES) <span class="comment"># 单构建模式 AND 多构建模式</span></span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;Setting build type to &#x27;$&#123;default_build_type&#125;&#x27; as none was specified.&quot;</span>)</span><br><span class="line">  <span class="keyword">set</span>(CMAKE_BUILD_TYPE <span class="string">&quot;$&#123;default_build_type&#125;&quot;</span> CACHE</span><br><span class="line">      <span class="keyword">STRING</span> <span class="string">&quot;Choose the type of build.&quot;</span> FORCE)</span><br><span class="line">  <span class="comment"># Set the possible values of build type for cmake-gui</span></span><br><span class="line">  <span class="keyword">set_property</span>(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS</span><br><span class="line">    <span class="string">&quot;Debug&quot;</span> <span class="string">&quot;Release&quot;</span> <span class="string">&quot;MinSizeRel&quot;</span> <span class="string">&quot;RelWithDebInfo&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
<p>当然，如果你已经知道用什么构建类型了，你也可以在命令行中指定：如 <code>cmake -DCMAKE_BUILD_TYPE=Debug ..</code>。</p>
<h2 id="CMake-3-1- 全局设置以及属性设置">CMake 3.1+: 全局设置以及属性设置</h2>
<p>这是支持 C 标准的一种方式，（在目标及全局级别）设置三个特定属性的值。这是全局的属性：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将 C 标准设为缓存变量，允许用户通过 -D 覆盖</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_STANDARD <span class="number">11</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;The C standard to use (e.g., 90, 99, 11, 17, 23)&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_STANDARD_REQUIRED <span class="keyword">ON</span>)   <span class="comment"># 告诉 CMake 使用上述设置</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_EXTENSIONS <span class="keyword">OFF</span>)         <span class="comment"># 是否启用拓展，来明确使用 -std=c11 还是 -std=gnu11</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建可执行文件（最终包）</span></span><br><span class="line"><span class="keyword">add_executable</span>(MyApp main.c)</span><br></pre></td></tr></table></figure>
<p>上述前三条配置，可以在最终包（即可执行程序，如 <code>main()</code> 入口的 final package）中使用，但不推荐在库中使用。原因如下：库通常需要兼容不同调用方的 C 标准，硬编码 <code>CMAKE_C_STANDARD</code> 会限制库的灵活性。</p>
<ul>
<li>如果库强制设为 C11，但用户项目用 C17，可能导致兼容性问题。</li>
<li>更好的方式是用 <code>target_compile_features</code> （见下文）。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 库的 CMakeLists.txt（不硬编码标准）</span></span><br><span class="line"><span class="keyword">add_library</span>(MyLib lib.cpp)</span><br><span class="line"><span class="keyword">target_compile_features</span>(MyLib PUBLIC c_std_11)  <span class="comment"># 仅表示最低要求</span></span><br></pre></td></tr></table></figure>
<p>你也可以对目标来设置这些属性：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set_target_properties</span>(myTarget PROPERTIES</span><br><span class="line">    C_STANDARD <span class="number">11</span></span><br><span class="line">    C_STANDARD_REQUIRED <span class="keyword">ON</span></span><br><span class="line">    C_EXTENSIONS NO</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这种方式相比于上面来说更好，但是仍然没法对 <code>PRIVATE</code> 和 <code>INTERFACE</code> 目标的属性有明确的控制，所以他们也仍然只对最终目标 (final targets) 有用。</p>
<p>如何换一种方式，在 C 代码中使用了 GNU 特性呢？</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全局启用 gnu11</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_STANDARD <span class="number">11</span>)        <span class="comment"># 先设置 C11</span></span><br><span class="line"><span class="keyword">add_compile_options</span>(-std=gnu11) <span class="comment"># 再覆盖为 GNU11</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 特定目标启用 gnu11</span></span><br><span class="line"><span class="keyword">target_compile_options</span>(YourTarget PUBLIC -std=gnu11)</span><br></pre></td></tr></table></figure>
<h1 id="一些小而常见的需求">一些小而常见的需求</h1>
<h2 id="地址无关代码 -Position-independent-code">地址无关代码 (Position independent code)</h2>
<p>用标志 <code>-fPIC</code> 来设置这个是最常见的。大部分情况下，你不需要去显式地声明它的值。CMake 将会在 <code>SHARED</code> 以及 <code>MODULE</code> 类型的库中自动的包含此标志。如果你需要显式地声明，可以这么写：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_POSITION_INDEPENDENT_CODE <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure>
<p>这样会对全局的目标进行此设置，或者可以这么写：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set_target_properties</span>(lib1 PROPERTIES POSITION_INDEPENDENT_CODE <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure>
<p>来对某个目标进行设置是否开启此标志。</p>
<h2 id="调试 -CMake">调试 CMake</h2>
<p>首先，让我们来盘点一下调试 CMakeLists 和其他 CMake 文件的方法。</p>
<h3 id="打印变量">打印变量</h3>
<p>通常我们使用的打印语句如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;MY_VARIABLE=$&#123;MY_VARIABLE&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>然而，通过一个内置的模组 <code>CMakePrintHelpoers</code> 可以更方便的打印变量：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span>(CMakePrintHelpers)</span><br><span class="line">cmake_print_variables(MY_VARIABLE)</span><br></pre></td></tr></table></figure>
<p>如果你只是想要打印一个变量，那么上述方法已经很好用了！如果你想要打印一些关于某些目标 (或者是其他拥有变量的项目，比如 <code>SOURCES</code>、<code>DIRECTORIES</code>、<code>TESTS</code> , 或 <code>CACHE_ENTRIES</code> - 全局变量好像因为某些原因缺失了) 的变量，与其一个一个打印它们，你可以简单的列举并打印它们：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">cmake_print_properties(</span><br><span class="line">    TARGETS my_target</span><br><span class="line">    PROPERTIES POSITION_INDEPENDENT_CODE</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="跟踪运行">跟踪运行</h3>
<p>你可能想知道构建项目的时候你的 CMake 文件究竟发生了什么，以及这些都是如何发生的？用 <code>--trace-source=&quot;filename&quot;</code> 就很不错，它会打印出你指定的文件现在运行到哪一行，让你可以知道当前具体在发生什么。另外还有一些类似的选项，但这些命令通常给出一大堆输出，让你找不着头脑。</p>
<p>例子：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">cmake -S . -B build --trace-source=CMakeLists.txt</span><br></pre></td></tr></table></figure>
<p>如果你添加了 <code>--trace-expand</code> 选项，变量会直接展开成它们的值。</p>
<h3 id="以 -debug- 模式构建">以 debug 模式构建</h3>
<p>对于单一构建模式的生成器 (single-configuration generators)，你可以使用参数 <code>-DCMAKE_BUILD_TYPE=Debug</code> 来构建项目，以获得调试标志 (debugging flags)。对于支持多个构建模式的生成器 (multi-configuration generators)，像是多数 IDE，你可以在 IDE 里打开调试模式。这种模式有不同的标志（变量以 <code>_DEBUG</code> 结尾，而不是 <code>_RELEASE</code> 结尾），以及生成器表达式的值 <code>CONFIG:Debug</code> 或 <code>CONFIG:Release</code>。</p>
<p>如果你使用了 debug 模式构建，你就可以在上面运行调试器了，比如 gdb 或 lldb。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title>工具之 Makefile</title>
    <url>/posts/240512184921.html</url>
    <content><![CDATA[<p>使用 GCC 命令行进行程序编译，在单个文件下是比较方便的。但当工程中的文件逐渐增多，甚至变得十分庞大的时候，使用 GCC 命令编译就会变得力不从心。这种情况下，需要借助项目构造工具 <code>make</code> 来帮助我们完成这个艰巨的任务。</p>
<p><strong>make 是一个命令工具，一个解释 Makefile 中指令的命令工具</strong>。<code>make</code> 工具在构造项目时需要加载一个 Makefile 文件，Makefile 关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，Makefile 定义了一系列的规则来指定哪些文件需要先编译、哪些文件需要后编译、哪些文件需要重新编译，甚至于进行更复杂的功能操作。Makefile 就像一个 Shell 脚本一样，其中也可以执行操作系统的命令。</p>
<p>Makefile 带来的好处就是“自动化编译”，一旦写好，只需要一个 <code>make</code> 命令，整个工程完全自动编译，极大的提高了软件开发的效率。</p>
<p>Makefile 文件有两种命名方式 <code>Makefile</code> 和 <code>makefile</code>。构建项目时，在哪个目录下执行构建命令 <code>make</code>，则这个目录下的 Makefile 文件就会被加载。因此，在一个项目中可以有多个 Makefile 文件，分别位于不同的项目目录中。</p>
<span id="more"></span>
<blockquote>
<p>本文转载并修改自：<a href="https://subingwen.cn/linux/makefile/">https://subingwen.cn/linux/makefile/</a></p>
</blockquote>
<h1 id="规则">规则</h1>
<p>Makefile 的框架是由规则构成的。<strong>make 命令执行时先在 Makefile 文件中查找各种规则，对各种规则进行解析后运行规则</strong>。规则的基本格式为：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每条规则的语法格式（command 前为 Tab 缩进，不能是空格）：</span></span><br><span class="line">target1 target2 ...: depend1 depend2 ...</span><br><span class="line">	command1</span><br><span class="line">	command2</span><br><span class="line">	......</span><br></pre></td></tr></table></figure>
<p>每条规则由三个部分组成分别是 <code> 目标 (target)</code>，<code> 依赖 (depend)</code> 和<code>命令(command)</code>。</p>
<ul>
<li><code>命令(command)</code>: 当前这条规则的动作，一般情况下这个动作就是一个 shell 命令。
<ul>
<li>例如：通过某个命令编译文件、生成库文件、进入目录等。</li>
<li>动作可以是多个，每个命令前必须有一个 Tab 缩进并且独占占一行。</li>
</ul>
</li>
<li><code>依赖(depend)</code>: 规则所必需的依赖条件，在规则的命令中可以使用这些依赖。
<ul>
<li>例如：生成可执行文件的目标文件（<code>*.o</code>）可以作为依赖使用。</li>
<li>如果规则的命令中不需要任何依赖，那么规则的依赖可以为空。</li>
<li>当前规则中的依赖，可以是其他规则中的某个目标，这样就形成了规则之间的嵌套。</li>
<li>依赖可以根据要执行的命令的实际需求，指定很多个。</li>
</ul>
</li>
<li><code>目标(target)</code>：规则中的目标，这个目标和规则中的命令是对应的。
<ul>
<li>通过执行规则中的命令，可以生成一个和目标同名的文件。</li>
<li>规则中可以有多个命令，因此可以通过这多条命令来生成多个目标，所以目标也可以有很多个。</li>
<li>通过执行规则中的命令，可以只执行一个动作、但不生成任何目标，这样的目标被称为 <code> 伪目标</code>。</li>
</ul>
</li>
</ul>
<p>关于上面的解释可能有些晦涩，下面通过一个例子来阐述一下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 举例: 有源文件 a.c b.c c.c head.h，需要生成可执行程序 app</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################# 例 1 #################</span></span><br><span class="line"><span class="section">app: a.c b.c c.c</span></span><br><span class="line">	gcc a.c b.c c.c -o app</span><br><span class="line"></span><br><span class="line"><span class="comment">################# 例 2 #################</span></span><br><span class="line"><span class="comment">### 有多个目标，多个依赖，多个命令 ###</span></span><br><span class="line">app app1: a.c b.c c.c d.c</span><br><span class="line">	gcc a.c b.c -o app</span><br><span class="line">	gcc c.c d.c -o app1</span><br><span class="line">	</span><br><span class="line"><span class="comment">################# 例 3 #################	</span></span><br><span class="line"><span class="comment">### 规则之间的嵌套 ###</span></span><br><span class="line"><span class="comment"># 第一条规则</span></span><br><span class="line"><span class="section">app: a.o b.o c.o</span></span><br><span class="line">	gcc a.o b.o c.o -o app</span><br><span class="line"></span><br><span class="line"><span class="comment"># a.o 是第一条规则中的依赖</span></span><br><span class="line"><span class="section">a.o: a.c</span></span><br><span class="line">	gcc -c a.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># b.o 是第一条规则中的依赖</span></span><br><span class="line"><span class="section">b.o: b.c</span></span><br><span class="line">	gcc -c b.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># c.o 是第一条规则中的依赖</span></span><br><span class="line"><span class="section">c.o: c.c</span></span><br><span class="line">	gcc -c c.c</span><br></pre></td></tr></table></figure>
<h1 id="工作原理">工作原理</h1>
<p>在此主要为大家剖析一下通过提供的 Makefile 文件，构建工具 <code>make</code> 在什么时候编译项目中的所有文件，在什么时候只选择更新项目中的某几个文件。另外，再研究一下如果 Makefile 里有多个规则，它们之间是如何配合工作的。我们基于下边的例子，依次进行讲解。</p>
<h2 id="规则执行">规则执行</h2>
<p>当调用 <code>make</code> 命令编译程序时，首先找到 Makefile 文件中的第 1 个规则，然后执行相关的动作。但需要注意的是，很多时候动作（命令）中使用的依赖可能不存在，<strong>如果依赖不存在，该动作也不会执行</strong>。</p>
<p>对应的解决方案如下：</p>
<p><strong>先将需要的依赖生成出来</strong>：在 Makefile 中添加新规则，将“不存在的依赖”作为目标，当新规则的命令执行完毕时，对应的目标就会生成。此时，其他规则中需要的依赖也就存在了。这样，某条规则在需要时会被其他规则调用，直到 Makefile 中的第一条规则的所有依赖都被生成。第一条规则中的命令可以基于这些依赖生成目标，完成 make 的任务。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 规则之间的嵌套</span></span><br><span class="line"><span class="comment"># 规则 1</span></span><br><span class="line"><span class="section">app: a.o b.o c.o</span></span><br><span class="line">	gcc a.o b.o c.o -o app</span><br><span class="line"><span class="comment"># 规则 2</span></span><br><span class="line"><span class="section">a.o: a.c</span></span><br><span class="line">	gcc -c a.c</span><br><span class="line"><span class="comment"># 规则 3</span></span><br><span class="line"><span class="section">b.o: b.c</span></span><br><span class="line">	gcc -c b.c</span><br><span class="line"><span class="comment"># 规则 4</span></span><br><span class="line"><span class="section">c.o: c.c</span></span><br><span class="line">	gcc -c c.c</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这个例子中，执行 <code>make</code> 命令会根据 Makefile 中的 4 条规则编译三个源文件。当解析第一条规则时，发现其中的三个依赖都不存在，因此对应的命令不能执行。</p>
<p>当依赖不存在时，<code>make</code> 会查找其他规则，找到用来生成这些依赖的规则，并执行其命令。因此，规则 2、规则 3、规则 4 中的命令会依次执行。当规则 1 中的依赖全部生成后，其对应的命令也会执行，最终生成规则 1 的目标，<code>make</code> 的工作就结束了。</p>
</blockquote>
<p>知识点拓展：</p>
<p>如果想要执行 Makefile 中非第一条规则对应的命令，那么就不能直接 <code>make</code>，需要将那条规则的目标也写到 make 的后边，比如只需要执行规则 3 中的命令，就需要执行 <code>make b.o</code>。</p>
<h2 id="文件时间戳">文件时间戳</h2>
<p>在执行 <code>make</code> 命令时，会 <strong> 根据文件的时间戳来判断 </strong> 是否执行 Makefile 文件中相关规则中的命令。</p>
<ul>
<li>目标是通过依赖生成的，因此正常情况下，目标的时间戳应大于所有依赖的时间戳。如果执行 <code>make</code> 命令时检测到规则中的目标和依赖满足这个条件，则规则中的命令不会执行。</li>
<li>当依赖文件被更新时，其时间戳也会随之更新。这时，目标的时间戳会小于某些依赖的时间戳，目标文件会通过规则中的命令被重新生成。</li>
<li>如果规则中的目标对应的文件根本不存在，则规则中的命令必定会被执行。</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 规则之间的嵌套</span></span><br><span class="line"><span class="comment"># 规则 1</span></span><br><span class="line"><span class="section">app: a.o b.o c.o</span></span><br><span class="line">	gcc a.o b.o c.o -o app</span><br><span class="line"><span class="comment"># 规则 2</span></span><br><span class="line"><span class="section">a.o: a.c</span></span><br><span class="line">	gcc -c a.c</span><br><span class="line"><span class="comment"># 规则 3</span></span><br><span class="line"><span class="section">b.o: b.c</span></span><br><span class="line">	gcc -c b.c</span><br><span class="line"><span class="comment"># 规则 4</span></span><br><span class="line"><span class="section">c.o: c.c</span></span><br><span class="line">	gcc -c c.c</span><br></pre></td></tr></table></figure>
<blockquote>
<p>根据前文描述，首先执行 <code>make</code> 命令，根据 Makefile 编译这几个源文件生成对应的目标文件。然后修改例子中的 <code>a.c</code> 文件。再次执行 <code>make</code> 编译这几个源文件。在这种情况下，首先执行规则 2 更新目标文件 <code>a.o</code>，然后执行规则 1 更新目标文件 <code>app</code>。其余的规则不会被执行。</p>
</blockquote>
<h2 id="自动推导">自动推导</h2>
<p>make 是一个功能强大的构建工具，尽管我们在编写 Makefile 时可能会出现不够严谨的情况，导致漏写一些构建规则，但程序仍然可以成功编译。这是因为 make 具有自动推导的能力，不完全依赖于 Makefile。</p>
<p>举例来说，当使用 <code>make</code> 命令编译扩展名为 <code>.c</code> 的 C 语言文件时，源文件的编译规则无需明确给出。这是因为 make 在进行编译时会使用一个默认的编译规则，按照默认规则完成对 <code>.c</code> 文件的编译，生成对应的 <code>.o</code> 文件。默认情况下，它使用命令 <code>cc -c</code> 来编译 <code>.c</code> 源文件。在 Makefile 中，只需给出需要构建的目标文件名（即一个 <code>.o</code> 文件），make 会自动为这个 <code>.o</code> 文件寻找合适的依赖文件（对应的 <code>.c</code> 文件），并使用默认的命令来构建这个目标文件。</p>
<p>假设本地项目目录中有以下几个源文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── add.c</span><br><span class="line">├── div.c</span><br><span class="line">├── head.h</span><br><span class="line">├── main.c</span><br><span class="line">├── Makefile</span><br><span class="line">├── mult.c</span><br><span class="line">└── sub.c</span><br></pre></td></tr></table></figure>
<p>目录中 Makefile 文件内容如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是一个完整的 Makefile 文件</span></span><br><span class="line"><span class="section">calc: add.o div.o main.o mult.o sub.o</span></span><br><span class="line">	gcc add.o div.o main.o mult.o sub.o -o calc</span><br></pre></td></tr></table></figure>
<p>通过 make 构建项目：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">cc    -c -o add.o add.c</span><br><span class="line">cc    -c -o div.o div.c</span><br><span class="line">cc    -c -o main.o main.c</span><br><span class="line">cc    -c -o mult.o mult.c</span><br><span class="line">cc    -c -o sub.o sub.c</span><br><span class="line">gcc  add.o  div.o  main.o  mult.o  sub.o -o calc</span><br></pre></td></tr></table></figure>
<p>可以观察到上述的 Makefile 文件中只有一条规则。在依赖部分，所有的 <code>.o</code> 文件在本地项目目录中都不存在，并且没有其他规则用来生成这些依赖文件。在这种情况下，<code>make</code> 会使用内部默认的构建规则，首先生成这些依赖文件，然后执行规则中的命令，最终生成目标文件 <code>calc</code>。</p>
<h1 id="变量">变量</h1>
<p>在使用 Makefile 进行规则定义时，为了增加灵活性，可以使用三种类型的变量：自定义变量、预定义变量、自动变量。</p>
<h2 id="自定义变量">自定义变量</h2>
<p><strong>自定义变量</strong>：这些变量是用户自己定义的、没有类型，可以根据需要随时修改。通过定义变量，可以将一些常用的值或命令集中管理，以便在整个 Makefile 中重复使用。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 错误，只创建了变量名，没有赋值</span></span><br><span class="line">obj</span><br><span class="line"><span class="comment"># 正确，创建一个变量名并且给其赋值</span></span><br><span class="line">LIBS = -lpthread</span><br></pre></td></tr></table></figure>
<p>在给 Makefile 中的变量赋值之后，如何在需要的时候将变量值取出来呢？</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(LIBS)</span></span><br></pre></td></tr></table></figure>
<p>自定义变量使用举例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是一个规则，普通写法</span></span><br><span class="line"><span class="section">calc: add.o div.o main.o mult.o sub.o</span></span><br><span class="line">	gcc add.o div.o main.o mult.o sub.o -o calc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是一个规则，里边使用了自定义变量</span></span><br><span class="line">obj = add.o div.o main.o mult.o sub.o</span><br><span class="line">target = calc</span><br><span class="line"><span class="variable">$(target)</span>: <span class="variable">$(obj)</span></span><br><span class="line">	gcc <span class="variable">$(obj)</span> -o <span class="variable">$(target)</span></span><br></pre></td></tr></table></figure>
<h2 id="预定义变量">预定义变量</h2>
<p><strong>预定义变量</strong>：这些变量是 make 已经定义好的，用户可以直接在 Makefile 中使用，而不用进行定义。例如，<code>CC</code> 表示 C 编译器的名称，<code>CFLAGS</code> 表示编译 C 程序时需要的额外参数等。这些预定义变量的名字一般都是大写的，经常采用的预定义变量如下表所示：</p>
<table>
<thead>
<tr>
<th>变 量 名</th>
<th>含 义</th>
<th>默 认 值</th>
</tr>
</thead>
<tbody>
<tr>
<td>AR</td>
<td>生成静态库库文件的程序名称</td>
<td>ar</td>
</tr>
<tr>
<td>AS</td>
<td>汇编编译器的名称</td>
<td>as</td>
</tr>
<tr>
<td>CC</td>
<td>C 语言编译器的名称</td>
<td>cc</td>
</tr>
<tr>
<td>CPP</td>
<td>C 语言预编译器的名称</td>
<td>$(CC) -E</td>
</tr>
<tr>
<td>CXX</td>
<td>C++ 语言编译器的名称</td>
<td>g++</td>
</tr>
<tr>
<td>FC</td>
<td>FORTRAN 语言编译器的名称</td>
<td>f77</td>
</tr>
<tr>
<td>RM</td>
<td>删除文件程序的名称</td>
<td>rm -f</td>
</tr>
<tr>
<td>ARFLAGS</td>
<td>生成静态库库文件程序的选项</td>
<td>无默认值</td>
</tr>
<tr>
<td>ASFLAGS</td>
<td>汇编语言编译器的编译选项</td>
<td>无默认值</td>
</tr>
<tr>
<td>CFLAGS</td>
<td>C 语言编译器的编译选项</td>
<td>无默认值</td>
</tr>
<tr>
<td>CPPFLAGS</td>
<td>C 语言预编译的编译选项</td>
<td>无默认值</td>
</tr>
<tr>
<td>CXXFLAGS</td>
<td>C++ 语言编译器的编译选项</td>
<td>无默认值</td>
</tr>
<tr>
<td>FFLAGS</td>
<td>FORTRAN 语言编译器的编译选项</td>
<td>无默认</td>
</tr>
</tbody>
</table>
<p>一个使用了自定义变量和预定义变量的 Makefile：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是一个规则，普通写法</span></span><br><span class="line"><span class="section">calc: add.o div.o main.o mult.o sub.o</span></span><br><span class="line">	gcc add.o div.o main.o mult.o sub.o -o calc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是一个规则，里边使用了自定义变量和预定义变量</span></span><br><span class="line">obj = add.o div.o main.o mult.o sub.o</span><br><span class="line">target = calc</span><br><span class="line">CFLAGS = -O3 <span class="comment"># 代码优化</span></span><br><span class="line"><span class="variable">$(target)</span>: <span class="variable">$(obj)</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(obj)</span> -o <span class="variable">$(target)</span> <span class="variable">$(CFLAGS)</span></span><br></pre></td></tr></table></figure>
<h2 id="自动变量">自动变量</h2>
<p><strong>自动变量</strong>：这些变量的值由 make 在特定的上下文中自动赋值，无需用户手动定义。例如，在规则中使用 <code>$@</code> 表示目标文件的名称，在命令中使用 <code>$&lt;</code> 表示第一个依赖文件的名称等。自动变量使得在规则中引用目标文件、依赖文件等更加方便。</p>
<p>自动变量只能在规则的命令中使用，下表中是一些常见的自动变量：</p>
<table>
<thead>
<tr>
<th>变 量</th>
<th>含 义</th>
</tr>
</thead>
<tbody>
<tr>
<td>$*</td>
<td>表示目标文件的名称，不包含目标文件的扩展名</td>
</tr>
<tr>
<td>$+</td>
<td>表示所有的依赖文件，这些依赖文件之间以空格分开，按照出现的先后为顺序，其中可能 包含重复的依赖文件</td>
</tr>
<tr>
<td>$&lt;</td>
<td>表示依赖项中第一个依赖文件的名称</td>
</tr>
<tr>
<td>$?</td>
<td>依赖项中，所有比目标文件时间戳晚的依赖文件，依赖文件之间以空格分开</td>
</tr>
<tr>
<td>$@</td>
<td>表示目标文件的名称，包含文件扩展名</td>
</tr>
<tr>
<td>$^</td>
<td>依赖项中，所有不重复的依赖文件，这些文件之间以空格分开</td>
</tr>
</tbody>
</table>
<p>下面几个例子，演示一下自动变量如何使用。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是一个规则的普通写法</span></span><br><span class="line"><span class="section">calc: add.o div.o main.o mult.o sub.o</span></span><br><span class="line">	gcc add.o div.o main.o mult.o sub.o -o calc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是一个规则，在命令中使用了自定义变量来替换相关内容</span></span><br><span class="line"><span class="comment"># 自动变量只能在规则的命令中使用</span></span><br><span class="line"><span class="section">calc: add.o div.o main.o mult.o sub.o</span></span><br><span class="line">	gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<h1 id="模式匹配">模式匹配</h1>
<p>在介绍概念之前，先读一下下面的这个 Makefile 文件:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">calc: add.o div.o main.o mult.o sub.o</span></span><br><span class="line">	gcc add.o div.o main.o mult.o sub.o -o calc</span><br><span class="line"></span><br><span class="line"><span class="comment"># gcc -c 仅编译 &amp; 汇编、不链接</span></span><br><span class="line"><span class="section">add.o: add.c</span></span><br><span class="line">	gcc add.c -c</span><br><span class="line"></span><br><span class="line"><span class="section">div.o: div.c</span></span><br><span class="line">	gcc div.c -c</span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">	gcc main.c -c</span><br><span class="line"></span><br><span class="line"><span class="section">sub.o: sub.c</span></span><br><span class="line">	gcc sub.c -c</span><br><span class="line"></span><br><span class="line"><span class="section">mult.o: mult.c</span></span><br><span class="line">	gcc mult.c -c</span><br></pre></td></tr></table></figure>
<p>在阅读过程中，能够发现从第二个规则开始到第六个规则做的是相同的事情。但是由于文件名不同，不得不书写多个规则，这就让 Makefile 文件看起来非常的冗余。我们可以将这一系列相同的操作整理成一个模板，所有类似的操作都可以通过模板去匹配。这样，Makefile 会精简不少，只是可读性会有所下降。</p>
<p>这个规则模板可以写成下边的样子，这种操作就称之为 <strong> 模式匹配</strong>。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一个规则</span></span><br><span class="line"><span class="section">calc: add.o div.o main.o mult.o sub.o</span></span><br><span class="line">	gcc add.o div.o main.o mult.o sub.o -o calc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模式匹配: 通过一个公式，代表若干个满足条件的规则</span></span><br><span class="line"><span class="comment"># 依赖有一个，后缀为.c，生成的目标是一个 .o 的文件，% 是一个通配符，匹配的是文件名</span></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	gcc <span class="variable">$&lt;</span> -c</span><br></pre></td></tr></table></figure>
<p>对于上述使用模式匹配的 Makefile，第一个规则中的依赖（这里是所有的 <code>.o</code> 目标文件）的生成，都需要基于这个使用了模式匹配的规则来生成。在这里，模式规则被执行了 5 次，其中的 % 对应的文件名是不断变化的。因此，命令中依赖的名字，必须要使用自动变量。</p>
<h1 id="函数">函数</h1>
<p>Makefile 中有许多函数，它们都具有返回值。函数的格式与 C/C++ 中的函数不同，写法是 <code>$(函数名 参数 1, 参数 2, 参数 3, ...)</code>，这样设计的目的是为了方便获取函数的返回值。</p>
<p>我将介绍两个在 Makefile 中使用频率较高的函数：<code>wildcard</code> 和 <code>patsubst</code>。</p>
<h2 id="wildcard">wildcard</h2>
<p><code>wildcard</code> 函数的作用是在指定目录下获取特定类型的文件名列表，返回以空格分隔的文件名字符串。函数原型如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> PATTERN...)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>参数功能：</p>
<ul>
<li><code>PATTERN</code> 指定了要搜索的目录和文件类型，比如 <code>*.c</code> 表示当前目录下的所有 <code>.c</code> 文件。</li>
<li>可以指定多个目录，每个路径之间使用空格分隔。</li>
</ul>
</li>
<li>
<p>返回值：</p>
<ul>
<li>返回符合条件的文件列表，文件名之间使用空格分隔。</li>
<li>例如：<code>$(wildcard *.c ./sub/*.c)</code> 可能返回 <code>a.c b.c c.c d.c e.c f.c ./sub/aa.c ./sub/bb.c</code>。</li>
</ul>
</li>
</ul>
<p>以下是函数的使用示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例：搜索三个不同目录下的 .c 格式的源文件</span></span><br><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> /home/robin/a/*.c /home/robin/b/*.c *.c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回值：获取一个大字符串，包含了满足条件的文件名，文件名之间用空格分隔</span></span><br><span class="line"><span class="comment"># /home/robin/a/a.c /home/robin/a/b.c /home/robin/b/c.c /home/robin/b/d.c e.c f.c</span></span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>src</code> 变量获取了满足条件的文件列表，这些文件分别来自 <code>/home/robin/a/</code>、<code>/home/robin/b/</code> 和当前目录。</p>
<h2 id="patsubst">patsubst</h2>
<p><code>patsubst</code> 函数的作用是替换指定模式的 <strong> 文件名后缀</strong>，函数原型如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> pattern, replacement, text)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>参数功能:</p>
<ul>
<li><code>pattern</code>：需要匹配的模式字符串，指定要被替换的文件名后缀。路径和文件名不需要关系，可以使用通配符 <code>%</code> 表示表示。</li>
<li><code>replacement</code>：替换后的新后缀模式字符串。仍然使用 <code>%</code> 表示原始路径和文件名。</li>
<li><code>text</code>：待处理的文本，即原始数据。</li>
</ul>
</li>
<li>
<p>返回值:</p>
<ul>
<li>函数返回替换后的字符串。</li>
</ul>
</li>
</ul>
<p>举例：<code>$(patsubst %.c, %.o, file1.c file2.c)</code> 会将 <code>file1.c</code> 和 <code>file2.c</code> 替换为 <code>file1.o</code> 和 <code>file2.o</code>。</p>
<h1 id="Makefile 编写">Makefile 编写</h1>
<p>下面基于一个简单的项目，为大家演示一下编写一个 Makefile 从不标准到标准的进化过程。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 项目目录结构</span></span><br><span class="line">.</span><br><span class="line">├── add.c</span><br><span class="line">├── div.c</span><br><span class="line">├── head.h</span><br><span class="line">├── main.c</span><br><span class="line">├── mult.c</span><br><span class="line">└── sub.c</span><br><span class="line"><span class="comment"># 需要编写 Makefile 对该项目进行自动化编译</span></span><br></pre></td></tr></table></figure>
<h2 id="版本 1">版本 1</h2>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">calc: add.o div.o main.o mult.o sub.o</span></span><br><span class="line">	gcc add.o div.o main.o mult.o sub.o -o calc</span><br></pre></td></tr></table></figure>
<ul>
<li>该版本的优点：书写简单。</li>
<li>该版本的缺点：只要依赖中的某一个源文件被修改，所有的源文件都需要被重新编译，重新生成规则中的所有 <code>.o</code> 目标文件，太耗时、效率低。</li>
<li>改进方式：提高效率，修改哪一个源文件，哪个源文件被重新编译，不修改就不重新编译。</li>
</ul>
<h2 id="版本 2">版本 2</h2>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认所有的依赖都不存在，需要使用其他规则生成这些依赖</span></span><br><span class="line"><span class="comment"># 因为 add.o 被更新，需要使用最新的依赖，生成最新的目标</span></span><br><span class="line"><span class="section">calc: add.o div.o main.o mult.o sub.o</span></span><br><span class="line">	gcc add.o div.o main.o mult.o sub.o -o calc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果修改了 add.c，add.o 被重新生成</span></span><br><span class="line"><span class="section">add.o: add.c</span></span><br><span class="line">	gcc add.c -c</span><br><span class="line"></span><br><span class="line"><span class="section">div.o: div.c</span></span><br><span class="line">	gcc div.c -c</span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">	gcc main.c -c</span><br><span class="line"></span><br><span class="line"><span class="section">sub.o: sub.c</span></span><br><span class="line">	gcc sub.c -c</span><br><span class="line"></span><br><span class="line"><span class="section">mult.o: mult.c</span></span><br><span class="line">	gcc mult.c -c</span><br></pre></td></tr></table></figure>
<ul>
<li>该版本的优点：相较于版本 1 效率提升了，只需要重新生成被修改的源文件的 <code>.o</code> 目标文件。</li>
<li>该版本的缺点：规则比较冗余，需要精简。</li>
<li>改进方式：在 Makefile 中 <strong> 使用变量和模式匹配</strong>。</li>
</ul>
<h2 id="版本 3">版本 3</h2>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加自定义变量 </span></span><br><span class="line">obj = add.o div.o main.o mult.o sub.o</span><br><span class="line">target = calc</span><br><span class="line"></span><br><span class="line"><span class="variable">$(target)</span>: <span class="variable">$(obj)</span></span><br><span class="line">	gcc <span class="variable">$(obj)</span> -o <span class="variable">$(target)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	gcc <span class="variable">$&lt;</span> -c</span><br></pre></td></tr></table></figure>
<ul>
<li>该版本的优点：文件精简不少，变得简洁了。</li>
<li>该版本的缺点：变量 obj 的值需要手动的写出来，如果需要编译的项目文件很多，都用手写出来不现实。</li>
<li>改进方式：在 Makefile 中 <strong> 使用函数</strong>。</li>
</ul>
<h2 id="版本 4">版本 4</h2>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加自定义变量</span></span><br><span class="line"><span class="comment"># 使用函数搜索当前目录下的源文件 .c</span></span><br><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 .c 源文件的后缀替换为 .o</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line">target = calc</span><br><span class="line"></span><br><span class="line"><span class="variable">$(target)</span>: <span class="variable">$(obj)</span></span><br><span class="line">	gcc <span class="variable">$(obj)</span> -o <span class="variable">$(target)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	gcc <span class="variable">$&lt;</span> -c</span><br></pre></td></tr></table></figure>
<ul>
<li>该版本的优点：解决了自动加载项目文件的问题，解放了双手。</li>
<li>该版本的缺点：没有文件删除的功能，不能删除项目编译过程中生成的 <code>*.o</code> 目标文件和可执行程序。</li>
<li>改进方式：在 Makefile 文件中添加新的规则用于删除生成的 <code>*.o</code> 目标文件和可执行程序。</li>
</ul>
<h2 id="版本 5">版本 5</h2>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加自定义变量</span></span><br><span class="line"><span class="comment"># 使用函数搜索当前目录下的源文件 .c</span></span><br><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 .c 源文件的后缀替换为 .o</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line">target = calc</span><br><span class="line"></span><br><span class="line"><span class="variable">$(target)</span>: <span class="variable">$(obj)</span></span><br><span class="line">	gcc <span class="variable">$(obj)</span> -o <span class="variable">$(target)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	gcc <span class="variable">$&lt;</span> -c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加规则，删除生成的目标文件和可执行程序</span></span><br><span class="line"><span class="comment"># 这个规则比较特殊，clean 根本不会生成，这是一个伪目标</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm <span class="variable">$(obj)</span> <span class="variable">$(target)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>该版本的优点：添加了新的 clean 规则用于文件的删除，直接 <code>make clean</code> 就可以执行规则中的删除命令了。</li>
<li>该版本的缺点：缺少对 clean 为伪文件的声明（在下面有具体的问题演示和分析）。</li>
<li>该改进方式：在 Makefile 文件中声明 <code>clean</code> 是一个伪目标，让 <code>make</code> 放弃对它的时间戳检测。</li>
</ul>
<p>正常情况下，这个版本的 Makefile 是可以正常工作的，但是如果在这个项目目录中添加一个叫做 <code>clean</code> 的文件（和规则中的目标名称相同），再进行 <code>make clean</code> 发现这个规则就不能正常工作了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在项目目录中添加一个叫 clean 的文件，然后在 make clean 这个规则中的命令就不工作了 </span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">add.c  calc   div.c  head.h  main.o    mult.c  sub.c</span><br><span class="line">add.o  div.o  main.c  Makefile  mult.o  sub.o  clean  ---&gt; 新添加的</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> 使用 Makefile 中的规则删除生成的目标文件和可执行程序 </span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make clean</span></span><br><span class="line">make: &#x27;clean&#x27; is up to date. </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> 查看目录，发现相关文件并没有被删除，make clean 失败了</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">add.c  calc   div.c  head.h  main.o    mult.c  sub.c</span><br><span class="line">add.o  clean  div.o  main.c  Makefile  mult.o  sub.o</span><br></pre></td></tr></table></figure>
<p>这个问题的关键点在于 <code>clean</code> 是一个伪目标，不对应任何实体文件，在前边讲 <strong> 关于文件时间戳更新 </strong> 问题的时候说过：如果目标不存在，规则的命令肯定被执行；如果目标文件存在了，就需要比较规则中目标文件和依赖文件的时间戳，满足条件才执行规则的命令，否则不执行。</p>
<p>解决这个问题需要在 Makefile 中声明 <code>clean</code> 是一个伪目标，这样 <code>make</code> 就不会对文件的时间戳进行检测，规则中的命令也就每次都会被执行了。</p>
<p>在 Makefile 中声明一个伪目标需要使用 <code>.PHONY</code> 关键字，声明方式为: <code>.PHONY: 伪文件名称</code>。</p>
<h2 id="最终版">最终版</h2>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加自定义变量</span></span><br><span class="line"><span class="comment"># 使用函数搜索当前目录下的源文件 .c</span></span><br><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 .c 源文件的后缀替换为 .o</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line">target = calc</span><br><span class="line"></span><br><span class="line"><span class="variable">$(target)</span>: <span class="variable">$(obj)</span></span><br><span class="line">	gcc <span class="variable">$(obj)</span> -o <span class="variable">$(target)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	gcc <span class="variable">$&lt;</span> -c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加规则，删除生成的目标文件和可执行程序</span></span><br><span class="line"><span class="comment"># 这个规则比较特殊，clean 根本不会生成，这是一个伪目标</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm <span class="variable">$(obj)</span> <span class="variable">$(target)</span></span><br></pre></td></tr></table></figure>
<h1 id="练习题 1">练习题 1</h1>
<p>如果觉得上边讲的内容看懂了，可以试着根据这个目录结构写出其对应的 Makefile 文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">目录结构</span></span><br><span class="line">.</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h  ==&gt; 头文件，声明了加减乘除四个函数</span><br><span class="line">├── main.c      ==&gt; 测试程序，调用了 head.h 中的函数</span><br><span class="line">├── Makefile</span><br><span class="line">└── src</span><br><span class="line">    ├── add.c   ==&gt; 加法运算</span><br><span class="line">    ├── div.c   ==&gt; 除法运算</span><br><span class="line">    ├── mult.c  ==&gt; 乘法运算</span><br><span class="line">    └── sub.c   ==&gt; 减法运算</span><br><span class="line"></span><br><span class="line">2 directories, 7 files</span><br></pre></td></tr></table></figure>
<p>根据上边的项目目录结构编写的 Makefile 文件如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 搜索多个指定目录下的.c 源文件</span></span><br><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> *.c ./src/*.c)</span></span><br><span class="line"><span class="comment"># 将上述源文件替换为以.o 为后缀的目标文件</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line">include = ./<span class="keyword">include</span></span><br><span class="line">target = calc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有不重复的依赖（$^）链接生成目标（$@）：从目标文件生成可执行文件</span></span><br><span class="line"><span class="variable">$(target)</span>: <span class="variable">$(obj)</span></span><br><span class="line">	gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译规则：从源文件生成目标文件</span></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	gcc <span class="variable">$&lt;</span> -c -I<span class="variable">$(include)</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f <span class="variable">$(obj)</span> <span class="variable">$(target)</span></span><br></pre></td></tr></table></figure>
<p>编译过程日志：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">gcc main.c -c -I./include -o main.o</span><br><span class="line">gcc src/add.c -c -I./include -o src/add.o</span><br><span class="line">gcc src/div.c -c -I./include -o src/div.o</span><br><span class="line">gcc src/mult.c -c -I./include -o src/mult.o</span><br><span class="line">gcc src/sub.c -c -I./include -o src/sub.o</span><br><span class="line">gcc main.o src/add.o src/div.o src/mult.o src/sub.o -o calc</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">make: “calc”已是最新。</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make clean</span></span><br><span class="line">rm -f  main.o  ./src/add.o  ./src/div.o  ./src/mult.o  ./src/sub.o calc</span><br><span class="line"><span class="meta prompt_">$ </span></span><br></pre></td></tr></table></figure>
<p>执行 <code>make</code> 后的项目目录结构：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── calc</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── main.c</span><br><span class="line">├── main.o</span><br><span class="line">├── Makefile</span><br><span class="line">└── src</span><br><span class="line">    ├── add.c</span><br><span class="line">    ├── add.o</span><br><span class="line">    ├── div.c</span><br><span class="line">    ├── div.o</span><br><span class="line">    ├── mult.c</span><br><span class="line">    ├── mult.o</span><br><span class="line">    ├── sub.c</span><br><span class="line">    └── sub.o</span><br><span class="line"></span><br><span class="line">2 directories, 13 files</span><br></pre></td></tr></table></figure>
<h1 id="练习题 2">练习题 2</h1>
<p>如果觉得上边讲的内容看懂了，可以试着根据这个目录结构写出其对应的 Makefile 文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── htdocs</span><br><span class="line">│   ├── check.cgi</span><br><span class="line">│   ├── color.c</span><br><span class="line">│   ├── color.cgi</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   └── README</span><br><span class="line">├── httpd.c</span><br><span class="line">├── LICENSE</span><br><span class="line">├── Makefile</span><br><span class="line">├── README.md</span><br><span class="line">└── simpleclient.c</span><br><span class="line"></span><br><span class="line">1 directory, 10 files</span><br></pre></td></tr></table></figure>
<p>根据上边的项目目录结构编写的 Makefile 文件如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC = gcc</span><br><span class="line">WARNFLAGS = -W -Wall</span><br><span class="line">LIBS = -lpthread <span class="comment">#-lsocket</span></span><br><span class="line"></span><br><span class="line">SRC = <span class="variable">$(<span class="built_in">wildcard</span> *.c ./htdocs/*.c)</span></span><br><span class="line">OBJ = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(SRC)</span>)</span></span><br><span class="line"><span class="comment"># 提取 SRC 中的文件名（包含目录）作为 EXEC 变量的值</span></span><br><span class="line">EXEC := <span class="variable">$(<span class="built_in">patsubst</span> %.c, %, <span class="variable">$(SRC)</span>)</span> <span class="comment"># $(notdir $(SRC))</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(EXEC)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标依赖于同名的 .o 文件</span></span><br><span class="line"><span class="variable">$(EXEC)</span>: %: %.o</span><br><span class="line">	<span class="variable">$(CC)</span> -g <span class="variable">$(WARNFLAGS)</span> <span class="variable">$(LIBS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译规则：从源文件生成目标文件</span></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(WARNFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f <span class="variable">$(EXEC)</span> <span class="variable">$(OBJ)</span></span><br></pre></td></tr></table></figure>
<p>编译过程日志：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">gcc -W -Wall -c httpd.c -o httpd.o</span><br><span class="line">gcc -g -W -Wall -lpthread  httpd.o -o httpd</span><br><span class="line">gcc -W -Wall -c simpleclient.c -o simpleclient.o</span><br><span class="line">simpleclient.c: In function ‘main’:</span><br><span class="line">simpleclient.c:9:14: warning: unused parameter ‘argc’ [-Wunused-parameter]</span><br><span class="line">    9 | int main(int argc, char *argv[])</span><br><span class="line">      |          ~~~~^~~~</span><br><span class="line">simpleclient.c:9:26: warning: unused parameter ‘argv’ [-Wunused-parameter]</span><br><span class="line">    9 | int main(int argc, char *argv[])</span><br><span class="line">      |                    ~~~~~~^~~~~~</span><br><span class="line">gcc -g -W -Wall -lpthread  simpleclient.o -o simpleclient</span><br><span class="line">gcc -W -Wall -c htdocs/color.c -o htdocs/color.o</span><br><span class="line">gcc -g -W -Wall -lpthread  htdocs/color.o -o htdocs/color</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">make: 对“all”无需做任何事。</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make clean</span></span><br><span class="line">rm -f  httpd  simpleclient  ./htdocs/color  httpd.o  simpleclient.o  ./htdocs/color.o</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>
<p>执行 <code>make</code> 后的项目目录结构：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── htdocs</span><br><span class="line">│   ├── check.cgi</span><br><span class="line">│   ├── color</span><br><span class="line">│   ├── color.c</span><br><span class="line">│   ├── color.cgi</span><br><span class="line">│   ├── color.o</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   └── README</span><br><span class="line">├── httpd</span><br><span class="line">├── httpd.c</span><br><span class="line">├── httpd.o</span><br><span class="line">├── LICENSE</span><br><span class="line">├── Makefile</span><br><span class="line">├── README.md</span><br><span class="line">├── simpleclient</span><br><span class="line">├── simpleclient.c</span><br><span class="line">└── simpleclient.o</span><br><span class="line"></span><br><span class="line">1 directory, 16 files</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考资料：</p>
<ol>
<li>本文转载并修改自：<a href="https://subingwen.cn/linux/makefile/">https://subingwen.cn/linux/makefile/</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter10.2 经典同步问题</title>
    <url>/posts/240205182643.html</url>
    <content><![CDATA[<p>本文介绍经典同步问题，包括读者 - 写者问题（涉及读者优先、写者优先的信号量方式实现与管程方式实现），以及哲学家就餐问题。</p>
<span id="more"></span>
<h1 id="读者 - 写者问题">读者 - 写者问题</h1>
<p>读者 - 写者问题的 <strong> 动机：对共享数据的访问</strong>，即读者想要读取共享空间中的数据，而写者想要往共享空间中写入数据，这就需要合理安排读者和写者的访问时机，否则就会出现数据错误问题。</p>
<p>这其中有两种不同角色的使用者：</p>
<ul>
<li>读者：不修改数据、仅仅读取数据；</li>
<li>写者：读取数据并写入（修改）数据。</li>
</ul>
<p>问题的约束（对共享数据访问的前提条件）：</p>
<ol>
<li>允许同一时刻有多个读者，但在任意时刻最多只有一个写者；</li>
<li>当没有写者时，读者才能访问数据；</li>
<li>当没有读者和写者时，写者才能访问数据；</li>
<li>在任何时候只有一个线程可以操作共享变量。</li>
</ol>
<p>涉及的共享数据、变量有哪些？</p>
<ul>
<li>共享数据集；</li>
<li>读者计数器 <code>ReaderCount</code>（初始化为 0）；</li>
<li>写者访问控制信号量 <code>WriteMutex</code>（初始化为 1）——在任意时刻最多只有一个写者，故初始化值必须为 1。</li>
<li>读者计数器访问控制信号量 <code>CountMutex</code>（初始化为 1）——这里初始化为 1，可以实现多个读者同时读取共享数据集，原因是 <code>WriteMutex</code> 和 <code>CountMutex</code> <strong>一个数对共享数据执行写入的互斥访问，另一个是对读者计数器的互斥访问，而不是对读取共享数据集的互斥访问</strong>，所以可以实现多个读者同时读取共享数据集。（具体看后续代码实现）</li>
</ul>
<h2 id="信号量方式实现读者优先">信号量方式实现读者优先</h2>
<h3 id="何为读者优先">何为读者优先</h3>
<p>何为读者优先？</p>
<p>只要有一个读者处于活跃状态（正在读取共享数据），后来的读者都会被接纳（允许其读取数据），即使这些读者是在正在等待的写者之后到来的，也会优先让这些读者读取数据。如果读者源源不断的出现，那么写者始终处于阻塞状态。</p>
<h3 id="共享变量定义">共享变量定义</h3>
<p>定义并初始化上述共享变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ReaderCount = <span class="number">0</span>; <span class="comment">// 读者计数器</span></span><br><span class="line"><span class="type">sem_t</span> WriteMutex; <span class="comment">// 写者访问控制信号量</span></span><br><span class="line"><span class="type">sem_t</span> CountMutex;  <span class="comment">// 读者计数器访问控制信号量，是! 计数器!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line">sem_init(&amp;WriteMutex, <span class="number">0</span>, <span class="number">1</span>);  <span class="comment">// 第二个参数是用于控制信号量的线程间共享</span></span><br><span class="line">sem_init(&amp;CountMutex, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h3 id="写者线程处理">写者线程处理</h3>
<p>Writer 写者线程处理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">writer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    sem_wait(&amp;WriteMutex);</span><br><span class="line">    write();  <span class="comment">// 写操作</span></span><br><span class="line">    sem_post(&amp;WriteMutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析：</p>
<ul>
<li>在写者线程中，当 <code>WriteMutex</code> 信号量为 1 时，执行 P 操作后 <code>WriteMutex &gt;=0</code>，不会触发等待；</li>
<li>若此时再来一个写者，执行 P 操作后，<code>WriteMutex &lt; 0</code>，会进行等待。直到持有信号量的写者，执行 V 操作后，唤醒一个等待的写者线程。</li>
</ul>
<h3 id="读者线程处理">读者线程处理</h3>
<p>Reader 读者线程处理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">reader</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    sem_wait(&amp;CountMutex);</span><br><span class="line">    <span class="keyword">if</span> (ReaderCount == <span class="number">0</span>) &#123;</span><br><span class="line">        sem_wait(&amp;WriteMutex);</span><br><span class="line">    &#125;</span><br><span class="line">    ReaderCount++;</span><br><span class="line">    sem_post(&amp;CountMutex);</span><br><span class="line"></span><br><span class="line">    read();  <span class="comment">// 读操作</span></span><br><span class="line"></span><br><span class="line">    sem_wait(&amp;CountMutex);</span><br><span class="line">    ReaderCount--;</span><br><span class="line">    <span class="keyword">if</span> (ReaderCount == <span class="number">0</span>) &#123;</span><br><span class="line">        sem_post(&amp;WriteMutex);</span><br><span class="line">    &#125;</span><br><span class="line">    sem_post(&amp;CountMutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析：</p>
<ul>
<li>在读者线程中，首先通过 <code>sem_wait(&amp;CountMutex)</code> 等待，获取读者计数器访问控制信号量，如果 <code>ReaderCount</code> 的值为 0，<strong>意味着第一个读者进入</strong>，需要通过 <code>sem_wait(&amp;WriteMutex)</code> 获取写者访问控制信号量（这样，如果后续来了写者线程，就会进入等待），避免写者同时存在。</li>
<li>接下来，释放读者计数器访问控制信号量 <code>sem_post(&amp;CountMutex)</code>（以使得后续读者能够进入），进行读操作。</li>
<li>最后，再次获取读者计数器访问控制信号量，减少读者计数器 <code>ReaderCount</code>，如果 <code>ReaderCount</code> 的值为 0，<strong>意味着没有读者了</strong>，需要通过 <code>sem_post(&amp;WriteMutex)</code> 释放写者访问控制信号量。</li>
</ul>
<p>为什么一个读者线程中，涉及了两对关于 <code>CountMutex</code> 的 <code>sem_wait</code> 等待和 <code>sem_post</code> 释放呢？</p>
<p>这是因为，读者计数器 <code>ReaderCount</code> 是一个共享变量，在一个读者进入或退出时，需要修改 <code>ReaderCount</code> 的值，这要保证对该变量的互斥访问，防止数据错误。</p>
<h2 id="管程方式实现写者优先">管程方式实现写者优先</h2>
<h3 id="何为写者优先">何为写者优先</h3>
<p>何为写者优先？</p>
<p>只要有一个写者处于活跃状态，后来的写者都会被接纳，即使这些写者是在正在等待的读者之后到来的，也会优先让这些写者写入数据。如果写者源源不断的出现，那么读者始终处于阻塞状态。</p>
<h3 id="伪代码">伪代码</h3>
<p>读者写者问题的写者优先可以抽象为两个方法：</p>
<ul>
<li>读者线程：等待没有写者 -&gt; 读取数据集 -&gt; 检查：唤醒等待的写者；</li>
<li>写者线程：等待没有读者、写者 -&gt; 往数据集写入数据 -&gt; 检查：唤醒等待的读者或写者。</li>
</ul>
<img src="../images/os-kernel/chapter10/writer-priority-monitor.png" alt="管程方式实现写者优先" width="80%" height="80%">
<h3 id="管程方式实现">管程方式实现</h3>
<h4 id="共享变量定义 -v2">共享变量定义</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> AR = <span class="number">0</span>;  <span class="comment">// active reader</span></span><br><span class="line"><span class="type">int</span> AW = <span class="number">0</span>;  <span class="comment">// active writer</span></span><br><span class="line"><span class="type">int</span> WR = <span class="number">0</span>;  <span class="comment">// waiting reader</span></span><br><span class="line"><span class="type">int</span> WW = <span class="number">0</span>;  <span class="comment">// waiting writer</span></span><br><span class="line"></span><br><span class="line">Condition okToRead;</span><br><span class="line">Condition okToWrite;</span><br><span class="line">Lock lock;</span><br></pre></td></tr></table></figure>
<h4 id="读者线程实现">读者线程实现</h4>
<img src="../images/os-kernel/chapter10/writer-priority-reader-thread.png" alt="读者线程实现" width="80%" height="80%">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读者读取数据（就像上面的伪代码）：等待没有写者 -&gt; 读取数据集 -&gt; 检查：唤醒等待的写者 -&gt; 退出</span></span><br><span class="line"><span class="function">Public <span class="title">Database::Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// wait until no writers;</span></span><br><span class="line">    <span class="built_in">StartRead</span>();</span><br><span class="line">    read database;</span><br><span class="line">    <span class="comment">// check out - wake up waiting writers;</span></span><br><span class="line">    <span class="built_in">DoneRead</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管程方式实现：等待没有写者后，读者开始读取</span></span><br><span class="line"><span class="function">Private <span class="title">Database::StartRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.<span class="built_in">Acquire</span>();</span><br><span class="line">    <span class="keyword">while</span> (AW + WW &gt; <span class="number">0</span>) &#123;  <span class="comment">/* 体现写者优先的细节 1 */</span></span><br><span class="line">        WR++;</span><br><span class="line">        okToRead.<span class="built_in">wait</span>(&amp;lock);</span><br><span class="line">        WR--</span><br><span class="line">    &#125;</span><br><span class="line">    AR++;</span><br><span class="line">    lock.<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管程方式实现：读者退出</span></span><br><span class="line"><span class="function">Private <span class="title">Database::DoneRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.<span class="built_in">Acquire</span>();</span><br><span class="line">    AR--;</span><br><span class="line">    <span class="comment">// 在没有活跃的读者时，才有可能唤醒写者</span></span><br><span class="line">    <span class="keyword">if</span> (AR == <span class="number">0</span> &amp;&amp; WW &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        okToWrite.<span class="built_in">signal</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    lock.<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>体现写者优先的细节 1：只要有写者，别管是活跃的、还是等待的，写者就得等待。</li>
</ul>
<p>在 <code>DoneRead()</code> 中，为什么有活跃的读者时，不能唤醒写者？不是写者优先吗？</p>
<p>因为，有活跃的读者，表明读者正在读取数据，这时若唤醒写者写入（修改数据），会出现数据错误。虽然是写者优先，但优先的前提是写者 <strong> 正在占据</strong> database，这时后来的读者、写者，才会优先写者。</p>
<h4 id="写者线程实现">写者线程实现</h4>
<img src="../images/os-kernel/chapter10/writer-priority-writer-thread.png" alt="读者线程实现" width="80%" height="80%">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写者写入数据（就像上面的伪代码）：等待没有读者、写者 -&gt; 往数据集写入数据 -&gt; 检查：唤醒等待的读者或写者</span></span><br><span class="line"><span class="function">Public <span class="title">Database::Write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// wait until no readers/writers;</span></span><br><span class="line">    <span class="built_in">StartWrite</span>();</span><br><span class="line">    write database;</span><br><span class="line">    <span class="comment">// check out - wake up waiting a write/all readers;</span></span><br><span class="line">    <span class="built_in">DoneWrite</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管程方式实现：等待没有写者后，读者开始读取</span></span><br><span class="line"><span class="function">Private <span class="title">Database::StartWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.<span class="built_in">Acquire</span>();</span><br><span class="line">    <span class="comment">// 有活跃的写者或活跃的读者，新写者必须等待</span></span><br><span class="line">    <span class="keyword">while</span> (AW + AR &gt; <span class="number">0</span>) &#123;  <span class="comment">/* 体现写者优先的细节 2 */</span></span><br><span class="line">        WW++;</span><br><span class="line">        okToWrite.<span class="built_in">wait</span>(&amp;lock);</span><br><span class="line">        WW--</span><br><span class="line">    &#125;</span><br><span class="line">    AW++;</span><br><span class="line">    lock.<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管程方式实现：读者退出</span></span><br><span class="line"><span class="function">Private <span class="title">Database::DoneWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.<span class="built_in">Acquire</span>();</span><br><span class="line">    AW--;</span><br><span class="line">    <span class="comment">// 有等待的写者则优先唤醒写者，没有则唤醒所有读者</span></span><br><span class="line">    <span class="keyword">if</span> (WW &gt; <span class="number">0</span>) &#123;  <span class="comment">/* 体现写者优先的细节 3 */</span></span><br><span class="line">        okToWrite.<span class="built_in">signal</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (WR &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        okToRead.<span class="built_in">broadcast</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    lock.<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>体现写者优先的细节 2：有活跃的写者（和活跃的读者）时，新的写者需要等待。</li>
<li>体现写者优先的细节 3：优先检查并唤醒等待的写者，而不是等待的读者。</li>
</ul>
<h1 id="哲学家就餐问题">哲学家就餐问题</h1>
<h2 id="问题描述">问题描述</h2>
<p>问题的设定是：</p>
<p>有一圆桌上放着 N 个餐盘和 N 个叉子，N 个哲学家坐在 <strong> 圆桌 </strong> 旁边的椅子上，每个哲学家需要同时拿起他左、右两边的叉子才能进餐，吃完后放下叉子继续思考。如果一个哲学家拿起了左边的叉子，但右边的叉子被其他哲学家占用，那么他就必须等待其他哲学家放下叉子后才能继续。</p>
<blockquote>
<p>哲学家就餐问题是一个经典的并发问题，用来探讨在共享资源的情况下，多个进程或线程之间如何协调和竞争资源的使用。</p>
</blockquote>
<h2 id="关键挑战">关键挑战</h2>
<p>哲学家就餐问题的挑战在于如何 <strong> 避免死锁 </strong>（当所有哲学家都拿起了左边的叉子，但无法再拿起右边的叉子时）和<strong> 饥饿</strong>（某个哲学家无法获得两个叉子而一直等待）的情况发生。</p>
<h2 id="问题思考">问题思考</h2>
<p>共享资源：N 个餐盘和 N 个叉子。</p>
<p>涉及的动作：思考、拿起某一个叉子、进餐、放下某一个叉子。</p>
<p>成功进餐：只要相邻的叉子，被同一个哲学家拿去，那么这个哲学家就可以成功进餐。</p>
<p>失败进餐：当所有哲学家都拿起了左边的叉子，导致无法拿起右边的叉子。</p>
<p>哲学家饿死：N-1 个哲学家进餐很多、很多次后，才能轮到那一个哲学家进餐，虽然有机会进餐，但是大概率在拿到这个机会前就被饿死了。</p>
<h2 id="各种实现思考">各种实现思考</h2>
<h3 id="直观实现（错误）">直观实现（错误）</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N (5)  <span class="comment">// 哲学家个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span> &#123;  <span class="comment">// 哲学家编号：0-4</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        think();                 <span class="comment">// 哲学家在思考</span></span><br><span class="line">        take_fork(i);            <span class="comment">// 去拿左边的叉子</span></span><br><span class="line">        take_fork((i + <span class="number">1</span>) % N);  <span class="comment">// 去拿右边的叉子</span></span><br><span class="line">        eat();                   <span class="comment">// 进餐</span></span><br><span class="line">        put_fork(i);             <span class="comment">// 放下左边的叉子</span></span><br><span class="line">        put_fork((i + <span class="number">1</span>) % N);   <span class="comment">// 放下右边的叉子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：不正确，可能导致死锁。对于 1 个哲学家没问题，但如果 5 个哲学家同时拿起了左边的叉子，大家都准备拿取右边的叉子，拿不到，出现死锁。</p>
<h3 id="稍作改进实现（错误）">稍作改进实现（错误）</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        think();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            take_fork(i);</span><br><span class="line">            <span class="keyword">if</span> (fork((i + <span class="number">1</span>) % N)) &#123;  <span class="comment">// 右边的叉子还在吗</span></span><br><span class="line">                take_fork((i + <span class="number">1</span>) % N);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                put_fork(i);       <span class="comment">// 放下左边的叉子</span></span><br><span class="line">                wait_some_time();  <span class="comment">// 等待一会儿</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        eat();</span><br><span class="line">        put_fork(i);</span><br><span class="line">        put_fork((i + <span class="number">1</span>) % N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：不正确，可能一直循环。大家同时拿起左边的叉子，又因为拿不到右边的叉子，又同时放下，如此循环。</p>
<h3 id="等待随机时间实现（可行）">等待随机时间实现（可行）</h3>
<p>将 <code>wait_some_time()</code> 替换为 <code>wait_random_time()</code>。可行，但由于时间随机，存在很多不确定性（如多次长时间等待，可能会出现饿死情况），不够完美。</p>
<h3 id="简单互斥访问实现（可行）">简单互斥访问实现（可行）</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;  <span class="comment">// 互斥信号量，初值为 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        think();</span><br><span class="line">        P(mutex);  <span class="comment">// 进入临界区</span></span><br><span class="line">        take_fork(i);</span><br><span class="line">        take_fork((i + <span class="number">1</span>) % N);</span><br><span class="line">        eat();</span><br><span class="line">        put_fork(i);</span><br><span class="line">        put_fork((i + <span class="number">1</span>) % N);</span><br><span class="line">        V(mutex);  <span class="comment">// 退出临界区</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：正确，但每次仅允许一个人进餐。虽然解决了死锁，但存在缺点：</p>
<ol>
<li>它将就餐（而不是叉子）看成是必须互斥访问的临界资源，由此造成了叉子资源的浪费；</li>
<li>从理论上讲，最多应允许 N%2 个不相邻的哲学家同时进餐。</li>
</ol>
<h2 id="正确实现">正确实现</h2>
<h3 id="思考">思考</h3>
<p>思路一：如果你是一个哲学家，你会怎么来解决这个问题？</p>
<p>指导原则：要么不拿，要么就拿两把叉子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S1: 思考中...</span><br><span class="line">S2: 进入饥饿状态</span><br><span class="line">S3: 如果左邻居或右邻居正在进餐，则等待，否则转向 S4</span><br><span class="line">S4: 拿起两把叉子</span><br><span class="line">S5: 进餐...</span><br><span class="line">S6: 放下左边的叉子</span><br><span class="line">S7: 放下右边的叉子</span><br><span class="line">S8: 新的循环又开始了，转向 S1</span><br></pre></td></tr></table></figure>
<p>思路二：计算机怎么解决这个问题？</p>
<p>指导原则：不能浪费 CPU 时间、进程间相互通信。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S1: 思考中...</span><br><span class="line">S2: 进入饥饿状态</span><br><span class="line">S3: 如果左邻居或右邻居正在进餐，进程进入阻塞状态，否则转向 S4</span><br><span class="line">S4: 拿起两把叉子</span><br><span class="line">S5: 进餐...</span><br><span class="line">S6: 放下左边的叉子，看看左邻居现在能否进餐（饥饿状态，两把叉子都在），若能则唤醒之</span><br><span class="line">S7: 放下右边的叉子，看看右邻居现在能否进餐（饥饿状态，两把叉子都在），若能则唤醒之</span><br><span class="line">S8: 新的循环又开始了，转向 S1</span><br></pre></td></tr></table></figure>
<p>思路三：你应该怎么编写程序？</p>
<ol>
<li>必须有数据结构：用于描述每个哲学家当前状态</li>
<li>该状态是一个临界资源，对它的访问应该是互斥地进行</li>
<li>一个哲学家吃饱后，可能要唤醒邻居，存在同步关系</li>
</ol>
<blockquote>
<p>这里我们将「哲学家」看做了互斥访问的资源，而不像上面错误的实现中是将「叉子」看做了互斥访问的资源。</p>
</blockquote>
<h3 id="实现（可运行）">实现（可运行）</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N (5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT(i) (((i) + N - 1) % N)  <span class="comment">// 左邻居</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT(i) (((i) + 1) % N)     <span class="comment">// 右邻居</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EAT_MAX_NR (10)  <span class="comment">// 每个哲学家允许的最大进餐次数，控制线程退出</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">philo_state</span> &#123;</span> THINKING = <span class="number">0</span>, HUNGARY, EATING &#125; philo_state_en;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> sem_mutex;      <span class="comment">// 互斥信号量，初值为 1</span></span><br><span class="line"><span class="type">int</span> state[N];         <span class="comment">// 哲学家状态</span></span><br><span class="line"><span class="type">sem_t</span> sem_sync[N];    <span class="comment">// 同步信号量，初值为 0</span></span><br><span class="line"><span class="type">pthread_t</span> thread[N];  <span class="comment">// 哲学家对应的线程</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> eatNr[N];  <span class="comment">// 哲学家进餐次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 哲学家思考，随机思考一段时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">think</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;philo-%d, think start at %ld\r\n&quot;</span>, i, clock());</span><br><span class="line">    sleep(<span class="number">1</span> + rand() % <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;philo-%d, think end at %ld\r\n&quot;</span>, i, clock());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 哲学家就餐，吃一会儿 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eat</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;philo-%d, eat start at %ld\r\n&quot;</span>, i, clock());</span><br><span class="line">    sleep(<span class="number">1</span> + rand() % <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;philo-%d, eat end at %ld\r\n&quot;</span>, i, clock());</span><br><span class="line">    eatNr[i]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检查当前哲学家是否可以进餐 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_take_lr_forks</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (state[i] == HUNGARY &amp;&amp; state[LEFT(i)] != EATING &amp;&amp; state[RIGHT(i)] != EATING) &#123;</span><br><span class="line">        state[i] = EATING;</span><br><span class="line">        <span class="comment">// 若能拿到叉子，执行 V 操作，后续就不会阻塞</span></span><br><span class="line">        sem_post(&amp;sem_sync[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 尝试拿叉子（不一定能达到） */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">take_forks</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    sem_wait(&amp;sem_mutex);</span><br><span class="line">    state[i] = HUNGARY;</span><br><span class="line">    test_take_lr_forks(i);</span><br><span class="line">    sem_post(&amp;sem_mutex);</span><br><span class="line">    <span class="comment">// 如果没拿到叉子，就会在这里阻塞，如果拿到了叉子，这里不会阻塞</span></span><br><span class="line">    sem_wait(&amp;sem_sync[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 就餐完毕，尝试唤醒邻居就餐 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">put_forks</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    sem_wait(&amp;sem_mutex);</span><br><span class="line">    state[i] = THINKING;</span><br><span class="line">    test_take_lr_forks(LEFT(i));</span><br><span class="line">    test_take_lr_forks(RIGHT(i));</span><br><span class="line">    sem_post(&amp;sem_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 哲学家线程：思考 - 拿叉子 - 就餐 - 放叉子 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread #%lu, phiol-%d in place\r\n&quot;</span>, pthread_self(), i);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        think(i);</span><br><span class="line">        take_forks(i);</span><br><span class="line">        eat(i);</span><br><span class="line">        put_forks(i);</span><br><span class="line">        <span class="keyword">if</span> (eatNr[i] &gt;= EAT_MAX_NR) &#123;  <span class="comment">// 控制线程退出</span></span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="comment">/* 初始化 */</span></span><br><span class="line">    sem_init(&amp;sem_mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        state[i] = THINKING;</span><br><span class="line">        eatNr[i] = <span class="number">0</span>;</span><br><span class="line">        sem_init(&amp;sem_sync[i], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建线程，并绑定线程函数 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        pthread_create(&amp;thread[i], <span class="literal">NULL</span>, (<span class="type">void</span>* (*)(<span class="type">void</span>*))philosopher, (<span class="type">void</span>*)(<span class="type">uintptr_t</span>)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待线程结束 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        pthread_join(thread[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 销毁信号量 */</span></span><br><span class="line">    sem_destroy(&amp;sem_mutex);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        sem_destroy(&amp;sem_sync[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结果分析">结果分析</h3>
<p>持续打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread #140511761397312, phiol-0 in place</span><br><span class="line">philo-0, think start at 1572</span><br><span class="line">Thread #140511753004608, phiol-1 in place</span><br><span class="line">philo-1, think start at 1621</span><br><span class="line">Thread #140511727826496, phiol-4 in place</span><br><span class="line">philo-4, think start at 1754</span><br><span class="line">Thread #140511744611904, phiol-2 in place</span><br><span class="line">philo-2, think start at 1791</span><br><span class="line">Thread #140511736219200, phiol-3 in place</span><br><span class="line">philo-3, think start at 2068</span><br><span class="line">philo-2, think end at 2092</span><br><span class="line">philo-2, eat start at 2111</span><br><span class="line">philo-1, think end at 2131</span><br><span class="line">philo-2, eat end at 2164</span><br><span class="line">philo-2, think start at 2184</span><br><span class="line">philo-1, eat start at 2194</span><br><span class="line">philo-4, think end at 2219</span><br><span class="line">philo-4, eat start at 2245</span><br><span class="line">philo-0, think end at 2280</span><br><span class="line">philo-3, think end at 2332</span><br><span class="line">philo-2, think end at 2366</span><br><span class="line">philo-1, eat end at 2423</span><br><span class="line">philo-1, think start at 2472</span><br><span class="line">philo-2, eat start at 2513</span><br><span class="line">philo-1, think end at 2561</span><br><span class="line">philo-4, eat end at 2602</span><br><span class="line">philo-4, think start at 2626</span><br><span class="line">philo-0, eat start at 2657</span><br><span class="line">philo-2, eat end at 2699</span><br><span class="line">philo-2, think start at 2719</span><br><span class="line">philo-3, eat start at 2750</span><br><span class="line">philo-0, eat end at 2795</span><br><span class="line">philo-0, think start at 2841</span><br><span class="line">philo-1, eat start at 2882</span><br><span class="line">philo-1, eat end at 2942</span><br><span class="line">philo-1, think start at 2977</span><br><span class="line">philo-4, think end at 3003</span><br><span class="line">philo-0, think end at 3038</span><br><span class="line">philo-0, eat start at 3053</span><br><span class="line">philo-1, think end at 3072</span><br><span class="line">philo-3, eat end at 3100</span><br><span class="line">philo-3, think start at 3114</span><br><span class="line">philo-2, think end at 3140</span><br><span class="line">philo-2, eat start at 3157</span><br><span class="line">philo-0, eat end at 3184</span><br><span class="line">philo-0, think start at 3222</span><br><span class="line">philo-4, eat start at 3258</span><br></pre></td></tr></table></figure>
<p>从上面的打印可以看出：每个哲学家都在思考、进餐，而且保证了同时最多只有 5%2 个哲学家在同时进餐，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2: 2111-2164  // 2 进餐</span><br><span class="line">1: 2194-2423  // 1 进餐</span><br><span class="line">4: 2245-2602  // 4,1 同时进餐</span><br><span class="line">2: 2513-2699  // 2,4 同时进餐</span><br><span class="line">0: 2657-2795  // 0,2 同时进餐</span><br><span class="line">3: 2750-3100  // 3,0 同时进餐</span><br><span class="line">1: 2882-2942  // 1,3 同时进餐</span><br><span class="line">0: 3053-3184  // 0,3 同时进餐（哲学家 3 吃的有点久啊~）</span><br></pre></td></tr></table></figure>
<p>最后，当每个哲学家进餐达到 10 次后，其线程终止，等全部退出后，销毁信号量，程序结束。</p>
<blockquote>
<p>参考资料：<br>
1：<a href="https://blog.csdn.net/weixin_53407527/article/details/125207305">https://blog.csdn.net/weixin_53407527/article/details/125207305</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>经典同步问题</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>读者写者问题</tag>
        <tag>经典同步问题</tag>
        <tag>哲学家就餐问题</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之 chapter9 同步与互斥</title>
    <url>/posts/240104202828.html</url>
    <content><![CDATA[<p>本文介绍同步与互斥，主要包括相关背景，竞态条件、原子操作、临界区 &amp; 互斥 &amp; 死锁 &amp; 饥饿等相关概念，临界区的属性以及如何实现临界区的互斥访问等。</p>
<span id="more"></span>
<h1 id="背景">背景</h1>
<p>第一章到第八章内容，到目前为止：</p>
<ul>
<li>多道程序设计：现代操作系统的重要特性。</li>
<li>并行很有用（为什么？）提示——多个并发实体：CPU、I/O、用户等。</li>
<li>进程 &amp; 线程：操作系统抽象出来用于支持多道程序设计。</li>
<li>CPU 调度：实现多道程序设计的机制。</li>
<li>调度算法：选择进程 &amp; 线程不同的策略。</li>
</ul>
<p><strong>独立线程</strong>：</p>
<ul>
<li>不和其它线程共享资源或状态；</li>
<li>确定性：输入状态决定结果；</li>
<li>可重现：能够重现起始条件、I/O；</li>
<li>调度顺序不重要。</li>
</ul>
<p><strong>合作线程</strong>：</p>
<ul>
<li>在多个线程中共享状态；</li>
<li>不确定性；</li>
<li>不可重现；</li>
</ul>
<p>不确定性和不可重现意味着 BUG 可能是间歇性发生的。</p>
<p>虽然如此，但进程 &amp; 线程、计算机、设备需要合作。</p>
<p><strong>合作的优点</strong>：</p>
<ol>
<li>共享资源：
<ul>
<li>一台电脑，多个用户；</li>
<li>一个银行存款余额，多台 ATM 机；</li>
<li>嵌入式系统（机器人控制：手臂和手的协调）。</li>
</ul>
</li>
<li>加速：
<ul>
<li>I/O 操作和计算可以重叠；</li>
<li>多处理器：将程序分成多个部分并行执行。</li>
</ul>
</li>
<li>模块化：
<ul>
<li>将大程序分解成小程序——以编译为例，gcc 会调用 cpp, cc1, cc2, as, ld；</li>
<li>使系统易于扩展。</li>
</ul>
</li>
</ol>
<p><strong>程序调用 <code>fork()</code> 创建新进程的过程</strong>：</p>
<ul>
<li>操作系统需要分配新的进程 ID，并保证其唯一性。</li>
<li>在内核中，<code>fork()</code>系统调用会运行 <code>new_pid = next_pid++</code>：
<ul>
<li><code>LOAD next_pid Reg1</code></li>
<li><code>STORE Reg1 new_pid</code> ——&gt; 假设发生了上下文切换，转去执行另一个程序的 <code>fork()</code> 操作</li>
<li><code>INC Reg1</code></li>
<li><code>STORE Reg1 next_pid</code></li>
</ul>
</li>
<li>假设有两个进程并发执行该过程：
<ul>
<li>正常情况下，如果 <code>next_pid</code> 的值为 <code>100</code>，那么其中一个进程将获得<code>new_pid=100</code> 的新进程 ID，另一个进程将获得 <code>new_pid=101</code> 的新进程 ID，同时 <code>next_pid</code> 的值将增加到<code>102</code>。</li>
<li><strong>但是，由于可能在自增操作之前发生了上下文切换 </strong>，最终导致两个进程都获得了<code>new_pid=100</code> 的新进程 ID，而 <code>next_pid</code> 的值也变成了<code>101</code>。</li>
</ul>
</li>
</ul>
<p>多线程程序具有不确定性和不可重现的特点，但 <strong> 无论多个线程的指令序列怎么交替执行，程序都必须正常工作</strong>。</p>
<p>因此，我们必须要有一些新的机制来保证能够 <strong> 达到最终确定的结果</strong>，后面会引入同步互斥机制来解决这种不确定性的问题。</p>
<h1 id="一些概念">一些概念</h1>
<h2 id="竞态条件（Race-Condition）">竞态条件（Race Condition）</h2>
<p>竞态条件是指在多个线程或进程并发执行的情况下，<strong>对共享资源的访问顺序不确定</strong>，从而导致程序的行为出现不可预测的结果。</p>
<ul>
<li>系统缺陷：结果依赖于并发执行（或者时间）的顺序、时间。
<ul>
<li>不确定性</li>
<li>不可重现</li>
</ul>
</li>
<li>怎么样避免竞态？</li>
</ul>
<h2 id="原子操作（Atomic-Operator）">原子操作（Atomic Operator）</h2>
<p>原子操作是指在并发环境下，<strong>不能被中断的一系列操作，要么全部执行成功，要么全部不执行</strong>。原子操作能够保证在多线程或多进程同时访问共享资源时的数据一致性。</p>
<p>原子操作的特点包括：</p>
<ol>
<li>不可中断性：原子操作在执行期间不能被其他线程或进程中断，保证了操作的完整性。</li>
<li>互斥性：原子操作在同一时间只能被一个线程或进程执行，避免了竞态条件的发生。</li>
<li>原子性：原子操作要么全部执行成功，要么全部不执行，不会出现部分执行的情况。</li>
</ol>
<blockquote>
<p>原子操作通常是由硬件提供的特殊指令或者操作系统提供的原子操作函数来实现的。</p>
</blockquote>
<p>实际上的操作往往不是原子的：</p>
<ul>
<li>有些看上去是原子操作，实际上不是；</li>
<li>连 <code>i++</code> 这样的简单语句，实际上是由三条指令构成的。</li>
</ul>
<h2 id="临界区 - 互斥 - 死锁 - 饥饿">临界区 &amp; 互斥 &amp; 死锁 &amp; 饥饿</h2>
<p><strong>临界区</strong>（Critical Section）是指进程中的一段需要访问共享资源，并且当另一个进程处于相应代码区域时便不会被执行的代码区域。</p>
<p><strong>互斥</strong>（Mutual Exclusion）是指当一个进程处于临界区并访问共享资源时，没有其他进程会处于临界区并访问任何相同的共享资源。</p>
<p><strong>死锁</strong>（Dead Lock）是指两个或以上进程，在相互等待完成特定任务，而最终没法将自身任务进行下去，形成循环等待。</p>
<p><strong>饥饿</strong>（Starvation）是指一个可执行的进程，被调度器持续忽略，以至于虽然处于可执行状态却不能被执行。</p>
<h1 id="临界区（Critical-Section）">临界区（Critical Section）</h1>
<h2 id="临界区的属性">临界区的属性</h2>
<p>要设计实现临界区，临界区必须满足以下属性：</p>
<ul>
<li><strong>互斥</strong>：同一时间临界区中最多存在一个线程。</li>
<li><strong>前进</strong>（Progress）：如果一个线程想要进入临界区，那么它最终会成功。</li>
<li><strong>有限等待</strong>：如果一个线程 <code>thread</code> 处于入口区，那么在 <code>thread</code> 的请求被接受前，其它线程进入临界区的时间是有限制的（否则线程 <code>thread</code> 可能会饥饿）。</li>
<li><strong>无忙等待</strong>（可选）：如果一个进程在等待进入临界区，那么在它可以进入之前会被挂起。</li>
</ul>
<h2 id="临界区的实现方法">临界区的实现方法</h2>
<p>实现临界区的互斥访问的方法：</p>
<ul>
<li>禁用硬件中断；</li>
<li>基于软件方法；</li>
<li>更高级的抽象方法。</li>
</ul>
<h1 id="禁用硬件中断（方法一）">禁用硬件中断（方法一）</h1>
<p>中断是指在程序执行过程中，由硬件或软件触发的一种特殊事件，<strong>它会打断当前正在执行的程序</strong>，并跳转到预定义的中断处理程序中执行。</p>
<p>上面说，中断会打断当前正在执行的程序，也正是因为这个中断，才导致了进程 / 线程的上下文切换——执行其它进程 / 线程。如果没有这个中断，是不是就可以让一个进程 / 线程顺利地执行完临界区代码呢？是的！</p>
<h2 id="方法">方法</h2>
<p>禁用硬件中断，实现临界区的互斥访问：</p>
<ul>
<li>没有中断机制，也就没有上下文切换，因此没有并发。
<ul>
<li>硬件将中断处理 延迟到 中断被启用之后。</li>
<li>大多数现代计算机体系结构都提供指令来完成这一操作。</li>
</ul>
</li>
<li>进入临界区：禁用中断。</li>
<li>离开临界区：启用中断。</li>
</ul>
<h2 id="特点">特点</h2>
<p>禁用硬件中断确实可以解决多个进程 / 线程同时访问临界区共享资源，但它有一些缺点：</p>
<ul>
<li>一旦中断被禁用，线程就无法被停止：
<ul>
<li>整个系统都会为你停下来！</li>
<li>可能导致其它线程处于饥饿状态！</li>
</ul>
</li>
<li>要是临界区可以任意长，会怎么样？
<ul>
<li>将无法限制响应中断所需的时间（可能存在硬件影响，如如无法及时响应网卡中断、输入设备中断）。</li>
</ul>
</li>
<li>要小心使用：
<ul>
<li>适用于临界区很小的情况。</li>
</ul>
</li>
<li>在多 CPU 的情况下，禁用硬件中断无法解决互斥问题：
<ul>
<li>每个 CPU 都有自己的中断控制器，禁用一个 CPU 的中断不会影响在其它 CPU 上的进程 / 线程产生中断，因此无法实现对临界区的互斥控制。</li>
</ul>
</li>
</ul>
<h1 id="基于软件的解决方案（方法二）">基于软件的解决方案（方法二）</h1>
<p>对于两个线程 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_{0}, T_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的临界区的互斥访问：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* T_i 的通常结构 */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">/* enter section, 进入区域 */</span></span><br><span class="line">        <span class="comment">/* critical section, 临界区域 */</span></span><br><span class="line">    <span class="comment">/* exit section, 离开区域 */</span></span><br><span class="line">        <span class="comment">/* reminder section, 提醒区域 */</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h2 id="单标志法（失败）">单标志法（失败）</h2>
<p>使用一个共享变量 <code>turn</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 声明并初始化共享变量 */</span></span><br><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Thread T_i (i = 0, j = 1) */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">/* enter section */</span></span><br><span class="line">    <span class="keyword">while</span> (turn != i);</span><br><span class="line">        <span class="comment">/* critical section */</span></span><br><span class="line">    <span class="comment">/* exit section */</span></span><br><span class="line">    turn = j;</span><br><span class="line">    <span class="comment">/* reminder section */</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>代码分析：</p>
<ul>
<li>该代码尝试实现 <strong> 两个 </strong> 线程对临界区的互斥访问；</li>
<li>该代码中 <code>turn</code> 的值只能是 <code>0/1</code>——线程 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub><mi mathvariant="normal">/</mi><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_{0}/T_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 会在执行完临界区代码后，将 <code>turn</code> 设置为 <code>1/0</code>；</li>
<li>如果 <code>turn</code> 的值不是自己（<code>while (turn != i)</code>），则会一直忙等待，等待另一个线程将 <code>turn</code> 值设置为它的对方（<code>turn=j</code>）。</li>
</ul>
<p>存在的问题（是否满足临界区属性）：</p>
<ul>
<li><strong>满足互斥访问，但有时不满足前进</strong>（满足「忙则等待」，但不满足「空闲则入」）：如果线程 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">T_{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 在访问了一次临界区后（此时 <code>turn=1</code>），下次能访问临界区的只能是线程 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 一直不访问临界区（不去设置 <code>turn=0</code>），那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">T_{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 便无法再次访问临界区。</li>
</ul>
<p>因此，该设计满足互斥访问，但 <strong> 只能在两个进程交替的访问临界区 </strong> 的情况下满足前进。</p>
<h2 id="双标志先检查（失败）">双标志先检查（失败）</h2>
<p>使用一个共享数组变量 <code>flag[2]</code>，先检查是否可以进入临界区：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 声明并初始化共享变量 */</span></span><br><span class="line"><span class="type">int</span> flag[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Thread T_i (i = 0, j = 1) */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">/* enter section */</span></span><br><span class="line">    <span class="keyword">while</span> (flag[j] == <span class="number">1</span>);</span><br><span class="line">    flag[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* critical section */</span></span><br><span class="line">    <span class="comment">/* exit section */</span></span><br><span class="line">    flag[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* reminder section */</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>代码分析：</p>
<ul>
<li>该代码尝试实现 <strong> 两个 </strong> 线程对临界区的互斥访问；</li>
<li>该代码中 <code>flag[]</code> 数组的每个位置值只能是 <code>0/1</code>——线程 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 会在执行临界区代码前（后），将 <code>flag[i]</code> 的标志设置为 <code>1</code>（<code>0</code>）；</li>
<li>进入临界区前，如果对方的标志是真，则会一直忙等待，等待另一个线程将它的标志设置为假。</li>
</ul>
<p>存在的问题（是否满足临界区属性）：</p>
<ul>
<li><strong>不满足互斥访问</strong>（不满足「忙则等待」）：初始化时，两个线程的 <code>flag</code> 都被置为 <code>0</code>；然后向下执行 <code>while</code>，都会发现对方的 <code>flag</code> 不为 <code>1</code>，则会进入临界区，无法实现对临界区的互斥访问。</li>
</ul>
<h2 id="双标志后检查（失败）">双标志后检查（失败）</h2>
<p>使用一个共享数组变量 <code>flag[2]</code>，先置位标志，后检查是否可以进入临界区：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 声明并初始化共享变量 */</span></span><br><span class="line"><span class="type">int</span> flag[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Thread T_i (i = 0, j = 1) */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">/* enter section */</span></span><br><span class="line">    flag[i] = <span class="number">1</span>;  <span class="comment">// 先置位标志</span></span><br><span class="line">    <span class="keyword">while</span> (flag[j] == <span class="number">1</span>);</span><br><span class="line">        <span class="comment">/* critical section */</span></span><br><span class="line">    <span class="comment">/* exit section */</span></span><br><span class="line">    flag[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* reminder section */</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>代码分析：</p>
<ul>
<li>该代码尝试实现 <strong> 两个 </strong> 线程对临界区的互斥访问；</li>
<li>该代码中 <code>flag[]</code> 数组的每个位置值只能是 <code>0/1</code>——线程 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 会在 enter section 前将 <code>flag[i]</code> 的标志设置为 <code>1</code>、在执行完 critical section 代码后，将 <code>flag[i]</code> 的标志设置为 <code>0</code>；</li>
<li><strong>先置位标志，后尝试进入临界区</strong>：如果对方的标志是真，则会一直忙等待，等待另一个线程将它的标志设置为假。</li>
</ul>
<p>存在的问题（是否满足临界区属性）：</p>
<ul>
<li><strong>满足互斥访问，但存在死锁 </strong>（满足「忙则等待」，但不满足「空闲则入」）：初始化时，两个线程的 <code>flag</code> 都被置为 <code>0</code>，并向下执行。当线程 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">T_{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 将其 <code>flag[0]</code> 设置为 <code>1</code> 后，发生了上下文切换；然后，线程 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 也会将其 <code>flag[1]</code> 设置为 <code>1</code>；至此，不管哪个线程执行 enter section 代码，都会等待，从而发生死锁。</li>
</ul>
<h2 id="Peterson 算法（成功）">Peterson 算法（成功）</h2>
<p>算法思想：在双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。而 Peterson 算法，在双方都争着想进入临界区时，让进程尝试“孔融让梨”，主动让对方先使用临界区。</p>
<p>Peterson 算法是满足进程 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">T_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 之间互斥的经典的基于软件的解决方法（1981 年）。</p>
<p>它使用两个共享数据项（Use two shared data items）：</p>
<ul>
<li><code>int turn</code> 指示该谁进入临界区</li>
<li><code>bool flag[]</code> 指示进程是否准备好进入临界区</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 声明并初始化共享变量 */</span></span><br><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>] = &#123;<span class="literal">false</span>, <span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Thread T_i (i = 0, j = 1) */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">/* enter section */</span></span><br><span class="line">    flag[i] = <span class="literal">true</span>;  <span class="comment">// 我想进入临界区</span></span><br><span class="line">    turn = j;  <span class="comment">// 孔融让梨</span></span><br><span class="line">    <span class="keyword">while</span> (flag[j] &amp;&amp; turn == j);</span><br><span class="line">        <span class="comment">/* critical section */</span></span><br><span class="line">    <span class="comment">/* exit section */</span></span><br><span class="line">    flag[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/* reminder section */</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>代码分析：</p>
<ul>
<li>该代码尝试实现 <strong> 两个 </strong> 线程对临界区的互斥访问；</li>
<li>如果自己想进入临界区，便将标志置为真 <code>flag[i] = true</code>、并谦让着让对方先进入 <code>turn=j</code>，然后自己做好忙等待的心理准备——但是会检查两个共享数据项，如果对方想进入临界区（<code>flag[j] == true</code>），这时自己便忙等待；否则，自己可以成功进入临界区。</li>
</ul>
<p>可以证明（用反证法），Peterson 算法能够满足互斥、前进、有限等待三种特性。</p>
<h2 id="Dekker 算法（成功）">Dekker 算法（成功）</h2>
<p>Dekker 算法是第一个针对双线程的基于软件的解决方法（1965 年）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 声明并初始化共享变量 */</span></span><br><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>] = &#123;<span class="literal">false</span>, <span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Thread T_i (i = 0, j = 1) */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">/* enter section */</span></span><br><span class="line">    flag[i] = <span class="literal">true</span>;  <span class="comment">// 我想进入临界区</span></span><br><span class="line">    <span class="keyword">while</span> (flag[j] == <span class="literal">true</span>) &#123;  <span class="comment">// 对方想进入临界区</span></span><br><span class="line">        <span class="keyword">if</span> (turn != i) &#123;  <span class="comment">// 没有轮到我</span></span><br><span class="line">            flag[i] = flase;  <span class="comment">// 孔融让梨，放弃进入临界区</span></span><br><span class="line">            <span class="keyword">while</span> (turn != i); <span class="comment">// 等待，直到把资格给到自己</span></span><br><span class="line">            flag[i] = <span class="literal">true</span>;  <span class="comment">// 你退出我则示意想要进入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">/* critical section */</span></span><br><span class="line">    <span class="comment">/* exit section */</span></span><br><span class="line">    turn = j;  <span class="comment">// 轮到你了</span></span><br><span class="line">    flag[i] = <span class="literal">false</span>;  <span class="comment">// 我不想进入临界区了</span></span><br><span class="line">    <span class="comment">/* reminder section */</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>代码分析：</p>
<ul>
<li>该代码尝试实现 <strong> 两个 </strong> 线程对临界区的互斥访问；</li>
<li><code>flag</code> 为真，表示想进入临界区（只是想，不代表能进入）；<code>turn</code> 为自己，表示自己可以进入临界区（对方不可以）；</li>
<li>假设只有 <code>flag[]</code> 共享变量：那就像「双标志后检查」一样，会发生死锁；<code>turn</code> 的使用，解决了死锁的问题。</li>
</ul>
<p>可以证明，Dekker 算法能够满足互斥、前进、有限等待三种特性。</p>
<h2 id="Eisenberg-and-McGuire 算法（N 进程）">Eisenberg and McGuire 算法（N 进程）</h2>
<p>有机会再补充。</p>
<h2 id="Bakery 算法（N 进程）">Bakery 算法（N 进程）</h2>
<p>解决 N 个进程的临界区互斥访问：</p>
<ul>
<li>进入临界区之前，进程接收一个数字，得到的数字最小的进入临界区；</li>
<li>如果进程 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">P_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 收到相同的数字，那么如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i &lt; j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 先进入临界区，否则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">P_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 先进入临界区；</li>
<li>编号方案总是按照枚举的增加顺序生成数字。</li>
</ul>
<h2 id="总结">总结</h2>
<p>这些算法有以下特点：</p>
<ul>
<li>复杂：需要两个进程的共享数据项；</li>
<li>需要忙等待：浪费 CPU 时间；</li>
<li>没有硬件保证的情况下，无真正的软件解决方案。
<ul>
<li>Peterson 算法需要原子的 <code>LOAD</code> 和<code>STORE</code>指令。</li>
</ul>
</li>
</ul>
<h1 id="更高级的抽象（方法三）">更高级的抽象（方法三）</h1>
<h2 id="一些解决方案">一些解决方案</h2>
<p>硬件提供一些原语：</p>
<ul>
<li>像中断禁用、原子操作指令等（大多数现代体系结构都这样）。</li>
</ul>
<p>操作系统提供更高级的编程抽象来简化并行编程：</p>
<ul>
<li>例如，锁、信号量；</li>
<li>从硬件原语中构建。</li>
</ul>
<p>锁是一个抽象数据结构，用于控制并发访问共享资源的机制：</p>
<ul>
<li>它具有一个二进制状态：锁定（locked）和解锁（unlocked）；</li>
<li>两种方法：
<ul>
<li><code>Lock::Acquire()</code>：锁被释放前一直等待，然后得到锁；</li>
<li><code>Lock::Release()</code>：锁释放，唤醒任何等待的进程。</li>
</ul>
</li>
</ul>
<p>使用锁来编写临界区：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">lock_next_pid-&gt;<span class="built_in">Acquire</span>();</span><br><span class="line">new_pid = next_pid++;</span><br><span class="line">lock_next_pid-&gt;<span class="built_in">Release</span>();</span><br></pre></td></tr></table></figure>
<p>前面（背景小节）的例子变得简单起来，<code>lock_next_pid-&gt;Acquire()</code> 加锁后，临界区中的代码 <code>next_pid++</code>，在同一时间（从读、执行加一再到写回内存），只有一个进程对其操作，确保对 <code>next_pid</code> 的操作是原子的。</p>
<p>大多数现代体系结构都提供特殊的原子操作指令：</p>
<ul>
<li>通过特殊的内存访问电路；</li>
<li>针对单处理器和多处理器。</li>
</ul>
<h2 id="Test-And-Set 指令">Test-And-Set 指令</h2>
<p><strong>测试和置位（Test-And-Set, TAS）指令 </strong> 把给定的内存地址设置为 1，然后返回之前的旧值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">TestAndSet</span><span class="params">(<span class="type">bool</span> *target)</span> &#123;</span><br><span class="line">    <span class="type">bool</span> rv = *target;</span><br><span class="line">    *target = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>还有一个 Compare And Swap (CAS) 指令。</p>
</blockquote>
<h2 id="Exchange 指令">Exchange 指令</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Exchange</span><span class="params">(<span class="type">bool</span> *<span class="type">bool</span> *b)</span> &#123;</span><br><span class="line">    <span class="type">bool</span> tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Test-And-Set 和 Exchange 在硬件上实现为一个原子操作，执行期间不会被其他处理器打断。</p>
</blockquote>
<h2 id="基于 TAS 指令实现自旋锁（spinlock）">基于 TAS 指令实现自旋锁（spinlock）</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Lock::<span class="built_in">Acquire</span>() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">TestAndSet</span>(value)) &#123;</span><br><span class="line">        ; <span class="comment">// spin 自旋锁，忙等待</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Lock::<span class="built_in">Release</span>() &#123;</span><br><span class="line">    value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Lock::Acquire()</code> 代码分析：</p>
<ul>
<li>如果锁被释放，那么 TAS 指令读取 0 并将值设置为 1（即锁被设置为忙，并且需要等待完成）；</li>
<li>如果锁处于忙等待，那么 TAS 指令读取 1 并将值设置为 1（即不改变锁的状态，并且需要循环 TAS 指令）。</li>
</ul>
<blockquote>
<p>上面方法，线程在等待的时候是忙等待，消耗 CPU 时间，自旋锁采用这种设计（因为它适用于持有锁的时间很短的情况下）。</p>
</blockquote>
<h2 id="无忙等待锁">无忙等待锁</h2>
<p>无忙等待锁，使处于忙等的进程睡眠，在临界区执行完的进程会将睡眠的进程唤醒。</p>
<img src="../images/os-kernel/chapter9/with-or-without-busy-waiting.png" alt="有无忙等待" width="80%" height="80%">
<p>如果临界区执行时间短，选择忙等方式（如自旋锁）；如果临界区执行时间长，选择无忙等待方式（如互斥锁、信号量、条件变量）。</p>
<h2 id="基于 Exchange 指令实现自旋锁（spinlock）">基于 Exchange 指令实现自旋锁（spinlock）</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 声明并初始化共享变量 */</span></span><br><span class="line"><span class="type">int</span> lock = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Thread T_i (i = 0, j = 1) */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">/* enter section */</span></span><br><span class="line">    key = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (key == <span class="number">1</span>) &#123;</span><br><span class="line">        Exchange(lock, key);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">/* critical section */</span></span><br><span class="line">    <span class="comment">/* exit section */</span></span><br><span class="line">    lock = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* reminder section */</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>代码分析：</p>
<ul>
<li>当 <code>key==1, lock==1</code> 时，交换两数后，不会影响两数的值，即无法退出循环、无法获取锁；</li>
<li>当 <code>key==1, lock==0</code> 时，交换两数后，有 <code>key==0, lock==1</code>，即立即获取锁、退出循环。</li>
</ul>
<h2 id="原子操作的特征">原子操作的特征</h2>
<p>优点：</p>
<ul>
<li>适用于单处理器或者共享主存的多处理器中 <strong> 任意数量的进程同步</strong>；</li>
<li>简单并且容易证明；</li>
<li>支持多临界区。</li>
</ul>
<p>缺点：</p>
<ul>
<li>忙等待消耗处理器时间；</li>
<li>可能导致饥饿（如进程离开临界区时，有多个等待进程的情况）；</li>
<li><strong>死锁</strong>：拥有临界区的低优先级进程，遇到上下文中断，高优先级进程获得处理器，并请求访问临界区，这时会忙等待，高优先级进程向进入临界区，低优先级进程由于无法占用处理器，导致无法退出临界区（解决方案：优先级反转）。</li>
</ul>
<h1 id="总结 -v2">总结</h1>
<p>锁是更高等级的编程抽象：</p>
<ul>
<li>互斥可以使用锁来实现</li>
<li>通常需要一定等级的硬件支持（比如原子操作指令）</li>
</ul>
<p>常用的三种实现方法：</p>
<ul>
<li>禁用中断（仅限于单处理器）</li>
<li>软件方法（复杂）</li>
<li>原子操作指令（单处理器或多处理器均可）</li>
</ul>
<p>可选的实现内容:</p>
<ul>
<li>有忙等待</li>
<li>无忙等待</li>
</ul>
<blockquote>
<p>参考资料：<br>
1：<a href="https://github.com/OXygenMoon/OperatingSystemInDepth">https://github.com/OXygenMoon/OperatingSystemInDepth</a><br>
2：<a href="https://blog.csdn.net/weixin_53407527/article/details/125088864">https://blog.csdn.net/weixin_53407527/article/details/125088864</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>同步与互斥</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>同步与互斥</tag>
        <tag>临界区</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之二叉搜索树</title>
    <url>/posts/231020174358.html</url>
    <content><![CDATA[<p>二叉搜索树（Binary Search Tree，BST）是一种常见的数据结构，它具有以下特点：</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值。</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值。</li>
<li>它的左、右子树也分别为二叉搜索树。</li>
</ul>
<p>由于 BST 的特点，二叉搜索树的查找、插入和删除效率都很高（BST 足够「平衡」情况下）。</p>
<span id="more"></span>
<h2 id="二叉搜索树操作">二叉搜索树操作</h2>
<p>二叉搜索树是什么样子的呢？百闻不如一见，直接上图：</p>
<p><img src="../images/data-structure/BST-Tree1.png" alt=""></p>
<h2 id="插入一个节点">插入一个节点</h2>
<p>如果我们插入一个节点，它的值为 9，我们应该插在哪里呢？看图~</p>
<p><img src="../images/data-structure/BST-Tree2.png" alt=""></p>
<p>我们插入值 9 的过程大概是这样的：</p>
<ol>
<li>9 &gt; 根节点 7 吗？大于，则转向看右子树；</li>
<li>9 &gt; 根节点 10 吗？小于，则转向看左子树；</li>
<li>左子树为空，则将 9 插入在这里。</li>
</ol>
<p>看看，这是不是跟有序数组的二分查找算法的思想一样呢，根据值的大小关系，决定下次搜索的区域（但 BST 的判断不一定每次都会排除 50% 的区域，这要看 BST 是否足够「平衡」）！</p>
<h2 id="搜索一个节点">搜索一个节点</h2>
<p><img src="../images/data-structure/BST-Searching.png" alt=""></p>
<p>搜索一个节点的过程跟上面插入一个节点的过程类似：</p>
<ol>
<li>5 == 根节点 7 吗？不等于；大于吗？小于，则转向左子树搜索；</li>
<li>5 == 根节点 2 吗？不等于；大于吗？大于，则转向右子树搜索；</li>
<li>5 == 根节点 5 吗？等于，搜索成功。</li>
</ol>
<h2 id="遍历二叉搜索树">遍历二叉搜索树</h2>
<p>我们知道，二叉树的遍历有前序遍历、中序遍历和后续遍历以及层序遍历。它们有不同的特点：</p>
<ul>
<li>前序遍历：先遍历根节点，再遍历左右子树；</li>
<li>中序遍历：先遍历左子树，中间遍历根节点，最后遍历右子树；</li>
<li>后续遍历：先遍历左子树和右子树，最后遍历根节点；</li>
<li>层序遍历：从上到下、从左到右，按层遍历二叉树中的每一个节点。</li>
</ul>
<p>结合二叉搜索树的特点：左子树上所有结点的值均小于它的根结点的值 &amp; 右子树上所有结点的值均大于它的根结点的值。设想一下，如果我们先获取左子树的值，再获取根节点的值，最后再获取右子树的值，并将它们按获取顺序保存到数组中，那么这个数组是不是按升序排序的数组呢？</p>
<p>没错，<strong>二叉搜索树的中序遍历的结果是一个按升序排序的有序数组</strong>，所以二叉搜索树又称二叉排序树。</p>
<p>二叉搜索树的中序遍历过程图。<br>
<img src="../images/data-structure/BST-in-order-traversing.png" alt=""></p>
<h2 id="删除一个节点">删除一个节点</h2>
<p>删除节点也很容易，根据二叉搜索树的特点，我们删除一个节点后，只需要将这个节点的左子树的最大值（或者是右子树的最小值）拿过来，放到这个被删除的节点这里即可。这样，删除一个节点后，这棵树依然是一棵二叉搜索树。</p>
<p><img src="../images/data-structure/BST-delete-node.png" alt=""></p>
<p>上图的 BST 删除一个节点中，Fig. 1 -&gt; Fig. 2 使用了左子树的最大值，Fig. 1 -&gt; Fig. 3 使用了右子树的最小值。</p>
<h2 id="二叉搜索树接口实现">二叉搜索树接口实现</h2>
<h3 id="定义 -BST- 结构">定义 BST 结构</h3>
<p>BST 结构定义与普通二叉树结构定义没有区别。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode_t;</span><br></pre></td></tr></table></figure>
<h3 id="创建一个节点">创建一个节点</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode_t* <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    TreeNode_t *newNode = (TreeNode_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode_t));</span><br><span class="line">    newNode-&gt;val = val;</span><br><span class="line">    newNode-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入一个节点（迭代实现）">插入一个节点（迭代实现）</h3>
<p>给定一棵 BST，插入一个节点的过程为：</p>
<ol>
<li>判断根节点是否为空：
<ul>
<li>为空，则创建一个节点，并返回该节点。</li>
</ul>
</li>
<li>根节点不为空，则判断插入的节点值与根节点的大小关系：
<ul>
<li>相等，则不需插入，直接返回根节点。</li>
<li>小于，则需要确定根节点是否有左子树：
<ul>
<li>无左子树，则创建一个节点并将其作为根节点的左子树，插入节点结束。</li>
<li>有左子树，更新根节点为左孩子节点，继续执行步骤 2；</li>
</ul>
</li>
<li>大于，则需要确定根节点是否有右子树：
<ul>
<li>无右子树，则创建一个节点并将其作为根节点的右子树，插入节点结束。</li>
<li>有右子树，更新根节点为右孩子节点，继续执行步骤 2；</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode_t* <span class="title function_">insertNode</span><span class="params">(TreeNode_t* root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> createNode(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode_t *curNode = root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curNode-&gt;val == val) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; curNode-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curNode-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                curNode-&gt;left = createNode(val);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curNode = curNode-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (curNode-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                curNode-&gt;right = createNode(val);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curNode = curNode-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入一个节点（递归实现）">插入一个节点（递归实现）</h3>
<p>通过插入节点的迭代实现可以看出，插入的过程本质上是插入的值与不同子树的根节点做大小比较的过程，并在合适的位置插入新节点。因此，我们也可以递归地实现插入节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode_t* <span class="title function_">insertNode</span><span class="params">(TreeNode_t* root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> createNode(val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;left = insertNode(root-&gt;left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;right = insertNode(root-&gt;right, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="搜索一个节点（迭代实现）">搜索一个节点（迭代实现）</h3>
<p>给定一棵 BST，搜素一个节点的过程为：</p>
<ol>
<li>判断根节点是否为空：
<ul>
<li>为空，则搜索失败，返回 <code>NULL</code>。</li>
<li>不为空，判断值是否相等：
<ul>
<li>相等，则搜索成功，返回当前节点。</li>
<li>不相等，则判断搜索值与根节点值的大小关系，更新根节点，并重复步骤 1。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode_t* <span class="title function_">searchNode</span><span class="params">(TreeNode_t* root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    TreeNode_t *curNode = root;</span><br><span class="line">    <span class="keyword">while</span> (curNode &amp;&amp; (val != curNode-&gt;val)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val &lt; curNode-&gt;val) &#123;</span><br><span class="line">            curNode = curNode-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curNode = curNode-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="搜索一个节点（递归实现）">搜索一个节点（递归实现）</h3>
<p>同样地，搜索一个节点也有递归实现方式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode_t* <span class="title function_">searchNode</span><span class="params">(TreeNode_t* root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span> || val == root-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> searchNode(root-&gt;left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchNode(root-&gt;right, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中序遍历 -BST">中序遍历 BST</h3>
<p>就像上面说的，二叉搜索树的中序遍历的结果是一个按升序排序的有序数组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inOrderTraversal</span><span class="params">(TreeNode_t* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        inOrderTraversal(root-&gt;left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;val);</span><br><span class="line">        inOrderTraversal(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历也是递归实现？！二叉树的每一棵子树还是一棵二叉树，所以二叉树的很多操作都可以用递归的方式实现。</p>
<h3 id="查找 -BST- 的最小节点">查找 BST 的最小节点</h3>
<p>给定一棵 BST 或它的子树，有时需要查找它的最小节点（比如后面的删除一个节点时，就会用到这个函数哦）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode_t* <span class="title function_">findMinNode</span><span class="params">(TreeNode_t* root)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (root-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = root-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找 -BST- 的最大节点">查找 BST 的最大节点</h3>
<p>给定一棵 BST 或它的子树，有时需要查找它的最大节点（比如后面的删除一个节点时，也可能用到这个函数哦）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode_t* <span class="title function_">findMaxNode</span><span class="params">(TreeNode_t* root)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (root-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找前驱节点">查找前驱节点</h3>
<p>在 BST 中，一个节点的 <strong> 前驱节点定义为比该节点小的所有节点中的最大节点</strong>。换句话说，它是在中序遍历顺序中位于该节点之前的节点。</p>
<p>如何确定前驱节点呢？</p>
<ul>
<li>如果一个节点有左子树，那么左子树的最大值就是前驱节点；</li>
<li>如果一个节点没有左子树，那么它的前驱节点就是离它最近的拥有右子树的祖先节点；
<ul>
<li><strong>确定方法 </strong>：从根节点搜，只要值比该节点的值小，它就<strong> 可能 </strong> 是前驱节点。通过在满足条件的情况下，不断更新这个节点（离它越来越近），最后就是前驱节点啦。</li>
</ul>
</li>
<li>如果一个节点既没有左子树也没有右子树，那么它没有前驱节点。</li>
</ul>
<blockquote>
<p>什么叫「离它最近的拥有右子树的祖先节点」呢？<br>
举个例子，上面的那张图中，节点 5 没有右子树，离它最近的拥有右子树的节点是节点 2，节点 2 是节点 5 的祖先节点，所以 5 的前驱节点是 2。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode_t* <span class="title function_">predecessorNode</span><span class="params">(TreeNode_t* root, TreeNode_t* node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果节点有左子树，则前驱节点为左子树中的最右节点</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">        <span class="keyword">return</span> findMaxNode(node-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果节点没有左子树，则前驱节点为离它最近的拥有右子树的祖先节点</span></span><br><span class="line">    TreeNode_t* predecessor = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; node-&gt;val) &#123;</span><br><span class="line">            predecessor = root;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &gt; node-&gt;val) &#123;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> predecessor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数一为 BST 的根节点，参数二为 BST 的某一节点，即想要查找参数二的前驱节点，参数二也可以传入根节点哦。</p>
</blockquote>
<h3 id="查找后驱节点">查找后驱节点</h3>
<p>在 BST 中，一个节点的 <strong> 后驱节点定义为比该节点大的所有节点中的最小节点</strong>。换句话说，它是在中序遍历顺序中位于该节点之后的节点。</p>
<p>如何确定后驱节点呢？</p>
<ul>
<li>如果一个节点有右子树，那么右子树的最小值就是后驱节点；</li>
<li>如果一个节点没有右子树，那么它的后驱节点就是离它最近的拥有左子树的祖先节点；</li>
<li>如果一个节点既没有右子树也没有左子树，那么它没有后驱节点。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode_t* <span class="title function_">successorNode</span><span class="params">(TreeNode_t* root, TreeNode_t* node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果节点有右子树，则后驱节点为右子树中的最左节点</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">        <span class="keyword">return</span> findMinNode(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果节点没有右子树，则后驱节点为离它最近的拥有左子树的祖先节点</span></span><br><span class="line">    TreeNode_t* successor = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; node-&gt;val) &#123;</span><br><span class="line">            successor = root;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; node-&gt;val) &#123;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> successor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除一个节点（递归实现）">删除一个节点（递归实现）</h3>
<p>给定一棵 BST，删除一个节点的思路为：</p>
<ul>
<li>若待删除的值小于根节点的值，则在左子树中查找并删除；</li>
<li>若待删除的值大于根节点的值，则在右子树中查找并删除；</li>
<li>若待删除的值等于根节点的值，要看它有没有左、右子树：
<ul>
<li>无左子树和右子树：直接删除；</li>
<li>仅有左子树，则只需更新根节点的地址为其左孩子的地址，并释放原根节点空间即可。</li>
<li>仅有右子树，则只需更新根节点的地址为其右孩子的地址，并释放原根节点空间即可。</li>
<li>既有左子树、又有右子树：
<ul>
<li>找左子树的最大值节点, 将根节点的值替换它的值，并删除它（又一次调用删除一个节点的函数）；或者找右子树的最小值节点, 将根节点的值替换它的值，并删除它。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode_t* <span class="title function_">deleteNode</span><span class="params">(TreeNode_t* root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;left = deleteNode(root-&gt;left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找到要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有子节点的情况</span></span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            root = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 只有右子节点的情况</span></span><br><span class="line">            TreeNode_t* temp = root;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 只有左子节点的情况</span></span><br><span class="line">            TreeNode_t* temp = root;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 有两个子节点的情况</span></span><br><span class="line">            <span class="comment">// 找左子树的最大值, 替换并删除它; 或者找右子树的最小值, 替换并删除它</span></span><br><span class="line">            TreeNode_t* temp = findMinNode(root-&gt;right);</span><br><span class="line">            root-&gt;val = temp-&gt;val;</span><br><span class="line">            root-&gt;right = deleteNode(root-&gt;right, temp-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="销毁 -BST">销毁 BST</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">destroyBST</span><span class="params">(TreeNode_t* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        destroyBST(root-&gt;left);</span><br><span class="line">        destroyBST(root-&gt;right);</span><br><span class="line">        <span class="built_in">free</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，在销毁二叉搜索树后，我们要将根节点指针 <code>root</code> 设为 <code>NULL</code>，以防止在后续操作中误用已被释放的内存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">destroyBST(root);</span><br><span class="line">root = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<h2 id="BST- 完整代码测试">BST 完整代码测试</h2>
<h3 id="完整代码">完整代码</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode_t;</span><br><span class="line"></span><br><span class="line">TreeNode_t* <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    TreeNode_t *newNode = (TreeNode_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode_t));</span><br><span class="line">    newNode-&gt;val = val;</span><br><span class="line">    newNode-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode_t* <span class="title function_">insertNode</span><span class="params">(TreeNode_t* root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> createNode(val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;left = insertNode(root-&gt;left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;right = insertNode(root-&gt;right, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode_t* <span class="title function_">searchNode</span><span class="params">(TreeNode_t* root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span> || val == root-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> searchNode(root-&gt;left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchNode(root-&gt;right, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrderTraversal</span><span class="params">(TreeNode_t* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        inOrderTraversal(root-&gt;left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;val);</span><br><span class="line">        inOrderTraversal(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode_t* <span class="title function_">findMinNode</span><span class="params">(TreeNode_t* root)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (root-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = root-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode_t* <span class="title function_">findMaxNode</span><span class="params">(TreeNode_t* root)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (root-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode_t* <span class="title function_">predecessorNode</span><span class="params">(TreeNode_t* root, TreeNode_t* node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果节点有左子树，则前驱节点为左子树中的最右节点</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">        <span class="keyword">return</span> findMaxNode(node-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果节点没有左子树，则前驱节点为离它最近的拥有右子树的祖先节点</span></span><br><span class="line">    TreeNode_t* predecessor = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; node-&gt;val) &#123;</span><br><span class="line">            predecessor = root;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &gt; node-&gt;val) &#123;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> predecessor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode_t* <span class="title function_">successorNode</span><span class="params">(TreeNode_t* root, TreeNode_t* node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果节点有右子树，则后驱节点为右子树中的最左节点</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">        <span class="keyword">return</span> findMinNode(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果节点没有右子树，则后驱节点为离它最近的拥有左子树的祖先节点</span></span><br><span class="line">    TreeNode_t* successor = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; node-&gt;val) &#123;</span><br><span class="line">            successor = root;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; node-&gt;val) &#123;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> successor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode_t* <span class="title function_">deleteNode</span><span class="params">(TreeNode_t* root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;left = deleteNode(root-&gt;left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找到要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有子节点的情况</span></span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            root = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 只有右子节点的情况</span></span><br><span class="line">            TreeNode_t* temp = root;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 只有左子节点的情况</span></span><br><span class="line">            TreeNode_t* temp = root;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 有两个子节点的情况</span></span><br><span class="line">            <span class="comment">// 找左子树的最大值, 替换并删除它; 或者找右子树的最小值, 替换并删除它</span></span><br><span class="line">            TreeNode_t* temp = findMinNode(root-&gt;right);</span><br><span class="line">            root-&gt;val = temp-&gt;val;</span><br><span class="line">            root-&gt;right = deleteNode(root-&gt;right, temp-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyBST</span><span class="params">(TreeNode_t* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        destroyBST(root-&gt;left);</span><br><span class="line">        destroyBST(root-&gt;right);</span><br><span class="line">        <span class="built_in">free</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试代码">测试代码</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 规范化地打印二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printBinaryTree</span><span class="params">(TreeNode_t* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">    printBinaryTree(root-&gt;left);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; &lt;- %d -&gt; &quot;</span>, root-&gt;val);</span><br><span class="line">    printBinaryTree(root-&gt;right);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argv, <span class="type">char</span> *argc[])</span> &#123;</span><br><span class="line">    TreeNode_t* root = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试插入节点和搜索节点</span></span><br><span class="line">    root = insertNode(root, <span class="number">5</span>);</span><br><span class="line">    root = insertNode(root, <span class="number">3</span>);</span><br><span class="line">    root = insertNode(root, <span class="number">7</span>);</span><br><span class="line">    root = insertNode(root, <span class="number">2</span>);</span><br><span class="line">    root = insertNode(root, <span class="number">4</span>);</span><br><span class="line">    root = insertNode(root, <span class="number">6</span>);</span><br><span class="line">    root = insertNode(root, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    TreeNode_t* result = searchNode(root, <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Node found: %d\n&quot;</span>, result-&gt;val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Node not found\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = searchNode(root, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Node found: %d\n&quot;</span>, result-&gt;val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Node not found\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试中序遍历</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In-order traversal: &quot;</span>);</span><br><span class="line">    inOrderTraversal(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试查找最小值节点和最大值节点</span></span><br><span class="line">    TreeNode_t* minNode = findMinNode(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Minimum value: %d\n&quot;</span>, minNode-&gt;val);</span><br><span class="line"></span><br><span class="line">    TreeNode_t* maxNode = findMaxNode(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Maximum value: %d\n&quot;</span>, maxNode-&gt;val);</span><br><span class="line"></span><br><span class="line">    printBinaryTree(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试前驱节点和后继节点</span></span><br><span class="line">    TreeNode_t* node = searchNode(root, <span class="number">4</span>);</span><br><span class="line">    TreeNode_t* predecessor = predecessorNode(root, node);</span><br><span class="line">    <span class="keyword">if</span> (predecessor != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Predecessor of %d: %d\n&quot;</span>, node-&gt;val, predecessor-&gt;val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No predecessor for %d\n&quot;</span>, node-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node = searchNode(root, <span class="number">7</span>);</span><br><span class="line">    TreeNode_t* successor = successorNode(root, node);</span><br><span class="line">    <span class="keyword">if</span> (successor != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Successor of %d: %d\n&quot;</span>, node-&gt;val, successor-&gt;val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No successor for %d\n&quot;</span>, node-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试删除节点</span></span><br><span class="line">    root = deleteNode(root, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次中序遍历，检查删除是否成功</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In-order traversal after deletion: &quot;</span>);</span><br><span class="line">    inOrderTraversal(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁二叉搜索树</span></span><br><span class="line">    destroyBST(root);</span><br><span class="line">    root = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试结果">测试结果</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Node found: 6</span><br><span class="line">Node not found</span><br><span class="line">In-order traversal: 2 3 4 5 6 7 8</span><br><span class="line">Minimum value: 2</span><br><span class="line">Maximum value: 8</span><br><span class="line">(((&lt;- 2 -&gt;) &lt;- 3 -&gt; (&lt;- 4 -&gt;)) &lt;- 5 -&gt; ((&lt;- 6 -&gt;) &lt;- 7 -&gt; (&lt;- 8 -&gt;)))</span><br><span class="line">Predecessor of 4: 3</span><br><span class="line">Successor of 7: 8</span><br><span class="line">In-order traversal after deletion: 2 4 5 6 7 8</span><br></pre></td></tr></table></figure>
<blockquote>
<p>插入和搜索的迭代实现方式也验证了，没有问题。</p>
</blockquote>
<p>建立的这棵树是这样子的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       5</span><br><span class="line">     /   \</span><br><span class="line">    /     \</span><br><span class="line">   3       7</span><br><span class="line"> /   \   /   \</span><br><span class="line">2     4 6     8</span><br></pre></td></tr></table></figure>
<p>节点 4 的前驱节点是 3，节点 7 的后驱节点是 8，没有问题！</p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://github.com/kodecocodes/swift-algorithm-club/blob/master/Binary%20Search%20Tree/README.markdown">BST in swift-algorithm-club</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉搜索树</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之堆基础与堆结构（数组实现）</title>
    <url>/posts/231018102559.html</url>
    <content><![CDATA[<p>堆（Heap）是一类特殊的数据结构，是最高效的优先级队列。堆是用 <strong> 数组实现 </strong> 的<strong>完全 </strong> 二叉树，没有使用父指针或者子指针，省内存。</p>
<span id="more"></span>
<blockquote>
<p>完全二叉树的形式是指除了最后一层之外，其他所有层的结点都是满的，而最后一层的所有结点都靠左边。</p>
</blockquote>
<h2 id="堆属性">堆属性</h2>
<p><strong>堆属性 </strong>：在最大堆中，父结点的值比每一个子结点的值都要大（可以等于）。在最小堆中，父结点的值比每一个子结点的值都要小（可以等于）。这就是所谓的「堆属性」，并且这个属性对堆中的<strong> 每一个结点 </strong> 都成立。</p>
<p>在一个最大堆中，最小元素一定在叶子结点中，但不能确定是哪一个；在一个最小堆中，最大元素一定在叶子结点中，但不能确定是哪一个。</p>
<p>下面是一个堆数据的二叉树模式图和紧凑数组模式图。</p>
<p>二叉树模式图：</p>
<p><img src="/images/data-structure/heap-tree-format-data.png" alt="堆的二叉树模式图"></p>
<p>紧凑数组模式图：</p>
<p><img src="/images/data-structure/heap-array-format-data.png" alt="堆的紧凑数组模式图"></p>
<blockquote>
<p>堆的根结点存放的是最大或者最小元素，但是 <strong> 其他结点的排序顺序是未知的，只是满足堆属性而已</strong>。</p>
</blockquote>
<h2 id="堆与普通树的区别">堆与普通树的区别</h2>
<ol>
<li>
<p><strong>结点顺序</strong>：在最大堆中，任一根结点都不小于其左、右子结点的值，而在二叉搜索树中，根结点一定大于其左结点的值，也一定小于其右结点的值。</p>
</li>
<li>
<p><strong>内存占用</strong>：普通树占用的内存比其存储的数据要多，因为要为每个结点对象及其左、右子结点指针分配内存，而堆仅仅使用一个数组存储数据，不需要指针。</p>
</li>
<li>
<p><strong>平衡</strong>：二叉搜索树时间复杂度为 <code>O(log n)</code> 的前提是树尽可能是平衡的。而堆中平衡不是问题，只要满足堆属性即可保证 <code>O(log n)</code> 的性能。</p>
</li>
<li>
<p><strong>搜索 </strong>：二叉搜索树中搜索很快，即二分查找 <code>O(log n)</code>。但是，在堆中搜索很慢，即遍历数组 <code>O(n)</code>，在堆中搜索不是第一优先级，因为<strong> 使用堆的目的是将最大（或者最小）的结点放在最前面，从而快速的进行相关插入、删除操作</strong>。</p>
</li>
</ol>
<h2 id="堆中父我子节点映射关系">堆中父我子节点映射关系</h2>
<p><strong>父我子结点映射关系</strong>：对于数组中索引为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 的结点（我），其父结点索引和左、右子结点在数组中的索引位置为如下：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>m</mi><mi>y</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mi>i</mi><mo separator="true">;</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>p</mi><mi>a</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mi>l</mi><mi>o</mi><mi>o</mi><mi>r</mi><mo stretchy="false">(</mo><mfrac><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><mn>2</mn></mfrac><mo stretchy="false">)</mo><mo separator="true">;</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">;</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mi>i</mi><mo>+</mo><mn>2</mn><mo>=</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo separator="true">;</mo></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}
my(i) = i; \\ 
parent(i) = floor(\frac{i-1}{2}); \\ 
left(i) = 2i+1; \\ 
right(i) = 2i + 2 = left(i) + 1; \\ 
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.76em;vertical-align:-2.63em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9500200000000008em;"><span style="top:-1.59999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-1.5949900000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-1.8899900000000003em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.1849900000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.2049900000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.1500100000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.29501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.59001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.885010000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.905010000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-5.20002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.1300000000000003em;"><span style="top:-5.130000000000001em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">i</span><span class="mpunct">;</span></span></span><span style="top:-3.6900000000000004em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.855664em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mpunct">;</span></span></span><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">2</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">;</span></span></span><span style="top:-0.8100000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">2</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">;</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.63em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<blockquote>
<p>所有结点的索引一定不能越界，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">i \in [0, n-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>。</p>
</blockquote>
<h2 id="堆数组元素大小关系">堆数组元素大小关系</h2>
<p><strong>数组关系</strong>：根据堆属性可知，在最大堆中有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mo stretchy="false">[</mo><mi>p</mi><mi>a</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>&gt;</mo><mo>=</mo><mi>a</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">array[parent(i)] &gt;= array[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> ，在最小堆中有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mo stretchy="false">[</mo><mi>p</mi><mi>a</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>&lt;</mo><mo>=</mo><mi>a</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">array[parent(i)] &lt;= array[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>。</p>
<h2 id="堆的二叉树模式的高度">堆的二叉树模式的高度</h2>
<p>堆的形状一定是一棵 <strong> 完全 </strong> 二叉树。在堆中，在当前层级所有的结点都已经填满之前不允许开始下一层的填充。</p>
<p>一个有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个结点的堆，其高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mi>f</mi><mi>l</mi><mi>o</mi><mi>o</mi><mi>r</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h=floor(log_{2}{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>。堆的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">h-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 层结点数量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{h}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。堆的最后一层若填满的话，最后一层包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup></mrow><annotation encoding="application/x-tex">2^h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span></span></span></span> 个结点，整个堆共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><msup><mn>2</mn><mrow><mi>h</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n=2^{h+1}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9324379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个结点。</p>
<p>叶结点总是位于数组的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>f</mi><mi>l</mi><mi>o</mi><mi>o</mi><mi>r</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[floor(n/2), n-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 区间，那么 <strong> 最后一个非叶子结点</strong>（最后一个内部结点）索引即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>l</mi><mi>o</mi><mi>o</mi><mi>r</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">floor(n/2)-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p>
<blockquote>
<p>堆的高度从 0 层开始，空堆的高度为 -1，高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span> 的堆有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">h + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 层（0 到 h 层）。</p>
</blockquote>
<h2 id="堆化（heapify）">堆化（heapify）</h2>
<p>「堆化」的目的是在堆进行插入或删除操作后，为了确保堆仍然是一个有效的最大堆或最小堆（仍然满足堆属性），需要进行一些必要的操作（上浮和下沉操作），这个过程就叫做堆化。</p>
<ol>
<li><code>shiftUp()</code>: If the element is greater (max-heap) or smaller (min-heap) than its parent, it needs to be swapped with the parent. This makes it move up the tree.</li>
<li><code>shiftDown()</code>. If the element is smaller (max-heap) or greater (min-heap) than its children, it needs to move down the tree.</li>
</ol>
<blockquote>
<p>上浮或下沉是一个递归过程，需要 <code>O(log n)</code> 时间。因为每次上浮或下沉都会选择一个子树、而抛弃另一个子树（上浮或下沉的次数最多为树的高度）。</p>
</blockquote>
<p>为什么在插入或删除时，会有上浮和下沉过程？</p>
<p>这是因为，删除操作时，会 pop 出堆顶的元素，<strong>并将堆数组的最后一个索引的元素填充到堆顶</strong>，这个操作会使得堆不再满足堆属性；而在插入操作时，会先将数据存储在堆数组的最后一个索引后面，插入的数据大小未知，也会导致堆不再满足堆属性。因此，在插入或删除操作执行后，需要进行堆化这一过程。</p>
<h2 id="数组实现堆数据结构">数组实现堆数据结构</h2>
<h3 id="堆结构定义">堆结构定义</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Heap</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *<span class="built_in">array</span>;     <span class="comment">// 堆的数组</span></span><br><span class="line">    <span class="type">int</span> size;       <span class="comment">// 堆的当前大小</span></span><br><span class="line">    <span class="type">int</span> capacity;   <span class="comment">// 堆的容量</span></span><br><span class="line">&#125; Heap_t;</span><br></pre></td></tr></table></figure>
<p>堆结构与之前的栈的结构类似，包括堆的最大容量、堆的当前大小（数据量）、存储数据的空间（数组）。</p>
<blockquote>
<p>这里，堆的数据成员使用一个指针，可以在创建不同的堆时，根据需要申请堆的容量；如果使用一个数组变量（如 <code>int array[MAX_CAPACITY]</code>），则在创建不同的堆时，无法修改堆的最大容量。<br>
这里，堆的数据成员使用一个 <code>int *</code> 类型的指针，如果我们堆中存放的数据是复杂的组合数据，简单地修改数据成员的指针类型即可。</p>
</blockquote>
<h3 id="堆的初始化">堆的初始化</h3>
<p>堆的初始化，包括申请堆本身的内存空间和数据成员的内存空间两部分，以及对基本成员做初始化操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化堆</span></span><br><span class="line">Heap_t* <span class="title function_">initHeap</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Heap_t *heap = (Heap_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Heap_t));</span><br><span class="line">    heap-&gt;<span class="built_in">array</span> = (<span class="type">int</span> *)<span class="built_in">malloc</span>(capacity * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    heap-&gt;size = <span class="number">0</span>;</span><br><span class="line">    heap-&gt;capacity = capacity;</span><br><span class="line">    <span class="keyword">return</span> heap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取父节点索引">获取父节点索引</h3>
<p>根据上述的理论基础，我们知道当前节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 的父节点的索引为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>a</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mi>l</mi><mi>o</mi><mi>o</mi><mi>r</mi><mo stretchy="false">(</mo><mfrac><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><mn>2</mn></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">parent(i) = floor(\frac{i-1}{2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.200664em;vertical-align:-0.345em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.855664em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取节点的父节点索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getParentIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (index - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取左子节点索引">获取左子节点索引</h3>
<p>根据上述的理论基础，我们知道当前节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 的左子节点的索引为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">left(i) = 2i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取节点的左子节点索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getLeftChildIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取右子节点索引">获取右子节点索引</h3>
<p>根据上述的理论基础，我们知道当前节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 的右子节点的索引为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mi>i</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">right(i) = 2i+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取节点的右子节点索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getRightChildIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (index &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆化之上浮操作">堆化之上浮操作</h3>
<p>在插入操作时，会先将数据存储在堆数组的最后一个索引后面，而插入的数据大小未知，会导致堆不再满足堆属性，需要进行堆化中的上浮操作，使堆数组重新满足堆属性。</p>
<p>首先，封装一个实现交换数组中两个位置的值的函数。这里，使用了异或运算的自反性，而没有使用临时变量的方式交换两个数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *<span class="built_in">array</span>, <span class="type">int</span> idx1, <span class="type">int</span> idx2)</span> &#123;</span><br><span class="line">    <span class="built_in">array</span>[idx1] = <span class="built_in">array</span>[idx1] ^ <span class="built_in">array</span>[idx2];</span><br><span class="line">    <span class="built_in">array</span>[idx2] = <span class="built_in">array</span>[idx1] ^ <span class="built_in">array</span>[idx2];</span><br><span class="line">    <span class="built_in">array</span>[idx1] = <span class="built_in">array</span>[idx1] ^ <span class="built_in">array</span>[idx2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在最大堆的堆化上浮操作中，如果当前索引对应的节点的值比其父节点的值大，则应该将两个节点进行交换，<strong>直到不满足当前节点比其父节点大或当前节点达到堆顶为止</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上浮操作，将节点移动到正确的位置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">siftUp</span><span class="params">(Heap_t *heap, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *<span class="built_in">array</span> = heap-&gt;<span class="built_in">array</span>;</span><br><span class="line">    <span class="type">int</span> parentIndex = getParentIndex(index);</span><br><span class="line">    <span class="keyword">while</span> ((index &gt; <span class="number">0</span>) &amp;&amp; (<span class="built_in">array</span>[index] &gt; <span class="built_in">array</span>[parentIndex])) &#123;</span><br><span class="line">        swap(<span class="built_in">array</span>, parentIndex, index);</span><br><span class="line">        index = parentIndex;  <span class="comment">// 交换节点后, 更新当前节点的位置</span></span><br><span class="line">        parentIndex = getParentIndex(index);  <span class="comment">// 重新获取父节点位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆化之下沉操作（迭代方式）">堆化之下沉操作（迭代方式）</h3>
<p>在删除操作时，会 pop 出堆顶的元素，并将堆数组的最后一个索引的元素填充到堆顶，这个操作会使得堆不再满足堆属性，需要进行堆化中的下沉操作 —— 将这个数放到合适它的位置，使堆数组重新满足堆属性。</p>
<p>在最大堆的堆化下沉操作中，当前索引对应的节点的值要跟它的左右孩子节点做比较，并跟两者中较大的孩子做位置替换，<strong>直到无需跟左右孩子节点替换（值比它俩都大）为止</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下沉操作，将节点移动到正确的位置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">siftDown</span><span class="params">(Heap_t *heap, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *<span class="built_in">array</span> = heap-&gt;<span class="built_in">array</span>;</span><br><span class="line">    <span class="type">int</span> size = heap-&gt;size;</span><br><span class="line">    <span class="type">int</span> leftChildIndex, rightChildIndex, maxIndex;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; size) &#123;</span><br><span class="line">        leftChildIndex = getLeftChildIndex(index);</span><br><span class="line">        rightChildIndex = getRightChildIndex(index);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接下来的两个判断为找出具有更大值的孩子的索引</span></span><br><span class="line">        maxIndex = index;</span><br><span class="line">        <span class="keyword">if</span> (leftChildIndex &lt; size &amp;&amp; <span class="built_in">array</span>[leftChildIndex] &gt; <span class="built_in">array</span>[maxIndex]) &#123;</span><br><span class="line">            maxIndex = leftChildIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightChildIndex &lt; size &amp;&amp; <span class="built_in">array</span>[rightChildIndex] &gt; <span class="built_in">array</span>[maxIndex]) &#123;</span><br><span class="line">            maxIndex = rightChildIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (maxIndex != index) &#123;</span><br><span class="line">            swap(<span class="built_in">array</span>, maxIndex, index);</span><br><span class="line">            index = maxIndex;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>while 循环处的条件其实为 true 也行, 代码里那么写是防止首次进入 while 循环时，便是非法的索引，这样可以少一次循环处理。</p>
</blockquote>
<h3 id="堆化之下沉操作（递归方式）">堆化之下沉操作（递归方式）</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">siftDown</span><span class="params">(Heap_t* heap, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxIndex = index;</span><br><span class="line">    <span class="type">int</span> leftChildIndex = getLeftChildIndex(index);</span><br><span class="line">    <span class="type">int</span> rightChildIndex = getRightChildIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来的两个判断为找出具有更大值的孩子的索引</span></span><br><span class="line">    <span class="keyword">if</span> (leftChildIndex &lt; heap-&gt;size &amp;&amp; heap-&gt;<span class="built_in">array</span>[leftChildIndex] &gt; heap-&gt;<span class="built_in">array</span>[maxIndex]) &#123;</span><br><span class="line">        maxIndex = leftChildIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rightChildIndex &lt; heap-&gt;size &amp;&amp; heap-&gt;<span class="built_in">array</span>[rightChildIndex] &gt; heap-&gt;<span class="built_in">array</span>[maxIndex]) &#123;</span><br><span class="line">        maxIndex = rightChildIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index != maxIndex) &#123;</span><br><span class="line">        swap(heap-&gt;<span class="built_in">array</span>, maxIndex, index);</span><br><span class="line">        siftDown(heap, maxIndex);  <span class="comment">// 递归方式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取堆顶元素">获取堆顶元素</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取堆顶元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(Heap_t *heap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Heap is empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap-&gt;<span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入数据">插入数据</h3>
<p>在插入操作时，会 <strong> 先将数据存储在堆数组的最后一个索引后面 </strong>，而插入的数据大小未知，会导致堆不再满足堆属性，需要<strong> 进行堆化中的上浮操作</strong>，使堆数组重新满足堆属性。</p>
<p>下面的动画演示了插入 <code>2,7,26,25,19,17,1,90,3,36</code> 数据（创建堆并维持堆属性）的过程。<br>
<img src="/images/data-structure/heap-push.gif" alt="堆插入数据"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Heap_t *heap, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;size &gt;= heap-&gt;capacity) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Heap is full!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    heap-&gt;<span class="built_in">array</span>[heap-&gt;size] = value;  <span class="comment">// 存储在堆数组的最后一个索引后面</span></span><br><span class="line">    siftUp(heap, heap-&gt;size);  <span class="comment">// 进行堆化中的上浮操作</span></span><br><span class="line">    heap-&gt;size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果不希望遇到堆满的情况（希望在堆满时依然可以插入数据），则可以在堆满时进行动态扩容，并修改堆的容量。</p>
</blockquote>
<h3 id="删除堆顶数据">删除堆顶数据</h3>
<p>在删除操作时，会 pop 出堆顶的元素，并 <strong> 将堆数组的最后一个索引的元素填充到堆顶 </strong>，这个操作会使得堆不再满足堆属性，需要<strong> 进行堆化中的下沉操作</strong> —— 将这个数放到合适它的位置，使堆数组重新满足堆属性。</p>
<p>下面的动画演示了删除堆顶数据的过程。<br>
<img src="/images/data-structure/heap-pop.gif" alt="删除堆顶数据过程"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除堆顶元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Heap_t *heap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Heap is empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> top = heap-&gt;<span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    heap-&gt;<span class="built_in">array</span>[<span class="number">0</span>] = heap-&gt;<span class="built_in">array</span>[heap-&gt;size - <span class="number">1</span>];</span><br><span class="line">    heap-&gt;size--;</span><br><span class="line">    siftDown(heap, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除堆顶后的紧凑型数组模式图是这样的：<br>
<img src="/images/data-structure/heap-pop-after.png" alt="删除堆顶数据后"></p>
<h3 id="打印堆数据">打印堆数据</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印堆元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printHeap</span><span class="params">(Heap_t *heap)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Heap: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; heap-&gt;size; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, heap-&gt;<span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="销毁堆">销毁堆</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 销毁堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyHeap</span><span class="params">(Heap_t *heap)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(heap-&gt;<span class="built_in">array</span>);</span><br><span class="line">    <span class="built_in">free</span>(heap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆操作的时间复杂度">堆操作的时间复杂度</h2>
<p>堆的时间复杂度如下：</p>
<ul>
<li>插入元素到堆：<code>O(log n)</code></li>
<li>删除堆顶元素：<code>O(log n)</code></li>
<li>获取堆顶元素：<code>O(1)</code></li>
<li>「Floyd 上浮方式」构建堆：<code>O(n)</code></li>
<li>堆排序：<code>O(n*log n)</code></li>
<li>上浮操作：<code>O(n*log n)</code></li>
<li>下沉操作：<code>O(n*log n)</code></li>
</ul>
<blockquote>
<p>为什么构建堆的过程的时间复杂度为 <code>O(n)</code> 呢？</p>
</blockquote>
<h2 id="数组实现堆完整代码">数组实现堆完整代码</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *<span class="built_in">array</span>;     <span class="comment">// 堆的数组</span></span><br><span class="line">    <span class="type">int</span> size;       <span class="comment">// 堆的当前大小</span></span><br><span class="line">    <span class="type">int</span> capacity;   <span class="comment">// 堆的容量</span></span><br><span class="line">&#125; Heap_t;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *<span class="built_in">array</span>, <span class="type">int</span> idx1, <span class="type">int</span> idx2)</span> &#123;</span><br><span class="line">    <span class="built_in">array</span>[idx1] = <span class="built_in">array</span>[idx1] ^ <span class="built_in">array</span>[idx2];</span><br><span class="line">    <span class="built_in">array</span>[idx2] = <span class="built_in">array</span>[idx1] ^ <span class="built_in">array</span>[idx2];</span><br><span class="line">    <span class="built_in">array</span>[idx1] = <span class="built_in">array</span>[idx1] ^ <span class="built_in">array</span>[idx2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Heap_t* <span class="title function_">initHeap</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Heap_t *heap = (Heap_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Heap_t));</span><br><span class="line">    heap-&gt;<span class="built_in">array</span> = (<span class="type">int</span> *)<span class="built_in">malloc</span>(capacity * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    heap-&gt;size = <span class="number">0</span>;</span><br><span class="line">    heap-&gt;capacity = capacity;</span><br><span class="line">    <span class="keyword">return</span> heap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getParentIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (index - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getLeftChildIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getRightChildIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (index &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">siftUp</span><span class="params">(Heap_t *heap, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *<span class="built_in">array</span> = heap-&gt;<span class="built_in">array</span>;</span><br><span class="line">    <span class="type">int</span> parentIndex = getParentIndex(index);</span><br><span class="line">    <span class="keyword">while</span> ((index &gt; <span class="number">0</span>) &amp;&amp; (<span class="built_in">array</span>[index] &gt; <span class="built_in">array</span>[parentIndex])) &#123;</span><br><span class="line">        swap(<span class="built_in">array</span>, parentIndex, index);</span><br><span class="line">        index = parentIndex;  <span class="comment">// 交换节点后, 更新当前节点的位置</span></span><br><span class="line">        parentIndex = getParentIndex(index);  <span class="comment">// 重新获取父节点位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">siftDown</span><span class="params">(Heap_t* heap, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxIndex = index;</span><br><span class="line">    <span class="type">int</span> leftChildIndex = getLeftChildIndex(index);</span><br><span class="line">    <span class="type">int</span> rightChildIndex = getRightChildIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来的两个判断为找出具有更大值的孩子的索引</span></span><br><span class="line">    <span class="keyword">if</span> (leftChildIndex &lt; heap-&gt;size &amp;&amp; heap-&gt;<span class="built_in">array</span>[leftChildIndex] &gt; heap-&gt;<span class="built_in">array</span>[maxIndex]) &#123;</span><br><span class="line">        maxIndex = leftChildIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rightChildIndex &lt; heap-&gt;size &amp;&amp; heap-&gt;<span class="built_in">array</span>[rightChildIndex] &gt; heap-&gt;<span class="built_in">array</span>[maxIndex]) &#123;</span><br><span class="line">        maxIndex = rightChildIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index != maxIndex) &#123;</span><br><span class="line">        swap(heap-&gt;<span class="built_in">array</span>, maxIndex, index);</span><br><span class="line">        siftDown(heap, maxIndex);  <span class="comment">// 递归方式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(Heap_t *heap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Heap is empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap-&gt;<span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Heap_t *heap, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;size &gt;= heap-&gt;capacity) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Heap is full!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    heap-&gt;<span class="built_in">array</span>[heap-&gt;size] = value;  <span class="comment">// 存储在堆数组的最后一个索引后面</span></span><br><span class="line">    siftUp(heap, heap-&gt;size);  <span class="comment">// 进行堆化中的上浮操作</span></span><br><span class="line">    heap-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Heap_t *heap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Heap is empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> top = heap-&gt;<span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    heap-&gt;<span class="built_in">array</span>[<span class="number">0</span>] = heap-&gt;<span class="built_in">array</span>[heap-&gt;size - <span class="number">1</span>];</span><br><span class="line">    heap-&gt;size--;</span><br><span class="line">    siftDown(heap, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printHeap</span><span class="params">(Heap_t *heap)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Heap: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; heap-&gt;size; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, heap-&gt;<span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyHeap</span><span class="params">(Heap_t *heap)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(heap-&gt;<span class="built_in">array</span>);</span><br><span class="line">    <span class="built_in">free</span>(heap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">10</span>, capacity = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> nums[] = &#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">26</span>,<span class="number">25</span>,<span class="number">19</span>,<span class="number">17</span>,<span class="number">1</span>,<span class="number">90</span>,<span class="number">3</span>,<span class="number">36</span>&#125;;</span><br><span class="line">    Heap_t *heap = initHeap(capacity);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        push(heap, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printHeap(heap);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Heap top: %d\n&quot;</span>, peek(heap));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Heap pop: %d\n&quot;</span>, pop(heap));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Heap top: %d\n&quot;</span>, peek(heap));</span><br><span class="line">    printHeap(heap);</span><br><span class="line">    destroyHeap(heap);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Heap: 90 36 17 25 26 7 1 2 3 19</span><br><span class="line">Heap top: 90</span><br><span class="line">Heap pop: 90</span><br><span class="line">Heap top: 36</span><br><span class="line">Heap: 36 26 17 25 19 7 1 2 3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://github.com/kodecocodes/swift-algorithm-club/tree/master/Heap">Heap in swift-algorithm-club</a></li>
<li><a href="https://visualgo.net/zh/heap">堆的动画制作网站</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之字典树</title>
    <url>/posts/230925185057.html</url>
    <content><![CDATA[<h2 id="什么是字典树">什么是字典树</h2>
<p>字典树，是一种 <strong> 以空间换时间 </strong> 的数据结构，又称 Trie 树、前缀树，是一种树形结构，典型应用是统计、排序和保存大量字符串（但不仅限于字符串）。所以经常被搜索引擎系统用于文本词频统计。它的优点是可以 <strong> 利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高</strong>。</p>
<span id="more"></span>
<img src="../images/data-structure/trie-demo.png" alt="字典树示意图" width="80%" height="80%">
<blockquote>
<p>可能大部分情况你很难直观或者有接触的体验，可能对前缀这个玩意没啥概念，可能做题遇到前缀问题也是暴力匹配蒙混过关，<strong>如果字符串比较少，使用哈希表等结构可能也能蒙混过关，但如果字符串比较长、相同前缀较多，那么使用字典树可以大大减少内存的使用和效率</strong>。<br>
一个字典树的应用场景：在 Google 搜索框输入部分单词下面会有一些神关联的搜索内容，你有时候都很神奇是怎么做到的，这其实就是字典树的一个思想。</p>
</blockquote>
<h2 id="字典树的性质">字典树的性质</h2>
<p>字典树是一种高效的数据结构，用于 <strong> 存储和快速检索字符串集合</strong>。它具有以下性质：</p>
<ol>
<li>字典树的 <strong> 根节点不包含任何字符</strong>，每个节点都代表一个字符，从根节点到叶节点的路径组成一个字符串。</li>
<li>每个节点可以包含 <strong> 多个子节点</strong>，每个子节点代表一个字符，节点之间的连接表示字符之间的关系。</li>
<li>每个节点的子节点通过不同的字符来标识，不同节点之间的路径上的字符不会重复。</li>
<li>字典树中的每个节点都可以 <strong> 存储一个附加值</strong>，用于表示该节点所代表的字符串的一些信息。</li>
<li>字典树可以 <strong> 高效地插入和查找字符串</strong>。插入操作将一个字符串的字符逐个添加到字典树中，查找操作根据给定的前缀或完整字符串，在字典树中检索相应的字符串。</li>
<li>字典树可以用于 <strong> 前缀匹配</strong>，例如，可以快速找到所有具有相同前缀的字符串。</li>
<li>字典树的 <strong> 空间复杂度相对较高</strong>，因为它需要为每个字符创建一个节点，但它可以通过压缩节点来减少空间占用。</li>
</ol>
<h2 id="设计实现字典树">设计实现字典树</h2>
<p>上面已经介绍了什么是字典树，那么我们开始设计一个字典树吧！</p>
<p>对于字典树，可能不同的场景或者需求设计上有一些细致的区别，但整体来说一般的字典树有创建、插入、查询（指定字符串）、查询（指定前缀）操作。</p>
<p>以 <a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">LeetCode 实现字典树 </a> 为例，实现字符集是 26 个英文小写字母的字典树的创建、插入、查询操作。</p>
<ul>
<li><code>trieCreate()</code> 初始化字典树对象。</li>
<li><code>void trieInsert(Trie *obj, char *word)</code> 向字典树中插入字符串<code>word</code>。</li>
<li><code>bool trieSearch(Trie *obj, char *word)</code> 搜索字符串 <code>word</code> 是否在字典树中。</li>
<li><code>bool trieStartsWith(Trie *obj, char *prefix)</code> 搜索字符串的前缀 <code>prefix</code> 是否在字典树中。</li>
</ul>
<h3 id="定义字典树类">定义字典树类</h3>
<p>字典树中的每一个节点，都是一个 <code>Trie</code> 类，而这个节点标识的字符可以是字符集中的任意一个字符。简单地，可以使用一个 <code>Trie</code> 类型数组（长度为字符集大小）来标识所有子节点。同时，为了表示该节点是否是某一个字符串的结束字符，可以添加一个布尔类型的结束标记 <code>isEnd</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUMS (26)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> *<span class="title">children</span>[<span class="title">NUMS</span>];</span>  <span class="comment">// 子节点指针数组，用于存储子节点的指针</span></span><br><span class="line">    <span class="type">bool</span> isEnd;  <span class="comment">// 表示当前节点是否为一个单词的结束节点</span></span><br><span class="line">    <span class="type">char</span> padding[<span class="number">7</span>];  <span class="comment">// 用于字节对齐的占位</span></span><br><span class="line">&#125; Trie;</span><br></pre></td></tr></table></figure>
<h3 id="字典树创建（初始化）">字典树创建（初始化）</h3>
<p>字典树有一个根节点，且字典树的根节点不包含任何字符。所以，我们需要初始化一个 <code>Trie</code> 类，并置空所有的子节点地址，以表示根节点不包含任何字符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Trie* <span class="title function_">trieCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    Trie *node = (Trie *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Trie));</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to create a trie node\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;sizeof(Trie) = %d\n&quot;, sizeof(Trie));  // x64, 216</span></span><br><span class="line">    <span class="built_in">memset</span>(node-&gt;children, <span class="number">0</span>, <span class="keyword">sizeof</span>(Trie));</span><br><span class="line">    node-&gt;isEnd = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过调用 <code>trieCreate()</code> 函数创建了节点 <code>node</code>，它不包含任何字符。</p>
<h3 id="字典树插入字符串">字典树插入字符串</h3>
<p>插入字符串的过程是逐个字符地搜索并检查它们是否存在于字典树中。如果某个字符不存在，则需要在上一个字符对应的节点上创建一个新的子节点，并将该节点指向新的字符（新的节点）。这样，就能够正确地构建出整个字符串在字典树中的路径。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trieInsert</span><span class="params">(Trie *obj, <span class="type">char</span> *word)</span> &#123;</span><br><span class="line">    Trie* curr = obj;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; word[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> index = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;children[index] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Trie* child = trieCreate();</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;failed to create a new trie\r\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr-&gt;children[index] = child;</span><br><span class="line">            curr-&gt;children[index]-&gt;isEnd = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将当前节点更新为新节点</span></span><br><span class="line">        curr = curr-&gt;children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将最后一个字符所在的节点标记为字符串的结尾</span></span><br><span class="line">    curr-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从根节点开始遍历字符串的每一个字符，然后根据字符计算出在子节点数组中的索引位置：</p>
<ul>
<li>如果该位置为空，则创建一个新的节点，并将该位置指向新节点；</li>
<li>然后，<strong>将当前节点更新为新节点</strong>，继续下一个字符的判断；</li>
<li>最后，将最后一个字符所在的节点标记为字符串的结尾，表示该字符串已经插入到字典树中。</li>
</ul>
<h3 id="字典树查询字符串">字典树查询字符串</h3>
<p>查询字符串的过程是在字典树已经建立好的情况下进行的。类似于插入过程，也是逐个字符地搜索并检查它们是否存在于字典树中（但不需要创建新的子节点）。如果在查询的过程中发现某个节点为空（未被初始化），则说明该字符串在字典树中不存在。如果成功遍历到最后一个字符所对应的节点，并且该节点标记为结束字符，则表明该字符串在字典树中存在；反之，如果最后一个字符对应的节点不是结束字符，则表明该字符串在字典树中不存在。所以 <strong> 在查询过程中，我们需要注意判断节点是否为空以及最后一个字符对应节点的结束字符标记</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">trieSearch</span><span class="params">(Trie *obj, <span class="type">char</span> *word)</span> &#123;</span><br><span class="line">    Trie* curr = obj;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; word[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> index = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;children[index] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr-&gt;isEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从根节点开始遍历字符串的每一个字符：</p>
<ul>
<li>首先，根据字符计算出在子节点数组中的索引位置：
<ul>
<li>如果对应位置的子节点为空，则表示字典树中没有该字符串；</li>
<li>如果对应位置的子节点非空，则将当前节点更新为新节点，继续后续字符的判断；</li>
</ul>
</li>
<li>最后，根据结束字符的状态，返回字符串是否存在。</li>
</ul>
<h3 id="字典树前缀查询">字典树前缀查询</h3>
<p>前缀查询的过程也是在字典树已经建立好的情况下进行的。与查询字符串的过程类似，我们仍然是逐个字符地搜索并检查它们是否存在于字典树中。不同之处在于，前缀查询不需要判断前缀字符串的最后一个字符是否是结束字符，只要能成功遍历到最后一个字符，就可以确认该前缀字符串存在于字典树中。</p>
<blockquote>
<p>因为字典树的特点是每个节点都存储了字符集中的每个字符的子节点，所以只要前缀字符串中的每个字符都在字典树中存在对应的子节点，就可以确定该前缀字符串存在于字典树中。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">trieStartsWith</span><span class="params">(Trie *obj, <span class="type">char</span> *prefix)</span> &#123;</span><br><span class="line">    Trie* curr = obj;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; prefix[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> index = prefix[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;children[index] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字典树释放">字典树释放</h3>
<p>字典树释放的过程需要释放 <strong> 每个 </strong> 节点的 <strong> 所有子节点 </strong> 的空间。如果某个节点的子节点不为空，则需要继续深入该子节点，释放它的子节点的空间，直到最底层的叶子节点。然后再回溯到上一层节点，继续释放它的其他子节点，直到所有节点的空间都被释放完毕。所以字典树的释放过程是一个递归地释放每个节点的所有子节点的过程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trieFree</span><span class="params">(Trie *obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUMS; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj-&gt;children[i]) &#123;</span><br><span class="line">            trieFree(obj-&gt;children[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完整字典树代码">完整字典树代码</h3>
<p>上面的代码汇总在一起就是完整的字典树的最基础的版本了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUMS (26)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> *<span class="title">children</span>[<span class="title">NUMS</span>];</span>  <span class="comment">// 子节点指针数组，用于存储子节点的指针</span></span><br><span class="line">    <span class="type">bool</span> isEnd;  <span class="comment">// 表示当前节点是否为一个单词的结束节点</span></span><br><span class="line">    <span class="type">char</span> padding[<span class="number">7</span>];  <span class="comment">// 用于字节对齐的占位</span></span><br><span class="line">&#125; Trie;</span><br><span class="line"></span><br><span class="line">Trie* <span class="title function_">trieCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    Trie *node = (Trie *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Trie));</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to create a trie node\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;sizeof(Trie) = %d\n&quot;, sizeof(Trie));  // x64, 216</span></span><br><span class="line">    <span class="built_in">memset</span>(node-&gt;children, <span class="number">0</span>, <span class="keyword">sizeof</span>(Trie));</span><br><span class="line">    node-&gt;isEnd = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trieInsert</span><span class="params">(Trie *obj, <span class="type">char</span> *word)</span> &#123;</span><br><span class="line">    Trie* curr = obj;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; word[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> index = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;children[index] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Trie* child = trieCreate();</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;failed to create a new trie\r\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr-&gt;children[index] = child;</span><br><span class="line">            curr-&gt;children[index]-&gt;isEnd = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    curr-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">trieSearch</span><span class="params">(Trie *obj, <span class="type">char</span> *word)</span> &#123;</span><br><span class="line">    Trie* curr = obj;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; word[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> index = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;children[index] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr-&gt;isEnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">trieStartsWith</span><span class="params">(Trie *obj, <span class="type">char</span> *prefix)</span> &#123;</span><br><span class="line">    Trie* curr = obj;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; prefix[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> index = prefix[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;children[index] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trieFree</span><span class="params">(Trie *obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUMS; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj-&gt;children[i]) &#123;</span><br><span class="line">            trieFree(obj-&gt;children[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    Trie *root = trieCreate();</span><br><span class="line"></span><br><span class="line">    trieInsert(root, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line">    trieInsert(root, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search apple: %s\n&quot;</span>, trieSearch(root, <span class="string">&quot;apple&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search banana: %s\n&quot;</span>, trieSearch(root, <span class="string">&quot;banana&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search car: %s\n&quot;</span>, trieSearch(root, <span class="string">&quot;car&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search prefix bana: %s\n&quot;</span>, trieStartsWith(root, <span class="string">&quot;bana&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    trieFree(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度">复杂度</h3>
<p>时间复杂度：初始化为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，其余操作为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|S|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|S|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">∣</span></span></span></span> 是每次插入或查询的字符串的长度。</p>
<p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>T</mi><mi mathvariant="normal">∣</mi><mo>×</mo><mi mathvariant="normal">Σ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|T| \times \Sigma)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Σ</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>T</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|T|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord">∣</span></span></span></span> 为所有插入字符串的长度之和，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span> 为字符集的大小。</p>
<h2 id="为什么根节点不包含任何字符">为什么根节点不包含任何字符</h2>
<p>字典树的根节点不包含任何字符是为了保持数据结构的一致性和简洁性。每个节点代表一个字符，根节点是整个字典树的起始点，它并不代表具体的字符。</p>
<ul>
<li>如果根节点包含一个字符，那么在插入和搜索操作时就需要额外的处理逻辑。例如，在搜索一个字符串时，需要先判断根节点的字符是否匹配，然后再进入下一层的子节点进行匹配。这样的处理逻辑会增加代码的复杂性。</li>
<li>而将根节点作为一个特殊的节点，不包含任何字符，可以简化操作。在搜索一个字符串时，直接从根节点开始匹配 <strong> 下一层的子节点</strong>（<code>node-&gt;children[x]</code>）即可，不需要额外的判断逻辑。这样的设计使得字典树的实现更加简单和统一。</li>
</ul>
<h2 id="为什么字典树空间复杂度相对较高">为什么字典树空间复杂度相对较高</h2>
<p>字典树是一种以空间换时间的数据结构（空间复杂度相对较高）。这是因为 <strong> 它需要存储每个节点的子节点指针 </strong>，具体来说，字典树的空间复杂度与字典树中存储的字符串数量和字符串的平均长度相关。<strong> 每个节点都需要存储一个指向下一个字符节点的指针</strong>，而每个字符串的字符数量会决定树的深度。因此，当字典树中包含大量的字符串或者字符串的平均长度较长时，字典树的空间复杂度就相对较高。</p>
<h2 id="哈希表实现的字典树">哈希表实现的字典树</h2>
<p>字典树基础版很容易，但很可能会出现一些延伸。</p>
<p>对于上面是 26 个字符的，我们很容易用 ASCII 找到对应索引，如果字符可能性比较多，用数组可能浪费的空间比较大，那我们也可以用哈希表实现字典树。使用哈希表替代数组，其实逻辑是一样的，只需要判断时候用哈希表判断是否存在对应的 key 即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uthash/src/uthash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    +-----------------------+</span></span><br><span class="line"><span class="comment">    |         Trie          |</span></span><br><span class="line"><span class="comment">    +-----------------------+</span></span><br><span class="line"><span class="comment">    |   ch                  |</span></span><br><span class="line"><span class="comment">    |   isEnd               |      +-----------------------+</span></span><br><span class="line"><span class="comment">    |   children            | ---&gt; |         Trie          |</span></span><br><span class="line"><span class="comment">    |   hh                  |      +-----------------------+</span></span><br><span class="line"><span class="comment">    +-----------------------+</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> *<span class="title">children</span>;</span></span><br><span class="line">    UT_hash_handle hh;</span><br><span class="line">&#125; Trie;</span><br><span class="line"></span><br><span class="line">Trie* <span class="title function_">trieCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    Trie *node = (Trie *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Trie));</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to create a trie node\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;ch = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    node-&gt;isEnd = <span class="literal">false</span>;</span><br><span class="line">    node-&gt;children = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trieInsert</span><span class="params">(Trie *root, <span class="type">char</span> *word)</span> &#123;</span><br><span class="line">    Trie *curr = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; word[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        Trie *child = <span class="literal">NULL</span>;</span><br><span class="line">        HASH_FIND(hh, curr-&gt;children, &amp;word[i], <span class="keyword">sizeof</span>(<span class="type">char</span>), child);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            child = trieCreate();</span><br><span class="line">            child-&gt;ch = word[i];</span><br><span class="line">            HASH_ADD(hh, curr-&gt;children, ch, <span class="keyword">sizeof</span>(<span class="type">char</span>), child);</span><br><span class="line">        &#125;</span><br><span class="line">        curr = child;</span><br><span class="line">    &#125;</span><br><span class="line">    curr-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">trieSearch</span><span class="params">(Trie *root, <span class="type">char</span> *word)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trie *curr = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; word[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        Trie *child = <span class="literal">NULL</span>;</span><br><span class="line">        HASH_FIND(hh, curr-&gt;children, &amp;word[i], <span class="keyword">sizeof</span>(<span class="type">char</span>), child);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr-&gt;isEnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">trieStartsWith</span><span class="params">(Trie *root, <span class="type">char</span> *prefix)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trie *curr = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; prefix[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        Trie *child = <span class="literal">NULL</span>;</span><br><span class="line">        HASH_FIND(hh, curr-&gt;children, &amp;prefix[i], <span class="keyword">sizeof</span>(<span class="type">char</span>), child);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trieFree</span><span class="params">(Trie *root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Trie *curr, *tmp;</span><br><span class="line">    HASH_ITER(hh, root-&gt;children, curr, tmp) &#123;</span><br><span class="line">        trieFree(curr-&gt;children);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    Trie *root = trieCreate();</span><br><span class="line"></span><br><span class="line">    trieInsert(root, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line">    trieInsert(root, <span class="string">&quot;+861**01[]&#x27;;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search apple: %s\n&quot;</span>, trieSearch(root, <span class="string">&quot;apple&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search +861**01[]&#x27;;/: %s\n&quot;</span>, trieSearch(root, <span class="string">&quot;+861**01[]&#x27;;/&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search car: %s\n&quot;</span>, trieSearch(root, <span class="string">&quot;car&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search prefix app: %s\n&quot;</span>, trieStartsWith(root, <span class="string">&quot;app&quot;</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    trieFree(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面为程序运行的结果。可以看到，使用哈希表实现字典树，可以处理的字符种类不再是仅限于英文字母。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Search apple: Found</span><br><span class="line">Search +861**01[]&#x27;;/: Found</span><br><span class="line">Search car: Not Found</span><br><span class="line">Search prefix app: Found</span><br></pre></td></tr></table></figure>
<p>关于 <code>HASH_FIND</code>、<code>HASH_ADD</code> 和 <code>HASH_ITER</code> 的使用可以看 <a href="https://troydhanson.github.io/uthash/userguide.html#_general_macros"> 这里</a>。</p>
<blockquote>
<p>参考连接：<a href="https://segmentfault.com/a/1190000040801084">https://segmentfault.com/a/1190000040801084</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>字典树</category>
      </categories>
      <tags>
        <tag>字典树</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式基础</title>
    <url>/posts/231213183051.html</url>
    <content><![CDATA[<p>正则表达式（Regular Expression）是表示搜索模式的字符串，常缩写成 Regex 或 Regexp。它常用于匹配、查找和替换文本中的字词。此外，我们可以测试文本是否符合我们设置的规则。</p>
<span id="more"></span>
<h1 id="正则符号汇总">正则符号汇总</h1>
<ol>
<li>
<p>锚点：</p>
<ul>
<li><code>^</code>：匹配字符串或行的开头。</li>
<li><code>$</code>：匹配字符串或行的末尾。</li>
<li><code>\b</code>：匹配单词的开头或末尾。</li>
<li><code>\B</code>：匹配不在单词开头或末尾的位置。</li>
</ul>
</li>
<li>
<p>字符类：</p>
<ul>
<li><code>[abc]</code>：匹配不在集合中的任意字符。</li>
<li><code>[a-z]</code>：匹配两个字符之间的任意字符，包括它们本身。</li>
<li><code>.</code>：匹配除换行符外的任意字符。</li>
<li><code>\w</code>：匹配字母、数字或下划线字符。</li>
<li><code>\W</code>：匹配除字母、数字和下划线之外的任意字符。</li>
<li><code>\d</code>：匹配所有数字字符。</li>
<li><code>\D</code>：匹配除数字外的任意字符。</li>
<li><code>\s</code>：匹配所有空白字符。</li>
<li><code>\S</code>：匹配除空白字符以外的任意字符。</li>
</ul>
</li>
<li>
<p>标志：</p>
<ul>
<li><code>g</code>：确保表达式不会在检索到第一个匹配项时停止，即全局匹配。</li>
<li><code>i</code>：使表达式忽略大小写。</li>
<li><code>m</code>：如果不启用，<code>^</code> 和 <code>$</code> 只匹配首行字符串的开始和结束，而不会单独匹配每一行。</li>
</ul>
</li>
<li>
<p>量词与分支：</p>
<ul>
<li><code>*</code>：表达式匹配零个或多个。</li>
<li><code>+</code>：表达式匹配一个或多个。</li>
<li><code>&#123;1,3&#125;</code>：表达式匹配指定范围的位数，区间为左闭右闭。</li>
<li><code>&#123;1,&#125;</code>：表达式至少匹配的位数。</li>
<li><code>?</code>：使 <code>?</code> 前面的字符可选，即可以有或没有（零次或一次）。</li>
<li><code>|</code>：类似于「或」，用于匹配多种符合条件的表达式之一。</li>
</ul>
</li>
<li>
<p>组和引用：</p>
<ul>
<li><code>()</code>：使表达式分组。</li>
<li><code>\1</code>：引用表达式的分组，数字表示为第几个分组。</li>
<li><code>(?:)</code>：创建无法引用的非捕获分组。它不是捕获分组，所以不能使用 <code>\1</code> 这种反向引用操作。</li>
</ul>
</li>
<li>
<p>零宽断言：</p>
<ul>
<li><code>(?=)</code>：正向先行断言，就是断言后面的字符是否满足断言指定的模式，满足则匹配成功。</li>
<li><code>(?!)</code>：负向先行断言，就是断言后面的字符是否满足断言指定的模式，不满足则匹配成功。</li>
<li><code>(?&lt;=)</code>：正向后行断言，就是断言前面的字符是否满足断言指定的模式，满足则匹配成功。</li>
<li><code>(?&lt;!)</code>：负向后行断言，就是断言前面的字符是否满足断言指定的模式，不满足则匹配成功。</li>
</ul>
</li>
</ol>
<h1 id="锚点">锚点</h1>
<h2 id="（字符串或行的开头）"><code>^</code>（字符串或行的开头）</h2>
<p><code>^</code>：匹配字符串或行的开头。</p>
<p>示例一：</p>
<ul>
<li>文本：<code><span style="background-color: #90EE90;"><b>an</b></span> answer or a question</code></li>
<li>正则：<code>/^\w+/g</code></li>
<li>解释：匹配字符串开头的单词（单词定义为包括字母、数字、下划线）。</li>
<li><a href="https://regex101.com/r/au5hjw/1">在线练习</a></li>
</ul>
<h2 id="（字符串或行的末尾）"><code>$</code>（字符串或行的末尾）</h2>
<p><code>$</code>：匹配字符串或行的末尾。</p>
<p>示例一：</p>
<ul>
<li>文本：<code>an answer or a <span style="background-color: #90EE90;"><b>question</b></span></code></li>
<li>正则：<code>/\w+$/g</code></li>
<li>解释：匹配字符串末尾的单词。</li>
<li><a href="https://regex101.com/r/40n0TP/2">在线练习</a></li>
</ul>
<h2 id="b（单词边界）"><code>\b</code>（单词边界）</h2>
<p><code>\b</code>：匹配单词的开头或末尾。</p>
<p>示例一：</p>
<ul>
<li>文本：<code>two ques<span style="background-color: #90EE90;"><b>tions</b></span> or three ques<span style="background-color: #90EE90;"><b>tions</b></span></code></li>
<li>正则：<code>/tions\b/g</code></li>
<li><a href="https://regex101.com/r/SoEUVG/1">在线练习</a></li>
</ul>
<p>示例二：</p>
<ul>
<li>文本：<code>two <span style="background-color: #90EE90;"><b>qu</b></span>estions or three <span style="background-color: #90EE90;"><b>qu</b></span>estions</code></li>
<li>正则：<code>/\bqu/g</code></li>
<li><a href="https://regex101.com/r/Vo5SW3/1">在线练习</a></li>
</ul>
<p>示例三：</p>
<ul>
<li>文本：<code>two questions or three questions</code></li>
<li>正则：<code>/\bes/g</code></li>
<li><a href="https://regex101.com/r/rrJlYO/1">在线练习</a></li>
</ul>
<h2 id="B（非单词边界）"><code>\B</code>（非单词边界）</h2>
<p><code>\B</code>：匹配不在单词开头或末尾的位置。</p>
<p>示例一：</p>
<ul>
<li>文本：<code>an a<span style="background-color: #90EE90;"><b>n</b></span>swer or a question</code></li>
<li>正则：<code>/n\B/g</code></li>
<li>解释：匹配不是单词结尾的 <code>n</code>。</li>
<li><a href="https://regex101.com/r/D63vfX/1">在线练习</a></li>
</ul>
<p>示例二：</p>
<ul>
<li>文本：<code>a<span style="background-color: #90EE90;"><b>n</b></span> a<span style="background-color: #90EE90;"><b>n</b></span>swer or a questio<span style="background-color: #90EE90;"><b>n</b></span></code></li>
<li>正则：<code>/\Bn/g</code></li>
<li>解释：匹配不是单词开头的 <code>n</code>。</li>
<li><a href="https://regex101.com/r/JA4h9M/1">在线练习</a></li>
</ul>
<h1 id="字符类">字符类</h1>
<h2 id="abc-（字符集）"><code>[abc]</code>（字符集）</h2>
<p><code>[abc]</code>：匹配集合中的任意字符。</p>
<p>示例一：</p>
<ul>
<li>文本：<code>car <span style="background-color: #90EE90;"><b>ber</b></span> bir <span style="background-color: #90EE90;"><b>bor</b></span> bd bood boedr bur</code></li>
<li>正则：<code>/b[oe]r/g</code></li>
<li>解释：匹配开头是 <code>b</code>、结尾是 <code>r</code>、中间 <strong> 一个 </strong> 字符是 <code>o</code> 或 <code>e</code> 的字符串。</li>
<li><a href="https://regex101.com/r/ppbzZl/1">在线练习</a></li>
</ul>
<h2 id="abc-（否定字符集）"><code>[^abc]</code>（否定字符集）</h2>
<p><code>[abc]</code>：匹配不在集合中的任意字符。</p>
<p>示例一：</p>
<ul>
<li>文本：<code>car ber <span style="background-color: #90EE90;"><b>bir</b></span> bor bd bood boedr <span style="background-color: #90EE90;"><b>bur</b></span></code></li>
<li>正则：<code>/b[^oe]r/g</code></li>
<li>解释：匹配开头是 <code>b</code>、结尾是 <code>r</code>、中间 <strong> 一个 </strong> 字符不是 <code>o</code> 或 <code>e</code> 的字符串。</li>
<li><a href="https://regex101.com/r/jB9a5c/1">在线练习</a></li>
</ul>
<h2 id="a-z-（范围）"><code>[a-z]</code>（范围）</h2>
<p><code>[a-z]</code>：匹配两个字符之间的任意字符，包括它们本身。</p>
<p>示例一：</p>
<ul>
<li>文本：<code>a<span style="background-color: #90EE90;"><b>bcde</b></span>f <span style="background-color: #90EE90;"><b>b</b></span> <span style="background-color: #90EE90;"><b>ec</b></span> <span style="background-color: #90EE90;"><b>e</b></span>m<span style="background-color: #90EE90;"><b>c</b></span></code></li>
<li>正则：<code>/[b-e]/g</code></li>
<li><a href="https://regex101.com/r/Vje0dj/1">在线练习</a></li>
</ul>
<h2 id="（点）"><code>.</code>（点）</h2>
<p><code>.</code>：匹配除换行符外的任意字符。</p>
<p>示例一：</p>
<ul>
<li>文本：<code><span style="background-color: #90EE90;"><b>hi012_-!?</b></span></code></li>
<li>正则：<code>/./g</code></li>
<li><a href="https://regex101.com/r/QUomQr/1">在线练习</a></li>
</ul>
<h2 id="w（单词）"><code>\w</code>（单词）</h2>
<p><code>\w</code>：匹配字母、数字或下划线字符。</p>
<p>示例一：</p>
<ul>
<li>文本：<code><span style="background-color: #90EE90;"><b>hi</b></span> <span style="background-color: #90EE90;"><b>01</b></span>?<span style="background-color: #90EE90;"><b>2</b></span> <span style="background-color: #90EE90;"><b>_</b></span>-!?</code></li>
<li>正则：<code>/\w/g</code></li>
<li><a href="https://regex101.com/r/svsY7f/1">在线练习</a></li>
</ul>
<h2 id="W（非单词）"><code>\W</code>（非单词）</h2>
<p><code>\W</code>：匹配除字母、数字和下划线之外的任意字符。</p>
<p>示例一：</p>
<ul>
<li>文本：<code>hELLo<span style="background-color: #90EE90;"><b> </b></span>01<span style="background-color: #90EE90;"><b>?</b></span>?<span style="background-color: #90EE90;"><b>2</b></span><span style="background-color: #90EE90;"><b> </b></span>_<span style="background-color: #90EE90;"><b>-!?</b></span></code></li>
<li>正则：<code>/\W/g</code></li>
<li><a href="https://regex101.com/r/yPU2XM/1">在线练习</a></li>
</ul>
<h2 id="d（数字）"><code>\d</code>（数字）</h2>
<p><code>\d</code>：匹配所有数字字符。</p>
<p>示例一：</p>
<ul>
<li>文本：<code>+<span style="background-color: #90EE90;"><b>144</b></span>-(<span style="background-color: #90EE90;"><b>22</b></span>)-<span style="background-color: #90EE90;"><b>13</b></span>=<span style="background-color: #90EE90;"><b>0</b></span>x<span style="background-color: #90EE90;"><b>6</b></span>D</code></li>
<li>正则：<code>/\d/g</code></li>
<li><a href="https://regex101.com/r/hKAapH/1">在线练习</a></li>
</ul>
<h2 id="D（非数字）"><code>\D</code>（非数字）</h2>
<p><code>\D</code>：匹配除数字外的任意字符。</p>
<p>示例一：</p>
<ul>
<li>文本：<code><span style="background-color: #90EE90;"><b>+</b></span>144<span style="background-color: #90EE90;"><b>-</b></span><span style="background-color: #90EE90;"><b>(</b></span>22<span style="background-color: #90EE90;"><b>)-</b></span>13<span style="background-color: #90EE90;"><b>=</b></span>0<span style="background-color: #90EE90;"><b>x</b></span>6<span style="background-color: #90EE90;"><b>D</b></span></code></li>
<li>正则：<code>/\D/g</code></li>
<li><a href="https://regex101.com/r/ByqKUX/1">在线练习</a></li>
</ul>
<h2 id="s（空白符）"><code>\s</code>（空白符）</h2>
<p><code>\s</code>：匹配所有空白字符。</p>
<p>示例一：</p>
<ul>
<li>文本：<code>one<span style="background-color: #90EE90;"><b> </b></span>two<span style="background-color: #90EE90;"><b> </b></span>.</code></li>
<li>正则：<code>/\s/g</code></li>
<li><a href="https://regex101.com/r/8Eqf53/1">在线练习</a></li>
</ul>
<h2 id="S（非空白符）"><code>\S</code>（非空白符）</h2>
<p><code>\S</code>：匹配除空白字符以外的任意字符。</p>
<p>示例一：</p>
<ul>
<li>文本：<code><span style="background-color: #90EE90;"><b>one</b></span> <span style="background-color: #90EE90;"><b>two</b></span> <span style="background-color: #90EE90;"><b>.</b></span></code></li>
<li>正则：<code>/\S/g</code></li>
<li><a href="https://regex101.com/r/cv2CF2/1">在线练习</a></li>
</ul>
<h1 id="标志">标志</h1>
<h2 id="g（全局匹配）"><code>g</code>（全局匹配）</h2>
<p><code>g</code>：确保表达式不会在检索到第一个匹配项时停止，即全局匹配。</p>
<p>示例一：</p>
<ul>
<li>文本：<code><span style="background-color: #90EE90;"><b>cat</b></span> dog&amp;<span style="background-color: #90EE90;"><b>cat</b></span></code></li>
<li>正则：<code>/cat/g</code></li>
<li><a href="https://regex101.com/r/UGslHN/1">在线练习</a></li>
</ul>
<p>示例二：</p>
<ul>
<li>文本：<code><span style="background-color: #90EE90;"><b>cat</b></span> dog&amp;cat</code></li>
<li>正则：<code>/cat/</code></li>
<li>解释：无全局标志下，则当检索到第一个匹配项时则停止。</li>
<li><a href="https://regex101.com/r/t8NQpt/1">在线练习</a></li>
</ul>
<h2 id="i（忽略大小写）"><code>i</code>（忽略大小写）</h2>
<p><code>i</code>：使表达式忽略大小写。</p>
<p>示例一：</p>
<ul>
<li>文本：<code><span style="background-color: #90EE90;"><b>CaT</b></span> dog&amp;<span style="background-color: #90EE90;"><b>cat</b></span></code></li>
<li>正则：<code>/cat/gi</code></li>
<li><a href="https://regex101.com/r/xFgnHn/1">在线练习</a></li>
</ul>
<h2 id="m（多行）"><code>m</code>（多行）</h2>
<p><code>m</code>：如果不启用，<code>^</code> 和 <code>$</code> 只匹配首行字符串的开始和结束，而不会单独匹配每一行。</p>
<p>示例一：</p>
<ul>
<li>
<p>文本：</p>
  <p><code>
  <span style="background-color: #90EE90;"><b>a</b></span> black cat
<p>a white cat<br>
</code></p></p>
</li>
<li>
<p>正则：<code>/^a/g</code></p>
</li>
<li>
<p>解释：全局匹配字符串开头是 <code>a</code> 的字符（不能匹配每行字符串开头是 <code>a</code> 的字符）。</p>
</li>
<li>
<p><a href="https://regex101.com/r/ww2ihx/1">在线练习</a></p>
</li>
</ul>
<p>示例二：</p>
<ul>
<li>
<p>文本：</p>
  <p><code>
  a white cat
<p>a black c<span style="background-color: #90EE90;"><b>at</b></span><br>
</code></p></p>
</li>
<li>
<p>正则：<code>/at$/g</code></p>
</li>
<li>
<p>解释：全局匹配字符串结尾是 <code>at</code> 的字符（不能匹配每行字符串结尾是 <code>at</code> 的字符）。</p>
</li>
<li>
<p><a href="https://regex101.com/r/MHiK1b/1">在线练习</a></p>
</li>
</ul>
<p>示例三：</p>
<ul>
<li>
<p>文本：</p>
  <p><code>
  <span style="background-color: #90EE90;"><b>a</b></span> black cat
<p><span style="background-color: #90EE90;"><b>a</b></span> white cat<br>
</code></p></p>
</li>
<li>
<p>正则：<code>/^a/gm</code></p>
</li>
<li>
<p>解释：全局匹配整个字符串 <strong> 每行 </strong> 开头是 <code>a</code> 的字符。</p>
</li>
<li>
<p><a href="https://regex101.com/r/WqkZkE/1">在线练习</a></p>
</li>
</ul>
<p>示例四：</p>
<ul>
<li>
<p>文本：</p>
  <p><code>
  a black c<span style="background-color: #90EE90;"><b>at</b></span>
<p>a white c<span style="background-color: #90EE90;"><b>at</b></span><br>
</code></p></p>
</li>
<li>
<p>正则：<code>/at$/gm</code></p>
</li>
<li>
<p>解释：全局匹配整个字符串 <strong> 每行 </strong> 结尾是 <code>at</code> 的字符。</p>
</li>
<li>
<p><a href="https://regex101.com/r/5HIKtS/1">在线练习</a></p>
</li>
</ul>
<h1 id="量词与分支">量词与分支</h1>
<h2 id="（至少匹配零个）"><code>*</code>（至少匹配零个）</h2>
<p><code>*</code>：表达式匹配零个或多个。</p>
<p>示例一：</p>
<ul>
<li>文本：<code><span style="background-color: #90EE90;"><b>bp</b></span> <span style="background-color: #90EE90;"><b>bep</b></span> <span style="background-color: #90EE90;"><b>beep</b></span></code></li>
<li>正则：<code>/be*p/g</code></li>
<li><a href="https://regex101.com/r/eRmirK/1">在线练习</a></li>
</ul>
<h2 id="（至少匹配一个）"><code>+</code>（至少匹配一个）</h2>
<p><code>+</code>：表达式匹配一个或多个。</p>
<p>示例一：</p>
<ul>
<li>文本：<code>bp <span style="background-color: #90EE90;"><b>bep</b></span> <span style="background-color: #90EE90;"><b>beep</b></span></code></li>
<li>正则：<code>/be+p/g</code></li>
<li><a href="https://regex101.com/r/e9lhy6/1">在线练习</a></li>
</ul>
<h2 id="1-3-（指定范围匹配）"><code>&#123;1,3&#125;</code>（指定范围匹配）</h2>
<p><code>&#123;1,3&#125;</code>：表达式匹配指定范围的位数，区间为左闭右闭。</p>
<p>示例一：</p>
<ul>
<li>文本：<code>bp <span style="background-color: #90EE90;"><b>bep</b></span> <span style="background-color: #90EE90;"><b>beep</b></span></code></li>
<li>正则：<code>/be&#123;1,2&#125;p/g</code></li>
<li><a href="https://regex101.com/r/WAwFPS/1">在线练习</a></li>
</ul>
<h2 id="1-（至少匹配次数）"><code>&#123;1,&#125;</code>（至少匹配次数）</h2>
<p><code>&#123;1,&#125;</code>：表达式至少匹配的位数。</p>
<p>示例一：</p>
<ul>
<li>文本：<code>bp <span style="background-color: #90EE90;"><b>bep</b></span> <span style="background-color: #90EE90;"><b>beep</b></span> <span style="background-color: #90EE90;"><b>beeep</b></span></code></li>
<li>正则：<code>/be&#123;1,&#125;p/g</code></li>
<li><a href="https://regex101.com/r/O3raUe/1">在线练习</a></li>
</ul>
<h2 id="（指定字符可选）"><code>?</code>（指定字符可选）</h2>
<p><code>?</code>：使 <code>?</code> 前面的字符可选，即可以有或没有（零次或一次）。</p>
<p>示例一：</p>
<ul>
<li>文本：<code><span style="background-color: #90EE90;"><b>color</b></span> <span style="background-color: #90EE90;"><b>colour</b></span></code></li>
<li>正则：<code>/colou?r/g</code></li>
<li>解释：单个字符可选。</li>
<li><a href="https://regex101.com/r/QLiuRQ/1">在线练习</a></li>
</ul>
<p>示例二：</p>
<ul>
<li>文本：<code><span style="background-color: #90EE90;"><b>color</b></span> colour <span style="background-color: #90EE90;"><b>cor</b></span></code></li>
<li>正则：<code>/co(lo)?r/g</code></li>
<li>解释：捕获组可选。</li>
<li><a href="https://regex101.com/r/uOGqyM/1">在线练习</a></li>
</ul>
<h2 id="（或分支）"><code>|</code>（或分支）</h2>
<p><code>|</code>：类似于「或」，用于匹配多种符合条件的表达式之一。</p>
<p>示例一：</p>
<ul>
<li>文本：<code>fat, <span style="background-color: #90EE90;"><b>cat</b></span>, <span style="background-color: #90EE90;"><b>rat</b></span></code></li>
<li>正则：<code>/(c|r)at/g</code> 或者 <code>/[cr]at/g</code></li>
<li><a href="https://regex101.com/r/KWyvtQ/1">在线练习</a></li>
</ul>
<h1 id="组和引用">组和引用</h1>
<h2 id="（捕获分组）"><code>()</code>（捕获分组）</h2>
<p><code>()</code>：使表达式分组。</p>
<p>示例一：</p>
<ul>
<li>文本：<code><span style="background-color: #90EE90;"><b>hahaha</b></span>, h, <span style="background-color: #90EE90;"><b>ha</b></span></code></li>
<li>正则：<code>/(ha)+/g</code></li>
<li><a href="https://regex101.com/r/uliqOL/1">在线练习</a></li>
</ul>
<h2 id="1（引用）"><code>\1</code>（引用）</h2>
<p><code>\1</code>：引用表达式的分组，数字表示为第几个分组。</p>
<p>示例一：</p>
<ul>
<li>文本：<code><span style="background-color: #90EE90;"><b>hah</b></span>, haa, <span style="background-color: #90EE90;"><b>dad</b></span>, <span style="background-color: #90EE90;"><b>dad</b></span>a</code></li>
<li>正则：<code>/(\w)a\1/g</code></li>
<li>解释：捕获分组 <code>(\w)</code> 匹配一个字母字符（包括大小写字母、数字和下划线），第二个字符为 <code>a</code>，反向引用 <code>\1</code> 表示引用第一个捕获组中匹配到的内容。该正则匹配字符 <code>a</code> 左右两个字符相等的字符串。</li>
<li><a href="https://regex101.com/r/GJPlNY/1">在线练习</a></li>
</ul>
<p>示例二：</p>
<ul>
<li>文本：<code><span style="background-color: #90EE90;"><b>hah</b></span>, haa, <span style="background-color: #90EE90;"><b>dad</b></span>, <span style="background-color: #90EE90;"><b>woawo</b></span>, <span style="background-color: #90EE90;"><b>dad</b></span>a</code></li>
<li>正则：<code>/(\w+)a\1/g</code></li>
<li>解释：捕获分组 <code>(\w+)</code> 至少匹配一个字母字符，第二个字符为 <code>a</code>，反向引用 <code>\1</code> 表示引用第一个捕获组中匹配到的内容。</li>
<li><a href="https://regex101.com/r/iD6FFt/1">在线练习</a></li>
</ul>
<p>示例三：</p>
<ul>
<li>文本：<code>hah, haa, dad, <span style="background-color: #90EE90;"><b>wobwob</b></span>, <span style="background-color: #90EE90;"><b>dada</b></span></code></li>
<li>正则：<code>/(\w+)([ab])\1\2/g</code></li>
<li><a href="https://regex101.com/r/zz2jSm/1">在线练习</a></li>
</ul>
<h2 id="（非捕获组）"><code>(?:)</code>（非捕获组）</h2>
<p><code>(?:)</code>：创建无法引用的非捕获分组。它不是捕获分组，所以不能使用 <code>\1</code> 这种反向引用操作。</p>
<p>示例一：</p>
<ul>
<li>文本：<code><span style="background-color: #90EE90;"><b>hahaha</b></span>, <span style="background-color: #90EE90;"><b>ha</b></span>h, <span style="background-color: #90EE90;"><b>ha</b></span>a<span style="background-color: #90EE90;"><b>ha</b></span></code></li>
<li>正则：<code>/(?:ha)+/g</code></li>
<li>解释：匹配至少出现一次 <code>ha</code> 的字符串。</li>
<li><a href="https://regex101.com/r/DhG6uE/1">在线练习</a></li>
</ul>
<h1 id="零宽断言">零宽断言</h1>
<h2 id="（断言后面满足给定模式）"><code>(?=)</code>（断言后面满足给定模式）</h2>
<p><code>(?=)</code>：正向先行断言，就是断言后面的字符是否满足断言指定的模式，满足则匹配成功。</p>
<p>示例一：</p>
<ul>
<li>文本：<code>1st, <span style="background-color: #90EE90;"><b>2</b></span>nd, 3pc, <span style="background-color: #90EE90;"><b>4</b></span>nd</code></li>
<li>正则：<code>/\d(?=nd)/g</code></li>
<li>解释：匹配满足一个数字后面紧跟 <code>nd</code> 的那个数字。在 <code>1st</code> 中有数字 <code>1</code>，但是在正向先行断言时，检查到的第一个字符为 <code>s</code>，与断言中的 <code>n</code> 不匹配，这时会停止匹配。</li>
<li><a href="https://regex101.com/r/zO3SzT/1">在线练习</a></li>
</ul>
<blockquote>
<p>正向先行断言记忆：看后面的字符是不是（<code>?</code>）等于（<code>=</code>）断言中的模式，等于则匹配成功。</p>
</blockquote>
<h2 id="（断言后面不满足给定模式）"><code>?!</code>（断言后面不满足给定模式）</h2>
<p><code>(?!)</code>：负向先行断言，就是断言后面的字符是否满足断言指定的模式，不满足则匹配成功。</p>
<p>示例一：</p>
<ul>
<li>文本：<code><span style="background-color: #90EE90;"><b>1</b></span>st, 2nd, <span style="background-color: #90EE90;"><b>3</b></span>pc, <span style="background-color: #90EE90;"><b>4</b></span>ne</code></li>
<li>正则：<code>/\d(?!nd)/g</code></li>
<li>解释：匹配满足一个数字后面紧跟着的不是 <code>nd</code> 的那个数字。</li>
<li><a href="https://regex101.com/r/GeV0jm/1">在线练习</a></li>
</ul>
<blockquote>
<p>负向先行断言记忆：看后面的字符是不是（<code>?</code>）不等于（<code>!</code>）断言中的模式，不等于则匹配成功。</p>
</blockquote>
<h2 id="（断言前面满足给定模式）"><code>?&lt;=</code>（断言前面满足给定模式）</h2>
<p><code>(?&lt;=)</code>：正向后行断言，就是断言前面的字符是否满足断言指定的模式，满足则匹配成功。</p>
<p>示例一：</p>
<ul>
<li>文本：<code>#1, $2, %<span style="background-color: #90EE90;"><b>3</b></span></code></li>
<li>正则：<code>/(?&lt;=%)\d/g</code></li>
<li>解释：匹配满足一个数字前面紧跟 <code>%</code> 的那个数字。</li>
<li><a href="https://regex101.com/r/w4UOLX/1">在线练习</a></li>
</ul>
<blockquote>
<p>正向后行断言记忆：看前面（<code>&lt;</code>）的字符是不是（<code>?</code>）等于（<code>=</code>）断言中的模式，等于则匹配成功。</p>
</blockquote>
<h2 id="（断言前面不满足给定模式）"><code>?&lt;!</code>（断言前面不满足给定模式）</h2>
<p><code>(?&lt;!)</code>：负向后行断言，就是断言前面的字符是否满足断言指定的模式，不满足则匹配成功。</p>
<p>示例一：</p>
<ul>
<li>文本：<code>#<span style="background-color: #90EE90;"><b>1</b></span>, $<span style="background-color: #90EE90;"><b>2</b></span>, %3</code></li>
<li>正则：<code>/(?&lt;!%)\d/g</code></li>
<li>解释：匹配满足一个数字前面紧跟着的不是 <code>%</code> 的那个数字。</li>
<li><a href="https://regex101.com/r/d02Cw0/1">在线练习</a></li>
</ul>
<blockquote>
<p>负向后行断言记忆：看前面（<code>&lt;</code>）的字符是不是（<code>?</code>）不等于（<code>!</code>）断言中的模式，不等于则匹配成功。</p>
</blockquote>
<h1 id="示例：格式化定义">示例：格式化定义</h1>
<p>有时候我们写的代码会不规范，比如指针变量可以写成 <code>int* a;</code> 或者 <code>int * a;</code>，普通变量可以写成 <code>int   a;</code>。</p>
<p>如何写一个正则表达式，来匹配所有不规范，并格式化它呢？</p>
<p>要规范化的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">job</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job</span>*  <span class="title">prev</span>;</span>  <span class="comment">/* pointer to previous job   */</span></span><br><span class="line">    <span class="type">void</span>   (*function)(<span class="type">void</span>* arg);  <span class="comment">/* function pointer          */</span></span><br><span class="line">    <span class="type">void</span>*  arg;  <span class="comment">/* function&#x27;s argument       */</span></span><br><span class="line">    <span class="type">void</span> ** arg2;</span><br><span class="line">    <span class="type">void</span> *a;</span><br><span class="line">&#125; job;</span><br></pre></td></tr></table></figure>
<p>正则表达式：<code>/(?&lt;=\w)\s*(?&lt;!\/)\**\s+/gm</code></p>
<p><a href="https://regex101.com/r/zHSW7X/1">在线练习</a>，这个正则表达式的含义是：</p>
<ul>
<li>
<p><code>(?&lt;=\w)</code>：断言前面是一个单词字符。</p>
</li>
<li>
<p><code>\s*</code>：匹配零个或多个空白字符。</p>
</li>
<li>
<p><code>(?&lt;!\/)</code>：断言前面不是斜杠字符。</p>
</li>
<li>
<p><code>\**</code>：匹配零个或多个星号字符。</p>
</li>
<li>
<p><code>\s+</code>：匹配一个或多个空白字符。</p>
</li>
</ul>
<p>综合起来，这个正则表达式的作用是匹配在单词字符后面，按顺序地：可以有或没有空格、可以有或没有星号（不能是斜杠后面的星号）、至少一个空格。</p>
<p>结果图：</p>
<p><img src="../images/computer-basics/regex-example1.png" alt=""></p>
<p>格式化替换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">replace</span>(<span class="params"><span class="keyword">match</span></span>):</span><br><span class="line">    <span class="comment"># 保持最多一个空格，后面追加匹配到的 * 的个数</span></span><br><span class="line">    word = (<span class="string">&#x27; &#x27;</span> <span class="keyword">if</span> <span class="keyword">match</span>.group(<span class="number">0</span>).count(<span class="string">&#x27; &#x27;</span>) &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span>) + <span class="string">&#x27;*&#x27;</span> * <span class="keyword">match</span>.group(<span class="number">0</span>).count(<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> word</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">normalize</span>(<span class="params">declaration</span>):</span><br><span class="line">    pattern = <span class="string">r&#x27;(?&lt;=\w)\s*(?&lt;!\/)\**\s+&#x27;</span> <span class="comment"># 匹配不规范的定义</span></span><br><span class="line">    declaration = re.sub(pattern, replace, declaration)</span><br><span class="line">    <span class="keyword">return</span> declaration</span><br></pre></td></tr></table></figure>
<p>替换后结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">job</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job</span> *<span class="title">prev</span>;</span>  <span class="comment">/* pointer to previous job */</span></span><br><span class="line">    <span class="type">void</span> (*function)(<span class="type">void</span> *arg);  <span class="comment">/* function pointer */</span></span><br><span class="line">    <span class="type">void</span> *arg;  <span class="comment">/* function&#x27;s argument */</span></span><br><span class="line">    <span class="type">void</span> **arg2;</span><br><span class="line">    <span class="type">void</span> *a;</span><br><span class="line">&#125; job;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://regexlearn.com/zh-cn/cheatsheet">https://regexlearn.com/zh-cn/cheatsheet</a></li>
<li><a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md">https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md</a></li>
<li><a href="https://regex101.com">https://regex101.com</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>源码解读 epoll 实现原理</title>
    <url>/posts/2410232111015.html</url>
    <content><![CDATA[<p>从源码角度来领略一下内核的 epoll 轮询机制。</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kernel/fs/eventpoll.c</span><br><span class="line">kernel/include/linux/poll.h</span><br><span class="line">kernel/include/uapi/linux/eventpoll.h</span><br></pre></td></tr></table></figure>
<h1 id="一、概述">一、概述</h1>
<p>在 Linux 2.6.8 之前还没有 epoll 机制，select 和 poll 作为 I/O 多路复用的机制实现并发程序，但这两种方式有着如下缺点：</p>
<ul>
<li>通过 select 方式单个进程能够监控的 fd 不得超过进程可打开的文件个数上限，默认为 1024，即便强行修改了这个上限，还会遇到性能问题。</li>
<li>select 轮询效率 O(n) 随着监控个数的增加而性能变差。</li>
<li>select 从内核空间返回到用户空间的是整个 fd 数组，应用程序还需要额外再遍历整个数组才知道哪些 fd 触发了相应事件。</li>
</ul>
<p>本文主要介绍 epoll 机制，有不少人可能都知道相比 <a href="http://gityuan.com/2015/12/06/linux_epoll/">select/poll 之下，epoll 有着明显优势</a>，这些优势的底层实现原理又是什么呢？</p>
<blockquote>
<p>epoll 实现原理的流程图见 <a href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93"> 这一小节</a>。</p>
</blockquote>
<h2 id="epoll 函数">epoll 函数</h2>
<p>用户态主要的 epoll 函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event* event)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event* events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="type">__uint32_t</span> events;</span><br><span class="line">    <span class="type">epoll_data_t</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>* ptr;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">uint32_t</span> u32;</span><br><span class="line">    <span class="type">uint64_t</span> u64;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> <span class="title">epoll_data_t</span>;</span></span><br></pre></td></tr></table></figure>
<p>接下来从源码角度剖析这 3 个方法。</p>
<h1 id="二、epoll-create">二、epoll_create</h1>
<p>用户态进程在调用 epoll_create 创建 epoll 句柄 epfd 时，会陷入内核，系统调用 SYSCALL_DEFINE1(epoll_create, int, size) 创建一个 file 实例，同时在内核内部分配 eventpoll 资源，并将其指向 file 实例的 void* private_data 成员下。后续就可以通过 epfd 找到 file，进而找到内核维护的 eventpoll 资源。</p>
<h2 id="2-1-sys-epoll-create">2.1 sys_epoll_create</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE1(epoll_create, <span class="type">int</span>, size) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">return</span> sys_epoll_create1(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>size 仅仅用来检测是否大于 0，并没有真正使用。sys_epoll_create1 过程检查参数，然后再调用 epoll_create1。</p>
<h2 id="2-2-sys-epoll-create1">2.2 sys_epoll_create1</h2>
<p>epoll_create1 的过程主要是创建并初始化 eventpoll 资源，创建 file 实例，并将 ep 放入 file-&gt;private 成员下、file 放在 ep-&gt;file 成员下，以及将 fd 与 file 关联起来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE1(epoll_create1, <span class="type">int</span>, flags) &#123;</span><br><span class="line">    <span class="type">int</span> error, fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span>* <span class="title">ep</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建内部数据结构 eventpoll 【小节 2.3】</span></span><br><span class="line">    error = ep_alloc(&amp;ep);  <span class="comment">// ⭐</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个未使用的 fd</span></span><br><span class="line">    fd = get_unused_fd_flags(O_RDWR | (flags &amp; O_CLOEXEC));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个匿名 inode 文件，使用 eventpoll_fops 文件操作结构，allocl_file() 创建一个 file，</span></span><br><span class="line">    <span class="comment">// 并将 ep 传递给 file，即 file-&gt;private_data = ep ⭐</span></span><br><span class="line">    file = anon_inode_getfile(<span class="string">&quot;[eventpoll]&quot;</span>, &amp;eventpoll_fops, ep, O_RDWR | (flags &amp; O_CLOEXEC));</span><br><span class="line"></span><br><span class="line">    ep-&gt;file = file;</span><br><span class="line">    fd_install(fd, file);  <span class="comment">// 建立 fd 和 file 的关联关系</span></span><br><span class="line">    <span class="keyword">return</span> fd;  <span class="comment">// fd 即 epfd</span></span><br><span class="line"></span><br><span class="line">out_free_fd:</span><br><span class="line">    put_unused_fd(fd);</span><br><span class="line">out_free_ep:</span><br><span class="line">    ep_free(ep);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-ep-alloc">2.3 ep_alloc</h2>
<p>分配 eventpoll 资源、初始化相关成员，并将分配的 eventpoll 资源地址传给入参的二级指针（这样在函数外部，二级指针的值就是刚才分配的资源的地址）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ep_alloc</span><span class="params">(<span class="keyword">struct</span> eventpoll** pep)</span> &#123;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span>* <span class="title">user</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span>* <span class="title">ep</span>;</span>  <span class="comment">// 【小节 2.4.1】</span></span><br><span class="line"></span><br><span class="line">    user = get_current_user();</span><br><span class="line">    error = -ENOMEM;</span><br><span class="line">    ep = kzalloc(<span class="keyword">sizeof</span>(*ep), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!ep))</span><br><span class="line">        <span class="keyword">goto</span> free_uid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相关成员初始化</span></span><br><span class="line">    spin_lock_init(&amp;ep-&gt;lock);</span><br><span class="line">    mutex_init(&amp;ep-&gt;mtx);</span><br><span class="line">    init_waitqueue_head(&amp;ep-&gt;wq);  <span class="comment">// 阻塞进程的等待队列</span></span><br><span class="line">    init_waitqueue_head(&amp;ep-&gt;poll_wait);</span><br><span class="line">    INIT_LIST_HEAD(&amp;ep-&gt;rdllist);  <span class="comment">// 就绪事件列表</span></span><br><span class="line">    ep-&gt;rbr = RB_ROOT;</span><br><span class="line">    ep-&gt;ovflist = EP_UNACTIVE_PTR;</span><br><span class="line">    ep-&gt;user = user;</span><br><span class="line">    *pep = ep;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">free_uid:</span><br><span class="line">    free_uid(user);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4- 相关结构体">2.4 相关结构体</h2>
<p>为了方便后续源码的阅读，这里列举前后文所涉及到的核心 struct。</p>
<img src="/images/linux-kernel/linux-struct-eventpoll.png" alt="eventpoll 相关结构组织关系" width="100%" height="100%">
<h3 id="2-4-1-struct-eventpoll">2.4.1 struct eventpoll</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This structure is stored inside the &quot;private_data&quot; member of the file ⭐</span></span><br><span class="line"><span class="comment"> * structure and represents the main data structure for the eventpoll</span></span><br><span class="line"><span class="comment"> * interface.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Protect the access to this structure */</span></span><br><span class="line">    <span class="type">spinlock_t</span> lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This mutex is used to ensure that files are not removed</span></span><br><span class="line"><span class="comment">     * while epoll is using them. This is held during the event</span></span><br><span class="line"><span class="comment">     * collection loop, the file cleanup path, the epoll file exit</span></span><br><span class="line"><span class="comment">     * code and the ctl operations.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mtx</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait queue used by sys_epoll_wait() */</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> wq;           <span class="comment">// &lt;- 将即将阻塞的进程加入到这个等待队列里 ⭐</span></span><br><span class="line">                                    <span class="comment">// &lt;- 后续 fd 事件触发时，会唤醒这个列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait queue used by file-&gt;poll() */</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> poll_wait;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List of ready file descriptors */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllist</span>;</span>       <span class="comment">// &lt;- 就绪事件的 epi-&gt;rdllist 会链接到这里哦 ⭐</span></span><br><span class="line">                                    <span class="comment">// (epi 中的 ffd 和 event 存储着用户关心的 fd 和 event)</span></span><br><span class="line">                                    <span class="comment">// &lt;- 通过列表判空，高效判断是否有就绪事件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* RB tree root used to store monitored fd structs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rbr</span>;</span>             <span class="comment">// &lt;- 红黑树的根节点，树的节点是 epitem 数据 ⭐</span></span><br><span class="line">                                    <span class="comment">// &lt;- 用红黑树来管理所有用户关心（被监听的）的 fd</span></span><br><span class="line">                                    <span class="comment">// &lt;- 节点排序规则：file 地址和 fd 为第一二优先级</span></span><br><span class="line">                                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                    static inline int ep_cmp_ffd(struct epoll_filefd *p1,</span></span><br><span class="line"><span class="comment">                                                    struct epoll_filefd *p2) &#123;</span></span><br><span class="line"><span class="comment">                                        return (p1-&gt;file &gt; p2-&gt;file ? +1 :</span></span><br><span class="line"><span class="comment">                                                (p1-&gt;file &lt; p2-&gt;file ? -1 : p1-&gt;fd - p2-&gt;fd));&#125;</span></span><br><span class="line"><span class="comment">                                     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This is a single linked list that chains all the &quot;struct epitem&quot; that</span></span><br><span class="line"><span class="comment">     * happened while transferring ready events to userspace w/out</span></span><br><span class="line"><span class="comment">     * holding -&gt;lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span>* <span class="title">ovflist</span>;</span>         <span class="comment">// &lt;- ep-&gt;ovflist = epi in the func &quot;ep_poll_callback&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wakeup_source used when ep_scan_ready_list is running */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wakeup_source</span>* <span class="title">ws</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The user that created the eventpoll descriptor */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span>* <span class="title">user</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">file</span>;</span>              <span class="comment">// &lt;- ep 对应的的文件地址 ⭐</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* used to optimize loop detection check */</span></span><br><span class="line">    <span class="type">int</span> visited;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">visited_list_link</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-2-struct-epitem">2.4.2 struct epitem</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* &lt;- epoll_ctl 的 op=EPOLL_CTL_ADD 时，会往红黑树中插入一个 epitem 节点</span></span><br><span class="line"><span class="comment"> * Each file descriptor added to the eventpoll interface will</span></span><br><span class="line"><span class="comment"> * have an entry of this type linked to the &quot;rbr&quot; RB tree.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> &#123;</span></span><br><span class="line">    <span class="comment">/* RB tree node used to link this structure to the eventpoll RB tree */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rbn</span>;</span>         <span class="comment">// &lt;- 放在首位，可以用于从红黑树中找到节点后，强转得到 epitem 结构</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List header used to link this structure to the eventpoll ready list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllink</span>;</span>   <span class="comment">// &lt;- 事件就绪时，将其链接到 ep-&gt;rdllist 列表下 ⭐</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Works together &quot;struct eventpoll&quot;-&gt;ovflist in keeping the</span></span><br><span class="line"><span class="comment">     * single linked chain of items.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span>* <span class="title">next</span>;</span>        <span class="comment">// &lt;- epi-&gt;next = ep-&gt;ovflist in the func &quot;ep_poll_callback&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The file descriptor information this item refers to */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> <span class="title">ffd</span>;</span>    <span class="comment">// &lt;- 这个节点所属的 eventpoll 文件，ffd.fd 就是 epfd 吧 ⭐</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of active wait queue attached to poll operations */</span></span><br><span class="line">    <span class="type">int</span> nwait;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List containing poll wait queues */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pwqlist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The &quot;container&quot; of this item */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span>* <span class="title">ep</span>;</span>       <span class="comment">// &lt;- 这个节点所属的 eventpoll 的地址 ⭐</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List header used to link this item to the &quot;struct file&quot; items list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">fllink</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wakeup_source used when EPOLLWAKEUP is set */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wakeup_source</span> __<span class="title">rcu</span>* <span class="title">ws</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The structure that describe the interested events and the source fd */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span>   <span class="comment">// &lt;- 从用户态 epool_ctl 拷贝过来的用户关心的事件 ⭐</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-3-struct-epoll-event">2.4.3 struct epoll_event</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    __u32 events;</span><br><span class="line">    __u64 data;</span><br><span class="line">&#125; EPOLL_PACKED;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-4-struct-epoll-filefd">2.4.4 struct epoll_filefd</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">&#125; __packed;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-5-struct-ep-pqueue">2.4.5 struct ep_pqueue</h3>
<p>epoll 优先队列，包含红黑树下对应的节点 epitem 和其对应的 poll 处理函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ep_pqueue</span> &#123;</span></span><br><span class="line">    poll_table pt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-6-struct-poll-table">2.4.6 struct poll_table</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_struct</span> &#123;</span></span><br><span class="line">    poll_queue_proc _qproc;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> _key;</span><br><span class="line">&#125; poll_table;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-7-struct-eppoll-entry">2.4.7 struct eppoll_entry</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eppoll_entry</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">llink</span>;</span>    <span class="comment">// 指向 epi-&gt;pwqlist</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span>* <span class="title">base</span>;</span>       <span class="comment">// 指向 epitem 的地址</span></span><br><span class="line">    <span class="type">wait_queue_t</span> wait;         <span class="comment">// 监视的目标 fd 的等待队列，指定了 fd 就绪时的回调函数 ⭐</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span>* whead;  <span class="comment">// 文件系统中，目标 fd 对应的等待队列头的地址 ⭐</span></span><br><span class="line">                               <span class="comment">// 后面会把 -&gt;wait 挂到 -&gt;whead 下，这样 fd 就绪唤醒 whead 队列时，</span></span><br><span class="line">                               <span class="comment">// 就可以通过 -&gt;wait.func 唤醒回调函数来往 ep-&gt;rdllist 中挂就绪事件</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="三、epoll-ctl">三、epoll_ctl</h1>
<h2 id="3-1-sys-epoll-ctl">3.1 sys_epoll_ctl</h2>
<p>该系统调用主要从 epfd 对应的 file 中获取 eventepoll 数据 ep，然后通过 key=&lt;file, fd&gt; 在 ep-&gt;rbr 中查找节点。根据查找结果 epi 和入参 op 操作进行增加、删除或修改处理分支。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE4(epoll_ctl, <span class="type">int</span>, epfd, <span class="type">int</span>, op, <span class="type">int</span>, fd, <span class="keyword">struct</span> epoll_event __user*, event) &#123;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="type">int</span> full_check = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>, <span class="title">tf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span>* <span class="title">ep</span>;</span>     <span class="comment">// 【小节 2.4.1】</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span>* <span class="title">epi</span>;</span>       <span class="comment">// 【小节 2.4.2】</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epds</span>;</span>  <span class="comment">// 【小节 2.4.3】</span></span><br><span class="line"></span><br><span class="line">    error = -EFAULT;</span><br><span class="line">    <span class="comment">// 如果操作携带事件（不是 EPOLL_CTL_DEL），则将用户空间的 epoll_event 拷贝到内核</span></span><br><span class="line">    <span class="keyword">if</span> (ep_op_has_event(op) &amp;&amp; copy_from_user(&amp;epds, event, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event)))</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line">    f = fdget(epfd);  <span class="comment">// 通过 epfd 获取对应的 fd 结构</span></span><br><span class="line">    tf = fdget(fd);   <span class="comment">// 通过 fd 获取对应的 fd 结构</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标 fd 必须支持 poll，因为后面的代码在文件系统的 poll() 下挂着 ep 的 poll() 处理机制</span></span><br><span class="line">    <span class="keyword">if</span> (!tf.file-&gt;f_op-&gt;poll)</span><br><span class="line">        <span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ep_op_has_event(op))  <span class="comment">// 检查是否允许 EPOLLWAKEUP</span></span><br><span class="line">        ep_take_care_of_epollwakeup(&amp;epds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 epfd 对应的 file 中获取 eventepoll 数据（即 epoll_create 过程创建的 ep） ⭐</span></span><br><span class="line">    ep = f.file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    mutex_lock_nested(&amp;ep-&gt;mtx, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    epi = ep_find(ep, tf.file, fd);  <span class="comment">// 通过 key=&lt;file, fd&gt; 在 ep 的红黑树中查找节点 ⭐</span></span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">        <span class="keyword">case</span> EPOLL_CTL_ADD:  <span class="comment">// 添加操作，要求条目不存在于 rb 树中</span></span><br><span class="line">            <span class="keyword">if</span> (!epi) &#123;</span><br><span class="line">                epds.events |= POLLERR | POLLHUP;  <span class="comment">// 发生错误 | 挂起</span></span><br><span class="line">                <span class="comment">// 申请一个 epitem 节点并设置其 event，然后添加到 ep 下的红黑树中，见【小节 3.2】 ⭐</span></span><br><span class="line">                error = ep_insert(ep, &amp;epds, tf.file, fd, full_check);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (full_check)  <span class="comment">// 进行完整性检查</span></span><br><span class="line">                clear_tfile_check_list();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EPOLL_CTL_DEL:  <span class="comment">// 删除操作，要求条目存在于 rb 树中</span></span><br><span class="line">            <span class="keyword">if</span> (epi)</span><br><span class="line">                error = ep_remove(ep, epi);  <span class="comment">// 见【小节 3.3】</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EPOLL_CTL_MOD:  <span class="comment">// 修改操作，要求条目存在于 rb 树中</span></span><br><span class="line">            <span class="keyword">if</span> (epi) &#123;</span><br><span class="line">                epds.events |= POLLERR | POLLHUP;</span><br><span class="line">                error = ep_modify(ep, epi, &amp;epds);  <span class="comment">// 见【小节 3.4】</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_unlock(&amp;ep-&gt;mtx);</span><br><span class="line">    fdput(tf);  <span class="comment">// 释放 epfd 的引用</span></span><br><span class="line">    fdput(f);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-ep-insert">3.2 ep_insert</h2>
<p>ep_insert 函数用于：</p>
<ol>
<li>初始化 poll table，指定 ep 的回调函数，调用文件系统的 poll 以及挂上的 ep poll 回调处理，检查 fd 文件的状态（可读、可写、挂起…），处理 ep 就绪队列；</li>
<li>将新的监视项（其查找 key=&lt;file, fd&gt;）封装成一个 epitem 对象，插入到 eventepoll 实例 ep 的红黑树中；</li>
<li>若 fd 上有用户关心的事件，按需看看是否需要（能够）唤醒进程。</li>
</ol>
<p>想想，为什么先执行 step1 再执行的 step2 呢？可以反过来吗？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * ep: 内核私有 eventpoll 实例</span></span><br><span class="line"><span class="comment"> * event: 从用户态 epoll_event 事件拷贝到内核态下的事件</span></span><br><span class="line"><span class="comment"> * tfile: 目标文件（作为红黑树插入的第一优先查找 key）</span></span><br><span class="line"><span class="comment"> * fd: 目标文件对应的 fd（作为红黑树插入的第二优先查找 key）</span></span><br><span class="line"><span class="comment"> * full_check: 是否进行完整性检查</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ep_insert</span><span class="params">(<span class="keyword">struct</span> eventpoll* ep, <span class="keyword">struct</span> epoll_event* event, <span class="keyword">struct</span> file* tfile, <span class="type">int</span> fd, <span class="type">int</span> full_check)</span> &#123;</span><br><span class="line">    <span class="type">int</span> error, revents, pwake = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">long</span> user_watches;     <span class="comment">// 当前用户监视的数量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span>* <span class="title">epi</span>;</span>    <span class="comment">// 新分配的监视项，要往红黑树中添加哦</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ep_pqueue</span> <span class="title">epq</span>;</span>  <span class="comment">// 【小节 2.4.5】</span></span><br><span class="line"></span><br><span class="line">    user_watches = atomic_long_read(&amp;ep-&gt;user-&gt;epoll_watches);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(user_watches &gt;= max_user_watches))</span><br><span class="line">        <span class="keyword">return</span> -ENOSPC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从内存池中分配新的监视项</span></span><br><span class="line">    <span class="keyword">if</span> (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造并填充 epi 结构体</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;epi-&gt;rdllink);</span><br><span class="line">    INIT_LIST_HEAD(&amp;epi-&gt;fllink);</span><br><span class="line">    INIT_LIST_HEAD(&amp;epi-&gt;pwqlist);</span><br><span class="line">    epi-&gt;ep = ep;  <span class="comment">// 所属的 eventpoll 实例</span></span><br><span class="line">    ep_set_ffd(&amp;epi-&gt;ffd, tfile, fd);  <span class="comment">// 将 tfile 和 fd 赋值给 ffd 对应成员，ffd 结构体见【小节 2.4.4】 ⭐</span></span><br><span class="line">    epi-&gt;event = *event;  <span class="comment">// 记录从用户态拷贝到内核的事件 ⭐</span></span><br><span class="line">    epi-&gt;nwait = <span class="number">0</span>;</span><br><span class="line">    epi-&gt;next = EP_UNACTIVE_PTR;  <span class="comment">// 设置为无效值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果包含 EPOLLWAKEUP，则创建一个唤醒源；否则初始化为 NULL</span></span><br><span class="line">    <span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLWAKEUP) &#123;</span><br><span class="line">        error = ep_create_wakeup_source(epi);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        RCU_INIT_POINTER(epi-&gt;ws, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    epq.epi = epi;</span><br><span class="line">    <span class="comment">// 初始化 poll table【小节 3.2.1 &amp; 3.2.3】 ⭐</span></span><br><span class="line">    init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 file-&gt;poll 方法【小节 3.2.2】，返回满足条件的事件类型 ⭐</span></span><br><span class="line">    revents = ep_item_poll(epi, &amp;epq.pt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁，将当前的 epi 与目标 file 关联起来</span></span><br><span class="line">    spin_lock(&amp;tfile-&gt;f_lock);</span><br><span class="line">    list_add_tail_rcu(&amp;epi-&gt;fllink, &amp;tfile-&gt;f_ep_links);</span><br><span class="line">    spin_unlock(&amp;tfile-&gt;f_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前 epi 添加到 RB 树（比较的 key 已经存在 epi-&gt;ffd 里了哦）⭐</span></span><br><span class="line">    ep_rbtree_insert(ep, epi);</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">// 添加操作这会儿，如果就存在满足的就绪事件 并且 epi 的就绪队列无数据（链表为空）</span></span><br><span class="line">    <span class="comment">// 那么，就链接节点到 ep-&gt;rdllist 列表中，并唤醒调用 epoll_wait() 的进程</span></span><br><span class="line">    <span class="keyword">if</span> ((revents &amp; event-&gt;events) &amp;&amp; !ep_is_linked(&amp;epi-&gt;rdllink)) &#123;</span><br><span class="line">        list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);  <span class="comment">// 添加节点到 ep-&gt;rdllist 列表中 ⭐</span></span><br><span class="line">        ep_pm_stay_awake(epi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒正在等待事件就绪的进程（即调用 epoll_wait 的进程）⭐</span></span><br><span class="line">        <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">            wake_up_locked(&amp;ep-&gt;wq);</span><br><span class="line">        <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">            pwake++;  <span class="comment">// 唤醒计数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line">    atomic_long_inc(&amp;ep-&gt;user-&gt;epoll_watches);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pwake)</span><br><span class="line">        ep_poll_safewake(&amp;ep-&gt;poll_wait);  <span class="comment">// 唤醒等待 eventpoll 文件就绪的进程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-1-init-poll-funcptr">3.2.1 init_poll_funcptr</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">init_poll_funcptr</span><span class="params">(poll_table* pt, poll_queue_proc qproc)</span> &#123;</span><br><span class="line">    pt-&gt;_qproc = qproc;</span><br><span class="line">    pt-&gt;_key = ~<span class="number">0UL</span>; <span class="comment">/* all events enabled */</span>  <span class="comment">// &lt;- 一个初始化而已，后面用时还会重新赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ep_insert 中，将 ep_pqueue 结构的 pt 成员中的_qproc 设置为 ep_ptable_queue_proc 函数。</p>
<h3 id="3-2-2-ep-item-poll">3.2.2 ep_item_poll</h3>
<p>f_op-&gt;poll() 就是调用 <a href="https://www.bluepuni.com/archives/epoll-in-depth#f_op-poll"> 文件系统的 poll 方法</a>，不同驱动设备实现方法略有不同，但都会执行 poll_wait()。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">ep_item_poll</span><span class="params">(<span class="keyword">struct</span> epitem* epi, poll_table* pt)</span> &#123;</span><br><span class="line">    pt-&gt;_key = epi-&gt;event.events;  <span class="comment">// &lt;- 重新赋值</span></span><br><span class="line">    <span class="comment">// 调用文件系统的 poll 核心方法【小节 3.2.3】 ⭐</span></span><br><span class="line">    <span class="keyword">return</span> epi-&gt;ffd.file-&gt;f_op-&gt;poll(epi-&gt;ffd.file, pt) &amp; epi-&gt;event.events;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>poll_wait() 会调用 epq.pt.qproc 所对应的回调函数 ep_ptable_queue_proc，其主要工作是初始化等待队列项 pwq-&gt;wait 的唤醒函数为 ep_poll_callback()，并把 pwq-&gt;wait 挂到文件系统对应的等待队列头 whead 下，源码如下所示。由此，当目标 fd 的就绪事件到来时，就会调用 ep_poll_callback() 函数。</p>
<h3 id="3-2-3-ep-ptable-queue-proc">3.2.3 ep_ptable_queue_proc</h3>
<p>该函数设置 pwq-&gt;wait 的成员 func 的唤醒回调函数为 ep_poll_callback，并将 pwq-&gt;wait 添加到 fd 的 whead 中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 用于处理文件的等待队列</span></span><br><span class="line"><span class="comment"> * file: 这里是 epi-&gt;ffd.file</span></span><br><span class="line"><span class="comment"> * whead: 【文件】的等待队列头</span></span><br><span class="line"><span class="comment"> * pt: 轮询的回调处理函数表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ep_ptable_queue_proc</span><span class="params">(<span class="keyword">struct</span> file* file, <span class="type">wait_queue_head_t</span>* whead, poll_table* pt)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span>* <span class="title">epi</span> =</span> ep_item_from_epqueue(pt);  <span class="comment">// 从 ep_pqueue 中获取 epi</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eppoll_entry</span>* <span class="title">pwq</span>;</span>  <span class="comment">// 【小节 2.4.7】</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从内存池中分配一个新的 eppoll_entry 条目</span></span><br><span class="line">    <span class="keyword">if</span> (epi-&gt;nwait &gt;= <span class="number">0</span> &amp;&amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) &#123;</span><br><span class="line">        <span class="comment">// 初始化等待队列项的唤醒回调函数 ⭐</span></span><br><span class="line">        init_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback);  <span class="comment">// 【小节 3.2.4】</span></span><br><span class="line">        pwq-&gt;whead = whead;  <span class="comment">// 记录文件 fd 的等待队列头</span></span><br><span class="line">        pwq-&gt;base = epi;</span><br><span class="line">        <span class="comment">// 将等待项 pwq-&gt;wait（内含 fd 就绪时的回调函数 ep_poll_callback）头插到 fd 的 whead 中 ⭐</span></span><br><span class="line">        add_wait_queue(whead, &amp;pwq-&gt;wait);</span><br><span class="line">        <span class="comment">// 将 pwq-&gt;llink 放入 epi-&gt;pwqlist 的尾部</span></span><br><span class="line">        list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist);</span><br><span class="line">        epi-&gt;nwait++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        epi-&gt;nwait = <span class="number">-1</span>;  <span class="comment">// 标记错误发生</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the &quot;struct epitem&quot; from an epoll queue wrapper */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> epitem* <span class="title function_">ep_item_from_epqueue</span><span class="params">(poll_table* p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> container_of(p, <span class="keyword">struct</span> ep_pqueue, pt)-&gt;epi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">init_waitqueue_func_entry</span><span class="params">(<span class="type">wait_queue_t</span>* q, <span class="type">wait_queue_func_t</span> func)</span> &#123;</span><br><span class="line">    q-&gt;flags = <span class="number">0</span>;</span><br><span class="line">    q-&gt;private = <span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;func = func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-4-ep-poll-callback">3.2.4 ep_poll_callback</h3>
<p>ep_poll_callback 函数核心功能是当目标 fd 的就绪事件到来时，将 fd 对应的 epitem 实例添加到 ep 就绪队列，并唤醒正在等待在 epoll_wait() 上的进程。这样，内核就会将 ep 就绪队列中的 event 报告给用户态应用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the callback that is passed to the wait queue wakeup</span></span><br><span class="line"><span class="comment"> * mechanism. It is called by the stored file descriptors when they</span></span><br><span class="line"><span class="comment"> * have events to report.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ep_poll_callback</span><span class="params">(<span class="type">wait_queue_t</span>* wait, <span class="type">unsigned</span> mode, <span class="type">int</span> sync, <span class="type">void</span>* key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pwake = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span>* <span class="title">epi</span> =</span> ep_item_from_wait(wait);  <span class="comment">// 从 eppoll_entry 中获取 epi</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span>* <span class="title">ep</span> =</span> epi-&gt;ep;                <span class="comment">// 从 epi 中获取 ep</span></span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果正在将事件传递给用户空间，我们不能持有锁</span></span><br><span class="line"><span class="comment">     * （因为我们正在访问用户内存，以及 linux f_op-&gt;poll() 语义）</span></span><br><span class="line"><span class="comment">     * 在那段时间内调用 epool_ctl 发生的所有事件，</span></span><br><span class="line"><span class="comment">     * 都链接在 ep-&gt;ovflist 中并在稍后重新入队（加入红黑树中）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(ep-&gt;ovflist != EP_UNACTIVE_PTR)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (epi-&gt;next == EP_UNACTIVE_PTR) &#123;</span><br><span class="line">            epi-&gt;next = ep-&gt;ovflist;</span><br><span class="line">            ep-&gt;ovflist = epi;</span><br><span class="line">            <span class="keyword">if</span> (epi-&gt;ws) &#123;</span><br><span class="line">                __pm_stay_awake(ep-&gt;ws);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If this file is already in the ready list we exit soon */</span></span><br><span class="line">    <span class="keyword">if</span> (!ep_is_linked(&amp;epi-&gt;rdllink)) &#123;</span><br><span class="line">        <span class="comment">// 将 epi 就绪事件插入到 ep 就绪队列 ⭐</span></span><br><span class="line">        list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">        ep_pm_stay_awake_rcu(epi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果活跃（有进程在等待），唤醒调用 epoll_wait() 而阻塞的进程 ⭐</span></span><br><span class="line">    <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">        wake_up_locked(&amp;ep-&gt;wq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">        pwake++;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="keyword">if</span> (pwake)</span><br><span class="line">        ep_poll_safewake(&amp;ep-&gt;poll_wait);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)key &amp; POLLFREE) &#123;</span><br><span class="line">        list_del_init(&amp;wait-&gt;task_list);  <span class="comment">// 删除相应的 wait</span></span><br><span class="line">        smp_store_release(&amp;ep_pwq_from_wait(wait)-&gt;whead, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断等待队列是否为空</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">waitqueue_active</span><span class="params">(<span class="type">wait_queue_head_t</span>* q)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !list_empty(&amp;q-&gt;task_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<details>
  <summary>ep_remove 和 ep_modify（点击展开）</summary>
<h2 id="3-3-ep-remove">3.3 ep_remove</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ep_remove</span><span class="params">(<span class="keyword">struct</span> eventpoll* ep, <span class="keyword">struct</span> epitem* epi)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">file</span> =</span> epi-&gt;ffd.file;</span><br><span class="line"></span><br><span class="line">    ep_unregister_pollwait(ep, epi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Remove the current item from the list of epoll hooks */</span></span><br><span class="line">    spin_lock(&amp;file-&gt;f_lock);</span><br><span class="line">    list_del_rcu(&amp;epi-&gt;fllink);</span><br><span class="line">    spin_unlock(&amp;file-&gt;f_lock);</span><br><span class="line"></span><br><span class="line">    rb_erase(&amp;epi-&gt;rbn, &amp;ep-&gt;rbr);</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="keyword">if</span> (ep_is_linked(&amp;epi-&gt;rdllink))</span><br><span class="line">        list_del_init(&amp;epi-&gt;rdllink);</span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    wakeup_source_unregister(ep_wakeup_source(epi));</span><br><span class="line">    call_rcu(&amp;epi-&gt;rcu, epi_rcu_free);</span><br><span class="line">    atomic_long_dec(&amp;ep-&gt;user-&gt;epoll_watches);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-4-ep-modify">3.4 ep_modify</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ep_modify</span><span class="params">(<span class="keyword">struct</span> eventpoll* ep, <span class="keyword">struct</span> epitem* epi, <span class="keyword">struct</span> epoll_event* event)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pwake = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> revents;</span><br><span class="line">    poll_table pt;</span><br><span class="line"></span><br><span class="line">    init_poll_funcptr(&amp;pt, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    epi-&gt;event.events = event-&gt;events; <span class="comment">/* need barrier below */</span></span><br><span class="line">    epi-&gt;event.data = event-&gt;data;     <span class="comment">/* protected by mtx */</span></span><br><span class="line">    <span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLWAKEUP) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ep_has_wakeup_source(epi))</span><br><span class="line">            ep_create_wakeup_source(epi);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ep_has_wakeup_source(epi)) &#123;</span><br><span class="line">        ep_destroy_wakeup_source(epi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    smp_mb();</span><br><span class="line"></span><br><span class="line">    revents = ep_item_poll(epi, &amp;pt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (revents &amp; event-&gt;events) &#123;</span><br><span class="line">        spin_lock_irq(&amp;ep-&gt;lock);</span><br><span class="line">        <span class="keyword">if</span> (!ep_is_linked(&amp;epi-&gt;rdllink)) &#123;</span><br><span class="line">            list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">            ep_pm_stay_awake(epi);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Notify waiting tasks that events are available */</span></span><br><span class="line">            <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">                wake_up_locked(&amp;ep-&gt;wq);</span><br><span class="line">            <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">                pwake++;</span><br><span class="line">        &#125;</span><br><span class="line">        spin_unlock_irq(&amp;ep-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We have to call this outside the lock */</span></span><br><span class="line">    <span class="keyword">if</span> (pwake)</span><br><span class="line">        ep_poll_safewake(&amp;ep-&gt;poll_wait);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="四、epoll-wait">四、epoll_wait</h1>
<h2 id="4-1-sys-epoll-wait">4.1 sys_epoll_wait</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE4(epoll_wait, <span class="type">int</span>, epfd, <span class="keyword">struct</span> epoll_event __user*, events, <span class="type">int</span>, maxevents, <span class="type">int</span>, timeout) &#123;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span>* <span class="title">ep</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// #define EP_MAX_EVENTS (INT_MAX / sizeof(struct epoll_event))</span></span><br><span class="line">    <span class="keyword">if</span> (maxevents &lt;= <span class="number">0</span> || maxevents &gt; EP_MAX_EVENTS)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查用户空间传递的内存是否可写，因为后面内核要拷贝就绪事件到用户内存</span></span><br><span class="line">    <span class="keyword">if</span> (!access_ok(VERIFY_WRITE, events, maxevents * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event)))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 epfd 对应的 file，进而通过 file 的 private_data 拿到 eventpoll 实例 ⭐</span></span><br><span class="line">    f = fdget(epfd);</span><br><span class="line">    ep = f.file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    error = ep_poll(ep, events, maxevents, timeout);  <span class="comment">// 【小节 4.2】 ⭐</span></span><br><span class="line"></span><br><span class="line">error_fput:</span><br><span class="line">    fdput(f);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-ep-poll">4.2 ep_poll</h2>
<p>该函数主要做以下几件事：</p>
<ol>
<li>判断被监听的 fds 中是否有就绪的 fd，如果有就返回（序号 4&amp;5）。</li>
<li>如果没有就把当前进程添加到 epoll 的等待队列中，并且进入睡眠。</li>
<li>进程会一直睡眠直到有以下几种情况发生：
<ul>
<li>被监听的 fds 中有就绪的事件；</li>
<li>设置了 timeout 并且超时了；</li>
<li>接收到中断信号。</li>
</ul>
</li>
<li>如果有就绪的文件，那么就调用 ep_send_events() 函数把就绪事件复制到入参指定的用户空间的 events 数组中。</li>
<li>返回就绪文件的个数。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ep_poll</span><span class="params">(<span class="keyword">struct</span> eventpoll* ep, <span class="keyword">struct</span> epoll_event __user* events, <span class="type">int</span> maxevents, <span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, eavail, timed_out = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">long</span> slack = <span class="number">0</span>;</span><br><span class="line">    <span class="type">wait_queue_t</span> wait;</span><br><span class="line">    <span class="type">ktime_t</span> expires, *to = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;  <span class="comment">// 超时设置</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">end_time</span> =</span> ep_set_mstimeout(timeout);</span><br><span class="line">        slack = select_estimate_accuracy(&amp;end_time);</span><br><span class="line">        to = &amp;expires;</span><br><span class="line">        *to = timespec_to_ktime(end_time);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// timeout 等于 0 为非阻塞操作，此处避免不必要的等待队列循环</span></span><br><span class="line">        timed_out = <span class="number">1</span>;</span><br><span class="line">        spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">        <span class="keyword">goto</span> check_events;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">fetch_events:</span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有事件就绪则进入睡眠状态，当事件就绪后可通过 ep_poll_callback() 来唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (!ep_events_available(ep)) &#123;  <span class="comment">// 【小节 4.2.1】</span></span><br><span class="line">        <span class="comment">// 初始化当前进程 current 的 wait 等待队列项 ⭐</span></span><br><span class="line">        init_waitqueue_entry(&amp;wait, current);  <span class="comment">// 【小节 4.2.2】</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前进程加入 ep-&gt;wq 等待队列，等待文件就绪、超时或中断信号 ⭐</span></span><br><span class="line">        __add_wait_queue_exclusive(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">            <span class="comment">// 有就绪队列或者超时，则跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (ep_events_available(ep) || timed_out)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 有待处理信号，则跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">                res = -EINTR;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line">            <span class="comment">// 主动出让 CPU，从这里开始进入睡眠状态</span></span><br><span class="line">            <span class="keyword">if</span> (!freezable_schedule_hrtimeout_range(to, slack, HRTIMER_MODE_ABS))</span><br><span class="line">                timed_out = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有 3 种情况会执行到这里：从等待队列中移除该进程、设置进程为运行态 ⭐</span></span><br><span class="line">        <span class="comment">// 1. 被监听的 fds 中有就绪的事件、2. 设置了 timeout 并且超时了、3. 接收到中断信号</span></span><br><span class="line">        __remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line">        set_current_state(TASK_RUNNING);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">check_events:</span><br><span class="line">    eavail = ep_events_available(ep);</span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 尝试传输就绪事件到用户空间，如果没有获取就绪事件，但还未超时，会再次 fetch_events ⭐</span></span><br><span class="line"><span class="comment">     * 1. eavail == 0 ? 返回 0 个就绪事件</span></span><br><span class="line"><span class="comment">     * 2. res == 0 ? 尝试传输就绪事件到用户空间（数量为 res 值）</span></span><br><span class="line"><span class="comment">     * 3. 尝试后 res == 0 ? 传输了 0 个或传输失败，未超时下则转向 fetch_events : 返回 res</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!res &amp;&amp; eavail &amp;&amp; !(res = ep_send_events(ep, events, maxevents)) &amp;&amp; !timed_out)</span><br><span class="line">        <span class="keyword">goto</span> fetch_events;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-1-ep-events-available">4.2.1 ep_events_available</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// eventpoll 就绪列表不为空 或 暂存列表不为空</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">ep_events_available</span><span class="params">(<span class="keyword">struct</span> eventpoll* ep)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !list_empty(&amp;ep-&gt;rdllist) || ep-&gt;ovflist != EP_UNACTIVE_PTR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-2-init-waitqueue-entry">4.2.2 init_waitqueue_entry</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">init_waitqueue_entry</span><span class="params">(<span class="type">wait_queue_t</span>* q, <span class="keyword">struct</span> task_struct* p)</span> &#123;</span><br><span class="line">    q-&gt;flags = <span class="number">0</span>;</span><br><span class="line">    q-&gt;private = p;</span><br><span class="line">    q-&gt;func = default_wake_function;  <span class="comment">// 设置等待队列项的唤醒函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="五、总结">五、总结</h1>
<ol>
<li>epoll_create()：获取一个未使用的 fd 作为 epfd，创建并初始化 eventpoll 结构体 ep，并将 ep 放入 file-&gt;private、file 放入 ep-&gt;file，最后将 file 与 fd 关联起来并返回 fd。</li>
<li>epoll_ctl()：以插入 epi 为例（进入 ep_insert 函数）。
<ul>
<li>init_poll_funcptr()：将 ep_pqueue-&gt;pt 的成员变量_qproc 设置为 ep_ptable_queue_proc 函数，用于文件系统中 poll_wait()的回调函数；</li>
<li>ep_item_poll()：通过这个函数，执行上面设置的 ep_ptable_queue_proc 回调函数；</li>
<li>ep_ptable_queue_proc()：将 pwq-&gt;wait 的成员变量 func 的唤醒回调函数设置为 ep_poll_callback——这是用于文件系统中有就绪事件触发时，唤醒进程所用的回调函数。再将 pwq-&gt;wait 添加到文件的等待队列头 whead 中——在就绪时，就能通过 wq 头找到 wq 项，在 wq 项中获取并执行 func 回调函数。</li>
</ul>
</li>
<li>epoll_wait()：主要工作是执行 ep_poll()方法。
<ul>
<li>设置将要阻塞的 current 进程的等待队列项，其唤醒函数为 default_wake_function()，然后将其加入 ep-&gt;wq；</li>
<li>freezable_schedule_hrtimeout_range()：出让 CPU，进入睡眠状态；</li>
<li>等待被唤醒。</li>
</ul>
</li>
</ol>
<p>之后，当其他进程的就绪事件发生时便会唤醒相应等待队列上的进程。比如监控的是可写事件，则会在 write()方法中调用 wake_up 方法唤醒相对应的等待队列上的进程，当唤醒后执行前面设置的唤醒回调函数 ep_poll_callback 函数。</p>
<ol>
<li>ep_poll_callback()：目标 fd 的就绪事件到来时，将 epi-&gt;rdllink 加入 ep-&gt;rdllist 的队列，导致 rdlist 不空，从而进程被唤醒，epoll_wait 得以继续执行。</li>
<li>回到 epoll_wait()，从队列中移除 wait，再传输就绪事件到用户空间。</li>
</ol>
<p>epoll 比 select 更高效的一点是：epoll 监控的每一个文件 fd 就绪事件触发，导致相应 fd 上的回调函数 ep_poll_callback()被调用。</p>
<img src="/images/linux-kernel/linux-epoll-principle.png" alt="Linux 内核的 epoll 实现原理" width="100%" height="100%">
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="http://gityuan.com/2019/01/06/linux-epoll/">http://gityuan.com/2019/01/06/linux-epoll/</a></li>
<li><a href="https://www.bilibili.com/video/BV12p4y1372v/">https://www.bilibili.com/video/BV12p4y1372v/</a></li>
<li><a href="https://github.com/liexusong/linux-source-code-analyze/blob/master/epoll-principle.md">https://github.com/liexusong/linux-source-code-analyze/blob/master/epoll-principle.md</a></li>
<li><a href="https://www.bluepuni.com/archives/epoll-in-depth/">https://www.bluepuni.com/archives/epoll-in-depth/</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>epoll</tag>
        <tag>IO多路复用</tag>
      </tags>
  </entry>
  <entry>
    <title>解密内存屏障</title>
    <url>/posts/240919200410.html</url>
    <content><![CDATA[<p>内存屏障（Memory Barrier）是 <strong> 一种同步机制，用于保证多线程编程中内存操作顺序的正确性 </strong>。这在多核处理器和现代复杂架构中尤为重要。内存屏障通过限制或重排序内存操作，<strong> 防止编译器或处理器对指令的重排序，以确保某些特定顺序的操作被严格按照程序员所指定的顺序执行</strong>。</p>
<span id="more"></span>
<p>内存屏障是一种底层原语，在不同计算机架构下有不同的实现细节。本文主要在 x86_64 处理器下，通过 Linux 及其内核代码来分析和使用内存屏障。</p>
<p>对大多数应用层开发者来说，“内存屏障”（Memory Barrier）是一种陌生，甚至有些诡异的技术。实际上，它常被用在操作系统内核中，<strong>用于实现同步机制 </strong>、驱动程序等。<strong> 利用它，能实现高效的无锁数据结构，提高多线程程序的性能表现</strong>。</p>
<p>本文首先探讨了内存屏障的必要性，之后介绍如何使用内存屏障实现一个无锁环形缓冲区（队列），用于在多个线程间进行高效的数据交换。</p>
<h2 id="理解内存屏障">理解内存屏障</h2>
<p>不少开发者并不理解一个事实——<u>程序实际运行时很可能并不完全按照开发者编写的顺序访问内存</u>。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = r;</span><br><span class="line">y = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>这里，y = 1 很可能先于 x = r 执行。这就是内存乱序访问。</p>
<p>内存乱序访问行为出现的理由是为了提升程序运行时的性能。<strong>编译器和 CPU 都可能引起内存乱序访问</strong>：</p>
<ul>
<li>编译时，编译器优化进行指令重排而导致内存乱序访问；</li>
<li>运行时，多 CPU 间交互引入内存乱序访问。</li>
</ul>
<p>编译器和 CPU 引入内存乱序访问通常不会带来什么问题，但在一些特殊情况下（主要是多线程程序中），逻辑的正确性依赖于内存访问顺序。这时，内存乱序访问会带来逻辑上的错误，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// thread 0</span></span><br><span class="line"><span class="keyword">while</span> (!ok);</span><br><span class="line"><span class="keyword">do</span>(x);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// thread 1</span></span><br><span class="line">x = <span class="number">42</span>;</span><br><span class="line">ok = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>ok 初始化为 0，线程 0 等待 ok 被设置为 1 后执行 do 函数。</p>
<p>假如，线程 1 对内存的写操作乱序执行，也就是 x 赋值晚于 ok 赋值完成，那么 do 函数接受的实参很有可能出乎开发者的意料，不为 42。</p>
<p>我们可以引入内存屏障来避免上述问题的出现。内存屏障能让 CPU 或者编译器在内存访问上有序。<strong>一个内存屏障之前的内存访问操作必定先于其之后的完成</strong>。</p>
<p>内存屏障包括两类：编译器屏障和 CPU 内存屏障。</p>
<h2 id="编译时内存乱序访问">编译时内存乱序访问</h2>
<h3 id="优化前">优化前</h3>
<p>编译器对代码做出优化时，可能改变实际执行指令的顺序（例如 gcc 下 -O2 或 -O3 都可能会改变实际执行指令的顺序），看一个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.c</span></span><br><span class="line"><span class="type">int</span> x, y, r;</span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    x = r;</span><br><span class="line">    y = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <a href="https://godbolt.org/">Compiler Explorer</a> 直接编译源文件：<em>gcc -g -o output.s -masm=intel -fno-verbose-asm -S -fdiagnostics-color=always example.c</em>。我们得到相关的汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x:</span><br><span class="line">        .zero   4                       ; 定义全局变量，占用 4 字节，初值为 0</span><br><span class="line">y:</span><br><span class="line">        .zero   4</span><br><span class="line">r:</span><br><span class="line">        .zero   4</span><br><span class="line">f:</span><br><span class="line">        push    rbp                     ; 保存当前栈基指针 (rbp) 到栈中。</span><br><span class="line">        mov     rbp, rsp                ; 更新 rbp 为当前栈顶指针(rsp)，便于函数内部的栈帧管理</span><br><span class="line">        mov     eax, DWORD PTR r[rip]   ; 更新 eax 为读取的全局变量 r 的值</span><br><span class="line">        mov     DWORD PTR x[rip], eax   ; 更新全局变量 x 为 eax 寄存器的值</span><br><span class="line">        mov     DWORD PTR y[rip], 1     ; 更新全局变量 y 为值 1</span><br><span class="line">        nop                             ; 空指令</span><br><span class="line">        pop     rbp                     ; 函数退出序列：从栈中恢复之前保存的栈基指针</span><br><span class="line">        ret                             ; 返回到函数调用，使用栈上的返回地址</span><br></pre></td></tr></table></figure>
<p>这里我们可以看到，x = r 和 y = 1 并没有乱序执行。现使用优化选项 -O2/-O3 编译上面的代码（gcc -O2 …），生成汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f:</span><br><span class="line">        mov     DWORD PTR y[rip], 1     ; y = 1</span><br><span class="line">        mov     eax, DWORD PTR r[rip]</span><br><span class="line">        mov     DWORD PTR x[rip], eax   ; x = r</span><br><span class="line">        ret</span><br><span class="line">r:</span><br><span class="line">        .zero   4</span><br><span class="line">y:</span><br><span class="line">        .zero   4</span><br><span class="line">x:</span><br><span class="line">        .zero   4</span><br></pre></td></tr></table></figure>
<p>我们可以清楚地看到经过编译器优化之后，y = 1 先于 x = r 执行，这意味着，编译器优化导致了内存乱序访问。</p>
<p><strong>避免内存乱序行为的办法就是使用编译器屏障（又叫优化屏障）。Linux 内核提供了函数 barrier()，用于让编译器保证其之前的内存访问先于其之后的内存访问完成</strong>。</p>
<blockquote>
<p>这个强制保证顺序的需求在哪里？换句话说乱序会带来什么问题？一个线程执行了 y = 1 , 但实际上 x = r 还没有执行完成，此时被另一个线程抢占，另一个线程执行，发现 y=1，以为此时 x 必定等于 r，执行相应逻辑，造成错误。</p>
</blockquote>
<h3 id="内核 barrier">内核 barrier()</h3>
<p>内核实现的编译器屏障 barrier()如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> barrier() __asm__ __volatile__(<span class="string">&quot;&quot;</span>: : :<span class="string">&quot;memory&quot;</span>)</span></span><br></pre></td></tr></table></figure>
<p>这是一个宏定义，在嵌入式编程或内核编程中经常使用。这个宏用于创建一个编译器内存屏障。</p>
<ul>
<li><code>__asm__</code>: 在 GCC 中，<code>__asm__</code> 是用来插入内联汇编代码的关键字。</li>
<li><code>__volatile__</code>: 该关键字表明所插入的汇编代码是 “volatile” 的，告诉编译器不要优化这段代码，即使它看起来没有做任何有用的事情。</li>
<li><code>&quot;&quot;</code>: 空字符串，表示没有实际的汇编指令。</li>
</ul>
<p>输入和输出操作数：</p>
<p><code>: : : &quot;memory&quot;</code>: 这是内联汇编语法中用来指定输入、输出、和被修改的寄存器或内存位置的部分。</p>
<ul>
<li>第一个冒号后面为空，表示没有输出操作数。</li>
<li>第二个冒号后面为空，表示没有输入操作数。</li>
<li>第三个冒号后面是 “memory”，表示这段内联汇编代码可能会影响内存。</li>
</ul>
<p>标记 <code>&quot;memory&quot;</code> 有以下几个主要作用：</p>
<ol>
<li><strong>内存屏障</strong>：它告诉编译器，这段汇编代码可能会访问或修改内存。因此，编译器在优化时不能对这段代码前后的内存访问进行重排序。</li>
<li><strong>确保代码顺序</strong>：编译器在遇到这段代码时，不会将这段代码前后的内存操作优化到其它位置。它会严格保持内存操作的顺序。</li>
</ol>
<p>这样做的原因是为了确保某些关键内存操作在修改和访问内存时不会被编译器的优化机制打乱顺序。特别是在多线程编程和操作系统开发中，内存屏障非常重要，以确保内存访问的一致性和正确性。</p>
<h3 id="优化后">优化后</h3>
<p>现在把此编译器屏障 barrier()加入代码中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> barrier() __asm__ __volatile__(<span class="string">&quot;&quot;</span>: : :<span class="string">&quot;memory&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x, y, r;</span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    x = r;</span><br><span class="line">    barrier();</span><br><span class="line">    y = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再编译（使用优化选项 -O2 或 -O3），就会发现内存乱序访问已经不存在了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f:</span><br><span class="line">        mov     eax, DWORD PTR r[rip]</span><br><span class="line">        mov     DWORD PTR x[rip], eax   ; x = r</span><br><span class="line">        mov     DWORD PTR y[rip], 1     ; y = 1</span><br><span class="line">        ret</span><br><span class="line">r:</span><br><span class="line">        .zero   4</span><br><span class="line">y:</span><br><span class="line">        .zero   4</span><br><span class="line">x:</span><br><span class="line">        .zero   4</span><br></pre></td></tr></table></figure>
<p>除了 barrier()函数外，本例还可以使用 volatile 这个关键字来避免编译时内存乱序访问（且仅能避免编译时的乱序访问），为什么呢？</p>
<p>可以参考前面部分的说明，编译器对于 volatile 声明究竟做了什么。<strong>volatile 关键字对于编译器而言，是开发者告诉编译器，这个变量内存的修改，可能不在你的可视范围内（比如被硬件或其他线程修改），不要对这个变量相关的代码进行优化，必须每次都从内存中实际读取或写入</strong>。</p>
<p>volatile 关键字能让 volatile 变量之间的内存访问上有序（仅指编译器行为保证的有序，不包括处理器行为导致的乱序），这里可以修改 x 和 y 的定义来解决问题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> x, y, r;</span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    x = r;</span><br><span class="line">    y = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 volatile 关键字，使得 x 相对 y、y 相对 x 在内存访问上是有序的。</p>
<p>实际上，在 Linux 内核中，ACCESS_ONCE 宏就是通过 volatile 使得编译器在对连续使用 ACCESS_ONCE 访问一些变量时，避免对这些访问进行指令重排。它通过类型转换和解引用的方式，将变量视为 volatile，确保从内存中直接读取或写入。</p>
<p>避免编译器指令重排的第三个修改方案：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ACCESS_ONCE(x) (*(volatile typeof(x) *)&amp;(x))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x, y, r;</span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    ACCESS_ONCE(x) = r;</span><br><span class="line">    ACCESS_ONCE(y) = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，基本上就阐述完成了编译时内存乱序访问的问题。下面看看 CPU 会有怎样的行为。</p>
<h2 id="运行时内存乱序访问">运行时内存乱序访问</h2>
<h3 id="乱序处理器">乱序处理器</h3>
<p>运行时，CPU 本身是会乱序执行指令的。</p>
<p>早期的处理器为有序处理器（in-order processors），总是按开发者编写的顺序执行指令，如果指令的输入操作对象（input operands）不可用（通常由于需要从内存中获取），那么处理器不会转而执行那些输入操作对象可用的指令，而是等待当前输入操作对象可用。相比之下，乱序处理器（out-of-order processors）会先处理那些有可用输入操作对象的指令（而非顺序执行）从而避免了等待，提高了效率。</p>
<p>现代计算机上，<strong>处理器运行的速度比内存访问快很多</strong>，有序处理器花在等待可用数据的时间里已可处理大量指令了。</p>
<p>即便现代处理器会乱序执行，但在单个 CPU 上，指令能通过指令队列顺序地获取并执行，结果利用队列顺序返回寄存器堆（详情可参考 <a href="http://en.wikipedia.org/wiki/Out-of-order_execution"> 这里</a>），这使得程序执行时所有的内存访问操作看起来像是按程序代码编写的顺序执行的。因此，内存屏障是没有必要使用的（前提是不考虑编译器优化的情况下）。</p>
<h3 id="SMP 架构">SMP 架构</h3>
<p>SMP（对称多处理，Symmetric Multiprocessing）是一种计算机体系结构，旨在提高系统的处理能力和容错性。<strong>这种架构中的多个处理器共享同一个内存以及 I/O 系统</strong>，每个处理器都能对称且并行地运行操作系统和应用程序。</p>
<p><strong>SMP 架构需要内存屏障的进一步解释</strong>：</p>
<p>从体系结构上来看，首先在 SMP 架构下，每个 CPU 与内存之间，都配有自己的高速缓存（Cache），以减少访问内存时的冲突。</p>
<img src="../images/sys-net-program/smp-arch.png" alt="SMP 架构" width="50%" height="50%">
<p>采用高速缓存（Cache）的写操作有两种模式：</p>
<ol>
<li>穿透（Write through）模式：每次写时，都直接将数据写回内存中，效率相对较低。</li>
<li>回写（Write back）模式：写的时候先写回 Cache，然后由 Cache 的硬件在周转复用缓冲线 (Cache Line) 时自动将数据写回内存，或者由软件主动地“冲刷”有关的缓冲线。</li>
</ol>
<p>出于性能的考虑，系统往往采用的是 Write back 模式来完成数据写入。正是由于存在 Cache 这一层，正是由于采用了 Write back 模式的数据写入，才导致 <strong> 在 SMP 架构下，对 Cache 的运用可能改变对内存操作的顺序</strong>。</p>
<p>以上面的一个简短代码为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// thread 0 - 在 CPU0 上运行</span></span><br><span class="line">x = <span class="number">42</span>;</span><br><span class="line">ok = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// thread 1 – 在 CPU1 上运行</span></span><br><span class="line"><span class="keyword">while</span>(!ok);</span><br><span class="line">print(x);</span><br></pre></td></tr></table></figure>
<p>这里 CPU1 执行时， x 一定是打印出 42 吗？让我们来看看以下图为例的说明：</p>
<img src="../images/sys-net-program/smp-multithread.png" alt="SMP 架构多线程访问共享内存" width="50%" height="50%">
<p>假设，正好 CPU0 的 Cache 中有 x，此时 CPU0 仅仅是将 x=42 写入到了 Cache 中，另外一个 ok 也在 Cache 中，但由于周转复用高速缓冲线（Cache Line）而导致将 ok=1 刷回到了内存中。此时 CPU1 首先执行对 ok 内存的读取操作，他读到了 ok 为 1 的结果，进而跳出循环，读取 x 的内容，但此时，由于实际写入的 x(42)还只在 CPU0 的 Cache 中，导致 CPU1 读到的数据为 x(17)。</p>
<p><strong>程序中编排好的内存访问顺序（指令序：program ordering）是先写入 x，再写入 ok。而实际上出现在该 CPU 外部，即系统总线上的次序（处理器序：processor ordering）却是先写入 ok，再写入 x（这个例子中 x(42)还未写入）</strong>。</p>
<p><strong>在 SMP 架构中，每个 CPU 都只知道自己何时会改变内存的内容，但是都不知道其它 CPU 会在什么时候改变内存的内容，也不知道自己本地的 Cache 中的内容是否与内存中的内容不一致。反过来，每个 CPU 都可能因为改变了内存内容，而使得其与其它 CPU 的 Cache 的内容不一致了</strong>。</p>
<p>在 SMP 架构下，由于 Cache 的存在而导致的内存访问次序（读或写都有可能顺序被改变）的改变很有可能影响到 CPU 间的同步与互斥。因此需要有一种手段，使得在某些操作之前，把这种“欠下”的内存操作（本例中的 x=42 的内存写入）全都最终地、物理地完成，就好像把欠下的债都结清，然后再开始新的（通常是比较重要的）活动一样。这种手段就是 <strong> 内存屏障，其本质原理就是对系统总线加锁</strong>。</p>
<h3 id="非 SMP 架构">非 SMP 架构</h3>
<p>回过头来，我们再来看看为什么非 SMP 架构（UP 架构）下，运行时内存乱序访问不存在。</p>
<p>在单处理器架构下，各个进程在宏观上是并行的，但是在微观上却是串行的，因为在同一时间点上，只有一个进程真正在运行（系统中只有一个处理器）。在这种情况下，我们再来看看上面提到的例子：</p>
<img src="../images/sys-net-program/non-smp-arch-multithread.png" alt="非 SMP 架构多线程访问共享内存" width="50%" height="50%">
<p>thread 0 和 thread 1 的指令都将在 CPU0 上按照指令序执行。thread 0 通过 CPU0 完成 x=42 的 Cache 写入后，再将 ok=1 写入内存，此后串行的将 thread 0 换出，thread 1 换入，即使此时 x=42 并未写入内存，但由于 thread 1 的执行仍然是在 CPU0 上执行，他仍然访问的是 CPU0 的 Cache。因此，即使 x=42 还未写回到内存中，thread 1 势必还是先从 Cache 中读到 x=42，再从内存中读到 ok=1。</p>
<p>综上所述，在单 CPU 上，多线程执行不存在运行时内存乱序访问，我们从内核源码也可得到类似结论（代码不完全摘录）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> barrier() __asm__ __volatile__(<span class="string">&quot;&quot;</span>: : :<span class="string">&quot;memory&quot;</span>) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mb() alternative(<span class="string">&quot;lock; addl $0,0(%%esp)&quot;</span>, <span class="string">&quot;mfence&quot;</span>, X86_FEATURE_XMM2) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rmb() alternative(<span class="string">&quot;lock; addl $0,0(%%esp)&quot;</span>, <span class="string">&quot;lfence&quot;</span>, X86_FEATURE_XMM2)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP       <span class="comment">// 是 SMP 架构</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> smp_mb() mb() </span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> smp_rmb() rmb() </span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> smp_wmb() wmb() </span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> smp_read_barrier_depends() read_barrier_depends() </span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> set_mb(var, value) do &#123; (void) xchg(&amp;var, value); &#125; while (0) </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span>                  <span class="comment">// 非 SMP 架构：即仅使用编译器屏障即可保证内存访问顺序</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> smp_mb() barrier() </span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> smp_rmb() barrier() </span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> smp_wmb() barrier() </span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> smp_read_barrier_depends() do &#123; &#125; while(0) </span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> set_mb(var, value) do &#123; var = value; barrier(); &#125; while (0) </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这里可看到对内存屏障的定义，如果是 SMP 架构，smp_mb 定义为 mb()，mb()为 CPU 内存屏障（接下来要谈的），而非 SMP 架构时（也就是 UP 架构），直接使用编译器屏障 barrier，运行时内存乱序访问并不存在。</p>
<h3 id="多 CPU 乱序原因">多 CPU 乱序原因</h3>
<p>为什么多 CPU 情况下会存在内存乱序访问？</p>
<p>我们知道每个 CPU 都存在 Cache，当一个特定数据第一次被其它 CPU 获取时，此数据显然不在对应 CPU 的 Cache 中（这就是 Cache Miss）。</p>
<p>这意味着 CPU 要从内存中获取数据（这个过程需要 CPU 等待数百个周期），此数据将被加载到 CPU 的 Cache 中，这样后续就能直接从 Cache 上快速访问。</p>
<p>当某个 CPU 进行写操作时，他必须确保其它 CPU 已将此数据从他们的 Cache 中移除（以便保证一致性），只有在移除操作完成后，此 CPU 才能安全地修改数据。</p>
<p>显然，存在多个 Cache 时，必须通过一个 Cache 一致性协议来避免数据不一致的问题，而这个通信的过程就可能导致乱序访问的出现，也就是运行时内存乱序访问。</p>
<p>受篇幅所限，这里不再深入讨论整个细节，有兴趣的读者可以研究《Memory Barriers: a Hardware View for Software Hackers》这篇文章，它详细地分析了整个过程。</p>
<p>现在通过一个例子来直观地说明多 CPU 下内存乱序访问的问题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> x, y, r1, r2;</span><br><span class="line"><span class="comment">// thread 0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">run0</span><span class="params">()</span> &#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    r1 = y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// thread 1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">run1</span><span class="params">()</span> &#123;</span><br><span class="line">    y = <span class="number">1</span>;</span><br><span class="line">    r2 = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变量均被初始化为 0，run0 和 run1 运行在不同的线程中。如果 run0 和 run1 在同一个 cpu 下执行完成，那么就如我们所料，r1 和 r2 的值不会同时为 0（原因见 <a href="/posts/240919200410.html#%E9%9D%9E%20SMP%20%E6%9E%B6%E6%9E%84"> 非 SMP 架构小节</a>）。如果 run0 和 run1 在不同的 CPU 下执行完成后，内存访问可以被 CPU 或编译器重排序，导致不同的执行顺序，这时 r1 和 r2 可能同时为 0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// r1=0, r2=0</span></span><br><span class="line">Thread <span class="number">1</span>:   r1 = y;         x = <span class="number">1</span>;</span><br><span class="line">Thread <span class="number">2</span>:           r2 = x;         y = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// r1=0, r2=0</span></span><br><span class="line">Thread <span class="number">1</span>:           r1 = y;         x = <span class="number">1</span>;</span><br><span class="line">Thread <span class="number">2</span>:   r2 = x;         y = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>我们可以 <strong> 使用 CPU 内存屏障来避免运行时内存乱序访问</strong>（x86_64）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// thread 0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">run0</span><span class="params">()</span> &#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// CPU 内存屏障，保证 x=1 在 r1=y 之前执行</span></span><br><span class="line">    __asm__ __volatile__(<span class="string">&quot;mfence&quot;</span>:::<span class="string">&quot;memory&quot;</span>);</span><br><span class="line">    r1 = y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// thread 1</span></span><br><span class="line"><span class="type">void</span> run1 &#123;</span><br><span class="line">    y = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// CPU 内存屏障，保证 y=1 在 r2=x 之前执行</span></span><br><span class="line">    __asm__ __volatile__(<span class="string">&quot;mfence&quot;</span>:::<span class="string">&quot;memory&quot;</span>);</span><br><span class="line">    r2 = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sfence-lfence-mfence">sfence/lfence/mfence</h3>
<p>在 x86-64 系统架构中，内存屏障（Memory Fence）是用于控制 CPU 指令和内存访问顺序的关键指令。这些指令在并发编程和多线程环境中尤为重要，以确保内存操作按预期的顺序执行。x86-64 系统架构提供了三种主要的内存屏障指令：<code>sfence</code>、<code>lfence</code> 和 <code>mfence</code>。以下是对这三种内存屏障的详细介绍（根据 GPT 的回复整理）：</p>
<p><code>sfence</code>（Store Fence）：</p>
<p>功能：</p>
<ul>
<li>确保所有在 <code>sfence</code> 之前的 <strong> 存储操作</strong>（写操作）在所有后续的存储操作之前完成。</li>
<li>注意：<strong>sfence 不会强制将数据立即写回内存（可以在 cache 中）</strong>，只是确保写操作的顺序性。</li>
</ul>
<p>用途：</p>
<ul>
<li><code>sfence</code> 通常用于确保写入顺序的一致性，特别是在写入不同处理器或内存区域时。</li>
<li>常用于需要强制将缓冲区中的写入操作同步到共享内存或 I/O 设备上。</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写入共享变量</span></span><br><span class="line">shared_var1 = <span class="number">1</span>;</span><br><span class="line">shared_var2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入 sfence，确保 shared_var1 和 shared_var2 的写入操作完成</span></span><br><span class="line">__asm__ __volatile__(<span class="string">&quot;sfence&quot;</span> ::: <span class="string">&quot;memory&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时，可以进行依赖于前述写入操作的其他操作</span></span><br><span class="line">perform_other_operations();</span><br></pre></td></tr></table></figure>
<p><code>lfence</code>（Load Fence）：</p>
<p>功能：</p>
<ul>
<li>确保所有在 <code>lfence</code> 之前的 <strong> 加载操作</strong>（读操作）在所有后续的加载操作之前完成。</li>
<li>在加载（读取）指定数据时防止内存访问重排序（比如正常应该按 A-&gt;B-&gt;C 的顺序读取，使用 lfence 可以保证按 A-&gt;B-&gt;C 的顺序读取）。</li>
<li>注意：<strong>lfence 不会强制从内存中读取数据（可以在 cache 中）</strong>，只是确保读取操作的顺序性。</li>
</ul>
<p>用途：</p>
<ul>
<li><code>lfence</code> 通常用于执行内存读操作的序列控制。</li>
<li>用于防止 CPU 在提前读取数据时造成的潜在数据一致性问题，特别是在读取敏感数据或具备安全隐患的场景下。</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取共享变量之前插入 lfence，确保之前的所有内存读取操作已完成</span></span><br><span class="line">__asm__ __volatile__(<span class="string">&quot;lfence&quot;</span> ::: <span class="string">&quot;memory&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取共享变量</span></span><br><span class="line"><span class="type">int</span> val1 = shared_var1;</span><br><span class="line"><span class="type">int</span> val2 = shared_var2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用读取到的值进行后续操作</span></span><br><span class="line">process_values(val1, val2);</span><br></pre></td></tr></table></figure>
<p><code>mfence</code>（Memory Fence）：</p>
<p>功能：</p>
<ul>
<li>确保所有在 <code>mfence</code> 之前的 <strong> 加载和存储操作 </strong> 在所有后续的加载和存储操作之前完成。它起到的是全内存屏障的作用。</li>
<li>注意：<strong>mfence 不会强制从内存中读取数据、或写回数据到内存（可以在 cache 中）</strong>，只是确保读取、写入操作的顺序性，即它能保证在其之前的写入操作对其他 CPU 可见（它可以确保一个线程对变量的更新在另一个线程读取时是最新的）。</li>
</ul>
<p>用途：</p>
<ul>
<li><code>mfence</code> 是在需要同时控制读写操作顺序的情况下使用的。</li>
<li>在多线程程序中，我们可以 <strong> 用 <code>mfence</code> 来确保跨多个 CPU 的内存访问顺序的一致性</strong>。</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行一些读写操作</span></span><br><span class="line">shared_var1 = <span class="number">1</span>;        <span class="comment">// read</span></span><br><span class="line"><span class="type">int</span> val = shared_var2;  <span class="comment">// write</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入 mfence，确保以上读写操作在下一步操作之前完成</span></span><br><span class="line">__asm__ __volatile__(<span class="string">&quot;mfence&quot;</span> ::: <span class="string">&quot;memory&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时，可以进行依赖于前述读写操作的其他操作</span></span><br><span class="line">perform_other_operations();</span><br></pre></td></tr></table></figure>
<h3 id="多线程下的运行时乱序">多线程下的运行时乱序</h3>
<p>为什么仅通过保证了写者的写入顺序（sfence），还是有可能有问题？还是之前的例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// thread 0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">run0</span><span class="params">()</span> &#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// CPU 内存屏障，保证 x=1 在 r1=y 之前执行</span></span><br><span class="line">    __asm__ __volatile__(<span class="string">&quot;sfence&quot;</span>:::<span class="string">&quot;memory&quot;</span>); <span class="comment">// mfence</span></span><br><span class="line">    r1 = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// thread 1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">run1</span><span class="params">()</span> &#123;</span><br><span class="line">    y = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// CPU 内存屏障，保证 y=1 在 r2=x 之前执行</span></span><br><span class="line">    __asm__ __volatile__(<span class="string">&quot;sfence&quot;</span>:::<span class="string">&quot;memory&quot;</span>); <span class="comment">// mfence</span></span><br><span class="line">    r2 = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果仅仅是对“写入”操作进行顺序化，实际上，还是有可能使的上面的代码出现 r1，r2 同时为 0（初始值）的场景：</p>
<img src="../images/sys-net-program/sfence-1.png" alt="sfence 下的乱序访问" width="50%" height="50%">
<p>当 CPU0 上的 thread 0 执行时，x 被先行写回到内存中，但如果此时 y 在 CPU0 的 Cache 中，这时 y 从缓存中读出，并被赋予 r1 写回内存，此时 r1 为 0。同理，CPU1 上的 thread 1 执行时，y 被先行写回到内存中，如果此时 x 在 CPU1 的 Cache 中存在，则此时 r2 被赋予了 x 的（过时）值 0，同样存在了 r1, r2 同时为 0。【这里的写回到内存：可能是主存也能是 cache】</p>
<p>这个现象实际上就是所谓的 r1=y 的读顺序与 x=1 的写顺序存在逻辑上的乱序所致（或者是 r2=x 与 y=1 存在乱序）——读操作与写操作之间存在乱序。而 mfence 就是将这类乱序也屏蔽掉。</p>
<p>如果是通过 mfence，是怎样解决该问题的呢？</p>
<img src="../images/sys-net-program/mfence-1.png" alt="mfence 下的顺序访问" width="50%" height="50%">
<p>当 thread 0 在 CPU0 上对 x=1 进行写入时，x=1 被刷新到内存中，由于是 mfence，他要求 r1 的读取操作从内存读取数据，而不是从缓存中读取数据。因此，此时如果 y 更新为 1，则 r1=1；如果 y 没有更新为 1，则 r1=0。同时，此时由于 x 更新为 1， r2 必须从内存中读取数据，则此时 r2=1。总而言之，r1 和 r2 一个为 0、一个为 1。【mfence 能保证在其之前的写入操作对其他 CPU 可见】</p>
<h2 id="内存屏障补充">内存屏障补充</h2>
<p>关于内存屏障的一些补充：</p>
<p>在实际的应用程序开发中，开发者可能完全不知道内存屏障就写出了正确的多线程程序，这主要是因为各种同步机制中已隐含了内存屏障（但和实际的内存屏障有细微差别），使得不直接使用内存屏障也不会存在任何问题。但如果你希望编写诸如无锁数据结构，那么内存屏障意义重大。</p>
<p>在 Linux 内核中，除了前面说到的编译器屏障 barrier()和 ACESS_ONCE()，还有 CPU 内存屏障：</p>
<ul>
<li>通用屏障，保证读写操作有序，包括 mb()和 smp_mb();</li>
<li>写操作屏障，仅保证写操作有序，包括 wmb()和 smp_wmb();</li>
<li>读操作屏障，仅保证读操作有序，包括 rmb()和 smp_rmb();</li>
</ul>
<p>注意，所有的 CPU 内存屏障（除了数据依赖屏障外）都隐含了编译器屏障（也就是使用 CPU 内存屏障后就无需再额外添加编译器屏障了）。</p>
<p>这里，在单处理器上 smp_x()直接使用编译器屏障（即 barrier()），而在 SMP 架构上才使用 CPU 内存屏障（即 mb()、wmb()、rmb()）。</p>
<p>还需要注意一点是，CPU 内存屏障中某些类型的屏障需要成对使用，否则会出错。详细来说就是：一个写操作屏障需要和读操作（或者数据依赖）屏障一起使用（当然，通用屏障也是可以的），反之亦然。</p>
<p>通常，我们是希望在写屏障之前出现的 STORE 操作，总是匹配读屏障或者数据依赖屏障之后出现的 LOAD 操作。以之前的代码示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// thread 0</span></span><br><span class="line">x = <span class="number">42</span>;</span><br><span class="line">smb_wmb();</span><br><span class="line">ok = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// thread 1</span></span><br><span class="line"><span class="keyword">while</span>(!ok);</span><br><span class="line">smb_rmb();</span><br><span class="line"><span class="keyword">do</span>(x);</span><br></pre></td></tr></table></figure>
<p>我们这么做，是希望在 thread 1 执行到 do(x)时（在 ok 验证的确 =1 时），x=42 的确是有效的（写屏障之前出现的 STORE 操作），此时 do(x)，的确是在执行 do(42)（读屏障之后出现的 LOAD 操作）。</p>
<p>最后，以一个使用内存屏障实现的无锁环形缓冲区来结束本文：<a href="/posts/240627210637.html">DPDK 无锁环形队列</a>。</p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://www.cnblogs.com/mysky007/p/12901776.html">https://www.cnblogs.com/mysky007/p/12901776.html</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>内存屏障</tag>
      </tags>
  </entry>
  <entry>
    <title>计网 CyC2018 之网络层</title>
    <url>/posts/240329202003.html</url>
    <content><![CDATA[<h1 id="计算机网络 - 网络层">计算机网络 - 网络层</h1>
<!-- GFM-TOC -->
<ul>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%BD%91%E7%BB%9C%E5%B1%82">计算机网络 - 网络层</a>
<ul>
<li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li>
<li><a href="#IP-%20%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F">IP 数据报格式</a></li>
<li><a href="#IP-%20%E5%9C%B0%E5%9D%80%E7%BC%96%E5%9D%80%E6%96%B9%E5%BC%8F">IP 地址编址方式</a>
<ul>
<li><a href="#1-%20%E5%88%86%E7%B1%BB">1. 分类</a></li>
<li><a href="#2-%20%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86">2. 子网划分</a></li>
<li><a href="#3-%20%E6%97%A0%E5%88%86%E7%B1%BB">3. 无分类</a></li>
</ul>
</li>
<li><a href="#%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE%20-ARP">地址解析协议 ARP</a></li>
<li><a href="#%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE%20-ICMP">网际控制报文协议 ICMP</a>
<ul>
<li><a href="#1-Ping">1. Ping</a></li>
<li><a href="#2-Traceroute">2. Traceroute</a></li>
</ul>
</li>
<li><a href="#%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91%20-VPN">虚拟专用网 VPN</a></li>
<li><a href="#%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%20-NAT">网络地址转换 NAT</a></li>
<li><a href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84">路由器的结构</a></li>
<li><a href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B">路由器分组转发流程</a></li>
<li><a href="#%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%86%E7%B1%BB">路由协议的分类</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE">动态路由选择协议</a>
<ul>
<li><a href="#1-%20%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE%20-RIP">1. 内部网关协议 RIP</a></li>
<li><a href="#2-%20%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE%20-OSPF">2. 内部网关协议 OSPF</a></li>
<li><a href="#3-%20%E5%A4%96%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE%20-BGP">3. 外部网关协议 BGP</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- GFM-TOC -->
<h2 id="概述">概述</h2>
<p>因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。<u>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的 </u> 数据报服务。</p>
<p>使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8d779ab7-ffcc-47c6-90ec-ede8260b2368.png" width="800"/> </div><br>
<p>与 IP 协议配套使用的还有三个协议：</p>
<ul>
<li>地址解析协议 ARP（Address Resolution Protocol）</li>
<li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li>
<li>网际组管理协议 IGMP（Internet Group Management Protocol）</li>
</ul>
<h2 id="IP- 数据报格式">IP 数据报格式</h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/85c05fb1-5546-4c50-9221-21f231cdc8c5.jpg" width="700"/> </div><br>
<ul>
<li><strong>版本</strong>：有 4（IPv4）和 6（IPv6）两个值；</li>
<li><strong>首部长度</strong>：占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li>
<li><strong>区分服务</strong>：用来获得更好的服务，可以理解为赋予报文不同优先级的一个字段，一般情况下不使用。</li>
<li><strong>总长度</strong>：包括首部长度和数据部分长度。</li>
<li><strong>生存时间 TTL</strong>：它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 减为 0 时就丢弃数据报。</li>
<li><strong>协议</strong>：指出携带的数据应该上交给哪个协议进行处理，例如 <u>ICMP</u>、TCP、UDP 等。</li>
<li><strong>首部检验和 </strong>：因为数据报<u> 每经过一个路由器，都要重新计算检验和 </u>，因此检验和计算<u> 不包含数据部分</u>，以减少计算的工作量。</li>
<li><strong>唯一标识 ID</strong>：不同数据报具有不同的唯一标识。在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li>
<li><strong>片偏移</strong>：和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</li>
<li><strong>分片标志位 Flags</strong>：包括不分片（DF）和更多片（MF）标志位。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/23ba890e-e11c-45e2-a20c-64d217f83430.png" width="700"/> </div><br>
<blockquote>
<p>IP 数据报发生分片后，不同分片的首部中，唯一标识字段相同、片偏移字段不同、首部校验和不同；DF 标志位通常是相同的，而 MF 标志位则用于指示是否还有后续片。</p>
</blockquote>
<h2 id="IP- 地址编址方式">IP 地址编址方式</h2>
<p>IP 地址的编址方式经历了三个历史阶段：分类、子网划分、无分类。</p>
<h3 id="1- 分类">1. 分类</h3>
<p>由两部分组成，<strong>网络号（Network ID）和主机号（Host ID）</strong>，其中 <u> 不同分类具有不同的网络号长度，并且是固定的</u>。</p>
<p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cbf50eb8-22b4-4528-a2e7-d187143d57f7.png" width="500"/> </div><br>
<h3 id="2- 子网划分">2. 子网划分</h3>
<p>通过 <u> 在主机号字段中拿一部分作为子网号</u>，把两级 IP 地址划分为三级 IP 地址。</p>
<p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p>
<p><strong>要使用子网，必须配置子网掩码</strong>。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p>
<blockquote>
<p>注意，外部网络看不到子网的存在。</p>
</blockquote>
<h3 id="3- 无分类">3. 无分类</h3>
<p>无分类编址（Classless Inter-Domain Routing, CIDR）消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，<u>使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化</u>。</p>
<p>IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}</p>
<p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀（子网掩码长度为 20）。</p>
<p>CIDR 的地址掩码可以继续称为子网掩码，网络前缀的长度等于子网掩码的首位连续为 1 的长度。</p>
<p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为 <strong> 路由聚合</strong>，也称为构成超网。</p>
<p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当 <u> 采用最长前缀匹配原则 </u> 来确定应该匹配哪一个。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[RTA]display ip routing-table                                                   </span><br><span class="line">                                                                                </span><br><span class="line">Destinations : 4 Routes : 4                                                     </span><br><span class="line">                                                                                </span><br><span class="line">Destination/Mask   Proto   Pre Cost        NextHop         Interface            </span><br><span class="line">0.0.0.0/32         Direct  0   0           127.0.0.1       InLoop0              </span><br><span class="line">10.20.1.0/24       Direct  0   0           10.20.1.11      GE0/0/0              </span><br><span class="line">10.20.1.11/32      Direct  0   0           127.0.0.1       InLoop0              </span><br><span class="line">10.20.1.255/32     Direct  0   0           10.20.1.11      GE0/0/0              </span><br><span class="line">[RTA]</span><br></pre></td></tr></table></figure>
<h2 id="地址解析协议 -ARP">地址解析协议 ARP</h2>
<p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此 <u> 在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变</u>。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/66192382-558b-4b05-a35d-ac4a2b1a9811.jpg" width="700"/> </div><br>
<p><strong>ARP 协议用于将 IP 地址映射到对应的 MAC 地址</strong>。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b9d79a5a-e7af-499b-b989-f10483e71b8b.jpg" width="500"/> </div><br>
<blockquote>
<p>ICMP 和 IGMP 属于网络层，但是作为 IP 数据报的数据部分存在。因此图中画在了 IP 之外。</p>
</blockquote>
<p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;RTA&gt;display arp                                                                </span><br><span class="line">   Type: S-Static    D-Dynamic    O-Openflow   R-Rule   I-Invalid               </span><br><span class="line">IP address      MAC address    VLAN/VSI name Interface/Link ID        Aging Type</span><br><span class="line">30.0.0.2        0000-00a1-231e --            GE0/1                    11    D   </span><br><span class="line">10.20.1.30      912b-b058-7eba --            GE0/0                    15    D   </span><br><span class="line">10.20.1.31      9010-bae2-7046 --            GE0/0                    15    D   </span><br><span class="line">&lt;RTA&gt;                                                                           </span><br></pre></td></tr></table></figure>
<p>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时 <mark> 主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址</mark>，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8006a450-6c2f-498c-a928-c927f758b1d0.png" width="700"/> </div><br>
<h2 id="网际控制报文协议 -ICMP">网际控制报文协议 ICMP</h2>
<p>ICMP 用于在 IP 网络中传送控制信息和错误消息，它 <u> 通常用于网络设备之间进行通信，以诊断网络问题和报告错误</u>。</p>
<p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。<u>ICMP 封装在 IP 数据报中</u>（作为数据部分），但是不属于高层协议，而是一种在 IP 层之上的协议。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e3124763-f75e-46c3-ba82-341e6c98d862.jpg" width="500"/> </div><br>
<p>ICMP 报文分为差错报告报文和询问报文，通常是 <u> 由网络设备生成并发送</u>。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/aa29cc88-7256-4399-8c7f-3cf4a6489559.png" width="600"/> </div><br>
<h3 id="1-Ping">1. Ping</h3>
<p>Ping 是 ICMP 的一个重要应用，主要 <u> 用来测试两台主机之间的连通性</u>。</p>
<p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p>
<h3 id="2-Traceroute">2. Traceroute</h3>
<p>Traceroute 是 ICMP 的另一个应用，<u>用来跟踪一个分组从源点到终点的路径</u>。</p>
<p>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p>
<ul>
<li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并 <u> 向源主机发送一个 ICMP 时间超过差错报告报文</u>；</li>
<li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并 <u> 向源主机发送一个 ICMP 时间超过差错报告报文</u>；</li>
<li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，目的主机要 <u> 向源主机发送 ICMP 终点不可达差错报告报文</u>。</li>
<li><strong>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间</strong>。</li>
</ul>
<h2 id="虚拟专用网 -VPN">虚拟专用网 VPN</h2>
<p>由于 IP 地址的紧缺，一个 <u> 机构能申请到的 IP 地址数往往 <strong> 远小于 </strong> 本机构所拥有的主机数</u>。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p>
<p>有三个专用地址块：</p>
<ul>
<li>10.0.0.0 ~ 10.255.255.255</li>
<li>172.16.0.0 ~ 172.31.255.255</li>
<li>192.168.0.0 ~ 192.168.255.255</li>
</ul>
<p>VPN <u>使用公用的互联网作为 </u> 本机构各专用网之间的 <u> 通信载体</u>。“专用”指机构内的主机只与本机构内的其它主机通信；“虚拟”指好像是、而实际上并不是，它有经过公用的互联网。</p>
<p>下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。IP 数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1556770b-8c01-4681-af10-46f1df69202c.jpg" width="800"/> </div><br>
<h2 id="网络地址转换 -NAT">网络地址转换 NAT</h2>
<p>专用网内部的主机使用本地 IP 地址，但又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。</p>
<p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，<u>现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址 </u>。使用端口号的 NAT 也叫做<strong> 网络地址与端口转换 NAPT</strong>。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2719067e-b299-4639-9065-bed6729dbf0b.png" width=""/> </div><br>
<h2 id="路由器的结构">路由器的结构</h2>
<p>路由器从功能上可以划分为：<strong>路由选择和分组转发</strong>。路由选择是指路由器根据网络中各设备之间的通信需求，选择最佳的传输路径进行数据转发；而分组转发则是指路由器将收到的数据包按照特定的规则进行处理和转发。</p>
<p>分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c3369072-c740-43b0-b276-202bd1d3960d.jpg" width="600"/> </div><br>
<blockquote>
<p>交换结构是指路由器内部用于处理和转发数据包的组件，通常包括转发表、邻接表、缓存等。</p>
</blockquote>
<h2 id="路由器分组转发流程">路由器分组转发流程</h2>
<p>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N：</p>
<ol>
<li>若 N 就是与此路由器 <u> 直接相连 </u> 的某个网络地址，则进行直接交付；</li>
<li>若路由表中有 <u> 目的地址 </u> 为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li>
<li>若路由表中有到达 <u> 网络地址 </u> 为 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li>
<li>若路由表中有一个 <u> 默认路由</u>，则把数据报传送给路由表中所指明的默认路由器；</li>
<li>报告转发分组出错。</li>
</ol>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1ab49e39-012b-4383-8284-26570987e3c4.jpg" width="800"/> </div><br>
<h2 id="路由协议的分类">路由协议的分类</h2>
<p>路由分类：</p>
<ul>
<li><strong>直连路由 </strong>：路由器直连接口所在的网络，当<u> 接口物理和协议状态都 UP 时 </u> 自动学习到路由表。</li>
<li><strong>静态路由 </strong>：根据数据访问需要<u> 手工 </u> 在每台设备上进行添加和维护的路由。</li>
<li><strong>动态路由协议</strong>：路由器自动进行路由信息的更新和同步，并且当网络拓扑变更时，能够自动收敛。</li>
</ul>
<p>不同路由协议的优先级，值越低优先级越高（不同厂商的优先级定义可能不同）：</p>
<img src="../images/computer-network/router-preference.png" alt="路由协议优先级" width="50%" height="50%">
<h2 id="动态路由选择协议">动态路由选择协议</h2>
<p>动态路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p>
<p>互联网可以划分为许多较小的自治系统（Autonomous System, AS），一个 AS 可以使用一种不同于其他 AS 的路由选择协议。</p>
<p>可以把 <strong> 动态路由选择协议 </strong> 划分为两大类：</p>
<ul>
<li>自洽系统 <strong> 内</strong>网关间交换路由的内部网关协议（Interior Gateway Protocol, IGP），包括：RIP、OSPF、IS-IS；</li>
<li>自治系统 <strong> 间</strong>交换路由的外部网关协议（External Gateway Protocol, EGP），包括：BGP（Border Gateway Protocol）。</li>
</ul>
<table>
<thead>
<tr>
<th><div style="width: 80px">项目</div></th>
<th><div style="width: 80px">RIP</div></th>
<th>OSPF</th>
<th>IS-IS</th>
</tr>
</thead>
<tbody>
<tr>
<td>协议类型</td>
<td>IP 层协议</td>
<td>IP 层协议</td>
<td>链路层协议</td>
</tr>
<tr>
<td>适用范围</td>
<td>适用于规模较小的网络中</td>
<td>适用于规模适用的网络中</td>
<td>适用于规模较大的网络中</td>
</tr>
<tr>
<td>路由算法</td>
<td>采用距离矢量算法</td>
<td>采用 SPF（Shortest Path First，最短路径优先）算法。通告 LSA（Link State Advertisement，链路状态通告）描述网络拓扑，根据网络拓扑生成一颗 SPT（Shortest Path Tree，最短路径树），计算出到网络中所有目的地的最短路径，并进行路由信息的交换</td>
<td>采用 SPF（Shortest Path First，最短路径优先）算法。根据网络拓扑生成一颗 SPT（Shortest Path Tree，最短路径树），计算出到网络中所有目的地的最短路径</td>
</tr>
<tr>
<td>收敛速度</td>
<td>收敛速度慢</td>
<td>收敛速度快</td>
<td>收敛速度快</td>
</tr>
<tr>
<td>扩展性</td>
<td>不能扩展</td>
<td>通过划分区域增强 OSPF 网络的可扩展性</td>
<td>通过 Level 路由器增强 IS-IS 网络的可扩展性</td>
</tr>
</tbody>
</table>
<p>按协议类型分类：</p>
<ul>
<li>距离矢量协议：RIP、BGP</li>
<li>链路状态协议：OSPF、IS-IS</li>
</ul>
<h3 id="1- 内部网关协议 -RIP">1. 内部网关协议 RIP</h3>
<p>RIP (Routing Information Protocol) 是一种 <u> 基于距离矢量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达</u>。</p>
<p><strong>原理：RIP 按固定的时间间隔仅和直接相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址</strong>。</p>
<p>使用距离矢量路由协议的路由器，并不了解网络的拓扑结构，该路由器只知道：</p>
<ol>
<li>自身与目的网络之间的距离（跳数）；</li>
<li>应该使用哪个出接口转发数据包。</li>
</ol>
<img src="../images/computer-network/RIP-1.png" alt="RIP 转发数据示意图" width="60%" height="60%">
<p>初始的直连路由，经过两次路由交换之后收敛完成，各个路由器的路由表：</p>
<img src="../images/computer-network/RIP-2-merged.png" alt="RIP 路由交换过程" width="100%" height="100%">
<blockquote>
<p>为什么后续交换没有表项更新了呢？</p>
<p>以路由器 C 中的路由 <code>10.0.1.0, G0/0/0, 2</code> 为例，它通过路由器 B 的 <code>G0/0/1</code> 扩散到路由器 B，假设会“形成”一个表项 <code>10.0.1.0, G0/0/1, 2+1</code>，但该路由器有一个更优的表项 <code>10.0.1.0, G0/0/0, 1 &lt; (2+1)</code> 可以到达目的网段，所以交换不会更新表项。</p>
</blockquote>
<p><strong>距离矢量算法大致步骤</strong>：</p>
<p>对地址为 X 的路由器的多个相邻路由器发来的 RIP 报文，先修改报文中的所有 entry ，把下一跳字段中的地址改为 X，并把所有的距离字段加 1。对修改后的 RIP 报文中的每一个 entry ，进行以下步骤：</p>
<ol>
<li>若路由器 X 的原路由表中没有目的网络 N，则把该 entry 添加到该路由表中；</li>
<li>否则：若下一跳路由器地址就是 X，则把收到的 entry 替换掉原来路由表中的 entry ；否则：若收到的 entry 中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2: 5, Y，新表项为 Net2: 4, X，则更新）；否则什么也不做。</li>
</ol>
<p>若 3 分钟（即 6 次 RIP 消息广播的时间）还没有收到相邻路由器的更新路由表，则路由器 X 把该相邻路由器标为不可达（将距离置为 16）。</p>
<p><strong>伪代码（仅供参考）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for each neighboring routers of X:</span><br><span class="line">    if RIP message received from neighboring router:</span><br><span class="line">        modify nexthop address to X&#x27;s gateway, and increment distance by 1</span><br><span class="line"></span><br><span class="line">        for each entry in modified RIP message:</span><br><span class="line">            if destination network N not in routing table:</span><br><span class="line">                add entry to routing table</span><br><span class="line">            else:</span><br><span class="line">                if nexthop address in received entry is X:</span><br><span class="line">                    replace existing entry in routing table with received entry</span><br><span class="line">                else:</span><br><span class="line">                    if received distance d is less than existing distance in routing table:</span><br><span class="line">                        update entry in routing table with received entry</span><br><span class="line">                    else:</span><br><span class="line">                        do nothing</span><br><span class="line">    else:</span><br><span class="line">        if no update received from neighboring router for 180s:</span><br><span class="line">            mark neighboring router as unreachable by setting distance to 16</span><br></pre></td></tr></table></figure>
<p><strong>RIP 的特点</strong>：</p>
<ul>
<li>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</li>
<li>RIP 以跳数作为度量值，虽然简单，但是不够科学。例如，被 RIP 优选的跳数少的路径可能是链路带宽低的路径，反而跳数多的路径是链路带宽高的路径。</li>
</ul>
<p><strong>路由环路的产生</strong>：</p>
<p>路由环路，就是数据包不断在这个网络传输，始终到达不了目的地，导致掉线或者网络瘫痪。</p>
<p>图中，路由器 C 与 <code>10.0.4.0/24</code> 网段的设备物理断开后，路由器 C 上对应的表项会被删除。</p>
<img src="../images/computer-network/RIP-3-merged.png" alt="路由环路产生过程" width="100%" height="100%">
<p>后续，在第一次 RIP 路由交换时，路由器 B 上的表项 <code>10.0.4.0, 1</code> 会通过路由器 C 的 <code>G0/0/0</code> 通告给路由器 C，并添加该表项 <code>10.0.4.0, G0/0/0, 1+1</code>。</p>
<p>在第二次 RIP 路由交换时，路由器 C 会再次把该表项通过路由器 B 的 <code>G0/0/1</code> 通告给路由器 B。<strong>原先路由器 B 上到达该目的网段的表项为 <code>10.0.4.0, G0/0/1, 1</code>，但这次路由器 C 通告的表项表明：到达目的网段 <code>10.0.4.0</code> 需要通过你的 <code>G0/0/1</code> 接口，其跳数是 <code>2+1</code>，故路由器 B 会更新该表项为  <code>10.0.4.0, G0/0/1, 3</code></strong>。</p>
<p>在再下一次 RIP 路由交换时，路由器 A 同理，会更新为  <code>10.0.4.0, G0/0/1, 3+1</code>。后续不断地交换，跳数越来越大…</p>
<p>路由环路的产生，会导致数据包不断在这个网络传输，始终到达不了目的地。例如，路由器 B 下挂的设备想要给 <code>10.0.4.0/24</code> 网段的设备通信时，数据包会从 <code>G0/0/1</code> 发送给路由器 C，路由器 C 又会从 <code>G0/0/0</code> 发回给 路由器 B，路由器 B 又会从 <code>G0/0/1</code> 发送给路由器 C，如此循环…</p>
<p><strong>距离矢量路由选择协议的防环机制</strong>：</p>
<ul>
<li><strong>定义最大度量以防止计数至无穷大</strong>：如 RIP 规定跳数达到 16 为不可达，数据包将被丢弃</li>
<li><strong>水平分割</strong>：路由器从一个接口收到的路由更新，不会再从同一个接口通告出去</li>
<li><strong>路由中毒</strong>：当本设备的某一路由表项不可达时，会立即向所有邻居发出通告（邻居再通告给邻居的邻居），以 16 跳数的方式表明该路由不可达</li>
<li><strong>毒性逆转</strong>：路由器从一个接口收到的路由更新，会以 16 跳从该接口更新出去（再次返回给那个邻居后，发现不是最优的路径，不会触发更新表项）</li>
<li>抑制计时器</li>
<li>触发更新</li>
</ul>
<img src="../images/computer-network/RIP-4-merged.png" alt="距离矢量路由选择协议的防环机制" width="80%" height="80%">
<blockquote>
<p>水平分割与毒性逆转不会同时存在。</p>
</blockquote>
<h3 id="2- 内部网关协议 -OSPF">2. 内部网关协议 OSPF</h3>
<p>开放最短路径优先（Open Shortest Path First, OSPF），是为了克服 RIP 的缺点而开发出来的。</p>
<p>这里的开放一词意味着：OSPF 不受某一家厂商控制，而是公开发表的，它使用了 Dijkstra 提出的 <a href="/posts/231117095232.html"> 最短路径算法 SPF</a>。</p>
<p>OSPF 具有以下特点：</p>
<ul>
<li>向本自治系统中的所有路由器发送信息，这种方法是洪泛法。</li>
<li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li>
<li>只有当链路状态发生变化时，路由器才会发送信息。</li>
</ul>
<p>所有路由器都具有全网的拓扑结构图，并且是一致的。相较于 RIP，OSPF 的更新过程收敛的很快。</p>
<blockquote>
<p>洪泛法（Flooding）是一种简单且基础的路由算法，常用于网络通信中。在洪泛法中，当一个路由器接收到一个数据包时，它会将该数据包发送到所有与其相邻的路由器（除了接收该数据包的路由器）。接收到数据包的路由器会继续将该数据包向外传输，直到数据包到达目的地。</p>
</blockquote>
<h3 id="3- 外部网关协议 -BGP">3. 外部网关协议 BGP</h3>
<p>AS 之间的路由选择很困难，主要是由于：</p>
<ul>
<li>互联网规模很大；</li>
<li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li>
<li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</li>
</ul>
<p>边界网关协议（Border Gateway Protocol, BGP）只能寻找一条比较好的路由，而不是最佳路由。</p>
<p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9cd0ae20-4fb5-4017-a000-f7d3a0eb3529.png" width="600"/> </div><br>
<blockquote>
<ol>
<li>本文修改自：<a href="https://github.com/CyC2018/CS-Notes">https://github.com/CyC2018/CS-Notes</a></li>
<li>RIP 参考：<a href="https://www.bilibili.com/video/BV1SK411T7EC/">https://www.bilibili.com/video/BV1SK411T7EC/</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>CyC2018</tag>
      </tags>
  </entry>
  <entry>
    <title>项目之线程池原理与实现</title>
    <url>/posts/240303201855.html</url>
    <content><![CDATA[<p><strong>线程池（Thread Pool）<strong>是一种基于 </strong> 池化思想 </strong> 管理线程的工具，经常出现在多线程服务器中，如 MySQL。</p>
<p>线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。<strong>线程池维护多个线程，等待监督管理者（worker）分配可并发执行的任务</strong>。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。</p>
<span id="more"></span>
<h1 id="为什么选择线程池">为什么选择线程池</h1>
<p>创建线程可能是非常昂贵的。通常每个线程都会执行几乎相同的任务，包括创建线程、执行任务和销毁线程等。线程本身相当 heavy —— 创建或销毁线程会占用很多本来想要执行的任务时间。因此，<strong>重用线程是一个很好的选择</strong>。</p>
<p>线程池的另一个好处是它可以防止系统过载（overloaded），它允许 <strong> 限制线程数量、任务排队，并仅在线程可用时运行任务</strong>。</p>
<blockquote>
<p>线程池维持固定数量的线程，并等待执行特定任务。该线程池可以设计为根据您需要完成的工作量进行扩展，但我更喜欢 <strong> 指定固定数量的线程 </strong>。为了确定这个数量，通常可以考虑<strong> 使用系统上的核心 / 处理器数量加一</strong>。</p>
</blockquote>
<h1 id="线程池的好处">线程池的好处</h1>
<p>使用线程池可以带来一系列好处：</p>
<ul>
<li>降低资源消耗（系统资源）：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。</li>
<li>提高线程的可管理性（系统资源）：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</li>
<li>提高响应速度（任务响应）：任务到达时，无需等待线程创建即可立即执行。</li>
</ul>
<h1 id="线程池解决的问题">线程池解决的问题</h1>
<p>线程池解决的核心问题就是资源管理问题。<strong>在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入</strong>。这种不确定性将带来以下若干问题：</p>
<ul>
<li>频繁申请 / 销毁资源和调度资源：将带来额外的消耗，可能会非常巨大。</li>
<li>对资源无限申请缺少抑制手段：易引发系统资源耗尽的风险。</li>
<li>系统无法合理管理内部的资源分布：会降低系统的稳定性。</li>
</ul>
<h1 id="线程池如何工作"><a href="https://jenkov.com/tutorials/java-concurrency/thread-pools.html#how-a-thread-pool-works">线程池如何工作</a></h1>
<p>可以将任务传递到线程池，而不是为每个任务启动一个新线程来并发地执行。一旦池中有任何空闲线程（idle threads），任务就会分配给其中一个空闲线程并执行。在内部，任务被插入到阻塞队列（Blocking Queue）中，池中的线程将从该队列中出队。当一个新任务被插入队列时，其中一个空闲线程将成功地将其出队并执行它。池中的其余空闲线程将被阻塞，等待任务出队。</p>
<img src="../images/projects/c-thread-pool/thread-pool-1.png" alt="线程池如何工作" width="100%" height="100%">
<p>何为阻塞队列（Blocking Queue）？</p>
<img src="../images/projects/c-thread-pool/blocking-queue.png" alt="阻塞队列" width="100%" height="100%">
<h1 id="C-Thread-Pool">C-Thread-Pool</h1>
<p>后续内容是对基于 C 语言实现的线程池的开源项目 <a href="https://github.com/Pithikos/C-Thread-Pool">C-Thread-Pool</a> 的学习。</p>
<h2 id="公共接口">公共接口</h2>
<table>
<thead>
<tr>
<th>Function example</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>thpool_init(4)</code></td>
<td>Will return a new threadpool with <code>4</code> threads.</td>
</tr>
<tr>
<td><code>thpool_add_work(thpool,func_p,arg_p)</code></td>
<td>Will add new work to the pool. Work is simply a function. You can pass a single argument to the function if you wish. If not, <code>NULL</code> should be passed.</td>
</tr>
<tr>
<td><code>thpool_wait(thpool)</code></td>
<td>Will wait for all jobs (both in queue and currently running) to finish.</td>
</tr>
<tr>
<td><code>thpool_destroy(thpool)</code></td>
<td>This will destroy the threadpool. If jobs are currently being executed, then it will wait for them to finish.</td>
</tr>
<tr>
<td><code>thpool_pause(thpool)</code></td>
<td>All threads in the threadpool will pause no matter if they are idle or executing work.</td>
</tr>
<tr>
<td><code>thpool_resume(thpool)</code></td>
<td>If the threadpool is paused, then all threads will resume from where they were.</td>
</tr>
<tr>
<td><code>thpool_num_threads_working(thpool)</code></td>
<td>Will return the number of currently working threads.</td>
</tr>
</tbody>
</table>
<h2 id="接口使用实例">接口使用实例</h2>
<p>We create a pool of 4 threads and then add 40 tasks to the pool (20 task1 functions and 20 task2 functions). task1 and task2 simply print which thread is running them.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">task1</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Task1, Thread #%u working on %d\n&quot;</span>, (<span class="type">int</span>)pthread_self(), (<span class="type">int</span>)(<span class="type">uintptr_t</span>)arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">task2</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Task2, Thread #%u working on %d\n&quot;</span>, (<span class="type">int</span>)pthread_self(), (<span class="type">int</span>)(<span class="type">uintptr_t</span>)arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Making threadpool with 4 threads&quot;</span>);</span><br><span class="line">    threadpool thpool = thpool_init(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Adding 40 tasks to threadpool&quot;</span>);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">        thpool_add_work(thpool, (<span class="type">void</span> (*)(<span class="type">void</span>*))(i % <span class="number">2</span> ? task1 : task2), (<span class="type">void</span>*)(<span class="type">uintptr_t</span>)i);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    thpool_wait(thpool);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Killing threadpool&quot;</span>);</span><br><span class="line">    thpool_destroy(thpool);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>As soon as we add the tasks to the pool, the threads will run them. It can happen that you see a single thread running all the tasks (highly unlikely). It is up the OS to decide which thread will run what. So it is not an error of the thread pool but rather a decision of the OS.</p>
<h2 id="数据结构组织关系">数据结构组织关系</h2>
<img src="../images/projects/c-thread-pool/thread-pool-struct.png" alt="线程池数据结构组织关系" width="100%" height="100%">
<p><a href="https://github.com/Pithikos/C-Thread-Pool">C-Thread-Pool</a> 实现的线程池包括如下数据结构：</p>
<ul>
<li>线程池数据结构：包括申请创建的每个线程的地址、任务队列等；</li>
<li>线程数据结构：包括创建的线程、线程所属的线程池等；</li>
<li>任务队列数据结构：包括一个是否存在任务的信号量；</li>
<li>任务数据结构；</li>
<li>信号量数据结构。</li>
</ul>
<h2 id="二进制信号量接口">二进制信号量接口</h2>
<img src="../images/projects/c-thread-pool/thread-pool-bsem-method.png" alt="线程池的二进制信号量接口" width="100%" height="100%">
<h2 id="线程池接口">线程池接口</h2>
<img src="../images/projects/c-thread-pool/thread-pool-thpool-method.png" alt="线程池的线程池接口" width="100%" height="100%">
<h3 id="线程池初始化">线程池初始化</h3>
<p>流程图左一：<code>struct thpool_* thpool_init(int num_threads)</code></p>
<ol>
<li>分配线程池内存空间</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">thpool_</span> &#123;</span></span><br><span class="line">    thread** threads;                  <span class="comment">// 指向一组线程（指针数组）</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> num_threads_alive;    <span class="comment">// 当前活跃的线程数量</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> num_threads_working;  <span class="comment">// 当前工作中的线程数量</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> thcount_lock;      <span class="comment">// used for thread count etc</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> threads_all_idle;   <span class="comment">// signal to thpool_wait</span></span><br><span class="line">    jobqueue jobqueue;                 <span class="comment">// 作业队列</span></span><br><span class="line">&#125; thpool_;</span><br><span class="line"></span><br><span class="line">thpool_* thpool_p = (<span class="keyword">struct</span> thpool_*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> thpool_));</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>初始化任务队列</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">jobqueue_init(&amp;thpool_p-&gt;jobqueue);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>创建线程池中的二级指针 <code>thpool_p-&gt;threads</code>，它指向一个 <code>struct thread *</code> 类型指针的 <strong> 指针数组</strong>。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">thpool_p-&gt;threads = (<span class="keyword">struct</span> thread**)<span class="built_in">malloc</span>(num_threads * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> thread*));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>后续将在 <code>thread_init()</code> 函数中，为每个指向 <code>struct thread *</code> 的指针分配一段内存空间。正因为是在 <strong> 其它函数内部 </strong> 为这里申请的二级指针指向的指针数组中的每个指针分配一段内存空间，所以在 <code>thread_init()</code> 函数中使用了二级指针。<a href="https://pursue26.github.io/posts/240224193217.html#%E4%BE%8B%E5%AD%90%E4%BA%8C">看这里，为什么用二级指针</a></p>
</blockquote>
<ol start="4">
<li>初始化一组线程</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_threads; i++) &#123;</span><br><span class="line">    thread_init(thpool_p, &amp;thpool_p-&gt;threads[i], i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程池添加任务">线程池添加任务</h3>
<p>流程图左二：<code>int thpool_add_work(thpool_* thpool_p, void (*function_p)(void*), void* arg_p)</code></p>
<ol>
<li>为添加的任务分配一块内存空间</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">job</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job</span>* <span class="title">next</span>;</span>             <span class="comment">// 指向下一个 job</span></span><br><span class="line">    <span class="type">void</span> (*function)(<span class="type">void</span>* arg);  <span class="comment">// 调用的 job 的函数，作为线程入口函数</span></span><br><span class="line">    <span class="type">void</span>* arg;                    <span class="comment">// 调用的 job 的函数的参数，作为线程入口函数的参数</span></span><br><span class="line">&#125; job;</span><br><span class="line"></span><br><span class="line">job* newjob = (<span class="keyword">struct</span> job*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> job));</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>根据入参初始化函数指针和函数参数</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">newjob-&gt;function = function_p;</span><br><span class="line">newjob-&gt;arg = arg_p;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>将任务添加到指定的队列中</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">jobqueue_push(&amp;thpool_p-&gt;jobqueue, newjob);</span><br></pre></td></tr></table></figure>
<p>关注点：</p>
<ol>
<li>
<p>对于任务队列中 <strong> 没有任务时的处理</strong>：<br>
不是采用轮询的方式，而是使用条件变量 <code>has_jobs-&gt;cond</code>，在入队 / 出队任务后，若仍有任务在队列中，则唤醒条件变量。</p>
</li>
<li>
<p>对于 <strong> 函数指针类型转换的处理</strong>：<br>
自定义的函数原型可以与 api 的原型不一致。例如：这里 api 的函数指针原型为<code>void (*)(void*)</code>，而「接口使用实例」中的 task1 和 task2 的函数原型为<code>void* (*)(void*)</code>。</p>
</li>
</ol>
<h3 id="线程池等待">线程池等待</h3>
<p>流程图左三：<code>void thpool_wait(thpool_* thpool_p)</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;thpool_p-&gt;thcount_lock);</span><br><span class="line"><span class="keyword">while</span> (thpool_p-&gt;jobqueue.len || thpool_p-&gt;num_threads_working) &#123;</span><br><span class="line">    pthread_cond_wait(&amp;thpool_p-&gt;threads_all_idle, &amp;thpool_p-&gt;thcount_lock);</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;thpool_p-&gt;thcount_lock);</span><br></pre></td></tr></table></figure>
<p>这个函数的工作原理是：</p>
<ol>
<li>获取锁，避免多个线程同时访问共享资源（这里是指 <code>thpool_</code> 结构中的计数变量）；</li>
<li>当任务队列中有任务或有正在处理任务的工作线程时，继续等待：
<ul>
<li>这个线程会等待在条件变量 <code>threads_all_idle</code> 上，同时释放 <code>thcount_lock</code> 互斥锁（以让其它线程有机会拿到锁），并阻塞在这个条件变量上。这样其它线程可以在条件满足时唤醒等待在 <code>threads_all_idle</code> 条件变量上的这个线程。</li>
<li>如果这个线程被其它线程唤醒后，这个线程会重新尝试获取 <code>thcount_lock</code> 互斥锁。一旦获取到互斥锁后，它会再次检查 while 条件，若条件成立，说明还有任务或工作线程。那么，这个线程会继续等待在条件变量上，等待被通知唤醒。</li>
</ul>
</li>
<li>直到所有任务都已经执行完毕且所有线程都是空闲的，释放锁。</li>
</ol>
<p>关注点：</p>
<ol>
<li>这个函数有何作用？用在哪里？<br>
用在销毁线程池之前，<strong>安全地执行完 </strong> 所有正在执行、尚未执行的任务。</li>
</ol>
<h3 id="线程池销毁">线程池销毁</h3>
<p>流程图右一：<code>void thpool_destroy(thpool_* thpool_p)</code></p>
<ol>
<li>复位全局活跃标志</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">threads_keepalive = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>复位的目的是，通过这个标志结束每个活跃线程的轮询（详见 <code>thread_do</code> 函数），并等待被唤醒后退出。</p>
<ol start="2">
<li>通过条件变量 <code>bsem_p-&gt;cond</code> 的唤醒，线程退出</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Give one second to kill idle threads */</span></span><br><span class="line"><span class="type">double</span> TIMEOUT = <span class="number">1.0</span>;</span><br><span class="line"><span class="type">time_t</span> start, end;</span><br><span class="line"><span class="type">double</span> tpassed = <span class="number">0.0</span>;</span><br><span class="line">time(&amp;start);</span><br><span class="line"><span class="keyword">while</span> (tpassed &lt; TIMEOUT &amp;&amp; thpool_p-&gt;num_threads_alive) &#123;</span><br><span class="line">    bsem_post_all(thpool_p-&gt;jobqueue.has_jobs);</span><br><span class="line">    time(&amp;end);</span><br><span class="line">    tpassed = difftime(end, start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Poll remaining threads */</span></span><br><span class="line"><span class="keyword">while</span> (thpool_p-&gt;num_threads_alive) &#123;</span><br><span class="line">    bsem_post_all(thpool_p-&gt;jobqueue.has_jobs);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里被唤醒后，<code>thread_do</code> 函数中的 <code>bsem_wait</code> 将被唤醒，随之跳出轮询并线程退出。</p>
<ol start="3">
<li>销毁任务队列</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">jobqueue_destroy(&amp;thpool_p-&gt;jobqueue);</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>其余堆上内存的释放</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; threads_total; n++) &#123;</span><br><span class="line">    thread_destroy(thpool_p-&gt;threads[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(thpool_p-&gt;threads);</span><br><span class="line"><span class="built_in">free</span>(thpool_p);</span><br></pre></td></tr></table></figure>
<p>关注点：</p>
<ol>
<li>对于 <strong> 线程释放的处理</strong>：<br>
可以定义一个条件变量来唤醒所有线程，通过复位 <code>threads_keepalive</code> 标志，使得在 <code>thread_do</code> 中被唤醒的线程，跳过任务执行（if）和轮询（while），达到优雅地退出。</li>
<li>对于 <strong> 唤醒线程的处理方式</strong>：<br>
超时时间内不断地、快速地唤醒所有活跃线程 + 固定时间轮询唤醒剩余活跃线程。为什么先后执行这两种方式，<strong>直接执行第二种方式不行吗</strong>？</li>
</ol>
<h3 id="线程池暂停与恢复">线程池暂停与恢复</h3>
<ol>
<li>注册信号并绑定线程暂停函数，实现在收到信号时暂停线程</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in function thread_do()</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">sigemptyset(&amp;act.sa_mask);</span><br><span class="line">act.sa_flags = SA_ONSTACK;</span><br><span class="line">act.sa_handler = thread_hold;</span><br><span class="line"><span class="keyword">if</span> (sigaction(SIGUSR1, &amp;act, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">    err(<span class="string">&quot;thread_do(): cannot handle SIGUSR1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">thread_hold</span><span class="params">(<span class="type">int</span> sig_id)</span> &#123;</span><br><span class="line">    (<span class="type">void</span>)sig_id;</span><br><span class="line">    threads_on_hold = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (threads_on_hold) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>流程图右二（上），暂停：<code>void thpool_pause(thpool_* thpool_p)</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; thpool_p-&gt;num_threads_alive; n++) &#123;</span><br><span class="line">    pthread_kill(thpool_p-&gt;threads[n]-&gt;pthread, SIGUSR1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数原型：<code>int pthread_kill(pthread_t thread, int sig)</code></p>
<p>函数描述：<code>pthread_kill()</code>函数向与调用者在同一进程中的线程 <code>thread</code> 发送信号 <code>sig</code>。该信号会<strong> 异步地 </strong> 被发送到 <code>thread</code> 线程中。发送成功返回 0，不成功返回非 0。</p>
<p>对「异步地」的理解：<code>pthread_kill()</code>函数向目标线程发送信号时，<strong>不会阻塞调用线程的执行 </strong>。换句话说，调用<code>pthread_kill()</code> 函数发送信号是一个异步操作，<strong>它会立即返回，而不会等待目标线程处理完信号后再继续执行</strong>。这意味着调用线程可以继续执行自己的任务，而不必等待目标线程对接收到的信号做出响应。</p>
<ol start="3">
<li>流程图右二（下），恢复：<code>void thpool_resume(thpool_* thpool_p)</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(<span class="type">void</span>)thpool_p;</span><br><span class="line">threads_on_hold = <span class="number">0</span>;  <span class="comment">// change its value here or thread_hold_on()</span></span><br></pre></td></tr></table></figure>
<p>关注点：</p>
<ol>
<li>线程池暂停与恢复函数是 <strong> 如何控制线程状态的</strong>？<br>
每个线程会注册一个信号，并绑定线程暂停函数。当线程池发出暂停时，每一个线程都将会收到一个暂停信号，这将触发执行 <code>thread_hold</code> 函数，进入循环睡眠，实现线程的暂停；当线程池发出恢复时，将 <code>threads_on_hold</code> 复位，<code>thread_hold</code> 函数将退出循环睡眠，线程继续执行。</li>
</ol>
<h2 id="线程接口">线程接口</h2>
<p>所有的线程接口都被 <code>static</code> 关键字修饰。</p>
<img src="../images/projects/c-thread-pool/thread-pool-thread-method.png" alt="线程池的线程接口" width="100%" height="100%">
<h3 id="线程初始化">线程初始化</h3>
<p>流程图左一：<code>static int thread_init(thpool_* thpool_p, struct thread** thread_p, int id)</code></p>
<ol>
<li>为线程池中的线程分配内存空间</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*thread_p = (<span class="keyword">struct</span> thread*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> thread));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么用二级指针作为入参？参考「线程池初始化 -3」小节。</p>
</blockquote>
<ol start="2">
<li>指定线程所属的线程池</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(*thread_p)-&gt;thpool_p = thpool_p;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这一步有何作用？通过线程找到对应的线程池，多个线程可以互斥地改变对应线程池的共享计数资源（发生在<code>thread_do</code>）。</p>
</blockquote>
<ol start="3">
<li>创建线程，并指定 start_routine 函数指针</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建实际线程，并开始执行 thread_do 函数（Worker 函数，其内部执行 Job 函数）</span></span><br><span class="line"><span class="comment"> * int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment"> * (void* (*)(void*))是一个强制类型转换，将 thread_do 函数类型强转为 start_routine 的 void *(*) (void *)类型</span></span><br><span class="line"><span class="comment"> * pthread_detach 函数用于将指定的线程分离出去，主线程不再需要通过 pthread_join 方式回收资源，被分离的线程结束后由 OS 回收资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">pthread_create(&amp;((*thread_p)-&gt;pthread), <span class="literal">NULL</span>, (<span class="type">void</span>* (*)(<span class="type">void</span>*))thread_do, (*thread_p));</span><br><span class="line">pthread_detach((*thread_p)-&gt;pthread);</span><br></pre></td></tr></table></figure>
<h3 id="线程 worker">线程 worker</h3>
<p>这是核心代码，Worker 作为一个无休止的循环，唯一的被中断是调用 <code>thpool_destroy()</code> 或程序退出。它作为一个 Worker，在内部执行不断入队的 Job。</p>
<ol>
<li>获取线程所属的线程池</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">thpool_* thpool_p = thread_p-&gt;thpool_p;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>互斥地更新活跃线程数量</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;thpool_p-&gt;thcount_lock);</span><br><span class="line">thpool_p-&gt;num_threads_alive += <span class="number">1</span>;</span><br><span class="line">pthread_mutex_unlock(&amp;thpool_p-&gt;thcount_lock);</span><br></pre></td></tr></table></figure>
<p>在「线程初始化」中，每创建一个线程示例，都会执行对应的启动例程，即<code>thread_do</code>，这个线程运行起来，共享计数量加一。</p>
<ol start="3">
<li>进入轮询（poll），等待条件变量的唤醒通知</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (threads_keepalive) &#123;</span><br><span class="line">    bsem_wait(thpool_p-&gt;jobqueue.has_jobs);</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>有任务被唤醒，执行 Job 任务</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (threads_keepalive) &#123;</span><br><span class="line">    job* job_p = jobqueue_pull(&amp;thpool_p-&gt;jobqueue);</span><br><span class="line">    job_p-&gt;function(job_p-&gt;arg);</span><br><span class="line">    <span class="built_in">free</span>(job_p);</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>无任务被唤醒，即是被 <code>thpool_destroy()</code> 唤醒，if 不成立，while 不成立，退出轮询，活跃线程退出。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;thpool_p-&gt;thcount_lock);</span><br><span class="line">thpool_p-&gt;num_threads_alive--;</span><br><span class="line">pthread_mutex_unlock(&amp;thpool_p-&gt;thcount_lock);</span><br></pre></td></tr></table></figure>
<h2 id="队列接口">队列接口</h2>
<p>任务队列主要是为线程服务的。当有新任务到来时，<code>thpool_add_work</code> 调用 push 函数将新任务插入队尾；当线程检测到任务队列有任务时，及时将任务从队列中 pull 并执行它。</p>
<img src="../images/projects/c-thread-pool/thread-pool-queue-method.png" alt="线程池的任务队列接口" width="100%" height="100%">
<p>具体接口在这里就不再介绍了，直接看流程吧，挺详细的。核心就在 push&amp;pull 操作后，若队列中仍有剩余任务，则会通知唤醒等待在条件变量上的线程，从而使得线程可以执行队列中的任务；当队列为空时，不再通知唤醒线程，线程便会阻塞在条件变量上。</p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://nachtimwald.com/2019/04/12/thread-pool-in-c/">https://nachtimwald.com/2019/04/12/thread-pool-in-c/</a></li>
<li><a href="https://smartyue076.github.io/2023/06/10/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/">https://smartyue076.github.io/2023/06/10/ 线程池原理与实现 /</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1849765">https://cloud.tencent.com/developer/article/1849765</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>项目</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>DPDK 无锁环形队列</title>
    <url>/posts/240627210637.html</url>
    <content><![CDATA[<p>DPDK 中的无锁环形队列利用原子操作（CAS）、出入队前后的内存屏蔽和高效的数据结构，提供了一个多生产者、多消费者并发安全的队列实现。但真的是“无锁”实现吗？</p>
<p>严格来说，“无锁”指的是避免使用传统的锁（例如互斥锁、读写锁等）来控制并发访问。在某些情况下，使用 CAS（Compare-And-Swap）等原子操作也会被称为无锁编程，因为它们不需要锁的开销（如上下文切换开销）。</p>
<p>其实，DPDK 中的无锁环形队的单生产者、单消费者是真正无锁的（也没有使用 CAS 原子操作）；但是，对于多生产者、多消费者来说，其利用了 CAS 原子操作来实现互斥地修改生产者、消费者的头指针和尾指针，达到安全地进行数据的并发访问。</p>
<span id="more"></span>
<blockquote>
<p>为什么单生产者、单消费者是无锁的？因为单生产者只会竞争写入位置，单消费者只会竞争读取位置，不会出现跨线程的竞争同一位置。</p>
</blockquote>
<h1 id="前置知识">前置知识</h1>
<h2 id="柔性数组成员">柔性数组成员</h2>
<h3 id="概念">概念</h3>
<p><code>void *ring[0]</code> 和 <code>void *ring</code> 都是指针类型，但它们有不同的含义和用法。</p>
<ul>
<li><code>void *ring</code>是一个指向 <code>void</code> 类型的 <em> 指针变量</em>。它可以指向任意类型的数据，但它本身只是一块内存地址。</li>
<li><code>void *ring[0]</code>是一个 <em> 指针数组 </em>，数组的大小为 0，<strong> 放在结构体的最后一个成员中以声明变长数组</strong>。</li>
</ul>
<p>在 C 语言中，数组大小为 0 是非法的，通常不被允许。然而，在某些编译器扩展和特定用法（<strong>例如在结构体的最后一个成员中</strong>）中，使用零长度数组是一种常见的技巧，用于实现柔性数组成员（Flexible Array Member，FAM）。FAM 是一种用于在结构体中声明变长数组的方法。</p>
<h3 id="示例">示例</h3>
<p><code>void *ring</code> 用法示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">example1</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *ring;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">example1</span> *<span class="title">ex</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> example1));</span><br><span class="line">ex-&gt;ring = <span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配一个存储 10 个 int 的空间</span></span><br><span class="line"><span class="comment">// ex-&gt;ring 是一个单个指针，指向一块动态分配的内存</span></span><br></pre></td></tr></table></figure>
<p><code>void *ring[0]</code> 用法示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">example2</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">void</span> *ring[<span class="number">0</span>]; <span class="comment">// 柔性数组成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">example2</span> *<span class="title">ex</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> example2) + <span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">void</span> *)); <span class="comment">// NOTE</span></span><br><span class="line">ex-&gt;size = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// ex-&gt;ring 是一个指向 10 个 void* 的数组</span></span><br></pre></td></tr></table></figure>
<p><code>ring[0]</code>是一个柔性数组成员，<strong>用于在结构体中实现变长数据</strong>。分配内存后，<code>ring[0]</code> 表示数据的开始位置。</p>
<p>实际使用时，柔性数组成员可 <strong> 作为数据项 </strong>，通常会分配比结构体定义更大的内存，如上面额外的<code>10 * sizeof(void *)</code> 资源，以便容纳实际的数据项。</p>
<h3 id="优点">优点</h3>
<p>在结构体中使用柔性数组成员的优点：</p>
<ul>
<li><strong>不占用任何空间 </strong>：由于<code>ring[0]</code> 是一个柔性数组成员，其大小在编译时为 0，不占用结构体本身的空间。</li>
<li><strong>分配时连续 </strong>：当为这个结构体 malloc 分配内存时，<mark> 会同时分配结构体和需要存储的数据项所需的所有内存，且这两块内存是连续的</mark>。</li>
<li><strong>方便内存释放 </strong>：因为内存是一次性分配的（不像上面的 example1 和它的 ring 成员是分别 malloc 的），释放时也只需要一次 free 操作即可释放整个结构体<strong> 及其包含的数据项</strong>。</li>
<li><strong>能提高速度</strong>：连续内存分配使得缓存命中率更高，内存访问速度更快。这对于需要高性能的应用来说是非常重要的。</li>
</ul>
<h1 id="DPDK 无锁环形队列">DPDK 无锁环形队列</h1>
<ul>
<li>DPDK 版本：v2.2.0，与高版本（如 v20.08）中 rte_ring 的结构有所不同，这里还是从简单的结构学起吧。</li>
</ul>
<h2 id="rte-ring 数据结构">rte_ring 数据结构</h2>
<p>数据结构 rte_ring 中需要关注的点：</p>
<ul>
<li class="checkbox-item"><input type="checkbox" id="checkbox5" checked="true"><label for="checkbox5">size 必须是一个 2 的幂次方的数，mask=size-1。</label></li>
<li class="checkbox-item"><input type="checkbox" id="checkbox6" checked="true"><label for="checkbox6"></label><strong>生产者和消费者各有一对 head 和 tail 索引（而不是共用一对 head 和 tail 索引）：其实这是为了实现多个线程同时出队、入队</strong>（具体看后面的代码、配图）；</li>
<li class="checkbox-item"><input type="checkbox" id="checkbox7" checked="true"><label for="checkbox7">head 和 tail 索引不是在 </label><code>[0, size)</code> 区间，而是在 <code>[0, 2^32)</code> 区间。</li>
<li class="checkbox-item"><input type="checkbox" id="checkbox8" checked="true"><label for="checkbox8">在结构体的最后一个成员使用柔性数组 </label><code>void *ring[0]</code> 作为数据项（其优点见《前置知识》小节）。</li>
<li class="checkbox-item"><input type="checkbox" id="checkbox9" checked="true"><label for="checkbox9">通过 head &amp; mask 和 tail &amp; mask 位运算来达到模运算，以高效地访问 </label><code>ring[]</code> 数组。</li>
<li class="checkbox-item"><input type="checkbox" id="checkbox10" checked="true"><label for="checkbox10">一般生产者和消费者线程会被不同的 CPU 核访问，因此结构体的 prod&amp;cons 成员使用了</label><code>__rte_cache_aligned</code>，将其分配到不同的 cache line。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An RTE ring structure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The producer and the consumer have a head and a tail index. The particularity</span></span><br><span class="line"><span class="comment"> * of these index is that they are not between 0 and size(ring). These indexes</span></span><br><span class="line"><span class="comment"> * are between 0 and 2^32, and we mask their value when we access the ring[]</span></span><br><span class="line"><span class="comment"> * field. Thanks to this assumption, we can do subtractions between 2 index</span></span><br><span class="line"><span class="comment"> * values in a modulo-32bit base: that&#x27;s why the overflow of the indexes is not</span></span><br><span class="line"><span class="comment"> * a problem.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_ring</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[RTE_RING_NAMESIZE]; <span class="comment">/**&lt; Name of the ring. */</span></span><br><span class="line">    <span class="type">int</span> flags;                    <span class="comment">/**&lt; 创建模式，支持多 / 单生产者和多 / 单消费者 */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rte_memzone</span>* <span class="title">memzone</span>;</span></span><br><span class="line">    <span class="comment">/**&lt; Memzone, if any, containing the rte_ring */</span></span><br><span class="line">    <span class="comment">/**&lt; rte_menzone 是 dpdk 内存管理底层的数据结构，memzone 用于记录在哪块 mem 分配的 rte_ring，释放的时候使用 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Ring producer status. 生产者数据结构 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">prod</span> &#123;</span></span><br><span class="line">        <span class="type">uint32_t</span> watermark;     <span class="comment">/**&lt; Maximum items before EDQUOT. 水位线，用于检查入队后是否超过水位线 */</span></span><br><span class="line">        <span class="type">uint32_t</span> sp_enqueue;    <span class="comment">/**&lt; True, if single producer. */</span></span><br><span class="line">        <span class="type">uint32_t</span> size;          <span class="comment">/**&lt; Size of ring. */</span></span><br><span class="line">        <span class="type">uint32_t</span> mask;          <span class="comment">/**&lt; Mask (size-1) of ring. */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">uint32_t</span> head; <span class="comment">/**&lt; Producer head. 入队前更新 head 字段，然后进行入队 */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">uint32_t</span> tail; <span class="comment">/**&lt; Producer tail. 入队完更新 tail 字段（让先更新过 head 字段的线程</span></span><br><span class="line"><span class="comment">                                                    优先更新 tail 字段，自己等待一会），更新后 tail == head */</span></span><br><span class="line">    &#125; prod __rte_cache_aligned;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Ring consumer status. 消费者数据结构 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cons</span> &#123;</span></span><br><span class="line">        <span class="type">uint32_t</span> sc_dequeue;    <span class="comment">/**&lt; True, if single consumer. */</span></span><br><span class="line">        <span class="type">uint32_t</span> size;          <span class="comment">/**&lt; Size of the ring. */</span></span><br><span class="line">        <span class="type">uint32_t</span> mask;          <span class="comment">/**&lt; Mask (size-1) of ring. */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">uint32_t</span> head; <span class="comment">/**&lt; Consumer head. 与生产者处理逻辑一样 */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">uint32_t</span> tail; <span class="comment">/**&lt; Consumer tail. 与生产者处理逻辑一样 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTE_RING_SPLIT_PROD_CONS</span></span><br><span class="line">    <span class="comment">/* 这个属性就是要求 gcc 在编译的时候，把 cons/prod 结构分配到不同的 cache line，为什么这样做？</span></span><br><span class="line"><span class="comment">        因为如果没有这些的话，这两个结构在内存上是连续的，编译器不会把他们分配到不同 cache line，</span></span><br><span class="line"><span class="comment">        而一般上这两个结构是要被不同的 CPU 核访问的，如果连续的话这两个核就会产生伪共享问题 */</span></span><br><span class="line">    &#125; cons __rte_cache_aligned;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    &#125; cons;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTE_LIBRTE_RING_DEBUG</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_ring_debug_stats</span> <span class="title">stats</span>[<span class="title">RTE_MAX_LCORE</span>];</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* ring[<span class="number">0</span>] __rte_cache_aligned; <span class="comment">/**&lt; Memory space of ring starts here.</span></span><br><span class="line"><span class="comment">                                        * not volatile so need to be careful</span></span><br><span class="line"><span class="comment">                                        * about compiler re-ordering */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="相关宏">相关宏</h2>
<p>TAILQ_HEAD 和 TAILQ_ENTRY 尾队列设计细节可参考 <a href="/posts/240702200642.html"> 这篇文章</a>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 尾队列表头 TAILQ_HEAD 宏定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_HEAD(name, type)                                  \</span></span><br><span class="line"><span class="meta">    struct name &#123;                                               \</span></span><br><span class="line"><span class="meta">        struct type* tqh_first; <span class="comment">/* first element */</span>             \</span></span><br><span class="line"><span class="meta">        struct type** tqh_last; <span class="comment">/* addr of last next element */</span> \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 尾队列实体 TAILQ_ENTRY 宏定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_ENTRY(type)                                              \</span></span><br><span class="line"><span class="meta">    struct &#123;                                                           \</span></span><br><span class="line"><span class="meta">        struct type* tqe_next;  <span class="comment">/* next element */</span>                     \</span></span><br><span class="line"><span class="meta">        struct type** tqe_prev; <span class="comment">/* address of previous next element */</span> \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** dummy structure type used by the rte_tailq APIs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_tailq_entry</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 扩展到：</span></span><br><span class="line"><span class="comment">            struct &#123;</span></span><br><span class="line"><span class="comment">                    struct rte_tailq_entry* tqe_next;</span></span><br><span class="line"><span class="comment">                    struct rte_tailq_entry** tqe_prev;</span></span><br><span class="line"><span class="comment">            &#125; next;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TAILQ_ENTRY(rte_tailq_entry) next; <span class="comment">/**&lt; Pointer entries for a tailq list */</span></span><br><span class="line">    <span class="type">void</span>* data;                        <span class="comment">/**&lt; Pointer to the data referenced by this tailq entry */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** dummy */</span></span><br><span class="line"><span class="comment">/* 扩展到：</span></span><br><span class="line"><span class="comment">        struct rte_tailq_entry_head &#123;</span></span><br><span class="line"><span class="comment">                struct rte_tailq_entry* tqh_first;</span></span><br><span class="line"><span class="comment">                struct rte_tailq_entry** tqh_last;</span></span><br><span class="line"><span class="comment">        &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TAILQ_HEAD(rte_tailq_entry_head, rte_tailq_entry);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_TAILQ_NAMESIZE 32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The structure defining a tailq header entry for storing</span></span><br><span class="line"><span class="comment"> * in the rte_config structure in shared memory. Each tailq</span></span><br><span class="line"><span class="comment"> * is identified by name.</span></span><br><span class="line"><span class="comment"> * Any library storing a set of objects e.g. rings, mempools, hash-tables,</span></span><br><span class="line"><span class="comment"> * is recommended to use an entry here, so as to make it easy for</span></span><br><span class="line"><span class="comment"> * a multi-process app to find already-created elements in shared memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_tailq_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_tailq_entry_head</span> <span class="title">tailq_head</span>;</span> <span class="comment">/**&lt; <span class="doctag">NOTE:</span> must be first element */</span></span><br><span class="line">    <span class="type">char</span> name[RTE_TAILQ_NAMESIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_tailq_elem</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reference to head in shared mem, updated at init time by</span></span><br><span class="line"><span class="comment">     * rte_eal_tailqs_init()</span></span><br><span class="line"><span class="comment">     * 在初始化时由 rte_eal_tailqs_init() 更新的共享内存中的头部引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_tailq_head</span>* <span class="title">head</span>;</span></span><br><span class="line">    <span class="comment">/* 扩展到：</span></span><br><span class="line"><span class="comment">            struct &#123;</span></span><br><span class="line"><span class="comment">                    struct rte_tailq_elem* tqe_next;</span></span><br><span class="line"><span class="comment">                    struct rte_tailq_elem** tqe_prev;</span></span><br><span class="line"><span class="comment">            &#125; next;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TAILQ_ENTRY(rte_tailq_elem) next;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> name[RTE_TAILQ_NAMESIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the first tailq entry casted to the right struct.</span></span><br><span class="line"><span class="comment"> * 返回转换为正确结构的第一个 tailq 条目</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_TAILQ_CAST(tailq_entry, struct_name) (struct struct_name*)&amp;(tailq_entry)-&gt;tailq_head</span></span><br></pre></td></tr></table></figure>
<h2 id="宏扩展后的数据结构">宏扩展后的数据结构</h2>
<p>上面的宏定义，使用 gcc -E 预处理后是这样的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_tailq_entry</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rte_tailq_entry</span>* <span class="title">tqe_next</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rte_tailq_entry</span>** <span class="title">tqe_prev</span>;</span></span><br><span class="line">    &#125; next;</span><br><span class="line">    <span class="type">void</span>* data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_tailq_entry_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_tailq_entry</span>* <span class="title">tqh_first</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_tailq_entry</span>** <span class="title">tqh_last</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_tailq_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_tailq_entry_head</span> <span class="title">tailq_head</span>;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_tailq_elem</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_tailq_head</span>* <span class="title">head</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rte_tailq_elem</span>* <span class="title">tqe_next</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rte_tailq_elem</span>** <span class="title">tqe_prev</span>;</span></span><br><span class="line">    &#125; next;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_ring_list</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_tailq_entry</span>* <span class="title">tqh_first</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_tailq_entry</span>** <span class="title">tqh_last</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义全局 rte_ring_tailq 尾队列，里面可以添加很多个创建的 ring_list（也是一个尾队列） */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rte_tailq_elem</span> <span class="title">rte_ring_tailq</span> =</span> &#123;</span><br><span class="line">    .name = RTE_TAILQ_RING_NAME,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="内存分布及挂接方式">内存分布及挂接方式</h2>
<p>全局 rte_ring_tailq 尾队列的内存分布及挂接方式：</p>
<img src="/images/data-structure/dpdk-lockless-ring-queue-1.png" alt="DPDK 无锁环形队列内存分布及挂接方式" width="100%" height="100%">
<h2 id="rte-ring-create 队列创建">rte_ring_create 队列创建</h2>
<p>几处要点：</p>
<ul>
<li>ring_size：计算待申请的 rte_ring 的大小（而不是申请空间），包含 void* ring[]数据块的空间。</li>
<li>te：申请一块 rte_tailq_entry 的空间。</li>
<li>r = mz-&gt;addr：申请一块内存，其中 mz-&gt;addr 指向了申请的大小为 ring_size 的 rte_ring 结构的首地址。</li>
<li>rte_ring_init：对上一步申请的大小为 ring_size 的 rte_ring 结构 r 进行初始化。</li>
<li>te-&gt;data = (void*)r：初始化参数之后，把 rte_tailq_entry 的 data 节点指向 rte_ring 结构地址。
<ul>
<li>要干嘛？尾队列里面的每个 entry 的 data 项都指向一个 rte_ring 无锁环形队列。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * rte_ring_create - create the ring</span></span><br><span class="line"><span class="comment"> * @name: 唯一标识 ring 的 name，不同的 ring 具有不同的 name</span></span><br><span class="line"><span class="comment"> * @count: ring 队列的长度，必须是 2 的幂次方</span></span><br><span class="line"><span class="comment"> * @socket_id: ring 位于的 socket（不是那个网络 socket）</span></span><br><span class="line"><span class="comment"> * @flags: 指定创建的 ring 的属性：单 / 多生产者、单 / 多消费者之间的组合。</span></span><br><span class="line"><span class="comment"> *         0 表示使用默认属性（多生产者、多消费者）。不同的属性出入队的操作会有所不同。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> rte_ring* <span class="title function_">rte_ring_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">unsigned</span> count, <span class="type">int</span> socket_id, <span class="type">unsigned</span> flags)</span> &#123;</span><br><span class="line">    <span class="type">char</span> mz_name[RTE_MEMZONE_NAMESIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_ring</span>* <span class="title">r</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_tailq_entry</span>* <span class="title">te</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rte_memzone</span>* <span class="title">mz</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> ring_size;</span><br><span class="line">    <span class="type">int</span> mz_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_ring_list</span>* <span class="title">ring_list</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这里是把 rte_tailq_entry_head 结构强转成了 rte_ring_list 结构，这俩结构的构成完全一样，强转没啥影响 */</span></span><br><span class="line">    ring_list = RTE_TAILQ_CAST(rte_ring_tailq.head, rte_ring_list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回申请的资源大小（包含结构体和数据块）：sizeof(struct rte_ring) + (count * sizeof(void *)) */</span></span><br><span class="line">    ring_size = rte_ring_get_memsize(count);</span><br><span class="line">    <span class="keyword">if</span> (ring_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        rte_errno = ring_size;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 申请一个 TAILQ ENTRY 尾队列节点的资源，在创建完成 rte_ring 后，挂接这个无锁队列到尾队列 entry 中 */</span></span><br><span class="line">    te = rte_zmalloc(<span class="string">&quot;RING_TAILQ_ENTRY&quot;</span>, <span class="keyword">sizeof</span>(*te), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (te == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        RTE_LOG(ERR, RING, <span class="string">&quot;Cannot reserve memory for tailq\n&quot;</span>);</span><br><span class="line">        rte_errno = ENOMEM;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 给唯一标识 ring 的名字增加一个前缀 */</span></span><br><span class="line">    <span class="built_in">snprintf</span>(mz_name, <span class="keyword">sizeof</span>(mz_name), <span class="string">&quot;%s%s&quot;</span>, RTE_RING_MZ_PREFIX, name);</span><br><span class="line"></span><br><span class="line">    rte_rwlock_write_lock(RTE_EAL_TAILQ_RWLOCK);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reserve a memory zone for this ring. If we can&#x27;t get rte_config or</span></span><br><span class="line"><span class="comment">     * we are secondary process, the memzone_reserve function will set</span></span><br><span class="line"><span class="comment">     * rte_errno for us appropriately - hence no check in this this function</span></span><br><span class="line"><span class="comment">     * 为新创建的 ring 分配内存空间 */</span></span><br><span class="line">    mz = rte_memzone_reserve(mz_name, ring_size, socket_id, mz_flags);</span><br><span class="line">    <span class="keyword">if</span> (mz != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        r = mz-&gt;addr;  <span class="comment">// 获取分配的内存空间的起始地址</span></span><br><span class="line">        <span class="comment">/* no need to check return value here, we already checked the</span></span><br><span class="line"><span class="comment">         * arguments above */</span></span><br><span class="line">        rte_ring_init(r, name, count, flags);  <span class="comment">// ring 队列初始化</span></span><br><span class="line"></span><br><span class="line">        te-&gt;data = (<span class="type">void</span>*)r; <span class="comment">// 挂接这个无锁队列到尾队列 entry 中</span></span><br><span class="line">        r-&gt;memzone = mz;</span><br><span class="line">        <span class="comment">/* 在全局尾队列 ring_list 上挂接一个节点 te（其数据为 ring 结构的节点 r 的地址）*/</span></span><br><span class="line">        TAILQ_INSERT_TAIL(ring_list, te, next);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r = <span class="literal">NULL</span>;</span><br><span class="line">        RTE_LOG(ERR, RING, <span class="string">&quot;Cannot reserve memory\n&quot;</span>);</span><br><span class="line">        rte_free(te);</span><br><span class="line">    &#125;</span><br><span class="line">    rte_rwlock_write_unlock(RTE_EAL_TAILQ_RWLOCK);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rte-ring-init 环初始化">rte_ring_init 环初始化</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rte_ring_init</span><span class="params">(<span class="keyword">struct</span> rte_ring* r, <span class="type">const</span> <span class="type">char</span>* name, <span class="type">unsigned</span> count, <span class="type">unsigned</span> flags)</span> &#123;</span><br><span class="line">    <span class="comment">/* compilation-time checks */</span></span><br><span class="line">    RTE_BUILD_BUG_ON((<span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_ring) &amp; RTE_CACHE_LINE_MASK) != <span class="number">0</span>);</span><br><span class="line">    RTE_BUILD_BUG_ON((offsetof(<span class="keyword">struct</span> rte_ring, prod) &amp; RTE_CACHE_LINE_MASK) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init the ring structure */</span></span><br><span class="line">    <span class="built_in">memset</span>(r, <span class="number">0</span>, <span class="keyword">sizeof</span>(*r));</span><br><span class="line">    <span class="built_in">snprintf</span>(r-&gt;name, <span class="keyword">sizeof</span>(r-&gt;name), <span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    r-&gt;flags = flags;</span><br><span class="line">    r-&gt;prod.watermark = count;</span><br><span class="line">    r-&gt;prod.sp_enqueue = !!(flags &amp; RING_F_SP_ENQ); <span class="comment">// 是否是 single-producer</span></span><br><span class="line">    r-&gt;cons.sc_dequeue = !!(flags &amp; RING_F_SC_DEQ); <span class="comment">// 是否是 single-consumer</span></span><br><span class="line">    r-&gt;prod.size = r-&gt;cons.size = count;</span><br><span class="line">    r-&gt;prod.mask = r-&gt;cons.mask = count - <span class="number">1</span>;</span><br><span class="line">    r-&gt;prod.head = r-&gt;cons.head = <span class="number">0</span>; <span class="comment">// 生产者与消费者的头指针索引</span></span><br><span class="line">    r-&gt;prod.tail = r-&gt;cons.tail = <span class="number">0</span>; <span class="comment">// 生产者与消费者的尾指针索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rte-ring-free 环释放">rte_ring_free 环释放</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* free the ring */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rte_ring_free</span><span class="params">(<span class="keyword">struct</span> rte_ring* r)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_ring_list</span>* <span class="title">ring_list</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_tailq_entry</span>* <span class="title">te</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ring was not created with rte_ring_create,</span></span><br><span class="line"><span class="comment">     * therefore, there is no memzone to free.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;memzone == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        RTE_LOG(ERR, RING, <span class="string">&quot;Cannot free ring (not created with rte_ring_create()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rte_memzone_free(r-&gt;memzone) != <span class="number">0</span>) &#123;</span><br><span class="line">        RTE_LOG(ERR, RING, <span class="string">&quot;Cannot free memory\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ring_list = RTE_TAILQ_CAST(rte_ring_tailq.head, rte_ring_list);</span><br><span class="line">    rte_rwlock_write_lock(RTE_EAL_TAILQ_RWLOCK);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* find out tailq entry，找出尾队列节点中 data 指向入参 r 的 entry */</span></span><br><span class="line">    TAILQ_FOREACH(te, ring_list, next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (te-&gt;data == (<span class="type">void</span>*)r)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (te == <span class="literal">NULL</span>) &#123; <span class="comment">// 没找到</span></span><br><span class="line">        rte_rwlock_write_unlock(RTE_EAL_TAILQ_RWLOCK);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TAILQ_REMOVE(ring_list, te, next); <span class="comment">// 找到，从全局尾队列中摘除该 rte_ring 无锁队列</span></span><br><span class="line"></span><br><span class="line">    rte_rwlock_write_unlock(RTE_EAL_TAILQ_RWLOCK);</span><br><span class="line"></span><br><span class="line">    rte_free(te);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单生产者单消费者出入队">单生产者单消费者出入队</h2>
<h3 id="单生产者 sp 入队">单生产者 sp 入队</h3>
<p>核心流程：</p>
<ol>
<li>首先，获取 prod.head 和 cons.tail 位置，然后计算空余 buffer 数量为 mask-(prod.head - cons.tail)；</li>
<li>其次，在入队操作前，修改 prod.head，后移 n 个单位，表明生产者将要生产到这里；</li>
<li>然后，进行入队操作 ENQUEUE_PTRS；</li>
<li>最后，在入队操作后，修改 prod.tail，使其值为生产前的 prod.head+n，表明生产完成后其尾节点的正确位置。
<ul>
<li>如果是单生产者模式，其实可以直接使用当前的 prod.head；但是如果多生产者模式，不能直接使用，因为多个线程会竞争写入。</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @internal Enqueue several objects on a ring (NOT multi-producers safe).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param r</span></span><br><span class="line"><span class="comment"> *   A pointer to the ring structure.</span></span><br><span class="line"><span class="comment"> * @param obj_table</span></span><br><span class="line"><span class="comment"> *   A pointer to a table of void * pointers (objects).</span></span><br><span class="line"><span class="comment"> * @param n</span></span><br><span class="line"><span class="comment"> *   The number of objects to add in the ring from the obj_table.</span></span><br><span class="line"><span class="comment"> * @param behavior 环的两种入队模式：固定数量入队、尽力而为入队</span></span><br><span class="line"><span class="comment"> *   RTE_RING_QUEUE_FIXED:    Enqueue a fixed number of items from a ring</span></span><br><span class="line"><span class="comment"> *   RTE_RING_QUEUE_VARIABLE: Enqueue as many items a possible from ring</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *   Depend on the behavior value</span></span><br><span class="line"><span class="comment"> *   if behavior = RTE_RING_QUEUE_FIXED</span></span><br><span class="line"><span class="comment"> *   - 0: Success; objects enqueue.</span></span><br><span class="line"><span class="comment"> *   - -EDQUOT: Quota exceeded. The objects have been enqueued, but the</span></span><br><span class="line"><span class="comment"> *     high water mark is exceeded.</span></span><br><span class="line"><span class="comment"> *   - -ENOBUFS: Not enough room in the ring to enqueue, no object is enqueued.</span></span><br><span class="line"><span class="comment"> *   if behavior = RTE_RING_QUEUE_VARIABLE</span></span><br><span class="line"><span class="comment"> *   - n: Actual number of objects enqueued.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __attribute__((always_inline))</span><br><span class="line">__rte_ring_sp_do_enqueue(<span class="keyword">struct</span> rte_ring *r, <span class="type">void</span> * <span class="type">const</span> *obj_table,</span><br><span class="line">             <span class="type">unsigned</span> n, <span class="keyword">enum</span> rte_ring_queue_behavior behavior)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> prod_head, cons_tail; <span class="comment">// 假设无边界时，两指针的相对顺序：0____ct------ph________+inf</span></span><br><span class="line">    <span class="type">uint32_t</span> prod_next, free_entries;</span><br><span class="line">    <span class="type">unsigned</span> i;</span><br><span class="line">    <span class="type">uint32_t</span> mask = r-&gt;prod.mask; <span class="comment">// 等于 size(ring)-1</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    prod_head = r-&gt;prod.head;</span><br><span class="line">    cons_tail = r-&gt;cons.tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The subtraction is done between two unsigned 32bits value</span></span><br><span class="line"><span class="comment">     * (the result is always modulo 32 bits even if we have</span></span><br><span class="line"><span class="comment">     * prod_head &gt; cons_tail). So &#x27;free_entries&#x27; is always between 0</span></span><br><span class="line"><span class="comment">     * and size(ring)-1. */</span></span><br><span class="line">    free_entries = mask + cons_tail - prod_head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check that we have enough room in ring */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(n &gt; free_entries)) &#123; <span class="comment">// 入队的 obj 数量大于队列空余空间</span></span><br><span class="line">        <span class="keyword">if</span> (behavior == RTE_RING_QUEUE_FIXED) &#123; <span class="comment">// 固定数量入队模式：无法全部入队，异常退出</span></span><br><span class="line">            __RING_STAT_ADD(r, enq_fail, n);</span><br><span class="line">            <span class="keyword">return</span> -ENOBUFS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 尽力而为入队模式：入队全部空余空间，即入队 free_entries 个 obj</span></span><br><span class="line">            <span class="comment">/* No free entry available */</span></span><br><span class="line">            <span class="keyword">if</span> (unlikely(free_entries == <span class="number">0</span>)) &#123;</span><br><span class="line">                __RING_STAT_ADD(r, enq_fail, n);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            n = free_entries; <span class="comment">// 实际入队 free_entries 个 obj</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prod_next = prod_head + n;</span><br><span class="line">    r-&gt;prod.head = prod_next; <span class="comment">// 修改 ring 结构中的 prod.head 指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* write entries in ring */</span></span><br><span class="line">    ENQUEUE_PTRS(); <span class="comment">// 入队操作</span></span><br><span class="line">    rte_smp_wmb();  <span class="comment">// 内存屏障</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if we exceed the watermark */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(((mask + <span class="number">1</span>) - free_entries + n) &gt; r-&gt;prod.watermark)) &#123; <span class="comment">// 已经用的空间 + 本次实际使用的空间 大于 水位线</span></span><br><span class="line">        ret = (behavior == RTE_RING_QUEUE_FIXED) ? -EDQUOT :</span><br><span class="line">            (<span class="type">int</span>)(n | RTE_RING_QUOT_EXCEED); <span class="comment">// 按模式指定异常返回值</span></span><br><span class="line">        __RING_STAT_ADD(r, enq_quota, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = (behavior == RTE_RING_QUEUE_FIXED) ? <span class="number">0</span> : n; <span class="comment">// 返回对应模式的成功状态下的返回值</span></span><br><span class="line">        __RING_STAT_ADD(r, enq_success, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r-&gt;prod.tail = prod_next; <span class="comment">// 修改 ring 结构中的 prod.tail 指针（sp 模式下，这里等于 prod.head 的值）</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="入队宏">入队宏</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* the actual enqueue of pointers on the ring.</span></span><br><span class="line"><span class="comment"> * Placed here since identical code needed in both</span></span><br><span class="line"><span class="comment"> * single and multi producer enqueue functions */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENQUEUE_PTRS() do &#123; \</span></span><br><span class="line"><span class="meta">    const uint32_t size = r-&gt;prod.size; \</span></span><br><span class="line"><span class="meta">    uint32_t idx = prod_head &amp; mask; \ <span class="comment">// 获取入队的起始索引</span></span></span><br><span class="line">    <span class="keyword">if</span> (likely(idx + n &lt; size)) &#123; \ <span class="comment">// 起始索引 + 入队量 小于 ring 大小，则直接往后入队，不用回绕到最开始继续入队</span></span><br><span class="line">        <span class="comment">// 先 4 个、4 个的入队（循环步长是 4），依次赋值，相当于循环展开优化，减少计算循环索引和预测条件分支判断等优化</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (n &amp; ((~(<span class="type">unsigned</span>)<span class="number">0x3</span>))); i+=<span class="number">4</span>, idx+=<span class="number">4</span>) &#123; \</span><br><span class="line">            r-&gt;ring[idx] = obj_table[i]; \</span><br><span class="line">            r-&gt;ring[idx+<span class="number">1</span>] = obj_table[i+<span class="number">1</span>]; \</span><br><span class="line">            r-&gt;ring[idx+<span class="number">2</span>] = obj_table[i+<span class="number">2</span>]; \</span><br><span class="line">            r-&gt;ring[idx+<span class="number">3</span>] = obj_table[i+<span class="number">3</span>]; \</span><br><span class="line">        &#125; \</span><br><span class="line">        <span class="keyword">switch</span> (n &amp; <span class="number">0x3</span>) &#123; \ <span class="comment">// 最后不足 4 个的 obj 入队</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: r-&gt;ring[idx++] = obj_table[i++]; \</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: r-&gt;ring[idx++] = obj_table[i++]; \</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: r-&gt;ring[idx++] = obj_table[i++]; \</span><br><span class="line">        &#125; \</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; \ <span class="comment">// 起始索引 + 入队量 不小于 ring 大小，则往后入队一部分到右边界，然后从左边界入队余下的一部分</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; idx &lt; size; i++, idx++)\ <span class="comment">// 入队部分 obj 到 ring 的[idx, size-1]</span></span><br><span class="line">            r-&gt;ring[idx] = obj_table[i]; \</span><br><span class="line">        <span class="keyword">for</span> (idx = <span class="number">0</span>; i &lt; n; i++, idx++) \ <span class="comment">// 入队余下的 obj 到 ring 的[0, n-(size-idx)-1]</span></span><br><span class="line">            r-&gt;ring[idx] = obj_table[i]; \</span><br><span class="line">    &#125; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="单消费者 sc 出队">单消费者 sc 出队</h3>
<p>核心流程：</p>
<ol>
<li>首先，获取 prod.tail 和 cons.head 位置，然后计算有效 buffer 数量为(prod.tail - cons.head)；</li>
<li>其次，在出队操作前，修改 cons.head，后移 n 个单位，表明消费者将要消费到这里；</li>
<li>然后，进行出队操作 DEQUEUE_PTRS；</li>
<li>最后，在出队操作后，修改 cons.tail，使其值为消费前的 cons.head+n，表明消费完成后其尾节点的正确位置。
<ul>
<li>如果是单消费者模式，其实可以直接使用当前的 cons.head；但是如果多消费者模式，不能直接使用，因为多个线程会竞争写入。</li>
</ul>
</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">生产者计算有效 buffer：</span><br><span class="line">____ct******ch---------------------pt+++++++++++ph______</span><br><span class="line">    |                                           |</span><br><span class="line">    ------------------used buffer----------------</span><br><span class="line"></span><br><span class="line">消费者计算有效 buffer：</span><br><span class="line">____ct------ch---------------------pt-----------ph______</span><br><span class="line">            |                      |</span><br><span class="line">            -------used buffer------</span><br></pre></td></tr></table></figure>
<p>为什么生产者、消费者计算有效使用 buffer 数量时的公式不一样？</p>
<p>（个人理解）使用不同计算公式，可能是为了兼顾 MPMC 模式。因为 <code>+++</code> 可能是被其它生产者线程预留的将要生成的 buffer、但还没来得及生成完成；同样的，<code>***</code>可能是被其它消费者线程预留的将要消费的 buffer、但还没来得及消费完成。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @internal Dequeue several objects from a ring (NOT multi-consumers safe).</span></span><br><span class="line"><span class="comment"> * When the request objects are more than the available objects, only dequeue</span></span><br><span class="line"><span class="comment"> * the actual number of objects 当请求出队量大于队列剩余量，则仅出队实际余量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param r</span></span><br><span class="line"><span class="comment"> *   A pointer to the ring structure.</span></span><br><span class="line"><span class="comment"> * @param obj_table</span></span><br><span class="line"><span class="comment"> *   A pointer to a table of void * pointers (objects) that will be filled.</span></span><br><span class="line"><span class="comment"> *   从 ring 中出队的 obj 存放到 obj_table 指向的内存里</span></span><br><span class="line"><span class="comment"> * @param n</span></span><br><span class="line"><span class="comment"> *   The number of objects to dequeue from the ring to the obj_table.</span></span><br><span class="line"><span class="comment"> * @param behavior 环的两种出队模式：固定数量出队、尽力而为出队</span></span><br><span class="line"><span class="comment"> *   RTE_RING_QUEUE_FIXED:    Dequeue a fixed number of items from a ring</span></span><br><span class="line"><span class="comment"> *   RTE_RING_QUEUE_VARIABLE: Dequeue as many items a possible from ring</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *   Depend on the behavior value</span></span><br><span class="line"><span class="comment"> *   if behavior = RTE_RING_QUEUE_FIXED</span></span><br><span class="line"><span class="comment"> *   - 0: Success; objects dequeued.</span></span><br><span class="line"><span class="comment"> *   - -ENOENT: Not enough entries in the ring to dequeue; no object is</span></span><br><span class="line"><span class="comment"> *     dequeued. 余量不足，则不出队任何 obj</span></span><br><span class="line"><span class="comment"> *   if behavior = RTE_RING_QUEUE_VARIABLE</span></span><br><span class="line"><span class="comment"> *   - n: Actual number of objects dequeued.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __attribute__((always_inline))</span><br><span class="line">__rte_ring_sc_do_dequeue(<span class="keyword">struct</span> rte_ring *r, <span class="type">void</span> **obj_table,</span><br><span class="line">         <span class="type">unsigned</span> n, <span class="keyword">enum</span> rte_ring_queue_behavior behavior)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> cons_head, prod_tail; <span class="comment">// 假设无边界时，两指针的相对顺序：0____ct------ph________+inf</span></span><br><span class="line">    <span class="type">uint32_t</span> cons_next, entries;</span><br><span class="line">    <span class="type">unsigned</span> i;</span><br><span class="line">    <span class="type">uint32_t</span> mask = r-&gt;prod.mask;</span><br><span class="line"></span><br><span class="line">    cons_head = r-&gt;cons.head;</span><br><span class="line">    prod_tail = r-&gt;prod.tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The subtraction is done between two unsigned 32bits value</span></span><br><span class="line"><span class="comment">     * (the result is always modulo 32 bits even if we have</span></span><br><span class="line"><span class="comment">     * cons_head &gt; prod_tail). So &#x27;entries&#x27; is always between 0</span></span><br><span class="line"><span class="comment">     * and size(ring)-1. */</span></span><br><span class="line">    entries = prod_tail - cons_head; <span class="comment">// ring 中的 obj 数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &gt; entries) &#123; <span class="comment">// 请求出队量大于实际余量，根据模式不同、处理不同</span></span><br><span class="line">        <span class="keyword">if</span> (behavior == RTE_RING_QUEUE_FIXED) &#123; <span class="comment">// 固定数量出队，无法出队指定数量，返回异常</span></span><br><span class="line">            __RING_STAT_ADD(r, deq_fail, n);</span><br><span class="line">            <span class="keyword">return</span> -ENOENT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (unlikely(entries == <span class="number">0</span>))&#123; <span class="comment">// 尽力而为出队，出队实际余量</span></span><br><span class="line">                __RING_STAT_ADD(r, deq_fail, n);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            n = entries; <span class="comment">// 出队量为实际余量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cons_next = cons_head + n;</span><br><span class="line">    r-&gt;cons.head = cons_next; <span class="comment">// 修改 ring 结构中的 cons.head 指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* copy in table */</span></span><br><span class="line">    DEQUEUE_PTRS(); <span class="comment">// 出队操作</span></span><br><span class="line">    rte_smp_rmb();  <span class="comment">// 内存屏蔽</span></span><br><span class="line"></span><br><span class="line">    __RING_STAT_ADD(r, deq_success, n);</span><br><span class="line">    r-&gt;cons.tail = cons_next; <span class="comment">// 修改 ring 结构中的 cons.tail 指针（sp 模式下，这里等于 cons.head 的值）</span></span><br><span class="line">    <span class="keyword">return</span> behavior == RTE_RING_QUEUE_FIXED ? <span class="number">0</span> : n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="出队宏">出队宏</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* the actual copy of pointers on the ring to obj_table.</span></span><br><span class="line"><span class="comment"> * Placed here since identical code needed in both</span></span><br><span class="line"><span class="comment"> * single and multi consumer dequeue functions */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEQUEUE_PTRS() do &#123; \</span></span><br><span class="line"><span class="meta">    uint32_t idx = cons_head &amp; mask; \ <span class="comment">// 获取出队的起始索引 </span></span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> size = r-&gt;cons.size; \</span><br><span class="line">    <span class="keyword">if</span> (likely(idx + n &lt; size)) &#123; \ <span class="comment">// 起始索引 + 出队量 小于 ring 大小，则直接往后出队，不用回绕到最开始继续出队</span></span><br><span class="line">        <span class="comment">// 先 4 个、4 个的出队（循环步长是 4），依次赋值，相当于循环展开优化，减少计算循环索引和预测条件分支判断等优化</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (n &amp; (~(<span class="type">unsigned</span>)<span class="number">0x3</span>)); i+=<span class="number">4</span>, idx+=<span class="number">4</span>) &#123;\</span><br><span class="line">            obj_table[i] = r-&gt;ring[idx]; \</span><br><span class="line">            obj_table[i+<span class="number">1</span>] = r-&gt;ring[idx+<span class="number">1</span>]; \</span><br><span class="line">            obj_table[i+<span class="number">2</span>] = r-&gt;ring[idx+<span class="number">2</span>]; \</span><br><span class="line">            obj_table[i+<span class="number">3</span>] = r-&gt;ring[idx+<span class="number">3</span>]; \</span><br><span class="line">        &#125; \</span><br><span class="line">        <span class="keyword">switch</span> (n &amp; <span class="number">0x3</span>) &#123; \ <span class="comment">// 最后不足 4 个的 obj 出队</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: obj_table[i++] = r-&gt;ring[idx++]; \</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: obj_table[i++] = r-&gt;ring[idx++]; \</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: obj_table[i++] = r-&gt;ring[idx++]; \</span><br><span class="line">        &#125; \</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; \ <span class="comment">// 起始索引 + 出队量 不小于 ring 大小，则往后出队一部分到右边界，然后从左边界出队余下的一部分</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; idx &lt; size; i++, idx++) \ <span class="comment">// 出队 ring 的[idx, size-1] 区间的 obj 到 obj_table 的前一段 </span></span><br><span class="line">            obj_table[i] = r-&gt;ring[idx]; \</span><br><span class="line">        <span class="keyword">for</span> (idx = <span class="number">0</span>; i &lt; n; i++, idx++) \ <span class="comment">// 出队 ring 的[0, n-(size-idx)-1] 区间的 obj 到 obj_table 的后一段</span></span><br><span class="line">            obj_table[i] = r-&gt;ring[idx]; \</span><br><span class="line">    &#125; \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="sp-sc 场景分析">sp&amp;sc 场景分析</h3>
<p>在单生产者、单消费者场景下，简单考虑 push 和 pop 数据，假设有生产者 A 和消费者 B 两个线程，分别指向 ring。</p>
<p>有几个问题：B 去 pop 数据的时候会不会因为判断有数据而取不到的情况？（A 在 push 数据时，不小心先更新了 prod.tail 后 push 数据）；A 在 push 数据时，是否会因为 B 先更新 cons.tail 而导致覆盖 B 还没来得及 pop 的数据？还有一些其他情况…</p>
<p>因为这里有内存屏障，并不会出现以上问题，以上的实现在单生产者和单消费者的情况下比较简单，但对于多读多写同一个 ring 可能比较复杂。</p>
<h2 id="多生产者多消费者出入队">多生产者多消费者出入队</h2>
<p>以下分析下复杂情况，即多个线程 push 和 pop 数据，这里仅分析生产和消费的源码，其他的一些比较细节且不是很重要的代码不在这里分析。</p>
<img src="/images/data-structure/dpdk-lockless-ring-queue-2.png" alt="DPDK 无锁环形队列 MPMC 模式下 head 和 tail 同步逻辑" width="100%" height="100%">
<h3 id="多生产者 mp 入队">多生产者 mp 入队</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @internal Enqueue several objects on the ring (multi-producers safe).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function uses a &quot;compare and set&quot; instruction to move the</span></span><br><span class="line"><span class="comment"> * producer index atomically.</span></span><br><span class="line"><span class="comment"> * 该函数使用 CAS 指令，原子地修改生产者索引 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param r</span></span><br><span class="line"><span class="comment"> *   A pointer to the ring structure.</span></span><br><span class="line"><span class="comment"> * @param obj_table</span></span><br><span class="line"><span class="comment"> *   A pointer to a table of void * pointers (objects).</span></span><br><span class="line"><span class="comment"> * @param n</span></span><br><span class="line"><span class="comment"> *   The number of objects to add in the ring from the obj_table.</span></span><br><span class="line"><span class="comment"> * @param behavior</span></span><br><span class="line"><span class="comment"> *   RTE_RING_QUEUE_FIXED:    Enqueue a fixed number of items from a ring</span></span><br><span class="line"><span class="comment"> *   RTE_RING_QUEUE_VARIABLE: Enqueue as many items a possible from ring</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *   Depend on the behavior value</span></span><br><span class="line"><span class="comment"> *   if behavior = RTE_RING_QUEUE_FIXED</span></span><br><span class="line"><span class="comment"> *   - 0: Success; objects enqueue.</span></span><br><span class="line"><span class="comment"> *   - -EDQUOT: Quota exceeded. The objects have been enqueued, but the</span></span><br><span class="line"><span class="comment"> *     high water mark is exceeded.</span></span><br><span class="line"><span class="comment"> *   - -ENOBUFS: Not enough room in the ring to enqueue, no object is enqueued.</span></span><br><span class="line"><span class="comment"> *   if behavior = RTE_RING_QUEUE_VARIABLE</span></span><br><span class="line"><span class="comment"> *   - n: Actual number of objects enqueued.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __attribute__((always_inline))</span><br><span class="line">__rte_ring_mp_do_enqueue(<span class="keyword">struct</span> rte_ring *r, <span class="type">void</span> * <span class="type">const</span> *obj_table,</span><br><span class="line">             <span class="type">unsigned</span> n, <span class="keyword">enum</span> rte_ring_queue_behavior behavior)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> prod_head, prod_next; <span class="comment">// 假设无边界时，两指针的相对顺序：......____ct------ph________...</span></span><br><span class="line">    <span class="type">uint32_t</span> cons_tail, free_entries;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> max = n;</span><br><span class="line">    <span class="type">int</span> success;</span><br><span class="line">    <span class="type">unsigned</span> i, rep = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> mask = r-&gt;prod.mask;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Avoid the unnecessary cmpset operation below, which is also</span></span><br><span class="line"><span class="comment">     * potentially harmful when n equals 0. */</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* move prod.head atomically */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">/* Reset n to the initial burst count */</span></span><br><span class="line">        n = max;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">         * while (unlikely(success == 0)) 时，说明有其他线程修改了 r-&gt;prod.head，</span></span><br><span class="line"><span class="comment">         * 因此，这里要重新读取，并执行 CAS 指令，否则永远不会 success == 1 退出</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        prod_head = r-&gt;prod.head;</span><br><span class="line">        cons_tail = r-&gt;cons.tail;</span><br><span class="line">        <span class="comment">/* The subtraction is done between two unsigned 32bits value</span></span><br><span class="line"><span class="comment">         * (the result is always modulo 32 bits even if we have</span></span><br><span class="line"><span class="comment">         * prod_head &gt; cons_tail). So &#x27;free_entries&#x27; is always between 0</span></span><br><span class="line"><span class="comment">         * and size(ring)-1. */</span></span><br><span class="line">        free_entries = (mask + cons_tail - prod_head);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* check that we have enough room in ring */</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(n &gt; free_entries)) &#123; <span class="comment">// 入队的 obj 数量大于队列空余空间</span></span><br><span class="line">            <span class="keyword">if</span> (behavior == RTE_RING_QUEUE_FIXED) &#123; <span class="comment">// 固定数量入队模式：无法全部入队，异常退出</span></span><br><span class="line">                __RING_STAT_ADD(r, enq_fail, n);</span><br><span class="line">                <span class="keyword">return</span> -ENOBUFS;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 尽力而为入队模式：入队全部空余空间，即入队 free_entries 个 obj</span></span><br><span class="line">                <span class="comment">/* No free entry available */</span></span><br><span class="line">                <span class="keyword">if</span> (unlikely(free_entries == <span class="number">0</span>)) &#123;</span><br><span class="line">                    __RING_STAT_ADD(r, enq_fail, n);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                n = free_entries; <span class="comment">// 实际入队 free_entries 个 obj</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prod_next = prod_head + n;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这里与 sp 模式不同，mp 模式下使用 CAS 指令实现原子比较并交换，这行代码试图在同一个时间点内，</span></span><br><span class="line"><span class="comment">         * 判断并更新 r-&gt;prod.head 的值，即当 r-&gt;prod.head 等于 prod_head 时，更新其值为 prod_next</span></span><br><span class="line"><span class="comment">         * 这种操作通常用于多线程编程中的同步，以确保没有两个线程同时修改共享变量 r-&gt;prod.head</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        success = rte_atomic32_cmpset(&amp;r-&gt;prod.head, prod_head, prod_next);</span><br><span class="line">    &#125; <span class="keyword">while</span> (unlikely(success == <span class="number">0</span>)); <span class="comment">// 操作失败时，再来一次</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* write entries in ring */</span></span><br><span class="line">    ENQUEUE_PTRS(); <span class="comment">// 入队操作（与单生产者入队操作执行过程一样）</span></span><br><span class="line">    rte_smp_wmb();  <span class="comment">// 内存屏蔽</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if we exceed the watermark */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(((mask + <span class="number">1</span>) - free_entries + n) &gt; r-&gt;prod.watermark)) &#123; <span class="comment">// 已经用的空间 + 本次实际使用的空间 大于 水位线</span></span><br><span class="line">        ret = (behavior == RTE_RING_QUEUE_FIXED) ? -EDQUOT :</span><br><span class="line">                (<span class="type">int</span>)(n | RTE_RING_QUOT_EXCEED); <span class="comment">// 按模式指定异常返回值</span></span><br><span class="line">        __RING_STAT_ADD(r, enq_quota, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = (behavior == RTE_RING_QUEUE_FIXED) ? <span class="number">0</span> : n; <span class="comment">// 返回对应模式的成功状态下的返回值</span></span><br><span class="line">        __RING_STAT_ADD(r, enq_success, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If there are other enqueues in progress that preceded us,</span></span><br><span class="line"><span class="comment">     * we need to wait for them to complete</span></span><br><span class="line"><span class="comment">     * 如果在我们之前，还有其他更早的生产者线程正在入队，</span></span><br><span class="line"><span class="comment">     * 我们需要等待他们完成，然后再更新 prod.tail</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (unlikely(r-&gt;prod.tail != prod_head)) &#123;</span><br><span class="line">        rte_pause();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set RTE_RING_PAUSE_REP_COUNT to avoid spin too long waiting</span></span><br><span class="line"><span class="comment">         * for other thread finish. It gives pre-empted thread a chance</span></span><br><span class="line"><span class="comment">         * to proceed and finish with ring dequeue operation. */</span></span><br><span class="line">        <span class="keyword">if</span> (RTE_RING_PAUSE_REP_COUNT &amp;&amp;</span><br><span class="line">            ++rep == RTE_RING_PAUSE_REP_COUNT) &#123;</span><br><span class="line">            rep = <span class="number">0</span>;</span><br><span class="line">            sched_yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;prod.tail = prod_next; <span class="comment">// 修改 ring 结构中的 prod.tail 指针（mp 模式下，这里等于 CAS 更新后的 r-&gt;prod.head 的值）</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CAS 函数源码">CAS 函数源码</h3>
<p>x86 平台的实现：lib\librte_eal\common\include\arch\x86\rte_atomic.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*------------------------- 32 bit atomic operations -------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">rte_atomic32_cmpset</span><span class="params">(<span class="keyword">volatile</span> <span class="type">uint32_t</span> *dst, <span class="type">uint32_t</span> <span class="built_in">exp</span>, <span class="type">uint32_t</span> src)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">            MPLOCKED</span></span><br><span class="line"><span class="params">            <span class="string">&quot;cmpxchgl %[src], %[dst];&quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;sete %[res];&quot;</span></span></span><br><span class="line"><span class="params">            : [res] <span class="string">&quot;=a&quot;</span> (res),     <span class="comment">/* output */</span></span></span><br><span class="line"><span class="params">              [dst] <span class="string">&quot;=m&quot;</span> (*dst)</span></span><br><span class="line"><span class="params">            : [src] <span class="string">&quot;r&quot;</span> (src),      <span class="comment">/* input */</span></span></span><br><span class="line"><span class="params">              <span class="string">&quot;a&quot;</span> (<span class="built_in">exp</span>),</span></span><br><span class="line"><span class="params">              <span class="string">&quot;m&quot;</span> (*dst)</span></span><br><span class="line"><span class="params">            : <span class="string">&quot;memory&quot;</span>)</span>;            <span class="comment">/* no-clobber list */</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多消费者 mc 出队">多消费者 mc 出队</h3>
<p>多消费者出队的实现，CAS 实现差不多和上面的多生产者一样，出队和单消费者实现一样。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @internal Dequeue several objects from a ring (multi-consumers safe). When</span></span><br><span class="line"><span class="comment"> * the request objects are more than the available objects, only dequeue the</span></span><br><span class="line"><span class="comment"> * actual number of objects</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function uses a &quot;compare and set&quot; instruction to move the</span></span><br><span class="line"><span class="comment"> * consumer index atomically.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param r</span></span><br><span class="line"><span class="comment"> *   A pointer to the ring structure.</span></span><br><span class="line"><span class="comment"> * @param obj_table</span></span><br><span class="line"><span class="comment"> *   A pointer to a table of void * pointers (objects) that will be filled.</span></span><br><span class="line"><span class="comment"> * @param n</span></span><br><span class="line"><span class="comment"> *   The number of objects to dequeue from the ring to the obj_table.</span></span><br><span class="line"><span class="comment"> * @param behavior</span></span><br><span class="line"><span class="comment"> *   RTE_RING_QUEUE_FIXED:    Dequeue a fixed number of items from a ring</span></span><br><span class="line"><span class="comment"> *   RTE_RING_QUEUE_VARIABLE: Dequeue as many items a possible from ring</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *   Depend on the behavior value</span></span><br><span class="line"><span class="comment"> *   if behavior = RTE_RING_QUEUE_FIXED</span></span><br><span class="line"><span class="comment"> *   - 0: Success; objects dequeued.</span></span><br><span class="line"><span class="comment"> *   - -ENOENT: Not enough entries in the ring to dequeue; no object is</span></span><br><span class="line"><span class="comment"> *     dequeued.</span></span><br><span class="line"><span class="comment"> *   if behavior = RTE_RING_QUEUE_VARIABLE</span></span><br><span class="line"><span class="comment"> *   - n: Actual number of objects dequeued.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __attribute__((always_inline))</span><br><span class="line">__rte_ring_mc_do_dequeue(<span class="keyword">struct</span> rte_ring *r, <span class="type">void</span> **obj_table,</span><br><span class="line">         <span class="type">unsigned</span> n, <span class="keyword">enum</span> rte_ring_queue_behavior behavior)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> cons_head, prod_tail; <span class="comment">// 假设无边界时，两指针的相对顺序：......____ch------pt________...</span></span><br><span class="line">    <span class="type">uint32_t</span> cons_next, entries;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> max = n;</span><br><span class="line">    <span class="type">int</span> success;</span><br><span class="line">    <span class="type">unsigned</span> i, rep = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> mask = r-&gt;prod.mask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Avoid the unnecessary cmpset operation below, which is also</span></span><br><span class="line"><span class="comment">     * potentially harmful when n equals 0. */</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* move cons.head atomically */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">/* Restore n as it may change every loop */</span></span><br><span class="line">        n = max;</span><br><span class="line"></span><br><span class="line">        cons_head = r-&gt;cons.head;</span><br><span class="line">        prod_tail = r-&gt;prod.tail;</span><br><span class="line">        <span class="comment">/* The subtraction is done between two unsigned 32bits value</span></span><br><span class="line"><span class="comment">         * (the result is always modulo 32 bits even if we have</span></span><br><span class="line"><span class="comment">         * cons_head &gt; prod_tail). So &#x27;entries&#x27; is always between 0</span></span><br><span class="line"><span class="comment">         * and size(ring)-1. */</span></span><br><span class="line">        entries = (prod_tail - cons_head);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set the actual entries for dequeue */</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt; entries) &#123;</span><br><span class="line">            <span class="keyword">if</span> (behavior == RTE_RING_QUEUE_FIXED) &#123;</span><br><span class="line">                __RING_STAT_ADD(r, deq_fail, n);</span><br><span class="line">                <span class="keyword">return</span> -ENOENT;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (unlikely(entries == <span class="number">0</span>))&#123;</span><br><span class="line">                    __RING_STAT_ADD(r, deq_fail, n);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                n = entries;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cons_next = cons_head + n;</span><br><span class="line">        success = rte_atomic32_cmpset(&amp;r-&gt;cons.head, cons_head, cons_next);</span><br><span class="line">    &#125; <span class="keyword">while</span> (unlikely(success == <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* copy in table */</span></span><br><span class="line">    DEQUEUE_PTRS();</span><br><span class="line">    rte_smp_rmb();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If there are other dequeues in progress that preceded us,</span></span><br><span class="line"><span class="comment">     * we need to wait for them to complete</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (unlikely(r-&gt;cons.tail != cons_head)) &#123;</span><br><span class="line">        rte_pause();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set RTE_RING_PAUSE_REP_COUNT to avoid spin too long waiting</span></span><br><span class="line"><span class="comment">         * for other thread finish. It gives pre-empted thread a chance</span></span><br><span class="line"><span class="comment">         * to proceed and finish with ring dequeue operation. */</span></span><br><span class="line">        <span class="keyword">if</span> (RTE_RING_PAUSE_REP_COUNT &amp;&amp;</span><br><span class="line">            ++rep == RTE_RING_PAUSE_REP_COUNT) &#123;</span><br><span class="line">            rep = <span class="number">0</span>;</span><br><span class="line">            sched_yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __RING_STAT_ADD(r, deq_success, n);</span><br><span class="line">    r-&gt;cons.tail = cons_next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> behavior == RTE_RING_QUEUE_FIXED ? <span class="number">0</span> : n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://www.jianshu.com/p/ab14b3d3aa83">https://www.jianshu.com/p/ab14b3d3aa83</a></li>
<li><a href="https://blog.csdn.net/u012630961/article/details/80974857">https://blog.csdn.net/u012630961/article/details/80974857</a></li>
<li><a href="https://elixir.bootlin.com/dpdk/v2.2.0/source/lib/librte_ring/rte_ring.c">https://elixir.bootlin.com/dpdk/v2.2.0/source/lib/librte_ring/rte_ring.c</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux IO 模式与 IO 多路复用</title>
    <url>/posts/240516221527.html</url>
    <content><![CDATA[<p>同步 I/O 和异步 I/O、阻塞 I/O 和非阻塞 I/O 分别是什么？到底有什么区别？不同的人在不同的上下文下给出的答案是不同的。所以先限定一下本文的上下文：本文讨论的背景是 Linux 环境下的 Network I/O。</p>
<span id="more"></span>
<blockquote>
<p>注：本文是对众多博客的学习和总结，可能存在理解错误。请带着怀疑的眼光，同时如果有错误希望能指出。</p>
</blockquote>
<h1 id="概念说明">概念说明</h1>
<p>在进行解释之前，首先要说明几个概念：</p>
<ul>
<li>用户空间和内核空间</li>
<li>进程切换</li>
<li>进程的阻塞</li>
<li>文件描述符</li>
<li>缓存 I/O</li>
</ul>
<h2 id="用户空间与内核空间">用户空间与内核空间</h2>
<p>现在操作系统都是采用虚拟存储器，那么对 32 位操作系统而言，它的寻址空间（虚拟存储空间）为 4G（2 的 32 次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。</p>
<p>为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对 Linux 操作系统而言，将最高的 1G 字节（从虚拟地址 0xC0000000 到 0xFFFFFFFF），供内核使用，称为内核空间；而将较低的 3G 字节（从虚拟地址 0x00000000 到 0xBFFFFFFF），供各个进程使用，称为用户空间。</p>
<h2 id="进程切换">进程切换</h2>
<p>为了控制进程的执行，内核必须有能力挂起正在 CPU 上运行的进程，并恢复以前挂起的某个进程的执行，这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p>
<p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p>
<ol>
<li>保存 CPU 上下文，包括程序计数器和其他寄存器。</li>
<li>更新 PCB 信息。</li>
<li>把进程的 PCB 移入相应的队列，如就绪队列、在某事件阻塞的等待队列。</li>
<li>选择另一个进程执行，并更新其 PCB。</li>
<li>更新内存管理的数据结构。</li>
<li>恢复 CPU 上下文。</li>
</ol>
<blockquote>
<p>注：总而言之就是 <strong> 很耗资源</strong>。</p>
</blockquote>
<h2 id="进程的阻塞">进程的阻塞</h2>
<p>正在执行的进程，由于期待的某些事件未发生，例如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作可做时，会 <strong> 主动执行 </strong> 阻塞原语（Block），使自己由运行状态变为阻塞状态。可见，进程的阻塞是 <strong> 进程自身的一种主动行为</strong>。也因此，只有处于运行态的进程（获得 CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用 CPU 资源的。</p>
<h2 id="文件描述符">文件描述符</h2>
<p>文件描述符（File descriptor, fd）是计算机科学中的一个术语，是一个 <strong> 用于表述指向文件的引用 </strong> 的抽象化概念。</p>
<p>文件描述符在形式上是一个非负整数。<strong>实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表</strong>。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p>
<p>在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是，文件描述符这一概念往往只适用于 UNIX、Linux 这样的操作系统。</p>
<h2 id="缓存 -I-O">缓存 I/O</h2>
<p>缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（page cache）中。也就是说，<strong>数据会先被拷贝到内核的缓冲区中，然后才会从内核的缓冲区拷贝到应用程序的地址空间</strong>。</p>
<p><strong>缓存 I/O 的缺点 </strong>：数据在传输过程中需要在应用程序地址空间和内核之间<strong> 进行多次数据拷贝操作</strong>，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p>
<h1 id="I-O 模式">I/O 模式</h1>
<p>刚才说了，对于一次 I/O 访问（以 read 为例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个 read 操作发生时，它会经历两个阶段：</p>
<ol>
<li><strong>等待数据准备好（Waiting for the data to be ready）</strong></li>
<li><strong>将数据从内核拷贝到进程中（Copying the data from the kernel to the process）</strong></li>
</ol>
<p>正式因为这两个阶段，Linux 系统产生了以下五种网络模式的方案：</p>
<ul>
<li>阻塞 I/O（blocking I/O）</li>
<li>非阻塞 I/O（nonblocking I/O）</li>
<li>I/O 多路复用（ I/O multiplexing）</li>
<li>信号驱动 I/O（ signal driven I/O）</li>
<li>异步 I/O（asynchronous I/O）</li>
</ul>
<blockquote>
<p>注：由于 signal driven I/O 在实际中并不常用，所以我这只提及剩下的四种 I/O 模式。</p>
</blockquote>
<h2 id="阻塞 -I-O">阻塞 I/O</h2>
<p>在 Linux 中，<strong>默认情况下所有的 socket 都是 blocking</strong>，一个典型的读操作流程大概是这样：</p>
<p><img src="https://notes.shichao.io/unp/figure_6.1.png" alt="阻塞 I/O（blocking I/O）模式"></p>
<p>当用户进程调用了 <code>recvfrom</code> 这个系统调用，kernel 就开始了 I/O 的第一个阶段：准备数据（对于网络 I/O 来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的 UDP 包。这个时候 kernel 就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。</p>
<p>而 <strong> 在用户进程这边，整个进程会被阻塞（当然，这是进程自己选择的阻塞）</strong>。当 kernel 等到数据准备好了，它就会将数据从 kernel 中拷贝到用户内存，然后 kernel 返回结果，用户进程才解除 block 的状态，重新运行起来。</p>
<p>所以，blocking I/O 的特点就是在 I/O 执行的两个阶段都被 block 了。</p>
<h2 id="非阻塞 -I-O">非阻塞 I/O</h2>
<p>在 Linux 下，可以通过设置 socket 使其变为 non-blocking。当对一个 non-blocking socket 执行读操作时，流程是这个样子：</p>
<p><img src="https://notes.shichao.io/unp/figure_6.2.png" alt="非阻塞 I/O（nonblocking I/O）模式"></p>
<p>当用户进程发出 read 操作时，如果 kernel 中的数据还没有准备好，那么它并不会 block 用户进程，而是立刻返回一个 error。从用户进程角度讲，它发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个 error 时，它就知道数据还没有准备好，于是它 <strong> 可以再次发送 read 操作</strong>。一旦 kernel 中的数据准备好了，并且又再次收到了用户进程的 system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
<p>所以，nonblocking I/O 的特点是用户进程需要 <strong> 不断地主动询问</strong> kernel 数据好了没有。</p>
<h2 id="I-O- 多路复用">I/O 多路复用</h2>
<p>I/O multiplexing 就是我们说的 <code>select</code>, <code>poll</code>, <code>epoll</code> 系统调用，有些地方也称这种 I/O 方式为 event driven I/O。它们的 <strong> 好处就在于单个 process 就可以同时处理（监听）多个网络连接的 I/O</strong>。它的基本原理就是通过 <code>select</code>，<code>poll</code>，<code>epoll</code> 系统调用，会不断地轮询所负责的所有 socket，当某个 socket 有数据到达了，就通知用户进程。</p>
<p><img src="https://notes.shichao.io/unp/figure_6.3.png" alt="I/O 多路复用（ I/O multiplexing）模式"></p>
<p>当用户进程调用了 <code>select</code>，那么整个进程会被 block，同时 kernel 会“监视” <code>select</code> 负责的所有 socket，当任何一个 socket 中的数据准备好了，<code>select</code> 就会返回。这个时候用户进程再调用 read 操作，可以直接将数据从 kernel 拷贝到用户进程。</p>
<p>所以，I/O 多路复用的特点是通过一种机制让一个进程能同时等待多个 fd，而这些 fd（socket fd）只要任意一个进入读就绪状态，<code>select</code> 系统调用就可以返回。</p>
<p>这个图和 blocking I/O 的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个 system call (<code>select</code> 和 <code>recvfrom</code>)，而 blocking I/O 只调用了一个 system call (<code>recvfrom</code>)。但是，<strong>用 <code>select</code> 的优势在于它可以同时处理多个 connection</strong>。</p>
<p>所以，<strong>如果处理的连接数不是很高的话，使用 <code>select</code> 或 <code>epoll</code> 的 web server 不一定比使用 multi-threading + blocking I/O 的 web server 性能更好，可能延迟还更大。<code>select</code> 或 <code>epoll</code> 的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接</strong>。</p>
<p><strong>在 I/O multiplexing Model 中，通常会将每个 socket 设置为 non-blocking 模式。这意味着当调用 socket 相关的 I/O 操作时，如果数据尚未准备好，该操作将立即返回而不会阻塞进程。然而，整个用户进程在等待事件发生时仍然会被阻塞</strong>。区别在于，这种阻塞是由于系统调用 select（或者其他 I/O 多路复用的系统调用，如 poll、epoll）而不是由于单个 socket I/O 操作导致的。因此，用户进程的阻塞状态是由 I/O 多路复用机制控制的，而不是由单个 socket I/O 操作控制的。</p>
<h2 id="异步 -I-O">异步 I/O</h2>
<p>Linux 的 asynchronous I/O 其实用得很少。先看一下它的流程：</p>
<p><img src="https://notes.shichao.io/unp/figure_6.5.png" alt="异步 I/O（asynchronous I/O）模式"></p>
<p>用户进程发起 read 操作之后，立刻就可以开始去做其它的事。而另一方面，从 kernel 的角度，当它收到一个 asynchronous read 之后，首先它会立刻返回，所以不会对用户进程产生任何 block。然后，kernel 会等待数据准备完成，然后将数据拷贝到用户内存。当这一切都完成之后，kernel 会给用户进程发送一个 signal，告诉它 read 操作完成了。</p>
<h2 id="总结">总结</h2>
<p><strong>blocking 和 non-blocking 的区别</strong></p>
<p>调用 blocking I/O 会一直 block 住对应的进程直到操作完成，而 non-blocking I/O 在 kernel 还准备数据的情况下会立刻返回。</p>
<p><strong>synchronous I/O 和 asynchronous I/O 的区别</strong></p>
<p>在说明 synchronous I/O 和 asynchronous I/O 的区别之前，需要先给出两者的定义。POSIX 的定义是这样子的：</p>
<ul>
<li>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes.</li>
<li>An asynchronous I/O operation does not cause the requesting process to be blocked.</li>
</ul>
<p>两者的区别就在于 synchronous I/O 做 I/O 操作的时候会将 process 阻塞。按照这个定义，之前所述的 blocking I/O/, non-blocking I/O, /I/O multiplexing 都属于 synchronous I/O。</p>
<p>有人会说，non-blocking I/O 并没有被 block 啊。这里有个非常 “狡猾” 的地方，定义中所指的 “I/O operation” 是指真实的 I/O 操作，就是例子中的 recvfrom 这个 system call。non-blocking I/O 在执行 recvfrom 这个 system call 的时候，如果 kernel 的数据没有准备好，这时候不会 block 进程。但是，当 kernel 中数据准备好的时候，recvfrom 会将数据从 kernel 拷贝到用户内存中，这个时候进程是被 block 了，在这段时间内，进程是被 block 的。</p>
<p>而 asynchronous I/O 则不一样，当进程发起 I/O 操作之后，就直接返回再也不理睬了，直到 kernel 发送一个信号，告诉进程说 I/O 完成。在这整个过程中，进程完全没有被 block。</p>
<p>各个 I/O Model 的比较如图所示：</p>
<p><img src="https://notes.shichao.io/unp/figure_6.6.png" alt="五种 I/O 模式比较"></p>
<p>通过上图，可以发现 non-blocking I/O 和 asynchronous I/O 的区别还是很明显的。在 non-blocking I/O 中，虽然进程大部分时间都不会被 block，但是它仍然要求进程去主动的 check，并且当数据准备完成以后，也需要进程主动的再次调用 recvfrom 来将数据拷贝到用户内存。而 asynchronous I/O 则完全不同。它就像是用户进程将整个 I/O 操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查 I/O 操作的状态，也不需要主动的去拷贝数据。</p>
<h1 id="I-O- 多路复用 -v2">I/O 多路复用</h1>
<h2 id="多路复用概念">多路复用概念</h2>
<p>I/O 多路复用就是通过一种机制，<strong>一个进程 </strong> 就可以 <strong> 监视 </strong> 多个 fd，一旦某个 fd 就绪（通常是读就绪 / 写就绪），便可通知进程进行相应的 I/O 操作。这 <strong> 避免了每个 I/O 操作都阻塞在一个线程上</strong>，从而提高了资源利用率和系统的并发处理能力。</p>
<p><code>select</code>, <code>poll</code>, <code>epoll</code> 都是实现 I/O 多路复用的机制，但本质上都是同步 I/O，因为它们都需要在 <strong> 读写事件就绪后自己负责进行读写，也就是说这个读写数据的过程是阻塞的</strong>（参考 <a href="#I-O-%20%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">I/O 多路复用</a> 小节的配图）。</p>
<blockquote>
<p>异步 I/O 则无需自己负责进行读写，它会负责把数据从内核拷贝到用户空间。</p>
</blockquote>
<h2 id="select">select</h2>
<p>系统调用定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 替换宏定义，化简后的结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> fds_bits[<span class="number">32</span>]; <span class="comment">// 32 位系统上 32*(4*8bits)=1024bits</span></span><br><span class="line">&#125; fd_set;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds,</span></span><br><span class="line"><span class="params">          fd_set *_Nullable <span class="keyword">restrict</span> readfds,</span></span><br><span class="line"><span class="params">          fd_set *_Nullable <span class="keyword">restrict</span> writefds,</span></span><br><span class="line"><span class="params">          fd_set *_Nullable <span class="keyword">restrict</span> exceptfds,</span></span><br><span class="line"><span class="params">          <span class="keyword">struct</span> timeval *_Nullable <span class="keyword">restrict</span> timeout)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">    <span class="title function_">select</span><span class="params">()</span> allows a program to monitor multiple file descriptors,     &lt;- 最多 1024 个 fd</span><br><span class="line">    waiting until one or more of the file descriptors become &quot;ready&quot;    &lt;- 至少一个 fd 就绪后，便可返回</span><br><span class="line">    <span class="keyword">for</span> some class of I/O <span class="title function_">operation</span> <span class="params">(e.g., input possible)</span>.  A file</span><br><span class="line">    descriptor is considered &quot;ready&quot; <span class="keyword">if</span> it is possible to perform a     &lt;- 就绪即有数据可读写（无阻塞）</span><br><span class="line">    corresponding I/O <span class="title function_">operation</span> <span class="params">(e.g., read(<span class="number">2</span>), or a sufficiently</span></span><br><span class="line"><span class="params">    small write(<span class="number">2</span>))</span> without blocking.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">    On success, <span class="title function_">select</span><span class="params">()</span> and <span class="title function_">pselect</span><span class="params">()</span> <span class="keyword">return</span> the number of file        &lt;- 三类集合的就绪数量和</span><br><span class="line">    descriptors contained in the three returned descriptor <span class="title function_">sets</span> <span class="params">(that</span></span><br><span class="line"><span class="params">    is, the total number of bits that are <span class="built_in">set</span> in readfds, writefds,</span></span><br><span class="line"><span class="params">    exceptfds)</span>.  The <span class="keyword">return</span> value may be zero <span class="keyword">if</span> the timeout expired</span><br><span class="line">    before any file descriptors became ready.</span><br><span class="line"></span><br><span class="line">    On error, -1 is returned, and errno is <span class="built_in">set</span> to indicate the error;</span><br><span class="line">    the file descriptor sets are unmodified, and timeout becomes</span><br><span class="line">    undefined.</span><br></pre></td></tr></table></figure>
<p><code>select</code> 函数监视的 fd 分 3 类，分别是 writefds、readfds 和 exceptfds。调用后 <code>select</code> 函数会阻塞，直到有 fd 就绪（有数据可读、可写或者有 except）或者超时（timeout 指定等待时间，如果立即返回设为 NULL 即可），函数返回。当 <code>select</code> 函数返回后，可以通过遍历各类 fdset，来找到就绪的 fd。</p>
<blockquote>
<p>select 使用“参数 - 值”传递的方式，即参数分别是 writefds、readfds 和 exceptfds，它们各自对应着一个位图（bitmap）值。这些位图表示了要监视的 fd 集合的状态，值为 1 表示就绪。</p>
</blockquote>
<p>与 <code>select</code> 系统调用相关的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清空（从集合中删除所有 fd），它应该作为初始化 fd 集的第一步使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 fd 添加到集合中，向集合中添加已经存在的 fd 是一个空操作，并不会产生错误</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从集合中移除 fd，移除一个不存在于集合中的 fd 是一个空操作，并不会产生错误</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 fd 是否仍然存在于集合中（是否有活动：I/O 操作准备就绪），如果存在于集合中，则返回非零值，否则返回零</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>来自 man 手册的示例代码</strong>：该代码监控标准输入（0），并设置超时时间为 5 秒。在超时时间到达前，若监控到标准输入有输入数据，则 <code>select</code> 返回值 1，表示有一个 fd 就绪，随之按返回结果提示不同的信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    fd_set rfds;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Watch stdin (fd 0) to see when it has input. */</span></span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;rfds);</span><br><span class="line">    FD_SET(<span class="number">0</span>, &amp;rfds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait up to five seconds. */</span></span><br><span class="line">    tv.tv_sec = <span class="number">5</span>;</span><br><span class="line">    tv.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    retval = select(<span class="number">1</span>, &amp;rfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);  <span class="comment">// 阻塞等待就绪事件发生</span></span><br><span class="line">    <span class="comment">/* 现在不再依赖于 tv 的值，当在超时时间内监控到标准输入有输入数据时，即可返回 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (retval == <span class="number">-1</span>)</span><br><span class="line">        perror(<span class="string">&quot;select()&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Data is available now.\n&quot;</span>);</span><br><span class="line">        <span class="comment">/* FD_ISSET(0, &amp;rfds) will be true. */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No data within five seconds.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>select 优点：<code>select</code> 目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。</p>
<p>select 缺点：</p>
<ol>
<li><strong><code>select</code> 的一个缺点在于其只能监视最多 FD_SETSIZE (1024) 个 fd 数量</strong>（对于许多现代应用程序来说这是一个不合理的下限），并且此限制将不会改变（用户可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低）。所有现代应用程序都应该使用 <code>poll</code> 或 <code>epoll</code>，它们不受此限制。</li>
<li><strong>fd_set rfds 不可重用</strong>：每次调用 <code>select</code> 之前或新的 fd 进来，需要重新 FD_ZERO 并 FD_SET。</li>
<li><strong>用户态和内核态拷贝产生开销</strong>：用户需要监听事件时，<code>select</code> 会将 writefds、readfds 和 exceptfds 集合都拷贝到内核态；以及有就绪事件时，再次将整个集合（而非就绪的那几个事件）拷贝回用户态。</li>
<li><strong>需要 O(n) 时间复杂度的轮询</strong>，来获取集合中就绪的 fd（即使只有一个就绪）。</li>
</ol>
<h2 id="poll">poll</h2>
<p>系统调用定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">    <span class="title function_">poll</span><span class="params">()</span> performs a similar task to <span class="title function_">select</span><span class="params">(<span class="number">2</span>)</span>: it waits <span class="keyword">for</span> one of</span><br><span class="line">    a <span class="built_in">set</span> of file descriptors to become &quot;ready&quot; to perform I/O.  The</span><br><span class="line">    Linux-specific <span class="title function_">epoll</span><span class="params">(<span class="number">7</span>)</span> API performs a similar task, but offers</span><br><span class="line">    features beyond those found in <span class="title function_">poll</span><span class="params">()</span>.</span><br></pre></td></tr></table></figure>
<p>不同于 <code>select</code> 使用三个位图（bitmap）来表示三个 fdset 的方式，<code>poll</code> 使用一个 pollfd 结构体指针 fds 实现，nfds 为 fds 数组的长度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="type">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">    <span class="type">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">    <span class="comment">/* The bits that may be set/returned in events and revents are defined in &lt;poll.h&gt;: POLLIN, POLLOUT, POLLHUP, et.al. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>pollfd 结构包含了要监视的 events 和发生的 revents，不再使用 <code>select</code> “参数 - 值” 传递的方式。同时 pollfd 并没有最大数量限制（但是数量过大后性能也会下降）。和 <code>select</code> 函数一样，<code>poll</code> 返回后，需要轮询 pollfd 来获取就绪的 fd。</p>
<p>从上面看，<code>select</code> 和 <code>poll</code> 都需要在返回后，<strong>通过遍历 fd 来获取已经就绪的 socket</strong>。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的 fd 数量的增长，其效率也会线性下降。</p>
<h2 id="epoll">epoll</h2>
<p>epoll 全称 eventpoll，是 linux 2.6 内核实现 IO 多路复用的一种实现，是之前的 <code>select</code> 和 <code>poll</code> 的增强版本。相对于 <code>select</code> 和 <code>poll</code> 来说，epoll 更加灵活、没有 fd 限制。</p>
<p><strong>epoll 使用一个 epfd 句柄管理多个 fd，将用户关心的 fd 的事件存放到内核的一个事件表（内核数据结构 struct eventpoll）中，这样只需要一次从内核空间到用户空间的拷贝（且仅需拷贝就绪的那几个事件）</strong>。</p>
<p>epoll 操作过程需要三个接口，分别如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;  <span class="comment">// 创建一个 epoll 的句柄 epfd</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>epoll_create 接口</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">    <span class="title function_">epoll_create</span><span class="params">()</span> creates a new <span class="title function_">epoll</span><span class="params">(<span class="number">7</span>)</span> instance.  Since Linux        &lt;- epoll 实例</span><br><span class="line">    2.6.8, the size argument is ignored, but must be greater than       &lt;- size 无用但要大于 0</span><br><span class="line">    zero; see HISTORY.</span><br><span class="line"></span><br><span class="line">    epoll_create() returns a file descriptor referring to the new       &lt;- 返回 epoll fd 句柄</span><br><span class="line">    epoll instance.  This file descriptor is used <span class="keyword">for</span> all the</span><br><span class="line">    subsequent calls to the epoll interface.  When no longer</span><br><span class="line">    required, the file descriptor returned by epoll_create() should     &lt;- 不再需要时要 close(epfd)</span><br><span class="line">    be closed by using close(<span class="number">2</span>).  When all file descriptors referring</span><br><span class="line">    to an epoll instance have been closed, the kernel destroys the      &lt;- 关闭后，内核销毁 epfd 实例，释放相关的 fd 资源</span><br><span class="line">    instance and releases the associated resources <span class="keyword">for</span> reuse.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">    On success, these system calls <span class="keyword">return</span> a file descriptor (a</span><br><span class="line">    nonnegative integer).  On error, <span class="number">-1</span> is returned, and errno is <span class="built_in">set</span></span><br><span class="line">    to indicate the error.</span><br></pre></td></tr></table></figure>
<p>创建一个 epoll 的句柄，<s>size 用来告诉内核这个监听的数目一共有多大，这个参数不同于 <code>select</code> 中的第一个参数（给出最大监听的 fd 值再加一），这里参数 size 并不是限制了 epoll 所能监听的 fd 最大个数，只是对内核初始分配内部数据结构的一个建议。</s> 自 Linux 2.6.8 后，size 参数被忽略，但应设置一个大于 0 的值。</p>
<blockquote>
<p>当创建好 epoll 句柄后，它就会占用一个 fd 值。在 Linux 下，如果查看 /proc/process-id/fd/，是能够看到这个 fd 的，所以在使用完 epoll 后，必须调用 <code>close()</code> 关闭，否则可能导致 fd 被耗尽。</p>
</blockquote>
<p><strong>epoll_ctl 接口</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br></pre></td></tr></table></figure>
<p>函数是对 epoll 句柄 epfd 执行 op 操作，即添加、修改或删除 epoll 句柄上的事件。</p>
<ul>
<li>epfd：epoll 句柄，是 epoll_create() 的返回值。</li>
<li>op：操作类型，用三个宏来表示，可以是 EPOLL_CTL_ADD, EPOLL_CTL_MOD, EPOLL_CTL_DEL。</li>
<li>fd：需要进行上述 op 操作的目标 fd。</li>
<li>event：指向 epoll_event 结构指针，用户进程告诉内核需要监听什么事件（即 event-&gt;events 成员指定的宏的组合事件）。</li>
</ul>
<p>epoll_event 结构体如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>      events;  <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="type">epoll_data_t</span>  data;    <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>     *ptr;</span><br><span class="line">    <span class="type">int</span>       fd;</span><br><span class="line">    <span class="type">uint32_t</span>  u32;</span><br><span class="line">    <span class="type">uint64_t</span>  u64;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span>  <span class="title">epoll_data_t</span>;</span></span><br></pre></td></tr></table></figure>
<p>成员 events 可以是以下几个宏的集合，通过 OR 运算组合而成：</p>
<table>
<thead>
<tr>
<th>events 标志</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>EPOLLIN</td>
<td>对应的 fd 可以读（包括对端 SOCKET 正常关闭）</td>
</tr>
<tr>
<td>EPOLLOUT</td>
<td>对应的 fd 可以写</td>
</tr>
<tr>
<td>EPOLLPRI</td>
<td>对应的 fd 有紧急的数据可读</td>
</tr>
<tr>
<td>EPOLLERR</td>
<td>对应的 fd 发生错误</td>
</tr>
<tr>
<td>EPOLLHUP</td>
<td>对应的 fd 被挂起</td>
</tr>
<tr>
<td>EPOLLET</td>
<td>将 EPOLL 设置为边缘触发（Edge Triggered）模式，相对于水平触发（Level Triggered）</td>
</tr>
<tr>
<td>EPOLLONESHOT</td>
<td>只监听一次事件，当监听完该事件后，如果需要继续监听，需将该 socket fd 重新加入到 EPOLL 队列</td>
</tr>
</tbody>
</table>
<p><strong>epoll_wait 接口</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>
<p>等待 epfd 上的 I/O 事件的发生，最多返回 maxevents 个事件。成功时返回就绪事件的数量（即 events 数组中有效条目的数量），失败时返回 -1 并设置 errno 错误码。</p>
<ul>
<li>events：用户空间中用于从内核接收就绪事件的数组指针。</li>
<li>maxevents：可以返回的最大事件数。events 数组的大小应该至少是 maxevents。</li>
<li>timeout：超时时间，单位是毫秒，-1 表示一直阻塞直到有事件发生，0 表示立即返回（即使没有事件），大于 0 表示等待指定毫秒数后返回。</li>
</ul>
<h2 id="epoll 优点">epoll 优点</h2>
<p>在 <code>select</code> 和 <code>poll</code> 中，进程只有在调用一定的方法后，内核才对所有监视的 fd 进行扫描，而 <code>epoll</code> 事先通过 <code>epoll_ctl()</code> 来注册一个 fd。一旦基于某个 fd 就绪时，内核会采用类似 callback 的回调机制，迅速激活这个 fd，当进程调用 <code>epoll_wait()</code> 时便得到通知。<strong>epoll 的魅力就在于它去掉了遍历 fd 的步骤，而是通过监听回调的机制</strong>。</p>
<p><strong>监视的 fd 数量不受限制</strong></p>
<ul>
<li>epoll 所支持的 fd 上限是最大可以打开文件的数目，这个数字一般远大于 2048。举个例子，在 1GB 内存的机器上大约是 10 万左右，具体数目可以通过命令 <code>cat /proc/sys/fs/file-max</code> 来查看。这个数目通常与系统内存的大小有很大关系。</li>
<li><code>select</code> 的最大缺点是进程打开的 fd 数量是有限制的，对于连接数量较大的服务器来说，这种限制根本无法满足需求。虽然也可以选择多进程的解决方案（如 Apache 的实现方式），但尽管在 Linux 上创建进程的代价相对较小，但仍旧不可忽视，加上进程间数据同步远不如线程间同步高效，因此也不是一种完美的方案。</li>
</ul>
<p><strong>I/O 效率不会随着监视 fd 的数量增长而下降</strong></p>
<ul>
<li>epoll 不同于 <code>select</code> 和 <code>poll</code> 的轮询方式，而是通过每个 fd 定义的回调函数来实现的。只有就绪的 fd 才会执行回调函数。</li>
<li>如果没有大量的 idle-connection（空闲连接）或者 dead-connection（失效连接），epoll 的效率并不会比 <code>select</code> 或 <code>poll</code> 高很多，但是当遇到大量的 idle-connection 时，就会发现 epoll 的效率大大高于 <code>select</code> 或 <code>poll</code>。</li>
</ul>
<p>epoll 通过其独特的回调机制和对大数量 fd 的支持，显著提高了高并发场景下 I/O 操作的效率，是现代高性能网络服务器的首选 I/O 多路复用机制。</p>
<h2 id="示例代码">示例代码</h2>
<p>示例一：这个程序使用 <code>epoll</code> 实现了一个简单的事件驱动服务器，可以处理多个客户端的连接和数据读写。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS (10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BUF (1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT (8080)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> epoll_fd;                              <span class="comment">// epoll create 分配的句柄</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span>                     <span class="comment">// 内核需要监听的事件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">my_events</span>[<span class="title">MAX_EVENTS</span>];</span>  <span class="comment">// 用于从内核得到就绪事件的集合</span></span><br><span class="line">    <span class="type">int</span> ready_nfds;                            <span class="comment">// epoll wait 返回的就绪事件的数量</span></span><br><span class="line">    <span class="type">int</span> sockfd, client_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>, <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> addrlen;</span><br><span class="line">    <span class="type">char</span> buffer[MAX_BUF];  <span class="comment">// 用于存储从客户端读取的数据</span></span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建服务器 socket</span></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置服务器地址结构</span></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    server_addr.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定 socket 到指定的端口，并监听客户端请求</span></span><br><span class="line">    retval = bind(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    retval = listen(sockfd, MAX_EVENTS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 epoll 实例</span></span><br><span class="line">    epoll_fd = epoll_create(MAX_EVENTS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化用于存储就绪事件的集合</span></span><br><span class="line">    <span class="built_in">memset</span>(my_events, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event) * MAX_EVENTS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加服务器 socket 到 epoll 实例，监听客户端连接事件</span></span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    ev.data.fd = sockfd;</span><br><span class="line">    retval = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, sockfd, &amp;ev);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Listening on port %d...\n&quot;</span>, PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ready_nfds = epoll_wait(epoll_fd, my_events, MAX_EVENTS, <span class="number">-1</span>);  <span class="comment">// 阻塞等待就绪事件发生</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有就绪事件，区分处理新的连接和已连接客户端的数据读写</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ready_nfds; i++) &#123;</span><br><span class="line">            <span class="comment">// 处理新的连接：客户端首次连接时添加到 epoll 事件中进行监听</span></span><br><span class="line">            <span class="keyword">if</span> (my_events[i].data.fd == sockfd) &#123;</span><br><span class="line">                addrlen = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">                client_fd = accept(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;addrlen);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将新连接的 socket 添加到 epoll 实例</span></span><br><span class="line">                ev.events = EPOLLIN;</span><br><span class="line">                ev.data.fd = client_fd;</span><br><span class="line">                retval = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, client_fd, &amp;ev);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Accepted connection from %s:%d\n&quot;</span>, inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 处理客户端 socket 的可读事件</span></span><br><span class="line">                <span class="built_in">memset</span>(buffer, <span class="number">0</span>, MAX_BUF);</span><br><span class="line">                client_fd = my_events[i].data.fd;</span><br><span class="line">                <span class="type">ssize_t</span> n = read(client_fd, buffer, MAX_BUF);</span><br><span class="line">                <span class="keyword">if</span> (n == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    close(client_fd);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Client disconnected, fd %d\n&quot;</span>, client_fd);</span><br><span class="line">                    close(client_fd);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Read from fd %d: %s&quot;</span>, client_fd, buffer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line">    close(epoll_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 Chrome 和 Postman 分别访问该服务器，可以看到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./ioepoll</span></span><br><span class="line">Listening on port 8080...</span><br><span class="line">Accepted connection from x.x.x.x:56613</span><br><span class="line">Accepted connection from x.x.x.x:56614</span><br><span class="line">Read from fd 5: GET / HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:8080</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line"></span><br><span class="line">Accepted connection from x.x.x.x:56617</span><br><span class="line">Read from fd 7: GET /df1231213232 HTTP/1.1</span><br><span class="line">User-Agent: PostmanRuntime/7.37.3</span><br><span class="line">Accept: */*</span><br><span class="line">Postman-Token: 1d9c80eb-1f7b-46fc-a0aa-96439f0971c0</span><br><span class="line">Host: 127.0.0.1:8080</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">Client disconnected, fd 7</span><br><span class="line">Client disconnected, fd 5</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>示例二：这个程序使用 <code>epoll</code> 实现了一个简单的事件驱动模型，通过 <strong> 回调函数 </strong> 处理标准输入（stdin）的可读事件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS (10)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*event_callback)</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="comment">/* 一般回调函数定义，可供所有事件使用这一结构体，</span></span><br><span class="line"><span class="comment">       在实际使用时，可按需求强制类型转换成不同的函数指针 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> callback;</span><br><span class="line">    <span class="type">void</span>* arg;</span><br><span class="line">&#125; <span class="type">event_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_callback</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">ssize_t</span> n = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EOF on fd %d\n&quot;</span>, fd);  <span class="comment">// End of file</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Read from fd %d: %s&quot;</span>, fd, buf);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> epoll_fd;                              <span class="comment">// epoll create 分配的句柄</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span>                     <span class="comment">// 内核需要监听的事件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">my_events</span>[<span class="title">MAX_EVENTS</span>];</span>  <span class="comment">// 用于从内核得到就绪事件的集合</span></span><br><span class="line">    <span class="type">event_data_t</span>* event_data = <span class="literal">NULL</span>;           <span class="comment">// 事件的具体数据：包含 fd、回调函数、参数</span></span><br><span class="line">    <span class="type">int</span> ready_nfds;                            <span class="comment">// epoll wait 返回的就绪事件的数量</span></span><br><span class="line">    <span class="type">int</span> stdin_fd = STDIN_FILENO;               <span class="comment">// 标准输入 fd</span></span><br><span class="line">    event_callback fn_callback = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化用于存储就绪事件的集合</span></span><br><span class="line">    <span class="built_in">memset</span>(my_events, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event) * MAX_EVENTS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 epoll 实例，返回其句柄</span></span><br><span class="line">    epoll_fd = epoll_create(MAX_EVENTS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate memory for event data ⭐</span></span><br><span class="line">    event_data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">event_data_t</span>));</span><br><span class="line">    event_data-&gt;fd = stdin_fd;</span><br><span class="line">    event_data-&gt;callback = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span>)read_callback;</span><br><span class="line">    event_data-&gt;arg = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将标准输入 fd 注册到 epoll 实例中，并监听可读事件</span></span><br><span class="line">    ev.events = EPOLLIN;              <span class="comment">// 监听可读事件</span></span><br><span class="line">    ev.data.ptr = (<span class="type">void</span>*)event_data;  <span class="comment">// 用于传递具体的事件数据 ⭐</span></span><br><span class="line"></span><br><span class="line">    retval = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, stdin_fd, &amp;ev)  <span class="comment">// 将 stdin 添加到 epoll 实例中</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Listening for input on stdin...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ready_nfds = epoll_wait(epoll_fd, my_events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有就绪事件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ready_nfds; i++) &#123;</span><br><span class="line">            <span class="comment">// 监听到可读事件</span></span><br><span class="line">            <span class="keyword">if</span> (my_events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">                event_data = (<span class="type">event_data_t</span>*)my_events[i].data.ptr;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> != event_data) &#123;</span><br><span class="line">                    <span class="comment">// 获取回调函数，执行相应的事件处理函数</span></span><br><span class="line">                    fn_callback = (event_callback)event_data-&gt;callback;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="literal">NULL</span> != fn_callback) &#123;</span><br><span class="line">                        fn_callback(event_data-&gt;fd, event_data-&gt;arg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(event_data);</span><br><span class="line">    close(epoll_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述程序，在终端输入一些数据，可以看到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./ioepoll2</span></span><br><span class="line">Listening for input on stdin...</span><br><span class="line">nihao</span><br><span class="line">Read from fd 0: nihao</span><br><span class="line">hello</span><br><span class="line">Read from fd 0: hello</span><br><span class="line">hi</span><br><span class="line">Read from fd 0: hi</span><br><span class="line">hello world!</span><br><span class="line">Read from fd 0: hello world!</span><br><span class="line">-=()&amp;*&amp;@&amp;@%&amp;!</span><br><span class="line">Read from fd 0: -=()&amp;*&amp;@&amp;@%&amp;!</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="epoll 工作模式">epoll 工作模式</h2>
<p>epoll 对 fd 的操作有两种模式：LT (level trigger) 和 ET (edge trigger)。LT 模式与 ET 模式的区别如下：</p>
<ul>
<li>LT 模式（默认模式）：当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序 <strong> 可以不立即处理该事件 </strong>。下次调用 epoll_wait 时，<strong> 会再次响应 </strong> 应用程序并通知此事件。</li>
<li>ET 模式：当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序 <strong> 必须立即处理该事件 </strong>。如果不处理，下次调用 epoll_wait 时，<strong> 不会再次响应 </strong> 应用程序并通知此事件（除非该描述符上有新的事件发生）。</li>
</ul>
<blockquote>
<p>意思就是对于就绪事件，LT 可以不着急处理，下次 epoll_wait 返回时，还有这个就绪事件；而 ET 不处理，下次 epoll_wait 返回时，不会再有这个事件（除非有新的事件发生，再次就绪）。</p>
</blockquote>
<h3 id="LT 模式">LT 模式</h3>
<p>LT 是缺省的工作方式，并且 <strong> 同时支持 block 和 non-block socket</strong>。在这种做法中，内核告诉你一个 fd 是否就绪了，然后你可以对这个就绪的 fd 进行 I/O 操作。<strong>如果你不作任何操作，内核还是会继续通知你的</strong>。</p>
<h3 id="ET 模式">ET 模式</h3>
<p>ET 是高速工作方式，<strong>只支持 non-block socket</strong>。在这种模式下，当描述符从未就绪变为就绪时，内核通过 epoll 告诉你。然后，它会假设你知道 fd 已经就绪，并且不会再为那个 fd 发送更多的就绪通知，直到你做了某些操作导致那个 fd 不再为就绪状态了。但是请注意，如果一直不对这个 fd 作 I/O 操作（从而导致它再次变成未就绪），内核不会发送更多的通知（only once）。</p>
<p><strong>ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高</strong>。当 epoll 工作在 ET 模式时，必须使用 non-block socket，以避免在一个 fd 上进行阻塞的读或写操作时，导致无法及时处理其他 fd 上的任务，从而造成任务饥饿。</p>
<h3 id="不同模式执行差异">不同模式执行差异</h3>
<p>假如有这样一个例子：</p>
<ol>
<li>我们已经把一个用来从管道中读取数据的文件句柄（RFD）添加到 epoll 描述符；</li>
<li>这个时候从管道的另一端被写入了 2KB 的数据；</li>
<li>调用 epoll_wait()，并且它会返回 RFD，说明它已经准备好读取操作；</li>
<li>然后我们读取了 1KB 的数据；</li>
<li>调用 epoll_wait() …</li>
</ol>
<p>对于 LT 模式：在第 5 步调用 epoll_wait() 之后，仍然能收到通知。</p>
<p>对于 ET 模式：如果我们在第 1 步将 RFD 添加到 epoll 描述符的时候使用了 EPOLLET 标志，那么在第 5 步调用 epoll_wait() 之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候，ET 工作模式才会汇报事件。因此在第 5 步的时候，调用者可能会放弃等待仍存在于文件输入缓冲区内的剩余数据。</p>
<p>当使用 epoll 的 ET 模型来工作时，当产生了一个 EPOLLIN 事件后，读数据的时候需要考虑的是当 recv() 返回的大小如果等于请求的大小，那么很有可能是缓冲区还有数据未读完，也意味着该次事件还没有处理完，所以还需要再次读取：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (rs) &#123;</span><br><span class="line">    buflen = recv(events[i].data.fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (buflen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 由于是非阻塞的模式，所以当 errno 为 EAGAIN 时，表示当前缓冲区已无数据可读</span></span><br><span class="line">        <span class="comment">// 在这里就当作是该次事件已处理完</span></span><br><span class="line">        <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buflen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里表示对端的 socket 已正常关闭</span></span><br><span class="line">        rs = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buflen == <span class="keyword">sizeof</span>(buf)) &#123;</span><br><span class="line">        rs = <span class="number">1</span>;  <span class="comment">// 很有可能是缓冲区还有数据未读完，需要再次尝试读取</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rs = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EAGAIN 错误码在 Linux 中的含义：</p>
<p>在 Linux 开发中，我们经常会遇到各种错误码（通过设置 <code>errno</code>），其中 EAGAIN 是一个比较常见的错误码，通常出现在进行非阻塞操作时。字面上，EAGAIN 的含义是“再试一次”。这个错误通常出现在应用程序进行非阻塞（non-blocking）操作时，如对文件、socket 或 FIFO 进行操作。</p>
<p>例如，当以 <code>O_NONBLOCK</code> 标志打开文件、socket 或 FIFO 时，如果连续执行 <code>read</code> 操作但没有数据可读，此时程序不会阻塞等待数据准备就绪，而是会返回一个错误码 EAGAIN，提示应用程序当前没有数据可读，请稍后再试。另一个例子是，当某些系统调用（如 <code>fork</code>）由于资源不足（如虚拟内存）而执行失败时，也会返回 EAGAIN，提示调用程序稍后重试，也许下一次调用会成功。</p>
<p>通过这些例子可以看出，EAGAIN 错误码通常用于指示当前操作无法立即完成，程序需要稍后重试。</p>
<blockquote>
<p>参考资料</p>
<ol>
<li>本文转载并修改自：<a href="https://segmentfault.com/a/1190000003063859">https://segmentfault.com/a/1190000003063859</a></li>
<li><a href="https://www.bilibili.com/video/BV1qJ411w7du/">https://www.bilibili.com/video/BV1qJ411w7du/</a></li>
<li><a href="https://notes.shichao.io/unp/ch6/">https://notes.shichao.io/unp/ch6/</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
        <category>IO模式</category>
      </categories>
      <tags>
        <tag>IO多路复用</tag>
        <tag>IO模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 内核等待队列</title>
    <url>/posts/241009203126.html</url>
    <content><![CDATA[<p>Linux 内核的等待队列是以双循环链表为基础数据结构，与进程调度机制紧密结合，能够用于实现核心的异步事件通知机制、可以使用等待队列实现阻塞进程的唤醒。等待队列在 Linux 内核中有着举足轻重的作用，很多 Linux 驱动都或多或少涉及到了等待队列。因此，对于 Linux 内核及驱动开发者来说，掌握等待队列是必修课之一。</p>
<span id="more"></span>
<p>在介绍等待队列机制的技术实现之前，先从功能角度谈下等待队列在内核中的角色。</p>
<h1 id="你理解阻塞吗">你理解阻塞吗</h1>
<p>写程序的时候，我们常常说某个系统调用是阻塞调用。</p>
<p>从用户层的角度，基本理解是：进程在执行某个系统调用的时候，因为需要的资源不满足（I/O 操作，加锁等），导致进程“停”在那里，等到资源就绪了或者设置的 timeout 时间超时了，进程得以继续执行。</p>
<p>从内核的角度，面对用户层对阻塞调用的需求，需要实现哪些机制呢？</p>
<ol>
<li>
<p>首先，进程陷入内核，内核发现进程所要求的资源暂时无法满足，需要将其设置为睡眠状态，然后调度其它进程执行。</p>
<ul>
<li>这里引出一个问题：1）<strong>内核如何将一个进程睡眠的</strong>？</li>
</ul>
</li>
<li>
<p>其次，等到资源就绪时，我们需要唤醒等待在该资源上的进程。</p>
<ul>
<li>这里存在两个问题：2）<strong>内核是怎么知道资源就绪的 </strong>？以及，3）<strong> 某个资源就绪了，内核怎么找到对应的等待进程，并将它唤醒的</strong>？</li>
</ul>
</li>
</ol>
<blockquote>
<p>一个场景：我们希望对某个 socket fd 进行阻塞 write 操作。发起写操作的时候，陷入内核，内核发现该 socket fd 的写缓冲区是满的（即需要的资源不满足），暂时不能写。这时，内核会将进程设置为睡眠状态。转而调用执行其它运行态的进程。等到该写缓冲区可以写的时候（即需要的资源满足了），内核将进程设置为运行状态，然后执行写操作，拷贝数据到内核写缓冲区。执行完，切换回用户态。</p>
</blockquote>
<p>1）<strong>内核如何将一个进程睡眠的</strong>？</p>
<p>在 Linux 中每一个进程都由 <code>task_struct</code> 数据结构来定义。它有一个 <code>.state</code> 状态成员，将其设置为睡眠（TASK_INTERRUPTIBLE 或 TASK_UNINTERRUPTIBLE），并将表示该进程的 <code>task_struct</code> 结构从就绪队列中移走（转移到等待队列中），内核就不会调度其执行，也就相当于睡眠了。</p>
<p>2）<strong>内核是怎么知道资源就绪的</strong>？</p>
<p>中断机制：内核的所有工作都是由中断驱动的。不管是系统调用陷入内核，还是调度，还是其它的内核活动，都是由各种各样的中断来触发执行的。对于设备 I/O，如果设备空闲了，会触发一个外部中断，该中断触发内核执行中断处理程序，通知等待进程、执行回调等等。</p>
<blockquote>
<p>资源可用 -&gt; 中断触发 -&gt; 内核接收到中断信号 -&gt; 中断处理程序（<strong>更新某种状态标记以表示资源可用</strong>） -&gt; 通知唤醒等待该资源的等待进程，重新进入调度队列（到这里中断处理结束） -&gt; 被调度时，执行资源处理（这通常是在进程的上下文中进行，而不是在中断上下文中）。</p>
</blockquote>
<p>3）<strong>某个资源就绪了，内核怎么找到对应的等待进程，并将它唤醒的</strong>？</p>
<p>等待队列：我们将一个资源和一个等待队列关联起来。如果进程所请求的资源还未就绪，就先加入到该资源的等待队列中。等到资源就绪了，就唤醒等待队列中的进程，加入到调度。</p>
<blockquote>
<p>怎么知道进程等待的资源是否就绪了呢（资源就绪后会发生什么变化）？在等待队列中，“资源”是一个通过条件变量 condition 模拟的抽象，当资源满足时，会将 condition 修改为真，从而 wake_up 等待队列中的进程。</p>
</blockquote>
<h1 id="等待队列与惊群">等待队列与惊群</h1>
<p><strong>“惊群”的基本行为是</strong>：有多个进程 / 线程等待在同一个资源上，而该资源一次只能有一个进程处理。比如文件描述符的写操作、accept 一个新连接等。那么，在资源就绪的时候，如果内核采取的策略是唤醒所有的进程，这样，只有一个进程获取了该资源，其它进程发现没有资源就绪，继续进入睡眠（所谓虚假唤醒）。这样的行为浪费了系统的 CPU 资源。</p>
<p>那是不是，内核在资源就绪的时候，就唤醒一个进程不就得了。其实也不是，因为不是所有资源都是互斥的。比如某个文件的读操作。</p>
<p><strong>那么，惊群问题怎么解决</strong>？</p>
<p>在用户态，可以有不同的解决方式。或者忽略惊群所带来的开销，或者使用锁方式保证一次只有一个进程来阻塞在一个资源上。</p>
<p>而对于内核来说，在等待队列上增加了一个是否“互斥等待”的标志。即如果是互斥等待的，一次唤醒一个进程；如果不是互斥等待的，一次唤醒所有进程。</p>
<p>互斥等待的经典例子：accept。因为我们很明确知道，对一个 listen fd 的 accept，肯定是一次只有一个进程可以处理。那么，我们在 listen fd 上的等待队列，就毫无疑问可以设置为“互斥等待”。所以，现今版本的 linux 内核，解决了 accept 的惊群问题。</p>
<p>但是像 epoll_wait 的惊群问题，就无法从等待队列的互斥等待来解决。首先，epoll fd 上也有一个等待队列，代表 epoll fd 所监听的其他若干文件描述符（资源）就绪时，唤醒等待队列上的进程。因为我们无法确定，进程对这些资源是不是都是互斥访问的，还是都不是。所以，只好唤醒所有进程。更多的惊群问题，可以查阅相关资料。</p>
<h1 id="等待队列">等待队列</h1>
<h2 id="作用">作用</h2>
<p>Linux 内核的 <strong> 等待队列是以双循环链表为基础数据结构</strong>，与进程调度机制紧密结合，能够用于实现核心的异步事件通知机制、可以使用等待队列实现阻塞进程的唤醒。</p>
<p>它有两种数据结构：等待队列头（<code>wait_queue_head_t</code>）和等待队列项（<code>wait_queue_t</code>）。等待队列头和等待队列中都包含一个 <code>list_head</code> 类型的域作为“连接件”。它通过一个双链表把等待 task 的头（<code>wait_queue_head_t</code>类型）和等待的进程列表（<code>wait_queue_t</code>类型）链接起来。</p>
<p><strong>等待队列的每个节点都代表一个进程 <code>task_struct</code> 的封装，它通过等待队列项的 <code>.private = current</code> 来“绑定”进程</strong>，具体看后面的代码实现。</p>
<h2 id="结构组成">结构组成</h2>
<p>（1）等待队列头</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等待队列头</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> &#123;</span></span><br><span class="line">    <span class="type">spinlock_t</span> lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> <span class="title">wait_queue_head_t</span>;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>成员</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>lock</td>
<td>自旋锁，在对 task_list 操作的过程中，使用该锁实现对等待队列（如添加、删除操作）的互斥访问</td>
</tr>
<tr>
<td>task_list</td>
<td>双向循环链表，存放等待的进程</td>
</tr>
</tbody>
</table>
<p>（2）等待队列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等待队列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags;  <span class="comment">// 指明该等待的进程是互斥进程还是非互斥进程</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WQ_FLAG_EXCLUSIVE 0x01</span></span><br><span class="line">    <span class="type">void</span>* private;</span><br><span class="line">    <span class="type">wait_queue_func_t</span> func;  <span class="comment">// 挂唤醒函数用的，如 default_wake_function</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*<span class="type">wait_queue_func_t</span>)</span><span class="params">(<span class="type">wait_queue_t</span>* wait, <span class="type">unsigned</span> mode, <span class="type">int</span> flags, <span class="type">void</span>* key)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue</span> <span class="title">wait_queue_t</span>;</span></span><br></pre></td></tr></table></figure>
<p>（3）等待队列头（<code>wait_queue_head_t</code>）和等待队列（<code>wait_queue_t</code>）的区别是等待队列是等待队列头的成员。也就是说等待队列头的 <code>.task_list</code> 域链接的成员就是等待队列类型的（<code>wait_queue_t</code>）。</p>
<p><img src="https://cslqm.github.io/img/in-post/%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97.png" alt="等待队列"></p>
<p>通过 <code>-&gt;task_list-&gt;next</code> 得到的是下一个等待项的 <code>task_list</code> 成员的地址。那么，如何找到 <code>wait_queue_t</code> 结构的首地址呢？如果是通过减法操作，不会受字节对齐影响吗？不会的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * container_of - 从结构体的成员指针获取指向整个结构体的指针</span></span><br><span class="line"><span class="comment"> * @ptr:    指向结构体成员的指针</span></span><br><span class="line"><span class="comment"> * @type:   结构体类型</span></span><br><span class="line"><span class="comment"> * @member: 成员在结构体中的名字</span></span><br><span class="line"><span class="comment"> * typeof(((type*)0)-&gt;member) 创建一个 type 类型的空指针，并访问其成员，</span></span><br><span class="line"><span class="comment"> *                            不会实际访问内存，只是获取成员的类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member)                   \</span></span><br><span class="line"><span class="meta">    (&#123;                                                    \</span></span><br><span class="line"><span class="meta">        const typeof(((type*)0)-&gt;member)* __mptr = (ptr); \</span></span><br><span class="line"><span class="meta">        (type*)((char*)__mptr - offsetof(type, member));  \</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br></pre></td></tr></table></figure>
<h1 id="操作 - 常用函数接口">操作 / 常用函数接口</h1>
<p>Linux-2.6 提供如下关于等待队列的操作：</p>
<p>（1）定义等待队列头</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">wait_queue_head_t</span> my_queue;</span><br></pre></td></tr></table></figure>
<p>（2）初始化等待队列头</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">init_waitqueue_head(&amp;my_queue);     <span class="comment">// 对已定义的结构初始化</span></span><br><span class="line">DECLARE_WAIT_QUEUE_HEAD(my_queue);  <span class="comment">// 定义结构并初始化</span></span><br></pre></td></tr></table></figure>
<p>（3）定义等待队列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DECLARE_WAITQUEUE(name, tsk);  <span class="comment">// 定义并初始化一个名为 name 的等待队列，并设置 private 域为 tsk</span></span><br></pre></td></tr></table></figure>
<p>（4）添加 / 移除等待队列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于将等待队列 wait，（头插）添加到等待队列头 q 指向的等待队列链表中</span></span><br><span class="line"><span class="type">void</span> fastcall <span class="title function_">add_wait_queue</span><span class="params">(<span class="type">wait_queue_head_t</span>* q, <span class="type">wait_queue_t</span>* wait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于将等待队列 wait，从等待队列头 q 指向的等待队列链表中移除</span></span><br><span class="line"><span class="type">void</span> fastcall <span class="title function_">remove_wait_queue</span><span class="params">(<span class="type">wait_queue_head_t</span>* q, <span class="type">wait_queue_t</span>* wait)</span>;</span><br></pre></td></tr></table></figure>
<p>（5）等待事件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">wait_event(<span class="built_in">queue</span>, condition);</span><br><span class="line">wait_event_interruptible(<span class="built_in">queue</span>, condition);</span><br><span class="line">wait_event_timeout(<span class="built_in">queue</span>, condition, timeout);</span><br><span class="line">wait_event_interruptible_timeout(<span class="built_in">queue</span>, condition, timeout);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">等待第一个参数 queue 作为等待队列头的等待队列被唤醒，而且第二个参数 condition 必须满足，否则阻塞 </span></span><br><span class="line"><span class="comment">wait_event 和 wait_event_interruptible 的区别在于后者可以被信号打断，而前者不能</span></span><br><span class="line"><span class="comment"> 加上 timeout 意味着阻塞等待的超时时间，以 jiffy 为单位，在第三个参数的 timeout 到达时，不论 condition 是否满足，均返回</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>（6）唤醒队列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wake_up</span><span class="params">(<span class="type">wait_queue_head_t</span>* <span class="built_in">queue</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">wake_up_interruptible</span><span class="params">(<span class="type">wait_queue_head_t</span>* <span class="built_in">queue</span>)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上述操作会唤醒以 queue 作为等待队列头的【所有】等待队列对应的进程</span></span><br><span class="line"><span class="comment">wake_up()               &lt;---&gt;   wait_event()</span></span><br><span class="line"><span class="comment">                                wait_event_timeout()</span></span><br><span class="line"><span class="comment">wake_up_interruptible() &lt;---&gt;   wait_event_interruptible()</span></span><br><span class="line"><span class="comment">                                wait_event_interruptible_timeout()</span></span><br><span class="line"><span class="comment">wake_up() 可以唤醒处于 TASK_INTERRUPTIBLE 和 TASK_UNINTERRUPTIBLE 的进程</span></span><br><span class="line"><span class="comment">wake_up_interruptble() 只能唤醒处于 TASK_INTERRUPTIBLE 的进程</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>（7）在等待队列上睡眠。sleep_on 无需条件的睡眠，可能导致竞态，3.15 版本后废弃，采用 wait_event 代替 sleep_on。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作用是将当前进程的状态置成 TASK_UNINTERRUPTIBLE，定义一个等待队列，并把它添加到等待队列头 q，直到资源获得，q 指向的等待队列被唤醒</span></span><br><span class="line">sleep_on(<span class="type">wait_queue_head_t</span>* q);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作用是将当前进程的状态置成 TASK_INTERRUPTIBLE，并定义一个等待队列，之后把它附属到等待队列头 q，直到资源可获得，q 指向的等待队列被唤醒或者进程收到信号</span></span><br><span class="line">interruptible_sleep_on(<span class="type">wait_queue_head_t</span>* q);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sleep_on()               &lt;---&gt;   wake_up()</span></span><br><span class="line"><span class="comment">interruptible_sleep_on() &lt;---&gt;   wake_up_interruptible()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h1 id="接口实现">接口实现</h1>
<h2 id="初始化">初始化</h2>
<p>（1）直接定义后初始化。init_waitqueue_head()函数会将自旋锁初始化为未锁，等待队列初始化为空的双向循环链表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">wait_queue_head_t</span> my_queue;</span><br><span class="line">init_waitqueue_head(&amp;my_queue);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> init_waitqueue_head(q)              \</span></span><br><span class="line"><span class="meta">    do &#123;                                    \</span></span><br><span class="line"><span class="meta">        static struct lock_class_key __key; \</span></span><br><span class="line"><span class="meta">                                            \</span></span><br><span class="line"><span class="meta">        __init_waitqueue_head((q), &amp;__key); \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __init_waitqueue_head(<span class="type">wait_queue_head_t</span>* q, <span class="keyword">struct</span> lock_class_key* key) &#123;</span><br><span class="line">    spin_lock_init(&amp;q-&gt;lock);          <span class="comment">// 初始化自旋锁</span></span><br><span class="line">    lockdep_set_class(&amp;q-&gt;lock, key);  <span class="comment">// 高级调试，具体代码看不懂，只知道可以检测是否发生死锁</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;q-&gt;task_list);     <span class="comment">// 初始化链表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">INIT_LIST_HEAD</span><span class="params">(<span class="keyword">struct</span> list_head* <span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">list</span>-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;prev = <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）定义并初始化的快捷方式，等价于（1）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DECLARE_WAIT_QUEUE_HEAD(my_queue);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_WAIT_QUEUE_HEAD(name) \</span></span><br><span class="line"><span class="meta">    wait_queue_head_t name = __WAIT_QUEUE_HEAD_INITIALIZER(name)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __WAIT_QUEUE_HEAD_INITIALIZER(name) &#123; \</span></span><br><span class="line"><span class="meta">    .lock      = __SPIN_LOCK_UNLOCKED(name.lock), \</span></span><br><span class="line"><span class="meta">    .task_list = &#123; &amp;(name).task_list, &amp;(name).task_list &#125; &#125;</span></span><br></pre></td></tr></table></figure>
<p>（3）定义等待队列，注意此处是定义一个 <code>wait_queue_t</code> 类型的变量 name，并将其 private 与设置为 tsk。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DECLARE_WAITQUEUE(name, tsk);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_WAITQUEUE(name, tsk) \</span></span><br><span class="line"><span class="meta">    wait_queue_t name = __WAITQUEUE_INITIALIZER(name, tsk)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __WAITQUEUE_INITIALIZER(name, tsk) &#123; \</span></span><br><span class="line"><span class="meta">    .private    = tsk, \</span></span><br><span class="line"><span class="meta">    .func       = default_wake_function, \</span></span><br><span class="line"><span class="meta">    .task_list  = &#123; NULL, NULL &#125; &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="添加／移出等待队列">添加／移出等待队列</h2>
<p>（1）向等待队列头中添加等待队列，设置等待的进程为非互斥进程，并将其添加进等待队列头的 <strong> 队头中（而非队尾）</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add_wait_queue</span><span class="params">(<span class="type">wait_queue_head_t</span>* q, <span class="type">wait_queue_t</span>* wait)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">    wait-&gt;flags &amp;= ~WQ_FLAG_EXCLUSIVE;   <span class="comment">// ~WQ_FLAG_EXCLUSIVE 位运算表示非互斥</span></span><br><span class="line">    spin_lock_irqsave(&amp;q-&gt;lock, flags);  <span class="comment">// 需要修改等待队列，申请锁</span></span><br><span class="line">    __add_wait_queue(q, wait);           <span class="comment">// 添加到等待队列的队头</span></span><br><span class="line">    spin_unlock_irqrestore(&amp;q-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(add_wait_queue);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __add_wait_queue(<span class="type">wait_queue_head_t</span>* head, <span class="type">wait_queue_t</span>* new) &#123;</span><br><span class="line">    list_add(&amp;new-&gt;task_list, &amp;head-&gt;task_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）向等待队列头中添加等待队列，设置等待的进程为互斥进程，并将其添加进等待队列头的 <strong> 队尾中（而非队头）</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add_wait_queue_exclusive</span><span class="params">(<span class="type">wait_queue_head_t</span>* q, <span class="type">wait_queue_t</span>* wait)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">    wait-&gt;flags |= WQ_FLAG_EXCLUSIVE;    <span class="comment">// 互斥进程 WQ_FLAG_EXCLUSIVE</span></span><br><span class="line">    spin_lock_irqsave(&amp;q-&gt;lock, flags);  <span class="comment">// 需要修改等待队列，申请锁</span></span><br><span class="line">    __add_wait_queue_tail(q, wait);      <span class="comment">// 添加到等待队列的队尾</span></span><br><span class="line">    spin_unlock_irqrestore(&amp;q-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(add_wait_queue_exclusive);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __add_wait_queue_tail(<span class="type">wait_queue_head_t</span>* head, <span class="type">wait_queue_t</span>* new) &#123;</span><br><span class="line">    list_add_tail(&amp;new-&gt;task_list, &amp;head-&gt;task_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数和 add_wait_queue()函数功能基本一样，只不过它是将等待的进程设置为互斥进程。</p>
<p>（3）在等待的资源或事件满足时，进程被唤醒，使用该函数从等待头指向的等待队列中删除一项。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">remove_wait_queue</span><span class="params">(<span class="type">wait_queue_head_t</span>* q, <span class="type">wait_queue_t</span>* wait)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;q-&gt;lock, flags);  <span class="comment">// 需要修改等待队列，申请锁</span></span><br><span class="line">    __remove_wait_queue(q, wait);        <span class="comment">// 删除</span></span><br><span class="line">    spin_unlock_irqrestore(&amp;q-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(remove_wait_queue);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __remove_wait_queue(<span class="type">wait_queue_head_t</span>* head, <span class="type">wait_queue_t</span>* old) &#123;</span><br><span class="line">    list_del(&amp;old-&gt;task_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="等待事件">等待事件</h2>
<h3 id="wait-event">wait_event</h3>
<p>wait_event 宏使进程被置于深睡眠状态（不可被信号中断）进行等待，直到 @condition 条件满足。等待队列头 @wq 在每次被 wakeup 时都会检查 @condition 条件，<strong>如果不满足则继续睡眠等待</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// linux/wait.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * wait_event - 睡眠直到条件满足 </span></span><br><span class="line"><span class="comment"> * @wq: 要等待的等待队列头</span></span><br><span class="line"><span class="comment"> * @condition: 要等待的条件表达式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 进程会进入不可中断的睡眠状态 (TASK_UNINTERRUPTIBLE)，直到</span></span><br><span class="line"><span class="comment"> * @condition 条件为真。每次等待队列头 @wq 被唤醒时都会检查该条件。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在改变可能影响等待条件的任何变量之后，必须调用 wake_up()。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> wait_event(wq, condition)    \</span></span><br><span class="line"><span class="meta">    do &#123;                             \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (condition)               \</span></span><br><span class="line"><span class="meta">            break;                   \</span></span><br><span class="line"><span class="meta">        __wait_event(wq, condition); \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __wait_event(wq, condition)                              \</span></span><br><span class="line"><span class="meta">    do &#123;                                                         \</span></span><br><span class="line"><span class="meta">        DEFINE_WAIT(__wait);                                     \</span></span><br><span class="line"><span class="meta">                                                                 \</span></span><br><span class="line"><span class="meta">        for (;;) &#123;                                               \</span></span><br><span class="line"><span class="meta">            prepare_to_wait(&amp;wq, &amp;__wait, TASK_UNINTERRUPTIBLE); \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (condition)                                       \</span></span><br><span class="line"><span class="meta">                break;                                           \</span></span><br><span class="line"><span class="meta">            schedule();                                          \</span></span><br><span class="line"><span class="meta">        &#125;                                                        \</span></span><br><span class="line"><span class="meta">        finish_wait(&amp;wq, &amp;__wait);                               \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// linux/wait.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_WAIT_FUNC(name, function)               \</span></span><br><span class="line"><span class="meta">    wait_queue_t name = &#123;                              \</span></span><br><span class="line"><span class="meta">        .private = current,                            \</span></span><br><span class="line"><span class="meta">        .func = function,                              \</span></span><br><span class="line"><span class="meta">        .task_list = LIST_HEAD_INIT((name).task_list), \</span></span><br><span class="line"><span class="meta">    &#125;  <span class="comment">// current 指向当前运行的进程的指针</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并初始化一个等待队列项，同时指定了 private 和 func 分别为 current 和 autoremove_wake_function</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_WAIT(name) DEFINE_WAIT_FUNC(name, autoremove_wake_function)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/asm-generic/current.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_current() (current_thread_info()-&gt;task)  <span class="comment">// 获取当前执行的任务（进程）的 task_struct 类型指针</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> current get_current()  <span class="comment">// 当前运行进程的指针</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// prepare_to_wait() 修改当前进程状态为不可中断的睡眠状态（TASK_UNINTERRUPTIBLE）</span></span><br><span class="line"><span class="comment">// schedule()开始进行睡眠 </span></span><br><span class="line"><span class="comment">// finish_wait() 修改当前进程状态为 TASK_RUNNING，并将当前进程从等待队列中移除（若它还在）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/wait.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 注意：我们需要在添加到等待队列之后再使用 &quot;set_current_state()&quot;，</span></span><br><span class="line"><span class="comment"> * 因为在 SMP 系统中需要一个内存屏障，避免编译器优化</span></span><br><span class="line"><span class="comment"> * 这样任何检测等待队列是否活跃的唤醒函数</span></span><br><span class="line"><span class="comment"> * 将被保证看到等待队列的添加，或者本线程中随后的测试将看到唤醒已经发生。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">prepare_to_wait</span><span class="params">(<span class="type">wait_queue_head_t</span>* q, <span class="type">wait_queue_t</span>* wait, <span class="type">int</span> state)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 睡眠前的准备工作，用于防止 wait 不在队列中，而事件已产生，则会无限等待 */</span></span><br><span class="line"></span><br><span class="line">    wait-&gt;flags &amp;= ~WQ_FLAG_EXCLUSIVE;   <span class="comment">// 设置为非互斥模式</span></span><br><span class="line">    spin_lock_irqsave(&amp;q-&gt;lock, flags);  <span class="comment">// 需要修改等待队列，申请锁</span></span><br><span class="line">    <span class="keyword">if</span> (list_empty(&amp;wait-&gt;task_list))    <span class="comment">// 当 wait 不在队列 q，则加入其中，防止无法唤醒</span></span><br><span class="line">        __add_wait_queue(q, wait);       <span class="comment">// 添加事件到等待队列</span></span><br><span class="line">    set_current_state(state);            <span class="comment">// 修改当前进程状态</span></span><br><span class="line">    spin_unlock_irqrestore(&amp;q-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(prepare_to_wait);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * finish_wait - clean up after waiting in a queue</span></span><br><span class="line"><span class="comment"> * @q: waitqueue waited on</span></span><br><span class="line"><span class="comment"> * @wait: wait descriptor</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Sets current thread back to running state and removes</span></span><br><span class="line"><span class="comment"> * the wait descriptor from the given waitqueue if still</span></span><br><span class="line"><span class="comment"> * queued.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">finish_wait</span><span class="params">(<span class="type">wait_queue_head_t</span>* q, <span class="type">wait_queue_t</span>* wait)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">    __set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!list_empty_careful(&amp;wait-&gt;task_list)) &#123;</span><br><span class="line">        spin_lock_irqsave(&amp;q-&gt;lock, flags);</span><br><span class="line">        list_del_init(&amp;wait-&gt;task_list);  <span class="comment">// deletes entry from list and reinitialize it</span></span><br><span class="line">        spin_unlock_irqrestore(&amp;q-&gt;lock, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(finish_wait);</span><br><span class="line"></span><br><span class="line"><span class="comment">// linux/sched.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_current_state(state_value) set_mb(current-&gt;state, (state_value))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_mb(var, value) \</span></span><br><span class="line"><span class="meta">    do &#123;                   \</span></span><br><span class="line"><span class="meta">        var = value;       \</span></span><br><span class="line"><span class="meta">        barrier();         \</span></span><br><span class="line"><span class="meta">    &#125; while (0)  <span class="comment">// 设置变量值并加上内存屏障避免指令重排</span></span></span><br></pre></td></tr></table></figure>
<p>有一个疑问，这里 <code>DEFINE_WAIT(__wait)</code> 定义一个 <strong> 局部 </strong> 等待队列项<code>__wait</code>，其用意在哪？</p>
<ul>
<li><strong>管理当前等待状态</strong>：使用 <code>__wait</code> 来表示当前进程（<code>.private = current</code>）的等待状态（<code>set_current_state(state)</code>），用来跟踪哪个线程（<code>current</code>）在等待哪个条件（<code>condition</code>）。</li>
<li><strong>自动清理</strong>：使用 <code>autoremove_wake_function</code> 回调函数，<code>__wait</code> 可以在条件满足时自动移除。</li>
</ul>
<p>另一个疑问，在 <code>set_current_state(state)</code> 设置进程状态时，为什么不是修改 <code>(&amp;__wait)-&gt;private-&gt;state</code>，而是再次获取<code>current-&gt;state</code> 来修改？它俩会不会已经不是同一个进程了呢？</p>
<ul>
<li><strong>单线程上下文 </strong>：<code>wait_event</code> 和 <code>__wait_event</code> 宏都<strong> 运行在调用进程的上下文中，不会被其它进程异步更改</strong>。因此，在循环等待或状态设置之前和之后，<code>current</code> 不会改变。</li>
<li><strong>调度保障</strong>：在进入不可中断状态后，进程会在调度器 <code>schedule()</code> 中等待条件发生改变并被唤醒。在这一过程中，进程上下文保持一致。</li>
</ul>
<p>所以，正常情况下 <code>current</code> 和 <code>.private</code> 所指的进程将保持一致。</p>
<h3 id="wait-event-interruptible">wait_event_interruptible</h3>
<p>wait_event_interruptible 与 wait_event 宏的不同之处是：该宏使进程被置于浅睡眠状态（可被信号中断）进行等待。在每次被唤醒的时候，首先检查 condition 是否为真，如果为真则返回 0；否则，检查进程是被信号唤醒，是则返回 -ERESTARTSYS 错误码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * wait_event_interruptible - sleep until a condition gets true</span></span><br><span class="line"><span class="comment"> * @wq: the waitqueue to wait on</span></span><br><span class="line"><span class="comment"> * @condition: a C expression for the event to wait for</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The process is put to sleep (TASK_INTERRUPTIBLE) until the</span></span><br><span class="line"><span class="comment"> * @condition evaluates to true or a signal is received.</span></span><br><span class="line"><span class="comment"> * The @condition is checked each time the waitqueue @wq is woken up.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * wake_up() has to be called after changing any variable that could</span></span><br><span class="line"><span class="comment"> * change the result of the wait condition.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function will return -ERESTARTSYS if it was interrupted by a</span></span><br><span class="line"><span class="comment"> * signal and 0 if @condition evaluated to true.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> wait_event_interruptible(wq, condition)               \</span></span><br><span class="line"><span class="meta">    (&#123;                                                        \</span></span><br><span class="line"><span class="meta">        int __ret = 0;                                        \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!(condition))                                     \</span></span><br><span class="line"><span class="meta">            __wait_event_interruptible(wq, condition, __ret); \</span></span><br><span class="line"><span class="meta">        __ret;                                                \</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __wait_event_interruptible(wq, condition, ret)         \</span></span><br><span class="line"><span class="meta">    do &#123;                                                       \</span></span><br><span class="line"><span class="meta">        DEFINE_WAIT(__wait);                                   \</span></span><br><span class="line"><span class="meta">                                                               \</span></span><br><span class="line"><span class="meta">        for (;;) &#123;                                             \</span></span><br><span class="line"><span class="meta">            prepare_to_wait(&amp;wq, &amp;__wait, TASK_INTERRUPTIBLE); \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (condition)                                     \</span></span><br><span class="line"><span class="meta">                break;                                         \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (!signal_pending(current)) &#123;                    \</span></span><br><span class="line"><span class="meta">                schedule();                                    \</span></span><br><span class="line"><span class="meta">                continue;                                      \</span></span><br><span class="line"><span class="meta">            &#125;                                                  \</span></span><br><span class="line"><span class="meta">            ret = -ERESTARTSYS;                                \</span></span><br><span class="line"><span class="meta">            break;                                             \</span></span><br><span class="line"><span class="meta">        &#125;                                                      \</span></span><br><span class="line"><span class="meta">        finish_wait(&amp;wq, &amp;__wait);                             \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br></pre></td></tr></table></figure>
<h3 id="wait-event-timeout">wait_event_timeout</h3>
<p>wait_event_timeout 也与 wait_event 类似，均使进程被置于深睡眠状态（不可被中断）进行等待。不过如果所给的睡眠时间为负数则立即返回；如果在睡眠期间被唤醒，且 condition 为真则返回剩余的睡眠时间，否则继续睡眠直到到达或超过给定的睡眠时间，然后返回 0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> wait_event_timeout(wq, condition, timeout)      \</span></span><br><span class="line"><span class="meta">    (&#123;                                                  \</span></span><br><span class="line"><span class="meta">        long __ret = timeout;                           \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!(condition))                               \</span></span><br><span class="line"><span class="meta">            __wait_event_timeout(wq, condition, __ret); \</span></span><br><span class="line"><span class="meta">        __ret;                                          \</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __wait_event_timeout(wq, condition, ret)                 \</span></span><br><span class="line"><span class="meta">    do &#123;                                                         \</span></span><br><span class="line"><span class="meta">        DEFINE_WAIT(__wait);                                     \</span></span><br><span class="line"><span class="meta">                                                                 \</span></span><br><span class="line"><span class="meta">        for (;;) &#123;                                               \</span></span><br><span class="line"><span class="meta">            prepare_to_wait(&amp;wq, &amp;__wait, TASK_UNINTERRUPTIBLE); \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (condition)                                       \</span></span><br><span class="line"><span class="meta">                break;                                           \</span></span><br><span class="line"><span class="meta">            ret = schedule_timeout(ret);                         \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (!ret)                                            \</span></span><br><span class="line"><span class="meta">                break;                                           \</span></span><br><span class="line"><span class="meta">        &#125;                                                        \</span></span><br><span class="line"><span class="meta">        finish_wait(&amp;wq, &amp;__wait);                               \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br></pre></td></tr></table></figure>
<h3 id="wait-event-interruptible-timeout">wait_event_interruptible_timeout</h3>
<p>wait_event_interruptible_timeout 是 interruptible 和 timeout 的结合，可使进程被置于浅睡眠状态（可被信号中断）进行等待。如果在睡眠期间被信号打断，则返回 -ERESTARTSYS 错误码；到达或超过给定的睡眠时间，则返回 0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> wait_event_interruptible_timeout(wq, condition, timeout)      \</span></span><br><span class="line"><span class="meta">    (&#123;                                                                \</span></span><br><span class="line"><span class="meta">        long __ret = timeout;                                         \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!(condition))                                             \</span></span><br><span class="line"><span class="meta">            __wait_event_interruptible_timeout(wq, condition, __ret); \</span></span><br><span class="line"><span class="meta">        __ret;                                                        \</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __wait_event_interruptible_timeout(wq, condition, ret) \</span></span><br><span class="line"><span class="meta">    do &#123;                                                       \</span></span><br><span class="line"><span class="meta">        DEFINE_WAIT(__wait);                                   \</span></span><br><span class="line"><span class="meta">                                                               \</span></span><br><span class="line"><span class="meta">        for (;;) &#123;                                             \</span></span><br><span class="line"><span class="meta">            prepare_to_wait(&amp;wq, &amp;__wait, TASK_INTERRUPTIBLE); \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (condition)                                     \</span></span><br><span class="line"><span class="meta">                break;                                         \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (!signal_pending(current)) &#123;                    \</span></span><br><span class="line"><span class="meta">                ret = schedule_timeout(ret);                   \</span></span><br><span class="line"><span class="meta">                <span class="keyword">if</span> (!ret)                                      \</span></span><br><span class="line"><span class="meta">                    break;                                     \</span></span><br><span class="line"><span class="meta">                continue;                                      \</span></span><br><span class="line"><span class="meta">            &#125;                                                  \</span></span><br><span class="line"><span class="meta">            ret = -ERESTARTSYS;                                \</span></span><br><span class="line"><span class="meta">            break;                                             \</span></span><br><span class="line"><span class="meta">        &#125;                                                      \</span></span><br><span class="line"><span class="meta">        finish_wait(&amp;wq, &amp;__wait);                             \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br></pre></td></tr></table></figure>
<h3 id="wait-event-interruptible-exclusive">wait_event_interruptible_exclusive</h3>
<p>同样和 wait_event_interruptible 一样，不过该睡眠的进程是一个互斥进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> wait_event_interruptible_exclusive(wq, condition)               \</span></span><br><span class="line"><span class="meta">    (&#123;                                                                  \</span></span><br><span class="line"><span class="meta">        int __ret = 0;                                                  \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!(condition))                                               \</span></span><br><span class="line"><span class="meta">            __wait_event_interruptible_exclusive(wq, condition, __ret); \</span></span><br><span class="line"><span class="meta">        __ret;                                                          \</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __wait_event_interruptible_exclusive(wq, condition, ret)          \</span></span><br><span class="line"><span class="meta">    do &#123;                                                                  \</span></span><br><span class="line"><span class="meta">        DEFINE_WAIT(__wait);                                              \</span></span><br><span class="line"><span class="meta">                                                                          \</span></span><br><span class="line"><span class="meta">        for (;;) &#123;                                                        \</span></span><br><span class="line"><span class="meta">            prepare_to_wait_exclusive(&amp;wq, &amp;__wait, TASK_INTERRUPTIBLE);  \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (condition) &#123;                                              \</span></span><br><span class="line"><span class="meta">                finish_wait(&amp;wq, &amp;__wait);                                \</span></span><br><span class="line"><span class="meta">                break;                                                    \</span></span><br><span class="line"><span class="meta">            &#125;                                                             \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (!signal_pending(current)) &#123;                               \</span></span><br><span class="line"><span class="meta">                schedule();                                               \</span></span><br><span class="line"><span class="meta">                continue;                                                 \</span></span><br><span class="line"><span class="meta">            &#125;                                                             \</span></span><br><span class="line"><span class="meta">            ret = -ERESTARTSYS;                                           \</span></span><br><span class="line"><span class="meta">            abort_exclusive_wait(&amp;wq, &amp;__wait, TASK_INTERRUPTIBLE, NULL); \</span></span><br><span class="line"><span class="meta">            break;                                                        \</span></span><br><span class="line"><span class="meta">        &#125;                                                                 \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">prepare_to_wait_exclusive</span><span class="params">(<span class="type">wait_queue_head_t</span>* q, <span class="type">wait_queue_t</span>* wait, <span class="type">int</span> state)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">    wait-&gt;flags |= WQ_FLAG_EXCLUSIVE;  <span class="comment">// 互斥进程</span></span><br><span class="line">    spin_lock_irqsave(&amp;q-&gt;lock, flags);</span><br><span class="line">    <span class="keyword">if</span> (list_empty(&amp;wait-&gt;task_list))</span><br><span class="line">        __add_wait_queue_tail(q, wait);  <span class="comment">// 添加到队列尾</span></span><br><span class="line">    set_current_state(state);</span><br><span class="line">    spin_unlock_irqrestore(&amp;q-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(prepare_to_wait_exclusive);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * abort_exclusive_wait - 终止在队列中的独占等待（abort exclusive waiting in a queue）</span></span><br><span class="line"><span class="comment"> * @q: waitqueue waited on</span></span><br><span class="line"><span class="comment"> * @wait: wait descriptor</span></span><br><span class="line"><span class="comment"> * @mode: runstate of the waiter to be woken</span></span><br><span class="line"><span class="comment"> * @key: key to identify a wait bit queue or %NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 将当前线程设置回运行状态，并从给定的等待队列中删除等待描述符（如果仍在队列中）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果调用者并发地唤醒该队列，则唤醒队列里的下一个等待者。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This prevents waiter starvation where an exclusive waiter</span></span><br><span class="line"><span class="comment"> * aborts and is woken up concurrently and no one wakes up</span></span><br><span class="line"><span class="comment"> * the next waiter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">abort_exclusive_wait</span><span class="params">(<span class="type">wait_queue_head_t</span>* q, <span class="type">wait_queue_t</span>* wait, <span class="type">unsigned</span> <span class="type">int</span> mode, <span class="type">void</span>* key)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">    __set_current_state(TASK_RUNNING);</span><br><span class="line">    spin_lock_irqsave(&amp;q-&gt;lock, flags);</span><br><span class="line">    <span class="keyword">if</span> (!list_empty(&amp;wait-&gt;task_list))</span><br><span class="line">        list_del_init(&amp;wait-&gt;task_list);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (waitqueue_active(q))  <span class="comment">// (!list_empty(&amp;q-&gt;task_list))</span></span><br><span class="line">        __wake_up_locked_key(q, mode, key);</span><br><span class="line">    spin_unlock_irqrestore(&amp;q-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(abort_exclusive_wait);</span><br></pre></td></tr></table></figure>
<h2 id="唤醒队列">唤醒队列</h2>
<h3 id="wake-up">wake_up</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> wake_up(x)      __wake_up(x, TASK_NORMAL, 1, NULL)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_NORMAL     (TASK_INTERRUPTIBLE | TASK_UNINTERRUPTIBLE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __wake_up - wake up threads blocked on a waitqueue.</span></span><br><span class="line"><span class="comment"> * @q: the waitqueue</span></span><br><span class="line"><span class="comment"> * @mode: which threads</span></span><br><span class="line"><span class="comment"> * @nr_exclusive: how many wake-one or wake-many threads to wake up</span></span><br><span class="line"><span class="comment"> * @key: is directly passed to the wakeup function</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It may be assumed that this function implies a write memory barrier before</span></span><br><span class="line"><span class="comment"> * changing the task state if and only if any tasks are woken up.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __wake_up(<span class="type">wait_queue_head_t</span> *q, <span class="type">unsigned</span> <span class="type">int</span> mode,</span><br><span class="line">            <span class="type">int</span> nr_exclusive, <span class="type">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;q-&gt;lock, flags);</span><br><span class="line">    __wake_up_common(q, mode, nr_exclusive, <span class="number">0</span>, key);</span><br><span class="line">    spin_unlock_irqrestore(&amp;q-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__wake_up);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The core wakeup function. Non-exclusive wakeups (nr_exclusive == 0) just</span></span><br><span class="line"><span class="comment"> * wake everything up. If it&#x27;s an exclusive wakeup (nr_exclusive == small +ve</span></span><br><span class="line"><span class="comment"> * number) then we wake all the non-exclusive tasks and one exclusive task.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There are circumstances in which we can try to wake a task which has already</span></span><br><span class="line"><span class="comment"> * started to run but is not in state TASK_RUNNING. try_to_wake_up() returns</span></span><br><span class="line"><span class="comment"> * zero in this (rare) case, and we handle it by continuing to scan the queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __wake_up_common(<span class="type">wait_queue_head_t</span> *q, <span class="type">unsigned</span> <span class="type">int</span> mode,</span><br><span class="line">            <span class="type">int</span> nr_exclusive, <span class="type">int</span> wake_flags, <span class="type">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">wait_queue_t</span> *curr, *next;</span><br><span class="line"></span><br><span class="line">    list_for_each_entry_safe(curr, next, &amp;q-&gt;task_list, task_list) &#123;</span><br><span class="line">        <span class="type">unsigned</span> flags = curr-&gt;flags;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过 curr-&gt;func 获取唤醒回调函数并执行</span></span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;func(curr, mode, wake_flags, key) &amp;&amp;</span><br><span class="line">                (flags &amp; WQ_FLAG_EXCLUSIVE) &amp;&amp; !--nr_exclusive)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>唤醒等待队列：可唤醒处于 TASK_INTERRUPTIBLE 和 TASK_UNINTERUPTIBLE 状态的进程，和 wait_event/wait_event_timeout 成对使用。</p>
<p>被唤醒的进程，都会检查自己等待的条件是否满足，满足的进程会修改自己的状态为 TASK_RUNNING；如果条件不满足会继续睡眠，等待下次被唤醒（睡眠的进程可能支持可中断，所以并发所有的唤醒都是由类似函数唤醒）。</p>
<h3 id="wake-up-interruptible">wake_up_interruptible</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> wake_up_interruptible(x)        __wake_up(x, TASK_INTERRUPTIBLE, 1, NULL)</span></span><br></pre></td></tr></table></figure>
<p>与 wake_up 的唯一区别是它只能唤醒 TASK_INTERRUPTIBLE 状态的进程。与 wait_event_interruptible/wait_event_interruptible_timeout/wait_event_interruptible_exclusive 成对使用。</p>
<h3 id="wake-up-…">wake_up_…</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> wake_up_all(x)      __wake_up(x, TASK_NORMAL, 0, NULL)  <span class="comment">// Non-exclusive wakeups (nr_exclusive == 0) just wake everything up.</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> wake_up_interruptible_nr(x, nr) __wake_up(x, TASK_INTERRUPTIBLE, nr, NULL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> wake_up_interruptible_all(x)    __wake_up(x, TASK_INTERRUPTIBLE, 0, NULL)</span></span><br></pre></td></tr></table></figure>
<p>这些也基本都和 wake_up/wake_up_interruptible 一样。</p>
<h2 id="在等待队列上睡眠">在等待队列上睡眠</h2>
<h3 id="sleep-on">sleep_on</h3>
<p>该函数的作用是定义一个等待队列（wait），并将 current 进程添加到等待队列中（wait），然后将当前进程的状态置为 TASK_UNINTERRUPTIBLE，并将等待队列（wait）添加到等待队列头（q）中。之后就被挂起直到资源可以获取，才被从等待队列头（q）中唤醒，从等待队列头（q）中移出等待队列（wait）。在被挂起等待资源期间，该进程不能被信号唤醒。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __sched <span class="title function_">sleep_on</span><span class="params">(<span class="type">wait_queue_head_t</span>* q)</span> &#123;</span><br><span class="line">    sleep_on_common(q, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(sleep_on);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> __sched <span class="title function_">sleep_on_common</span><span class="params">(<span class="type">wait_queue_head_t</span>* q, <span class="type">int</span> state, <span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">wait_queue_t</span> wait;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait 变量用于当前线程 current 挂接，并指定唤醒函数</span></span><br><span class="line">    init_waitqueue_entry(&amp;wait, current);</span><br><span class="line"></span><br><span class="line">    __set_current_state(state);</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;q-&gt;lock, flags);</span><br><span class="line">    __add_wait_queue(q, &amp;wait);</span><br><span class="line">    spin_unlock(&amp;q-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让线程调度并进入睡眠，直到资源可以获取或者超时</span></span><br><span class="line">    timeout = schedule_timeout(timeout);</span><br><span class="line">    spin_lock_irq(&amp;q-&gt;lock);</span><br><span class="line">    __remove_wait_queue(q, &amp;wait);</span><br><span class="line">    spin_unlock_irqrestore(&amp;q-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> timeout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/wait.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">init_waitqueue_entry</span><span class="params">(<span class="type">wait_queue_t</span>* q, <span class="keyword">struct</span> task_struct* p)</span> &#123;</span><br><span class="line">    q-&gt;flags = <span class="number">0</span>;</span><br><span class="line">    q-&gt;private = p;</span><br><span class="line">    q-&gt;func = default_wake_function;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __set_current_state(state_value) \</span></span><br><span class="line"><span class="meta">    do &#123;                                 \</span></span><br><span class="line"><span class="meta">        current-&gt;state = (state_value);  \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br></pre></td></tr></table></figure>
<p>上面，四个自旋锁操作的区别在于中断处理和锁的解锁方式：</p>
<ol>
<li>
<p><code>spin_lock_irqsave(&amp;q-&gt;lock, flags)</code>:</p>
<ul>
<li>获取自旋锁并禁用本地 CPU 中断。</li>
<li><strong>保存中断状态到 <code>flags</code> 中，以便之后恢复</strong>，用于确保在锁持有期间，不会因中断处理导致竞态条件。</li>
</ul>
</li>
<li>
<p><code>spin_unlock(&amp;q-&gt;lock)</code>:</p>
<ul>
<li>释放自旋锁。</li>
<li><strong>不恢复中断状态</strong>，常用于不涉及中断的情况下。</li>
</ul>
</li>
<li>
<p><code>spin_lock_irq(&amp;q-&gt;lock)</code>:</p>
<ul>
<li>获取自旋锁并禁用本地 CPU 中断。</li>
<li><strong>不保存中断状态</strong>，一般用于不关心中断状态恢复的临界区。</li>
</ul>
</li>
<li>
<p><code>spin_unlock_irqrestore(&amp;q-&gt;lock, flags)</code>:</p>
<ul>
<li>释放自旋锁。</li>
<li><strong>恢复之前保存的中断状态</strong>，用于结束一段可能影响中断处理的代码块，并恢复到进入时的中断状态。</li>
</ul>
</li>
</ol>
<h3 id="sleep-on-timeout">sleep_on_timeout</h3>
<p>与 sleep_on() 函数的区别在于调用该函数时，如果在指定的时间内（timeout）没有获得等待的资源就会返回。实际上是调用 schedule_timeout() 函数实现的。值得注意的是，如果给定的 timeout 小于 0，则不会睡眠。该函数返回的是真正的睡眠时间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> __sched <span class="title function_">sleep_on_timeout</span><span class="params">(<span class="type">wait_queue_head_t</span>* q, <span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sleep_on_common(q, TASK_UNINTERRUPTIBLE, timeout);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(sleep_on_timeout);</span><br></pre></td></tr></table></figure>
<h3 id="interruptible-sleep-on">interruptible_sleep_on</h3>
<p>该函数和 sleep_on() 函数唯一的区别是：将当前进程的状态置为 TASK_INTERRUPTINLE，这意味在睡眠过程中，如果该进程收到信号则会被唤醒。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __sched <span class="title function_">interruptible_sleep_on</span><span class="params">(<span class="type">wait_queue_head_t</span>* q)</span> &#123;</span><br><span class="line">    sleep_on_common(q, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(interruptible_sleep_on);</span><br></pre></td></tr></table></figure>
<h3 id="interruptible-sleep-on-timeout">interruptible_sleep_on_timeout</h3>
<p>类似于 sleep_on_timeout() 函数。进程在睡眠中可能在等待的时间没有到达就被信号打断而被唤醒，也可能是等待的时间到达而被唤醒。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> __sched <span class="title function_">interruptible_sleep_on_timeout</span><span class="params">(<span class="type">wait_queue_head_t</span>* q, <span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sleep_on_common(q, TASK_INTERRUPTIBLE, timeout);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(interruptible_sleep_on_timeout);</span><br></pre></td></tr></table></figure>
<p>以上四个函数都是让进程在等待队列上睡眠，不过是小有差异而已。在实际用的过程中，根据需要选择合适的函数使用就是了。例如，</p>
<ul>
<li>在对软驱数据的读写中，如果设备没有就绪，则调用 sleep_on() 函数睡眠直到数据可读（可写）；</li>
<li>在打开串口的时候，如果串口端口处于关闭状态，则调用 interruptible_sleep_on() 函数尝试等待其打开；</li>
<li>在声卡驱动中，读取声音数据时，如果没有数据可读，就会等待足够常的时间直到可读取。</li>
</ul>
<h2 id="字符设备驱动示例">字符设备驱动示例</h2>
<p>要在 Linux 内核中使用 <code>wait_queue_head_t</code> 来实现进程的等待和唤醒，我们可以编写一个简单的字符设备驱动示例。该示例将展示如何让一个进程进入睡眠状态，直到另一个进程或事件唤醒它。</p>
<h3 id="内核代码">内核代码</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;wait_queue_example&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major_num;</span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(wq)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> condition = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">device_read</span><span class="params">(<span class="keyword">struct</span> file* filp, <span class="type">char</span>* buffer, <span class="type">size_t</span> length, <span class="type">loff_t</span>* offset)</span> &#123;</span><br><span class="line">    printk(<span class="string">&quot;Process %d (%s) going to sleep\n&quot;</span>, current-&gt;pid, current-&gt;comm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让进程进入睡眠，并在条件满足（等待数据到达）时被唤醒</span></span><br><span class="line">    wait_event_interruptible(wq, condition != <span class="number">0</span>);  <span class="comment">// 该函数将进程设置为非互斥的 TASK_INTERRUPTIBLE 状态的进程</span></span><br><span class="line"></span><br><span class="line">    condition = <span class="number">0</span>;  <span class="comment">// Reset the condition</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;Process %d (%s) woken up\n&quot;</span>, current-&gt;pid, current-&gt;comm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">device_write</span><span class="params">(<span class="keyword">struct</span> file* filp, <span class="type">const</span> <span class="type">char</span>* buffer, <span class="type">size_t</span> length, <span class="type">loff_t</span>* offset)</span> &#123;</span><br><span class="line">    printk(<span class="string">&quot;Process %d (%s) waking up the readers\n&quot;</span>, current-&gt;pid, current-&gt;comm);</span><br><span class="line"></span><br><span class="line">    condition = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒等待在条件上的所有进程，通知已经有数据可以读取</span></span><br><span class="line">    wake_up_interruptible(&amp;wq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123;</span><br><span class="line">    .read = device_read,</span><br><span class="line">    .write = device_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">wait_queue_example_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    major_num = register_chrdev(<span class="number">0</span>, DEVICE_NAME, &amp;fops);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (major_num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;Registering char device failed with %d\n&quot;</span>, major_num);</span><br><span class="line">        <span class="keyword">return</span> major_num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;I was assigned major number %d.&quot;</span>, major_num);</span><br><span class="line">    printk(<span class="string">&quot;To talk to the driver, create a dev file with &#x27;mknod /dev/%s c %d 0&#x27;.\n&quot;</span>, DEVICE_NAME, major_num);</span><br><span class="line">    printk(<span class="string">&quot;Try various minor numbers. Try to cat and echo to the device file.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">wait_queue_example_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    unregister_chrdev(major_num, DEVICE_NAME);</span><br><span class="line">    printk(<span class="string">&quot;Goodbye, world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(wait_queue_example_init);</span><br><span class="line">module_exit(wait_queue_example_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;ahaaa&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;A simple Linux driver with wait queues&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="编译模块">编译模块</h3>
<p>使用 make 编译模块，在包含源代码和 Makefile 的目录中运行 make 命令，这会生成一个.ko（内核模块）文件，比如 wait_queue_example.ko。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m += wait_queue_example.o</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>
<h3 id="加载模块">加载模块</h3>
<p>使用 insmod 命令加载模块：<code>sudo insmod wait_queue_example.ko</code>。如果一切顺利，你将看不到任何输出，因为 <code>printk</code> 函数不会输出到控制台，而是输出到内核日志。</p>
<p>查看模块是否成功加载 / 卸载：<code>lsmod | grep wait_queue_example</code></p>
<p>查看内核日志，以确保模块正常启动：<code>dmesg | tail</code></p>
<p>使用 rmmod 命令卸载模块：<code>sudo rmmod wait_queue_example</code></p>
<h3 id="创建设备文件">创建设备文件</h3>
<p>查找 wait_queue_example 对应的主设备号：<code>cat /proc/devices</code></p>
<p>使用 mknod 创建设备文件，假设主设备号是 major_num：<code>sudo mknod /dev/wait_queue_example c &lt;major_num&gt; 0</code></p>
<p>设置设备文件的权限，使其可读写：<code>sudo chmod 666 /dev/wait_queue_example</code></p>
<h3 id="运行进程">运行进程</h3>
<p>在一个终端中运行<code>cat /dev/wait_queue_example</code>，此进程将进入等待队列进行睡眠。</p>
<p>在另一个终端中使用<code>echo &quot;wake&quot; &gt; /dev/wait_queue_example</code>，这将唤醒等待的进程。</p>
<p>再次通过 <code>dmesg | tail</code> 查看内核日志，可以看到：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[28154.120944] Process 9571 (cat) going to sleep</span><br><span class="line">[28200.935241] Process 9603 (bash) waking up the readers</span><br><span class="line">[28200.935265] Process 9571 (cat) woken up</span><br></pre></td></tr></table></figure>
<p>这两个进程，能共享 condition 这个变量吗？一个进行修改了这个变量，另一个进程可以读到修改后的变量吗？</p>
<p>是的，这两个进程可以共享和访问 condition 变量，因为 <strong> 它们在同一个内核模块中运行，并共享相同的内存地址空间（同一块内存）</strong>。因此，一个进程对 condition 的更改对其它进程立即可见。</p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://shunlqing.github.io/2018/05/19/2018_5_19LinuxKernel_WaitQueue/">https://shunlqing.github.io/2018/05/19/2018_5_19LinuxKernel_WaitQueue/</a></li>
<li><a href="https://cslqm.github.io/2020/01/08/wait_queue_head_t/">https://cslqm.github.io/2020/01/08/wait_queue_head_t/</a></li>
<li><a href="https://juejin.cn/post/7083852861930471432">https://juejin.cn/post/7083852861930471432</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>数据结构 - 等待队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 数据结构之队列</title>
    <url>/posts/240702200642.html</url>
    <content><![CDATA[<p>Tail Queue 位于 <code>/usr/include/x86_64-linux-gnu/sys/queue.h</code>，可以<code>include &lt;sys/queue.h&gt;</code> 后直接使用。Queue 的所有源码都是宏定义，因此完全包含于 queue.h 当中，无需编译为库文件。</p>
<span id="more"></span>
<h1 id="各种结构示意图">各种结构示意图</h1>
<p>queue.h 包含以下几种数据结构：</p>
<ul>
<li>单链表（Singly-linked List, SLIST）</li>
<li>单链尾队列（Singly-linked Tail queue, STAILQ）</li>
<li>双链表（List, LIST）</li>
<li>双链尾队列（Tail queue, TAILQ）</li>
<li>简单队列（Simple queue, SQUEUE）</li>
<li>循环队列（Circular queue, CIRCLEQ）</li>
</ul>
<p>SLIST：单向无尾队列。SLIST 非常适合具有大数据集且很少或没有删除的应用程序，或者用于实现 LIFO 后进先出队列。</p>
<img src="/images/data-structure/linux-slist.png" alt="单向无尾队列" width="80%" height="80%">
<p>STAILQ：单向有尾队列，节点 n 为尾节点。</p>
<img src="/images/data-structure/linux-stailq.png" alt="单向有尾队列" width="80%" height="80%">
<p>LIST：双向无尾队列。</p>
<img src="/images/data-structure/linux-list.png" alt="双向无尾队列" width="80%" height="80%">
<p>TAILQ：双向有尾队列。</p>
<img src="/images/data-structure/linux-tailq.png" alt="双向有尾队列" width="80%" height="80%">
<p>CIRCLEQ：双向循环队列。</p>
<img src="/images/data-structure/linux-circleq.png" alt="双向循环队列" width="80%" height="80%">
<blockquote>
<p>有尾、无尾的区别：通过这几张图可以发现，有尾（无尾）就是 head 头结构中有（无）指向链表尾节点的指针。</p>
</blockquote>
<h1 id="各种结构指向图">各种结构指向图</h1>
<img src="/images/data-structure/linux-queue.png" alt="各种结构指向图" width="100%" height="100%">
<h1 id="单向无尾队列 SLIST">单向无尾队列 SLIST</h1>
<p>SLIST：单向无尾队列。SLIST 非常适合具有大数据集且很少或没有删除的应用程序，或者用于实现 LIFO 后进先出队列。</p>
<img src="/images/data-structure/linux-slist.png" alt="单向无尾队列" width="80%" height="80%">
<h2 id="扩展后的数据结构">扩展后的数据结构</h2>
<p>SLIST 数据结构涉及 SLIST_HEAD 和 SLIST_ENTRY 两个宏定义，先给出扩展后的数据结构示例，可以看出两处宏的 type 参数要保持统一（这里都是 entry）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表节点，不同于新手常写的链表，这里被一个 struct 包裹起来了</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entry</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">// SLIST_ENTRY(entry) entries;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">entry</span>* <span class="title">sle_next</span>;</span></span><br><span class="line">    &#125; entries;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slisthead</span> &#123;</span> <span class="comment">// SLIST_HEAD(slisthead, entry);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">entry</span>* <span class="title">slh_first</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="数据结构宏定义">数据结构宏定义</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Singly-linked List definitions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// SLIST 的头节点，这里传入的 type 与 SLIST_ENTRY 宏中的 type 一致</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLIST_HEAD(name, type)                      \</span></span><br><span class="line"><span class="meta">    struct name &#123;                                   \</span></span><br><span class="line"><span class="meta">        struct type* slh_first; <span class="comment">/* first element */</span> \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 SLIST 的头节点结构体（不是结构体指针）为 NULL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLIST_HEAD_INITIALIZER(head) \</span></span><br><span class="line"><span class="meta">    &#123; NULL &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SLIST 的节点，这里传入的 type 与 SLIST_HEAD 宏中的 type 一致</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLIST_ENTRY(type)                         \</span></span><br><span class="line"><span class="meta">    struct &#123;                                      \</span></span><br><span class="line"><span class="meta">        struct type* sle_next; <span class="comment">/* next element */</span> \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里只给出了指向下一个 SLIST 节点的数据结构，没有数据字段，在项目代码使用时，可以这样写：</span></span><br><span class="line"><span class="comment">    struct entry &#123;</span></span><br><span class="line"><span class="comment">        int data;</span></span><br><span class="line"><span class="comment">        SLIST_ENTRY(entry) entries;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="操作函数宏定义">操作函数宏定义</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Singly-linked List functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 初始化 SLIST 头节点结构体指针的 slh_first 成员为 NULL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLIST_INIT(head)          \</span></span><br><span class="line"><span class="meta">    do &#123;                          \</span></span><br><span class="line"><span class="meta">        (head)-&gt;slh_first = NULL; \</span></span><br><span class="line"><span class="meta">    &#125; while (<span class="comment">/*CONSTCOND*/</span> 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 适用于中间节点、尾节点后面插入，不能用于首节点前面插入</span></span><br><span class="line"><span class="comment">    0. field 为 SLIST_ENTRY 成员的成员名</span></span><br><span class="line"><span class="comment">    1. 将新元素 elm 的 sle_next 指向 slistelm 元素的 sle_next</span></span><br><span class="line"><span class="comment">    2. 在元素 slistelm 后面插入新元素 elm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLIST_INSERT_AFTER(slistelm, elm, field)            \</span></span><br><span class="line"><span class="meta">    do &#123;                                                    \</span></span><br><span class="line"><span class="meta">        (elm)-&gt;field.sle_next = (slistelm)-&gt;field.sle_next; \</span></span><br><span class="line"><span class="meta">        (slistelm)-&gt;field.sle_next = (elm);                 \</span></span><br><span class="line"><span class="meta">    &#125; while (<span class="comment">/*CONSTCOND*/</span> 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 适用于在首节点前插入（同时更新头节点）</span></span><br><span class="line"><span class="comment">    1. 将新元素 elm 的 sle_next 指向头节点的 slh_first</span></span><br><span class="line"><span class="comment">    2. 更新头节点 head 的 slh_first 地址为新元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLIST_INSERT_HEAD(head, elm, field)        \</span></span><br><span class="line"><span class="meta">    do &#123;                                           \</span></span><br><span class="line"><span class="meta">        (elm)-&gt;field.sle_next = (head)-&gt;slh_first; \</span></span><br><span class="line"><span class="meta">        (head)-&gt;slh_first = (elm);                 \</span></span><br><span class="line"><span class="meta">    &#125; while (<span class="comment">/*CONSTCOND*/</span> 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新头节点 head 的 slh_first 地址为下一个节点</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLIST_REMOVE_HEAD(head, field)                         \</span></span><br><span class="line"><span class="meta">    do &#123;                                                       \</span></span><br><span class="line"><span class="meta">        (head)-&gt;slh_first = (head)-&gt;slh_first-&gt;field.sle_next; \</span></span><br><span class="line"><span class="meta">    &#125; while (<span class="comment">/*CONSTCOND*/</span> 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    向后遍历头节点 head 指向的 type 类型的链表 curelm，移除（未释放）指定的元素 elm</span></span><br><span class="line"><span class="comment">    1. 如果头节点 head 指向的链表首节点是待移除的元素 elm -&gt; 更新头节点</span></span><br><span class="line"><span class="comment">    2. 否则，循环判断当前节点 curelm 的下一个节点是否是待移除的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLIST_REMOVE(head, elm, type, field)                                 \</span></span><br><span class="line"><span class="meta">    do &#123;                                                                     \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> ((head)-&gt;slh_first == (elm)) &#123;                                    \</span></span><br><span class="line"><span class="meta">            SLIST_REMOVE_HEAD((head), field);                                \</span></span><br><span class="line"><span class="meta">        &#125; <span class="keyword">else</span> &#123;                                                             \</span></span><br><span class="line"><span class="meta">            struct type* curelm = (head)-&gt;slh_first;                         \</span></span><br><span class="line"><span class="meta">            while (curelm-&gt;field.sle_next != (elm))                          \</span></span><br><span class="line"><span class="meta">                curelm = curelm-&gt;field.sle_next;                             \</span></span><br><span class="line"><span class="meta">            curelm-&gt;field.sle_next = curelm-&gt;field.sle_next-&gt;field.sle_next; \</span></span><br><span class="line"><span class="meta">        &#125;                                                                    \</span></span><br><span class="line"><span class="meta">    &#125; while (<span class="comment">/*CONSTCOND*/</span> 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从头节点 head 指向的链表首节点开始遍历链表，依次将每个节点分配给 var，通过判断 var 是否为 NULL 决定是否遍历完成</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLIST_FOREACH(var, head, field) for ((var) = (head)-&gt;slh_first; (var); (var) = (var)-&gt;field.sle_next)</span></span><br></pre></td></tr></table></figure>
<h2 id="访问宏定义">访问宏定义</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Singly-linked List access methods.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLIST_EMPTY(head) ((head)-&gt;slh_first == NULL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLIST_FIRST(head) ((head)-&gt;slh_first)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLIST_NEXT(elm, field) ((elm)-&gt;field.sle_next)</span></span><br></pre></td></tr></table></figure>
<h2 id="示例代码">示例代码</h2>
<p>示例代码来自：<a href="https://man7.org/linux/man-pages/man3/SLIST_ENTRY.3.html">man-pages</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/queue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 参见《扩展后的数据结构》 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entry</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    SLIST_ENTRY(entry) entries; <span class="comment">/* Singly linked list */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SLIST_HEAD(slisthead, entry);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">n1</span>, *<span class="title">n2</span>, *<span class="title">n3</span>, *<span class="title">np</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">slisthead</span> <span class="title">head</span>;</span> <span class="comment">/* Singly linked list head */</span></span><br><span class="line"></span><br><span class="line">    SLIST_INIT(&amp;head); <span class="comment">/* Initialize the queue */</span></span><br><span class="line"></span><br><span class="line">    n1 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> entry)); <span class="comment">/* Insert at the head */</span></span><br><span class="line">    SLIST_INSERT_HEAD(&amp;head, n1, entries);</span><br><span class="line"></span><br><span class="line">    n2 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> entry)); <span class="comment">/* Insert after */</span></span><br><span class="line">    SLIST_INSERT_AFTER(n1, n2, entries);</span><br><span class="line"></span><br><span class="line">    SLIST_REMOVE(&amp;head, n2, entry, entries); <span class="comment">/* Deletion */</span></span><br><span class="line">    <span class="built_in">free</span>(n2);                                <span class="comment">// 用户手动释放</span></span><br><span class="line"></span><br><span class="line">    n3 = SLIST_FIRST(&amp;head);</span><br><span class="line">    SLIST_REMOVE_HEAD(&amp;head, entries); <span class="comment">/* Deletion from the head */</span></span><br><span class="line">    <span class="built_in">free</span>(n3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        n1 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> entry));</span><br><span class="line">        SLIST_INSERT_HEAD(&amp;head, n1, entries);  <span class="comment">// 在链表头插入</span></span><br><span class="line">        n1-&gt;data = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Forward traversal */</span></span><br><span class="line">    SLIST_FOREACH(np, &amp;head, entries) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%i &quot;</span>, np-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>); <span class="comment">// 4 3 2 1 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!SLIST_EMPTY(&amp;head)) &#123; <span class="comment">/* List deletion */</span></span><br><span class="line">        n1 = SLIST_FIRST(&amp;head);</span><br><span class="line">        SLIST_REMOVE_HEAD(&amp;head, entries);</span><br><span class="line">        <span class="built_in">free</span>(n1);</span><br><span class="line">    &#125;</span><br><span class="line">    SLIST_INIT(&amp;head);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="单向有尾队列 STAILQ">单向有尾队列 STAILQ</h1>
<p>STAILQ：单向有尾队列，节点 n 为尾节点。</p>
<img src="/images/data-structure/linux-stailq.png" alt="单向有尾队列" width="80%" height="80%">
<h2 id="扩展后的数据结构 -v2">扩展后的数据结构</h2>
<p>STAILQ 数据结构涉及 STAILQ_HEAD 和 STAILQ_ENTRY 两个宏定义，先给出扩展后的数据结构示例，可以看出两处宏的 type 参数要保持统一（这里都是 entry）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单向尾队列的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entry</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">// STAILQ_ENTRY(entry)</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">entry</span>* <span class="title">stqe_next</span>;</span></span><br><span class="line">    &#125; entries;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stailhead</span> &#123;</span> <span class="comment">// STAILQ_HEAD(stailhead, entry)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">entry</span>* <span class="title">stqh_first</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">entry</span>** <span class="title">stqh_last</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="数据结构宏定义 -v2">数据结构宏定义</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Singly-linked Tail queue declarations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// STAILQ 的头节点，stqh_last 是一个二级指针，里面存储着一个地址（指向尾节点的 stqe_next 成员地址，而不是尾节点首地址）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STAILQ_HEAD(name, type)                                       \</span></span><br><span class="line"><span class="meta">    struct name &#123;                                                     \</span></span><br><span class="line"><span class="meta">        struct type* stqh_first; <span class="comment">/* first element */</span>                  \</span></span><br><span class="line"><span class="meta">        struct type** stqh_last; <span class="comment">/* addr of last stqe_next element */</span> \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 STAILQ 的头节点（不是结构体指针）的 stqh_first 为 NULL，stqh_last 为 stqh_first 的地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STAILQ_HEAD_INITIALIZER(head) \</span></span><br><span class="line"><span class="meta">    &#123; NULL, &amp;(head).stqh_first &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// STAILQ 的节点，这里传入的 type 与 STAILQ_HEAD 宏中的 type 一致</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STAILQ_ENTRY(type)                         \</span></span><br><span class="line"><span class="meta">    struct &#123;                                       \</span></span><br><span class="line"><span class="meta">        struct type* stqe_next; <span class="comment">/* next element */</span> \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里只给出了指向下一个 STAILQ 节点的数据结构，没有数据字段，在项目代码使用时，可以这样写：</span></span><br><span class="line"><span class="comment">    struct entry &#123;</span></span><br><span class="line"><span class="comment">        int data;</span></span><br><span class="line"><span class="comment">        STAILQ_ENTRY(entry) entries;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="操作函数宏定义 -v2">操作函数宏定义</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Singly-linked Tail queue functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 初始化 STAILQ 头节点结构体指针的成员</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STAILQ_INIT(head)                        \</span></span><br><span class="line"><span class="meta">    do &#123;                                         \</span></span><br><span class="line"><span class="meta">        (head)-&gt;stqh_first = NULL;               \</span></span><br><span class="line"><span class="meta">        (head)-&gt;stqh_last = &amp;(head)-&gt;stqh_first; \</span></span><br><span class="line"><span class="meta">    &#125; while (<span class="comment">/*CONSTCOND*/</span> 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 STAILQ 的头节点 head 前插入新元素 elm，并重新将头节点 head 指向新元素 elm</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STAILQ_INSERT_HEAD(head, elm, field)                       \</span></span><br><span class="line"><span class="meta">    do &#123;                                                           \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (((elm)-&gt;field.stqe_next = (head)-&gt;stqh_first) == NULL) \</span></span><br><span class="line"><span class="meta">            (head)-&gt;stqh_last = &amp;(elm)-&gt;field.stqe_next;           \</span></span><br><span class="line"><span class="meta">        (head)-&gt;stqh_first = (elm);                                \</span></span><br><span class="line"><span class="meta">    &#125; while (<span class="comment">/*CONSTCOND*/</span> 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 STAILQ 尾节点（通过头节点 head 获取）后面插入新元素 elm</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STAILQ_INSERT_TAIL(head, elm, field)         \</span></span><br><span class="line"><span class="meta">    do &#123;                                             \</span></span><br><span class="line"><span class="meta">        (elm)-&gt;field.stqe_next = NULL;               \</span></span><br><span class="line"><span class="meta">        *(head)-&gt;stqh_last = (elm); <span class="comment">/* 原尾节点的 stqe_next 指向新元素 */</span> \</span></span><br><span class="line"><span class="meta">        (head)-&gt;stqh_last = &amp;(elm)-&gt;field.stqe_next; \</span></span><br><span class="line"><span class="meta">    &#125; while (<span class="comment">/*CONSTCOND*/</span> 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在中间节点、尾节点 listelm 后面插入新元素 elm。如果是尾节点后插入，则需要更新头节点的 stqh_last</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STAILQ_INSERT_AFTER(head, listelm, elm, field)                     \</span></span><br><span class="line"><span class="meta">    do &#123;                                                                   \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (((elm)-&gt;field.stqe_next = (listelm)-&gt;field.stqe_next) == NULL) \</span></span><br><span class="line"><span class="meta">            (head)-&gt;stqh_last = &amp;(elm)-&gt;field.stqe_next;                   \</span></span><br><span class="line"><span class="meta">        (listelm)-&gt;field.stqe_next = (elm);                                \</span></span><br><span class="line"><span class="meta">    &#125; while (<span class="comment">/*CONSTCOND*/</span> 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 头节点指向首节点的下一个节点。如果移动后只剩一个节点，则需要更新头节点的 stqh_last</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STAILQ_REMOVE_HEAD(head, field)                                         \</span></span><br><span class="line"><span class="meta">    do &#123;                                                                        \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (((head)-&gt;stqh_first = (head)-&gt;stqh_first-&gt;field.stqe_next) == NULL) \</span></span><br><span class="line"><span class="meta">            (head)-&gt;stqh_last = &amp;(head)-&gt;stqh_first;                            \</span></span><br><span class="line"><span class="meta">    &#125; while (<span class="comment">/*CONSTCOND*/</span> 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 head 遍历 STAILQ，移除指定的元素 elm。如果移除的元素 elm 是尾节点，则需要更新头节点的 stqh_last</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STAILQ_REMOVE(head, elm, type, field)                                                 \</span></span><br><span class="line"><span class="meta">    do &#123;                                                                                      \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> ((head)-&gt;stqh_first == (elm)) &#123;                                                    \</span></span><br><span class="line"><span class="meta">            STAILQ_REMOVE_HEAD((head), field);                                                \</span></span><br><span class="line"><span class="meta">        &#125; <span class="keyword">else</span> &#123;                                                                              \</span></span><br><span class="line"><span class="meta">            struct type* curelm = (head)-&gt;stqh_first;                                         \</span></span><br><span class="line"><span class="meta">            while (curelm-&gt;field.stqe_next != (elm))                                          \</span></span><br><span class="line"><span class="meta">                curelm = curelm-&gt;field.stqe_next;                                             \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> ((curelm-&gt;field.stqe_next = curelm-&gt;field.stqe_next-&gt;field.stqe_next) == NULL) \</span></span><br><span class="line"><span class="meta">                (head)-&gt;stqh_last = &amp;(curelm)-&gt;field.stqe_next;                               \</span></span><br><span class="line"><span class="meta">        &#125;                                                                                     \</span></span><br><span class="line"><span class="meta">    &#125; while (<span class="comment">/*CONSTCOND*/</span> 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从头节点 head 指向的首节点开始遍历队列，依次将每个节点分配给 var，通过判断 var 是否为 NULL 决定是否遍历完成</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STAILQ_FOREACH(var, head, field) for ((var) = ((head)-&gt;stqh_first); (var); (var) = ((var)-&gt;field.stqe_next))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STAILQ_CONCAT(head1, head2)                    \</span></span><br><span class="line"><span class="meta">    do &#123;                                               \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!STAILQ_EMPTY((head2))) &#123;                  \</span></span><br><span class="line"><span class="meta">            *(head1)-&gt;stqh_last = (head2)-&gt;stqh_first; \</span></span><br><span class="line"><span class="meta">            (head1)-&gt;stqh_last = (head2)-&gt;stqh_last;   \</span></span><br><span class="line"><span class="meta">            STAILQ_INIT((head2));                      \</span></span><br><span class="line"><span class="meta">        &#125;                                              \</span></span><br><span class="line"><span class="meta">    &#125; while (<span class="comment">/*CONSTCOND*/</span> 0)</span></span><br></pre></td></tr></table></figure>
<h2 id="访问宏定义 -v2">访问宏定义</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Singly-linked Tail queue access methods.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STAILQ_EMPTY(head) ((head)-&gt;stqh_first == NULL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STAILQ_FIRST(head) ((head)-&gt;stqh_first)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STAILQ_NEXT(elm, field) ((elm)-&gt;field.stqe_next)</span></span><br></pre></td></tr></table></figure>
<h2 id="示例代码 -v2">示例代码</h2>
<p>示例代码来自：<a href="https://man7.org/linux/man-pages/man3/stailq.3.html">man-pages</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/queue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entry</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    STAILQ_ENTRY(entry) entries; <span class="comment">/* Singly linked tail queue */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">STAILQ_HEAD(stailhead, entry);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">n1</span>, *<span class="title">n2</span>, *<span class="title">n3</span>, *<span class="title">np</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stailhead</span> <span class="title">head</span>;</span> <span class="comment">/* Singly linked tail queue head */</span></span><br><span class="line"></span><br><span class="line">    STAILQ_INIT(&amp;head); <span class="comment">/* Initialize the queue */</span></span><br><span class="line"></span><br><span class="line">    n1 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> entry)); <span class="comment">/* Insert at the head */</span></span><br><span class="line">    STAILQ_INSERT_HEAD(&amp;head, n1, entries);</span><br><span class="line"></span><br><span class="line">    n1 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> entry)); <span class="comment">/* Insert at the tail */</span></span><br><span class="line">    STAILQ_INSERT_TAIL(&amp;head, n1, entries);</span><br><span class="line"></span><br><span class="line">    n2 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> entry)); <span class="comment">/* Insert after */</span></span><br><span class="line">    STAILQ_INSERT_AFTER(&amp;head, n1, n2, entries);</span><br><span class="line"></span><br><span class="line">    STAILQ_REMOVE(&amp;head, n2, entry, entries); <span class="comment">/* Deletion */</span></span><br><span class="line">    <span class="built_in">free</span>(n2);</span><br><span class="line"></span><br><span class="line">    n3 = STAILQ_FIRST(&amp;head);</span><br><span class="line">    STAILQ_REMOVE_HEAD(&amp;head, entries); <span class="comment">/* Deletion from the head */</span></span><br><span class="line">    <span class="built_in">free</span>(n3);</span><br><span class="line"></span><br><span class="line">    n1 = STAILQ_FIRST(&amp;head);</span><br><span class="line">    n1-&gt;data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        n1 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> entry));</span><br><span class="line">        STAILQ_INSERT_HEAD(&amp;head, n1, entries);</span><br><span class="line">        n1-&gt;data = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Forward traversal */</span></span><br><span class="line">    STAILQ_FOREACH(np, &amp;head, entries) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%i &quot;</span>, np-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>); <span class="comment">// 4 3 2 1 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* TailQ deletion */</span></span><br><span class="line">    n1 = STAILQ_FIRST(&amp;head);</span><br><span class="line">    <span class="keyword">while</span> (n1 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        n2 = STAILQ_NEXT(n1, entries);</span><br><span class="line">        <span class="built_in">free</span>(n1);</span><br><span class="line">        n1 = n2;</span><br><span class="line">    &#125;</span><br><span class="line">    STAILQ_INIT(&amp;head);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="双向无尾队列 LIST">双向无尾队列 LIST</h1>
<p>LIST：双向无尾队列。</p>
<img src="/images/data-structure/linux-list.png" alt="双向无尾队列" width="80%" height="80%">
<h2 id="扩展后的数据结构 -v3">扩展后的数据结构</h2>
<p>LIST 数据结构涉及 LIST_HEAD 和 LIST_ENTRY 两个宏定义，先给出扩展后的数据结构示例，可以看出两处宏的 type 参数要保持统一（这里都是 entry）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LIST 节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entry</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">// LIST_ENTRY(entry) entries;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">entry</span>* <span class="title">le_next</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">entry</span>** <span class="title">le_prev</span>;</span></span><br><span class="line">    &#125; entries;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LIST 头节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listhead</span> &#123;</span> <span class="comment">// LIST_HEAD(listhead, entry);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">entry</span>* <span class="title">lh_first</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据结构宏定义 -v3">数据结构宏定义</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * List definitions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// LIST 头节点</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_HEAD(name, type)                      \</span></span><br><span class="line"><span class="meta">    struct name &#123;                                  \</span></span><br><span class="line"><span class="meta">        struct type* lh_first; <span class="comment">/* first element */</span> \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LIST 头节点结构体（非结构体指针）初始化为 NULL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_HEAD_INITIALIZER(head) \</span></span><br><span class="line"><span class="meta">    &#123; NULL &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LIST 节点，le_prev 是一个二级指针，里面存储着一个地址（指向前一个节点的 le_next 成员地址）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_ENTRY(type)                                              \</span></span><br><span class="line"><span class="meta">    struct &#123;                                                          \</span></span><br><span class="line"><span class="meta">        struct type* le_next;  <span class="comment">/* next element */</span>                     \</span></span><br><span class="line"><span class="meta">        struct type** le_prev; <span class="comment">/* address of previous next element */</span> \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="操作函数宏定义 -v3">操作函数宏定义</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * List functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT(head)          \</span></span><br><span class="line"><span class="meta">    do &#123;                         \</span></span><br><span class="line"><span class="meta">        (head)-&gt;lh_first = NULL; \</span></span><br><span class="line"><span class="meta">    &#125; while (<span class="comment">/*CONSTCOND*/</span> 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在 listelm 节点后面插入新节点 elm</span></span><br><span class="line"><span class="comment">    1. 将新节点 elm 指向 listelm 节点的原有的下一个节点前面</span></span><br><span class="line"><span class="comment">    2. listelm 节点的原有的下一个节点的 le_prev，更新为指向新节点 elm 的 le_next 成员地址</span></span><br><span class="line"><span class="comment">    3. 更新 listelm 节点的下一个节点为新节点 elm</span></span><br><span class="line"><span class="comment">    4. 新节点的 le_prev，更新为指向 listelm 节点的 le_next 成员地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INSERT_AFTER(listelm, elm, field)                               \</span></span><br><span class="line"><span class="meta">    do &#123;                                                                     \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (((elm)-&gt;field.le_next = (listelm)-&gt;field.le_next) != NULL)       \</span></span><br><span class="line"><span class="meta">            (listelm)-&gt;field.le_next-&gt;field.le_prev = &amp;(elm)-&gt;field.le_next; \</span></span><br><span class="line"><span class="meta">        (listelm)-&gt;field.le_next = (elm);                                    \</span></span><br><span class="line"><span class="meta">        (elm)-&gt;field.le_prev = &amp;(listelm)-&gt;field.le_next;                    \</span></span><br><span class="line"><span class="meta">    &#125; while (<span class="comment">/*CONSTCOND*/</span> 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在 listelm 节点前面插入新节点 elm</span></span><br><span class="line"><span class="comment">    1. 新节点 elm 的 le_prev 更新为 listelm 节点的 le_prev</span></span><br><span class="line"><span class="comment">    2. 新节点 elm 的 le_next 指向 listelm 节点</span></span><br><span class="line"><span class="comment">    3. 让 listelm 节点的原有前一个节点指向新节点 elm</span></span><br><span class="line"><span class="comment">    4. listelm 节点的 le_prev 指向前一个新节点 elm 的 le_next 成员地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INSERT_BEFORE(listelm, elm, field)           \</span></span><br><span class="line"><span class="meta">    do &#123;                                                  \</span></span><br><span class="line"><span class="meta">        (elm)-&gt;field.le_prev = (listelm)-&gt;field.le_prev;  \</span></span><br><span class="line"><span class="meta">        (elm)-&gt;field.le_next = (listelm);                 \</span></span><br><span class="line"><span class="meta">        *(listelm)-&gt;field.le_prev = (elm);                \</span></span><br><span class="line"><span class="meta">        (listelm)-&gt;field.le_prev = &amp;(elm)-&gt;field.le_next; \</span></span><br><span class="line"><span class="meta">    &#125; while (<span class="comment">/*CONSTCOND*/</span> 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在 head 头节点前插入一个节点 elm，并更新头</span></span><br><span class="line"><span class="comment">    1. 将新节点链接在头节点指向的首节点的前面</span></span><br><span class="line"><span class="comment">    2. 更新头节点指向的首节点的 le_prev 为新节点 elm 的 le_next 成员地址</span></span><br><span class="line"><span class="comment">    3. 更新头节点 lh_first 为新节点 elm 的首地址</span></span><br><span class="line"><span class="comment">    4. 更新新首节点 elm 的 le_prev 的地址为头节点的 lh_first 成员地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INSERT_HEAD(head, elm, field)                           \</span></span><br><span class="line"><span class="meta">    do &#123;                                                             \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (((elm)-&gt;field.le_next = (head)-&gt;lh_first) != NULL)       \</span></span><br><span class="line"><span class="meta">            (head)-&gt;lh_first-&gt;field.le_prev = &amp;(elm)-&gt;field.le_next; \</span></span><br><span class="line"><span class="meta">        (head)-&gt;lh_first = (elm);                                    \</span></span><br><span class="line"><span class="meta">        (elm)-&gt;field.le_prev = &amp;(head)-&gt;lh_first;                    \</span></span><br><span class="line"><span class="meta">    &#125; while (<span class="comment">/*CONSTCOND*/</span> 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 移除指定的节点</span></span><br><span class="line"><span class="comment">    1. 将移除节点的下一个节点的 le_prev 更新为移除元素的 le_prev（如果移除节点不是尾节点）</span></span><br><span class="line"><span class="comment">    2. 通过解引用移除节点的 le_prev 获取前一个节点指向的下一个节点，将其重新指向移除元素的下一个节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_REMOVE(elm, field)                                         \</span></span><br><span class="line"><span class="meta">    do &#123;                                                                \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> ((elm)-&gt;field.le_next != NULL)                               \</span></span><br><span class="line"><span class="meta">            (elm)-&gt;field.le_next-&gt;field.le_prev = (elm)-&gt;field.le_prev; \</span></span><br><span class="line"><span class="meta">        *(elm)-&gt;field.le_prev = (elm)-&gt;field.le_next;                   \</span></span><br><span class="line"><span class="meta">    &#125; while (<span class="comment">/*CONSTCOND*/</span> 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从头节点 head 指向的首节点开始遍历队列，依次将每个节点分配给 var，通过判断 var 是否为 NULL 决定是否遍历完成</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_FOREACH(var, head, field) for ((var) = ((head)-&gt;lh_first); (var); (var) = ((var)-&gt;field.le_next))</span></span><br></pre></td></tr></table></figure>
<h2 id="访问宏定义 -v3">访问宏定义</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * List access methods.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_EMPTY(head) ((head)-&gt;lh_first == NULL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_FIRST(head) ((head)-&gt;lh_first)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_NEXT(elm, field) ((elm)-&gt;field.le_next)</span></span><br></pre></td></tr></table></figure>
<h2 id="示例代码 -v3">示例代码</h2>
<p>示例代码来自：<a href="https://man7.org/linux/man-pages/man3/list.3.html">man-pages</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/queue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entry</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    LIST_ENTRY(entry) entries; <span class="comment">/* List */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LIST_HEAD(listhead, entry);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">n1</span>, *<span class="title">n2</span>, *<span class="title">n3</span>, *<span class="title">np</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listhead</span> <span class="title">head</span>;</span> <span class="comment">/* List head */</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    LIST_INIT(&amp;head); <span class="comment">/* Initialize the list */</span></span><br><span class="line"></span><br><span class="line">    n1 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> entry));     <span class="comment">/* Insert at the head */</span></span><br><span class="line">    LIST_INSERT_HEAD(&amp;head, n1, entries);  <span class="comment">// head &lt;-&gt; n1</span></span><br><span class="line"></span><br><span class="line">    n2 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> entry));   <span class="comment">/* Insert after */</span></span><br><span class="line">    LIST_INSERT_AFTER(n1, n2, entries);  <span class="comment">// head &lt;-&gt; n1 &lt;-&gt; n2</span></span><br><span class="line"></span><br><span class="line">    n3 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> entry));    <span class="comment">/* Insert before */</span></span><br><span class="line">    LIST_INSERT_BEFORE(n2, n3, entries);  <span class="comment">// head &lt;-&gt; n1 &lt;-&gt; n3 &lt;-&gt; n2</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>; <span class="comment">/* Forward traversal */</span></span><br><span class="line">    LIST_FOREACH(np, &amp;head, entries) &#123;</span><br><span class="line">        np-&gt;data = i++;  <span class="comment">// n1(0) n3(1) n2(2)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LIST_REMOVE(n2, entries); <span class="comment">/* Deletion, head &lt;-&gt; n1 &lt;-&gt; n3 */</span></span><br><span class="line">    <span class="built_in">free</span>(n2);</span><br><span class="line">    <span class="comment">/* Forward traversal */</span></span><br><span class="line">    LIST_FOREACH(np, &amp;head, entries) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%i &quot;</span>, np-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);  <span class="comment">// 0 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List deletion */</span></span><br><span class="line">    n1 = LIST_FIRST(&amp;head);</span><br><span class="line">    <span class="keyword">while</span> (n1 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        n2 = LIST_NEXT(n1, entries);</span><br><span class="line">        <span class="built_in">free</span>(n1);</span><br><span class="line">        n1 = n2;</span><br><span class="line">    &#125;</span><br><span class="line">    LIST_INIT(&amp;head);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="双向有尾队列 TAILQ">双向有尾队列 TAILQ</h1>
<p>TAILQ：双向有尾队列。</p>
<img src="/images/data-structure/linux-tailq.png" alt="双向有尾队列" width="80%" height="80%">
<h2 id="扩展后的数据结构 -v4">扩展后的数据结构</h2>
<p>TAILQ 数据结构涉及 TAILQ_HEAD 和 TAILQ_ENTRY 两个宏定义，先给出扩展后的数据结构示例，可以看出两处宏的 type 参数要保持统一（这里都是 entry）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entry</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span>  <span class="comment">// TAILQ_ENTRY(entry)</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">entry</span>* <span class="title">tqe_next</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">entry</span>** <span class="title">tqe_prev</span>;</span></span><br><span class="line">    &#125; entries;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tailhead</span> &#123;</span>  <span class="comment">// TAILQ_HEAD(tailhead, entry)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">entry</span>* <span class="title">tqh_first</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">entry</span>** <span class="title">tqh_last</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>tqe_prev</code>和 <code>tqh_last</code> 为什么是二级指针，换成一级指针行不行？</p>
<p>肯定不行，如果它的前面是头节点怎么办，头节点的定义里面没有 <code>struct entry</code> 结构体类型啊！再仔细看看，不管是头节点还是普通节点，都有 <code>struct entry*</code> 结构体指针类型，那就定义一个类型为 <code>struct entry**</code> 的变量好了。这样前插的时候就可以统一处理了，例子见 TAILQ_INSERT_BEFORE。</p>
<h2 id="数据结构宏定义 -v4">数据结构宏定义</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Tail queue definitions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// TAILQ 头节点，其中 qual=qualifier，用于修饰限定 type，如 qual=const</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TAILQ_HEAD(name, type, qual)                              \</span></span><br><span class="line"><span class="meta">    struct name &#123;                                                  \</span></span><br><span class="line"><span class="meta">        qual type* tqh_first;      <span class="comment">/* first element */</span>             \</span></span><br><span class="line"><span class="meta">        qual type* qual* tqh_last; <span class="comment">/* addr of last next element */</span> \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_HEAD(name, type) _TAILQ_HEAD(name, struct type,)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_HEAD_INITIALIZER(head) \</span></span><br><span class="line"><span class="meta">    &#123; NULL, &amp;(head).tqh_first &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TAILQ 节点，qual 用于修饰限定 type 和二级指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TAILQ_ENTRY(type, qual)                                          \</span></span><br><span class="line"><span class="meta">    struct &#123;                                                              \</span></span><br><span class="line"><span class="meta">        qual type* tqe_next;       <span class="comment">/* next element */</span>                     \</span></span><br><span class="line"><span class="meta">        qual type* qual* tqe_prev; <span class="comment">/* address of previous next element */</span> \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_ENTRY(type) _TAILQ_ENTRY(struct type,)</span></span><br></pre></td></tr></table></figure>
<h2 id="操作函数宏定义 -v4">操作函数宏定义</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Tail queue functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// TAILQ 头节点初始化，初始化时头节点中的二级指针 tqh_last 指向 tqh_first 成员变量的地址 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_INIT(head)                       \</span></span><br><span class="line"><span class="meta">    do &#123;                                       \</span></span><br><span class="line"><span class="meta">        (head)-&gt;tqh_first = NULL;              \</span></span><br><span class="line"><span class="meta">        (head)-&gt;tqh_last = &amp;(head)-&gt;tqh_first; \</span></span><br><span class="line"><span class="meta">    &#125; while (<span class="comment">/*CONSTCOND*/</span> 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在头节点 head 前插入新节点 elm，并更新头节点</span></span><br><span class="line"><span class="comment">    1. 将新节点的 tqe_next 指向头节点的 tqh_first 指向的首节点</span></span><br><span class="line"><span class="comment">    2. 如果首节点非空，则将原首节点的 tqe_prev 指向新节点 elm 的 tqe_next 成员变量的地址</span></span><br><span class="line"><span class="comment">    3. 否则（首节点为空），则【更新尾指针 tqh_last 指向新节点 elm 的 tqe_next 成员变量的地址】</span></span><br><span class="line"><span class="comment">    4. 更新头节点的 tqh_first 指向新节点 elm</span></span><br><span class="line"><span class="comment">    5. 更新新节点 elm 的 tqe_prev 指向头节点的 tqh_first 成员变量的地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_INSERT_HEAD(head, elm, field)                             \</span></span><br><span class="line"><span class="meta">    do &#123;                                                                \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (((elm)-&gt;field.tqe_next = (head)-&gt;tqh_first) != NULL)        \</span></span><br><span class="line"><span class="meta">            (head)-&gt;tqh_first-&gt;field.tqe_prev = &amp;(elm)-&gt;field.tqe_next; \</span></span><br><span class="line"><span class="meta">        <span class="keyword">else</span>                                                            \</span></span><br><span class="line"><span class="meta">            (head)-&gt;tqh_last = &amp;(elm)-&gt;field.tqe_next;                  \</span></span><br><span class="line"><span class="meta">        (head)-&gt;tqh_first = (elm);                                      \</span></span><br><span class="line"><span class="meta">        (elm)-&gt;field.tqe_prev = &amp;(head)-&gt;tqh_first;                     \</span></span><br><span class="line"><span class="meta">    &#125; while (<span class="comment">/*CONSTCOND*/</span> 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在尾节点（通过 head 获取尾节点的 tqe_next 地址）后插入新节点 elm</span></span><br><span class="line"><span class="comment">    1. 将作为尾节点的新节点 elm 的 tqe_next 置 NULL</span></span><br><span class="line"><span class="comment">    2. 将作为尾节点的新节点 elm 的 tqe_prev 指向原尾节点的 tqe_next 成员的地址（通过(head)-&gt;tqh_last 获取）</span></span><br><span class="line"><span class="comment">    3. 将原尾节点作为新尾节点 elm 的前一个节点（将原尾节点指向新尾节点 elm）</span></span><br><span class="line"><span class="comment">    4. 更新头节点中指向尾节点的 tqe_next 成员地址的二级指针 tqh_last</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_INSERT_TAIL(head, elm, field)        \</span></span><br><span class="line"><span class="meta">    do &#123;                                           \</span></span><br><span class="line"><span class="meta">        (elm)-&gt;field.tqe_next = NULL;              \</span></span><br><span class="line"><span class="meta">        (elm)-&gt;field.tqe_prev = (head)-&gt;tqh_last;  \</span></span><br><span class="line"><span class="meta">        *(head)-&gt;tqh_last = (elm);                 \</span></span><br><span class="line"><span class="meta">        (head)-&gt;tqh_last = &amp;(elm)-&gt;field.tqe_next; \</span></span><br><span class="line"><span class="meta">    &#125; while (<span class="comment">/*CONSTCOND*/</span> 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在节点 listelm 后插入新节点 elm，如果是在尾节点后插入，则更新头节点的 tqh_last 成员地址</span></span><br><span class="line"><span class="comment">    1. 更新新节点 elm 的 tqe_next 为节点 listelm 的 tqe_next，即插入</span></span><br><span class="line"><span class="comment">    2. 如果更新后新节点 elm 的 tqe_next 不为空：</span></span><br><span class="line"><span class="comment">        则不是在尾节点后插入，更新节点 listelm 的原下一个节点的 tqe_prev 成员值为新节点 elm 的 tqe_next 成员地址</span></span><br><span class="line"><span class="comment">        否则，是在尾节点后插入，则更新头节点的 tqh_last 成员地址为新节点 elm(尾节点) 的 tqe_next 成员地址</span></span><br><span class="line"><span class="comment">    3. 将节点 listelm 指向新节点 elm</span></span><br><span class="line"><span class="comment">    4. 将新节点的 tqe_prev 成员值指向节点 listelm 的 tqe_next 成员地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_INSERT_AFTER(head, listelm, elm, field)                       \</span></span><br><span class="line"><span class="meta">    do &#123;                                                                    \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (((elm)-&gt;field.tqe_next = (listelm)-&gt;field.tqe_next) != NULL)    \</span></span><br><span class="line"><span class="meta">            (elm)-&gt;field.tqe_next-&gt;field.tqe_prev = &amp;(elm)-&gt;field.tqe_next; \</span></span><br><span class="line"><span class="meta">        <span class="keyword">else</span>                                                                \</span></span><br><span class="line"><span class="meta">            (head)-&gt;tqh_last = &amp;(elm)-&gt;field.tqe_next;                      \</span></span><br><span class="line"><span class="meta">        (listelm)-&gt;field.tqe_next = (elm);                                  \</span></span><br><span class="line"><span class="meta">        (elm)-&gt;field.tqe_prev = &amp;(listelm)-&gt;field.tqe_next;                 \</span></span><br><span class="line"><span class="meta">    &#125; while (<span class="comment">/*CONSTCOND*/</span> 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在节点 listelm 前插入新节点 elm，不涉及更新头节点的成员信息</span></span><br><span class="line"><span class="comment">    1. 更新新节点的 tqe_prev 为节点 listelm 的 tqe_prev</span></span><br><span class="line"><span class="comment">    2. 将新节点的 tqe_next 指向节点 listelm</span></span><br><span class="line"><span class="comment">    3. 将节点 listelm 的前一个节点指向新节点 elm：</span></span><br><span class="line"><span class="comment">        a) 解引用 *(listelm)-&gt;field.tqe_prev，即节点 listelm 的前一个节点的 tqe_next 地址，指向新节点 elm</span></span><br><span class="line"><span class="comment">        b) 如果节点 listelm 是首节点呢? 解引用获取到的就是头节点 head 的 tqh_first 地址，其指向新节点 elm</span></span><br><span class="line"><span class="comment">    4. 更新节点 listelm 的 tqe_prev 成员值为新插入节点 elm 的 tqe_next 成员地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_INSERT_BEFORE(listelm, elm, field)            \</span></span><br><span class="line"><span class="meta">    do &#123;                                                    \</span></span><br><span class="line"><span class="meta">        (elm)-&gt;field.tqe_prev = (listelm)-&gt;field.tqe_prev;  \</span></span><br><span class="line"><span class="meta">        (elm)-&gt;field.tqe_next = (listelm);                  \</span></span><br><span class="line"><span class="meta">        *(listelm)-&gt;field.tqe_prev = (elm);                 \</span></span><br><span class="line"><span class="meta">        (listelm)-&gt;field.tqe_prev = &amp;(elm)-&gt;field.tqe_next; \</span></span><br><span class="line"><span class="meta">    &#125; while (<span class="comment">/*CONSTCOND*/</span> 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 移除节点 elm，如果移除的是首 / 尾节点，则需要更新头节点的 tqh_first/tqh_last 地址</span></span><br><span class="line"><span class="comment">    1. 判断待移除的节点 elm 的 tqe_next 是否为空：</span></span><br><span class="line"><span class="comment">        不为空，则不是尾节点：更新节点 elm 的下一个节点的 tqe_prev 值为节点 elm 的 tqe_prev 值</span></span><br><span class="line"><span class="comment">        为空，则是尾结点：更新头节点的 tqh_last 值为节点 elm 的 tqe_prev 值</span></span><br><span class="line"><span class="comment">    2. 通过解引用修改待移除节点 elm 的前一个节点的值，从而将其指向待移除节点 elm 的下一个节点</span></span><br><span class="line"><span class="comment">        解引用前的前一个节点的地址：可能是前一个普通节点的 tqe_next 地址，也可能是头节点的 tqh_first 地址；</span></span><br><span class="line"><span class="comment">        通过解引用修改变量地址下的值，从而将其指向正确的节点（待移除节点 elm 的下一个节点）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_REMOVE(head, elm, field)                                     \</span></span><br><span class="line"><span class="meta">    do &#123;                                                                   \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (((elm)-&gt;field.tqe_next) != NULL)                               \</span></span><br><span class="line"><span class="meta">            (elm)-&gt;field.tqe_next-&gt;field.tqe_prev = (elm)-&gt;field.tqe_prev; \</span></span><br><span class="line"><span class="meta">        <span class="keyword">else</span>                                                               \</span></span><br><span class="line"><span class="meta">            (head)-&gt;tqh_last = (elm)-&gt;field.tqe_prev;                      \</span></span><br><span class="line"><span class="meta">        *(elm)-&gt;field.tqe_prev = (elm)-&gt;field.tqe_next;                    \</span></span><br><span class="line"><span class="meta">    &#125; while (<span class="comment">/*CONSTCOND*/</span> 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正向遍历，从头节点 head 指向的首节点开始遍历队列，依次将每个节点分配给 var，通过判断 var 是否为 NULL 决定是否遍历完成</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_FOREACH(var, head, field) for ((var) = ((head)-&gt;tqh_first); (var); (var) = ((var)-&gt;field.tqe_next))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反向遍历，参考 TAILQ_LAST 和 TAILQ_PREV</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_FOREACH_REVERSE(var, head, headname, field) for ((var) = (*(((struct headname*)((head)-&gt;tqh_last))-&gt;tqh_last)); (var); (var) = (*(((struct headname*)((var)-&gt;field.tqe_prev))-&gt;tqh_last)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_CONCAT(head1, head2, field)                           \</span></span><br><span class="line"><span class="meta">    do &#123;                                                            \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!TAILQ_EMPTY(head2)) &#123;                                  \</span></span><br><span class="line"><span class="meta">            *(head1)-&gt;tqh_last = (head2)-&gt;tqh_first;                \</span></span><br><span class="line"><span class="meta">            (head2)-&gt;tqh_first-&gt;field.tqe_prev = (head1)-&gt;tqh_last; \</span></span><br><span class="line"><span class="meta">            (head1)-&gt;tqh_last = (head2)-&gt;tqh_last;                  \</span></span><br><span class="line"><span class="meta">            TAILQ_INIT((head2));                                    \</span></span><br><span class="line"><span class="meta">        &#125;                                                           \</span></span><br><span class="line"><span class="meta">    &#125; while (<span class="comment">/*CONSTCOND*/</span> 0)</span></span><br></pre></td></tr></table></figure>
<h2 id="访问宏定义 -v4">访问宏定义</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Tail queue access methods.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_EMPTY(head) ((head)-&gt;tqh_first == NULL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_FIRST(head) ((head)-&gt;tqh_first)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_NEXT(elm, field) ((elm)-&gt;field.tqe_next)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_LAST(head, headname) (*(((struct headname*)((head)-&gt;tqh_last))-&gt;tqh_last))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_PREV(elm, headname, field) (*(((struct headname*)((elm)-&gt;field.tqe_prev))-&gt;tqh_last))</span></span><br></pre></td></tr></table></figure>
<h3 id="TAILQ-LAST">TAILQ_LAST</h3>
<p>TAILQ_LAST 可以获取尾节点的结构体首地址（不是尾节点的 tqe_next 成员地址），它是如何获取到的？</p>
<p><code>(head)-&gt;tqh_last</code> 是最后一个节点的 <code>entries.tqe_next</code> 成员的地址，可是这个地址不是用户想要的，用户要的是节点的地址（结构体的首地址），所以只好曲线救国，请看《各种结构指向图》小节的 TAILQ，从 1 到 2 再到 3。</p>
<p>从 <code>entries.tqe_next</code> 的地址怎么得到 <code>entries.tqe_prev</code> 的值呢（目的是为了得到倒数第二个节点的 <code>entries.tqe_next</code>）？</p>
<p>其实也不难，虽然 <code>struct entry</code> 里面 <code>entries</code> 这个结构体变量没有标签，但是 <strong> 它的元素构成和 <code>struct headname</code> 完全一样</strong>，都是一个 <code>struct entry*</code> 和一个 <code>struct entry**</code>，所以可以把 <code>entries.tqe_next</code> 的地址强制转换为 <code>(struct headname *)</code> 类型：</p>
<p><code>(struct headname *)((head)-&gt;tqh_last)</code></p>
<p>然后访问它的 <code>tqh_last</code> 成员（也就是图中尾节点的 <code>tqe_prev</code>）：</p>
<p><code>((struct headname *)((head)-&gt;tqh_last))-&gt;tqh_last</code></p>
<p>这样就得到了前一个节点的 <code>entries.tqe_next</code> 的地址，再对它解引用：</p>
<p><code>*(((struct headname *)((head)-&gt;tqh_last))-&gt;tqh_last)</code></p>
<p>就得到了 <code>entries.tqe_next</code> 变量，这恰好是大结构体（ struct entry ）的首地址。</p>
<h3 id="TAILQ-PREV">TAILQ_PREV</h3>
<p>我们再看 TAILQ_PREV 这个宏，道理类似。请看《各种结构指向图》小节的 TAILQ，从 a 到 b 再到 c。</p>
<p>设当前节点的地址是 <code>elm</code>（图中用最后这个节点来示意），<code>(elm)-&gt;field.tqe_prev</code>，表示顺着 a，得到它前面那个节点的 <code>tqe_next</code> 成员的地址，对这个地址强制转换为 <code>struct headname *</code>，即</p>
<p><code>(struct headname *)((elm)-&gt;field.tqe_prev)</code></p>
<p>再通过访问 <code>tqh_last</code>（等效于访问 <code>tqe_prev</code>），也就是顺着 b，得到了 <code>elm</code> 前面的前面的节点的 <code>tqe_next</code> 地址，即</p>
<p><code>((struct headname *)((elm)-&gt;field.tqe_prev))-&gt;tqh_last</code></p>
<p>对它解引用，就得到 <code>elm</code> 前面的前面的节点的 <code>tqe_next</code>，它刚好是 c 指向的 <code>elm</code>前面的结构体的首地址。</p>
<p><code>*(((struct headname *)((elm)-&gt;field.tqe_prev))-&gt;tqh_last)</code></p>
<h2 id="示例代码 -v4">示例代码</h2>
<p>示例代码来自：<a href="https://man7.org/linux/man-pages/man3/tailq.3.html">man-pages</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/queue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entry</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    TAILQ_ENTRY(entry) entries; <span class="comment">/* Tail queue */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TAILQ_HEAD(tailhead, entry);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">n1</span>, *<span class="title">n2</span>, *<span class="title">n3</span>, *<span class="title">np</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tailhead</span> <span class="title">head</span>;</span> <span class="comment">/* Tail queue head */</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    TAILQ_INIT(&amp;head); <span class="comment">/* Initialize the queue */</span></span><br><span class="line"></span><br><span class="line">    n1 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> entry)); <span class="comment">/* Insert at the head */</span></span><br><span class="line">    n1-&gt;data = <span class="number">20</span>;</span><br><span class="line">    TAILQ_INSERT_HEAD(&amp;head, n1, entries);  <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">    n1 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> entry)); <span class="comment">/* Insert at the tail */</span></span><br><span class="line">    n1-&gt;data = <span class="number">30</span>;</span><br><span class="line">    TAILQ_INSERT_TAIL(&amp;head, n1, entries);  <span class="comment">// 20 30</span></span><br><span class="line"></span><br><span class="line">    n2 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> entry)); <span class="comment">/* Insert after */</span></span><br><span class="line">    n2-&gt;data = <span class="number">40</span>;</span><br><span class="line">    TAILQ_INSERT_AFTER(&amp;head, n1, n2, entries);  <span class="comment">// 20 30 40</span></span><br><span class="line"></span><br><span class="line">    n3 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> entry)); <span class="comment">/* Insert before */</span></span><br><span class="line">    n3-&gt;data = <span class="number">50</span>;</span><br><span class="line">    TAILQ_INSERT_BEFORE(n2, n3, entries);  <span class="comment">// 20 30 50 40</span></span><br><span class="line"></span><br><span class="line">    TAILQ_REMOVE(&amp;head, n2, entries); <span class="comment">/* Deletion */</span></span><br><span class="line">    <span class="built_in">free</span>(n2);</span><br><span class="line">    <span class="comment">/* Forward traversal */</span></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    TAILQ_FOREACH(np, &amp;head, entries) &#123;</span><br><span class="line">        np-&gt;data = np-&gt;data + (i++);</span><br><span class="line">    &#125;  <span class="comment">// 20 31 52</span></span><br><span class="line">    <span class="comment">/* Reverse traversal */</span></span><br><span class="line">    TAILQ_FOREACH_REVERSE(np, &amp;head, tailhead, entries) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%i &quot;</span>, np-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);  <span class="comment">// 52 31 20</span></span><br><span class="line">    <span class="comment">/* TailQ deletion */</span></span><br><span class="line">    n1 = TAILQ_FIRST(&amp;head);</span><br><span class="line">    <span class="keyword">while</span> (n1 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        n2 = TAILQ_NEXT(n1, entries);</span><br><span class="line">        <span class="built_in">free</span>(n1);</span><br><span class="line">        n1 = n2;</span><br><span class="line">    &#125;</span><br><span class="line">    TAILQ_INIT(&amp;head);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考资料</p>
<ol>
<li><a href="https://www.cnblogs.com/fuzidage/p/14482501.html">https://www.cnblogs.com/fuzidage/p/14482501.html</a></li>
<li><a href="https://blog.csdn.net/ET_Endeavoring/article/details/121609082">https://blog.csdn.net/ET_Endeavoring/article/details/121609082</a></li>
<li>SLIT: <a href="https://blog.csdn.net/longintchar/article/details/122907350">https://blog.csdn.net/longintchar/article/details/122907350</a></li>
<li>STAILQ: <a href="https://blog.csdn.net/longintchar/article/details/122907478">https://blog.csdn.net/longintchar/article/details/122907478</a></li>
<li>TAILQ: <a href="https://blog.csdn.net/longintchar/article/details/122907708">https://blog.csdn.net/longintchar/article/details/122907708</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>队列</tag>
        <tag>Linux</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 文件系统 tinyfs 实现</title>
    <url>/posts/241119182636.html</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="tinyfs 设计">tinyfs 设计</h1>
<h2 id="数据结构">数据结构</h2>
<p>定义文件名长度、文件数量、块大小等。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NAMELEN (32)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_FILES (32)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_FILEBYTES (512)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TINYFS_MAGIC (0x20231118)</span></span><br></pre></td></tr></table></figure>
<p>定义目录项格式：目录是由许多“文件”的文件名 -inode 值构成的列表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义每一个目录项的格式</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_dir_entry</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> filename[MAX_NAMELEN];</span><br><span class="line">    <span class="type">uint8_t</span> idx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定义一个目录项下最多存放多少个文件：由数据块大小除以每个目录数据占用的空间计算得出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_DENTRY_NR (MAX_FILEBYTES / sizeof(struct tinyfs_dir_entry))</span></span><br></pre></td></tr></table></figure>
<p>定义每一个“文件”的格式：由元数据和数据部分构成。其中数据部分采用柔性数组，在创建“文件”时一并申请元数据和数据部分的内存空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义每一个文件的格式</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_file_blk</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> busy;  <span class="comment">// 块是否被占用</span></span><br><span class="line">    <span class="type">mode_t</span> mode;   <span class="comment">// 文件模式</span></span><br><span class="line">    <span class="type">uint8_t</span> idx;   <span class="comment">// 块索引</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">uint8_t</span> file_size;     <span class="comment">// 文件大小</span></span><br><span class="line">        <span class="type">uint8_t</span> dir_children;  <span class="comment">// 目录下的文件数量</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据部分，单个文件支持最大 MAX_FILEBYTES 字节</span></span><br><span class="line">    <span class="comment">// 若是目录则可存储 MAX_DENTRY_NR 个目录项</span></span><br><span class="line">    <span class="type">char</span> data[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/images/linux-kernel/filesystem/tinyfs-arch.png" alt="虚拟文件系统 tinyfs 磁盘（内存）组织结构" width="80%" height="80%">
<h2 id="接口实现">接口实现</h2>
<h3 id="全局变量与公共接口">全局变量与公共接口</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟磁盘的内存空间，在创建文件时搜索一个可用的块位置并申请块资源</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_file_blk</span>* <span class="title">disk</span>[<span class="title">MAX_FILES</span> + 1];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前已创建文件的数量</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> files_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化磁盘空间，所有块位置都可用</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_disk</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_FILES; i++) &#123;</span><br><span class="line">        disk[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配新的块，并初始化一些参数</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> tinyfs_file_blk* <span class="title function_">alloc_block</span><span class="params">(<span class="type">uint8_t</span> idx, <span class="type">mode_t</span> mode)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_file_blk</span>* <span class="title">blk</span> =</span> kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> tinyfs_file_blk) + MAX_FILEBYTES, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!blk)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    blk-&gt;busy = <span class="number">1</span>;</span><br><span class="line">    blk-&gt;mode = mode;</span><br><span class="line">    blk-&gt;idx = idx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (S_ISDIR(mode))</span><br><span class="line">        blk-&gt;dir_children = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        blk-&gt;file_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据部分占用的空间</span></span><br><span class="line">    <span class="built_in">memset</span>(blk-&gt;data, <span class="number">0</span>, MAX_FILEBYTES);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> blk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="文件系统注册与注销">文件系统注册与注销</h3>
<p>注册时指定文件系统类型，其中除 fs 的名字外、还有挂载和卸载的钩子函数。注销时，要释放所有“文件”的磁盘资源（这里是内存资源）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件系统类型定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">tinyfs_fs_type</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .name = <span class="string">&quot;tinyfs&quot;</span>,</span><br><span class="line">    .mount = tinyfs_mount,</span><br><span class="line">    .kill_sb = tinyfs_kill_superblock,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件系统初始化</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tinyfs_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    init_disk();</span><br><span class="line"></span><br><span class="line">    ret = register_filesystem(&amp;tinyfs_fs_type);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        pr_err(<span class="string">&quot;Register tinyfs failed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;tinyfs loaded\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件系统退出</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tinyfs_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    unregister_filesystem(&amp;tinyfs_fs_type);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; MAX_FILES + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (disk[i]) &#123;</span><br><span class="line">            kfree(disk[i]);</span><br><span class="line">            disk[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;tinyfs unloaded\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(tinyfs_init);</span><br><span class="line">module_exit(tinyfs_exit);</span><br></pre></td></tr></table></figure>
<h3 id="挂载文件系统">挂载文件系统</h3>
<p>挂载文件系统：<code>mount -t tinyfs none /mnt/tinyfs</code>。通过 mount_nodev 函数申请 super block 资源，并使用指定的钩子函数 tinyfs_fill_super 初始化它，并与 tinyfs 的私有数据部分相关联。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件系统的挂载和初始化：从已申请的 sb 资源中申请 root inode 并初始化，以及持久化根目录内容到硬盘</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tinyfs_fill_super</span><span class="params">(<span class="keyword">struct</span> super_block* sb, <span class="type">void</span>* data, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">root_inode</span>;</span></span><br><span class="line">    <span class="type">int</span> mode = S_IFDIR | <span class="number">0755</span>;</span><br><span class="line"></span><br><span class="line">    sb-&gt;s_magic = TINYFS_MAGIC;</span><br><span class="line">    sb-&gt;s_op = &amp;tinyfs_super_operations;</span><br><span class="line"></span><br><span class="line">    root_inode = new_inode(sb);</span><br><span class="line">    <span class="keyword">if</span> (!root_inode) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Failed to create root inode\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Init uid, gid, mode for new inode according to posix standards</span></span><br><span class="line">    inode_init_owner(&amp;nop_mnt_idmap, root_inode, <span class="literal">NULL</span>, mode);</span><br><span class="line">    root_inode-&gt;i_ino = <span class="number">1</span>;  <span class="comment">// 根目录的 inode 编号为 1</span></span><br><span class="line">    root_inode-&gt;i_sb = sb;</span><br><span class="line">    root_inode-&gt;i_op = &amp;tinyfs_inode_ops;</span><br><span class="line">    root_inode-&gt;i_fop = &amp;tinyfs_dir_operations;</span><br><span class="line">    root_inode-&gt;__i_atime = root_inode-&gt;__i_mtime = root_inode-&gt;__i_ctime = current_time(root_inode);</span><br><span class="line"></span><br><span class="line">    sb-&gt;s_root = d_make_root(root_inode);  <span class="comment">// 创建文件系统的 dentry 根目录</span></span><br><span class="line">    <span class="keyword">if</span> (!sb-&gt;s_root) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Failed to create root dentry\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    files_count++;  <span class="comment">// 更新文件计数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂载的根目录的目录内容初始化</span></span><br><span class="line">    disk[<span class="number">1</span>] = alloc_block(<span class="number">1</span>, mode);</span><br><span class="line">    <span class="keyword">if</span> (!disk[<span class="number">1</span>]) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Failed to alloc a disk block space\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    root_inode-&gt;i_private = disk[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;tinyfs mounted successfully\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂载文件系统：mount -t tinyfs none /mnt/tinyfs</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> dentry* <span class="title function_">tinyfs_mount</span><span class="params">(<span class="keyword">struct</span> file_system_type* fs_type, <span class="type">int</span> flags, <span class="type">const</span> <span class="type">char</span>* dev_name, <span class="type">void</span>* data)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * mount_nodev() 用于挂载一个没有设备文件（即设备为空）或者说是虚拟文件系统的文件系统</span></span><br><span class="line"><span class="comment">     * 函数内，主要是通过 sget() 分配一个超级块 s，然后使用钩子函数 tinyfs_fill_super() 来初始化超级块的一些数据</span></span><br><span class="line"><span class="comment">     * error = tinyfs_fill_super(s, data, flags &amp; SB_SILENT ? 1 : 0);</span></span><br><span class="line"><span class="comment">     * 在初始化成功后，通过 dget(s-&gt;s_root) 增加文件系统的根目录项的引用计数，并返回根目录项</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> mount_nodev(fs_type, flags, data, tinyfs_fill_super);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="卸载文件系统">卸载文件系统</h3>
<p>销毁文件系统：<code>umount /mnt/tinyfs</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 销毁文件系统：umount /mnt/tinyfs</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tinyfs_kill_superblock</span><span class="params">(<span class="keyword">struct</span> super_block* sb)</span> &#123;</span><br><span class="line">    kill_anon_super(sb);</span><br><span class="line">    pr_info(<span class="string">&quot;tinyfs unmounted and resources cleaned up\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="file 操作方法实现">file 操作方法实现</h3>
<p>通过 tinyfs_file_operations 变量初始化 file 的操作方法（这里是文件读、写接口）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件操作结构体，包含了 read 和 write 方法</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">tinyfs_file_operations</span> =</span> &#123;</span><br><span class="line">    .read = tinyfs_file_read,</span><br><span class="line">    .write = tinyfs_file_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入文件的实现：ssize_t write(int fd, const void buf[.count], size_t count);</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">tinyfs_file_write</span><span class="params">(<span class="keyword">struct</span> file* filp, <span class="type">const</span> <span class="type">char</span> __user* buf, <span class="type">size_t</span> len, <span class="type">loff_t</span>* ppos)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_file_blk</span>* <span class="title">blk</span>;</span></span><br><span class="line">    <span class="type">char</span>* buffer;</span><br><span class="line"></span><br><span class="line">    blk = filp-&gt;f_path.dentry-&gt;d_inode-&gt;i_private;  <span class="comment">// 获取文件块</span></span><br><span class="line">    <span class="keyword">if</span> (!blk) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Null pointer\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buffer = (<span class="type">char</span>*)&amp;blk-&gt;data[<span class="number">0</span>];</span><br><span class="line">    buffer += *ppos;  <span class="comment">// 将指针指向当前偏移位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入的长度不能超过文件的剩余数据空间</span></span><br><span class="line">    len = min(MAX_FILEBYTES - (<span class="type">size_t</span>)blk-&gt;file_size, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(buffer, buf, len)) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Failed to copy data from user to kernel\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    *ppos += len;            <span class="comment">// 更新文件偏移量</span></span><br><span class="line">    blk-&gt;file_size = *ppos;  <span class="comment">// 更新文件大小</span></span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;Written %zu bytes to file, total %lld bytes\n&quot;</span>, len, *ppos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件的实现：ssize_t read(int fd, void buf[.count], size_t count);</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">tinyfs_file_read</span><span class="params">(<span class="keyword">struct</span> file* filp, <span class="type">char</span> __user* buf, <span class="type">size_t</span> len, <span class="type">loff_t</span>* ppos)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_file_blk</span>* <span class="title">blk</span>;</span></span><br><span class="line">    <span class="type">char</span>* buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文件块</span></span><br><span class="line">    blk = (<span class="keyword">struct</span> tinyfs_file_blk*)filp-&gt;f_path.dentry-&gt;d_inode-&gt;i_private;</span><br><span class="line">    <span class="keyword">if</span> (!blk) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Null pointer\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前偏移量超过文件大小，返回 0</span></span><br><span class="line">    <span class="keyword">if</span> (*ppos &gt; blk-&gt;file_size) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Failed to read, end of file reached: ppos=%lld, file_size=%d\n&quot;</span>, *ppos, blk-&gt;file_size);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取的长度不能超过文件的大小</span></span><br><span class="line">    len = min((<span class="type">size_t</span>)blk-&gt;file_size, len);</span><br><span class="line"></span><br><span class="line">    buffer = (<span class="type">char</span>*)&amp;blk-&gt;data[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, buffer, len)) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Failed to copy data from kernel to user\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    *ppos += len;  <span class="comment">// 更新文件偏移量</span></span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;Read successful: ppos=%lld, len=%zu\n&quot;</span>, *ppos, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="目录文件操作方法实现">目录文件操作方法实现</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目录操作结构体，包含了 readdir(iterate_shared) 方法</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">tinyfs_dir_operations</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .iterate_shared = tinyfs_iterate,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取目录的实现：遍历目录中的所有文件</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tinyfs_iterate</span><span class="params">(<span class="keyword">struct</span> file* filp, <span class="keyword">struct</span> dir_context* ctx)</span> &#123;</span><br><span class="line">    <span class="type">loff_t</span> pos;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_file_blk</span>* <span class="title">blk</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_dir_entry</span>* <span class="title">entry</span>;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前文件的位置，如果文件指针已经不在起始位置，说明已经读取完</span></span><br><span class="line">    pos = filp-&gt;f_pos;</span><br><span class="line">    <span class="keyword">if</span> (pos)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前目录块的私有数据</span></span><br><span class="line">    blk = (<span class="keyword">struct</span> tinyfs_file_blk*)filp-&gt;f_path.dentry-&gt;d_inode-&gt;i_private;</span><br><span class="line">    <span class="keyword">if</span> (!blk) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Null pointer\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前块不是目录，返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (!S_ISDIR(blk-&gt;mode)) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Not a directory block\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOTDIR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历目录中的所有文件</span></span><br><span class="line">    entry = (<span class="keyword">struct</span> tinyfs_dir_entry*)&amp;blk-&gt;data[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; blk-&gt;dir_children; i++) &#123;</span><br><span class="line">        pr_info(<span class="string">&quot;Reading entry %d-th: %s\n&quot;</span>, i + <span class="number">1</span>, entry[i].filename);</span><br><span class="line">        <span class="comment">// 在目录列表中将目录条目（文件名和元数据）填充到目录缓冲区中</span></span><br><span class="line">        dir_emit(ctx, entry[i].filename, strnlen(entry[i].filename, MAX_NAMELEN), entry[i].idx, DT_UNKNOWN);</span><br><span class="line">        ctx-&gt;pos++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="inode 操作方法实现">inode 操作方法实现</h3>
<p>通过 tinyfs_inode_ops 变量初始化 inode 的操作方法（这里是创建文件、删除文件、创建目录、删除目录、查找“文件”）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// inode 操作集，包含文件和目录的操作</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> <span class="title">tinyfs_inode_ops</span> =</span> &#123;</span><br><span class="line">    .create = tinyfs_create,</span><br><span class="line">    .unlink = tinyfs_unlink,</span><br><span class="line">    .mkdir = tinyfs_mkdir,</span><br><span class="line">    .rmdir = tinyfs_rmdir,</span><br><span class="line">    .lookup = tinyfs_lookup,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建文件或目录的实现</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tinyfs_do_create</span><span class="params">(<span class="keyword">struct</span> inode* dir, <span class="keyword">struct</span> dentry* dentry, <span class="type">umode_t</span> mode)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">inode</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>* <span class="title">sb</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_dir_entry</span>* <span class="title">entry</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_file_blk</span> *<span class="title">blk</span>, *<span class="title">pblk</span>;</span></span><br><span class="line">    <span class="type">int</span> idx = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    sb = dir-&gt;i_sb;</span><br><span class="line">    <span class="keyword">if</span> (!sb) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Null pointer\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到一个空闲块位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; MAX_FILES + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!disk[i]) &#123;</span><br><span class="line">            idx = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (files_count &gt;= MAX_FILES || <span class="number">-1</span> == idx) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;No space left to create file or directory\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOSPC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果模式既不是目录也不是文件，返回无效参数错误</span></span><br><span class="line">    <span class="keyword">if</span> (!S_ISDIR(mode) &amp;&amp; !S_ISREG(mode)) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Invalid mode (%u): neither directory nor file\n&quot;</span>, mode);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在找到的空闲块处分配块资源</span></span><br><span class="line">    disk[idx] = alloc_block(idx, mode);</span><br><span class="line">    <span class="keyword">if</span> (!disk[idx]) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Failed to alloc a disk block space\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inode = new_inode(sb);</span><br><span class="line">    <span class="keyword">if</span> (!inode) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Failed to create new inode\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    inode-&gt;i_ino = idx;</span><br><span class="line">    inode-&gt;i_sb = sb;</span><br><span class="line">    inode-&gt;i_op = &amp;tinyfs_inode_ops;</span><br><span class="line">    inode-&gt;__i_atime = inode-&gt;__i_mtime = inode-&gt;__i_ctime = current_time(inode);</span><br><span class="line"></span><br><span class="line">    blk = disk[idx];</span><br><span class="line">    blk-&gt;mode = mode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按目录或文件，初始化相应成员</span></span><br><span class="line">    <span class="keyword">if</span> (S_ISDIR(mode)) &#123;</span><br><span class="line">        blk-&gt;dir_children = <span class="number">0</span>;</span><br><span class="line">        inode-&gt;i_fop = &amp;tinyfs_dir_operations;</span><br><span class="line">        pr_info(<span class="string">&quot;Created directory: %s\n&quot;</span>, dentry-&gt;d_name.name);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISREG(mode)) &#123;</span><br><span class="line">        blk-&gt;file_size = <span class="number">0</span>;</span><br><span class="line">        inode-&gt;i_fop = &amp;tinyfs_file_operations;</span><br><span class="line">        pr_info(<span class="string">&quot;Created file: %s\n&quot;</span>, dentry-&gt;d_name.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂上 tinyfs 的私有数据块（第 idx 个 block）</span></span><br><span class="line">    inode-&gt;i_private = blk;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取目录对应的 tinyfs 的私有数据块</span></span><br><span class="line">    pblk = (<span class="keyword">struct</span> tinyfs_file_blk*)dir-&gt;i_private;</span><br><span class="line">    <span class="keyword">if</span> (pblk-&gt;dir_children + <span class="number">1</span> &gt; MAX_DENTRY_NR) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;No space left to save dir entry\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新创建的文件或目录加入到父目录的子目录列表中</span></span><br><span class="line">    entry = (<span class="keyword">struct</span> tinyfs_dir_entry*)&amp;pblk-&gt;data[<span class="number">0</span>];</span><br><span class="line">    entry += pblk-&gt;dir_children;  <span class="comment">// 跳过已存在的前 N 个孩子的内存，指到新孩子的存储位置</span></span><br><span class="line"></span><br><span class="line">    entry-&gt;idx = idx;</span><br><span class="line">    <span class="built_in">strncpy</span>(entry-&gt;filename, dentry-&gt;d_name.name, MAX_NAMELEN - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    pblk-&gt;dir_children++;  <span class="comment">// 孩子数量加一</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键步骤：初始化并将新 inode 的添加到 dentry，即将文件或目录记录在当前目录下</span></span><br><span class="line">    inode_init_owner(&amp;nop_mnt_idmap, inode, dir, mode);</span><br><span class="line">    d_add(dentry, inode);</span><br><span class="line"></span><br><span class="line">    files_count++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建目录的实现</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tinyfs_mkdir</span><span class="params">(<span class="keyword">struct</span> mnt_idmap* idmap, <span class="keyword">struct</span> inode* dir, <span class="keyword">struct</span> dentry* dentry, <span class="type">umode_t</span> mode)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tinyfs_do_create(dir, dentry, S_IFDIR | mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建文件的实现</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tinyfs_create</span><span class="params">(<span class="keyword">struct</span> mnt_idmap* idmap, <span class="keyword">struct</span> inode* dir, <span class="keyword">struct</span> dentry* dentry, <span class="type">umode_t</span> mode, <span class="type">bool</span> excl)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tinyfs_do_create(dir, dentry, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 sb 创建一个 inode 并初始化它</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode* <span class="title function_">tinyfs_iget</span><span class="params">(<span class="keyword">struct</span> super_block* sb, <span class="type">int</span> idx)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">inode</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_file_blk</span>* <span class="title">blk</span>;</span></span><br><span class="line"></span><br><span class="line">    blk = disk[idx];</span><br><span class="line">    <span class="keyword">if</span> (!blk) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Null pointer\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inode = new_inode(sb);</span><br><span class="line">    <span class="keyword">if</span> (!inode) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Failed to create a new inode\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inode-&gt;i_ino = idx;</span><br><span class="line">    inode-&gt;i_sb = sb;</span><br><span class="line">    inode-&gt;i_op = &amp;tinyfs_inode_ops;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (S_ISDIR(blk-&gt;mode))</span><br><span class="line">        inode-&gt;i_fop = &amp;tinyfs_dir_operations;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (S_ISREG(blk-&gt;mode))</span><br><span class="line">        inode-&gt;i_fop = &amp;tinyfs_file_operations;</span><br><span class="line"></span><br><span class="line">    inode-&gt;__i_atime = inode-&gt;__i_mtime = inode-&gt;__i_ctime = current_time(inode);</span><br><span class="line">    inode-&gt;i_private = blk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> dentry* <span class="title function_">tinyfs_lookup</span><span class="params">(<span class="keyword">struct</span> inode* parent_inode, <span class="keyword">struct</span> dentry* child_dentry, <span class="type">unsigned</span> <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>* <span class="title">sb</span> =</span> parent_inode-&gt;i_sb;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_file_blk</span>* <span class="title">blk</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_dir_entry</span>* <span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">    blk = (<span class="keyword">struct</span> tinyfs_file_blk*)parent_inode-&gt;i_private;</span><br><span class="line"></span><br><span class="line">    entry = (<span class="keyword">struct</span> tinyfs_dir_entry*)&amp;blk-&gt;data[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; blk-&gt;dir_children; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(entry[i].filename, child_dentry-&gt;d_name.name)) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">inode</span> =</span> tinyfs_iget(sb, entry[i].idx);</span><br><span class="line">            <span class="keyword">if</span> (!inode) &#123;</span><br><span class="line">                pr_err(<span class="string">&quot;Null pointer\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_file_blk</span>* <span class="title">inner</span> =</span> (<span class="keyword">struct</span> tinyfs_file_blk*)inode-&gt;i_private;</span><br><span class="line">            inode_init_owner(&amp;nop_mnt_idmap, inode, parent_inode, inner-&gt;mode);</span><br><span class="line">            d_add(child_dentry, inode);</span><br><span class="line">            pr_info(<span class="string">&quot;found dentry: %s\n&quot;</span>, child_dentry-&gt;d_name.name);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除目录的实现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tinyfs_rmdir</span><span class="params">(<span class="keyword">struct</span> inode* dir, <span class="keyword">struct</span> dentry* dentry)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">inode</span> =</span> dentry-&gt;d_inode;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_file_blk</span>* <span class="title">blk</span> =</span> (<span class="keyword">struct</span> tinyfs_file_blk*)inode-&gt;i_private;  <span class="comment">// 获取目录的磁盘块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_file_blk</span>* <span class="title">pblk</span> =</span> (<span class="keyword">struct</span> tinyfs_file_blk*)dir-&gt;i_private;   <span class="comment">// 获取父目录的磁盘块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_dir_entry</span>* <span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否为空目录</span></span><br><span class="line">    <span class="keyword">if</span> (blk-&gt;dir_children &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Cannot remove non-empty directory: %s\n&quot;</span>, dentry-&gt;d_name.name);</span><br><span class="line">        <span class="keyword">return</span> -ENOTEMPTY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从父目录中移除该目录的目录项</span></span><br><span class="line">    entry = (<span class="keyword">struct</span> tinyfs_dir_entry*)&amp;pblk-&gt;data[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pblk-&gt;dir_children; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(entry[i].filename, dentry-&gt;d_name.name)) &#123;  <span class="comment">// 找到该文件</span></span><br><span class="line">            <span class="comment">// 移动父目录中后续的目录项，覆盖当前的目录项</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; pblk-&gt;dir_children - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;entry[j], &amp;entry[j + <span class="number">1</span>], <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tinyfs_dir_entry));  <span class="comment">// 移动目录项</span></span><br><span class="line">            &#125;</span><br><span class="line">            pblk-&gt;dir_children--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放该文件的所有内存</span></span><br><span class="line">    disk[blk-&gt;idx] = <span class="literal">NULL</span>;</span><br><span class="line">    kfree(blk);</span><br><span class="line">    blk = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;Removed directory: %s\n&quot;</span>, dentry-&gt;d_name.name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> simple_rmdir(dir, dentry);  <span class="comment">// 调用 VFS 的 rmdir 实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除文件的实现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tinyfs_unlink</span><span class="params">(<span class="keyword">struct</span> inode* dir, <span class="keyword">struct</span> dentry* dentry)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">inode</span> =</span> dentry-&gt;d_inode;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_file_blk</span>* <span class="title">blk</span> =</span> (<span class="keyword">struct</span> tinyfs_file_blk*)inode-&gt;i_private;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_file_blk</span>* <span class="title">pblk</span> =</span> (<span class="keyword">struct</span> tinyfs_file_blk*)dir-&gt;i_private;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_dir_entry</span>* <span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新父目录的子目录列表，移除该文件的目录项</span></span><br><span class="line">    entry = (<span class="keyword">struct</span> tinyfs_dir_entry*)&amp;pblk-&gt;data[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pblk-&gt;dir_children; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(entry[i].filename, dentry-&gt;d_name.name)) &#123;  <span class="comment">// 找到该文件</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; pblk-&gt;dir_children - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;entry[j], &amp;entry[j + <span class="number">1</span>], <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tinyfs_dir_entry));  <span class="comment">// 移动目录项</span></span><br><span class="line">            &#125;</span><br><span class="line">            pblk-&gt;dir_children--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放该文件的所有内存</span></span><br><span class="line">    disk[blk-&gt;idx] = <span class="literal">NULL</span>;</span><br><span class="line">    kfree(blk);</span><br><span class="line">    blk = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;Removed file: %s\n&quot;</span>, dentry-&gt;d_name.name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> simple_unlink(dir, dentry);  <span class="comment">// 调用 VFS 的 unlink 实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关键梳理">关键梳理</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tinyfs_fill_super()</span></span><br><span class="line">root_inode-&gt;i_op = &amp;tinyfs_inode_ops;</span><br><span class="line">root_inode-&gt;i_fop = &amp;tinyfs_dir_operations;</span><br></pre></td></tr></table></figure>
<p>在挂载 tinyfs 文件系统时，在初始化的 super block 中指定了关于根目录的 inode 操作和根目录的目录 file 操作。这样就可以在挂载的根目录下，进行 <code>touch/mkdir/ls</code> 操作了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tinyfs_do_create()</span></span><br><span class="line">inode-&gt;i_op = &amp;tinyfs_inode_ops;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (S_ISDIR(mode)) &#123;</span><br><span class="line">    inode-&gt;i_fop = &amp;tinyfs_dir_operations;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISREG(mode)) &#123;</span><br><span class="line">    inode-&gt;i_fop = &amp;tinyfs_file_operations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 inode 的 .create 方法 tinyfs_do_create 中，指定了对于“文件”是目录还是文件的操作方法，这样在任意目录创建的文件就有了读、写操作；创建的目录就有了 <code>ls</code> 遍历操作。</p>
<h2 id="完整代码">完整代码</h2>
<p>注意，本套代码在 Linux 6.8 内核版本下运行与测试。代码中不乏诸多 BUG，如：</p>
<ol>
<li>删除非空目录</li>
<li>硬链接引用计数</li>
<li>ls 无法显示当前目录 <code>.</code> 和父目录 <code>..</code></li>
<li>读取文件时会显示两份数据</li>
<li>…</li>
</ol>
<h3 id="tinyfs-h">tinyfs.h</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NAMELEN (32)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_FILES (32)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_FILEBYTES (512)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TINYFS_MAGIC (0x20231118)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义每一个目录项的格式</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_dir_entry</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> filename[MAX_NAMELEN];</span><br><span class="line">    <span class="type">uint8_t</span> idx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_DENTRY_NR (MAX_FILEBYTES / sizeof(struct tinyfs_dir_entry))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义每一个文件的格式</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_file_blk</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> busy;  <span class="comment">// 块是否被占用</span></span><br><span class="line">    <span class="type">mode_t</span> mode;   <span class="comment">// 文件模式</span></span><br><span class="line">    <span class="type">uint8_t</span> idx;   <span class="comment">// 块索引</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">uint8_t</span> file_size;     <span class="comment">// 文件大小</span></span><br><span class="line">        <span class="type">uint8_t</span> dir_children;  <span class="comment">// 目录下的文件数量</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据部分，单个文件支持最大 MAX_FILEBYTES 字节</span></span><br><span class="line">    <span class="comment">// 若是目录则可存储 MAX_DENTRY_NR 个目录项</span></span><br><span class="line">    <span class="type">char</span> data[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="tinyfs-c">tinyfs.c</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tinyfs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tinyfs_iterate</span><span class="params">(<span class="keyword">struct</span> file* filp, <span class="keyword">struct</span> dir_context* ctx)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">tinyfs_file_read</span><span class="params">(<span class="keyword">struct</span> file* filp, <span class="type">char</span> __user* buf, <span class="type">size_t</span> len, <span class="type">loff_t</span>* ppos)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">tinyfs_file_write</span><span class="params">(<span class="keyword">struct</span> file* filp, <span class="type">const</span> <span class="type">char</span> __user* buf, <span class="type">size_t</span> len, <span class="type">loff_t</span>* ppos)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tinyfs_do_create</span><span class="params">(<span class="keyword">struct</span> inode* dir, <span class="keyword">struct</span> dentry* dentry, <span class="type">umode_t</span> mode)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tinyfs_mkdir</span><span class="params">(<span class="keyword">struct</span> mnt_idmap* idmap, <span class="keyword">struct</span> inode* dir, <span class="keyword">struct</span> dentry* dentry, <span class="type">umode_t</span> mode)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tinyfs_create</span><span class="params">(<span class="keyword">struct</span> mnt_idmap* idmap, <span class="keyword">struct</span> inode* dir, <span class="keyword">struct</span> dentry* dentry, <span class="type">umode_t</span> mode, <span class="type">bool</span> excl)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tinyfs_rmdir</span><span class="params">(<span class="keyword">struct</span> inode* dir, <span class="keyword">struct</span> dentry* dentry)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tinyfs_unlink</span><span class="params">(<span class="keyword">struct</span> inode* dir, <span class="keyword">struct</span> dentry* dentry)</span>;</span><br><span class="line"><span class="keyword">struct</span> dentry* <span class="title function_">tinyfs_lookup</span><span class="params">(<span class="keyword">struct</span> inode* parent_inode, <span class="keyword">struct</span> dentry* child_dentry, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> dentry* <span class="title function_">tinyfs_mount</span><span class="params">(<span class="keyword">struct</span> file_system_type* fs_type, <span class="type">int</span> flags, <span class="type">const</span> <span class="type">char</span>* dev_name, <span class="type">void</span>* data)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tinyfs_fill_super</span><span class="params">(<span class="keyword">struct</span> super_block* sb, <span class="type">void</span>* data, <span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟磁盘的内存空间，在创建文件时搜索一个可用的块位置并申请块资源</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_file_blk</span>* <span class="title">disk</span>[<span class="title">MAX_FILES</span> + 1];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前已创建文件的数量</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> files_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化磁盘空间，所有块位置都可用</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_disk</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_FILES; i++) &#123;</span><br><span class="line">        disk[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配新的块，并初始化一些参数</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> tinyfs_file_blk* <span class="title function_">alloc_block</span><span class="params">(<span class="type">uint8_t</span> idx, <span class="type">mode_t</span> mode)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_file_blk</span>* <span class="title">blk</span> =</span> kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> tinyfs_file_blk) + MAX_FILEBYTES, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!blk)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    blk-&gt;busy = <span class="number">1</span>;</span><br><span class="line">    blk-&gt;mode = mode;</span><br><span class="line">    blk-&gt;idx = idx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (S_ISDIR(mode))</span><br><span class="line">        blk-&gt;dir_children = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        blk-&gt;file_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据部分占用的空间</span></span><br><span class="line">    <span class="built_in">memset</span>(blk-&gt;data, <span class="number">0</span>, MAX_FILEBYTES);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> blk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目录操作结构体，包含了 readdir(iterate_shared) 方法</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">tinyfs_dir_operations</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .iterate_shared = tinyfs_iterate,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取目录的实现：遍历目录中的所有文件</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tinyfs_iterate</span><span class="params">(<span class="keyword">struct</span> file* filp, <span class="keyword">struct</span> dir_context* ctx)</span> &#123;</span><br><span class="line">    <span class="type">loff_t</span> pos;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_file_blk</span>* <span class="title">blk</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_dir_entry</span>* <span class="title">entry</span>;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前文件的位置，如果文件指针已经不在起始位置，说明已经读取完</span></span><br><span class="line">    pos = filp-&gt;f_pos;</span><br><span class="line">    <span class="keyword">if</span> (pos)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前目录块的私有数据</span></span><br><span class="line">    blk = (<span class="keyword">struct</span> tinyfs_file_blk*)filp-&gt;f_path.dentry-&gt;d_inode-&gt;i_private;</span><br><span class="line">    <span class="keyword">if</span> (!blk) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Null pointer\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前块不是目录，返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (!S_ISDIR(blk-&gt;mode)) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Not a directory block\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOTDIR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历目录中的所有文件</span></span><br><span class="line">    entry = (<span class="keyword">struct</span> tinyfs_dir_entry*)&amp;blk-&gt;data[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; blk-&gt;dir_children; i++) &#123;</span><br><span class="line">        pr_info(<span class="string">&quot;Reading entry %d-th: %s\n&quot;</span>, i + <span class="number">1</span>, entry[i].filename);</span><br><span class="line">        <span class="comment">// 在目录列表中将目录条目（文件名和元数据）填充到目录缓冲区中</span></span><br><span class="line">        dir_emit(ctx, entry[i].filename, strnlen(entry[i].filename, MAX_NAMELEN), entry[i].idx, DT_UNKNOWN);</span><br><span class="line">        ctx-&gt;pos++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件操作结构体，包含了 read 和 write 方法</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">tinyfs_file_operations</span> =</span> &#123;</span><br><span class="line">    .read = tinyfs_file_read,</span><br><span class="line">    .write = tinyfs_file_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入文件的实现：ssize_t write(int fd, const void buf[.count], size_t count);</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">tinyfs_file_write</span><span class="params">(<span class="keyword">struct</span> file* filp, <span class="type">const</span> <span class="type">char</span> __user* buf, <span class="type">size_t</span> len, <span class="type">loff_t</span>* ppos)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_file_blk</span>* <span class="title">blk</span>;</span></span><br><span class="line">    <span class="type">char</span>* buffer;</span><br><span class="line"></span><br><span class="line">    blk = filp-&gt;f_path.dentry-&gt;d_inode-&gt;i_private;  <span class="comment">// 获取文件块</span></span><br><span class="line">    <span class="keyword">if</span> (!blk) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Null pointer\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buffer = (<span class="type">char</span>*)&amp;blk-&gt;data[<span class="number">0</span>];</span><br><span class="line">    buffer += *ppos;  <span class="comment">// 将指针指向当前偏移位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入的长度不能超过文件的剩余数据空间</span></span><br><span class="line">    len = min(MAX_FILEBYTES - (<span class="type">size_t</span>)blk-&gt;file_size, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(buffer, buf, len)) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Failed to copy data from user to kernel\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    *ppos += len;            <span class="comment">// 更新文件偏移量</span></span><br><span class="line">    blk-&gt;file_size = *ppos;  <span class="comment">// 更新文件大小</span></span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;Written %zu bytes to file, total %lld bytes\n&quot;</span>, len, *ppos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件的实现：ssize_t read(int fd, void buf[.count], size_t count);</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">tinyfs_file_read</span><span class="params">(<span class="keyword">struct</span> file* filp, <span class="type">char</span> __user* buf, <span class="type">size_t</span> len, <span class="type">loff_t</span>* ppos)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_file_blk</span>* <span class="title">blk</span>;</span></span><br><span class="line">    <span class="type">char</span>* buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文件块</span></span><br><span class="line">    blk = (<span class="keyword">struct</span> tinyfs_file_blk*)filp-&gt;f_path.dentry-&gt;d_inode-&gt;i_private;</span><br><span class="line">    <span class="keyword">if</span> (!blk) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Null pointer\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前偏移量超过文件大小，返回 0</span></span><br><span class="line">    <span class="keyword">if</span> (*ppos &gt; blk-&gt;file_size) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Failed to read, end of file reached: ppos=%lld, file_size=%d\n&quot;</span>, *ppos, blk-&gt;file_size);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取的长度不能超过文件的大小</span></span><br><span class="line">    len = min((<span class="type">size_t</span>)blk-&gt;file_size, len);</span><br><span class="line"></span><br><span class="line">    buffer = (<span class="type">char</span>*)&amp;blk-&gt;data[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, buffer, len)) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Failed to copy data from kernel to user\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    *ppos += len;  <span class="comment">// 更新文件偏移量</span></span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;Read successful: ppos=%lld, len=%zu\n&quot;</span>, *ppos, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inode 操作集，包含文件和目录的操作</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> <span class="title">tinyfs_inode_ops</span> =</span> &#123;</span><br><span class="line">    .create = tinyfs_create,</span><br><span class="line">    .unlink = tinyfs_unlink,</span><br><span class="line">    .mkdir = tinyfs_mkdir,</span><br><span class="line">    .rmdir = tinyfs_rmdir,</span><br><span class="line">    .lookup = tinyfs_lookup,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建文件或目录的实现</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tinyfs_do_create</span><span class="params">(<span class="keyword">struct</span> inode* dir, <span class="keyword">struct</span> dentry* dentry, <span class="type">umode_t</span> mode)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">inode</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>* <span class="title">sb</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_dir_entry</span>* <span class="title">entry</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_file_blk</span> *<span class="title">blk</span>, *<span class="title">pblk</span>;</span></span><br><span class="line">    <span class="type">int</span> idx = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    sb = dir-&gt;i_sb;</span><br><span class="line">    <span class="keyword">if</span> (!sb) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Null pointer\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到一个空闲块位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; MAX_FILES + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!disk[i]) &#123;</span><br><span class="line">            idx = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (files_count &gt;= MAX_FILES || <span class="number">-1</span> == idx) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;No space left to create file or directory\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOSPC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果模式既不是目录也不是文件，返回无效参数错误</span></span><br><span class="line">    <span class="keyword">if</span> (!S_ISDIR(mode) &amp;&amp; !S_ISREG(mode)) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Invalid mode (%u): neither directory nor file\n&quot;</span>, mode);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在找到的空闲块处分配块资源</span></span><br><span class="line">    disk[idx] = alloc_block(idx, mode);</span><br><span class="line">    <span class="keyword">if</span> (!disk[idx]) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Failed to alloc a disk block space\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inode = new_inode(sb);</span><br><span class="line">    <span class="keyword">if</span> (!inode) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Failed to create new inode\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    inode-&gt;i_ino = idx;</span><br><span class="line">    inode-&gt;i_sb = sb;</span><br><span class="line">    inode-&gt;i_op = &amp;tinyfs_inode_ops;</span><br><span class="line">    inode-&gt;__i_atime = inode-&gt;__i_mtime = inode-&gt;__i_ctime = current_time(inode);</span><br><span class="line"></span><br><span class="line">    blk = disk[idx];</span><br><span class="line">    blk-&gt;mode = mode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按目录或文件，初始化相应成员</span></span><br><span class="line">    <span class="keyword">if</span> (S_ISDIR(mode)) &#123;</span><br><span class="line">        blk-&gt;dir_children = <span class="number">0</span>;</span><br><span class="line">        inode-&gt;i_fop = &amp;tinyfs_dir_operations;</span><br><span class="line">        pr_info(<span class="string">&quot;Created directory: %s\n&quot;</span>, dentry-&gt;d_name.name);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISREG(mode)) &#123;</span><br><span class="line">        blk-&gt;file_size = <span class="number">0</span>;</span><br><span class="line">        inode-&gt;i_fop = &amp;tinyfs_file_operations;</span><br><span class="line">        pr_info(<span class="string">&quot;Created file: %s\n&quot;</span>, dentry-&gt;d_name.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂上 tinyfs 的私有数据块（第 idx 个 block）</span></span><br><span class="line">    inode-&gt;i_private = blk;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取目录对应的 tinyfs 的私有数据块</span></span><br><span class="line">    pblk = (<span class="keyword">struct</span> tinyfs_file_blk*)dir-&gt;i_private;</span><br><span class="line">    <span class="keyword">if</span> (pblk-&gt;dir_children + <span class="number">1</span> &gt; MAX_DENTRY_NR) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;No space left to save dir entry\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新创建的文件或目录加入到父目录的子目录列表中</span></span><br><span class="line">    entry = (<span class="keyword">struct</span> tinyfs_dir_entry*)&amp;pblk-&gt;data[<span class="number">0</span>];</span><br><span class="line">    entry += pblk-&gt;dir_children;  <span class="comment">// 跳过已存在的前 N 个孩子的内存，指到新孩子的存储位置</span></span><br><span class="line"></span><br><span class="line">    entry-&gt;idx = idx;</span><br><span class="line">    <span class="built_in">strncpy</span>(entry-&gt;filename, dentry-&gt;d_name.name, MAX_NAMELEN - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    pblk-&gt;dir_children++;  <span class="comment">// 孩子数量加一</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键步骤：初始化并将新 inode 的添加到 dentry，即将文件或目录记录在当前目录下</span></span><br><span class="line">    inode_init_owner(&amp;nop_mnt_idmap, inode, dir, mode);</span><br><span class="line">    d_add(dentry, inode);</span><br><span class="line"></span><br><span class="line">    files_count++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建目录的实现</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tinyfs_mkdir</span><span class="params">(<span class="keyword">struct</span> mnt_idmap* idmap, <span class="keyword">struct</span> inode* dir, <span class="keyword">struct</span> dentry* dentry, <span class="type">umode_t</span> mode)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tinyfs_do_create(dir, dentry, S_IFDIR | mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建文件的实现</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tinyfs_create</span><span class="params">(<span class="keyword">struct</span> mnt_idmap* idmap, <span class="keyword">struct</span> inode* dir, <span class="keyword">struct</span> dentry* dentry, <span class="type">umode_t</span> mode, <span class="type">bool</span> excl)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tinyfs_do_create(dir, dentry, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 sb 创建一个 inode 并初始化它</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode* <span class="title function_">tinyfs_iget</span><span class="params">(<span class="keyword">struct</span> super_block* sb, <span class="type">int</span> idx)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">inode</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_file_blk</span>* <span class="title">blk</span>;</span></span><br><span class="line"></span><br><span class="line">    blk = disk[idx];</span><br><span class="line">    <span class="keyword">if</span> (!blk) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Null pointer\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inode = new_inode(sb);</span><br><span class="line">    <span class="keyword">if</span> (!inode) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Failed to create a new inode\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inode-&gt;i_ino = idx;</span><br><span class="line">    inode-&gt;i_sb = sb;</span><br><span class="line">    inode-&gt;i_op = &amp;tinyfs_inode_ops;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (S_ISDIR(blk-&gt;mode))</span><br><span class="line">        inode-&gt;i_fop = &amp;tinyfs_dir_operations;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (S_ISREG(blk-&gt;mode))</span><br><span class="line">        inode-&gt;i_fop = &amp;tinyfs_file_operations;</span><br><span class="line"></span><br><span class="line">    inode-&gt;__i_atime = inode-&gt;__i_mtime = inode-&gt;__i_ctime = current_time(inode);</span><br><span class="line">    inode-&gt;i_private = blk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> dentry* <span class="title function_">tinyfs_lookup</span><span class="params">(<span class="keyword">struct</span> inode* parent_inode, <span class="keyword">struct</span> dentry* child_dentry, <span class="type">unsigned</span> <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>* <span class="title">sb</span> =</span> parent_inode-&gt;i_sb;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_file_blk</span>* <span class="title">blk</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_dir_entry</span>* <span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">    blk = (<span class="keyword">struct</span> tinyfs_file_blk*)parent_inode-&gt;i_private;</span><br><span class="line"></span><br><span class="line">    entry = (<span class="keyword">struct</span> tinyfs_dir_entry*)&amp;blk-&gt;data[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; blk-&gt;dir_children; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(entry[i].filename, child_dentry-&gt;d_name.name)) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">inode</span> =</span> tinyfs_iget(sb, entry[i].idx);</span><br><span class="line">            <span class="keyword">if</span> (!inode) &#123;</span><br><span class="line">                pr_err(<span class="string">&quot;Null pointer\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_file_blk</span>* <span class="title">inner</span> =</span> (<span class="keyword">struct</span> tinyfs_file_blk*)inode-&gt;i_private;</span><br><span class="line">            inode_init_owner(&amp;nop_mnt_idmap, inode, parent_inode, inner-&gt;mode);</span><br><span class="line">            d_add(child_dentry, inode);</span><br><span class="line">            pr_info(<span class="string">&quot;found dentry: %s\n&quot;</span>, child_dentry-&gt;d_name.name);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除目录的实现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tinyfs_rmdir</span><span class="params">(<span class="keyword">struct</span> inode* dir, <span class="keyword">struct</span> dentry* dentry)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">inode</span> =</span> dentry-&gt;d_inode;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_file_blk</span>* <span class="title">blk</span> =</span> (<span class="keyword">struct</span> tinyfs_file_blk*)inode-&gt;i_private;  <span class="comment">// 获取目录的磁盘块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_file_blk</span>* <span class="title">pblk</span> =</span> (<span class="keyword">struct</span> tinyfs_file_blk*)dir-&gt;i_private;   <span class="comment">// 获取父目录的磁盘块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_dir_entry</span>* <span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否为空目录</span></span><br><span class="line">    <span class="keyword">if</span> (blk-&gt;dir_children &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Cannot remove non-empty directory: %s\n&quot;</span>, dentry-&gt;d_name.name);</span><br><span class="line">        <span class="keyword">return</span> -ENOTEMPTY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从父目录中移除该目录的目录项</span></span><br><span class="line">    entry = (<span class="keyword">struct</span> tinyfs_dir_entry*)&amp;pblk-&gt;data[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pblk-&gt;dir_children; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(entry[i].filename, dentry-&gt;d_name.name)) &#123;  <span class="comment">// 找到该文件</span></span><br><span class="line">            <span class="comment">// 移动父目录中后续的目录项，覆盖当前的目录项</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; pblk-&gt;dir_children - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;entry[j], &amp;entry[j + <span class="number">1</span>], <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tinyfs_dir_entry));  <span class="comment">// 移动目录项</span></span><br><span class="line">            &#125;</span><br><span class="line">            pblk-&gt;dir_children--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放该文件的所有内存</span></span><br><span class="line">    disk[blk-&gt;idx] = <span class="literal">NULL</span>;</span><br><span class="line">    kfree(blk);</span><br><span class="line">    blk = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;Removed directory: %s\n&quot;</span>, dentry-&gt;d_name.name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> simple_rmdir(dir, dentry);  <span class="comment">// 调用 VFS 的 rmdir 实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除文件的实现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tinyfs_unlink</span><span class="params">(<span class="keyword">struct</span> inode* dir, <span class="keyword">struct</span> dentry* dentry)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">inode</span> =</span> dentry-&gt;d_inode;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_file_blk</span>* <span class="title">blk</span> =</span> (<span class="keyword">struct</span> tinyfs_file_blk*)inode-&gt;i_private;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_file_blk</span>* <span class="title">pblk</span> =</span> (<span class="keyword">struct</span> tinyfs_file_blk*)dir-&gt;i_private;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tinyfs_dir_entry</span>* <span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新父目录的子目录列表，移除该文件的目录项</span></span><br><span class="line">    entry = (<span class="keyword">struct</span> tinyfs_dir_entry*)&amp;pblk-&gt;data[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pblk-&gt;dir_children; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(entry[i].filename, dentry-&gt;d_name.name)) &#123;  <span class="comment">// 找到该文件</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; pblk-&gt;dir_children - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;entry[j], &amp;entry[j + <span class="number">1</span>], <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tinyfs_dir_entry));  <span class="comment">// 移动目录项</span></span><br><span class="line">            &#125;</span><br><span class="line">            pblk-&gt;dir_children--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放该文件的所有内存</span></span><br><span class="line">    disk[blk-&gt;idx] = <span class="literal">NULL</span>;</span><br><span class="line">    kfree(blk);</span><br><span class="line">    blk = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;Removed file: %s\n&quot;</span>, dentry-&gt;d_name.name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> simple_unlink(dir, dentry);  <span class="comment">// 调用 VFS 的 unlink 实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> <span class="title">tinyfs_super_operations</span> =</span> &#123;</span><br><span class="line">    <span class="comment">// .alloc_inode = new_inode,</span></span><br><span class="line">    .statfs = simple_statfs,             <span class="comment">// 使用通用的文件系统统计操作</span></span><br><span class="line">    .drop_inode = generic_delete_inode,  <span class="comment">// 删除 inode 的默认操作</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件系统的挂载和初始化：从已申请的 sb 资源中申请 root inode 并初始化，以及持久化根目录内容到硬盘</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tinyfs_fill_super</span><span class="params">(<span class="keyword">struct</span> super_block* sb, <span class="type">void</span>* data, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">root_inode</span>;</span></span><br><span class="line">    <span class="type">int</span> mode = S_IFDIR | <span class="number">0755</span>;</span><br><span class="line"></span><br><span class="line">    sb-&gt;s_magic = TINYFS_MAGIC;</span><br><span class="line">    sb-&gt;s_op = &amp;tinyfs_super_operations;</span><br><span class="line"></span><br><span class="line">    root_inode = new_inode(sb);</span><br><span class="line">    <span class="keyword">if</span> (!root_inode) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Failed to create root inode\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Init uid, gid, mode for new inode according to posix standards</span></span><br><span class="line">    inode_init_owner(&amp;nop_mnt_idmap, root_inode, <span class="literal">NULL</span>, mode);</span><br><span class="line">    root_inode-&gt;i_ino = <span class="number">1</span>;  <span class="comment">// 根目录的 inode 编号为 1</span></span><br><span class="line">    root_inode-&gt;i_sb = sb;</span><br><span class="line">    root_inode-&gt;i_op = &amp;tinyfs_inode_ops;</span><br><span class="line">    root_inode-&gt;i_fop = &amp;tinyfs_dir_operations;</span><br><span class="line">    root_inode-&gt;__i_atime = root_inode-&gt;__i_mtime = root_inode-&gt;__i_ctime = current_time(root_inode);</span><br><span class="line"></span><br><span class="line">    sb-&gt;s_root = d_make_root(root_inode);  <span class="comment">// 创建文件系统的 dentry 根目录</span></span><br><span class="line">    <span class="keyword">if</span> (!sb-&gt;s_root) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Failed to create root dentry\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    files_count++;  <span class="comment">// 更新文件计数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂载的根目录的目录内容初始化</span></span><br><span class="line">    disk[<span class="number">1</span>] = alloc_block(<span class="number">1</span>, mode);</span><br><span class="line">    <span class="keyword">if</span> (!disk[<span class="number">1</span>]) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Failed to alloc a disk block space\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    root_inode-&gt;i_private = disk[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;tinyfs mounted successfully\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂载文件系统：mount -t tinyfs none /mnt/tinyfs</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> dentry* <span class="title function_">tinyfs_mount</span><span class="params">(<span class="keyword">struct</span> file_system_type* fs_type, <span class="type">int</span> flags, <span class="type">const</span> <span class="type">char</span>* dev_name, <span class="type">void</span>* data)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * mount_nodev() 用于挂载一个没有设备文件（即设备为空）或者说是虚拟文件系统的文件系统</span></span><br><span class="line"><span class="comment">     * 函数内，主要是通过 sget() 分配一个超级块 s，然后使用钩子函数 tinyfs_fill_super() 来初始化超级块的一些数据</span></span><br><span class="line"><span class="comment">     * error = tinyfs_fill_super(s, data, flags &amp; SB_SILENT ? 1 : 0);</span></span><br><span class="line"><span class="comment">     * 在初始化成功后，通过 dget(s-&gt;s_root) 增加文件系统的根目录项的引用计数，并返回根目录项</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> mount_nodev(fs_type, flags, data, tinyfs_fill_super);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁文件系统：umount /mnt/tinyfs</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tinyfs_kill_superblock</span><span class="params">(<span class="keyword">struct</span> super_block* sb)</span> &#123;</span><br><span class="line">    kill_anon_super(sb);</span><br><span class="line">    pr_info(<span class="string">&quot;tinyfs unmounted and resources cleaned up\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件系统类型定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">tinyfs_fs_type</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .name = <span class="string">&quot;tinyfs&quot;</span>,</span><br><span class="line">    .mount = tinyfs_mount,</span><br><span class="line">    .kill_sb = tinyfs_kill_superblock,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件系统初始化</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tinyfs_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    init_disk();</span><br><span class="line"></span><br><span class="line">    ret = register_filesystem(&amp;tinyfs_fs_type);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        pr_err(<span class="string">&quot;Register tinyfs failed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;tinyfs loaded\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件系统退出</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tinyfs_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    unregister_filesystem(&amp;tinyfs_fs_type);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; MAX_FILES + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (disk[i]) &#123;</span><br><span class="line">            kfree(disk[i]);</span><br><span class="line">            disk[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;tinyfs unloaded\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(tinyfs_init);</span><br><span class="line">module_exit(tinyfs_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">umount -f /mnt/tinyfs</span></span><br><span class="line"><span class="comment">rmmod tinyfs</span></span><br><span class="line"><span class="comment">make clean</span></span><br><span class="line"><span class="comment">make</span></span><br><span class="line"><span class="comment">insmod tinyfs.ko</span></span><br><span class="line"><span class="comment">mount -t tinyfs none /mnt/tinyfs</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="测试">测试</h2>
<h3 id="挂载命令">挂载命令</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make clean</span><br><span class="line">make</span><br><span class="line">insmod tinyfs.ko</span><br><span class="line">mount -t tinyfs none /mnt/tinyfs</span><br></pre></td></tr></table></figure>
<h3 id="卸载命令">卸载命令</h3>
<p>需要在不进入 /mnt/tinyfs 目录下执行卸载命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">umount -f /mnt/tinyfs</span><br><span class="line">rmmod tinyfs</span><br></pre></td></tr></table></figure>
<h3 id="测试过程">测试过程</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@Standard-PC:/mnt# ls -li</span><br><span class="line">总计 0</span><br><span class="line">1 drwxr-xr-x 1 root root 0 11 月 19 18:48 tinyfs</span><br><span class="line">root@Standard-PC:/mnt# cd tinyfs/</span><br><span class="line">root@Standard-PC:/mnt/tinyfs# ls -li</span><br><span class="line">总计 0</span><br><span class="line">root@Standard-PC:/mnt/tinyfs# mkdir test1</span><br><span class="line">root@Standard-PC:/mnt/tinyfs# mkdir test2</span><br><span class="line">root@Standard-PC:/mnt/tinyfs# mkdir test3</span><br><span class="line">root@Standard-PC:/mnt/tinyfs# touch text1.txt</span><br><span class="line">root@Standard-PC:/mnt/tinyfs# touch text2.txt</span><br><span class="line">root@Standard-PC:/mnt/tinyfs# mkdir test4</span><br><span class="line">root@Standard-PC:/mnt/tinyfs# echo 12345 &gt; text3.txt</span><br><span class="line">root@Standard-PC:/mnt/tinyfs#</span><br><span class="line">root@Standard-PC:/mnt/tinyfs# ls -l -i</span><br><span class="line">总计 0</span><br><span class="line">2 drwxr-xr-x 1 root root 0 11 月 19 18:49 test1</span><br><span class="line">3 drwxr-xr-x 1 root root 0 11 月 19 18:49 test2</span><br><span class="line">4 drwxr-xr-x 1 root root 0 11 月 19 18:49 test3</span><br><span class="line">7 drwxr-xr-x 1 root root 0 11 月 19 18:50 test4</span><br><span class="line">5 -rw-r--r-- 1 root root 0 11 月 19 18:49 text1.txt</span><br><span class="line">6 -rw-r--r-- 1 root root 0 11 月 19 18:50 text2.txt</span><br><span class="line">8 -rw-r--r-- 1 root root 0 11 月 19 18:50 text3.txt</span><br><span class="line">root@Standard-PC:/mnt/tinyfs# rm text1.txt</span><br><span class="line">root@Standard-PC:/mnt/tinyfs# ls -l -i</span><br><span class="line">总计 0</span><br><span class="line">2 drwxr-xr-x 1 root root 0 11 月 19 18:49 test1</span><br><span class="line">3 drwxr-xr-x 1 root root 0 11 月 19 18:49 test2</span><br><span class="line">4 drwxr-xr-x 1 root root 0 11 月 19 18:49 test3</span><br><span class="line">7 drwxr-xr-x 1 root root 0 11 月 19 18:50 test4</span><br><span class="line">6 -rw-r--r-- 1 root root 0 11 月 19 18:50 text2.txt</span><br><span class="line">8 -rw-r--r-- 1 root root 0 11 月 19 18:50 text3.txt</span><br><span class="line">root@Standard-PC:/mnt/tinyfs# echo abcd &gt; text1.txt</span><br><span class="line">root@Standard-PC:/mnt/tinyfs# ls -l -i</span><br><span class="line">总计 0</span><br><span class="line">2 drwxr-xr-x 1 root root 0 11 月 19 18:49 test1</span><br><span class="line">3 drwxr-xr-x 1 root root 0 11 月 19 18:49 test2</span><br><span class="line">4 drwxr-xr-x 1 root root 0 11 月 19 18:49 test3</span><br><span class="line">7 drwxr-xr-x 1 root root 0 11 月 19 18:50 test4</span><br><span class="line">5 -rw-r--r-- 1 root root 0 11 月 19 18:51 text1.txt</span><br><span class="line">6 -rw-r--r-- 1 root root 0 11 月 19 18:50 text2.txt</span><br><span class="line">8 -rw-r--r-- 1 root root 0 11 月 19 18:50 text3.txt</span><br><span class="line">root@Standard-PC:/mnt/tinyfs# cd test2</span><br><span class="line">root@Standard-PC:/mnt/tinyfs/test2# mkdir test21</span><br><span class="line">root@Standard-PC:/mnt/tinyfs/test2# touch text21.txt</span><br><span class="line">root@Standard-PC:/mnt/tinyfs/test2# mkdir test22</span><br><span class="line">root@Standard-PC:/mnt/tinyfs/test2# touch text22.txt</span><br><span class="line">root@Standard-PC:/mnt/tinyfs/test2# ls -l -i</span><br><span class="line">总计 0</span><br><span class="line"> 9 drwxr-xr-x 1 root root 0 11 月 19 18:52 test21</span><br><span class="line">11 drwxr-xr-x 1 root root 0 11 月 19 18:52 test22</span><br><span class="line">10 -rw-r--r-- 1 root root 0 11 月 19 18:52 text21.txt</span><br><span class="line">12 -rw-r--r-- 1 root root 0 11 月 19 18:52 text22.txt</span><br><span class="line">root@Standard-PC:/mnt/tinyfs/test2# rm text21.txt</span><br><span class="line">root@Standard-PC:/mnt/tinyfs/test2# rm -r test22</span><br><span class="line">root@Standard-PC:/mnt/tinyfs/test2# ls -l -i</span><br><span class="line">总计 0</span><br><span class="line"> 9 drwxr-xr-x 1 root root 0 11 月 19 18:52 test21</span><br><span class="line">12 -rw-r--r-- 1 root root 0 11 月 19 18:52 text22.txt</span><br><span class="line">root@Standard-PC:/mnt/tinyfs/test2# ls</span><br><span class="line">test21  text22.txt</span><br><span class="line">root@Standard-PC:/mnt/tinyfs/test2# cd ..</span><br><span class="line">root@Standard-PC:/mnt/tinyfs# ls</span><br><span class="line">test1  test2  test3  test4  text1.txt  text2.txt  text3.txt</span><br><span class="line">root@Standard-PC:/mnt/tinyfs# tree</span><br><span class="line">.</span><br><span class="line">├── test1</span><br><span class="line">├── test2</span><br><span class="line">│   ├── test21</span><br><span class="line">│   └── text22.txt</span><br><span class="line">├── test3</span><br><span class="line">├── test4</span><br><span class="line">├── text1.txt</span><br><span class="line">├── text2.txt</span><br><span class="line">└── text3.txt</span><br><span class="line"></span><br><span class="line">5 directories, 4 files</span><br><span class="line">root@Standard-PC:/mnt/tinyfs# cat text3.txt</span><br><span class="line">12345</span><br><span class="line">12345  // 数据被读取了两次！</span><br><span class="line">root@Standard-PC:/mnt/tinyfs# rm -r test2</span><br><span class="line">root@Standard-PC:/mnt/tinyfs# ls</span><br><span class="line">test1  test3  test4  text1.txt  text2.txt  text3.txt</span><br><span class="line">root@Standard-PC:/mnt/tinyfs# cd test2</span><br><span class="line">-bash: cd: test2: 没有那个文件或目录 </span><br><span class="line">root@Standard-PC:/mnt/tinyfs# touch 1.txt</span><br><span class="line">root@Standard-PC:/mnt/tinyfs# touch 2.txt</span><br><span class="line">root@Standard-PC:/mnt/tinyfs# touch 3.txt</span><br><span class="line">root@Standard-PC:/mnt/tinyfs#</span><br><span class="line">root@Standard-PC:/mnt/tinyfs# ls -l -i</span><br><span class="line"> 总计 0</span><br><span class="line"> 3 -rw-r--r-- 1 root root 0 11 月 19 18:55 1.txt</span><br><span class="line"> 9 -rw-r--r-- 1 root root 0 11 月 19 18:55 2.txt</span><br><span class="line">10 -rw-r--r-- 1 root root 0 11 月 19 18:55 3.txt</span><br><span class="line"> 2 drwxr-xr-x 1 root root 0 11 月 19 18:49 test1</span><br><span class="line"> 4 drwxr-xr-x 1 root root 0 11 月 19 18:49 test3</span><br><span class="line"> 7 drwxr-xr-x 1 root root 0 11 月 19 18:50 test4</span><br><span class="line"> 5 -rw-r--r-- 1 root root 0 11 月 19 18:51 text1.txt</span><br><span class="line"> 6 -rw-r--r-- 1 root root 0 11 月 19 18:50 text2.txt</span><br><span class="line"> 8 -rw-r--r-- 1 root root 0 11 月 19 18:50 text3.txt</span><br><span class="line">root@Standard-PC:/mnt/tinyfs#</span><br></pre></td></tr></table></figure>
<h3 id="内核日志">内核日志</h3>
<p>从日志中可以看到，在删除目录、文件时有一些 WARNING。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@Standard-PC:/home/zkwang/ccode/tinyfs# dmesg</span><br><span class="line">[3554.248389] tinyfs loaded</span><br><span class="line">[3573.580879] tinyfs mounted successfully</span><br><span class="line">[3627.377401] Created directory: test1</span><br><span class="line">[3629.360099] Created directory: test2</span><br><span class="line">[3631.790973] Created directory: test3</span><br><span class="line">[3645.009682] Created file: text1.txt</span><br><span class="line">[3649.358875] Created file: text2.txt</span><br><span class="line">[3661.254142] Created directory: test4</span><br><span class="line">[3672.623560] Created file: text3.txt</span><br><span class="line">[3672.623580] Written 6 bytes to file, total 6 bytes</span><br><span class="line">[3696.802383] Reading entry 1-th: test1</span><br><span class="line">[3696.802388] Reading entry 2-th: test2</span><br><span class="line">[3696.802389] Reading entry 3-th: test3</span><br><span class="line">[3696.802389] Reading entry 4-th: text1.txt</span><br><span class="line">[3696.802390] Reading entry 5-th: text2.txt</span><br><span class="line">[3696.802391] Reading entry 6-th: test4</span><br><span class="line">[3696.802392] Reading entry 7-th: text3.txt</span><br><span class="line">[3723.591431] Removed file: text1.txt</span><br><span class="line">[3723.591447] ------------[cut here]------------</span><br><span class="line">[3723.591448] WARNING: CPU: 1 PID: 5898 at fs/dcache.c:766 dput+0x199/0x1b0</span><br><span class="line">[3723.591456] Modules linked in: tinyfs(OE) 省略...</span><br><span class="line">[3723.591612]  &lt;/TASK&gt;</span><br><span class="line">[3723.591613] ---[end trace 0000000000000000]---</span><br><span class="line">[3728.585730] Reading entry 1-th: test1</span><br><span class="line">[3728.585736] Reading entry 2-th: test2</span><br><span class="line">[3728.585737] Reading entry 3-th: test3</span><br><span class="line">[3728.585738] Reading entry 4-th: text2.txt</span><br><span class="line">[3728.585739] Reading entry 5-th: test4</span><br><span class="line">[3728.585739] Reading entry 6-th: text3.txt</span><br><span class="line">[3749.471244] Created file: text1.txt</span><br><span class="line">[3749.471260] Written 5 bytes to file, total 5 bytes</span><br><span class="line">[3751.604462] Reading entry 1-th: test1</span><br><span class="line">[3751.604478] Reading entry 2-th: test2</span><br><span class="line">[3751.604479] Reading entry 3-th: test3</span><br><span class="line">[3751.604480] Reading entry 4-th: text2.txt</span><br><span class="line">[3751.604481] Reading entry 5-th: test4</span><br><span class="line">[3751.604482] Reading entry 6-th: text3.txt</span><br><span class="line">[3751.604483] Reading entry 7-th: text1.txt</span><br><span class="line">[3757.179360] Reading entry 1-th: test1</span><br><span class="line">[3757.179366] Reading entry 2-th: test2</span><br><span class="line">[3757.179367] Reading entry 3-th: test3</span><br><span class="line">[3757.179367] Reading entry 4-th: text2.txt</span><br><span class="line">[3757.179368] Reading entry 5-th: test4</span><br><span class="line">[3757.179369] Reading entry 6-th: text3.txt</span><br><span class="line">[3757.179370] Reading entry 7-th: text1.txt</span><br><span class="line">[3772.983041] Created directory: test21</span><br><span class="line">[3790.182636] Created file: text21.txt</span><br><span class="line">[3797.113555] Created directory: test22</span><br><span class="line">[3799.803665] Created file: text22.txt</span><br><span class="line">[3805.302208] Reading entry 1-th: test21</span><br><span class="line">[3805.302215] Reading entry 2-th: text21.txt</span><br><span class="line">[3805.302216] Reading entry 3-th: test22</span><br><span class="line">[3805.302217] Reading entry 4-th: text22.txt</span><br><span class="line">[3819.650587] Removed file: text21.txt</span><br><span class="line">[3848.111870] Removed directory: test22</span><br><span class="line">[3848.111894] ------------[cut here]------------</span><br><span class="line">[3848.111895] WARNING: CPU: 8 PID: 5913 at fs/inode.c:331 drop_nlink+0x2e/0x50</span><br><span class="line">[3848.111902] Modules linked in: tinyfs(OE)  省略...</span><br><span class="line">[3848.112103]  &lt;/TASK&gt;</span><br><span class="line">[3848.112104] ---[end trace 0000000000000000]---</span><br><span class="line">[3850.845726] Reading entry 1-th: test21</span><br><span class="line">[3850.845731] Reading entry 2-th: text22.txt</span><br><span class="line">[3856.437171] Reading entry 1-th: test21</span><br><span class="line">[3856.437175] Reading entry 2-th: text22.txt</span><br><span class="line">[3859.858365] Reading entry 1-th: test1</span><br><span class="line">[3859.858369] Reading entry 2-th: test2</span><br><span class="line">[3859.858370] Reading entry 3-th: test3</span><br><span class="line">[3859.858371] Reading entry 4-th: text2.txt</span><br><span class="line">[3859.858372] Reading entry 5-th: test4</span><br><span class="line">[3859.858373] Reading entry 6-th: text3.txt</span><br><span class="line">[3859.858373] Reading entry 7-th: text1.txt</span><br><span class="line">[3864.182500] Reading entry 1-th: test1</span><br><span class="line">[3864.182506] Reading entry 2-th: test2</span><br><span class="line">[3864.182507] Reading entry 3-th: test3</span><br><span class="line">[3864.182507] Reading entry 4-th: text2.txt</span><br><span class="line">[3864.182509] Reading entry 5-th: test4</span><br><span class="line">[3864.182509] Reading entry 6-th: text3.txt</span><br><span class="line">[3864.182510] Reading entry 7-th: text1.txt</span><br><span class="line">[3864.182591] Reading entry 1-th: test21</span><br><span class="line">[3864.182593] Reading entry 2-th: text22.txt</span><br><span class="line">[3879.324995] Reading entry 1-th: test1</span><br><span class="line">[3879.325000] Reading entry 2-th: test2</span><br><span class="line">[3879.325001] Reading entry 3-th: test3</span><br><span class="line">[3879.325002] Reading entry 4-th: text2.txt</span><br><span class="line">[3879.325002] Reading entry 5-th: test4</span><br><span class="line">[3879.325003] Reading entry 6-th: text3.txt</span><br><span class="line">[3879.325004] Reading entry 7-th: text1.txt</span><br><span class="line">[3880.713272] Read successful: ppos=6, len=6</span><br><span class="line">[3880.713285] Read successful: ppos=12, len=6</span><br><span class="line">[3880.713288] Failed to read, end of file reached: ppos=12, file_size=6</span><br><span class="line">[3917.372096] Reading entry 1-th: test21</span><br><span class="line">[3917.372102] Reading entry 2-th: text22.txt</span><br><span class="line">[3917.372112] Reading entry 1-th: test21</span><br><span class="line">[3917.372113] Reading entry 2-th: text22.txt</span><br><span class="line">[3917.372128] Removed directory: test21</span><br><span class="line">[3917.372146] ------------[cut here]------------</span><br><span class="line">[3917.372148] WARNING: CPU: 8 PID: 5923 at fs/inode.c:331 drop_nlink+0x2e/0x50</span><br><span class="line">[3917.372155] Modules linked in: tinyfs(OE)  省略...</span><br><span class="line">[3917.372388]  &lt;/TASK&gt;</span><br><span class="line">[3917.372389] ---[end trace 0000000000000000]---</span><br><span class="line">[3917.372395] ------------[cut here]------------</span><br><span class="line">[3917.372396] WARNING: CPU: 8 PID: 5923 at fs/inode.c:331 drop_nlink+0x2e/0x50</span><br><span class="line">[3917.372399] Modules linked in: tinyfs(OE)  省略...</span><br><span class="line">[3917.372514]  &lt;/TASK&gt;</span><br><span class="line">[3917.372515] ---[end trace 0000000000000000]---</span><br><span class="line">[3917.372529] Removed file: text22.txt</span><br><span class="line">[3917.372539] Removed directory: test2</span><br><span class="line">[3919.763064] Reading entry 1-th: test1</span><br><span class="line">[3919.763070] Reading entry 2-th: test3</span><br><span class="line">[3919.763071] Reading entry 3-th: text2.txt</span><br><span class="line">[3919.763072] Reading entry 4-th: test4</span><br><span class="line">[3919.763073] Reading entry 5-th: text3.txt</span><br><span class="line">[3919.763074] Reading entry 6-th: text1.txt</span><br><span class="line">[3925.485462] Reading entry 1-th: test1</span><br><span class="line">[3925.485468] Reading entry 2-th: test3</span><br><span class="line">[3925.485469] Reading entry 3-th: text2.txt</span><br><span class="line">[3925.485470] Reading entry 4-th: test4</span><br><span class="line">[3925.485471] Reading entry 5-th: text3.txt</span><br><span class="line">[3925.485472] Reading entry 6-th: text1.txt</span><br><span class="line">[3926.325130] Reading entry 1-th: test1</span><br><span class="line">[3926.325134] Reading entry 2-th: test3</span><br><span class="line">[3926.325135] Reading entry 3-th: text2.txt</span><br><span class="line">[3926.325136] Reading entry 4-th: test4</span><br><span class="line">[3926.325137] Reading entry 5-th: text3.txt</span><br><span class="line">[3926.325137] Reading entry 6-th: text1.txt</span><br><span class="line">[3926.587543] Reading entry 1-th: test1</span><br><span class="line">[3926.587547] Reading entry 2-th: test3</span><br><span class="line">[3926.587548] Reading entry 3-th: text2.txt</span><br><span class="line">[3926.587548] Reading entry 4-th: test4</span><br><span class="line">[3926.587549] Reading entry 5-th: text3.txt</span><br><span class="line">[3926.587550] Reading entry 6-th: text1.txt</span><br><span class="line">[3978.529407] Created file: 1.txt</span><br><span class="line">[3981.841504] Created file: 2.txt</span><br><span class="line">[3984.412749] Created file: 3.txt</span><br><span class="line">[3997.119562] Reading entry 1-th: test1</span><br><span class="line">[3997.119567] Reading entry 2-th: test3</span><br><span class="line">[3997.119568] Reading entry 3-th: text2.txt</span><br><span class="line">[3997.119569] Reading entry 4-th: test4</span><br><span class="line">[3997.119570] Reading entry 5-th: text3.txt</span><br><span class="line">[3997.119571] Reading entry 6-th: text1.txt</span><br><span class="line">[3997.119571] Reading entry 7-th: 1.txt</span><br><span class="line">[3997.119572] Reading entry 8-th: 2.txt</span><br><span class="line">[3997.119573] Reading entry 9-th: 3.txt</span><br><span class="line">root@Standard-PC:/home/zkwang/ccode/tinyfs#</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://cloud.tencent.com/developer/article/1497058">https://cloud.tencent.com/developer/article/1497058</a></li>
<li><a href="https://blog.csdn.net/yanghao23/article/details/135892565">https://blog.csdn.net/yanghao23/article/details/135892565</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
        <category>文件系统</category>
      </categories>
      <tags>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 基础</title>
    <url>/posts/250605180332.html</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="SQL">SQL</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 什么是 SQL？</span><br><span class="line">	Structured Query Language：结构化查询语言 </span><br><span class="line">	其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。</span><br><span class="line">	</span><br><span class="line">2.SQL 通用语法</span><br><span class="line">	1. SQL 语句可以单行或多行书写，以分号结尾。</span><br><span class="line">	2. 可使用空格和缩进来增强语句的可读性。</span><br><span class="line">	3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。</span><br><span class="line">	4. 3 种注释</span><br><span class="line">		* 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) </span><br><span class="line">		* 多行注释: /* 注释 */</span><br><span class="line">	</span><br><span class="line">3. SQL 分类</span><br><span class="line">	1) DDL(Data Definition Language) 数据定义语言 </span><br><span class="line">		用来定义数据库对象：数据库、表、列等。关键字：create, drop,alter 等</span><br><span class="line">	2) DML(Data Manipulation Language) 数据操作语言 </span><br><span class="line">		用来对数据库中表的数据进行增、删、改。关键字：insert, delete, update 等</span><br><span class="line">	3) DQL(Data Query Language) 数据查询语言 </span><br><span class="line">		用来查询数据库中表的记录(数据)。关键字：select, where 等</span><br><span class="line">	4) DCL(Data Control Language) 数据控制语言(了解)</span><br><span class="line">		用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等</span><br></pre></td></tr></table></figure>
<h2 id="DDL：操作数据库">DDL：操作数据库</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 操作数据库：CRUD</span><br><span class="line">   1. C(Create): 创建</span><br><span class="line">      * 创建数据库：</span><br><span class="line">        * create database 数据库名称;</span><br><span class="line">      * 创建数据库，判断不存在，再创建：</span><br><span class="line">        * create database if not exists 数据库名称;</span><br><span class="line">      * 创建数据库，并指定字符集</span><br><span class="line">        * create database 数据库名称 character set 字符集名;</span><br><span class="line"></span><br><span class="line">      * 练习： 创建 db4 数据库，判断是否存在，并制定字符集为 gbk</span><br><span class="line">        * create database if not exists db4 character set gbk;</span><br><span class="line">   2. R(Retrieve)：检索(查询)</span><br><span class="line">      * 查询所有数据库的名称:</span><br><span class="line">        * show databases;</span><br><span class="line">      * 查询某个数据库的字符集: 查询某个数据库的创建语句</span><br><span class="line">        * show create database 数据库名称;</span><br><span class="line">   3. U(Update): 修改</span><br><span class="line">      * 修改数据库的字符集</span><br><span class="line">        * alter database 数据库名称 character set 字符集名称;</span><br><span class="line">   4. D(Delete): 删除</span><br><span class="line">      * 删除数据库</span><br><span class="line">        * drop database 数据库名称;</span><br><span class="line">      * 判断数据库存在，存在再删除</span><br><span class="line">        * drop database if exists 数据库名称;</span><br><span class="line">   5. 使用数据库</span><br><span class="line">      * 查询当前正在使用的数据库名称</span><br><span class="line">        * select database();</span><br><span class="line">      * 使用数据库</span><br><span class="line">        * use 数据库名称;</span><br></pre></td></tr></table></figure>
<h3 id="操作数据库实例演示">操作数据库实例演示</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询所有数据库的名称 </span><br><span class="line">SHOW DATABASES;</span><br><span class="line"></span><br><span class="line">-- 查看某个数据库的字符集（查看某个数据库的创建语句）</span><br><span class="line">SHOW CREATE DATABASE mysql;</span><br><span class="line"></span><br><span class="line">-- 判断后(若不存在) 创建 db 数据库，并指定</span><br><span class="line">CREATE DATABASE IF NOT EXISTS db CHARACTER SET utf8;</span><br><span class="line"></span><br><span class="line">-- 修改指定数据库的字符集</span><br><span class="line">ALTER DATABASE db CHARACTER SET gbk;</span><br><span class="line"></span><br><span class="line">-- 判断数据库是否存在，存在则删除</span><br><span class="line">DROP DATABASE IF EXISTS db;</span><br><span class="line"></span><br><span class="line">-- 查询正在使用的数据库名称</span><br><span class="line">SELECT DATABASE();</span><br><span class="line"></span><br><span class="line">-- 使用某个数据库</span><br><span class="line">USE db;</span><br></pre></td></tr></table></figure>
<h2 id="DDL：操作数据表">DDL：操作数据表</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2. 操作表</span><br><span class="line">	1. C(Create): 创建</span><br><span class="line">		* 创建表语法：</span><br><span class="line">			create table 表名(</span><br><span class="line">				列名 1 数据类型 1,</span><br><span class="line">				列名 2 数据类型 2,</span><br><span class="line">				....</span><br><span class="line">				列名 n 数据类型 n</span><br><span class="line">			);</span><br><span class="line">		* 数据库类型：</span><br><span class="line">			1. int：整数类型</span><br><span class="line">			2. double: 小数类型</span><br><span class="line">			3. date: 日期，只包含年月日    yyyy-MM-dd</span><br><span class="line">			4. datetime: 日期，包含年月日时分秒    yyyy-MM-dd HH:mm:ss</span><br><span class="line">			5. timestamp: 时间戳类型	包含年月日时分秒	 yyyy-MM-dd HH:mm:ss	</span><br><span class="line">				* 如果将来不给这个字段赋值，或赋值为 null，则默认使用当前的系统时间，来自动赋值</span><br><span class="line">			6. varchar：字符串</span><br><span class="line">			* 复制表语法：</span><br><span class="line">			* create table 表名 like 被复制的表名;</span><br><span class="line">	2. R(Retrieve)：检索(查询)</span><br><span class="line">		* 查询某个数据库中所有的表名称</span><br><span class="line">			* show tables;</span><br><span class="line">		* 查询表结构</span><br><span class="line">			* desc 表名;</span><br><span class="line">	3. U(Update): 修改</span><br><span class="line">		1. 修改表名</span><br><span class="line">			alter table 表名 rename to 新的表名;</span><br><span class="line">		2. 修改表的字符集</span><br><span class="line">			alter table 表名 character set 字符集名称;</span><br><span class="line">		3. 添加一列</span><br><span class="line">			alter table 表名 add 列名 数据类型;</span><br><span class="line">		4. 修改列名称、类型</span><br><span class="line">			alter table 表名 change 列名 新列别 新数据类型;</span><br><span class="line">			alter table 表名 modify 列名 新数据类型;</span><br><span class="line">		5. 删除列</span><br><span class="line">			alter table 表名 drop 列名;</span><br><span class="line">		6. 修改字段排列顺序 / 在增加的时候指定字段位置：FIRST 或者 AFTER 字段名</span><br><span class="line">            ALTER TABLE 表名 ADD 字段名 数据类型 FIRST;</span><br><span class="line">            ALTER TABLE 表名 ADD 字段名 数据类型 AFTER 字段名;</span><br><span class="line">            ALTER TABLE 表名 CHANGE 字段名 旧字段名 新字段名 新数据类型 FIRST;</span><br><span class="line">            ALTER TABLE 表名 MODIFY 字段名 数据类型 AFTER 字段名;</span><br><span class="line">	4. D(Delete): 删除</span><br><span class="line">		* drop table 表名;</span><br><span class="line">		* drop table  if exists 表名;</span><br></pre></td></tr></table></figure>
<h3 id="操作表实例演示">操作表实例演示</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询某个数据库中所有表名称</span><br><span class="line">SHOW TABLES;</span><br><span class="line"></span><br><span class="line">-- 创建表</span><br><span class="line">CREATE TABLE student(`name` VARCHAR(20), age INT, score DOUBLE(5,2), DATA TIMESTAMP);</span><br><span class="line"></span><br><span class="line">-- 复制表</span><br><span class="line">CREATE TABLE stu LIKE student;</span><br><span class="line">CREATE TABLE IF NOT EXISTS stu LIKE student;</span><br><span class="line"></span><br><span class="line">-- DESC: description, 查询表结构</span><br><span class="line">DESC student;</span><br><span class="line"></span><br><span class="line">-- 修改表名</span><br><span class="line">ALTER TABLE stu RENAME TO teacher;</span><br><span class="line"></span><br><span class="line">-- 修改表的字符集</span><br><span class="line">ALTER TABLE student CHARACTER SET gbk;</span><br><span class="line"></span><br><span class="line">-- 给表添加一列</span><br><span class="line">ALTER TABLE student ADD id INT;</span><br><span class="line"></span><br><span class="line">-- 修改某一列的名称并重新指定该列的数据类型</span><br><span class="line">ALTER TABLE student CHANGE id user_id INT;</span><br><span class="line"></span><br><span class="line">-- 修正某一列的数据类型但不修改列名称</span><br><span class="line">ALTER TABLE student MODIFY user_id BIGINT;</span><br><span class="line"></span><br><span class="line">-- 删除表中的某一列</span><br><span class="line">ALTER TABLE student DROP user_id;</span><br><span class="line"></span><br><span class="line">-- 判断表是否存在, 存在则删除该表</span><br><span class="line">DROP TABLE IF EXISTS teacher;</span><br></pre></td></tr></table></figure>
<h2 id="DML：增删改">DML：增删改</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 添加数据：</span><br><span class="line">	* 语法：</span><br><span class="line">		* insert into 表名 (列名 1, 列名 2,... 列名 n) values(值 1, 值 2,... 值 n);</span><br><span class="line">	* 注意：</span><br><span class="line">		1. 列名和值要一一对应。</span><br><span class="line">		2. 如果表名后，不定义列名，则默认给所有列添加值</span><br><span class="line">			insert into 表名 values(值 1, 值 2,... 值 n);</span><br><span class="line">		3. 除了数字类型，其他类型的值需要使用引号(单双都可以) 引起来</span><br><span class="line">2. 删除数据：</span><br><span class="line">	* 语法：</span><br><span class="line">		* delete from 表名 [where 条件];</span><br><span class="line">	* 注意：</span><br><span class="line">		1. 如果不加条件，则删除表中所有记录。</span><br><span class="line">		2. 如果要删除所有记录</span><br><span class="line">			1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作，效率低</span><br><span class="line">			2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表</span><br><span class="line">3. 修改数据：</span><br><span class="line">	* 语法：</span><br><span class="line">		* update 表名 set 列名 1 = 值 1, 列名 2 = 值 2,... [where 条件];</span><br><span class="line">	* 注意：如果不加任何条件，则会将表中所有记录全部修改。</span><br></pre></td></tr></table></figure>
<h3 id="增删改演示">增删改演示</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 往表中指定的列插入数据 </span><br><span class="line">INSERT INTO student(user_id, NAME, age, score) VALUES(7, &quot; 小傻瓜 &quot;, 12, 72.56);</span><br><span class="line"></span><br><span class="line">-- 按条件删除表中的数据, 如果不加条件则逐条删除数据直到为空表</span><br><span class="line">DELETE FROM student WHERE user_id = 1;</span><br><span class="line"></span><br><span class="line">-- 逐条删除数据直到为空表, 效率慢避免误操作, 慎用</span><br><span class="line">DELETE FROM student;</span><br><span class="line"></span><br><span class="line">-- 删除表, 并创建一个与之前表结构完全相同的空表, 效率高(等价于 DELETE FROM student;) 推荐使用</span><br><span class="line">TRUNCATE TABLE student;</span><br><span class="line"></span><br><span class="line">-- 按条件修改表中的数据</span><br><span class="line">UPDATE student SET age = 17, score = 95.28 WHERE user_id = 1</span><br></pre></td></tr></table></figure>
<h2 id="DQL：查询">DQL：查询</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* select * from 表名;</span><br><span class="line"></span><br><span class="line">1. 查询表中的记录语法：</span><br><span class="line">	select</span><br><span class="line">		字段列表</span><br><span class="line">	from</span><br><span class="line">		表名列表</span><br><span class="line">	where</span><br><span class="line">		条件列表</span><br><span class="line">	group by</span><br><span class="line">		分组字段</span><br><span class="line">	distinct</span><br><span class="line">		去重</span><br><span class="line">	having</span><br><span class="line">		分组之后的条件</span><br><span class="line">	order by</span><br><span class="line">		排序</span><br><span class="line">	limit</span><br><span class="line">		分页限定</span><br><span class="line"></span><br><span class="line">2. 基础查询</span><br><span class="line">	1. 多个字段的查询:</span><br><span class="line">		select 字段名 1，字段名 2... from 表名;</span><br><span class="line">		* 注意：如果查询所有字段，则可以使用 * 来替代字段列表。</span><br><span class="line">	2. 查询多个字段，但去除多余的重复记录：</span><br><span class="line">		* select distinct 字段名 1，字段名 2... from 表名;</span><br><span class="line">	3. 计算列:</span><br><span class="line">		* 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）</span><br><span class="line">		* ifnull(表达式 1, 表达式 2)：null 参与的运算，计算结果都为 null</span><br><span class="line">			* 表达式 1：哪个字段需要判断是否为 null，如果该字段为 null，则替换为表达式 2 的值</span><br><span class="line">	4. 起别名：</span><br><span class="line">		* as：as 也可以省略</span><br><span class="line"></span><br><span class="line">3. 条件查询</span><br><span class="line">	1. where 子句后跟条件</span><br><span class="line">	2. 运算符</span><br><span class="line">		* &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt;(不等于)</span><br><span class="line">		* BETWEEN...AND  </span><br><span class="line">		* IN(集合) </span><br><span class="line">		* LIKE：模糊查询</span><br><span class="line">			* 占位符：</span><br><span class="line">				* _: 单个任意字符</span><br><span class="line">				* %：多个任意字符</span><br><span class="line">		* IS NULL  </span><br><span class="line">		* and  或  &amp;&amp;</span><br><span class="line">		* or   或  || </span><br><span class="line">		* not  或  !</span><br></pre></td></tr></table></figure>
<h3 id="查询演示">查询演示</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查看表中的所有列的记录: SELECT * FROM 表名;</span><br><span class="line">SELECT * FROM student;</span><br><span class="line"></span><br><span class="line">-- 多个字段 (列) 查询语法: SELECT 字段名 1, 字段名 2, ... FROM 表名;</span><br><span class="line">SELECT age, score FROM student;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 多个字段去重语法: SELECT DISTINCT 字段名 1, 字段名 2, ... FROM 表名;</span><br><span class="line"> */</span><br><span class="line">-- 去重被选择的多个字段 (列) 中存在完全重复的字段, 只保留一个 </span><br><span class="line">SELECT DISTINCT age, score FROM student;</span><br><span class="line"></span><br><span class="line">-- 选择多个字段(列), 并对特定的列进行四则运算, 并作为(AS) 新列</span><br><span class="line">SELECT DISTINCT age, score, age * 100 + IFNULL(score, 0) AS combine FROM student;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"> * 按条件查询语法：WHERE 限制条件</span><br><span class="line"> * 注意: 判断是否为空用 xxx IS NULL / xxx IS NOT NULL</span><br><span class="line"> */</span><br><span class="line">SELECT * FROM student WHERE age &gt; 10 AND age &lt; 16;</span><br><span class="line">SELECT * FROM student WHERE age BETWEEN 11 AND 15;</span><br><span class="line">SELECT * FROM student WHERE age IN(14,16,17);</span><br><span class="line">SELECT * FROM student WHERE score IS NULL;</span><br><span class="line">SELECT * FROM student WHERE score IS NOT NULL;</span><br><span class="line">SELECT * FROM student WHERE age &lt;&gt; 16; -- &lt;&gt; 表示不等于</span><br><span class="line">SELECT * FROM student WHERE score &lt; 82 OR score &gt; 88;</span><br><span class="line"></span><br><span class="line">-- 模糊查询：查询名字第一个字是 小 的数据(一个 % 表示多个任意字符)</span><br><span class="line">SELECT * FROM student WHERE NAME LIKE &quot; 小 %&quot;;</span><br><span class="line"></span><br><span class="line">-- 模糊查询：查询名字第一个字是 小 的数据(一个_表示任意一个字符)</span><br><span class="line">SELECT * FROM student WHERE NAME LIKE &quot; 小__&quot;;</span><br><span class="line"></span><br><span class="line">-- 模糊查询：查询名字中包含 小 的数据</span><br><span class="line">SELECT * FROM student WHERE NAME LIKE &quot;% 小 %&quot;;</span><br><span class="line"></span><br><span class="line">-- 模糊查询：查询名字中不包含 小 的数据</span><br><span class="line">SELECT * FROM student WHERE NAME NOT LIKE &quot;% 小 %&quot;;</span><br></pre></td></tr></table></figure>
<h2 id="DQL：排序查询">DQL：排序查询</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 排序查询</span><br><span class="line">	* 语法： order by 子句</span><br><span class="line">		* order by 排序字段 1 排序方式 1, 排序字段 2 排序方式 2...;</span><br><span class="line">	* 排序方式：</span><br><span class="line">		* ASC：升序，默认的</span><br><span class="line">		* DESC：降序</span><br><span class="line">	* 注意：</span><br><span class="line">		* 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件</span><br><span class="line">2. 聚合函数：将一列数据作为一个整体，进行纵向的计算。</span><br><span class="line"></span><br><span class="line">   1. count：计算个数</span><br><span class="line">      1. 一般选择非空的列：主键</span><br><span class="line">      2. count(*)</span><br><span class="line">   2. max：计算最大值</span><br><span class="line">   3. min：计算最小值</span><br><span class="line">   4. sum：计算和</span><br><span class="line">   5. avg：计算平均值</span><br><span class="line"></span><br><span class="line">   * 注意：聚合函数的计算，排除 null 值。</span><br><span class="line">     解决方案：</span><br><span class="line">      	1. 选择不包含非空的列进行计算</span><br><span class="line">        2. IFNULL 函数</span><br></pre></td></tr></table></figure>
<h3 id="排序查询演示">排序查询演示</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* </span><br><span class="line"> * 排序查询语法: ORDER BY 排序字段 1 排序方法 1, 排序字段 2 排序方法 2, ...</span><br><span class="line"> * 升序 ASC, 降序 DESC 排序 </span><br><span class="line"> */</span><br><span class="line">SELECT * FROM student ORDER BY score ASC;</span><br><span class="line"></span><br><span class="line">-- 按第一规则 age 升序, age 相同时按第二规则 score 降序</span><br><span class="line">SELECT * FROM student ORDER BY age ASC, score DESC;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"> * 聚合函数: 将一列数据作为一个整体, 进行纵向计算.</span><br><span class="line"> * 	COUNT(), MAX(), MIN(), SUM(), AVG()</span><br><span class="line"> */</span><br><span class="line">-- 统计数据条数</span><br><span class="line">SELECT COUNT(user_id) FROM student;</span><br><span class="line"></span><br><span class="line">-- 统计数据条数(COUNT 默认不统计 null, 使用 IFNULL 增加 null 的计数)</span><br><span class="line">SELECT COUNT(IFNULL(score, 0)) FROM student;</span><br><span class="line"></span><br><span class="line">-- 聚合函数的使用</span><br><span class="line">SELECT MAX(score), MIN(age), SUM(score), AVG(age) FROM student;</span><br></pre></td></tr></table></figure>
<h2 id="DQL：分组查询">DQL：分组查询</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3. 分组查询:</span><br><span class="line">	1. 语法： group by 分组字段；</span><br><span class="line">	2. 注意：</span><br><span class="line">		1. 分组之后查询的字段：分组字段、聚合函数</span><br><span class="line">		2. where 和 having 的区别？</span><br><span class="line">			1. where 在分组 group by 之前进行限定，如果不满足条件，则不参与分组。</span><br><span class="line">			2. having 在分组 group by 之后进行限定，如果不满足结果，则不会被查询出来。</span><br><span class="line">			3. where 后不可以跟聚合函数，having 可以进行聚合函数的判断。</span><br></pre></td></tr></table></figure>
<h3 id="分组查询演示">分组查询演示</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 按照性别分组，分别查询男、女同学的平均分</span><br><span class="line">SELECT sex, AVG(math) FROM student GROUP BY sex;</span><br><span class="line"></span><br><span class="line">-- 按照性别分组，分别查询男女同学的平均分和人数</span><br><span class="line">SELECT sex, AVG(math), COUNT(id) FROM student GROUP BY sex;</span><br><span class="line"></span><br><span class="line">--  按照性别分组，分别查询男女同学的平均分、人数，要求：分数低于 70 分的人不参与分组</span><br><span class="line">SELECT sex, AVG(math), COUNT(id) FROM student WHERE math &gt;= 70 GROUP BY sex;</span><br><span class="line"></span><br><span class="line">--  按照性别分组，分别查询男女同学的平均分 要求：分数低于 70 分的人不参与分组，分组之后人数要大于 2 个人才进行显示</span><br><span class="line">SELECT</span><br><span class="line">    sex,</span><br><span class="line">    AVG (math),</span><br><span class="line">    COUNT (id) AS cnt</span><br><span class="line">FROM</span><br><span class="line">    student</span><br><span class="line">WHERE math &gt;= 70 </span><br><span class="line">GROUP BY sex</span><br><span class="line">HAVING COUNT (id) &gt; 0;</span><br></pre></td></tr></table></figure>
<h2 id="DQL：分页查询">DQL：分页查询</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4. 分页查询</span><br><span class="line">	1. 语法：limit 开始的索引, 每页查询的条数;</span><br><span class="line">	2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数</span><br><span class="line">		-- 每页显示 3 条记录 </span><br><span class="line">		SELECT * FROM student LIMIT 0,3; -- 第 1 页</span><br><span class="line">		SELECT * FROM student LIMIT 3,3; -- 第 2 页</span><br><span class="line">		SELECT * FROM student LIMIT 6,3; -- 第 3 页</span><br><span class="line">	3. limit 是一个 MySQL&quot; 方言 &quot;</span><br></pre></td></tr></table></figure>
<h2 id="约束">约束</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。	</span><br><span class="line">* 分类：</span><br><span class="line">	1. 主键约束： primary key</span><br><span class="line">	2. 非空约束： not null</span><br><span class="line">	3. 唯一约束： unique</span><br><span class="line">	4. 外键约束： foreign key</span><br></pre></td></tr></table></figure>
<h3 id="非空约束演示">非空约束演示</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 约束: 非空约束(NOT NULL)、唯一约束(UNIQUE)、主键约束(PRIMARY KEY)、外键约束(FOREIGN KEY)</span><br><span class="line"> */</span><br><span class="line">-- 非空约束: 1. 在创建表时添加非空约束</span><br><span class="line">CREATE TABLE stu (age INT, `name` VARCHAR (20) NOT NULL);</span><br><span class="line"></span><br><span class="line">-- 非空约束: 2. 删除非空约束, 使用 MODIFY</span><br><span class="line">ALTER TABLE stu MODIFY `name` VARCHAR (20);</span><br><span class="line"></span><br><span class="line">-- 非空约束: 3. 创建表时未添加非空约束, 创建表之后添加非空约束</span><br><span class="line">ALTER TABLE stu MODIFY `name` VARCHAR (20) NOT NULL;</span><br></pre></td></tr></table></figure>
<h3 id="唯一约束演示">唯一约束演示</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 注意 mysql 中，唯一约束限定的列的值可以有多个 null */</span><br><span class="line"></span><br><span class="line">-- 唯一约束: 在创建表时添加唯一约束</span><br><span class="line">CREATE TABLE stu (id BIGINT UNIQUE, age INT, `name` VARCHAR (20) NOT NULL);</span><br><span class="line"></span><br><span class="line">-- 唯一约束: 2. 删除唯一约束, 使用 drop index</span><br><span class="line">ALTER TABLE stu DROP INDEX id;</span><br><span class="line"></span><br><span class="line">-- 唯一约束: 3. 创建表时未添加唯一约束, 创建表之后添加唯一约束</span><br><span class="line">ALTER TABLE stu MODIFY id BIGINT UNIQUE;</span><br></pre></td></tr></table></figure>
<h3 id="主键约束演示">主键约束演示</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 主键约束：primary key</span><br><span class="line"> * 注意：</span><br><span class="line"> * 	1. 含义：非空且唯一</span><br><span class="line"> * 	2. 一张表只能有一个字段为主键</span><br><span class="line"> * 	3. 主键就是表中记录的唯一标识</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">-- 主键约束: 1. 在创建表时添加主键约束</span><br><span class="line">CREATE TABLE stu (id BIGINT PRIMARY KEY, age INT, `name` VARCHAR (20));</span><br><span class="line"></span><br><span class="line">-- 主键约束: 2. 删除主键约束使用 DROP PRIMARY KEY</span><br><span class="line">ALTER TABLE stu DROP PRIMARY KEY;</span><br><span class="line"></span><br><span class="line">-- 主键约束: 3. 创建表时未添加主键约束, 创建表之后添加主键约束(此时主键字段数据不能有重复)</span><br><span class="line">ALTER TABLE stu MODIFY id BIGINT PRIMARY KEY;</span><br><span class="line"></span><br><span class="line">-- 自动增长(AUTO_INCREMENT)：常与主键约束一起使用, </span><br><span class="line">-- 使用自动增长要求数据类型为数值型, 可以实现值的自动增长.</span><br><span class="line">ALTER TABLE stu MODIFY id BIGINT PRIMARY KEY AUTO_INCREMENT;</span><br></pre></td></tr></table></figure>
<h3 id="外键约束演示">外键约束演示</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 外键约束: foreign key, 用于让不同的表之间产生关系, 从而保证数据的正确性.</span><br><span class="line"> * 外键约束语法: CONSTRAINT 外键名称 FOREIGN KEY (外键列) REFERENCES 主表名称(主表列名称)</span><br><span class="line"> * 注意: 创建外键约束的主列表名称要求不能出现重复数据(可以使用唯一约束)！</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">-- 外键约束: 在创建表时添加外键约束约束</span><br><span class="line">CREATE TABLE com (-- 主表 com</span><br><span class="line">    sex_id INT UNIQUE,</span><br><span class="line">    sex VARCHAR (20) UNIQUE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE stu (</span><br><span class="line">    id BIGINT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    age INT,</span><br><span class="line">    `name` VARCHAR (20),</span><br><span class="line">    sex INT, -- 外键列</span><br><span class="line">    CONSTRAINT sex_ky FOREIGN KEY (sex) REFERENCES com (sex_id) -- 外键约束</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 外键约束: 2. 删除外键约束, 使用 DROP FOREIGN KEY 外键名称</span><br><span class="line">ALTER TABLE stu DROP FOREIGN KEY sex_ky;</span><br><span class="line"></span><br><span class="line">-- 外键约束: 3. 创建表时未添加外键约束, 创建表之后添加外键约束, ADD 外键约束</span><br><span class="line">ALTER TABLE stu ADD constraint sex_ky foreign key (sex) references com (sex_id);</span><br></pre></td></tr></table></figure>
<h3 id="级联操作演示">级联操作演示</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 外键级联语法: 级联更新(ON UPDATE CASCADE), 级联删除(ON DELETE CASCADE)</span><br><span class="line"> * 	注意: 外键级联操作要配合外键约束使用</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">-- 外键级联: 给外键约束添加外键级联, 添加时要先删除外键约束再添加外键级联</span><br><span class="line">ALTER TABLE stu</span><br><span class="line">    DROP FOREIGN KEY sex_ky; -- 删除外键约束</span><br><span class="line"></span><br><span class="line">ALTER TABLE stu</span><br><span class="line">    ADD CONSTRAINT sex_ky FOREIGN KEY (sex) REFERENCES com (sex_id) ON UPDATE CASCADE ON DELETE CASCADE; -- 添加外键级联</span><br></pre></td></tr></table></figure>
<h2 id="数据库设计之多表关系">数据库设计之多表关系</h2>
<pre><code>1. 多表之间的关系
	1. 分类：
		1. 一对一(了解)：
			* 如：人和身份证
			* 分析：一个人只有一个身份证，一个身份证只能对应一个人
		2. 一对多(多对一)：
			* 如：部门和员工
			* 分析：一个部门有多个员工，一个员工只能对应一个部门
		3. 多对多：
			* 如：学生和课程
			* 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择
	2. 实现关系：
		1. 一对多(多对一)：
			* 如：部门和员工
			* 实现方式：在「多」的一方建立外键，指向「一」的一方的主键
		2. 多对多：
			* 如：学生和课程
			* 实现方式：多对多关系实现需要借助第三张中间表，中间表至少包含两个字段，
					    这两个字段作为第三张表的外键，分别指向两张表的主键
		3. 一对一(了解)：
			* 如：人和身份证
			* 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键
</code></pre>
<h3 id="多表关系实例演示">多表关系实例演示</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 四张表：用户表 A、旅游线路表 B、旅游线路分类表 C、(旅游线路收藏表 D)</span><br><span class="line"> * 分析关系：旅游线路分类表 C 和旅游线路表 B 关系为「一对多」, </span><br><span class="line"> * 		   用户表 A 和旅游线路表 B 关系为「多对多」, 用户可以收藏多张线路表, 一张线路表可以被多用户收藏,</span><br><span class="line"> * 		   旅游线路收藏表 D 为「中间表」.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>多表关系实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> *  -- 创建旅游线路分类表 tab_category</span><br><span class="line"> *  cid 旅游线路分类主键，自动增长</span><br><span class="line"> *  cname 旅游线路分类名称非空，唯一，字符串 100</span><br><span class="line"> */</span><br><span class="line">CREATE TABLE tab_category (</span><br><span class="line">	cid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	cname VARCHAR(100) NOT NULL UNIQUE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> *  -- 创建旅游线路表 tab_route</span><br><span class="line"> *  rid 旅游线路主键，自动增长</span><br><span class="line"> *  rname 旅游线路名称非空，唯一，字符串 100</span><br><span class="line"> *  price 价格</span><br><span class="line"> *  rdate 上架时间，日期类型</span><br><span class="line"> *  cid 外键，所属分类</span><br><span class="line"> */</span><br><span class="line">CREATE TABLE tab_route(</span><br><span class="line">	rid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	rname VARCHAR(100) NOT NULL UNIQUE,</span><br><span class="line">	price DOUBLE,</span><br><span class="line">	rdate DATE,</span><br><span class="line">	cid INT, -- 一对多实现方式：在「多」的一方建立外键，指向「一」的一方的主键</span><br><span class="line">	FOREIGN KEY (cid) REFERENCES tab_category(cid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> *  -- 创建用户表 tab_user</span><br><span class="line"> *  uid 用户主键，自动增长</span><br><span class="line"> *  username 用户名长度 100，唯一，非空</span><br><span class="line"> *  password 密码长度 30，非空</span><br><span class="line"> *  name 真实姓名长度 100</span><br><span class="line"> *  birthday 生日</span><br><span class="line"> *  sex 性别，定长字符串 1，默认为男性</span><br><span class="line"> *  telephone 手机号，字符串 11</span><br><span class="line"> *  email 邮箱，字符串长度 100</span><br><span class="line"> */</span><br><span class="line">CREATE TABLE tab_user (</span><br><span class="line">	uid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	username VARCHAR(100) UNIQUE NOT NULL,</span><br><span class="line">	PASSWORD VARCHAR(30) NOT NULL,</span><br><span class="line">	NAME VARCHAR(100),</span><br><span class="line">	birthday DATE,</span><br><span class="line">	sex CHAR(1) DEFAULT &#x27; 男 &#x27;,</span><br><span class="line">	telephone VARCHAR(11),</span><br><span class="line">	email VARCHAR(100)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> *  -- 创建收藏表 tab_favorite</span><br><span class="line"> *  rid 旅游线路 id，外键</span><br><span class="line"> *  date 收藏时间</span><br><span class="line"> *  uid 用户 id，外键</span><br><span class="line"> *  rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次</span><br><span class="line">*/</span><br><span class="line">CREATE TABLE tab_favorite (</span><br><span class="line">	rid INT, -- 线路 id</span><br><span class="line">	uid INT, -- 用户 id</span><br><span class="line">    `data` DATETIME,</span><br><span class="line">	-- 创建复合主键(联合主键)</span><br><span class="line">	PRIMARY KEY(rid,uid), -- 多对多关系实现需要借助第三张中间表，中间表至少包含两个字段，</span><br><span class="line">					      -- 这两个字段作为第三张表的外键，分别指向两张表的主键</span><br><span class="line">	FOREIGN KEY (rid) REFERENCES tab_route(rid),</span><br><span class="line">	FOREIGN KEY(uid) REFERENCES tab_user(uid)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="数据库设计的范式">数据库设计的范式</h2>
<pre><code>2. 数据库设计的范式

 	* 概念：设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，
 		   这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。
 	
	目前关系数据库有六种范式：
		   第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、
		   巴斯 - 科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）

	* 分类：
		一. 第一范式（1NF）：每一列都是不可分割的原子数据项
		二. 第二范式（2NF）：在 1NF 的基础上，非码属性必须完全依赖于码，
						（在 1NF 基础上, 消除非主属性对主码的部分函数依赖）
		三. 第三范式（3NF）：在 2NF 基础上, 任何非主属性不依赖于其它非主属性
						（在 2NF 基础上, 消除传递依赖）
	
	* 几个概念：
		1. 函数依赖：A--&gt;B, 如果通过 A 属性 (属性组) 的值，可以确定唯一 B 属性的值, 则称 B 依赖于 A
			# 表结构: &lt; 学号 | 姓名 | 系名 | 系主任 | 课程 | 分数 &gt;
			例如：学号 --&gt; 姓名,  (学号，课程名称)--&gt; 分数
		
		2. 完全函数依赖：A--&gt;B, 如果 A 是一个属性组，则 B 属性值的确定需要依赖于 A 属性组中「所有」属性值
			例如：(学号，课程名称)--&gt; 分数
		
		3. 部分函数依赖：A--&gt;B, 如果 A 是一个属性组，则 B 属性值的确定只需要依赖于 A 属性组中「部分」属性值
			例如：(学号，课程名称)--&gt; 姓名, 不需要依赖于 A 属性组中的课程名称就可以确定姓名
		
		4. 传递函数依赖：A--&gt;B, B--&gt;C, 如果通过 A 属性 (属性组) 的值，可以确定唯一 B 属性的值, 
					  再通过 B 属性 (属性组) 的值可以确定唯一 C 属性的值, 则称 C 传递函数依赖于 A
			例如：学号 --&gt; 系名，系名 --&gt; 系主任
		
		5. 码：在一张表中, 一个属性 (属性组) 被其他所有属性所「完全依赖」, 则称这个属性 (属性组) 为该表的码
			* 主属性：码属性组中的所有属性
			* 非主属性：除码属性组以外的属性
			例如：该表中码为 (学号，课程名称), 学号、课程名称为主属性
			     姓名 | 系名 | 系主任 | 分数 被 (学号，课程名称)码 所完全依赖
</code></pre>
<h2 id="数据库的备份和还原">数据库的备份和还原</h2>
<pre><code>1. 命令行：
	* 语法：
		* 命令行备份： mysqldump -u 用户名 -p 密码 数据库名称 &gt; 保存的路径
		* 命令行还原：
			1. 登录数据库  2. 创建数据库  3. 使用数据库  4. 执行文件: source 文件路径
</code></pre>
<h3 id="数据库备份和还原实例演示">数据库备份和还原实例演示</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 命令行备份 */</span><br><span class="line">mysqldump -uroot -proot db &gt; d:/save_path/save_name.sql</span><br><span class="line"></span><br><span class="line">DROP DATABASE db; -- 删除数据库</span><br><span class="line"></span><br><span class="line">/* 命令行还原 */</span><br><span class="line">SHOW DATABASES; -- 登陆数据库</span><br><span class="line">CREATE DATABASE db; -- 创建数据库</span><br><span class="line">USE db; -- 使用数据库</span><br><span class="line">source d:/save_path/save_name.sql -- 执行 SQL 文件还原数据库</span><br></pre></td></tr></table></figure>
<h2 id="多表查询">多表查询</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 准备 SQL 数据</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">-- 创建部门表</span><br><span class="line">CREATE TABLE dept (</span><br><span class="line">    id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    `name` VARCHAR (20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO dept (`name`)</span><br><span class="line">VALUES</span><br><span class="line">    (&#x27; 开发部 &#x27;),</span><br><span class="line">    (&#x27; 市场部 &#x27;),</span><br><span class="line">    (&#x27; 财务部 &#x27;);</span><br><span class="line"></span><br><span class="line">-- 创建员工表</span><br><span class="line">CREATE TABLE emp (</span><br><span class="line">    id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    `name` VARCHAR (10),</span><br><span class="line">    gender CHAR (1),</span><br><span class="line">    salary DOUBLE,</span><br><span class="line">    join_date DATE,</span><br><span class="line">    dept_id INT,</span><br><span class="line">    FOREIGN KEY (dept_id) REFERENCES dept (id) -- 外键, 关联部门表(部门表的主键)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO emp (</span><br><span class="line">    `name`,</span><br><span class="line">    gender,</span><br><span class="line">    salary,</span><br><span class="line">    join_date,</span><br><span class="line">    dept_id</span><br><span class="line">)</span><br><span class="line">VALUES </span><br><span class="line">    (&#x27; 孙悟空 &#x27;, &#x27; 男 &#x27;, 7200, &#x27;2013-02-24&#x27;, 1),</span><br><span class="line">    (&#x27; 猪八戒 &#x27;, &#x27; 男 &#x27;, 3600, &#x27;2010-12-02&#x27;, 2),</span><br><span class="line">    (&#x27; 唐僧 &#x27;, &#x27; 男 &#x27;, 9000, &#x27;2008-08-08&#x27;, 2),</span><br><span class="line">    (&#x27; 白骨精 &#x27;, &#x27; 女 &#x27;, 5000, &#x27;2015-10-07&#x27;, 3),</span><br><span class="line">    (&#x27; 蜘蛛精 &#x27;, &#x27; 女 &#x27;, 4500, &#x27;2011-03-14&#x27;, 1);</span><br></pre></td></tr></table></figure>
<h3 id="内连接与外连接查询">内连接与外连接查询</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 笛卡尔积：</span><br><span class="line">	* 有两个集合 A, B, 取这两个集合的所有可能的组合情况构成的表即为笛卡尔积.</span><br><span class="line">	* 要完成多表查询，需要消除无用的数据.</span><br><span class="line"></span><br><span class="line">* 多表查询的分类：</span><br><span class="line">	1. 内连接查询：</span><br><span class="line">		1. 隐式内连接：使用 where 条件消除无用数据 </span><br><span class="line">			* 例如：</span><br><span class="line">			-- 查询所有员工信息和对应的部门信息</span><br><span class="line">			SELECT * FROM emp, dept WHERE emp.`dept_id` = dept.`id`;</span><br><span class="line">			</span><br><span class="line">			-- 查询员工表的名称、性别, 部门表的名称</span><br><span class="line">			SELECT</span><br><span class="line">                emp.name,</span><br><span class="line">                emp.gender,</span><br><span class="line">                dept.name</span><br><span class="line">            FROM</span><br><span class="line">                emp,</span><br><span class="line">                dept</span><br><span class="line">            WHERE emp.`dept_id` = dept.`id`;</span><br><span class="line"></span><br><span class="line">       	2. 显式内连接：</span><br><span class="line">			* 语法： SELECT 字段列表 FROM 表名 1 [INNER] JOIN 表名 2 ON 连接条件;</span><br><span class="line">			* 例如：</span><br><span class="line">				SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`;</span><br><span class="line">		</span><br><span class="line">		3. 内连接查询：</span><br><span class="line">			1. 从哪些表中查询数据  2. 条件是什么  3. 查询哪些字段</span><br><span class="line">	</span><br><span class="line">	2. 外连接查询：</span><br><span class="line">		1. 左外连接：查询的是左表所有数据以及其左表与右表的交集部分.</span><br><span class="line">			* 语法： SELECT 字段列表 FROM 表 1 LEFT [OUTER] JOIN 表 2 ON 连接条件;</span><br><span class="line">			* 例子：</span><br><span class="line">			    -- 查询所有员工信息, 如果员工有部门, 则查询部门名称, 没有部门, 则不显示部门名称</span><br><span class="line">			    -- 注: 如果简单的使用隐式内连接的话, 没有部门(NULL) 的员工将不会被查询到</span><br><span class="line">			    SELECT</span><br><span class="line">                    t1.*,</span><br><span class="line">                    t2.`name`</span><br><span class="line">                FROM</span><br><span class="line">                    emp t1</span><br><span class="line">                    LEFT JOIN dept t2</span><br><span class="line">                        ON t1.`dept_id` = t2.`id`;		</span><br><span class="line">		2. 右外连接：查询的是右表所有数据以及其右表与左表的交集部分.</span><br><span class="line">			* 语法： SELECT 字段列表 FROM 表 1 RIGHT [OUTER] JOIN 表 2 ON 连接条件;</span><br><span class="line">			* 例子：</span><br><span class="line">				SELECT</span><br><span class="line">                    t1.*,</span><br><span class="line">                    t2.`name`</span><br><span class="line">                FROM</span><br><span class="line">                    dept t1</span><br><span class="line">                    RIGHT JOIN emp t2</span><br><span class="line">                        ON t1.`id` = t2.`dept_id`;</span><br><span class="line">        3. 全外连接：显示左右两个表全部记录</span><br><span class="line">        	* 语法：左外连接语句 union 右外连接语句;</span><br><span class="line">        	* union 与 union all 的区别： union 会去掉相同的纪录, union all 不会去掉相同记录</span><br></pre></td></tr></table></figure>
<h3 id="子查询">子查询</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3. 子查询：</span><br><span class="line">	* 概念：查询中嵌套查询，称嵌套查询为子查询。</span><br><span class="line">		-- 查询工资最高的员工信息, 一条 sql 就完成这个操作, 子查询</span><br><span class="line">		SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp);</span><br><span class="line"></span><br><span class="line">	* 子查询的不同情况：</span><br><span class="line">		1. 子查询的结果是「单行单列」的：</span><br><span class="line">			* 子查询可以作为条件，使用运算符 &gt; &gt;= &lt; &lt;= = 来判断</span><br><span class="line">			-- 查询员工工资小于平均工资的人</span><br><span class="line">			SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp);</span><br><span class="line"></span><br><span class="line">		2. 子查询的结果是「多行单列」的：</span><br><span class="line">			* 子查询可以作为条件，使用运算符 IN 来判断</span><br><span class="line">			-- 查询 &#x27; 财务部 &#x27; 和 &#x27; 市场部 &#x27; 所有的员工信息, 子查询</span><br><span class="line">			SELECT</span><br><span class="line">                *</span><br><span class="line">            FROM</span><br><span class="line">                emp</span><br><span class="line">            WHERE dept_id IN</span><br><span class="line">                (SELECT</span><br><span class="line">                    id</span><br><span class="line">                FROM</span><br><span class="line">                    dept</span><br><span class="line">                WHERE NAME IN (&#x27; 财务部 &#x27;, &#x27; 市场部 &#x27;));</span><br><span class="line"></span><br><span class="line">		3. 子查询的结果是多行多列的：</span><br><span class="line">			* 子查询可以作为一张「虚拟表」参与查询</span><br><span class="line">			-- 查询员工入职日期是 2011-11-11 日之后的员工信息和部门信息, 子查询</span><br><span class="line">			SELECT</span><br><span class="line">                *</span><br><span class="line">            FROM</span><br><span class="line">                dept t1,</span><br><span class="line">                (SELECT</span><br><span class="line">                    *</span><br><span class="line">                FROM</span><br><span class="line">                    emp</span><br><span class="line">                WHERE emp.`join_date` &gt; &#x27;2011-11-11&#x27;) t2 -- 虚拟表</span><br><span class="line">            WHERE t1.id = t2.dept_id;</span><br><span class="line">				</span><br><span class="line">			-- 普通内连接</span><br><span class="line">			SELECT</span><br><span class="line">                *</span><br><span class="line">            FROM</span><br><span class="line">                dept t1,</span><br><span class="line">                emp t2</span><br><span class="line">            WHERE t1.`id` = t2.`dept_id`</span><br><span class="line">                AND t2.`join_date` &gt; &#x27;2011-11-11&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="多表查询练习">多表查询练习</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 部门表</span><br><span class="line">CREATE TABLE dept (</span><br><span class="line">	id INT PRIMARY KEY PRIMARY KEY, -- 部门 id</span><br><span class="line">	dname VARCHAR(50), -- 部门名称</span><br><span class="line">	loc VARCHAR(50) -- 部门所在地</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 职务表，职务名称，职务描述</span><br><span class="line">CREATE TABLE job (</span><br><span class="line">	id INT PRIMARY KEY,</span><br><span class="line">    jname VARCHAR(20),</span><br><span class="line">    description VARCHAR(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 员工表</span><br><span class="line">CREATE TABLE emp (</span><br><span class="line">	id INT PRIMARY KEY, -- 员工 id</span><br><span class="line">    ename VARCHAR(50), -- 员工姓名</span><br><span class="line">    job_id INT, -- 职务 id</span><br><span class="line">    mgr INT , -- 上级领导</span><br><span class="line">    joindate DATE, -- 入职日期</span><br><span class="line">    salary DECIMAL(7,2), -- 工资</span><br><span class="line">    bonus DECIMAL(7,2), -- 奖金</span><br><span class="line">    dept_id INT, -- 所在部门编号</span><br><span class="line">    CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id),</span><br><span class="line">    CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 工资等级表</span><br><span class="line">CREATE TABLE salarygrade (</span><br><span class="line">    grade INT PRIMARY KEY, -- 级别</span><br><span class="line">    losalary INT, -- 最低工资</span><br><span class="line">    hisalary INT  -- 最高工资</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 部门表 dept 和员工表 emp 是一对多的关系, 职务表 job 和员工表 emp 是一对多的关系</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line"> -- 需求：</span><br><span class="line"></span><br><span class="line">-- 1. 查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述</span><br><span class="line">SELECT</span><br><span class="line">    emp.`id`,</span><br><span class="line">    emp.`ename`,</span><br><span class="line">    emp.`salary`,</span><br><span class="line">    job.`jname`,</span><br><span class="line">    job.`description`</span><br><span class="line">FROM</span><br><span class="line">    emp,</span><br><span class="line">    job</span><br><span class="line">WHERE emp.`job_id` = job.`id`;</span><br><span class="line"></span><br><span class="line">-- 2. 查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置</span><br><span class="line">SELECT</span><br><span class="line">    emp.`id`,</span><br><span class="line">    emp.`ename`,</span><br><span class="line">    emp.`salary`,</span><br><span class="line">    job.`jname`,</span><br><span class="line">    job.`description`,</span><br><span class="line">    dept.`dname`,</span><br><span class="line">    dept.`loc`</span><br><span class="line">FROM</span><br><span class="line">    emp,</span><br><span class="line">    job,</span><br><span class="line">    dept</span><br><span class="line">WHERE emp.`dept_id` = dept.`id` AND emp.`job_id` = job.`id`;</span><br><span class="line"></span><br><span class="line">-- 3. 查询员工姓名，工资，工资等级</span><br><span class="line">SELECT</span><br><span class="line">    t1.`ename`,</span><br><span class="line">    t1.`salary`,</span><br><span class="line">    t2.`grade`</span><br><span class="line">FROM</span><br><span class="line">    emp t1,</span><br><span class="line">    salarygrade t2</span><br><span class="line">WHERE t1.`salary` BETWEEN t2.`losalary`</span><br><span class="line">    AND t2.`hisalary`;</span><br><span class="line"></span><br><span class="line">-- 4. 查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级</span><br><span class="line">SELECT</span><br><span class="line">    t1.`ename`,</span><br><span class="line">    t1.`salary`,</span><br><span class="line">    t3.`jname`,</span><br><span class="line">    t3.`description`,</span><br><span class="line">    t2.`dname`,</span><br><span class="line">    t2.`loc`,</span><br><span class="line">    t4.`grade`</span><br><span class="line">FROM</span><br><span class="line">    emp t1,</span><br><span class="line">    dept t2,</span><br><span class="line">    job t3,</span><br><span class="line">    salarygrade t4</span><br><span class="line">WHERE t1.`job_id` = t3.`id`</span><br><span class="line">    AND t1.`dept_id` = t2.`id`</span><br><span class="line">    AND t1.`salary` BETWEEN t4.`losalary`</span><br><span class="line">    AND t4.`hisalary`;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 5. 查询出部门编号、部门名称、部门位置、部门人数</span><br><span class="line">SELECT</span><br><span class="line">	t2.`id`,</span><br><span class="line">	t2.`dname`,</span><br><span class="line">	t2.`loc`,</span><br><span class="line">	COUNT(t1.`id`) AS &#x27; 部门人数 &#x27;</span><br><span class="line">	</span><br><span class="line">FROM</span><br><span class="line">	emp t1,</span><br><span class="line">	dept t2</span><br><span class="line">WHERE</span><br><span class="line">	t1.`dept_id` = t2.`id`</span><br><span class="line">GROUP BY</span><br><span class="line">	t1.`dept_id`;</span><br><span class="line"></span><br><span class="line">-- 使用子查询的结果是多行多列的, 可以作为一张「虚拟表」参与查询</span><br><span class="line">SELECT</span><br><span class="line">    t2.`id`,</span><br><span class="line">    t2.`dname`,</span><br><span class="line">    t2.`loc`,</span><br><span class="line">    t1.` 部门人数 `</span><br><span class="line">FROM</span><br><span class="line">    (SELECT</span><br><span class="line">        dept_id,</span><br><span class="line">        COUNT (id) AS &quot; 部门人数 &quot;</span><br><span class="line">    FROM</span><br><span class="line">        emp</span><br><span class="line">    GROUP BY emp.`dept_id`) AS t1,</span><br><span class="line">    dept AS t2</span><br><span class="line">WHERE t1.`dept_id` = t2.`id`;</span><br><span class="line"></span><br><span class="line">-- 6. 查询所有员工的姓名及其直接上级的姓名, 没有领导的员工也需要查询</span><br><span class="line">SELECT</span><br><span class="line">    t1.`ename` AS &quot; 员工姓名 &quot;,</span><br><span class="line">    t2.`ename` AS &quot; 直接上级 &quot; </span><br><span class="line">FROM</span><br><span class="line">    emp t1 -- emp t1, emp t2 成为「自相关」</span><br><span class="line">    LEFT JOIN emp t2 -- 查询左表的数据和其交集的数据, 左外连接</span><br><span class="line">        ON t1.`mgr` = t2.`id`;</span><br></pre></td></tr></table></figure>
<h2 id="事务">事务</h2>
<h3 id="事务的使用">事务的使用</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 事务的基本介绍 </span><br><span class="line">	1. 概念：</span><br><span class="line">		*  如果一个包含多个步骤的业务操作「被事务管理」，那么这些业务操作要么同时成功，要么同时失败。</span><br><span class="line">		</span><br><span class="line">	2. 操作：</span><br><span class="line">		1. 开启事务： START TRANSACTION;</span><br><span class="line">		2. 回滚： ROLLBACK;</span><br><span class="line">		3. 提交： COMMIT;</span><br><span class="line">	</span><br><span class="line">	3. MySQL 数据库中事务默认自动提交</span><br><span class="line">		</span><br><span class="line">		* 事务提交的两种方式：</span><br><span class="line">			* 自动提交：</span><br><span class="line">				* MySQL 数据库默认是自动提交事务</span><br><span class="line">				* 一条 DML(增删改) 语句会自动提交一次事务</span><br><span class="line">			* 手动提交：</span><br><span class="line">				* Oracle 数据库默认是手动提交事务</span><br><span class="line">				* 需要先开启事务，再提交</span><br><span class="line">		* 修改事务的默认提交方式：</span><br><span class="line">			* 查看事务的默认提交方式： SELECT @@autocommit; -- 1 代表自动提交  0 代表手动提交</span><br><span class="line">			* 修改默认提交方式： set @@autocommit = 0;</span><br></pre></td></tr></table></figure>
<h3 id="四大特性和隔离级别">四大特性和隔离级别</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2. 事务的四大特征：</span><br><span class="line">	1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。</span><br><span class="line">	2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。</span><br><span class="line">	3. 隔离性：多个事务之间相互独立。</span><br><span class="line">	4. 一致性：事务操作前后，数据总量不变。</span><br><span class="line"></span><br><span class="line">3. 事务的隔离级别（了解）</span><br><span class="line">	* 概念: 多个事务之间隔离的、相互独立的，但是如果多个事务操作同一批数据，则会引发一些问题，</span><br><span class="line">		   设置不同的隔离级别就可以解决这些问题。</span><br><span class="line">	* 存在的问题：</span><br><span class="line">		1. 脏读：一个事务读取到另一个事务中没有提交的数据 </span><br><span class="line">		2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。</span><br><span class="line">		3. 幻读：一个事务操作(DML 操作) 数据表中所有记录，另一个事务添加了一条数据，</span><br><span class="line">				则第一个事务查询不到自己的修改。</span><br><span class="line">	* 隔离级别：</span><br><span class="line">		1. read uncommitted：读未提交</span><br><span class="line">			* 会产生的问题：脏读、不可重复读、幻读</span><br><span class="line">		2. read committed：读已提交 (Oracle 默认)</span><br><span class="line">			* 会产生的问题：不可重复读、幻读</span><br><span class="line">		3. repeatable read：可重复读 (MySQL 默认)</span><br><span class="line">			* 会产生的问题：幻读</span><br><span class="line">		4. serializable：串行化</span><br><span class="line">			* 可以解决所有的问题</span><br><span class="line">		* 注意：隔离级别从小到大安全性越来越高，但是效率越来越低</span><br><span class="line">		</span><br><span class="line">		* 数据库查询隔离级别：</span><br><span class="line">			* SELECT @@tx_isolation;</span><br><span class="line">		* 数据库设置隔离级别：</span><br><span class="line">			* SET GLOBAL TRANSACTION ISOLATION LEVEL  级别字符串;</span><br><span class="line"></span><br><span class="line">	* 演示：</span><br><span class="line">		SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br><span class="line">		START TRANSACTION;</span><br><span class="line">		-- 转账操作</span><br><span class="line">		UPDATE account SET balance = balance - 500 WHERE id = 1;</span><br><span class="line">		UPDATE account SET balance = balance + 500 WHERE id = 2;</span><br><span class="line">		</span><br><span class="line">		ROLLBACK; -- 回滚</span><br><span class="line">		COMMIT; -- 提交</span><br></pre></td></tr></table></figure>
<h2 id="DCL：数据控制语句">DCL：数据控制语句</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* SQL 分类：</span><br><span class="line">	1. DDL：操作数据库和表</span><br><span class="line">	2. DML：增删改表中数据</span><br><span class="line">	3. DQL：查询表中数据</span><br><span class="line">	4. DCL(Data Control Language)：管理用户，授权</span><br><span class="line"></span><br><span class="line">* DCL：管理用户，授权</span><br><span class="line">	1. 管理用户</span><br><span class="line">		1. 添加用户：</span><br><span class="line">			* 语法： CREATE USER &#x27; 用户名 &#x27;@&#x27; 主机名 &#x27; IDENTIFIED BY &#x27; 密码 &#x27;;</span><br><span class="line">		2. 删除用户：</span><br><span class="line">			* 语法： DROP USER &#x27; 用户名 &#x27;@&#x27; 主机名 &#x27;;</span><br><span class="line">		3. 修改用户密码：</span><br><span class="line">			* 语法： UPDATE USER SET PASSWORD = PASSWORD(&#x27; 新密码 &#x27;) WHERE USER = &#x27; 用户名 &#x27;;</span><br><span class="line">			* 语法： SET PASSWORD FOR &#x27; 用户名 &#x27;@&#x27; 主机名 &#x27; = PASSWORD(&#x27; 新密码 &#x27;);</span><br><span class="line"></span><br><span class="line">			* mysql 中忘记了 root 用户的密码？</span><br><span class="line">				1. cmd --&gt; net stop mysql 停止 mysql 服务(需要管理员运行该 cmd)</span><br><span class="line">				2. 使用无验证方式启动 mysql 服务, 命令: mysqld --skip-grant-tables</span><br><span class="line">				3. 打开新的 cmd 窗口, 直接输入 mysql 命令, 敲回车, 就可以登录成功</span><br><span class="line">				4. 输入命令: USE mysql;</span><br><span class="line">				5. UPDATE USER SET PASSWORD = PASSWORD(&#x27; 新密码 &#x27;) WHERE USER = &#x27;root&#x27;;</span><br><span class="line">				6. 关闭两个窗口后, 打开任务管理器, 手动结束 mysqld.exe 的进程</span><br><span class="line">				7. 启动 mysql 服务, 使用新密码登录</span><br><span class="line">		4. 查询用户：</span><br><span class="line">			-- 1. 切换到 mysql 数据库</span><br><span class="line">			USE myql;</span><br><span class="line">			-- 2. 查询 user 表</span><br><span class="line">			SELECT * FROM USER;</span><br><span class="line"></span><br><span class="line">	2. 权限管理：</span><br><span class="line">		1. 查询权限：</span><br><span class="line">			-- 查询权限</span><br><span class="line">			SHOW GRANTS FOR &#x27; 用户名 &#x27;@&#x27; 主机名 &#x27;;</span><br><span class="line">			* 通配符： % 表示可以在任意主机使用用户登录数据库</span><br><span class="line"></span><br><span class="line">		2. 授予权限：</span><br><span class="line">			-- 授予权限</span><br><span class="line">			GRANT 权限列表 ON 数据库名. 表名 TO &#x27; 用户名 &#x27;@&#x27; 主机名 &#x27;;</span><br><span class="line">			-- 给张三用户授予所有权限(ALL), 在任意数据库上操作任意表(*.*)</span><br><span class="line">			GRANT ALL ON *.* TO &#x27;zhangsan&#x27;@&#x27;localhost&#x27;;</span><br><span class="line">			-- 刷新使授权立即生效</span><br><span class="line">			flush privileges;</span><br><span class="line">		3. 撤销权限：</span><br><span class="line">			-- 撤销权限：</span><br><span class="line">			revoke 权限列表 on 数据库名. 表名 from &#x27; 用户名 &#x27;@&#x27; 主机名 &#x27;;</span><br><span class="line">			REVOKE UPDATE ON db3.`account` FROM &#x27;lisi&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure>
<h2 id="数据库管理软件分类">数据库管理软件分类</h2>
<p>管理数据的工具根据它们存取数据的特点来划分，主要分为关系型和非关系型。可以简单的理解为，关系型数据库需要有表结构 *，* 非关系型数据库是 key-value 存储的，没有表结构。</p>
<p>MySQL 是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</p>
<h2 id="存储引擎">存储引擎</h2>
<p><strong>存储引擎：存储数据的方式</strong>。</p>
<ul>
<li>
<p><strong>InnoDB 存储引擎（数据持久化）：MySQL5.6 之后的默认的存储引擎</strong>。</p>
</li>
<li>
<p>Myisam 存储（数据持久化）：MySQL5.5 之前的默认存储引擎。</p>
</li>
<li>
<p>Memory 存储引擎（断点数据消失）：数据存储在内存中，也就是说数据断点消失</p>
</li>
</ul>
<p><strong>InnoDB 存储引擎</strong>：共 2 个文件，数据和索引存储在一起，即数据、索引一个文件，表结构一个文件。原子性操作：不能再拆分。查看当前默认的存储引擎：<code>show variables like %engin%;</code></p>
<ul>
<li>Innodb 存储引擎：支持事务、支持行级锁、表级锁、支持外键。</li>
<li>支持事务：为了保证数据的完整性，将多个操作变成原子性操作，保证数据安全。</li>
<li>支持行级锁：修改的行少的时候用，适合修改数据频繁的操作。</li>
<li>表级锁：批量修改多行的时候用，适合对于大量数据的同时修改。</li>
<li>支持外键：约束两张表中的关联字段不能随意的添加和删除，降低数据增删改的出错率。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 面试题：</span><br><span class="line"># 了解 mysql 的存储引擎吗？	Innodb  Myisam  Memory</span><br><span class="line"># 项目用了什么存储引擎，为什么？</span><br><span class="line">   # innodb, 因为 innodb 存储引擎： 	支持事务，行锁，表锁，外键。</span><br><span class="line">   # 因为，多个用户操作的过程中对同一张表的数据同时做修改，innodb 支持行级锁，所以用了这个存储引擎。</span><br><span class="line">   # 为了适应程序未来的扩展，扩展新功能的时候可能会用到，涉及要维护的数据的完整性。</span><br><span class="line">   # 项目中有两张表，之间的外键关系是什么···，一张表的修改或删除比较频繁，怕出错所以做了外键约束。</span><br></pre></td></tr></table></figure>
<h2 id="多表结构的创建与分析">多表结构的创建与分析</h2>
<p><strong>如何找出两张表之间的关系</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">分析步骤：</span><br><span class="line">1、先站在左表的角度去找</span><br><span class="line">	是否左表的多条记录可以对应右表的一条记录，</span><br><span class="line">	如果是，则证明左表的一个字段 foreign key 右表一个字段 (通常是 id)</span><br><span class="line"></span><br><span class="line">2、再站在右表的角度去找</span><br><span class="line">	是否右表的多条记录可以对应左表的一条记录，</span><br><span class="line">	如果是，则证明右表的一个字段 foreign key 左表一个字段 (通常是 id)</span><br><span class="line"></span><br><span class="line">3、总结：</span><br><span class="line"># 多对一：</span><br><span class="line">    如果只有步骤 1 成立，则是左表多对一右表</span><br><span class="line">    如果只有步骤 2 成立，则是右表多对一左表</span><br><span class="line"></span><br><span class="line"># 多对多：</span><br><span class="line">    如果步骤 1 和 2 同时成立，则证明这两张表时一个双向的多对一，即多对多。</span><br><span class="line">    此时，需要定义一个这两张表的关系表来专门存放二者的关系。</span><br><span class="line"></span><br><span class="line"># 一对一:</span><br><span class="line">	如果 1 和 2 都不成立，即是左表的一条记录唯一对应右表的一条记录，反之亦然。</span><br><span class="line">	这种情况很简单，就是在左表 foreign key 右表的基础上，将左表的外键字段设置成 unique 即可。</span><br><span class="line">	create table customer(</span><br><span class="line">        id int primary key auto_increment,</span><br><span class="line">        name varchar(20) not null</span><br><span class="line">    );</span><br><span class="line">    create table student(</span><br><span class="line">            id int primary key auto_increment,</span><br><span class="line">            class_name varchar(20) not null,</span><br><span class="line">            customer_id int unique, -- 外键的字段一定要保证 unique</span><br><span class="line">            foreign key(customer_id) references customer(id) </span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<h2 id="数据类型">数据类型</h2>
<p><strong>字符串类型</strong>：</p>
<p>CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</p>
<ul>
<li>CHAR 最大长度为 255，尾部空格被抛弃，VARCHAR 最大长度 65535，尾部空格被保留。</li>
</ul>
<p>BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，<strong>不同的是它们包含二进制字符串而不要非二进制字符串 </strong>。也就是说，它们<strong> 包含字节字符串而不是字符字符串</strong>。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。</p>
<p><strong>ENUM 和 SET 类型</strong>：</p>
<p>ENUM 中文名称叫枚举类型，它的值范围需要在创建表时通过枚举方式显示。ENUM<strong>只允许从值集合中选取单个值，而不能一次取多个值</strong>。</p>
<p>SET 和 ENUM 非常相似，也是一个字符串对象，里面可以包含 0-64 个成员。根据成员的不同，存储上也有所不同。set 类型可以 <strong> 允许值集合中任意选择 1 或多个元素进行组合</strong>。对超出范围的内容将不允许注入，而对重复的值将进行自动去重。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>ENUM</td>
<td>对 1-255 个成员的枚举需要 1 个字节存储；对于 255-65535 个成员，需要 2 个字节存储；最多允许 65535 个成员。</td>
<td>单选：选择性别</td>
</tr>
<tr>
<td>SET</td>
<td>1-8 个成员的集合，占 1 个字节；9-16 个成员的集合，占 2 个字节；17-24 个成员的集合，占 3 个字节；25-32 个成员的集合，占 4 个字节；33-64 个成员的集合，占 8 个字节。</td>
<td>多选：兴趣爱好</td>
</tr>
</tbody>
</table>
<h2 id="外键与 innoDB 存储引擎">外键与 innoDB 存储引擎</h2>
<p>外键 foreign key 约束：<strong>具有外键的表的存储引擎必须是 innoDB 存储引擎</strong>，且被关联的字段（即 references 指定的另一张表的字段）必须保证唯一。具有外键的表的记录，随与之关联的父表的记录同步更新<code>on update cascade</code>、同步删除<code>on delete cascade</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table father_table(</span><br><span class="line">	...</span><br><span class="line">)engine = innodb;</span><br><span class="line"></span><br><span class="line">create table child_table(</span><br><span class="line">	...</span><br><span class="line">)engine = innodb;</span><br></pre></td></tr></table></figure>
<h2 id="MySQL 索引原理">MySQL 索引原理</h2>
<p>索引的设计，可以加快查询速度。</p>
<h2 id="case-when-then 用法">case when then 用法</h2>
<p>case 具有两中格式：简单 case 函数和 case 搜索函数。case 函数只返回第一个符合条件的值，剩下的 case 部分将会被自动忽略。</p>
<p>Tip：case when then 得到的结果是「多行一列」的，得到后可以继续对其使用聚合函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 简单 case 函数</span><br><span class="line">case sex</span><br><span class="line">	when &#x27;1&#x27; then &#x27; 男 &#x27;</span><br><span class="line">	when &#x27;2&#x27; then &#x27; 女 &#x27;</span><br><span class="line">	else &#x27; 其他 &#x27; end;</span><br><span class="line"></span><br><span class="line">-- case 搜索函数</span><br><span class="line">case</span><br><span class="line">	when sex = &#x27;1&#x27; then &#x27; 男 &#x27;</span><br><span class="line">	when sex = &#x27;2&#x27; then &#x27; 女 &#x27;</span><br><span class="line">    else &#x27; 其他 &#x27; end;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 将性别 id 替换为可读的中文</span><br><span class="line">SELECT u.id, u.name,</span><br><span class="line">	(CASE u.sex</span><br><span class="line">     	WHEN 1 THEN &#x27; 男 &#x27;</span><br><span class="line">     	WHEN 2 THEN &#x27; 女 &#x27;</span><br><span class="line">     	ELSE &#x27; 空的 &#x27; END</span><br><span class="line">       ) &#x27; 性别 &#x27;</span><br><span class="line">FROM users u;</span><br><span class="line"></span><br><span class="line">-- 统计不同性别的人的数量</span><br><span class="line">SELECT</span><br><span class="line">    COUNT(CASE WHEN u.sex=1 THEN 1 END) &#x27;male&#x27;,</span><br><span class="line">    COUNT(CASE WHEN u.sex=2 THEN 1 END) &#x27;female&#x27;,</span><br><span class="line">    COUNT(CASE WHEN u.sex &lt;&gt;1 AND u.sex&lt;&gt;2 THEN 1 END) &#x27;other&#x27;</span><br><span class="line">FROM users u;</span><br></pre></td></tr></table></figure>
<h2 id="select-into">select into</h2>
<p>INSERT INTO 语句用于向表格中插入新的行。</p>
<p>SELECT INTO 语句从一个表中选取数据，然后 <strong> 把数据插入另一个表中 </strong>。<strong> 常用于创建表的备份复件或者用于对记录进行存档</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 指定所要插入数据的列：</span><br><span class="line">INSERT INTO table_name (列 1, 列 2,...) VALUES (值 1, 值 2,....)</span><br><span class="line"></span><br><span class="line">-- 把所有的列插入新表 </span><br><span class="line">SELECT *</span><br><span class="line">INTO new_table_name [IN externaldatabase] </span><br><span class="line">FROM old_tablename</span><br><span class="line"></span><br><span class="line">-- 只把希望的列插入新表 </span><br><span class="line">SELECT column_name1, column_name3</span><br><span class="line">INTO new_table_name [IN externaldatabase] </span><br><span class="line">FROM old_tablename</span><br></pre></td></tr></table></figure>
<h2 id="delect 与 truncate 比较">delect 与 truncate 比较</h2>
<ul>
<li>处理效率：drop &gt; truncate &gt; delete。</li>
<li>drop 删除整个表；truncate 删除全部记录，但不删除表（的结构）；delete 删除部分记录。</li>
<li><strong>delete 不影响所用 extent，高水线保持原位置不动；truncate 会将高水线复位</strong>。</li>
</ul>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法之哈希表实现</title>
    <url>/posts/231227190828.html</url>
    <content><![CDATA[<p>本文实现一个简单的哈希表（散列表），包括常见的初始化创建表、查询操作、添加键值对、删除键值对和销毁哈希表等操作。在本次实现中，哈希桶使用双向链表数据结构。</p>
<span id="more"></span>
<h1 id="哈希表实现">哈希表实现</h1>
<p>首先，先抛出本次实现的哈希表的数据结构关系图，其中包括哈希表头结构、哈希表结构、双向链表头结构、双向链表结构、哈希节点结构、哈希桶结构、数据节点结构等。</p>
<img src="../images/data-structure/hash-table-struct.png" alt="哈希表结构" width="100%" height="100%">
<blockquote>
<p>图中，虚线箭头表示结构体使用了 <code>typedef</code> 起别名。</p>
</blockquote>
<h2 id="哈希表结构定义">哈希表结构定义</h2>
<h3 id="双向链表结构">双向链表结构</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双向链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagDL_NODE</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagDL_NODE</span> *<span class="title">pstNext</span>;</span> <span class="comment">// A pointer to the next element</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagDL_NODE</span> *<span class="title">pstPrev</span>;</span> <span class="comment">// A pointer to the prev element</span></span><br><span class="line">&#125; DL_NODE_S;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表头节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagDL_HEAD</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulSize; <span class="comment">// the element numbers in the double-linked</span></span><br><span class="line">    DL_NODE_S *pstFirst; <span class="comment">// the first element in the double-linked</span></span><br><span class="line">&#125; DL_HEAD_S;</span><br></pre></td></tr></table></figure>
<h3 id="哈希节点结构">哈希节点结构</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 哈希节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> DL_NODE_S HASH_NODE_S;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希桶头节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> DL_HEAD_S HASH_LIST_S;</span><br></pre></td></tr></table></figure>
<h3 id="哈希表结构">哈希表结构</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HASH_BUCKET_SIZE (1000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagHASH_TABLE</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulSize;</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*pfHash)</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *)</span>;</span><br><span class="line">    HASH_LIST_S *pstBckt; <span class="comment">// 每个哈希桶中始终存储着双向链表的头节点</span></span><br><span class="line">&#125; HASH_TABLE_S;</span><br></pre></td></tr></table></figure>
<h3 id="哈希表头结构">哈希表头结构</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 哈希表头节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagHASH_HEAD</span> &#123;</span></span><br><span class="line">    HASH_TABLE_S *pstTable;</span><br><span class="line">    <span class="comment">/* 其它成员，如哈希表创建时间、哈希表状态、节点数量、锁等 */</span></span><br><span class="line">&#125; HASH_HEAD_S;</span><br></pre></td></tr></table></figure>
<h2 id="数据节点结构">数据节点结构</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 哈希节点（数据节点）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagDataNode</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 哈希节点，不可少，且要作为首位成员 */</span></span><br><span class="line">    HASH_NODE_S stHashNode;</span><br><span class="line">    <span class="comment">/* hash key */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulIdentifier;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ucAge;</span><br><span class="line">    <span class="type">char</span> *pcName;</span><br><span class="line">    <span class="comment">/* hash payload */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uiHeight;</span><br><span class="line">&#125; DATA_NODE_S;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>数据节点结构的首位成员必须是 <code>HASH_NODE_S</code> 哈希节点（双链表节点）</strong>。这是因为，后续需要将真正的哈希节点（存储在哈希表中的用户数据节点） <code>DATA_NODE_S</code> 结构强转成 <code>HASH_NODE_S</code> 结构，并修改其 <code>pstNext</code> 和 <code>pstPrev</code> 指针，将「数据」首地址存储在哈希表中。若不是首位成员，会把「数据」成员修改，造成数据错误。</p>
<p>首位成员必须是 <code>HASH_NODE_S</code> 哈希节点，使得哈希桶中仅存储了数据的首地址，而不会过多的存储数据信息。其次，这样设计，使得数据节点结构可以包含任何你想要的信息，而无需修改哈希表的各个函数接口。</p>
</blockquote>
<h2 id="哈希函数">哈希函数</h2>
<p>哈希函数的作用是将一个较大的输入空间映射到一个较小的输出空间，且尽可能保证均匀映射。在哈希表中，输入空间是所有 <code>key</code>，输出空间是所有哈希桶（数组索引）。换句话说，对于一个输入 <code>key</code>，可以通过哈希函数得到该 <code>key</code> 在数组中的位置。哈希函数应尽可能保证映射后的输出空间尽可能均匀、分散，以减少哈希冲突的发生。</p>
<p>在这里，我们简单地使用 <code>DATA_NODE_S</code> 节点的 <code>ulIdentifier</code> 模上哈希桶大小，作为哈希函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">hashFunc</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *pKey)</span> &#123;</span><br><span class="line">    <span class="type">const</span> DATA_NODE_S *pstKey = (<span class="type">const</span> DATA_NODE_S *)pKey;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstKey) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s():%d: null pointer\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">long</span>)(pstKey-&gt;ulIdentifier % HASH_BUCKET_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哈希键比较函数">哈希键比较函数</h2>
<p>对于哈希表中的节点，在查询和删除操作时，需要将哈希表中遍历的节点的 key 与给定的数据的 key 进行比较，匹配成功返回 <code>0</code>，否则返回 <code>-1</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">hashKeyCmp</span><span class="params">(<span class="type">const</span> HASH_NODE_S *pstHashNode, <span class="type">const</span> <span class="type">void</span> *pKey)</span> &#123;</span><br><span class="line">    <span class="type">const</span> DATA_NODE_S *pstNode = (<span class="type">const</span> DATA_NODE_S *)pstHashNode;</span><br><span class="line">    <span class="type">const</span> DATA_NODE_S *pstKey = (<span class="type">const</span> DATA_NODE_S *)pKey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstNode || <span class="literal">NULL</span> == pstKey) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s():%d: null pointer\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pstNode-&gt;ulIdentifier != pstKey-&gt;ulIdentifier || \</span><br><span class="line">        pstNode-&gt;ucAge != pstKey-&gt;ucAge || <span class="built_in">strcmp</span>(pstNode-&gt;pcName, pstKey-&gt;pcName) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双向链表节点删除函数">双向链表节点删除函数</h2>
<p>当需要删除哈希表中的节点时，需要从双向链表中移除指定的节点 <code>pstNode</code>：</p>
<ul>
<li>若 <code>pstNode</code> 不是头节点，则删除节点，并正确处理前、后节点的指向关系。</li>
<li>若 <code>pstNode</code> 是头节点，则删除节点、<strong>重新指定头节点为链表中的下一个节点</strong>，并正确处理前、后节点的指向关系。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">dlNodeDel</span><span class="params">(DL_HEAD_S *pstHead, DL_NODE_S *pstNode)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstNode || <span class="literal">NULL</span> == pstHead) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 前一个节点不为空，则 pstNode 不是头结点 */</span></span><br><span class="line">    <span class="keyword">if</span> (pstNode-&gt;pstPrev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 将前一个节点的下一个节点指针指向当前节点的下一个节点</span></span><br><span class="line">        pstNode-&gt;pstPrev-&gt;pstNext = pstNode-&gt;pstNext;</span><br><span class="line">        <span class="keyword">if</span> (pstNode-&gt;pstNext != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 将下一个节点的前一个节点指针指向当前节点的前一个节点</span></span><br><span class="line">            pstNode-&gt;pstNext-&gt;pstPrev = pstNode-&gt;pstPrev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 更新头节点为下一个节点，并将其上一个节点指向 NULL */</span></span><br><span class="line">        pstHead-&gt;pstFirst = pstNode-&gt;pstNext;</span><br><span class="line">        <span class="keyword">if</span> (pstNode-&gt;pstNext != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pstNode-&gt;pstNext-&gt;pstPrev = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pstHead-&gt;ulSize--;  <span class="comment">// 删除节点后，更新节点数量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，这里仅仅是从双向链表中移除指定的节点，并没有释放对应的内存空间。</p>
</blockquote>
<h2 id="哈希表创建与初始化操作">哈希表创建与初始化操作</h2>
<p>哈希表创建主要包括申请哈希表本身的空间（即哈希表大小、哈希函数和哈希桶地址空间），以及为每个哈希桶位置分配双向链表头节点空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HASH_TABLE_S *<span class="title function_">hashCreate</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> ulSize, <span class="type">unsigned</span> <span class="type">long</span> (*pfHash)(<span class="type">const</span> <span class="type">void</span> *))</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ulSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s():%d: hash bucket size should be large zero\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HASH_TABLE_S *pstTable = (HASH_TABLE_S *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HASH_TABLE_S));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstTable) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s():%d: Could not allocate memory for hash table\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HASH_LIST_S *pstBckt = (HASH_LIST_S *)<span class="built_in">malloc</span>((ulSize + <span class="number">1</span>) * <span class="keyword">sizeof</span>(HASH_LIST_S));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstBckt) &#123;</span><br><span class="line">        <span class="built_in">free</span>(pstTable);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s():%d: Could not allocate memory for hash bucket\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(pstBckt, <span class="number">0</span>, (ulSize + <span class="number">1</span>) * <span class="keyword">sizeof</span>(HASH_LIST_S));</span><br><span class="line"></span><br><span class="line">    pstTable-&gt;ulSize = ulSize + <span class="number">1</span>;</span><br><span class="line">    pstTable-&gt;pfHash = pfHash;</span><br><span class="line">    pstTable-&gt;pstBckt = pstBckt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pstTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哈希表添加操作">哈希表添加操作</h2>
<p>哈希表的添加键值对操作的过程为：</p>
<ol>
<li>各个指针地址为空判断；</li>
<li>通过哈希函数获取给定键的哈希索引；</li>
<li>通过哈希索引，获取对应的哈希桶；</li>
<li>在哈希桶的头节点前插入新增的节点，并更新头结点。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hashAdd</span><span class="params">(HASH_TABLE_S *pstTable, HASH_NODE_S *pstNode)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstTable || <span class="literal">NULL</span> == pstNode || <span class="literal">NULL</span> == pstTable-&gt;pfHash) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s():%d: null pointer\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 通过哈希函数获取指定桶的地址 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulIndex = pstTable-&gt;pfHash((<span class="type">const</span> <span class="type">void</span> *)pstNode);</span><br><span class="line">    DL_HEAD_S *pstBckt = (DL_HEAD_S *)(&amp;pstTable-&gt;pstBckt[ulIndex]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstBckt) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s():%d: null pointer of hash bucket head\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在头节点前插入节点 */</span></span><br><span class="line">    pstNode-&gt;pstPrev = <span class="literal">NULL</span>; <span class="comment">// 新节点的 prev 指向 NULL</span></span><br><span class="line">    pstNode-&gt;pstNext = pstBckt-&gt;pstFirst; <span class="comment">// 新节点的 next 指向头结点</span></span><br><span class="line">    <span class="keyword">if</span> (pstBckt-&gt;pstFirst != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pstBckt-&gt;pstFirst-&gt;pstPrev = pstNode; <span class="comment">// 原头结点的 prev 指向新节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新头节点为插入的节点，并更新 DL 节点数量 */</span></span><br><span class="line">    pstBckt-&gt;pstFirst = pstNode; </span><br><span class="line">    pstBckt-&gt;ulSize++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，该 <strong> 哈希表添加操作并不会判断节点是否存在于对应的桶中，而是直接执行节点添加操作</strong>。用户在使用时，需要先检查节点是否存在，不存在才能执行添加操作。</p>
</blockquote>
<h2 id="哈希表查询操作">哈希表查询操作</h2>
<p>哈希表的查询键值对操作的过程为：</p>
<ol>
<li>各个指针地址为空判断；</li>
<li>通过哈希函数获取给定键的哈希索引；</li>
<li>通过哈希索引，获取对应的哈希桶；</li>
<li>获取哈希桶的头节点（双向链表的头节点）地址；</li>
<li>遍历双向链表中的每一个节点，并使用哈希比较函数与给定的键做比较：
<ul>
<li>若匹配成功，则返回哈希节点的地址；</li>
<li>若匹配失败，则继续向后遍历。</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HASH_NODE_S *<span class="title function_">hashFind</span><span class="params">(HASH_TABLE_S *pstTable, <span class="type">const</span> <span class="type">void</span> *pKey, <span class="type">long</span> (*pfKeyCmp)(<span class="type">const</span> HASH_NODE_S *, <span class="type">const</span> <span class="type">void</span> *))</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstTable || <span class="literal">NULL</span> == pKey || <span class="literal">NULL</span> == pfKeyCmp || <span class="literal">NULL</span> == pstTable-&gt;pfHash) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s():%d: null pointer\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 通过哈希函数获取指定桶的地址 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulIndex = pstTable-&gt;pfHash(pKey);</span><br><span class="line">    DL_HEAD_S *pstBckt = (DL_HEAD_S *)(&amp;pstTable-&gt;pstBckt[ulIndex]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstBckt) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s():%d: null pointer of hash bucket head\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这里遍历链表需要 O(N)时间，可考虑优化为红黑树，使得时间为 O(logN) */</span></span><br><span class="line">    DL_NODE_S *pstNode = pstBckt-&gt;pstFirst;</span><br><span class="line">    <span class="keyword">while</span> (pstNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pfKeyCmp(pstNode, pKey) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pstNode;</span><br><span class="line">        &#125;</span><br><span class="line">        pstNode = pstNode-&gt;pstNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哈希表删除操作">哈希表删除操作</h2>
<p>哈希表的删除键值对操作的过程为：</p>
<ol>
<li>各个指针地址为空判断；</li>
<li>通过哈希函数获取给定键的哈希索引；</li>
<li>通过哈希索引，获取对应的哈希桶；</li>
<li>获取哈希桶的头节点（双向链表的头节点）地址；</li>
<li>遍历双向链表中的每一个节点，并使用哈希比较函数与给定的键做比较：
<ul>
<li>若匹配成功，则从双向链表中删除该节点；</li>
<li>若匹配失败，则继续向后遍历。</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hashDel</span><span class="params">(HASH_TABLE_S *pstTable, <span class="type">const</span> <span class="type">void</span> *pKey, <span class="type">long</span> (*pfKeyCmp)(<span class="type">const</span> HASH_NODE_S *, <span class="type">const</span> <span class="type">void</span> *))</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstTable || <span class="literal">NULL</span> == pKey || <span class="literal">NULL</span> == pfKeyCmp || <span class="literal">NULL</span> == pstTable-&gt;pfHash) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s():%d: null pointer\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 通过哈希函数获取指定桶的地址 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulIndex = pstTable-&gt;pfHash(pKey);</span><br><span class="line">    DL_HEAD_S *pstBckt = (DL_HEAD_S *)(&amp;pstTable-&gt;pstBckt[ulIndex]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstBckt) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s():%d: null pointer of hash bucket head\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这里遍历链表需要 O(N)时间，可考虑优化为红黑树，使得时间为 O(logN) */</span></span><br><span class="line">    DL_NODE_S *pstNode = pstBckt-&gt;pstFirst;</span><br><span class="line">    <span class="keyword">while</span> (pstNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pfKeyCmp(pstNode, pKey) == <span class="number">0</span>) &#123;</span><br><span class="line">            dlNodeDel((DL_HEAD_S *)pstBckt, (DL_NODE_S *)pstNode);</span><br><span class="line">            <span class="comment">/* 从哈希桶中移除 DL 节点，但不释放数据，它由用户决定 */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pstNode = pstNode-&gt;pstNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>哈希表删除节点操作，只会将节点从双向链表中移除，但 <strong> 不会释放对应的内存空间（释放或不释放节点的内存空间由用户决定）</strong>。</p>
</blockquote>
<h2 id="哈希表遍历打印操作">哈希表遍历打印操作</h2>
<p>哈希表的打印键值对操作的过程为：</p>
<ol>
<li>各个指针地址为空判断；</li>
<li>遍历哈希表中的每一个哈希桶：
<ul>
<li>获取哈希桶的头节点（双向链表的头节点）地址；</li>
<li>遍历双向链表中的每一个节点，并打印数据内容。</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因不同数据的结构不同，这里使用宏定义定义指定节点的打印内容</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATA_PRINT_INFO(bucketId, pstNode) \</span></span><br><span class="line"><span class="meta">    do &#123; \</span></span><br><span class="line"><span class="meta">        DATA_NODE_S *pstData = (DATA_NODE_S *)(pstNode); \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">&quot;    bucket id = %lu, .ulIdentifier = %lu, .ucAge = %d, .pcName = %s, .Height = %dcm\n&quot;</span>, \</span></span><br><span class="line"><span class="meta">                (bucketId), pstData-&gt;ulIdentifier, pstData-&gt;ucAge, pstData-&gt;pcName, pstData-&gt;uiHeight); \</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hashPrint</span><span class="params">(HASH_TABLE_S *pstTable)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstTable) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s():%d: null pointer\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 遍历哈希表中的每一个哈希桶的所有节点，并对节点执行特定操作 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; pstTable-&gt;ulSize; i++) &#123;</span><br><span class="line">        DL_HEAD_S *pstBckt = (DL_HEAD_S *)(&amp;pstTable-&gt;pstBckt[i]);</span><br><span class="line">        <span class="keyword">if</span> (pstBckt != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            DL_NODE_S *pstNode = pstBckt-&gt;pstFirst;</span><br><span class="line">            <span class="keyword">if</span> (pstBckt-&gt;ulSize &gt; <span class="number">0</span> &amp;&amp; pstNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;No.%lu hash bucket has %lu nodes\n&quot;</span>, i, pstBckt-&gt;ulSize);</span><br><span class="line">                <span class="keyword">while</span> (pstNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    DATA_PRINT_INFO(i, pstNode); <span class="comment">// 打印的内容</span></span><br><span class="line">                    pstNode = pstNode-&gt;pstNext;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哈希表销毁操作">哈希表销毁操作</h2>
<p>哈希表的销毁所有键值对操作的过程为：</p>
<ol>
<li>各个指针地址为空判断；</li>
<li>遍历哈希表中的每一个哈希桶：
<ul>
<li>获取哈希桶的头节点（双向链表的头节点）地址；</li>
<li>遍历双向链表中的每一个节点，从哈希表中移除节点，并释放对应的内存空间（可选）。</li>
</ul>
</li>
<li>释放所有哈希桶的内存空间，并释放哈希表内存空间。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 销毁操作是否释放数据的内存空间？这里定义了一个删除并释放的宏（用户可自行设计这个宏）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH_NODE_DEL_FREE(pstBckt, pstDelNode, bFree) \</span></span><br><span class="line"><span class="meta">    do &#123; \</span></span><br><span class="line"><span class="meta">        dlNodeDel((DL_HEAD_S *)(pstBckt), (DL_NODE_S *)(pstDelNode)); \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> ((bFree) &amp;&amp; (pstDelNode) != NULL) &#123; \</span></span><br><span class="line"><span class="meta">            free((DATA_NODE_S *)(pstDelNode)); \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hashDestroy</span><span class="params">(HASH_TABLE_S *pstTable, <span class="type">bool</span> bFree)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstTable) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s():%d: null pointer\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 遍历哈希表中的每一个哈希桶的所有节点，并对节点执行特定操作 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; pstTable-&gt;ulSize; i++) &#123;</span><br><span class="line">        DL_HEAD_S *pstBckt = (DL_HEAD_S *)(&amp;pstTable-&gt;pstBckt[i]);</span><br><span class="line">        <span class="keyword">if</span> (pstBckt != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            DL_NODE_S *pstNode = pstBckt-&gt;pstFirst;</span><br><span class="line">            <span class="keyword">while</span> (pstNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                DL_NODE_S *pstDelNode = pstNode;</span><br><span class="line">                pstNode = pstNode-&gt;pstNext;</span><br><span class="line">                HASH_NODE_DEL_FREE(pstBckt, pstDelNode, bFree); <span class="comment">// 删除节点，按需释放数据内存</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(pstTable-&gt;pstBckt);</span><br><span class="line">    <span class="built_in">free</span>(pstTable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="哈希表测试">哈希表测试</h1>
<h2 id="测试代码">测试代码</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    assert(HASH_BUCKET_SIZE &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    HASH_HEAD_S *hashHead = (HASH_HEAD_S *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HASH_HEAD_S));</span><br><span class="line">    assert(hashHead != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    hashHead-&gt;pstTable = hashCreate(HASH_BUCKET_SIZE, hashFunc);</span><br><span class="line">    assert(hashHead-&gt;pstTable != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    HASH_TABLE_S *pstTable = hashHead-&gt;pstTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建测试数据 */</span></span><br><span class="line">    DATA_NODE_S dataList[] = &#123;</span><br><span class="line">        &#123;.stHashNode = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">        .ulIdentifier = <span class="number">1</span>,</span><br><span class="line">        .ucAge = <span class="number">18</span>,</span><br><span class="line">        .pcName = <span class="string">&quot;Bob&quot;</span>,</span><br><span class="line">        .uiHeight = <span class="number">178</span>&#125;,</span><br><span class="line">        &#123;.stHashNode = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">        .ulIdentifier = <span class="number">2</span>,</span><br><span class="line">        .ucAge = <span class="number">20</span>,</span><br><span class="line">        .pcName = <span class="string">&quot;John&quot;</span>,</span><br><span class="line">        .uiHeight = <span class="number">181</span>&#125;,</span><br><span class="line">        &#123;.stHashNode = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">        .ulIdentifier = <span class="number">3</span>,</span><br><span class="line">        .ucAge = <span class="number">18</span>,</span><br><span class="line">        .pcName = <span class="string">&quot;LiHua&quot;</span>,</span><br><span class="line">        .uiHeight = <span class="number">176</span>&#125;,</span><br><span class="line">        &#123;.stHashNode = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">        .ulIdentifier = <span class="number">2</span>,</span><br><span class="line">        .ucAge = <span class="number">22</span>,</span><br><span class="line">        .pcName = <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">        .uiHeight = <span class="number">168</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> dataSize = <span class="keyword">sizeof</span>(dataList) / <span class="keyword">sizeof</span>(dataList[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    DATA_NODE_S **nodeList = (DATA_NODE_S **)<span class="built_in">malloc</span>(dataSize * <span class="keyword">sizeof</span>(DATA_NODE_S *));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加节点，无法确定节点是否重复时，应先执行查找操作 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dataSize; i++) &#123;</span><br><span class="line">        nodeList[i] = (DATA_NODE_S *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DATA_NODE_S));</span><br><span class="line">        <span class="built_in">memcpy</span>(nodeList[i], &amp;dataList[i], <span class="keyword">sizeof</span>(DATA_NODE_S));</span><br><span class="line">        <span class="comment">// 因 DATA_NODE_S 的靠前的成员，正好为 HASH_NODE_S 的所有成员；因此，强转 DATA_NODE_S，不会修改其它成员的信息</span></span><br><span class="line">        hashAdd(pstTable, (HASH_NODE_S *)nodeList[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印哈希表中的所有节点 */</span></span><br><span class="line">    hashPrint(pstTable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建查找数据 */</span></span><br><span class="line">    DATA_NODE_S keyList[] = &#123;</span><br><span class="line">        &#123;.stHashNode = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">        .ulIdentifier = <span class="number">3</span>,</span><br><span class="line">        .ucAge = <span class="number">18</span>,</span><br><span class="line">        .pcName = <span class="string">&quot;LiHua&quot;</span>,</span><br><span class="line">        .uiHeight = <span class="number">176</span>&#125;,</span><br><span class="line">        &#123;.stHashNode = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">        .ulIdentifier = <span class="number">2</span>,</span><br><span class="line">        .ucAge = <span class="number">22</span>,</span><br><span class="line">        .pcName = <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">        .uiHeight = <span class="number">168</span>&#125;,</span><br><span class="line">        &#123;.stHashNode = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">        .ulIdentifier = <span class="number">2</span>,</span><br><span class="line">        .ucAge = <span class="number">22</span>,</span><br><span class="line">        .pcName = <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">        .uiHeight = <span class="number">168</span>&#125;,</span><br><span class="line">        &#123;.stHashNode = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">        .ulIdentifier = <span class="number">2</span>,</span><br><span class="line">        .ucAge = <span class="number">20</span>,</span><br><span class="line">        .pcName = <span class="string">&quot;John&quot;</span>,</span><br><span class="line">        .uiHeight = <span class="number">181</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> keySize = <span class="keyword">sizeof</span>(keyList) / <span class="keyword">sizeof</span>(keyList[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    DATA_NODE_S *retNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查找节点 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; keySize; i++) &#123;</span><br><span class="line">        retNode = (DATA_NODE_S *)hashFind(pstTable, (<span class="type">const</span> <span class="type">void</span> *)&amp;keyList[i], hashKeyCmp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (retNode != <span class="literal">NULL</span>) &#123; <span class="comment">// 查找成功</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Found data: \n&quot;</span>);</span><br><span class="line">            DATA_PRINT_INFO(hashFunc(retNode), retNode);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 删除节点，并由用户手动释放数据空间 */</span></span><br><span class="line">            hashDel(pstTable, (<span class="type">const</span> <span class="type">void</span> *)retNode, hashKeyCmp);</span><br><span class="line">            <span class="comment">// free(retNode);  // note1</span></span><br><span class="line">            retNode = <span class="literal">NULL</span>; <span class="comment">// 因后续还要使用变量，这里释放后手动置 NULL</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 再次查找节点 */</span></span><br><span class="line">            retNode = (DATA_NODE_S *)hashFind(pstTable, (<span class="type">const</span> <span class="type">void</span> *)&amp;keyList[i], hashKeyCmp);</span><br><span class="line">            <span class="keyword">if</span> (retNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Data delete failed\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Data delete successful\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Data not found\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hashPrint(pstTable);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 销毁哈希表，并释放数据空间 */</span></span><br><span class="line">    hashDestroy(pstTable, <span class="literal">true</span>);  <span class="comment">// note2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; dataSize; i++) &#123;</span></span><br><span class="line"><span class="comment">        free(nodeList[i]);  // note3</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">free</span>(nodeList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：note1~3 选择一处释放即可，否则会出现重复释放，报错 <code>free(): double free detected in tcache 2</code>。</p>
<h2 id="测试结果">测试结果</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">No.1 hash bucket has 1 nodes</span><br><span class="line">    Bucket id = 1, .Identifier = 1, .Age = 18, .Name = Bob, .Height = 178cm</span><br><span class="line">No.2 hash bucket has 2 nodes</span><br><span class="line">    Bucket id = 2, .Identifier = 2, .Age = 22, .Name = Alice, .Height = 168cm</span><br><span class="line">    Bucket id = 2, .Identifier = 2, .Age = 20, .Name = John, .Height = 181cm</span><br><span class="line">No.3 hash bucket has 1 nodes</span><br><span class="line">    Bucket id = 3, .Identifier = 3, .Age = 18, .Name = LiHua, .Height = 176cm</span><br><span class="line">Found data:</span><br><span class="line">    Bucket id = 3, .Identifier = 3, .Age = 18, .Name = LiHua, .Height = 176cm</span><br><span class="line">Data delete successful</span><br><span class="line">No.1 hash bucket has 1 nodes</span><br><span class="line">    Bucket id = 1, .Identifier = 1, .Age = 18, .Name = Bob, .Height = 178cm</span><br><span class="line">No.2 hash bucket has 2 nodes</span><br><span class="line">    Bucket id = 2, .Identifier = 2, .Age = 22, .Name = Alice, .Height = 168cm</span><br><span class="line">    Bucket id = 2, .Identifier = 2, .Age = 20, .Name = John, .Height = 181cm</span><br><span class="line">Found data:</span><br><span class="line">    Bucket id = 2, .Identifier = 2, .Age = 22, .Name = Alice, .Height = 168cm</span><br><span class="line">Data delete successful</span><br><span class="line">No.1 hash bucket has 1 nodes</span><br><span class="line">    Bucket id = 1, .Identifier = 1, .Age = 18, .Name = Bob, .Height = 178cm</span><br><span class="line">No.2 hash bucket has 1 nodes</span><br><span class="line">    Bucket id = 2, .Identifier = 2, .Age = 20, .Name = John, .Height = 181cm</span><br><span class="line">Data not found</span><br><span class="line">No.1 hash bucket has 1 nodes</span><br><span class="line">    Bucket id = 1, .Identifier = 1, .Age = 18, .Name = Bob, .Height = 178cm</span><br><span class="line">No.2 hash bucket has 1 nodes</span><br><span class="line">    Bucket id = 2, .Identifier = 2, .Age = 20, .Name = John, .Height = 181cm</span><br><span class="line">Found data:</span><br><span class="line">    Bucket id = 2, .Identifier = 2, .Age = 20, .Name = John, .Height = 181cm</span><br><span class="line">Data delete successful</span><br><span class="line">No.1 hash bucket has 1 nodes</span><br><span class="line">    Bucket id = 1, .Identifier = 1, .Age = 18, .Name = Bob, .Height = 178cm</span><br></pre></td></tr></table></figure>
<h1 id="哈希表实现完整代码">哈希表实现完整代码</h1>
<details>
  <summary>哈希表实现完整代码（点击展开）</summary>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该代码未经过完备的测试验证 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagDL_NODE</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagDL_NODE</span> *<span class="title">pstNext</span>;</span> <span class="comment">// A pointer to the next element</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagDL_NODE</span> *<span class="title">pstPrev</span>;</span> <span class="comment">// A pointer to the prev element</span></span><br><span class="line">&#125; DL_NODE_S;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表头节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagDL_HEAD</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulSize; <span class="comment">// the element numbers in the double-linked</span></span><br><span class="line">    DL_NODE_S *pstFirst; <span class="comment">// the first element in the double-linked</span></span><br><span class="line">&#125; DL_HEAD_S;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> DL_HEAD_S HASH_LIST_S;</span><br><span class="line"><span class="keyword">typedef</span> DL_NODE_S HASH_NODE_S;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagHASH_TABLE</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulSize;</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*pfHash)</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *)</span>;</span><br><span class="line">    HASH_LIST_S *pstBckt; <span class="comment">// 哈希桶中始终存储着双向链表的头节点</span></span><br><span class="line">&#125; HASH_TABLE_S;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表头节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagHASH_HEAD</span> &#123;</span></span><br><span class="line">    HASH_TABLE_S *pstTable;</span><br><span class="line">    <span class="comment">/* 其它成员，如哈希表创建时间、哈希表状态、节点数量、锁等 */</span></span><br><span class="line">&#125; HASH_HEAD_S;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagDataNode</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 哈希节点，不可少，且要作为首位成员 */</span></span><br><span class="line">    HASH_NODE_S stHashNode;</span><br><span class="line">    <span class="comment">/* hash key */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulIdentifier;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ucAge;</span><br><span class="line">    <span class="type">char</span> *pcName;</span><br><span class="line">    <span class="comment">/* hash payload */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uiHeight;</span><br><span class="line">&#125; DATA_NODE_S;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH_BUCKET_SIZE (10000)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATA_PRINT_INFO(bucketId, pstNode) \</span></span><br><span class="line"><span class="meta">    do &#123; \</span></span><br><span class="line"><span class="meta">        DATA_NODE_S *pstData = (DATA_NODE_S *)(pstNode); \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">&quot;    Bucket id = %lu, .Identifier = %lu, .Age = %d, .Name = %s, .Height = %dcm\n&quot;</span>, \</span></span><br><span class="line"><span class="meta">                (bucketId), pstData-&gt;ulIdentifier, pstData-&gt;ucAge, pstData-&gt;pcName, pstData-&gt;uiHeight); \</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH_NODE_DEL_FREE(pstBckt, pstDelNode, bFree) \</span></span><br><span class="line"><span class="meta">    do &#123; \</span></span><br><span class="line"><span class="meta">        dlNodeDel((DL_HEAD_S *)(pstBckt), (DL_NODE_S *)(pstDelNode)); \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> ((bFree) &amp;&amp; (pstDelNode) != NULL) &#123; \</span></span><br><span class="line"><span class="meta">            free((DATA_NODE_S *)(pstDelNode)); \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">hashFunc</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *pKey)</span> &#123;</span><br><span class="line">    <span class="type">const</span> DATA_NODE_S *pstKey = (<span class="type">const</span> DATA_NODE_S *)pKey;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstKey) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s():%d: null pointer\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">long</span>)(pstKey-&gt;ulIdentifier % HASH_BUCKET_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">hashKeyCmp</span><span class="params">(<span class="type">const</span> HASH_NODE_S *pstHashNode, <span class="type">const</span> <span class="type">void</span> *pKey)</span> &#123;</span><br><span class="line">    <span class="type">const</span> DATA_NODE_S *pstNode = (<span class="type">const</span> DATA_NODE_S *)pstHashNode;</span><br><span class="line">    <span class="type">const</span> DATA_NODE_S *pstKey = (<span class="type">const</span> DATA_NODE_S *)pKey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstNode || <span class="literal">NULL</span> == pstKey) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s():%d: null pointer\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pstNode-&gt;ulIdentifier != pstKey-&gt;ulIdentifier || \</span><br><span class="line">        pstNode-&gt;ucAge != pstKey-&gt;ucAge || <span class="built_in">strcmp</span>(pstNode-&gt;pcName, pstKey-&gt;pcName) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">dlNodeDel</span><span class="params">(DL_HEAD_S *pstHead, DL_NODE_S *pstNode)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstNode || <span class="literal">NULL</span> == pstHead) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 前一个节点不为空，则 pstNode 不是头结点 */</span></span><br><span class="line">    <span class="keyword">if</span> (pstNode-&gt;pstPrev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 将前一个节点的下一个节点指针指向当前节点的下一个节点</span></span><br><span class="line">        pstNode-&gt;pstPrev-&gt;pstNext = pstNode-&gt;pstNext;</span><br><span class="line">        <span class="keyword">if</span> (pstNode-&gt;pstNext != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 将下一个节点的前一个节点指针指向当前节点的前一个节点</span></span><br><span class="line">            pstNode-&gt;pstNext-&gt;pstPrev = pstNode-&gt;pstPrev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 更新头节点为下一个节点，并将其上一个节点指向 NULL */</span></span><br><span class="line">        pstHead-&gt;pstFirst = pstNode-&gt;pstNext;</span><br><span class="line">        <span class="keyword">if</span> (pstNode-&gt;pstNext != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pstNode-&gt;pstNext-&gt;pstPrev = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pstHead-&gt;ulSize--;  <span class="comment">// 删除节点后，更新节点数量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HASH_TABLE_S *<span class="title function_">hashCreate</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> ulSize, <span class="type">unsigned</span> <span class="type">long</span> (*pfHash)(<span class="type">const</span> <span class="type">void</span> *))</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ulSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s():%d: hash bucket size should be large zero\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HASH_TABLE_S *pstTable = (HASH_TABLE_S *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HASH_TABLE_S));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstTable) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s():%d: Could not allocate memory for hash table\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HASH_LIST_S *pstBckt = (HASH_LIST_S *)<span class="built_in">malloc</span>((ulSize + <span class="number">1</span>) * <span class="keyword">sizeof</span>(HASH_LIST_S));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstBckt) &#123;</span><br><span class="line">        <span class="built_in">free</span>(pstTable);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s():%d: Could not allocate memory for hash bucket\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(pstBckt, <span class="number">0</span>, (ulSize + <span class="number">1</span>) * <span class="keyword">sizeof</span>(HASH_LIST_S));</span><br><span class="line"></span><br><span class="line">    pstTable-&gt;ulSize = ulSize + <span class="number">1</span>;</span><br><span class="line">    pstTable-&gt;pfHash = pfHash;</span><br><span class="line">    pstTable-&gt;pstBckt = pstBckt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pstTable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hashAdd</span><span class="params">(HASH_TABLE_S *pstTable, HASH_NODE_S *pstNode)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstTable || <span class="literal">NULL</span> == pstNode || <span class="literal">NULL</span> == pstTable-&gt;pfHash) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s():%d: null pointer\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 通过哈希函数获取指定桶的地址 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulIndex = pstTable-&gt;pfHash((<span class="type">const</span> <span class="type">void</span> *)pstNode);</span><br><span class="line">    DL_HEAD_S *pstBckt = (DL_HEAD_S *)(&amp;pstTable-&gt;pstBckt[ulIndex]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstBckt) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s():%d: null pointer of hash bucket head\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在头节点前插入节点 */</span></span><br><span class="line">    pstNode-&gt;pstPrev = <span class="literal">NULL</span>; <span class="comment">// 新节点的 prev 指向 NULL</span></span><br><span class="line">    pstNode-&gt;pstNext = pstBckt-&gt;pstFirst; <span class="comment">// 新节点的 next 指向头结点</span></span><br><span class="line">    <span class="keyword">if</span> (pstBckt-&gt;pstFirst != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pstBckt-&gt;pstFirst-&gt;pstPrev = pstNode; <span class="comment">// 原头结点的 prev 指向新节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新头节点为插入的节点，并更新 DL 节点数量 */</span></span><br><span class="line">    pstBckt-&gt;pstFirst = pstNode; </span><br><span class="line">    pstBckt-&gt;ulSize++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HASH_NODE_S *<span class="title function_">hashFind</span><span class="params">(HASH_TABLE_S *pstTable, <span class="type">const</span> <span class="type">void</span> *pKey, <span class="type">long</span> (*pfKeyCmp)(<span class="type">const</span> HASH_NODE_S *, <span class="type">const</span> <span class="type">void</span> *))</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstTable || <span class="literal">NULL</span> == pKey || <span class="literal">NULL</span> == pfKeyCmp || <span class="literal">NULL</span> == pstTable-&gt;pfHash) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s():%d: null pointer\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 通过哈希函数获取指定桶的地址 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulIndex = pstTable-&gt;pfHash(pKey);</span><br><span class="line">    DL_HEAD_S *pstBckt = (DL_HEAD_S *)(&amp;pstTable-&gt;pstBckt[ulIndex]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstBckt) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s():%d: null pointer of hash bucket head\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这里遍历链表需要 O(N) 时间，可考虑优化为红黑树，使得时间为 O(logN) */</span></span><br><span class="line">    DL_NODE_S *pstNode = pstBckt-&gt;pstFirst;</span><br><span class="line">    <span class="keyword">while</span> (pstNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pfKeyCmp(pstNode, pKey) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pstNode;</span><br><span class="line">        &#125;</span><br><span class="line">        pstNode = pstNode-&gt;pstNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hashDel</span><span class="params">(HASH_TABLE_S *pstTable, <span class="type">const</span> <span class="type">void</span> *pKey, <span class="type">long</span> (*pfKeyCmp)(<span class="type">const</span> HASH_NODE_S *, <span class="type">const</span> <span class="type">void</span> *))</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstTable || <span class="literal">NULL</span> == pKey || <span class="literal">NULL</span> == pfKeyCmp || <span class="literal">NULL</span> == pstTable-&gt;pfHash) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s():%d: null pointer\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 通过哈希函数获取指定桶的地址 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulIndex = pstTable-&gt;pfHash(pKey);</span><br><span class="line">    DL_HEAD_S *pstBckt = (DL_HEAD_S *)(&amp;pstTable-&gt;pstBckt[ulIndex]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstBckt) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s():%d: null pointer of hash bucket head\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这里遍历链表需要 O(N)时间，可考虑优化为红黑树，使得时间为 O(logN) */</span></span><br><span class="line">    DL_NODE_S *pstNode = pstBckt-&gt;pstFirst;</span><br><span class="line">    <span class="keyword">while</span> (pstNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pfKeyCmp(pstNode, pKey) == <span class="number">0</span>) &#123;</span><br><span class="line">            dlNodeDel((DL_HEAD_S *)pstBckt, (DL_NODE_S *)pstNode);</span><br><span class="line">            <span class="comment">/* 从哈希桶中移除 DL 节点，但不释放数据，它由用户决定 */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pstNode = pstNode-&gt;pstNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hashPrint</span><span class="params">(HASH_TABLE_S *pstTable)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstTable) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s():%d: null pointer\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 遍历哈希表中的每一个哈希桶的所有节点，并对节点执行特定操作 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; pstTable-&gt;ulSize; i++) &#123;</span><br><span class="line">        DL_HEAD_S *pstBckt = (DL_HEAD_S *)(&amp;pstTable-&gt;pstBckt[i]);</span><br><span class="line">        <span class="keyword">if</span> (pstBckt != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            DL_NODE_S *pstNode = pstBckt-&gt;pstFirst;</span><br><span class="line">            <span class="keyword">if</span> (pstBckt-&gt;ulSize &gt; <span class="number">0</span> &amp;&amp; pstNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;No.%lu hash bucket has %lu nodes\n&quot;</span>, i, pstBckt-&gt;ulSize);</span><br><span class="line">                <span class="keyword">while</span> (pstNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    DATA_PRINT_INFO(i, pstNode); <span class="comment">// 打印的内容</span></span><br><span class="line">                    pstNode = pstNode-&gt;pstNext;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hashDestroy</span><span class="params">(HASH_TABLE_S *pstTable, <span class="type">bool</span> bFree)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pstTable) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s():%d: null pointer\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 遍历哈希表中的每一个哈希桶的所有节点，并对节点执行特定操作 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; pstTable-&gt;ulSize; i++) &#123;</span><br><span class="line">        DL_HEAD_S *pstBckt = (DL_HEAD_S *)(&amp;pstTable-&gt;pstBckt[i]);</span><br><span class="line">        <span class="keyword">if</span> (pstBckt != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            DL_NODE_S *pstNode = pstBckt-&gt;pstFirst;</span><br><span class="line">            <span class="keyword">while</span> (pstNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                DL_NODE_S *pstDelNode = pstNode;</span><br><span class="line">                pstNode = pstNode-&gt;pstNext;</span><br><span class="line">                HASH_NODE_DEL_FREE(pstBckt, pstDelNode, bFree); <span class="comment">// 删除节点，按需释放数据内存</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(pstTable-&gt;pstBckt);</span><br><span class="line">    <span class="built_in">free</span>(pstTable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    assert(HASH_BUCKET_SIZE &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    HASH_HEAD_S *hashHead = (HASH_HEAD_S *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HASH_HEAD_S));</span><br><span class="line">    assert(hashHead != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    hashHead-&gt;pstTable = hashCreate(HASH_BUCKET_SIZE, hashFunc);</span><br><span class="line">    assert(hashHead-&gt;pstTable != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    HASH_TABLE_S *pstTable = hashHead-&gt;pstTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建测试数据 */</span></span><br><span class="line">    DATA_NODE_S dataList[] = &#123;</span><br><span class="line">        &#123;.stHashNode = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">        .ulIdentifier = <span class="number">1</span>,</span><br><span class="line">        .ucAge = <span class="number">18</span>,</span><br><span class="line">        .pcName = <span class="string">&quot;Bob&quot;</span>,</span><br><span class="line">        .uiHeight = <span class="number">178</span>&#125;,</span><br><span class="line">        &#123;.stHashNode = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">        .ulIdentifier = <span class="number">2</span>,</span><br><span class="line">        .ucAge = <span class="number">20</span>,</span><br><span class="line">        .pcName = <span class="string">&quot;John&quot;</span>,</span><br><span class="line">        .uiHeight = <span class="number">181</span>&#125;,</span><br><span class="line">        &#123;.stHashNode = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">        .ulIdentifier = <span class="number">3</span>,</span><br><span class="line">        .ucAge = <span class="number">18</span>,</span><br><span class="line">        .pcName = <span class="string">&quot;LiHua&quot;</span>,</span><br><span class="line">        .uiHeight = <span class="number">176</span>&#125;,</span><br><span class="line">        &#123;.stHashNode = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">        .ulIdentifier = <span class="number">2</span>,</span><br><span class="line">        .ucAge = <span class="number">22</span>,</span><br><span class="line">        .pcName = <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">        .uiHeight = <span class="number">168</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> dataSize = <span class="keyword">sizeof</span>(dataList) / <span class="keyword">sizeof</span>(dataList[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    DATA_NODE_S **nodeList = (DATA_NODE_S **)<span class="built_in">malloc</span>(dataSize * <span class="keyword">sizeof</span>(DATA_NODE_S *));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加节点，无法确定节点是否重复时，应先执行查找操作 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dataSize; i++) &#123;</span><br><span class="line">        nodeList[i] = (DATA_NODE_S *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DATA_NODE_S));</span><br><span class="line">        <span class="built_in">memcpy</span>(nodeList[i], &amp;dataList[i], <span class="keyword">sizeof</span>(DATA_NODE_S));</span><br><span class="line">        <span class="comment">// 因 DATA_NODE_S 的靠前的成员，正好为 HASH_NODE_S 的所有成员；因此，强转 DATA_NODE_S，不会修改其它成员的信息</span></span><br><span class="line">        hashAdd(pstTable, (HASH_NODE_S *)nodeList[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印哈希表中的所有节点 */</span></span><br><span class="line">    hashPrint(pstTable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建查找数据 */</span></span><br><span class="line">    DATA_NODE_S keyList[] = &#123;</span><br><span class="line">        &#123;.stHashNode = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">        .ulIdentifier = <span class="number">3</span>,</span><br><span class="line">        .ucAge = <span class="number">18</span>,</span><br><span class="line">        .pcName = <span class="string">&quot;LiHua&quot;</span>,</span><br><span class="line">        .uiHeight = <span class="number">176</span>&#125;,</span><br><span class="line">        &#123;.stHashNode = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">        .ulIdentifier = <span class="number">2</span>,</span><br><span class="line">        .ucAge = <span class="number">22</span>,</span><br><span class="line">        .pcName = <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">        .uiHeight = <span class="number">168</span>&#125;,</span><br><span class="line">        &#123;.stHashNode = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">        .ulIdentifier = <span class="number">2</span>,</span><br><span class="line">        .ucAge = <span class="number">22</span>,</span><br><span class="line">        .pcName = <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">        .uiHeight = <span class="number">168</span>&#125;,</span><br><span class="line">        &#123;.stHashNode = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">        .ulIdentifier = <span class="number">2</span>,</span><br><span class="line">        .ucAge = <span class="number">20</span>,</span><br><span class="line">        .pcName = <span class="string">&quot;John&quot;</span>,</span><br><span class="line">        .uiHeight = <span class="number">181</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> keySize = <span class="keyword">sizeof</span>(keyList) / <span class="keyword">sizeof</span>(keyList[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    DATA_NODE_S *retNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查找节点 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; keySize; i++) &#123;</span><br><span class="line">        retNode = (DATA_NODE_S *)hashFind(pstTable, (<span class="type">const</span> <span class="type">void</span> *)&amp;keyList[i], hashKeyCmp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (retNode != <span class="literal">NULL</span>) &#123; <span class="comment">// 查找成功</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Found data: \n&quot;</span>);</span><br><span class="line">            DATA_PRINT_INFO(hashFunc(retNode), retNode);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 删除节点，并由用户手动释放数据空间 */</span></span><br><span class="line">            hashDel(pstTable, (<span class="type">const</span> <span class="type">void</span> *)retNode, hashKeyCmp);</span><br><span class="line">            <span class="comment">// free(retNode);  // note1</span></span><br><span class="line">            retNode = <span class="literal">NULL</span>; <span class="comment">// 因后续还要使用变量，这里释放后手动置 NULL</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 再次查找节点 */</span></span><br><span class="line">            retNode = (DATA_NODE_S *)hashFind(pstTable, (<span class="type">const</span> <span class="type">void</span> *)&amp;keyList[i], hashKeyCmp);</span><br><span class="line">            <span class="keyword">if</span> (retNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Data delete failed\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Data delete successful\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Data not found\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hashPrint(pstTable);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 销毁哈希表，并释放数据空间 */</span></span><br><span class="line">    hashDestroy(pstTable, <span class="literal">true</span>);  <span class="comment">// note2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; dataSize; i++) &#123;</span></span><br><span class="line"><span class="comment">        free(nodeList[i]);  // note3</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">free</span>(nodeList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>哈希表</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>双向链表</tag>
      </tags>
  </entry>
  <entry>
    <title>项目之 HTTP 服务器实现</title>
    <url>/posts/240507194549.html</url>
    <content><![CDATA[<p>tinyhttpd 是一个简易的 HTTP 服务器，支持 CGI。代码量少，非常容易阅读，十分适合网络编程初学者学习的项目。麻雀虽小，五脏俱全。在 tinyhttpd 中可以学到 linux 上进程的创建、管道的使用。Linux 下 socket 编程基本方法和 HTTP 协议的最基本结构。</p>
<span id="more"></span>
<h1 id="函数描述">函数描述</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">error_die</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *)</span>;       <span class="comment">// 异常信息写到 perror 并退出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_line</span><span class="params">(<span class="type">int</span>, <span class="type">char</span> *, <span class="type">int</span>)</span>;     <span class="comment">// 读取 request headers 的一行，把回车换行等情况都统一为换行符结束</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cat</span><span class="params">(<span class="type">int</span>, FILE *)</span>;              <span class="comment">// 读取 server 上的一个文件，写到 client socket</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">serve_file</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *)</span>; <span class="comment">// 调用响应头并调用 cat 函数，将 server 上的文件发给 client</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">headers</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *)</span>;    <span class="comment">// 构造 200 OK 的响应头部，写到套接字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bad_request</span><span class="params">(<span class="type">int</span>)</span>;              <span class="comment">// 返回给客户端一个 400 BAD REQUEST 响应报文</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">not_found</span><span class="params">(<span class="type">int</span>)</span>;                <span class="comment">// 返回给客户端一个 404 NOT FOUND 响应报文</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cannot_execute</span><span class="params">(<span class="type">int</span>)</span>;           <span class="comment">// 返回给客户端一个 500 Internal Server Error 响应报文，主要处理发生在执行 CGI 程序时出现的错误</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unimplemented</span><span class="params">(<span class="type">int</span>)</span>;            <span class="comment">// 返回给客户端一个 501 Method Not Implemented 响应报文，表明 httpd 服务器不支持该方法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">startup</span><span class="params">(u_short *)</span>;             <span class="comment">// 建立 HTTP 服务，包括创建套接字、绑定端口、监听客户端等</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">accept_request</span><span class="params">(<span class="type">void</span> *)</span>;       <span class="comment">// 处理 server 监听到的 client socket 的一个 HTTP 请求，在这里体现了服务器处理请求的流程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">execute_cgi</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *)</span>; <span class="comment">// 执行 CGI 脚本程序，核心执行函数</span></span><br></pre></td></tr></table></figure>
<p>不熟悉 HTTP 协议的可以看 <a href="https://blog.csdn.net/chen1415886044/article/details/103748926"> 这篇博客</a>。</p>
<p><strong>建议源码阅读顺序</strong>：</p>
<p>main -&gt; startup -&gt; accept_request -&gt; execute_cgi，通晓主要工作流程后，再仔细把每个函数的源码看一看。</p>
<h1 id="项目结构">项目结构</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./</span><br><span class="line">├── client  # makefile 编译产生</span><br><span class="line">├── htdocs</span><br><span class="line">│   ├── check.cgi  # 744 &lt;- Linux 文件权限</span><br><span class="line">│   ├── color.c    # 644</span><br><span class="line">│   ├── color.cgi  # 744</span><br><span class="line">│   ├── color_cgi  # 755, makefile 编译产生</span><br><span class="line">│   ├── index.html # 600</span><br><span class="line">│   └── README</span><br><span class="line">├── httpd  # makefile 编译产生</span><br><span class="line">├── httpd.c</span><br><span class="line">├── LICENSE</span><br><span class="line">├── Makefile</span><br><span class="line">├── README.md</span><br><span class="line">└── simpleclient.c</span><br></pre></td></tr></table></figure>
<h1 id="整体执行流程">整体执行流程</h1>
<p>整体执行流程图如下：</p>
<img src="../images/projects/httpServer/httpd-flowchart.png" alt="httpd 执行流程图" width="100%" height="100%">
<h1 id="工作流程">工作流程</h1>
<ol>
<li>
<p>【setup 函数】服务器启动，在指定端口或随机选取端口绑定 httpd 服务。</p>
</li>
<li>
<p>【main 函数死循环】收到一个 HTTP 请求报文时（其实就是 listen 的端口 accpet 的时候），派生一个线程运行 accept_request 函数。</p>
</li>
<li>
<p>【accept_request 函数】取出 HTTP 请求报文的请求行中的 method (GET 或 POST) 和 url。</p>
<ul>
<li>对于 GET 方法，如果有携带参数，则 query_string 指针指向 url 中 ? 后面的 GET 参数。</li>
<li>格式化 url 到 path 数组，path 表示浏览器请求的服务器文件路径（在 tinyhttpd 中服务器文件位于 htdocs 文件夹下）。当 url 以 / 结尾，或 url 是个目录，则默认在 path 中加上 index.html，表示访问主页。</li>
<li>如果文件路径合法，对于无参数的 GET 请求，直接输出服务器文件到浏览器，即用 HTTP 格式写到套接字上，跳到流程 10。其他情况（带参数 GET、POST 方式，url 为可执行文件），则调用 excute_cgi 函数执行 cgi 脚本。</li>
</ul>
</li>
<li>
<p>【excute_cgi 函数】读取整个 HTTP 请求头并丢弃，如果是 POST 则找出 Content-Length 的值并放到环境变量中（后续 POST 请求使用）。然后，把 HTTP 200 状态码写到套接字。建立两个管道，cgi_input 和 cgi_output，并 fork 一个子进程。</p>
<ul>
<li>在子进程中，把 STDOUT 重定向到 cgi_output 的写入端，把 STDIN 重定向到 cgi_input 的读取端，关闭 cgi_input 的写入端 和 cgi_output 的读取端。然后，设置 request_method 环境变量，GET 的话设置 query_string 环境变量，POST 的话设置 content_length 环境变量，<strong>这些环境变量都是为了给 cgi 脚本调用</strong>，接着调用 execl 运行 cgi 程序。</li>
<li>在父进程中，关闭 cgi_input 的读取端和 cgi_output 的写入端。<strong>如果 POST 的话，把 POST 数据写入 cgi_input，已被重定向到 STDIN，读取 cgi_output 管道的输出到客户端，该管道输入是 STDOUT</strong>。接着关闭所有管道，等待子进程结束。这一部分比较乱，见“httpd 执行流程图”的管道流向状态图。</li>
</ul>
</li>
<li>
<p>关闭与浏览器的连接，完成了一次 HTTP 请求与响应，因为 HTTP 是无连接的。</p>
</li>
</ol>
<blockquote>
<p>尽管 HTTP 在 TCP 之上运行，但 HTTP 被称为“无连接”是因为它每次请求 - 响应周期都是短暂的，没有保持持久连接状态。这意味着每个请求都需要在客户端和服务器之间建立一个新的 TCP 连接，并在请求完成后立即关闭连接。</p>
</blockquote>
<h1 id="项目编译">项目编译</h1>
<p>Makefile 文件：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all: httpd client ./htdocs/color_cgi</span></span><br><span class="line">LIBS = -lpthread <span class="comment">#-lsocket</span></span><br><span class="line"><span class="section">httpd: httpd.c</span></span><br><span class="line">	gcc -g -W -Wall <span class="variable">$(LIBS)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">client: simpleclient.c</span></span><br><span class="line">	gcc -W -Wall -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">./htdocs/color_cgi: ./htdocs/color.c</span></span><br><span class="line">	gcc -W -Wall -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm httpd client ./htdocs/color_cgi</span><br></pre></td></tr></table></figure>
<h1 id="验证 httpd 服务器">验证 httpd 服务器</h1>
<img src="../images/projects/httpServer/get-post-url.png" alt="GET 与 POST 请求" width="90%" height="90%">
<h2 id="CGI- 程序">CGI 程序</h2>
<p>这里使用 C 语言写一个 CGI 简单程序：通过获取服务器 execute_cgi 函数设置的 CONTENT_LENGTH 环境变量，来拿到请求正文的长度、解析出 color 表单数据，并使用 color 值生成相应的简单页面。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc -o color_cgi color.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LENGTH (1024)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数用于从标准输入读取 POST 数据</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">get_post_data</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *post_data = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> *content_length_str = getenv(<span class="string">&quot;CONTENT_LENGTH&quot;</span>); <span class="comment">// 服务器 execute_cgi 函数设置的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (content_length_str != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> content_length = atoi(content_length_str);</span><br><span class="line">        <span class="keyword">if</span> (content_length &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            post_data = (<span class="type">char</span> *)<span class="built_in">malloc</span>((content_length + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">            fgets(post_data, content_length + <span class="number">1</span>, <span class="built_in">stdin</span>); <span class="comment">// 从标准输入读取 n 个字节到数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> post_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取 POST 数据</span></span><br><span class="line">    <span class="type">char</span> *post_data = get_post_data();</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> color[MAX_LENGTH] = <span class="string">&quot;yellow&quot;</span>; <span class="comment">// 默认颜色为黄色</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (post_data != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 包含 HTTP POST 请求数据的字符串，格式类似于 key1=value1&amp;key2=value2&amp;key3=value3</span></span><br><span class="line">        <span class="type">char</span> *token = strtok(post_data, <span class="string">&quot;&amp;&quot;</span>); <span class="comment">// 返回第一个子字符串（键值对）的指针</span></span><br><span class="line">        <span class="keyword">while</span> (token != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> key[MAX_LENGTH], value[MAX_LENGTH];</span><br><span class="line">            <span class="built_in">sscanf</span>(token, <span class="string">&quot;%[^=]=%s&quot;</span>, key, value);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(key, <span class="string">&quot;color&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">strncpy</span>(color, value, MAX_LENGTH - <span class="number">1</span>);</span><br><span class="line">                color[MAX_LENGTH - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 确保字符串结尾</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            token = strtok(<span class="literal">NULL</span>, <span class="string">&quot;&amp;&quot;</span>); <span class="comment">// 获取下一个子字符串（键值对）的指针</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 HTML</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Content-type: text/html\r\n\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;!DOCTYPE html&gt;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;html&gt;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;head&gt;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    &lt;title&gt;%s&lt;/title&gt;\n&quot;</span>, color);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    &lt;style&gt;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;        body &#123;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            background-color: %s;\n&quot;</span>, color);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;        &#125;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    &lt;/style&gt;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;/head&gt;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;body&gt;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    &lt;h1&gt;This is %s&lt;/h1&gt;\n&quot;</span>, color);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;/body&gt;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;/html&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">if</span> (post_data != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(post_data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="GET 请求">GET 请求</h2>
<p><strong>HTTP 请求报文的一般格式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;request-line&gt;</span><br><span class="line">&lt;request-headers&gt;</span><br><span class="line">&lt;blank line&gt;</span><br><span class="line">&lt;request-body&gt;</span><br></pre></td></tr></table></figure>
<p>我们通过 Chrome 进行以下请求：</p>
<ul>
<li>Request URL: <a href="http://127.0.0.1:4000/index.html">http://127.0.0.1:4000/index.html</a></li>
<li>Request Method: GET</li>
</ul>
<p>Rqeuest Headers:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /index.html HTTP/1.1  # 请求行</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Host: 127.0.0.1:4000</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36</span><br></pre></td></tr></table></figure>
<p>上述请求的响应报文：</p>
<p>Response Headers:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Server: jdbhttpd/0.1.0</span><br><span class="line">Content-Type: text/html</span><br></pre></td></tr></table></figure>
<p>Response Body:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Index&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;p&gt;Welcome to J. David&#x27;s webserver.&lt;/p&gt;</span><br><span class="line">    &lt;h1&gt;CGI demo&lt;/h1&gt;</span><br><span class="line">    &lt;form action=&quot;color_cgi&quot; method=&quot;post&quot;&gt;</span><br><span class="line">        Enter a color: &lt;input type=&quot;text&quot; name=&quot;color&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot;&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="POST 请求">POST 请求</h2>
<p><strong>HTTP 响应报文的一般格式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;status-line&gt;</span><br><span class="line">&lt;response-headers&gt;</span><br><span class="line">&lt;blank line&gt;</span><br><span class="line">&lt;response-body&gt;</span><br></pre></td></tr></table></figure>
<p>我们通过 Chrome 进行以下请求：</p>
<ul>
<li>Request URL: <a href="http://127.0.0.1:4000/color_cgi">http://127.0.0.1:4000/color_cgi</a></li>
<li>Request Method: POST</li>
<li>这里的 color_cgi 是 color.c 编写的 CGI 程序编译成的可执行文件。</li>
</ul>
<p>Rqeuest Headers: 通过页面输入的 Form Data 为 color=gray</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /color_cgi HTTP/1.1  # 请求行</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 10  # 请求正文长度，在这里即 `color=gray`</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Host: 127.0.0.1:4000</span><br><span class="line">Origin: http://127.0.0.1:4000</span><br><span class="line">Referer: http://127.0.0.1:4000/</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36</span><br></pre></td></tr></table></figure>
<p>上述请求的响应报文：</p>
<p>Response Headers:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.0 200 OK  # 状态行</span><br><span class="line">Content-type: text/html</span><br></pre></td></tr></table></figure>
<p>Response Body:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;gray&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        body &#123;</span><br><span class="line">            background-color: gray;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;This is gray&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h1 id="完整源码">完整源码</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ISspace(x) isspace((int)(x)) <span class="comment">// 检查字符是否为空白字符（如空格、换行符等）</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_STRING <span class="string">&quot;Server: jdbhttpd/0.1.0\r\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CONNECTS (5) <span class="comment">// 监听（连接）的最大客户端数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_die</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *)</span>;       <span class="comment">// 异常信息写到 perror 并退出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_line</span><span class="params">(<span class="type">int</span>, <span class="type">char</span> *, <span class="type">int</span>)</span>;     <span class="comment">// 读取 request headers 的一行，把回车换行等情况都统一为换行符结束</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cat</span><span class="params">(<span class="type">int</span>, FILE *)</span>;              <span class="comment">// 读取 server 上的一个文件，写到 client socket</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">serve_file</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *)</span>; <span class="comment">// 调用响应头并调用 cat 函数，将 server 上的文件发给 client</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">headers</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *)</span>;    <span class="comment">// 构造 200 OK 的响应头部，写到套接字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bad_request</span><span class="params">(<span class="type">int</span>)</span>;              <span class="comment">// 返回给客户端一个 400 BAD REQUEST 响应报文</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">not_found</span><span class="params">(<span class="type">int</span>)</span>;                <span class="comment">// 返回给客户端一个 404 NOT FOUND 响应报文</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cannot_execute</span><span class="params">(<span class="type">int</span>)</span>;           <span class="comment">// 返回给客户端一个 500 Internal Server Error 响应报文，主要处理发生在执行 CGI 程序时出现的错误</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unimplemented</span><span class="params">(<span class="type">int</span>)</span>;            <span class="comment">// 返回给客户端一个 501 Method Not Implemented 响应报文，表明 httpd 服务器不支持该方法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">startup</span><span class="params">(u_short *)</span>;             <span class="comment">// 建立 HTTP 服务，包括创建套接字、绑定端口、监听客户端等</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">accept_request</span><span class="params">(<span class="type">void</span> *)</span>;       <span class="comment">// 处理 server 监听到的 client socket 的一个 HTTP 请求，在这里体现了服务器处理请求的流程</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">execute_cgi</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *)</span>; <span class="comment">// 执行 CGI 脚本程序，核心执行函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEND_BUF_MSG(sock_fd, buf, flags, msg, ...) \</span></span><br><span class="line"><span class="meta">    do                                              \</span></span><br><span class="line"><span class="meta">    &#123;                                               \</span></span><br><span class="line"><span class="meta">        sprintf(buf, msg, ##__VA_ARGS__);           \</span></span><br><span class="line"><span class="meta">        send(sock_fd, buf, strlen(buf), flags);     \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR_REPORT_WITH_EXIT(code, msg) \</span></span><br><span class="line"><span class="meta">    do                                    \</span></span><br><span class="line"><span class="meta">    &#123;                                     \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> ((code) &lt; 0)                   \</span></span><br><span class="line"><span class="meta">        &#123;                                 \</span></span><br><span class="line"><span class="meta">            error_die(msg);               \</span></span><br><span class="line"><span class="meta">        &#125;                                 \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_POINTER_NON_NULL(ptr)    \</span></span><br><span class="line"><span class="meta">    do                                 \</span></span><br><span class="line"><span class="meta">    &#123;                                  \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (NULL == (ptr))             \</span></span><br><span class="line"><span class="meta">        &#123;                              \</span></span><br><span class="line"><span class="meta">            error_die(<span class="string">&quot;null pointer&quot;</span>); \</span></span><br><span class="line"><span class="meta">        &#125;                              \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* A request has caused a call to accept() on the server port to</span></span><br><span class="line"><span class="comment"> * return.  Process the request appropriately.</span></span><br><span class="line"><span class="comment"> * Parameters: the socket connected to the client */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">accept_request</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c_sock_fd = (<span class="type">intptr_t</span>)arg;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">size_t</span> numchars;</span><br><span class="line">    <span class="type">char</span> method[<span class="number">255</span>];</span><br><span class="line">    <span class="type">char</span> url[<span class="number">255</span>];</span><br><span class="line">    <span class="type">char</span> path[<span class="number">512</span>];</span><br><span class="line">    <span class="type">size_t</span> i, j;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="type">int</span> cgi = <span class="number">0</span>; <span class="comment">/* becomes true if server decides this is a CGI program */</span></span><br><span class="line">    <span class="type">char</span> *query_string = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 读取 HTTP 请求报文的第一行数据，假如访问 https://www.google.com/search?q=socket</span></span><br><span class="line"><span class="comment">     * 那么，HTTP 请求报文的第一行数据是：GET /search?q=socket HTTP/1.1</span></span><br><span class="line"><span class="comment">     * HTTP 请求报文组成：</span></span><br><span class="line"><span class="comment">     *      请求方法 请求 URL HTTP 协议及版本</span></span><br><span class="line"><span class="comment">     *      请求报文头</span></span><br><span class="line"><span class="comment">     *      \r\n</span></span><br><span class="line"><span class="comment">     *      请求报文体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    numchars = get_line(c_sock_fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将请求方法存到 method 缓冲区 */</span></span><br><span class="line">    i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!ISspace(buf[i]) &amp;&amp; (i &lt; <span class="keyword">sizeof</span>(method) - <span class="number">1</span>)) <span class="comment">// 遍历到空白字符或缓存满为止</span></span><br><span class="line">    &#123;</span><br><span class="line">        method[i] = buf[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    j = i; <span class="comment">// 指向第一行数据的首个空白字符或缓存满的位置</span></span><br><span class="line">    method[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若请求的方法既不是 GET 或 POST，则发送 HTTP 响应报文，通知客户端请求的 Web 方法尚未实现 */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">0</span> != strcasecmp(method, <span class="string">&quot;GET&quot;</span>)) &amp;&amp; (<span class="number">0</span> != strcasecmp(method, <span class="string">&quot;POST&quot;</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        unimplemented(c_sock_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ISspace(buf[j]) &amp;&amp; (j &lt; numchars)) <span class="comment">// 跳过请求方法后面的所有空白字符（空格）</span></span><br><span class="line">    &#123;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将 HTTP 请求报文的请求 URL 存到 url 缓冲区 */</span></span><br><span class="line">    <span class="keyword">while</span> (!ISspace(buf[j]) &amp;&amp; (i &lt; <span class="keyword">sizeof</span>(url) - <span class="number">1</span>) &amp;&amp; (j &lt; numchars))</span><br><span class="line">    &#123;</span><br><span class="line">        url[i++] = buf[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    url[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若请求的方法是 POST，则服务器认为是 CGI 程序 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == strcasecmp(method, <span class="string">&quot;POST&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cgi = <span class="number">1</span>; <span class="comment">// 使能 CGI 标志</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 若请求的方法是 GET，且在 url 中检查到 ? 字符，</span></span><br><span class="line"><span class="comment">     * 则服务器认为是 CGI 程序，并从 ? 位置分隔 url 缓存区为两份字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == strcasecmp(method, <span class="string">&quot;GET&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        query_string = url;</span><br><span class="line">        <span class="keyword">while</span> ((*query_string != <span class="string">&#x27;?&#x27;</span>) &amp;&amp; (*query_string != <span class="string">&#x27;\0&#x27;</span>)) <span class="comment">// 遍历到 ? 字符或 \0 结束符为止</span></span><br><span class="line">        &#123;</span><br><span class="line">            query_string++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (*query_string == <span class="string">&#x27;?&#x27;</span>) <span class="comment">// 检查是 ? 字符还是 url 的 \0 导致的跳出循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            cgi = <span class="number">1</span>;              <span class="comment">// 使能 CGI 标志</span></span><br><span class="line">            *query_string = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 从 ? 位置分隔 url 缓存区为两份字符串</span></span><br><span class="line">            query_string++;       <span class="comment">// 指向后一份字符串的起始位置（? 字符的下一个字符位置）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 url 字符串的第一份（可能未分隔，只有一份）拼接在 htdocs 后面，并存储在 path 缓冲区</span></span><br><span class="line">    <span class="built_in">sprintf</span>(path, <span class="string">&quot;htdocs%s&quot;</span>, url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 path 缓冲区以 / 结尾，则拼接 index.html，即 Web 首页的意思</span></span><br><span class="line">    <span class="keyword">if</span> (path[<span class="built_in">strlen</span>(path) - <span class="number">1</span>] == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcat</span>(path, <span class="string">&quot;index.html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在服务器端中查找 path 缓冲区中的文件的状态信息，并将状态信息存储到 struct stat 指向的变量 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == stat(path, &amp;st))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果文件不存在，则按行读取 HTTP 请求的 headers，但都忽略掉；</span></span><br><span class="line"><span class="comment">         * 并向客户端发送 404 NOT FOUND&#x27;s response</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> ((numchars &gt; <span class="number">0</span>) &amp;&amp; (<span class="number">0</span> != <span class="built_in">strcmp</span>(<span class="string">&quot;\n&quot;</span>, buf))) <span class="comment">/* read &amp; discard headers */</span></span><br><span class="line">        &#123;</span><br><span class="line">            numchars = get_line(c_sock_fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        not_found(c_sock_fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 若文件类型为目录，则对路径拼接 index.html 首页 Web 文件 */</span></span><br><span class="line">        <span class="keyword">if</span> (S_ISDIR(st.st_mode))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcat</span>(path, <span class="string">&quot;/index.html&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 判断文件是否具有执行权限（任意用户），若是则使能 CGI 标志（才有权限执行 CGI 程序）*/</span></span><br><span class="line">        <span class="keyword">if</span> ((st.st_mode &amp; S_IXUSR) || (st.st_mode &amp; S_IXGRP) || (st.st_mode &amp; S_IXOTH))</span><br><span class="line">        &#123;</span><br><span class="line">            cgi = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 使能或未使能 CGI 对应不同动作 */</span></span><br><span class="line">        <span class="keyword">if</span> (cgi)</span><br><span class="line">        &#123;</span><br><span class="line">            execute_cgi(c_sock_fd, path, method, query_string);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            serve_file(c_sock_fd, path); <span class="comment">// 将服务器上的文件发给客户端</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(c_sock_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Inform the client that a request it has made has a problem.</span></span><br><span class="line"><span class="comment"> * Parameters: client socket */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bad_request</span><span class="params">(<span class="type">int</span> c_sock_fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    SEND_BUF_MSG(c_sock_fd, buf, <span class="number">0</span>, <span class="string">&quot;HTTP/1.0 400 BAD REQUEST\r\n&quot;</span>);</span><br><span class="line">    SEND_BUF_MSG(c_sock_fd, buf, <span class="number">0</span>, <span class="string">&quot;Content-type: text/html\r\n&quot;</span>);</span><br><span class="line">    SEND_BUF_MSG(c_sock_fd, buf, <span class="number">0</span>, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    SEND_BUF_MSG(c_sock_fd, buf, <span class="number">0</span>, <span class="string">&quot;&lt;P&gt;Your browser sent a bad request, &quot;</span>);</span><br><span class="line">    SEND_BUF_MSG(c_sock_fd, buf, <span class="number">0</span>, <span class="string">&quot;such as a POST without a Content-Length.\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Put the entire contents of a file out on a socket.  This function</span></span><br><span class="line"><span class="comment"> * is named after the UNIX &quot;cat&quot; command, because it might have been</span></span><br><span class="line"><span class="comment"> * easier just to do something like pipe, fork, and exec(&quot;cat&quot;).</span></span><br><span class="line"><span class="comment"> * Parameters: the client socket descriptor</span></span><br><span class="line"><span class="comment"> *             FILE pointer for the file to cat */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cat</span><span class="params">(<span class="type">int</span> c_sock_fd, FILE *resource)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 不断地从文件流中读取一行数据，然后发给客户端，直到 End of File 为止 */</span></span><br><span class="line">    fgets(buf, <span class="keyword">sizeof</span>(buf), resource);</span><br><span class="line">    <span class="keyword">while</span> (!feof(resource))</span><br><span class="line">    &#123;</span><br><span class="line">        send(c_sock_fd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">        fgets(buf, <span class="keyword">sizeof</span>(buf), resource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Inform the client that a CGI script could not be executed.</span></span><br><span class="line"><span class="comment"> * Parameter: the client socket descriptor. */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cannot_execute</span><span class="params">(<span class="type">int</span> c_sock_fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    SEND_BUF_MSG(c_sock_fd, buf, <span class="number">0</span>, <span class="string">&quot;HTTP/1.0 500 Internal Server Error\r\n&quot;</span>);</span><br><span class="line">    SEND_BUF_MSG(c_sock_fd, buf, <span class="number">0</span>, <span class="string">&quot;Content-type: text/html\r\n&quot;</span>);</span><br><span class="line">    SEND_BUF_MSG(c_sock_fd, buf, <span class="number">0</span>, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    SEND_BUF_MSG(c_sock_fd, buf, <span class="number">0</span>, <span class="string">&quot;&lt;P&gt;Error prohibited CGI execution.\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Print out an error message with perror() (for system errors; based</span></span><br><span class="line"><span class="comment"> * on value of errno, which indicates system call errors) and exit the</span></span><br><span class="line"><span class="comment"> * program indicating an error. */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">error_die</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *sc)</span></span><br><span class="line">&#123;</span><br><span class="line">    perror(sc);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Execute a CGI script.  Will need to set environment variables as</span></span><br><span class="line"><span class="comment"> * appropriate.</span></span><br><span class="line"><span class="comment"> * Parameters: client socket descriptor</span></span><br><span class="line"><span class="comment"> *             path to the CGI script */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">execute_cgi</span><span class="params">(<span class="type">int</span> c_sock_fd, <span class="type">const</span> <span class="type">char</span> *path,</span></span><br><span class="line"><span class="params">                 <span class="type">const</span> <span class="type">char</span> *method, <span class="type">const</span> <span class="type">char</span> *query_string)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> cgi_output[<span class="number">2</span>]; <span class="comment">// 管道的读端与写端文件描述符</span></span><br><span class="line">    <span class="type">int</span> cgi_input[<span class="number">2</span>];</span><br><span class="line">    <span class="type">pid_t</span> cpid;</span><br><span class="line">    <span class="type">int</span> w_status;</span><br><span class="line">    <span class="type">int</span> iter;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> numchars = <span class="number">1</span>; <span class="comment">// 初始时 buf 的长度</span></span><br><span class="line">    <span class="type">int</span> content_length = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * <span class="doctag">NOTE:</span> 因为这个函数被 accpect 函数调用（内部处理了客户端请求报文的请求行），</span></span><br><span class="line"><span class="comment">     * 故这里是从请求报头（第二行数据）开始接收处理的，但从请求行开始处理也没问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 按行读取 HTTP 请求 headers，但都忽略掉 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == strcasecmp(method, <span class="string">&quot;GET&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((numchars &gt; <span class="number">0</span>) &amp;&amp; (<span class="number">0</span> != <span class="built_in">strcmp</span>(<span class="string">&quot;\n&quot;</span>, buf))) <span class="comment">/* read &amp; discard headers */</span></span><br><span class="line">        &#123;</span><br><span class="line">            numchars = get_line(c_sock_fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 按行读取 HTTP 请求的 headers 并截断，获取 POST 方法中的 `Content-Length:` 的值 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == strcasecmp(method, <span class="string">&quot;POST&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> ((numchars &gt; <span class="number">0</span>) &amp;&amp; (<span class="number">0</span> != <span class="built_in">strcmp</span>(<span class="string">&quot;\n&quot;</span>, buf)))</span><br><span class="line">        &#123;</span><br><span class="line">            buf[<span class="number">15</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == strcasecmp(buf, <span class="string">&quot;Content-Length:&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 请求格式：Content-Length: 28，从子串中获取 Body 内容长度 */</span></span><br><span class="line">                content_length = atoi(&amp;(buf[<span class="number">16</span>]));</span><br><span class="line">                <span class="comment">/* break; */</span> <span class="comment">// 把 headers 接收完，所有不提前退出</span></span><br><span class="line">            &#125;</span><br><span class="line">            numchars = get_line(c_sock_fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == content_length)</span><br><span class="line">        &#123;</span><br><span class="line">            bad_request(c_sock_fd);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">/* HEAD or other */</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建 CGI 脚本的输入、输出管道 */</span></span><br><span class="line">    <span class="keyword">if</span> (pipe(cgi_output) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cannot_execute(c_sock_fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pipe(cgi_input) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cannot_execute(c_sock_fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cpid = fork();</span><br><span class="line">    <span class="keyword">if</span> (cpid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cannot_execute(c_sock_fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SEND_BUF_MSG(c_sock_fd, buf, <span class="number">0</span>, <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == cpid) <span class="comment">/* child process: CGI script */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> meth_env[<span class="number">255</span>];</span><br><span class="line">        <span class="type">char</span> query_env[<span class="number">255</span>];</span><br><span class="line">        <span class="type">char</span> length_env[<span class="number">255</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 将标准输出（输入）重定向到 CGI 输出（输入）管道的写端（读端），并关闭不使用的一端 */</span></span><br><span class="line">        dup2(cgi_output[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">        dup2(cgi_input[<span class="number">0</span>], STDIN_FILENO);</span><br><span class="line">        close(cgi_output[<span class="number">0</span>]);</span><br><span class="line">        close(cgi_input[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sprintf</span>(meth_env, <span class="string">&quot;REQUEST_METHOD=%s&quot;</span>, method);</span><br><span class="line">        putenv(meth_env);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == strcasecmp(method, <span class="string">&quot;GET&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(query_env, <span class="string">&quot;QUERY_STRING=%s&quot;</span>, query_string);</span><br><span class="line">            putenv(query_env);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">/* POST */</span></span><br><span class="line">            <span class="built_in">sprintf</span>(length_env, <span class="string">&quot;CONTENT_LENGTH=%d&quot;</span>, content_length);</span><br><span class="line">            putenv(length_env);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        close(cgi_output[<span class="number">1</span>]); <span class="comment">// 调用 execl 前关闭 fd</span></span><br><span class="line">        close(cgi_input[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        execl(path, <span class="string">&quot;&quot;</span>, <span class="literal">NULL</span>); <span class="comment">// `&quot;&quot;` 消除 warning</span></span><br><span class="line">        _exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; <span class="comment">/* parent process */</span></span><br><span class="line">        close(cgi_output[<span class="number">1</span>]);</span><br><span class="line">        close(cgi_input[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == strcasecmp(method, <span class="string">&quot;POST&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (iter = <span class="number">0</span>; iter &lt; content_length; iter++)</span><br><span class="line">            &#123;</span><br><span class="line">                recv(c_sock_fd, &amp;c, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                write(cgi_input[<span class="number">1</span>], &amp;c, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (read(cgi_output[<span class="number">0</span>], &amp;c, <span class="number">1</span>) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            send(c_sock_fd, &amp;c, <span class="number">1</span>, <span class="number">0</span>); <span class="comment">// With a zero flags argument, send() is equivalent to write()</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        close(cgi_output[<span class="number">0</span>]);</span><br><span class="line">        close(cgi_input[<span class="number">1</span>]);</span><br><span class="line">        waitpid(cpid, &amp;w_status, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Get a line from a socket, whether the line ends in a newline,</span></span><br><span class="line"><span class="comment"> * carriage return, or a CRLF combination.  Terminates the string read</span></span><br><span class="line"><span class="comment"> * with a null character.  If no newline indicator is found before the</span></span><br><span class="line"><span class="comment"> * end of the buffer, the string is terminated with a null.  If any of</span></span><br><span class="line"><span class="comment"> * the above three line terminators is read, the last character of the</span></span><br><span class="line"><span class="comment"> * string will be a linefeed and the string will be terminated with a</span></span><br><span class="line"><span class="comment"> * null character.</span></span><br><span class="line"><span class="comment"> * Parameters: the socket descriptor</span></span><br><span class="line"><span class="comment"> *             the buffer to save the data in</span></span><br><span class="line"><span class="comment"> *             the size of the buffer</span></span><br><span class="line"><span class="comment"> * Returns: the number of bytes stored (excluding null) */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_line</span><span class="params">(<span class="type">int</span> sock_fd, <span class="type">char</span> *buf, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> recv_bytes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((i &lt; size - <span class="number">1</span>) &amp;&amp; (c != <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        recv_bytes = recv(sock_fd, &amp;c, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (recv_bytes &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                recv_bytes = recv(sock_fd, &amp;c, <span class="number">1</span>, MSG_PEEK); <span class="comment">// 预读一个字节，不从管道弹出</span></span><br><span class="line">                <span class="keyword">if</span> ((recv_bytes &gt; <span class="number">0</span>) &amp;&amp; (c == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    recv(sock_fd, &amp;c, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    c = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            buf[i] = c;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            c = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Return the informational HTTP headers about a file. */</span></span><br><span class="line"><span class="comment">/* Parameters: the socket to print the headers on</span></span><br><span class="line"><span class="comment"> *             the name of the file */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">headers</span><span class="params">(<span class="type">int</span> c_sock_fd, <span class="type">const</span> <span class="type">char</span> *filename)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    (<span class="type">void</span>)filename; <span class="comment">/* could use filename to determine file type */</span></span><br><span class="line"></span><br><span class="line">    SEND_BUF_MSG(c_sock_fd, buf, <span class="number">0</span>, <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>);</span><br><span class="line">    SEND_BUF_MSG(c_sock_fd, buf, <span class="number">0</span>, SERVER_STRING);</span><br><span class="line">    SEND_BUF_MSG(c_sock_fd, buf, <span class="number">0</span>, <span class="string">&quot;Content-Type: text/html\r\n&quot;</span>);</span><br><span class="line">    SEND_BUF_MSG(c_sock_fd, buf, <span class="number">0</span>, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Give a client a 404 not found status message. */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">not_found</span><span class="params">(<span class="type">int</span> c_sock_fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    SEND_BUF_MSG(c_sock_fd, buf, <span class="number">0</span>, <span class="string">&quot;HTTP/1.0 404 NOT FOUND\r\n&quot;</span>);</span><br><span class="line">    SEND_BUF_MSG(c_sock_fd, buf, <span class="number">0</span>, SERVER_STRING);</span><br><span class="line">    SEND_BUF_MSG(c_sock_fd, buf, <span class="number">0</span>, <span class="string">&quot;Content-Type: text/html\r\n&quot;</span>);</span><br><span class="line">    SEND_BUF_MSG(c_sock_fd, buf, <span class="number">0</span>, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    SEND_BUF_MSG(c_sock_fd, buf, <span class="number">0</span>, <span class="string">&quot;&lt;HTML&gt;&lt;TITLE&gt;Not Found&lt;/TITLE&gt;\r\n&quot;</span>);</span><br><span class="line">    SEND_BUF_MSG(c_sock_fd, buf, <span class="number">0</span>, <span class="string">&quot;&lt;BODY&gt;&lt;P&gt;The server could not fulfill\r\n&quot;</span>);</span><br><span class="line">    SEND_BUF_MSG(c_sock_fd, buf, <span class="number">0</span>, <span class="string">&quot;your request because the resource specified\r\n&quot;</span>);</span><br><span class="line">    SEND_BUF_MSG(c_sock_fd, buf, <span class="number">0</span>, <span class="string">&quot;is unavailable or nonexistent.\r\n&quot;</span>);</span><br><span class="line">    SEND_BUF_MSG(c_sock_fd, buf, <span class="number">0</span>, <span class="string">&quot;&lt;/BODY&gt;&lt;/HTML&gt;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Send a regular file to the client.  Use headers, and report</span></span><br><span class="line"><span class="comment"> * errors to client if they occur.</span></span><br><span class="line"><span class="comment"> * Parameters: a pointer to a file structure produced from the socket</span></span><br><span class="line"><span class="comment"> *              file descriptor</span></span><br><span class="line"><span class="comment"> *             the name of the file to serve */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">serve_file</span><span class="params">(<span class="type">int</span> c_sock_fd, <span class="type">const</span> <span class="type">char</span> *filename)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *resource = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> numchars = <span class="number">1</span>; <span class="comment">// 初始时 buf 的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 按行读取 HTTP 请求的 headers，但都忽略掉 */</span></span><br><span class="line">    <span class="keyword">while</span> ((numchars &gt; <span class="number">0</span>) &amp;&amp; (<span class="number">0</span> != <span class="built_in">strcmp</span>(<span class="string">&quot;\n&quot;</span>, buf))) <span class="comment">/* read &amp; discard headers */</span></span><br><span class="line">    &#123;</span><br><span class="line">        numchars = get_line(c_sock_fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 打开服务器上的文件，若打开失败则发送 404 NOT FOUND 给客户端；</span></span><br><span class="line"><span class="comment">     * 否则，构造 response headers 和 response body，将文件发送给客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    resource = fopen(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == resource)</span><br><span class="line">    &#123;</span><br><span class="line">        not_found(c_sock_fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        headers(c_sock_fd, filename);</span><br><span class="line">        cat(c_sock_fd, resource);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(resource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* This function starts the process of listening for web connections</span></span><br><span class="line"><span class="comment"> * on a specified port.  If the port is 0, then dynamically allocate a</span></span><br><span class="line"><span class="comment"> * port and modify the original port variable to reflect the actual</span></span><br><span class="line"><span class="comment"> * port.</span></span><br><span class="line"><span class="comment"> * Parameters: pointer to variable containing the port to connect on</span></span><br><span class="line"><span class="comment"> * Returns: the socket */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">startup</span><span class="params">(u_short *port)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> httpd_fd;</span><br><span class="line">    <span class="type">int</span> on = <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">s_addr</span>;</span></span><br><span class="line">    <span class="type">int</span> ret_code;</span><br><span class="line"></span><br><span class="line">    CHECK_POINTER_NON_NULL(port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建一个 socket 描述符，但此时 socket 未与特定地址绑定 */</span></span><br><span class="line">    httpd_fd = socket(AF_INET,     <span class="comment">// IPv4 地址族</span></span><br><span class="line">                      SOCK_STREAM, <span class="comment">// 提供有序的，可靠的，双向的，基于字节流的通讯</span></span><br><span class="line">                      <span class="number">0</span>);          <span class="comment">// system picks protocol (as TCP)</span></span><br><span class="line">    ERROR_REPORT_WITH_EXIT(httpd_fd, <span class="string">&quot;socket&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化服务器的本地地址，用于与指定的文件描述符绑定（bind）在一起 */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;s_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(s_addr));</span><br><span class="line">    s_addr.sin_family = AF_INET;</span><br><span class="line">    s_addr.sin_port = htons(*port);</span><br><span class="line">    s_addr.sin_addr.s_addr = htonl(INADDR_ANY); <span class="comment">// INADDR_ANY = 0.0.0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * SO_REUSEADDR 选项允许在套接字关闭后，可以立即重新绑定相同的端口，</span></span><br><span class="line"><span class="comment">     * 而不必等待一段时间（不必等待 TCP 的 TIME-WAIT 状态的持续时间）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ret_code = setsockopt(httpd_fd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="keyword">sizeof</span>(on));</span><br><span class="line">    ERROR_REPORT_WITH_EXIT(ret_code, <span class="string">&quot;setsockopt failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 将套接字描述符与指定的服务器本地地址相绑定，</span></span><br><span class="line"><span class="comment">     * 若 sockaddr 结构中的端口号为 0，操作系统会自动为套接字描述符分配一个可用的临时端口号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ret_code = bind(httpd_fd, (<span class="keyword">struct</span> sockaddr *)&amp;s_addr, <span class="keyword">sizeof</span>(s_addr));</span><br><span class="line">    ERROR_REPORT_WITH_EXIT(ret_code, <span class="string">&quot;bind&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查 bind 调用是否动态分配了端口 */</span></span><br><span class="line">    <span class="keyword">if</span> (*port == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 获取 httpd_fd 绑定到的本地地址，位于 s_addr 指向的缓冲区中 */</span></span><br><span class="line">        <span class="type">socklen_t</span> s_addr_len = (<span class="type">socklen_t</span>)<span class="keyword">sizeof</span>(s_addr);</span><br><span class="line">        ret_code = getsockname(httpd_fd, (<span class="keyword">struct</span> sockaddr *)&amp;s_addr, &amp;s_addr_len);</span><br><span class="line">        ERROR_REPORT_WITH_EXIT(ret_code, <span class="string">&quot;getsockname&quot;</span>);</span><br><span class="line"></span><br><span class="line">        *port = ntohs(s_addr.sin_port); <span class="comment">// 获取动态分配的端口号，以便在函数外正确读取</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret_code = listen(httpd_fd, MAX_CONNECTS);</span><br><span class="line">    ERROR_REPORT_WITH_EXIT(ret_code, <span class="string">&quot;listen&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> httpd_fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Inform the client that the requested web method has not been</span></span><br><span class="line"><span class="comment"> * implemented.</span></span><br><span class="line"><span class="comment"> * Parameter: the client socket */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unimplemented</span><span class="params">(<span class="type">int</span> c_sock_fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    SEND_BUF_MSG(c_sock_fd, buf, <span class="number">0</span>, <span class="string">&quot;HTTP/1.0 501 Method Not Implemented\r\n&quot;</span>);</span><br><span class="line">    SEND_BUF_MSG(c_sock_fd, buf, <span class="number">0</span>, SERVER_STRING);</span><br><span class="line">    SEND_BUF_MSG(c_sock_fd, buf, <span class="number">0</span>, <span class="string">&quot;Content-Type: text/html\r\n&quot;</span>);</span><br><span class="line">    SEND_BUF_MSG(c_sock_fd, buf, <span class="number">0</span>, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    SEND_BUF_MSG(c_sock_fd, buf, <span class="number">0</span>, <span class="string">&quot;&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Method Not Implemented\r\n&quot;</span>);</span><br><span class="line">    SEND_BUF_MSG(c_sock_fd, buf, <span class="number">0</span>, <span class="string">&quot;&lt;/TITLE&gt;&lt;/HEAD&gt;\r\n&quot;</span>);</span><br><span class="line">    SEND_BUF_MSG(c_sock_fd, buf, <span class="number">0</span>, <span class="string">&quot;&lt;BODY&gt;&lt;P&gt;HTTP request method not supported.\r\n&quot;</span>);</span><br><span class="line">    SEND_BUF_MSG(c_sock_fd, buf, <span class="number">0</span>, <span class="string">&quot;&lt;/BODY&gt;&lt;/HTML&gt;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s_sock_fd, c_sock_fd; <span class="comment">// 服务端与客户端的文件描述符</span></span><br><span class="line">    u_short port = <span class="number">4000</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> client_addr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    <span class="type">pthread_t</span> newthread;</span><br><span class="line">    <span class="type">int</span> ret_code;</span><br><span class="line"></span><br><span class="line">    s_sock_fd = startup(&amp;port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;httpd running on port %d\n&quot;</span>, port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c_sock_fd = accept(s_sock_fd, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr, &amp;client_addr_len);</span><br><span class="line">        ERROR_REPORT_WITH_EXIT(c_sock_fd, <span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;httpd accepts a client connect, fd=%d\n&quot;</span>, c_sock_fd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// accept_request((void *)(intptr_t)c_sock_fd);</span></span><br><span class="line">        ret_code = pthread_create(&amp;newthread, <span class="literal">NULL</span>, (<span class="type">void</span> *)accept_request, (<span class="type">void</span> *)(<span class="type">intptr_t</span>)c_sock_fd);</span><br><span class="line">        <span class="keyword">if</span> (ret_code != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(s_sock_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://hanfeng.ink/post/tinyhttpd">https://hanfeng.ink/post/tinyhttpd</a></li>
<li><a href="https://jacktang816.github.io/post/tinyhttpdread">https://jacktang816.github.io/post/tinyhttpdread</a></li>
<li><a href="https://blog.csdn.net/chen1415886044/article/details/103748926">https://blog.csdn.net/chen1415886044/article/details/103748926</a></li>
<li><a href="https://blog.csdn.net/weixin_42621338/article/details/84574977">https://blog.csdn.net/weixin_42621338/article/details/84574977</a></li>
<li>本文对应的源码：<a href="https://github.com/Pursue26/Tinyhttpd">https://github.com/Pursue26/Tinyhttpd</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>项目</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>项目之确定性网络 CSQF</title>
    <url>/posts/231202180319.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，这个密码看着不太对，请再试试。" data-whm="抱歉，这个文章不能被校验，不过您还是能看看解密后的内容。">
  <script id="hbeData" type="hbeData" data-hmacdigest="38149f3886ac7a6d5937e366c154fdbb324919d857f4f6e7924634156e8b358c">296e0e11e5707115aade5aa86d82978cc8e0b187f577349bdaaf317eeb18ec71ab79204b18f543c45345a919b6c6480fc5b6b0b1d61b45697f17894ab703ed86effb66880f403bf18e2ee3355841c7133aed0638021c4781c33b284aee4a62103a40743c50ce7002f19ca3c1246e26bdc8495be3061037492b4a58483660627c45538bdf0193b73442be64f47dd8fbbd7d8544b36c52aa1033dc6db92fdbb2e171dc0851113db5c30a043a443e5a8e304e3597996bf59f5691be1fa6c3acd134d65b59d694d4a6f418a06533a1fb3f3cc5eda7648387e77391b930701ada7ccaae90959fea7a9748a59376297ee770ba0e7ac5c4dc98fadec8d9f3c377459d4f59554b2f7a2a49f2b1acdb1a55b260283fe1f00435d0461dd060176da754f805cccc7ff08d299baace8293cdce25ce7030d7479704e209ea6df6e8be0d0fbaa67735f2516f57531edf410f6c8b1106e7fc1b2a718d617a0b19944df408fbcefc83042b9d40ef05e1a21c8422164a44abbf089381b3c735c15eadd2887a0fd83513ae05ad80ac2c2c61d2f91dcfd550a0973f920395a3109c81cffd46834f929cd318abb3553db9de64b0c3a29891d9404842d66ee5e69217231e7ff7a44b5672a580a6ebe3cb13f75f5b372bc5bb2a286a46c6c3e18eea3a54cfde87c16b76ce007d6247251d0802e932e3e0316023ad7b3e91b99300aca5fca5826c35b150cc9dde9b6428fbabb38cfe2353fde7960dd0afc1d5072f36b84dc87fc96488ed94e222454576c48c580d2c6bd6c9d8da57020161f1e2e26dd4a595603fd60b78dd98b9c53dd00bc86488a20ecab0b76c70a0a337bf8eefdd6a74b1e5ed48aa73873ae3d25f87a2fa6a5a55808a855cda73426bfbf432580b4596a221edb67bf7a2b5cc198927de492dc5194f5efe8c68efa9a4699298412e5db91048a6db7b42acef51fe1013548ee87034636fc7db7c4b9c736016a7b1ca2bfaf37a9a98f591955468df65ddeef906f97df35f7fa21dbd9bc073417adb290756dbabdda2ef75249ed869e3323ddb394adf2c3a1dc5f92a0f012e71cfba6106a3cff032ae81d9d23a7fb33085097abe5fb4c5e0c28550291aab26cd726681ab0eb99699bf1508efdd3d83ff92cf17ba4351af4d793d7755ab937a71e89da1f24561f5499c4f1eddb7ed59a0ef1747871285451f138187706119450cf4f2b88423b51d14b6d0eb6ebdd02a8109710df98d10cdf9b3d46a919a7618baaae250c6152504637548920d413d5cd860df8630aa0b908d18f7dd2f365d2e5a150da92735b46143b29a6cacda987da4689ec0aca308c9fce87f7134010f3e3d42248ebcf551b1f155a94545f16cbde983aa52fb547f305d3c875b084bfedb8538f3fa8f3461d1bd7ed217c133025d6cd0ec19c504778eb173ff04c5341b75835cc3995ccf85b74a4d5e770357b169129c890dfb7ad391d92dd1a11571430d3cce57582abb9551193152eb50a949a0d1140de148aab44beef0b8539991d55a5b4bd55d7219d2d388112600ce1f73befce7dab356f915c500bd59b612875cc930b916aa212151f16a5397ef4e1aa72f5c9d9c303720a5a38c57a39bfcd5a7e9da805068cd78fb0534d4b9d614394d8f240908ac34423cfb78bafeb21d1addb401219570a2061a7f1a6b3d0fa86b2f7ac77721db3b9ba093892902172811c938c5867ef253281aeff2237f4a856b05f79779ad58351696d1b9d8ac17fc75f60aff85fb0ccd54e83cd1077f65c445dcc34f8962739982577b2cfb02aa1614951b62d675d6a2893616902b87c3f0f0fb9e302abf067a774be3e46ee210cca82a8b13895e84b93791fad16191b676ab04e10a1736ebfde211bd6e20b3321982d4ac98f048329d927c6f608490d29eb4fa529b7b8349a8d3f6f84ade9814e37f56a642d1ad1f59f4fdb3b3d0f96f62005d181ae047ed63ccff495100f8477485aefb26781b090e6b34043553fd7e548712f46d0615158717549905b8389d82391a9a3728d24c4f458c2bda657347382e4403874a6307afd0eb21e82d9b37440648e59bfbeab3806dc5891cd4d9ca2c35d7c9045c91e1b831d5c70ed0a45069d0dbdcba674256e71f8a7122c2cc1b764fed458b70e8d4168f699de26f0cbcc266e1ece9a991c7e53caa3f365742be1063228a1062cef38694943f5cc64d268b3501d8db275a29f2ca348c4957f63a68bcdb26fa60e418c0e4bb3f1a72b3d55d101a00800941428122f2629be7934c353a2d5e3cfcfcec3cde28cc5bf703e62b5772b3d1d28ce2119624be62a432e9a19c0857f38e2b1b01e759feb3fc1549c16be15b9a2def440b7003457e63713f3ccdd0fe5f694923a4816c9da9a08adca2ebd752e29a43ebc9d207f431ae7a4a635c1be617347641c0ecc9b7b0f96535f45126c8d1fc681e254bc34d795e223d0786bbdb74d0c01240a0ad62b6a8b56d7fd8709622861d497fd32e7582629f909a25c95d1f195d4e8ebd5ea2101a9109baf5e09654782cd2f98c66d5e4bb3e10733e0ce15156697714dad57a2b274a2f6c459584566aa705ee9e60d32c319cd567471ced97279754df61fc3a936c51e9cf0b70c21b5e60a1fc555691663b7b2f52f10e97472bb27f65a5fc980f2e9e0e542ba611ae3c3c14ddf681efc15515904ba519272931486aff821bedb2ca1d034ab4cbc6324dc38369b819c086c34734401f1204a692d9dc5598810dfa5330698ec5315b34def60572ad109ba2aed16272c23263612119f94664253914955c937d9b77f5645393ad46d924e52ad1c08ceacb069a33072add25dd56df123dd4f4be39930938d45fbba6445c468c2f48ae5fc71b3535116e54df5b8c0eca5de64cb00b48b3432a812a54ce2b886894767656743ca3a766bfa7d021ff5255f3dfb8dfb84efffb7c0f58f0b18c4c0bd66c7b090e68b76a19e939fed6920c533612a6654d122a8c09d3c023ca3afb7904ddf92906be4ec711bac1eb9ba76a31d8a24b1c091827691942c0c62ae1d76c1a672ec38e8dbfec8494f10fe8e0f6c4e681e382230fa23e7fbbac4c554c3bee561b67753a2a02fca8eade48ad10523346c46d19963d3e5f41ba6dee4c833c4c5891e5bb7ae5b0dab3f44b3dce599ddef0ed2966f97e7c53931935fd7046f005d9857b2e30d0cc112fbc456e24a863d5ee39fa1ab5a3ae62f4268ca18d1422548efef1c4863e404e59def6ff8683a342ef4f611f576ebf57141c94fc6b01aac46deac386ce857842ec0628a9ecd24710570c5e723d5acf4bc6e0742c7761d91a2207b878d5b5a97d1c86b88787b035153325da977aef167eccf2633e07943e05f81126161b2b38f0260d43d5a0bee187dc65a3411078bf630dfcdf33228bd329bb024cc8a35dcb9d5c091911589870e1090bf8072dcfcf268b78f66cc82ad6393188e1c6ed6b4c75198f973026fef12b9f9dc892a774c207bfbd03292b2d0304d9bcb0cc6f7b3ab41959c5da0ceb31e1ac73e78d6ccf426de03777fc048508caef0eae3954f5b7b3721ed75820111431ec502200e8cc41ec1aa859222b3615d9b808d58d425f5bc37c68ffda166189b1610d6dfa0eaee5d7f130deec18ae362e10c027cbabfc3ffcc10676f24089cd6928b6cdd28b154227810f39b630d66dd38c405cc6fe70d055c04e09bda2cde73aff3e05da14ace844727ffa776c3b0eabf04c5c58aff5021bf3a8b6dc1281570a5ae6cfca1b9f5e892cfba2b750d94f7d76409368481adbaebded0aeea3871fb46f8b8b9a9f9111a09fff0d390e12cb1c524ce5591b7198c0a3a73283c711f0ec2e8f4994ae48bcfd2266913d20542f0109ff4a0a7fea4e1f823554a971a29214d101e79bc425df3704fc6d177a91edb1618c4a83578d0a6dd8123ea8fed475e1c1cf709a041839a36d677ab266fc0fa52a161748f9b3c8ca8d495ff2b0f1855737583b0ba5dadf8eb78d5819eb631ca7e7101293cd9b8b007ef0bbe59bfdbfd547d308c2ede7784dc84648fd4d5d3531e251bf5385ffc460bb89660592869fc9a142af8158e2a103e740ce6aea40cdfa600e2462b22a50c7b9c52b8638448d37c76c4e0980d288937f4d6c56ac8ed07a105af5fdc48f3db35858a95d24744dd28c595cda6794fed6723007b0a0e7a08e13f6cb9fa4f5531f7e6a48ee14be6a19216e0ca393600c8d5e10b4211fb3ad0b5c66d95207793de4bf74c88697a1c6fc6f0c739982e05d3c43b8416d3d5c3827aa0b1456ca860b21d54f237fafaf3234ff00dd1f61d819120af9854330db0234dc23d65ba5f7bea291aa5b42eb0951f18bba6436e029f7ae7f31a3f8611b9cd21adea13c4ed1747243a37c30247da1090ebfce5ccce1771843da503b515b83b5ec6afe3615b6b5bacaaf489309de1445ea787beab95dacce02621f057dbda691d9b55f8159d66b012362022e4fcaef75190a4f8acce3f4f2de3a1652b85c63fdcdc64ee332348f5e3f7662eaba3650c7866bd3b3d661f0b65b64f3e2a9cf38237b99bbb53d1600eae4f5bd0025783f66325c0ad3e975f90418e88c1c71b0c10747f540551fd7a48188fb27ddb2e3651c045846e73d3decd84acb01d023d5d94cdd0f4a92ac70320f789338a775eb378d8ea2bd8eaa99f10529c36b317894d0110c3b00d7d141b205c48e31281b09b11a2870698f6ef30b902af2404cb48f0314befe023ed7906928a558fd8f6aa6d7b09605c613cc1c297fc4d2272eb8fc98e3ab9f18668ac28c7ebb615c33738be212fba1fbb6fbc660a1b31e203caa7036d53fe499a59796d062cf96007b72fd425636e98ef99a8294e3d48690b9c4ea5ecbed8f898db023d9c42230073df2c84162120246e5b52620df00ed599ee2c2a095a94950065c8a39744e10cced1d2dd01e07acb66ad12a825e3f0b902c59722cb1bce6cdb6052086949d84bbd86f6d36525828bf39d1f78014709c9a2c7b5d3cd9bb98f6d974531c5522a4c6e0e1655d67729ef2b2a66fbe05edeba4e3710c77ebf548d08f458cc8ee3f68d2cd1385573fbb0be77eb58a5dcc4ace69272155333e3f91f7f812ad07a2eccab64fff7fa75c87ad284821b07cafc53c630f70ed9eb54b80020078df9407af7a497f6b62854c9d01052268211e9e4f3ca141fec6ed8d230661427d6614a8b30c522b9b80c2d36294fdde7f6d374aefc34f9002546d4e354e47c0bd6e0de1071da57da0f68a58ea5a332c759cfa15951b0e2bf5374d11e3d2b54cc7181ad6a052cec3a6dd308ac44e84ddfb7e8dabd4892b8ac4a60e0992d046a087bf5d743698e4eef3f7f10d56c82298857dcce9a7dc32fd3d00149a5d8d5edcd61b4b4057a4fec4cc3acf741350ef7bc229676346ea918de936d36acbf29705777f39d58fa9c2459ce8738d21d665df5d4b91d88439bd65b1ea17e6f7341a82aa485bcb8890b48ab850b6b77d960a2eb3cd5ac97626ce3aa90d476cf6cac31f20e2befc8ac05bca2190e5cc0e55ef359285201fa04ab97bc61d2c6e241eece619aba299576256d9e61f2717f12a6cfcd629314af6c0bb1ace24ec0a16b225c3ba64c4aec1b6290d17e70417c88f7c66183be0f87eeecc1089f0696a2a437953c0788c865a93fc786ca56396462d2732f86046dc3cca30ae79b7caa41e39651e9c15fea617626d513e6bc9aa7a6bb2282928489e32c70528d9bb472cc58288f06a50ec719cbb5d9548a7557e53cbe92f813d1566b6a04941ca4027b7e04e03750812e12c871380c329efc65c53f9eaad0b3488554393a83cc7429b8a0b4ab1d73dbeeff426cbb1412c69b43ee337bd8ced77099b1348a69e732d2e1ad7ad4349870628ba6751b8716b1919aefb6ca06314c84ba7b44beee535659a623c914434b07b3fac378686e8bf6a8cf1352ac06cd2f4bf0cc20629006dcbdb92874293b7a7cf83212b5b6674297399ca7be92e1d124f8c7c7ef2fbf58557537414f98bff077c7912dd5e303781852c5b2d831705836d40ff07d406776d6bf5ef588afd09c5510e43bea5e7edb4968d01169aaebf5231a82b2c27605620309a5c823b4490159c8db3adcb31c64d7ebf230e2203bab049e012d5f7959e861126c64e67d5af30aad4742d0776e470e51420e7cdd15c113d64606f42e39cfdf9b553b6b6bdc59be8082a34ad4c075840fb84bdb86b601ddaf22c5cca7c633ddbba16f57054c9b8abad738f3e18a4a9b1fc020387fc34098144bf482dcfd870d996ba2366f4a793b6cbfc8f15991c06a6555bec52edb364f436d4654dd49da639a28fbf5a693005dce8c880eb0bc9b260c930f43c7df01464179cb9d55641af71c9a07f9357dcad60c4ce084ec82b019dcb1ab8dcf23e191a29a2993557b69dd8c54ae42a22768c046681a28fe0c0cc4cc9624645e58d4819ccbfbccff6ddfb418a95cccf6065b9f7e9212c002fb71bddb2076bf09b45dffa48d2177a50fdbf90a1a9bd4e2f77d923e6e0fbf5e90c62efbd16152a6c69d1df249b759ad26d612e6111d25174171726bc706e343132a2d6fe2e3080f9a312ad00f77ea89a117b7058ffb7a4f4ac3f16399253cb02f59ceefcd35fdab2e6f525bbdf5bbb2e3d1aadddd52db9f2a6f3afdafda80d254b5ef10e196efaa82907c443d32037f19b6505cb8adb4ef6da15811930ff0e5587d104f5ea91f5dabdadffe98a6a4b60c31c1f85e4260ed90cb4f13e0122cfb41388ec8aa4ab374fd678f3c1c62838d1092f4c857732ac64d3702e9150b337433ecd9bfc3d4dc5e451fee409cdc37a5e1a1603dd7e6ddb4807c9b890e72d4d5cce88bddb2cd24e3b1d5a6cc545cd9a0a3e3573d1f0ae495143834cc77aff94e190c8a94ab273ccc5eac94f42900018ddf0ce8f4b77301e439426b0ad35744e3e39c8ede06a1898c5c3c81c89761d9b9ceed89ef676d4310898165d516d86bec4781e896d8f5fe629891b5325fadd1a444305414f04c94511317fbbe7f9cac6db57dcb2e11c056665330967f7d03d0b04bf75c0ae38dd27f531478e52050f03086ab10692f82c3f030c5f7730b07ab1cb48eb32e12bdd046f8f8d4e1972e7a49f374cbcd2c8eae41120a6a870febb8fff775cbee1968c3aa18f52b02d9c29e1ec2ab0883cb6b835627072c04f9e6e99056cb0274340318d506cb3f26897dc7e3f19ecf5f2d7d6216f682c4b8b4e5fb7470b35ce3717339b7cd3a1b917449685362f322416377cd8c637a8551abaaa040b37598f45d2f34d3f9f1b554d037dc6a20593e80f9e94cc51fe05f48da84b085bfd791d62cb67d86a26552c0e1c73189e41ee74775ea0a26f3351f62b3e69400f3006d0fefd7af45f36288776e475398fc07df1a1b670af4d1b7b4623a6aa5931d8a460c0e0fe97adabaef639b438393f8c96cae9beca51a2a247749a779ed748092817081ed515cfa79a9b79ffb81a75c4b290687a7add6eecba8728a3ad6b1f97b50b0b123d2284e44ed1f54f657a40b39377de01baecc021633d3c2d98ce18345c782b00586f314d4e0fd4dbda96106d9de95cf03ae68e04215b8369a1675eaab86b41d0c6d4c4d9351493f64eb2fdbcc16be275f63866681d857243211d01ae01896517fa8eabc4f088ec046ce0664a74f08c379c6f2a9708e9148aaaaf406e97e727d32a882f48fd2f55ab7c713241e1039d00a7ff3ed472fc48cd0ccb6e838a7fd9bec23ad32187f805c822fef67f1bb22240e97b27a57cd8eb2614dc57a34fdf8466974586952d7ffdabbb5c4ca2a36fe24778adbf77aa64930bdd5d8fcc042ef1fb098a559d1946bbcc49187bd916f8c4297e3d5070aa4ac4582fc419c860c4c2d0d67a1a94def2f3842584f665f718a2918a0f88edd1f0e93ff029c15a73c0f86135b1351033cc9dcf73d62c00a0ee0bb3ab23e3e681ffcc2faf61fc6aee4315868dcbcf4642a8d5a7c7348af9094e00136cdba46d0cb31e7dd2cb9997a3c9cbf2732e387d833493b4aa4e27ea9539943829b50120c8d776348af1b3255e4e53699009ba3acf1d5463c3c82150e29d433804cf91154a288d5e6ff69174df15a3cf27b4dff46912dbf26502214a8a935aa71af18b9b54a667c7e2f1c2f0b06648520c84bc96d3cd3310aa34983eed9fedca965e72082818aaaece87cb905ac2236838812689705045fc18f424117e3efaee347f611070123397b78c701f31ebbf50d8abae3a44bf0ce5eefc4b57ba3172341971c35218a48d52aae9488a21a6115146e7e3ac7a1c8ae101934955a19906707b7aee1d8ba7ba60db94e8a9bd9d436b52e59409e07aa001a4d50e42b73f545d4f4c784f8fcd4ebea242e018186d9aa5f454faf6558f0a8ae139b8cdaed5d7ee846e4c138001b6fd128610ec1ca154c1e47479790aa0c847e85aa8245b76c26d29a04c8c030e072b75e7a36dccb3926088981642d545a37b2ed693e795a3d6b6245c556976e74bfa0476f1136e837c0e0d6be9330b2063418744e1e825fdde2a1bbe56df52aa537898fac19f4461b0d41efd9adf584c9ee5bea1858b0a8bc764b25ea94865e2d56eeaac44dda62aff14f08e1974b1531afb502c7250fdb46e3bc32d12c5398ef09d6514ba4f9fef77cd049c81c22f9cd254a78c2b549e1e7b4de041864cdd213974e270f6e23d60a07ce69cce830b90145740712e7b4d3ced0a659ce74a149f4b13eafc22e0ef64e0d707229af61820c14f1452376daf9a7bf159272b241eec88f32d9a28b50b48fc87d933206672aa959aaa59e42fddf706eaa390a86f92e6abde025c348be64f8279e887aa783fe10550d58346d357a3c5852442e5e87cc157cc499b7cdd54bd5f40ccdff234400cd0bdef73b78518726330e70cd873f980de2083a41b26ea3d05574bd677dca5ccd6aa699efffd81a93031b866f0db2fac9e78d8ecc9ace55d6c648c2feb9d7a90b9e5a9a2516c2256e3d4515c41e8b7656fcff059d2c9fb6925cf5e0c7765c2a7f4d9da454321fa60971495b9469dd4e55c61606788eabd8a034a3fa2ab4b8668e89b2a00bd50e6cbbee8e10caa9b321f39646848a097bee700ce86633c19c13af254b70084e49e3903eef1bff6659e80a7e10057dda019851b6467c82e4aa27f8333a2e314a85055c2a429bd49118da591c6b4e3428a79ccb6ee411407d6ab6ed24c4e2a001b5c1511d3d5e5c08035184af2486bb3a83be5317d13d59b0ac5f5f3de0eb13bcd15cc16dbb42ea8875c49f4e8999c10f01f2e449c5cfb35214b2d33d8a88429b7c27babe3315e6b4dfe89a8fa76d37d4a0ff9ba8d80128403c00e21bd589c3902b07c5af0e93848fdeeefcaf7f69406cc3724a9df7f9066449cab33e27105582e44ca6f5b8699a820a4cf7267f7e5dda0e9058e4deec6ebbec7880973c67f11b1d0aaa215600e0dd57375ef29e67c7dbde137ed43793b8ec69b3e4526ed840257ea20b321abe163b89a09495e960cbb4d0ee626e593469bc163eee7bf83845c7c9093c34bbe688894fa2cc1225db85dfb9c605cfd701a327a4fbd05afe9210abdd90b3ab302b44e6157db6a6fe23c960860c6b6aff8e83be83771cb0b17ab7bd2bb2f4d6640c6bd9a2d623d0ce8526d18e2d0567b5e79edf100a0d1caddb4697ee5bc2ac65f1c0d8583e6f4cd1ec284ba4894c8901ed5404eea3a9e2039fafc626f03ce97d095e7be2f4e4276866e3c62fc33247c432d0399d026b5f9304131e098afffda5cb60b248080ea0a9c678b52d970bb8eac32ff1e80d2cc757edb399ad8a314fb980c89d7ed8d9ffa17890886029cd96879ea4b0d1eed7e951f58e53fd7413fcba5375f5cd2e9d0683d685363c70bcfb504722064a852e9b8dc814ed264727e2a40da2523cef2d66b5a39eff00553f1d2c88deaf0b18090b2ca26fa3c9f4f0245ac51c05f3914dafe668281b9492c63e88ad2d07d2329d8c9a5cf23ffb74302e0dab551065ff3d72ca75e86d4e361187dca9171dfef38ff1b644a084d8d45d045fa5609fe736d4c14407044dcbb275446c330012db3060138b87ae38f291fc90ac8d0d857f47a6114f19a2a980c3fae3959cf774c7faef1eb29bb13484ddbb95eed2a8506a2b1c783ba30cb306465f0e378f63277643e1fd63fbb601578d966953c9da7c4297c7cf51d06054a7238203e42c6875cc7c36cbd777adc4c63658f89bc73eda15692e0227b043f2219ffdaa889c4191120cb77d2733ec3715c70e908c858c339b63ce1ff487fc5e54b1aeccfe64354eae2394c52bf7d2cc56494afdd4906a49c7db5486386deebefa1d15644adc4f54f22b24406e39c4d3cf9bbe109e295afbf7a18fed16890bc336c463bd9c1ba1f660760edb50b2382dd6e518d487c36ac51251ef4b265366df0ed35efe83493570d46869a9aaa90a0cfcec47828407d2e4623e1a25f900ddcd67505dba0360a0b16204a0ff5ad1f654b7453d5ef7bce3e84e1e5cebd0f9cba6718e5316b90dc5e165935f2f99804d548fdf9865eafd431c17ad3be04eab3b4da88dd876666efac2865b9d07df81c81b3dc1bf1fa4f22f17943a75b4fa1a3eed127fccb25012e42cf692f77745ce55f17350e9c70e296661c20c3a50c6823a7ba052618433263ee644eea5aeeebd4cb8056286e5fb30025da8efef4e015faf129bec14e0ed75be1f3eae64fe39c8a816afa3cadb89f6e7fe3e4623827ab2ed25ba8c207cbeb83d993fe8ee1d1eeee8a170bf4b5a4781c599035f167cd0d1fb4b66ec9a7d86faac3dc3271c5e7c16bedd2614ab8c7e4a97a8da96966dc3b31d9be80aded640d961e4ba21e25d15f2957d477ed4071f9dc960a1505fb49f170171152ac35c477c960a42f7d45667cab2926ea9344fdda539b22d7dd59fe5246311480bf0df89d3754ed1514d30e17eb024ffebf403ac8c5b242a0202aaff95b51ed51773678aeb8c0f500dc19e1e8d99bd9c152dabf7d53d62eac3d01bc82e93554786c8f41f405a72c4a9268d2958ad58e57244c34b2118a50aafa20bdcabd56c5162a0cf349d2611e68cd58a952220f5cf295871c377fbd10dbfb468bc18c39ea0989e396cf7559f3e9b9c56e1829d0cd93d6264383f5de9186871c60636da855018d40c84a8be75839505ef960e363609b5883b54e1a49dc7e20bbd96ced4de6d9e35f0cc85e4c3cd3f3c85a5f34f931e2ecef314aa99b2fac41b5568fdb87f270d236f15edbebb8839e4ac8b1305263f936e823e20d35a282fbaaafe3688cfc53830f95cb17566fe9360b6da408e3d4628a050ac143fbdac0acb8c918c77234070346a55b8878eea2b5988258736dbf34cdb65527c33139081a0bd14116c0fb024463ad82b234675452482878b8ea690c525454c9062a00bca19455fddcec52ece95ca4adb0a3cb872a16964d894966664182061895e758f2179e034c0561e4b82a2c3c765c20d5510ddefdad47e5cde2f293316201ff0f0497931ac1beacdd313221f381acb1aa9bc865cec058c14301dce16189f148754d0f1fe64aac61aaee88d697b4e76ed24d1ad16a5f1ff0d728554a5d32b130e306da622bfb00a34abad1f8b830cc93eb4dda8b858c3e3808fcc067f6a9f01a20b4843c083ce7f7d4d61308bb11f398d876ce17de79fcdc9e56b0ff2a3f53e28d34a73d6bcfac482c782cf723179c19eca6dd8d13bda8946b4e4576e109e528ab931e4e3b1f67eccffc017141fc280d2f1807c1ad3e37783c65dd41db38bfb1c81d08253b55a1c480a2c2aae53a2e1c8d77a8fed65a42affe3f9d01f06a918a7390e3fd3b5b55fdc8c64803eea9bc734ada24a0b647957b042232b2ad9ab755a098e2aa690323a14989ed91783dbe562cb5cbfe5e5436f85957d977a13658e730bb9f6c8a8255c5355ab3b15d8eca14f3fa0165ea7c4debe8ebd091e13a6baea2b3f76a8853d24ff663bfad833e4526f37b34fde5e350b0b9f9a48e5f807e5b8ed921b1f6bd9a55cfb209525a0ba99a928aa6c1026876561cd5d80e785a758ba2a135d90ac5cac8079c3dc4d70b8d665258cddc175fee2bc1b4852ae0b23a32404a8399cda8fbde7cef058ac172068e17cfcfc62e628f6d9f9805539523c4c399160b8d7549cf5d4a0b0786c45767914f69da914fc47ab08ce699d5e78a7e6d264014ad2193ecebbacab5dc4e455b76891d58666df953012753f1e407e5d5a9f228b27052f666800f53c0519f43b704d9d3c8dd65f459e80b3590f06174ad371bc74f3f484781b0c1071154e0d8ce86b535940fee12ad186854f295cc956df40ddc11dc28503986c485a7d5c10df3d75f3fd2bfe11f04abb97918accf46465f58d0d0e506128a0e4c8b0ab403f11480874ac51edbdbd46d8bf8840b0d5ac4b00941e0b4de7d900af4be0ad5f63773086bae40295c71e875791402356c24ce17034296a0dced8852a9977bd0d6f1a9e80d53ec138c37579b19f72882270d75d71b8779b84b0131971b24433cd0a17aae4a27bf32726e82c31655afccb07455c362077235339cd42d50fec3786600944444d923b75afe6a5560079873b2e847d7554bb0a3cf923e06b6cb7dd101796db6c0f8f397670f6ed489a8491e654977f3b093ad5b4e237aa886d0e77dc479b92bc87a192e2a8af5388249b6e89700dc1e7fc3e0fb4ad7ac7f638d4f0ea85f33034bf555ff3b3b189a5fa696353ed321e9adbb56b595a2feda74d4c367339dde77513930174355052e0482605e91eb56992b0697a36ea6bed4a6cf2856df1f55667d53e5c2dddaa9754d7846cd49d1bed89e0153e0aa22afee5c6504e11d758f2db71eb654eb567796e8dad9b720437ef95252a93de05e014e9333fb0a50495ecb5cb90614690faac46d9fbd9f1bc6c9b3441be0839c1efab2f6893b7b7402d79942bc0a4f9b1aea86a9a4fe6825e280d4bd2113bb431e1f48e8415ce2646f880c0406985fd4356787df9d3f03261c64540fef0287b4cf0b0ab5655b36438b1d7090b74595236fa06a942064bf72b8223f8862a214e1809b4cf2579386758e9a9afc3065d644843af3a2ac74e19970accc721ff0c8e9485ca61c025e6940ad3f3bd93a0027a65fdd7b55e822945e34cf2744c4b9d76cb430f90ce131299156c6208c6540afd506174416a9fcb1b633b692a6f55bfb9b75f466729aa331086a706b995830ed0f334b8f9ea2ac18e47c07ee5650b82e2855be832dfc1e7e4e95951e8fd8c2bff9162af3f4d8bdc938a4d952d0dccec954cf0e563e7b09140d0df2d84efef112ef4f946aa17a8cfa562b803ce596241dfc07402dab197a0140288b413b54505f5e070857d81ddf8eba1c4acf37e56a0041311c0c305b7353ead2aec0099bac2e1be33754a2e6dacbeb29e23760fb3e7db3d6c6a35989a18862006ab21db7c008fafe40207f4be6ffd481e524fe72cd5417f57ba9a33eef7d11773dbd48868aba3b9bdd4f76bc4773902a10fe6ada73b282a8a8c3842f953375d0768b98e6dce91b1d73b8c4df65398c4f05e9321e5b039bd8717d15b3440b2cc70e77358c3eb75834a861171a5a87bb5873901666c9d9398c317a55185d43fe1be0dfe425821be314a37ed33324803aae7a9552ac077ba225e2ea4197dab6b09eba127cfd489d118bf2bf72bcff288c46ebdf3b06e753e08e00a727bad1e3a11f088fd8d0b0ba5482d6d21350fd98b6a5f501b3b85ed66711e0dea39675933955293241c8e1e260b685e3c624969b7dd6a93153c8b3a17d256e87e788389266ae7f373bd778b3b960f7698ae29adf26ed61500adbac307eac360149baafd13c302baea43ddb6cc2ef5a8e40c58120cb60afd1120067bf70ee97f4cad06443a377bb6f51b954c4d918cfd9937067f5b0e3c6614b4d7eb96b71999baffc76deabad7017c6ecfcbefd19254ccb3973c2db98a4f1c169aff73d0bfa466401e3bd5a63085433efc2d47a45a75f73abe491ef906a2060b44146ea4bea253ff5a06e01dc7fbb4e0d089df5c3715e93971a63f0108cc871a6d639793c4c32fe03efe329fa53b50cc03b3e53c4923b50ed8d615fe2d911c18d85bd8ae568e0eb03bb05b0d1e1e24f7e2de20e62ce9254f8dab6de680be585ebbccb2ed225cd122c27a264bb2c74137ed8663b546afbaeadcbff595d2889d32e8f8e948cc2933a13298bbf7f5f0bab40f780724e4952e694ed78256d5a105be2190b8154f29bfaba3449ab38464e2c5895b01472228f6b03893d3e91b11a130f642649338cf0a6e95720e325b8051e3b228ea6cdf352f88f6797c7c4b219d9b5c2d8b6a87d51b69eb7706a936a0b3f1a49fb0d2dc8b0fac0e4bd2f0f165fd166cc4d3a88accb4eab4846b2ff581d300d2725c8d1b144db7b244c9102a0f90fe4b20eb6519467ee1a5ce663860173dc572eaa218bffd58cdfeaf80a81794fda28ed5cc5703769b8984b7509b5c7cb3fe6d6ab5e90e7acba727adab9b3a7ae7e881822b302338904c4975af642c788471fd58fae9ccc5f29a2e883f416dccc14a26d90f07b4a76e98ed14306d3e08ab55819b4848e5875419298d46d1321f0e2ed6f502a269b061a1da039fdac65994aed6f3c0e4b76b80dc9b205e95a06f96fa3b30e1149f685d9885fdad603a3307aca6955deea29e0f7ab47d38f9466a05f4ddf6c10f737f784ba49200a5bf82c8aa4b23bfda63b426889ddeb4d5973dc87add8a98851afbef2ec5d94133f19ea7802c141ae223a8f68dba1bf1098a028fa54e28e36058edc0a7e4603b47e7296805697a49be7a6d19b8966f605c6dfe21b1c4e851e8ca8c6061b2861b776bd815b8c740bbf37bc390abf260472a404063153f3f3ddae2aef9c9ce65a489c5879fac5660ba01c7c20e229ced53aff3e77c48df8d80a1867dd832041444ff6055a93ae119fa255a01c107ca8e54fdd45285560072b4727de53aaa809494d4f22ec5066bc4fa16831d6431fa2ee0b74207ee169778a1c8d15759fbd974f7890e66689b66e61bddf26e75792c961e6634ed5c6484c44eee717d7d34f2033fd251f914d4107dfc5a8a82d25281b93a05789333ef1b3078592a9d9117b2462252e24b68d9957c460d861689d68f40a65771ad5e47d509d107393001f613804295f2f6aef2966f66d584785122ce72bbf2ba3857ffa8e29142baa316c7bec7f0e3e667f099cb421de3dca41ce0a3528bffac3ad1699be117eef988f11b991d19bacb40d810459ddc111ac1557ff523519a2aaacd1496ec38018c6576a2fb988a5ab5278a8f340a099efde2bb5ad30e3b4faab1579bfa91e4c653999036d5f12fc514460ecea75aa82729af866cf5a2a6661473292451341dc65ab61329f582dff85f213791d13277578559164b7638be4ec82d591710b97181ae0d4ed303bf9344c700537c0095eaa0d2293ed7f659cf6c305d49d09b9f627b1cf40274d7550555f4972c44ec1cab2605f3eed87284d15b9fa7b4ee572e67d61a8848ba0804f6b6f81c6853f7bb64ef3e6cd05f0e9db97533d30727934d34d0bfd54be825e440596b0cadc8e3d07141368c795a7d10ea656e8c33fe22df91ba01d347f232721090109f2b73735d80348f216b364a10f5165f2d8cf023f700230be52f9ef23d8746da1049cf1e4cadcbd5581a1ed9c1283101482e5a926ef79396af644395ddae3fffe8828be90153ba533d8c0a144fa2fd204e49d3e21a9b59afb116031175c62366859ff161337b169a279182df8efb125acdd1cffee44f6f83b093d93d4b8740df4782e43a178eb35e63e6a12e47a76eb96c93653acc6f5f70cb5b9c9331aa7c3c7c827cc4c3c6673953c7b4df7ed6f78022bc0981a2dc97ae0d9a681c9936eb21cbbfe912df8ad73268cb10e7537f7b74d77d198d8c004e95370b7b368e768a5f890c18b697cc2fd54db4dff1abb85a1cb3802d489c5f46677786f0ce6e7204bb06df1b7a936fe6464487dc2e0ce0f3f3a895dcccce7fa26d7aa89fe52b78e26dce5c4e0fd28b4763a43c9bc2b91a055960d2929f8b775ae4f66daba951f4347d398ea15d984b25bcc2f96958a7f5aa5741a2447ecf9369f9923199ee58cfd09268fc247a8d4e79d1acdc5a6035565171cb8487ef8e20aa74077788872ddc6de1eee45ca5ec2b22b0e5fe133cfbf68ec07e6ed4f88f810154b25468c4391ea1e79b0b5e87548ec25cdecbe416609f9f9f8d16049e6da4ef531d880c42bdafbf017a5a3ecf252b7499b2376f4f25e7ba995f46d35e8361e26f55f2a64e81df480a982193e766a315ead72877352037faff3958f359f3b68f310c444d2e4ea87f4e5074e428f92ca07bf1846b5d4741f1ed3a00a34e3442316b43191c6b2ce5a7aed9dccd93388d33c799507835ab87ebc389fe59d0fda34941be616577942dcf153c80a1a1058e0fe4d49dc91ca31797a02eb57fbca7ae9b6d0d4e5f3aa438be61f12eb56bd69672ebef8ecfee6986a96cd3088c40bbc728eaa9f40633843fdba18b6f0418696677e0acf5b4c0c4148dd848614450ba7ce943e1f479d32768c2b9e0988f8332596a650bea0d85f67a3e724d24e1c72f78015fe706a3a80e56275a2ecb9b50e4fdafd70a835819e9f63185cd9a8c2bd234f4c530b6559ddf9031de92890f4ba6d37cf27da75e0399a0fc9adc75c0a92a9a270aeddabcd265526093e233f3c561d6619ba767fa75aef7cce3d9e8544c63ad163b0318346fb93cbcabcbf8e2671749baac4d64967034b2452ae62b16b41399acd883c23a71b92b516eec5c81a93e780ee76fa2b70e2bcc8504a362008d04d1e834f99ab42061ba581aee56b85249126fd285f874031e4cb257b403552a862e0892fb0a8701518a61e3edbabc55c768535a08934ed1288d7cc4ea8ce602da7b1c0aeaad697d32fb0fcfed2724d0c13e9af19ef150b73278b79dba629f4d08a45689b5a2b2e81f9c696f496a31599e54dee1aec5844b8f065dc3b7a98ec8364f0b542703e3da50a9106a8bf1fdaff2330428391551fe6811f3a680f6df40e3607563d9dbc64e8963b4bdfb05cb53d1ce8d8871d835924272dc810a62ecff7fa62cc4a1d57b8d9837ede733b10564741b2540a051639fac0ba16fba5c652ffbc1631092cf67313a9b8c84b0a4381aa95f81e393bee2b3ccd1f8ca4abcc7fbee35d577ccb723ec044a745af6da1311312a28761ac17b87abf456115795e38af37928c355cdf5ca132e4e4eef96ef88b48648c0102f711cd1e9157208574a0ed6604952fb269a936ed87a534f19212b3dcb9f2a7be69bcfcd75faee8059241626b3c55273e775f498fe03b347f9aaeaebcc0cb7c15eb9deb634f50c935d64c290042175b22d1d61d25343da493cd56fd4be2daec63e725387dc6ab02747102e380472ad224109eaff51e4fc60b2ea464065a67d6de91d6f36f52920cb946a27089c476b59d851595d9817ace9fa9d4e378d2abeec004684b1b0f4178dc65329488a235411a9d6850edbbed1dd20a4914caf719d6321f884c11130ef78378967346d742bba8621e41eb60e03741d2e81d1b3a399bfe654a3145f740b2c3e83e6f4c7de5dd825374a0635ce490b5218327371c521ca8169bfdb0799cf0c984c3ffcfb9aa4251ac69515fac06a7228b3ac1fe83629a1b7933accc4e46179827229cb7651caaea92b48354b7f3f8f25a49062801a0a47c28f30cbbdb13604c01b85a8cdca33c03bbaee1bc0b8ae18e5729f877c2d9d4f95b999df976b4d92e90fa9fa2fde42fc36840c541dcd7ed8cbe4d1111fefe5753ebfa437c828abd227909e75f70417482052a1feb33667f5861e6abb7cbab762753f0b66499dffc9ca1cd049d7f99fade5fdd94649c661278f81a54fad1e8f311aa80fa8460d7c0e7a0896b10d137cc9aae764cd91b2122c199e4f6d53264d22f6d39ef85e177601ae79c2e0b150244aa023390af728e665eeeed475b86454829dc3cddfd9844d56e40dcbbe5045f457a05e82650513c4ec8f88986f868b88789cc8e3e8c70c211e0370be5949cb12a0fc4f1a9f1e09480a633de7dec61d31fc3d0944421c004d733b06984e8b7271649d58e754a54d83481cb0dbc34a11590fb6cecaa54337ae8aa63ff819811e13abd45f210af7395efa29a219bc74879a6c792f488383b78c6b9a1acac89a82d6bad276e0d4bf49b17259924fbd5061665cb9bb3807fee05c6161d6585c9496c65c5d2ddbf0e512b88d49bab6206afa5894f08cb26da608ff274408f6be127785317a2354e559bc767e5a5afc89bade53dc0d162b37d7728e270d99a3631711126d4a47766bc81e519dbaf0b218c230fd15a19aba4e4aba81ba90a75719557d5d6d8504097f3ceba811f13f13abb58cbb15041636731327d613c2b87861b8fe4f36f63d30902e0c4073a41368b641ac5a688fa254bbe3f62612a098b687da083d08d9a5ef25e41c03fd3f317c576c46d3594dbae813a3f267931281ca056875354830f6c30754973e8f8c5bba984c893d602e5329dc8df28093eae5d0a17fc6de866f42fe83804de7b7d323883441e01eb702bbe6b6d3675eb8fe30064dc945428536e5c569b1707a3bd491ed9279ce89a6e77c78fe57484ca49e712188300efd479d8cede8453279020542180e1f29f7ae1617bd554389986387e65bf1f98cf370d562c303f87e1b73770dbda0c939e7ba1423188d35749ffd9b1419b616c0cbd942dc45b9150cb1d7fc2c54fab405fbc6b57e3e8e83897368a5c118d059e9ba97d76b6c4ffaa47d51e4d0ab1dd1d5499987760111cd6594613f4bcecf196ac0cae3b0e8b7414df518a824d44422d409c9bcd0ad4c55e3eda26155f701bad57df1530dd40e3f80d6adb8e69eba1ebdb318dc4289175bea10903702094082642569049e0af8e469738a49bb1fafbd01c5aa4684daa7f1a960fa2043c824e1bfdf0adfe92dab639a662fefcb0443b1d1ef500e7d16a320cf31f79f9c12a04419d5c0322e13644b180ddd6dcdc3c968b162270ce9eeedbbbf7c813b29530e652d89b9ffeddece9f7f9847d6d38d86e223db8b825d15e00e366836fcdb7ada1ab2d5069bb6e87cfa700c957d93155af6b93f62f8383e55633f92b80bada76a2a10ea977dfcca59c80462ee8b0bcf44082df61bdb66b82761f08c0719f07501f8405ac42bfaa14284b4e5926ea40aefcce1dedebfa0f45799545c8c8315c28ad5c4bcb552245785173f44070081c8452f2944972ed281035e1f7809d7bc3524577ddc37c1b1f65ba7f77c24d09149d7f1f8938291183c01e8b99c055fbf3a3fd22b9eb6eedbf2fa8456076cdd9775d5b203493ad909cd5d4e070772f7a87f2649011892ae5141c41d217193e01df5bf841a0a817978e6bc53b6f6307c6e7b203da8f51937620eb4548a426fcb3aa7ab878b3f5d21f5c8458ba4628d254ca21964a20ee17c869cd874630c815328b0daec2f388f443c7c7e13e9d8781281866f3756c39d3a7b03d200ef2fe4225f12264ffcc2435d5e5dacb6e4ebf202aff4efb059d24632f5bbb11828eca1b7b723fe9035848463de9dc8ce8a90ed9dd2155b632c2986007ff2bd87decfd0055239ed17b53049d3866d42827e8e648910ce602a356dfb7ca145ce36543d73806f9f8ef53cc4afbc9ea5297819e55c2e4735409b73e2fcb69a4983d96d38906196d5d57566739414aa14c2865051e3a81743f5021650aaf3e81cd316a59d113cb5382c7701323d65246d5155e9cebdb907848a8fc45fa1e93e1a25ea49d73d9f2eed6490ad87d922a8d5f4764e9948796e13f0c0a60cc4c53796bc72f22ef4b116c90a144f90d2453957f47fb808bcd84a53abd362f97585020b37885c2e87edc02094c9730fea2b05040e493d1fd0f929ec1de16c24c405f64b6f9620ca3764c83be86ed8d659112faed4952453fc3429d101e1077d3b57159e77022459119e352021573518c459dbc1b38410b1814a14591250f977e0aaa8ff6add67c23f71b8c4bf342482dd1739870594a965176ba82e870ecd37ae08ce97da566cc5b87c6d3f149f5e357c8e9bcfb07b85f676c4141415f1f8f6d492557b19c937300b9ff0a1d5f5641b29ae3f595aaa28ae2dbfc2727fe006ab6927247c8424820452e9b4f265002b4f7db9e3522fb82c93022c65454d439e64fb8bcccbb70bfc6d2c7bb443e5944a65c01e6507f3be2199b253a8c91a832de01e5cf3cbf149311012b557bfaebbd9de1c577a04bc3a3c83484d43a1481c5ff3c748c41d23abb4ceae4f369f7c6a7cd53e0bac6d41937372ab9f3ba900a1fe3909e0bf74630d0a5ad58c3d7b2b9a4e8fb55bb17942496cdaadc064c5ed7fe8257412b6d47b9916ebdb2312fe5a7780731dba58a1ae4341a914a4108207c3a1ee56bb88b8a8c54de354a15e4aa75f019043a563545103265c667bd5098d3878d4df5536e99cc02bc5771b46f2e6994fe1ecc3ca1931281729254f17085f63435355c0141fb8e363a43681f0ef5ce563143b1aa6e9d92bc8c6b143f8542c8b79d0031597079ba5b10c1e5eea464204f5907f37e222369256b9213cb45a07c28c3fff986d6e692f6f569a14c513706ef8a34b37a01a2481ae7e2e339c49e4640969062cf137f8f4f320dc7f5a80b23406151307cc6e8f89dab7ff6638fbd4c23cbb6d09f0ffc2773d46ca233121f6ab9cfeaddaf3dd6a14aa9ddd6b38dd33d3ddce7f7b6b852be2d6d0a59c40bd0bc435043818357db7240ca193945e8d65b37791feed385773c04685818f2424501da7bd16b08f1902a9e101b9db555e2088d88a0fef4d9d2605103bc32e44145bbb60d611a33bf2479df136a2376fd12f5505302d5aa62543dcb084544446426024b865276443393e1e79d942923f979ce1dee0b2ae58ac4c2373d534ac1f3ced4d6ea07bc6c8ccf7382bbebe7e7b0c85f26eca6271e15f59510cc54ebd8e1ef9a38635f030b12e56b385a5927383ce98bf64f2daf6759d6ef5b6113c775b11fe40f6d95dff0eece5c495b778158f3bd569ad8172b2e2c322385254ee54c0f8fb8c632fb3fba50d81ba7a0ddb547557ba5d27e183bcb6d0fe2158553caf8797d34828ae64948decb86c06d8379108e4753630f680c5f02fb43c358968f09272b450ca4dbd387085aebc9f89253f0281fed73ed0f03f60f5f932ae52b802452a04feaad43e157bb124fcff70f5eec05faa3b959c52d9b04910337e0c2d00b0b5a0931ae19c574cef3958fab849010f2ebe9143170b67b908a31020daa63a7cd5aa620376f529e964a65ac770f990f4d55ba76e265cc9384c21e63f69ddda2a6b04769128c70517bb112d563cd98bcf0d27e3a807d26873ff87e1d3eea27c0fb59bc56851725d00f8114da3c42200238708764ecaa1333b4d1c4e203f678d68a073dc9e1b8c8dc3ddf0b1c4072bab6fc00cafb298f649aa27834ef4a7593e2403eee160c4535500742afde0cdaf56d8f6925e81da88b351e0c99df7ec7738fb025bd696b7a9c01f1c49ed8383f690cd49e2d71b68c1d22bb6bdfa867e59a6603c2a8cd539f1948b501e82e1323b8ee43041e2529aa750d4995c60aec57bcf6bbc02604fdaceabb6b80af652e8e22d68696d74a36bcae2234261ad64e5aecfbf9e7dcf12c820348a11c4bcdc4171bb9a02553a964e79ec86602590c2eaad551e913b78a4fb50da8ae1dd399c98716a6bc912c9192dbb5909185c97a342451241a11095fbf911c104f1b00d882f792f5aae2bbc7601cb7fa75b5892873e2630576e6ab71fdbaeb653a8088169f1f297c497ecea3e780da8db2ce58287286dfe5f2d2ab3935fb7d13542b743dde0d7288083098a4d8072a7ad3bc679acc2670c69a01c1c6f67fa6b79a4a664153d080ea866abd1fa6c743264126b23b449b5f99c4c2fade6893ee98a1d23acb7fa06344fdaa2656ea5e311a0485ff0bb1d7c9cefaf2636eab60947fac89d2e30f2aa4e87c4493794dc40be6b624c7d18bd2f13bb9a6e6b0136a862232b646ffee8a24783a6f864698d3d058f7793ba28e9c9048c3104f3583ba25bc48cde3241afbaa92244f2035db74ad849c628c3908d2f2bcf5256ec389c0d8e77b98cfdba8bf286efc91939c57697b6e2d63d93485403f43f18eb78517662fcf19773dc59e0c26d23bd87f3c67dac3033bce58d84ced45cdf8cf2b81a3ff38d24c4d59cb63a1de87c8522c2a173fb82e733a0af94d6a699a0e4910a26ec476acf240afa91beac17d4d9b0966c402f72a7a51f2489e1bace166fb43a814a9163d21958e7ef499bddd6968b0a02e45f6240762b62ba6824bbcb8cded1f4e6a7e39192dc4c1140f6b91b9cd85b09800b870771d296fb7f7f04f3b6def3c654b2b3102e543db448a25bb1eef4109881b647a4f3aa05b5dc0b329e999013ba347f2a8f678003d5b1851cc48e316b0075cb9a95f5588e4ca806127ffa7fc2700778d0914cf3f5fc73517004a086f9113e672e335083d5fef33b4f71dcc99c207a6312c2363733fa9644908bb441f89d997aca6a55866ba4a59936b21198275f5de6cf677012be04563a4a8c7ea5a445e53ef5f7544d062e7157855e3177fdd370189537395ab1bed407f869fca5cad88b9fe1ec9691e861fe79a2485b0f5e514ac87b9237911d1c11f2171abcc1476f1e414585e07bdf56968d48eb91b3ae688513d2760189663c0e3fcbe12c34bd45bc2669067bd197044705ee244bfeaa4b142958bd373ba7bb0bf678439e1afa545cf8341d9ea9e54ea83ff6723ee85d66c0557b75687f5b53600289989d6a0bbf9c702c2b2ef3a508737b4ecbc7bba6d98ec35a54d85c79aff511b23f5f31b7dbbd80edf35297b19689c6ee8f437d75f5c741316aa937e79fb5a483ccc85d8b1f42c47f6eec85b6e87997e7a4144cf5814e49196682a1f4dd5755d490657abc691c3689e062e6f78182407122880716d8caf3d5d23133687a15e8dac07ac37bc784eaebf15dcfde58ec0d2265aa4bb4f52150fbdf126ac601d13bffc7d588d6bc1e18bc7894dd648760e94bfce60370668eb25efea4a2f1127d637348cb4e2033e1566ca23a4d1e6abd1afa1e239bb38e0635c0fee00e8870d864fc7d836a51500cf9a1f9ffff9c64dad8478f8eb80cca89526190e36f9f3b4c5bb38ad41251d3a467a2f4c47affa1ebf4be5916ba38525f6d1cb31dadfe24992ca3b701069f4804f9c077d9cbabc0b9adfec4752742873b8a23c452f394bdd3787f59062cea9c6c6713f5e657c02926fa81589e3f9adeb4913b58b937ff82bdaeec88e223374cd07f9cf7656f87e5a718317dec7bd545774e39196c19eeac7dbb72929ffd48a13096136af25834453cffa2c84cf1eb4771c2ebaa2b7336aa86f135435a255a3193ca723fd0673fb15e6a77832c90b47b627deffc5739f2b1873d81de18d9c3abb373c828cc4a01a6d74507648e53427548ff581795313c2d0bede49a08c47de307114dfd382ea37a66ecee029d50b49507d93bb67258d4e560ec747b7296afadc3943f0609ef81692456b0a45058e4f4a43453aa00b41ee2cb55f4aee896e06e7ebb8f82527dc0e54ecded6289b89e71054ae38d13cb4fa923cbe2d88d7b29b2102e4d9e4bc84fb951f154aba27bffa31fda46e6b693f2aabd4b55042db311178d9b011303f7b342979a3ff172da49e41313dabf50aecdc9d584ddfcb4608e9bdd5c3262f9e99e9b9d60c06c9f2686a1e7a1b6fcdb8bab45b3a43eb0aa3cc6278974cb0a649ff0b1a447465cfc66a6860411adb734a3a834aca718bc25c6a8608b784df090f1f48fdc2640b17b770dc1c9a34cbe1d5715433fb954c2d081b61c922e3962087030aedbdef41f86b5f6b290b930a466cea48859ec7af834a5e0d29a1090d00f91636f102eae7aaddcce29d9822a04e4e22ee87d4560c58b7a32b1690eb979aac179de378d98782a302033564771452a45c78d7869d584b87ef1354d688ce80acd5c149c04f73d243b8ca5e0bca0d873200e4aad9d3f4e7d1549d592d42ed3f3589681a4dd8c3a9a19d916150e449d236c89c99ee0303dff498a413ecb92d3c79da02353c935391552c8e60d0310f9741ce083010dec926ec50b34450376213ea8b482349bfc76f5ef78fa878249c5f8616a8590bbffc260fa7f89a0f995af4658cf73181deb7e8d906b93b90ece994c6bf061746a29d862881585ebaa6bd44f64b17e9561542feed8c53963abcc7d2e6b66989620ec5c4c67d022d4ddc5734c81acc778e4f105d406a2f1cbe0fec2bd1ccc506379da20183775fe03e18d57207fdd3eb1bf3407a15c9e4418699c4be7c0677aeb9a5a4243a7780a9b2f0315fea8333656fd11a6881a95f5a1bea7bcfb683a4093e9f2ede951fd8de91f949a7bd85abb14d6c12544b5b9686af1fad80912974e14af328f7601c59f941a36ad626b93db6bf4062106b768d497c2655c183ea6fa95a3f476fb0ae8d3a12b47b2f29a5d1ffd118ed76d59c28295ac255bf9b75462e5c3fabd104f77bc66633ee354fd145f5fe7cac806eee2f73a0ac29830d71134cae5e2c019b3540d91ac41e76bad321037509733ba5c06acfec3f2bdf3328d5d46f3d1947915d2f8dcf898710e4f03dcfca8baf397f8d2390dc05af7f3b139e8764a6a0543a6b9ebee9230f6b59f786f587becc9a188f36d32152f3d251288ec04994c180f685ee27ba7022e69d802b516f9e551d1ad0dc330b8d0d35478fd679fd9b06bb5f8bbebd19700270e9f38ade8e8b0bc0516ab4831934fe1f618d953f18de42e1f23f98337703cf4b53e9e3a9ee37d390965f025d8826da8775b189fc02d3d3f6ce138611096dc875f606f782767627c6bfe1a0b3dd3ba0fe79217b7d107d0fe200c76edce08a879d4572bcd6b2db8adcb7b29d08e308aeecd6d312bb144746f9da9965c80c1290f17fa6198c310a0955d53f6a7c4ff21200a51a4673336f3d14a65d2a06057fc3b49b2cdbd65e7f900cf117dd1b5bd1e0fb2382c6ff5893dc33a2534820acd3f1fbb4902f80db0d579a1a24843ac3a785dcd8058bd201b04db5abb219e0008669545fc7c1b56a2819d868287b21211be2997e4a79fedb0730e78a1b2166eee710cfc17d36828815eca690d0ed963067ff1d0dfe1bc7073913b5aae6ef8697228f57b8aef75d09cc3852fad77dbaa3f78bcaf1439ab77ebf379ec5fb94de9c93d3d9a5d1064408841f6f6c0a84806572bc5c2622b6666822f37fd5ddb4d98b27a2f60e9316998f4e62a5293e3e507c83987e3b318b947fecb81f7bfac5c3030e1fedfa4b5596b4bf30114bfb6a12fb6ba60224daeb2fa53236dff00ddc5fcec5488920e808093d9ad2151aa4bb9d14686095b7a45bbe03a293e0903e47d0ea06468e298bd4efbee9018a8a9fc58c972b08408dbd298ef6762674854972b868494957eaae6d21d865e6b7a55a7f7d34545985851163b9e18f90b26a4eb480aff9805e2da0392168939e14749d95e171d52a18b8508be51e536c850cca408a5bca010e80d479d3ff08316a59c3d5a73f99df06dae52bce1d5f8a902e4626299a0e2389b5d4d7bbf53ffa6cb98189e4dd85f5904fa4e40792ec738156b24583dd97028191274436dca75735fd93afcf018197c5a2fbe901927662d9a769fc370839b3590e04178b0da44cf719e1976d00109586c9d2513a40085311ad4ca28b70ff52bcb360f417fcd296fafa0ed408b74637875718733a2425f820baed753d440f6dacd517c76fc73a3dd734d4e20f19d811519586bd6600e7ed409eb55313e658f9d9c49abf84049160902fb5e9b12ebf65bb130a0ccf2f1a13a7cd04e30e7c130cb3cbdf1a1b7853be10d37d0deb6cb12470b3f4d1c1d7912637c9ebc7e43b7a5dc20bf5be1c0406ded3d3ee546bce7b9dac57554bb58e31e2afebfaec094431f54ebbbfff3ba8431d306c719fa6cc8edd97c68d98b453e2ec93e04011810df05f0ca5409dcf1f33e7757abbee21d0b3c48c0c41a681ae14037fc0237ebb6f0e455d5931a79817f241f5180c940e84369f394e3d03b4670f5ae92e716ff68cc355caa3e687788b72039394f303349a74c4e4eaaabbff451026a444b31f2070ce4054925a165b5efb839d36f730c01e27199640e3b080cd1de7da3215dc37eecff8e49880e5ef7c21933bede3e86f01ca41325f243b17dba3f6fd552fe3ecec84cd1138602ea3743f197851d88fafaa509805855eebd55e51349cce4210baabd1073e664230cb4e1180f47793b6d71bcbfdc1499c589b154df6123335a3ca70d30a19566a6be3e68dd91da84b54aa8f7d10251a98dc1c62cb267f595ff3ef2b2cf90a946fc37ee141234ebdfbb52ae3560e69cd86fc342597ddeb79a2bc9ae0adce29cb9d77d7da34c0211175f2a9f586cb08ca5ab8e28e60bbb0280d9ced17188851a579c9be3f1db36dc67812c46c1a0ae2be89a3e84305870e27d743612b02af32e3eaa9450b4f920edba60da2f1b30145b0d3435a72a6d4726c60390f530e9da907fb69c74a40d2b0329ed2eeb308b1cccc4e14fb9c002e3f75d8e102ff78ba9d7c08779d19231b33f7df01baffddfcba1e8ef2b80170c54bd129fbb2808999796d85453727166a8c735db4247d03eecc7c1be6d721661399b8ce7b0d846bcf6119cb149cf9c3ea818a4ef3a7e6fe7ad8f7903a4d73b336feecd409cedc1ebd5a2e90e2ede1f7c53fbeb4d4332cf5250ff3f93bb1e4ca051ab2db863e94c96f75a90fb220eadf16754d72954e72fc7df614be00fce263a3eac2b444b8e3a919521ac7b4907aebfc9c3286b5571fb2a53ff521d368d2425a5e1e287af26363be4ca0525a3aabf68207ea1066a465b6219bf1b1a2f9fe4aca2bf228f279ba82e5b5d1a15737599d936eff2eff112dc4232b575317144e9165a20bde792559cb0ad128f6e4647987f497eae9c770d02e6bd40d21aca72ebda6695c90069d61b9040b8fad59ccbb8c705244dfcea71b5d6d80753ff2c2b30d23463b865977572ffd5ca67666e8320c82d19268820d518a771d8e194d9b3e8dd60eb3cfc46e45e0ac00887dc5e068484f41aea61ff24038c1390a56a21d73a58849534890025aff26f9309e54c8a8fd7fee05c7fa010496d256254a6c032e187b21b76ed5d3e7abff15f252be3ce9c5e2a1eaadbd5dcc7d821e545fb0440929a20483a1367c0cc9ca4cc221c2af980cb443d015ae8cca42fdd5673ba4ac2481b046140ce05bec89102bbdcea2b037de50733101c6f53587f8e245fec2c84cac1965ffe64d43dd44447b756b51b5dd1a294f93fd8fc38401ba7f7e869c6dd7e5eef26cac1e347c361ee4dabdd209f0f08ed3eb5c337fe43a6fd1a825895df6bc7dda6dc21089967a7af1fa0a46fdda0560cdd3d9029c872c58d7c00ce4749adbbf5ada7439d9fd80f2ed4e96957b9357acea2ad4ecad8d319bdc1b8dadd8225488b62fee888931358a239764fde65c5a1e787832055161908541b23fbcd41e58908a2e74f5782fcdcfe520cad5f7668cb6ba8662a1df0deed6660320761be0268d1ba4160654872f5552bea2ccd8c18d7703f3463794d2719b9d4482b545562d33ab3e2ccd293e1f5464b197bb950857c40ded68c2683a59e7692cd7be600f5e95da8c77e620dde6319049d8086989d88aacefa02f9cf7807d311879e02a74fb1365ff69cef0a5443f7b27f255a3dde3ee8cddf911d4d9d21743789b7fcecb266ebe4027623d663fbecc8771e9f4ea84b84f6c42ed151553c76388b57d87fea28fe3d06ace717c1eebbd042f121d73847658d332a5175bdef7e97a0ac22c28df6b3c3fc793f39fd2ff876836c41fb7d79a83ef99955a2f17d7b99f171deadd8be72d6d7e0bd99dc119bc33957fc235fc28161de2890c6ebaa63d03284f65c2aa08fcae4e8aac6df8b626fe448f0eb3d7d8e7ecbe06750e18699a9b4c0f02065bea975071d4f4e8f5a4bc1c9172d223b81bddeaf0d051cea2372ea4501e82434d816a04e94c5fe1cb31207b2aa1c61d450c31d98b441c865406f03381f9d4b9f567651035d32233fa4e7aca779889a65a01cf004bc61dd6f84a078fb209e3187f26ff916826bd60221d21a3fc0e5cf5107aa0dab457d518486c7c7b059a8271c9a39fdceafd5e96193000f034772217e4f23426ee6ff209b711793e0b4702c2f6fcdd41a2f5df75e89f56ba159f9163c07ffe8288100b598e64a2a2641990b24a689c3c6dc8bd41fbc9f284eb027741828b58a9e4a5deb6f58155bded11f9cb6b6824f8a142017ea6bbeee59df95c1d841dd7bd095f16f7a65fcb736438732754751cfbf75608992e56b060747023dc0f92d942ea83ca830810082214407c59b0e34f82d79f5b95f288959f7efba0321530e809a02f1175d08ebea91f7c8e1d2309021b31a793a472c62e9d278996d5f0d354e150975ea796a53ef96034758e316e255327c6020311586c954d8af6d56183b5dda4fee57171c0682d407d39613131a25a091fd0e995e39b365e737ca17e3aa72ef31540018f5c90ff7c6bf9c2f6c74ebdf81769359877b3e3ea91469e7b642957d83e0a32b1c2de43a63e9f9a9feae65fecea90c7bed07ef29b68998ca3e5e709cd269249140648b4a00c46c12bdf5de728bcf275512b3a5d29ba1a0b9016022c41f23251db549594ba70920a6ad33e0ea2f7b3cf310df6a852e5f2881e6fa08730784292bb581aa237b52e5ec43c8894219e836ae4450e9462abe339b611bf2d80b45a8ddaea5e95df8f2dc57a04d106d2a5c977cc2f6bd0246087933f133078aaa618cd91568070056a7f19610d8ce14f694524b4dbee6458811757daabfa6d312b71d483de1ad852bca0c0e9df4a53652395b184403410ffab594693050c6dc54e3346fa7c7a5b4213cc292176d853d5dedb77575c54abd5be4620ea439442b5034d6018f871b8300cb0ffda27567d6e25c0c845ad9bbba8bb4fe109047073ba14440166039864662cd1737107ea24b51b6a1c871bd41f8d9aba9ed73c9446a847e5cc660fd5182c4f9d0c4cf7b212ce8635eb6fc806ee9ec17079fd7aa81fb19dbc5367e4563af7688bb7d20d769a2a64132e5d9b266e9511f9647fdfe26d4db249f906a0b667a4f3d29857c85a222aab21883f3ee2bab446e2a47d91316b7889cd41cb472ec50c5e3b010232e56d49393c61034d0fbe9b57af5fbe89d7d47418848dd74a6b78cde504ac6cb9fa9c65030ef78f0e5bbf0604040acb3edcbee5eac56c9823b6cb3e93f5d919ca786303b52235f611893ecefeccdf87959381da3db806f9ba55360bfd7efdcf05d85adecb157768169024fd350ea339f3013334f699f5352e1d36457d7a9f9fd8fe28b9d7d87d880bcab35399efce4d473c8f4e8a77c0c7bd7a9847167e359c5551585a56b9eff40ac5bcda82c30b5053997c82fdf6fc9d9344c7376d9133af767aecd4bd5f8da9a3c1d8ba665d3db810a3228c55e49156f1686ef7383b98353617fee32232800af283492c69f2f69407256081a39ee336cf7b7723121bfe7f8e264cafdfea7e09cb69e63c9dc80f8aa16f96039d3b4df30a5f1f97bc7e254d41e701bf802c5509a463c08207c3f2a6aefb9b9afab90f24f44a1e0a765d17313c2e37d72c03528cb3e0160ec54f311bb60b7dd056ae34524569fa8c0b4931ad892f6163ecfd2f640060a51044c40ee48dd67a7c87a086ff3cdd63dd8bf0394786d6fcf5ea5d12946132fcdfb171df33c6d92de3802eed31e0457984f6902bb1c43110c77c6aeebfeed7e0a27315f59f91b55ff39c61502777964d30d02ec8c66e83c31c2d0862dffd4234ef83dd2d5f96a18142ecb397778aa6d7125593ac290a736c85ecae9374b55eee0990169da7a391b598643c784da0f948ef788bef4261866b61ac19f99196ef1357656ee3a6570ebe3d038a3cda86df7049781020f1b669fd2d3849f7d335315f515d1b1179117f7e0a2a940e9602e4483f94b978b8a6b4d5890d9eaab6ecd4f5922aa3786c22a8bc9ce48f6561e015860486b6b132d32476c53a207072832e4fbc81812c97eebf1091b9d996890434f51a991f92ad303dac0812fa2d6b9af00826fd7fd9272919fc7189625fc575cc6b4402c7c494a345710ce930bb35a33d20fa90d68e2fbeed03b4912e4ca55049b7c7059b9cbefb36c927f6d45ac0f82d2055c12be9b59f73118c8dce3290589ec02e00ba36697daca4282ece89251df7f3ad8e51be3ede1395d8b731d0f1845029b950b1f7518860bc2f482d5e0de3cdeab71a121241f378d214b6457bfab0bd526ffdecb265b34a2286a72d370071573df17625e1a4c31e1c24f83ac915e702a7172ee468be82645e8e5ba2fc1be2acd0430895894f2864c80c316b75c9d9dabda8348d12eca6c83002f30b40e40dde44f5133ae7292d72f0a5d9e95043ebdb7a502c616def4880d344d9957d199246d15532c0fc09748a5ff0a93b366ff90289550bc92132ad2067160f677d70673c99e1382cb103983208024cd18b9accdf4d2bb86afa446e55e7ba25b1f5677f423e9bda6415dde4c29d8942528848ccabcc080a2145362eb31b35fe40b65d023c52629ac155858c98352a64e0d36a72f5afb520ae8a42b92f77ddee9767aa9a0a067a598208448287c1373a515cdff3696d561f46513233a8917fbc01554e9aedee98f162037718a892d676b0456af90b33a005ba9a2e81df5095ca0b0f1fe7d3b58b805c73b7fb8de78d06d68cf41b759b265414a91e39187e83dcdc306557cdf7add34eda938c3cf64e7d6eb026af6a450d3fed7cf56c3cfca8fa42d95c506d13931a565e2ac116edbe4078c688c6e8640569c3a1761a10f5178362ed29f089a07c6578be7606b57768250718bfcea36cb560fdf7d9461c77b7dd0996ae55e82b80cad43398ca66cd1af30d2798b41501ef002eb6554bc0e338bcba207900c360f3145f0d4e726c74939bc4963cf4ce959a86972cc47dcb863bd103258fa600bbabb1c4a1cf8ca0aec407bf01ee47718f1785cebb5e1c1553b3f24e49a5bf2f4ebf12abf11eea7167d92a17c6e8b3c7b3f29d9675053f575c95f7d79ce7d468fb0ded0adc946073ef6d817151bf1e5c840b75eec1b4f6e4bd29c6b48e0bf0669b3f2bbff71bec02fb51370522bef26768e2ab36b2675748accb18fa0558bc8b53a135afc935c5336fa15c17b39c6f97b2e85a4b6eff5f7c2b012ba89911464b579a41c61bf52db6553bfdd6efa948371d04567c1e646b6170de8f578084eabd1c798e596b256b084410fbd7a7c090e8b33e397080cc5d19185a2ab3004081d388f04675e16f782ddcd9819e36990a3b943216cda7f3af31c571a3680732458813c5ef171f99385383b8ba543f32d998e7d043b8aa2d837a12b915f44ebe92dc73277e105465a2e4ab8d7dd3c9f79a2ba4c475758c9307b4124352b85f47536def9471acb3238049261ec825eced8689f0095e4d119dff0a0343f479bf75c2b274b050b03a746965d83d4ae9e05f2ae5489dad87267ebefa8788d225eb750b5f3f98f4981aa8acfb56cf2a3b58540c597a5519ecef0dd5b47953e3ef60b1f8cf96ac8330397444b42bfe3e962676f2d9331960cbdea4dd8cdfdbe0c1552d5bc7ba78ee86386c5ffb475783675c3518e3cfbbc3fad5b1c1cb3d46d5e82e5a8f1d0f4cf3ead7798432047113b1372013cd6d0bd4ec8f8f82638234f44a3132fe725f6d676e0f76809d17ce347a8abbdf2619648698f54a16e9c9bec9b63affe049f9e9ed004a5f30ffc58693cb6872d202673e019be54534ee2761bc58aac35fe50158407995ce0169f22ca074b5405ad51fb0c066c03a325203098dd76fb36c2ec83041b4a6362c77b84f58409d545f6ff79a054131767b9031b65b19e48f204e7af947f09cb01420477b18c1d8177b05b9732687113dba6cee50bf54302d7bd2de2646f7467346592690b5132b93f1da6897e48b8868e805091d9e1a92a6e9a228cb3a4782d14f89cb3d96b7bb0285046a687690b697a13ad2b2761c8a69e41a772f5dc0a17573410dffd1b204ae1b7a29abe8d6c31d493b64ac307769697501f4377d5aa7a5c0c0fe195ec4ea0dfac8222409b2089cf9b970e2d0913a658b9d79a27f8c04824cdb76a8d9cc787b096f86eed6af15b84293b590d85ee480b1d696fda08cd0c92138871d5dd9d72cfe28140b8311477297a1ad96d2bf7f8e3752122431d0b10e80ea28f6513135f66833685d690f89de3da8038b09b1e8060a70622a00833a7d8635e912e7e2dac41a3da1557c2c158ac76b3be36f2c7c74bfe031f8b5286ab9342673ff6e7c240bb07d0fbe10e637b390183ecee66741be4b5d6c8ea6466dc37eb3bdb1ec2c0415850e120feeba1bf4250e34d28e8dd68d91a3603902f1e888afa7eef45c6d3b5c19d8196ae6f19e7ae3026112eb4bd4bb0b883b62631a7f11fc9125b97cbd170699fb745ea02165c17acdd6adbd657480b325b907375c1fe0303cb23ca40ed74f12a8c47e1c7772b82cd423d588296e3f936c657465c5b4c52b065643825fc35e80b154533bd84b0f59d6abf08d844b8204788073b1e21c2983a55ed52ac5adce85c41d94efbed3e54e6d2ed32b9d42aae42665941ae1169e560138f752f93d496a7355ff6747c097511b28084d2a1c97a86d219759c85f67cb62b5b13510944d1684df3281053b2ff7c225b796ec945538d6ec31406545b49a0501609633c2ac3c8e073838568915e08c935e88dce36e9bf12c4d03b593c119f230018a17234cd7c71c7f681ba89ab7a9000bdd9cb27ec3bcebc562ea77042591da249fbe5130c657232431fb2a1ccf0e2be65dc853f13b0dd5dfc6a45af8e1618bfb02bcd3a04e28ab402123f06bed93ab4bdd15e90f29b947d55ec5e3301351b43058c8ab3d2e19ccdd486d203787f31ea416c96d3bda72215bbf68b000b3cf813fcbbf12ac1648a43eabfd14fec1bab4118125788dbbeada7d4641bf408c5cf4a8d2ccdaafdff88fe52786ab01f72694bb25decab7ba1c38540c0d238382ef5d06e383f0992f49fffb223e7b66f200ae36778b4422e3e1949227dbeac59d7bd136a5442026da9befc5ae10bcb52ef2719a52a19b8409e45a9985ecec556079bd8ac85fe40d232101de4c04cd7a21ebe890cd5b3e54f77d33653e0910338242ed9a976434ae6bb74eca885ce24072d7c887ed2691045b459f573010c95467b24b90d54c03c7acf1e50a764f53d0b8d4d2a423c5771da9f61a2dcc57b879ba5a7fdbc1b92d7cb2b11d62c4986164cfcab89fc151ea8dc9241150129535dd456867e3ce46a347143ede4af5a8faabed7c5c6609724c00ba342d0be4c8c23ee3190161d4bb58a433a5a41042d67e5ef33d1370e1b85c373feb9ad90680787e399223eb738cff0e80576c70e9a534d17b9950a1064ef29f13fd964286aab34bfd52b6ec4723c7e35a9db169cf33b97b59af0fef66046002f89cd6a42c18c0fa9fd6422c2adeeb33695eceaaf18911fdfade9b2aed784f8354a7c9be77ff8f2b94da1f9cbe8885840282016c34f76ec9168ecd9b39ac906b39a4a1f1bc65725ea5e35285f41d5a1c44b65c8a0d072cdc003cf09af4579201dd732b33f493cf4dc73732d4a9100a9a26b3da16856a916cd0409759409ade63c9cfcec0baa4f7863809f57b29507346126f58453d5cccfa033d93e3aac731c0f8b1e80213923ae8653687e31a091a7d825fde3a615c9046a73894b9aba12c8746f7f71ef2d61fa108b9e26b1c631ba1bf344d4d6341a1f64455ffaeeb0897d018d2fbf1b2c3159b61ab2ad898bedc0a3c91d93d8549fc45fcd8a5b6acf5d6540a530a7df33cca85f45037c74d96619e4a5ea18ba8656506d572467c502c175c8149d005dcf5c2ec9a93b66bd3dbc7d1cc7ee2b1db3d8bdaf1e72f858f163267ef0a4c356e73b3ea8f93f5add4827c6838fe629b4605c687b1dc1ee1e2485e6318b97991bf3d0017c7de6d8b28087c5a075a88723758e5eb8e90234747f529134c0203a1cd0d4974e688f692ad8fe3087e207123492c142d7f9dc49e41c0da0a299abb8885f403af0508d48cf34949d98c516653e8a29af17dc38149b5e13326d09a220eec240b1999a938560879af592ca1dd7f1bea7c876c6bbdf490baab23809c65cf8681f20fb25b0bfd2b9470ad5d1d756d84e43f46c92fdd2a036cad271530e32b940711ea5a62abe17ae39afa5ab741081e74cb86330afc78394af3daaed41b82f47fa8d1583c5f682bcbf2df66f245b963ecccab610858b900a0c0b16850313cfde3aa94af217150fbbba4410d30a9b9135afc70577d115a63bc3983d02b87a24ff1206a07b3cb5270a6f13014c0fadf17c882fbc5f915c9a966f762b79cc79bc2b15d86ed1d2afdb093cb7f68f807e78c0810c05b00ad7a7c14e58a7c7188f9e812a52db64939a6a434fb56b3e4603d6cc61f793d7b3e0cb79d09ceafbd1c89d6f733c08fbadc0a7e7b182952c35f0d776aa65e2e58edfbd653b42b294cc1b2fa2cbcf02cb69be448f8080f1e9dc14e6beb7adebf238ce4a2410114cd9bac6b1ae68dc935a8035459a37589f57bd079af5aad4aafbf0aab319bb5743ac678e65863f910d08b7f117f67d4e62df211be7bbb591108d15d5f802e998e1325b52b2ce298a16fe1aca8175300de2e80787c2e6f06059d7bb4579d1e1281dad32796efc39f18c6009bbb4cdaf6cf6a9fd7efe5c17816729f7d4105579e9fafc9374529bc2e6cd05db6d857d5a709a128b6f5a8cc1aabd4394bd220a3da812bdb69dc1050da11ef0864753e088f2aa7027ff2d91fbe8936f9b87ffd006b3a2494e62254fb94a8953331b6b96874a102bb4e372fc666d29635bbd2bdba7c60399143cceb2d585bc57e370b432e24aae88e9c6425cad79d7a3f0da50960e7974c72d057fac4578c0a3ef55d01b5204871c025d9c2d7691d7c8368ab9b8566f5ea2885dabafa198ca4b17a696d1cc071c8391e129aae5f431b87210e2a41d8b6e37a0f63058eb610e59505b3007a88e5ec75a927b497478e51faa171ec3a1a0f17d0e90062b8303e12dda60d56620685bbcbdb20b10352f48bae2b8e9f1b98d990929f1d7922e6a919caa4b666424b0d0af5d3c30e67d0d20fcfbb43f30f8f4162e86c9a440900657b733f57b0c57f3d2db07c9bd1173d27179e50e41431678cb9908f4dde5071fb4ff8697653f9476af1900cab3a959d46c54827dcb08f6e196ecd9874c18f9d2dbc30c5a7c10067979e1f738a69f9960bdbfe98cce02ad0652c06ebeaed0d4d8cdbd18f3c2d515d7a8fe6de939c572a19138b0b58e12abeaec3d78378d310e1bc78ef623d5ed2f0486763ce181d3fcd63eb82f8e550223154c8325eae9184d9b29f741aa79ed8d0b8e3e3b2d14f1dfe0de2e50967ae1cadf2bfa518eceb316d46f58190eae43cee5e0a3382b12086886b3dc94e6c6c5c3006de6941e15d9c883706e2d7c9e70ed5f1335ce24f56f92571e38c5fffaffedf95f75d8e96a99a51f9179f434812c4a4f10a7ae01899b26aa6ee52955ec66f669b2423a6edb962772e55c2c321a853ac818474172e5472251ee89b0291478d204baf9bd07ffbf74d27229ac4487840e9d17aa7f1b824635352879fccaf75edd5d7c7c835fb5e65cf8490769b636eb890b28bc81759122f8608bd6415dea027a221f97b87e7ad3cb9c532f66896e561ea27b84dd9e94e87bfaf92528fb6abc2f46c6b596d7c3cc640937fd73dcd6ef602edd6773360a2822e0afb966782c3563db13777a13b7a652f4a15b8ea44fbf41411c496c2f2c8acd2ab36c00a9e68833c696f01376083552f8baeac2230c28135d9cba848f88f4c3c9f910af4a3dd4f2be5d607cb81a342f082eff5f4885060ebf1fb2a5587d7bf3db1d6ce65bbb2f77335bb82a6680655284d6da052819a50cbf79d165c715970f16821110258e84dbe0b3aa696322631730cd54e317078c0d849cd3b1cfb9502b2b322a980465a4bbe74516dbefeceee3d3f2422b5310b80f7b2d905b3ed1991cf43fbc88e64cbc1203e7ff51c476ea0a27c4f05ab0a45c52b73ee5c8e8467f8f11cfaccf79cb778e69cedb8ad5e6b4f8de69a831fb0fb117b00f01289808e57a80019e558cf49cb4222053fd4a24f42b2e5e16eea7ed5b22e2d90cce075f6a5e4f0f0ea68236809828d92d067033c9267a46f4deeb95f7ec07ba89b65d7f0fe93748509278ab0ebfba241d4c0aded19d708018e04c25b81b40f11fe9b73a10845f455a1cec7856efc1dddc4f08b792164d9ed48dbfe6f0462145ae45f5e1438f238813a8106a523bedc1efe824535068eda878389e3be4375fafb6e3ee5d5296a0533fe32aca70e667d327d4d5238658711e7fc612f92b306cf183278f7fc7314e4e50e1915029718809562cdb2bc46785846806681ef3690fbc784838f5a3fe385076ac5675f5030042d8af81ebfe2445aa4e88a8a2bef41f68ae94312abec1a78357f64f25da1966681ce563c01cc08edcaeb7aeeec9b8bd5b2c72d8c541efa2b52545d1fcc94f7aa78dd4dc59cc243400846e8ceff6c26f8ab3582977f58e2ea5ce561b7f8415dea198a93eaa28f47ccb504391d0d5315a8db980ce7db7251ec3b6352ad88aef070e7746ec882760664e37193b728bb3f69d1f3135eff56e544341e6007a5dffe9dbc7087af9b55afdb7f31b24252cbbb6c6be4f126f2b11e987848c042b63c7e4182bfb9f0306666c62c6d59d89feac6aee5be904a818c6ff360854e109b7ad7997d73d2de49496fe70607b5b3042241eb8c9906db9b03d6a0ec63c85af16b582e3deb9cd5a37d80af602d69318e0594b491918bb8e4912153ce0c0da9086ba7fb19efdc58f4a07f545157faea02ecfc6949ce2c19d115624bfbf5a19e3ef0cf205923f871f033c134781ef7f2c1f4f9a4c5a874d68d5c7c7540b279cbb4301278068412df88083c6e4fc15ff46131c733824dcb07ad5aadff2f52e442d35be885b5d481a97b7eb03ba9c72ae583a8e4c9cf932742434be05f35283b91eca89ee0610e934260fb572649d192c830247d5818e3ae91882d5767edee3a5b6bfddeaca7b546b27210706e76562c4bbb36c2598388e3fe2df1ec0fa4593e007a8eb34ec9cca9a12f5244fd9d304a9a709de3a9ca8e47d6e14556fcc63d312236b3c40e617e0012081b36845dfcc2cad955c08565daa7347bb7316ab62625a5c2d9a7fd78bc735ff701dba936ba34b9ca34abfd3810e2a507916cda2035a7038f1b425ea7dccf14c4383e59f9620e13c3ac94ea3c2fbc2b905a8eab366fe3f542a6ff8fec1119f6ebaf3d854e4fd25ef4913ee9618b408176cfae56ae6b3f8326ec93d263bac3efb27e3cbdb32ae3f8f9dc90ed12e6ea11b243c867075ee2ba768ba4bb688c487437aa9b6429033331f64b48eaa28a8d3a8f250dfd1864219e22d7188d51f9e03a519a66fd5f3e53d17b511cf0fe0d179f5a17c9ac1a7b515b37f1620baecf9022acceda265d59ab7e2b27c503c9fb1719e7ea06f920696b336cbd7e24d2d661e53ec7072160f4460d23fb31a1cc0f3b01dff3db72b5a03df178bbfa6314a4ae1c121061b1ac3573fecef7515fe92e1263272631c3f4e8085810b5565f8316e926f4863fb52035db626b38d6da7a37aecaefce8d13d1c14edc15e452807474733675ee22bdaf404a44b62e1988f40a9cbafc5cd42be3ff89363b35ec3e0c05a3a92b8320cfb807876577ef7cdf1906c763d1132af2748c2af4038e02b2f35d3e0483e9039adcdffcc42c39dbfa0a7617da20637b0872a9e54f022d7ab9b8aef9bba1dd5b390bf5150742fb0187f31e1bc8786ceb1521e6750aa6368fa32ec22bb425ac2d6583b4c5254b6006adec951ef81fd1c95c69f46272585f2ff2cc8803efbf8e154f3e2a86bef0ded59685d2915c85a0556daca6591b2790dc3046cb7aca20a3acc0e3568278d81fafb646f0205e224900ea2bd932990a9dd7563473d16ca3159c1ae74203474174a32d199647026600c0ecd1d44d542b7d407ff0b99b065fb4e859644a82dc5223c50a6a1700bc0f5f0f9e1e6aa3ca9d85245b40431a9640671ca69d678e8c88570835e27c34212280a78634abc332b3079b23f20c168d0148b61dd2b4b41c5366fd32a0377ec9704d2639c5708945974d3af8216e4882339f1ec90286837a83a97101c929518094347ec4dda7fa63f8951d6dc97a8a155af46dd04a657b9dad60bce062506c9f4944cdd639b68be33d43b5c4aa4b04c88d886c6f43d9ce4bd8b9c48b707bd5786fcab676cfa488da0c824da18a8beb276ac0fa24323f7f84151b88818729e8a3afedccd82f9f1b3faf65bb221afa46c86a59219ce5d8d7e057cd4060cc80f437ee1417f3da39d6cafd220216ff76c8b94d331ac7bfa26cdd8332a701bc180e45efc11efa4be03f92e4cabe9b8430e8e56c1380fda8f911bf9e57e9f66c447e5140de80b39726edfe03180c0f2804f2ba2e9a26e96655c70c58269489de7cdd6508e52c8eff75e4ad5dc8e3d3c3f7acc4c2bfd62df031fc3fd4371612f883bcd81e367508c474b937a5c0bd3d483ea9789f75edf31b3817b9c409954565925a37c7ea3f5bf69db646ed87bb31108c80c5b5410ee9aac2fc871cf00edad4bb8b8ae3fabb946799ab5f741ea3cdc30e73638beda39078621799297849496cbb1d5831a3827bdd0a50a2773fd8251695758dcb9a7e9b3e53526faa623f92c9fb2f9fb80a95d692a339f432c7c45c40ba54a461ecb5778875ab1ef8876b293479bb5957f3a808e04f83387681291bbf244cd3bf3d21f5edb16d837cb4e64ddfd2fdac9c2822307358a04cb00fea13e0f4a825e80f2bc0d698ab3969ea05a23ac7eb15039b9c64006cf33154e5a0b4b809fb9ca1a6cee22078c65f4461e6c832db2a8ce27211e89d422325d08f9a435793780c6cc51d2ef3e6e3cf411aa439c7340e6dc037316bd7b99cc5941a7bfc070add5cc672109cf0e4d398b2ca039f8cfbe0ff27f052ddf324ba3efa0afbbbacc128cfa7b2bc745ed567d5c7aeb20870165ca6ed13d0a17917b9f9fe03cab40d8b2ce926b2a4be08be5d6877097399baf9269f607d422f3278b0cb47253f5bae39241f33f4f55e71c49379d34b8987c4f0b880776a5daa19963d6df411c5bf2a7b6055fe630294ee23828deaa9ff59b89d05032375cbda3b4074c595d023d2b949b8b91a322cafbea6f914ba2ddcaab4d0c5601577e64fa75c13173c1d3d3a6eb03220a865e1810d1ab32bb0a0c79b54e718d5e516bcae0dbdef3c6514ccac04118945e26c15504520c6b71e96dcf62a1a49e7704010a94492f2c83ea23d12e3507a10cdfa773495d9b3cf563154f3587716b9ccb1260a91c26cf2b44035798a417e8048b9b49bccee740b4db4c536ceb24f2f0f8c6f2e31e878354b10df286c8598f443ee32afcf5de46633ecffaa3528ff5b0e347ac4db01dcf782a2ed1b37ad629692a028c046f81e7f8c3aafb928dd382b4d743887e90b26e82a185299ca01a60499753e5eb5e1bea1ca3d6b2e8b0f23ce832998a785d619cc1c860b96965b55470ccceec13849ee814cbb374593561e8fc3479f66cb2c122e9d7b7f978688d5243f49c768b4e1d653b9063e3753d779e1103a74dba7cad9d3f1c20ee8f7ae6be697deaa86daf40720ee25843baabc9e8aa872563670397df5c24e84291dfe0dd9d4515724ebb32e7d7701b26a3275fe3959c5299219ad928ad63d3eb1df70509e6634807b32cfaff1419de0f4c847b96c9906c45266b915914ba0c5df805fa7a470fc6a83b25b6c95d1899af9fc7f8a0047801e56dbbe54c5ca705139185e3e9f49f834653bea316ca297380cef43149ae4223650555b6e5f1bf4e8f4069ef69b7c1d255d6b5ddd0a3758d3f02c1366c5321c814a351cc4c9f0345fbf665e5c6b25626b3ac6efeae228cb5bb39c196beecf2de3eb78c123907c5551fa691718ce4282fa4ed618fc6e2ae2b0591d39ed0093c531dcb2aeca48efe5b2c5b3ddcad2286bd011446b3f04ed83835eab1cf7e035f28c3f1fafbd68f53414088d9638f0b178a22e7ceb7c4103478601547dc5b773dd3fd36442d07f014733744d3fe8f5846de7d78d73a4d6be5e2bda04b6c2e6b60a7b2f809ea2f9b426a482f26cfd7bd2c3725eb95c4610da13de41eb5c1fa4f16d7b42bf9d64f5392d2076b6f621f5d9a1f9bc9b20bc1e78af4214cb4518d6fba9534013dccc3db31b5604a25cdba4e61a12444842b5ffc33641e60d46c11cca7a03a8b1b0737650e4adbc98be1957b976376ffbaf1437a4fc400c443332aa67840a5e900e2e48e0ae606b4a323bf13faf06f6db583b74c1c8a4f974ef0a81628c245d40ee511254b6e68ac9eb1299fe33008869dfe022c9f8f01f4e3c8212ded6696822a73bfd6bd1ab8ed8371ec87c9e6c821a634857403bb2af82c412cf31f4aff8c834632946db2281e181ba68c2795da99736814c6847c22a91c9986469ce7e9e1b8a005e0ae160a072e63909dbf64f0e564325a5e098f378a89e81eddfd9cab7f0e2344ced625c2c06fcd4b35d38848d90cb0cbe25853438c0279d856788f179e792286caffe392db428bf7a197ad8f3ac2fe4d7725eebadb00c533cb66a967f1760587ed5ca8198058ba3c42a4eea1d4afacd5ee571cdbaaca9b5487ec72324ca6aa6afb24205ff97a2da5ff27c90cf8fc0ad9f82ffb95dad41018b6d863bc51d334771996cd54a71f0a32c5cfdc4022443e357b8d833b8c418ebd73c04f4b1de3c3b5101f5d6c2cdd458627235d93ea54ab353ac744af551b77498b363b0f3103e7dfe1137e1b7455733af2bddbddcec2f2a1f392b159bd39e65e23aa68017995e3e83e9451f86f7d7135fc0543c08ff96dc0f7f48e0aef32df8a5f5b6256b7f52b9137a331127c13a0e516c0a7ad3b6c23818a540fb17fd0b408d4b6046d60978b1a97361f16e609ad9c3a731bae57dd5687bf0f52adaa0096febc8f8e05d8e81ad66d84b983e0098b13225037a8ee72e94767c2df5419850c555faaaefb2a6c5e4daef6bfe770f60eacd6c7f6a2140c956e9867a380b8527def76ab1142961599c72c00fdf8129a4695649a29b38e34127ee3574e65d55e2494eaf78c80a90ec740b395d8acbe881812c4b01d06160fa3c857fbadcf47c3dbd1abd3e984b82e77720a67443b8574b032f1b4f478443e04704f9bc5a75918a0ff7c8cd7abe7ecad88f0a4d63ad2ab3b3bbae679bbe5a3c3a1f084faa7676fdc53f7845dc29784f3c537e7780b0053e48c4bb24f6a44423ebb98ee458aad0727641c464c31a2f197523f6a5532b2dfcbe4f3674663caa9d6df7ed306a9d8cc958fcb4a703205d35c71c06eb7f6a7ed832d1d4facae388158b84255869c29c0cb5e56f7a4dc8046717f5733e53de83ac18d3646f19fb118cfbd23dd2031b182a58cd22db4f285e9f90dc607c8e414c27064fac88eb4865b3f21230e583338a25603ba22156b7e90b129c2fe275d51eaee5b0e183ac56d2e434855df38e1b2dbe1ffb3a40fb2ef551faefa17ca6370ae1fa40dd70679e8e67dc7e398a9c9b09a8a9b3cef96b9bb51a8e67d9b740b8978b5ba3ccab941ce501f6b11e225cf80dc6ea4310e1952ace4cf599d1309ee9eaf9d45149c13abd9a61766a7dc4f4d1ef4490b5d0e1285c0d5924582446fa45c4d74da270358bae301c5a1911892396c5de478d1f842b2427466cc59d55f816f323f1b647afdd1185fb35d995b0071d3d3072cb185572b2cdb66ddd44e945ef01598af4b9b8b8d3ae745e86710d2288b9aa52f533207d7c55fc9958b9334ee42dafdea088360ad888556ae950a376c096970798d683e6de11e026f85825f1ed1b343a4597af7cf5f840266d825dd2bb71311c3a1c9d2e7b10a9c671f443a1099424548066689a955bdaed16c6b1676f68447ea33ecffee95e9ede56e25da5de2a8eedbb9683eeec0aadcf86e4a27862284edf1acb6c40bb143b625e14298b97c8058c0e6efe5a50e6331ea803e26092232aaf4850f6a9145daefa8057bd6b9f18f3db84d38177e1200c26bc7423370e41d30f5c474d02431ed7567649e8cf89cce3198519c305f5f920d0738fed778b5e6a5ab8442948fc34482a375b5ec62b3db76f9f8821499a365bfa9e0e9637f92fa3ea312062a406c75121569d760dee6b9bf80628bdae198cee022e01c0cbe0426f8d4540f3e05e4a50d6d388a833dfa38fb8d1ef87db697464a0c4727bf92c2ac06d09cfd13d9da1a9290bbe851222a20c9a980e9efadeeba5581afd072ea7daa9c9f91cb5b02259872bda843369811ceb1b995e997498f383e142fb5f1ab42d86f7376e1570f19a9965f1676682f2e17c6269d72621f1338cbbb9d4628f9190b8e10a7cb48b8ac68645cd2624d46ae2b3cb7b956cd1f0b97de905b8282bbbdec42b7206b85612f1bf50946b02089b1afc306a96ac741a4eaa7f58ca53ec52cbb52d6529eba81e47a387a24219967527aefbebd49ba59d9b014eeb9a5b1c98d06173c424adecb2bc476044997d01d4950308dc45b188023b2349c58c6231aab0b2fa11b04f5021c6c93a59a73c3220104c341889abb136c7f80ac7531787414204747a66df9bc38e859d5afb3382ac4dece149519d5774ad23247d271817efdf1e4630566db142e36473d89c846932af54d67d424b63ea55692065dfa58e4fbbe2b3de1cd72c8c37e1191d1bb64863a582574e181a1d02612c2a932a7ecb69c3a0efcdfecbf86fe3c4f9e0042056f1dbb46c8638cc33f9e9de18272e4e506fac11905281be146dc18d4714ab0c34774a57009f52275addbd1abed2a37ee9af8a263e96dc0c712a5a5374dce8ed67e3557a6e0a6e71a1210345708bba3295725a325b9b73cca0a4d45962a5e38113c5104a81e2b0cb6a5d6cc2ff393a643c4780bfafae3c80b5598dad32769c048b0bd27799c901f3f7def5b9e138b95dbcc48be5a4c361d327e7590a0f73cbcc2796c252bec59b664f3047a99fafc80887f82edcfdac1c98c82de78b20d44fe3eade841b14ee9f678640c9f729bf4090a20d886e0ce107e685684fb7569d2bb54a4130abadfd4e06723b574fbe1f4ee332e3f7bf4cbfae8621e86d44b7cac5494273bc73113bac3654787bada790f0da079147b227519f4c22e1d55c1c2841895ab5095f8629d90a5e36e20ab82102841b2c6ab58b1e495d75078139e64cb73ab8b4582fbef5a64ae5c60f9762df95b730ad7f4c1e8a570ee5bc3b7d58f9480d9cb9abf69b61b4aa38b93215b5154006836a769ca54f0a857c29e8de87e84b30a3d76036fc42133357db0fe30fdcf1858750e8860f7a5e70f6e268c72afdc021c63d118c4b449f0c202ee2e69a02cf62741d61e33edf23dd78bee90c132c36ac9690d188ccbbdfa3c8b756f48a58782f05963a589c44042fc962fee8b68f4e05060733cb0e6efcecb14dd2dbe3bae28e5597cfe515f4094daf843d05a55f2464319d78dc8eead79b7672698e2ea454ab350ffc7453b520b4f55a1138b5f44c7971203a0e7436899e3f2c3b9085d6ffc40473d61211c13f6daf3cd7059814d4e32fe143f90559173f4f194534d76c81d0cd304cb26e2811ec86a3a1f869098579bbe9360a9911d0f68166e8e320321f67cf20b48bd7ee39a5e0495e98680240c62fe2c2318c00bd35f3406976a8c8b584156a1032032a257368f93edad7b74750b1f44c86fe4286bb6c446c4d3ec1b13319ea17bb3690e9e8222126561eee52a7ecbb964ae2fb00452936f4c76bf97528cf5e8ce613abde40f7fbf0cd7dc62672bcd1b59679282a2af2b226b5911f94e0a6f9bb9036010d2bc80958afb0c039fddc7cdf6b9449659fb0cc7a8cbbaed0d49fa73aa4d5ac1c944adbb5a86a449775e52cde56ffd0d4fe2ae26e44a53c012c2b8636cc26d11078d315ba107dae04de1bada8c17d40731904889aa2352cbecdb3fef1a66b74a31d7b7bfb4848b997777e9bb788bb6a65811a5a1847c8625f6da9f7ed94ba570fec72a6e7a889124f545a2c7ebe5f2df28d5d9b145c63a98c70cfe20df2a9adff113ff32c6d11aa1b1df90715bcd325f39020b39cde47d8ddf73019f4e397683a4e057eaf10e89a9367dd0553ee176998ec3186ed7023da3857348afefb63a04186f8b08f7472e88b3b6d8ff2d4434d8d0726ec7ef2f0b2d1f143a421801cf74971f1b6814ef76f53597bf3d75867e500f00f85fd6a39fa332024fc11dbf30a28df2cdec6544c4ab7394f7f0b1d36e6e21754b14c0b01aa3356ece50fff1ab8208477204b35cf0f4618c30b12d3817398f04c4446733e0f29d9348c4f87e011826e0475b7dcf80352103230cbf29e1ef81244c5dde081600b2e30172845237f9a9b4008e18c4acedd516d7ea8613cfad018d4caf8b75bd679ebd57070be1e1e9c46504572166d6e1609bc038b8bc8105eb6c234f95dc46285844acc3fbf06783ae5491e9b4fb304fe73354916c5d1885a6909dcfaa5bcb9c8d8e9e80dd202b83dd3c9baea32ef373b83531fa90105879f3806639f548e7a08e2287171f90b909938209eb3318f99423b607fa6e145d7c10869defb1a480aa8c496e09821056a4b687f2a814d8143a0fe167e0656fd556b5eef5e8280c747b9cb593a01d21ddfe55dfa91d748cc6cf294d472131aac3845ba64f32a8aa7d268b60c3d92442cfbfa745a3b09ab2ab921ef957bf6c7954b36347d8136204c27c4ea50e31e730070435737dd99b1fc74b62f9de65114e9eb1d74d5fbab55c0c5f609d6a981ec4ab1c1e25aa181a7200335fda7eb7994bca7d967e157d97cdbf883fa0cf912eaff076830d135ec4e02f5e64b5173de5877099ac937f3d393cb33f5235df7d91ac53e3f13396cb08c014b43d8042209b7544c996f223b5eaa2a15c1845df4243ac36b3962b753118f12199a00905b75b505fc00c067450e5a07aa90149e5fd90f69ede3f91a1367145a3ed9333c873fdde5b23308e41eaddfdb81da9973a4622cda2b20dd052e0018499ada41c8a6549cbc16eaf05d54dc8d40a8b72818a5b05ed242b3d7739aecd99eaf323095006983fb9dc5bba393006f9d0d70ee7a6c43b98c37d00a566c7e9ab9b36e39ce939a8c6b0601c5a62ef0ecb49f2a95ef77bd46719f6a50c65a0826f469601199747e168396b74d60e7feac9875d00139b962b28836c6195d2326b7eb5c2035648e96be8d4a3ea63abf1fd175a9895c9c2bed4260b96a57edb9f90356d84bfa5f16593b738d31e6d7efe5aa3db070ffd94192dd317a89969927df5426d982065b092abcbea3c4a1b350a02983688ef5a93bf9f529e5a48d89a934278fb75b1aa3cc72cf774ee9d0e4853ca360a56f246965841c921db07f5659435c3ae0a022d691310f17bde77fd01cc42091cb716e55fa99c3cf8aae0f805c03814ae186fd7a97a39a63d7d7e90d7ca237fcb428001c1914cbf11ad0b5f37a064f0f97694d849bbd7d54d922262d169a92b23cf166824c39d14c33f3af9e9656275803869a6a6cd646e7d832d93df6b96bc1e26904ab74c5f614fb0392fa5696c08df872f8549d3add69d4c8f84f3b18fdcdd3f2c00ca2d13a9e1d58ea0f351df300afa5cadc40fbd12d7e8e03b5e6b03327dd00467c0ea6c9c6163bfa5093f9ad2a3fe5ef7fe0e7d386847e287152582aef60d69a47e4b3f155e3665f485bd412ed3a2d16addd38212ad64a59705d4a56dccc6eb722fd1a8fcf2817489686d79608220b03dff4886f0f4831709f2993317086c872e7436f88d2b09cf6b12774148be3f5ec1e560a779dd2aa6a724a1a46d435e4bb5ace7f55f0d803c5e3985ffe5c21a47b27e8fc0862727ba17b1903093db21fbfae6812f77f1dccc58e7e5863bb2a3dee50e15c04e6419fd8d4c89d62dd4b2c5f07c1fec5241b96111776bf058667de03d6892e20645b71bdaedfdef665f19b12c7dc23ace152fd01700c94ce2aa10be25dd577123a2e5117da9a51a22ad329c4cbafd963cf4afa55fc3f03bcf9e18a6918d2c25192cd969500b14ba05a398e908aeffffdbff5682908e07d14876d4e25290c639cd47bc34754618648a5722a727eaddafda0791a70f9f1377736bd9bd8f5f466c45ea12b24b3a8e7f5cbf28b0e8d6aabddf7a0fe831da43cb841f21f87c07eee2d7b1ef99c47a166d168be2a8efd18fb0ec5ac60dea38ef7458ebc4c8fd30bb400b23baa5116561ad1c42ff92a7d6d06972d7a2af4fe06ceab076ff1e3c5f136d6ca33e4671626578139feb25b0983d07dacbdcf00224c7a14c21807c6f62328768ca9b459d548328cfa8615da280679160839d38646c496e429fd06744417cb3811593948e4f143e9e8fa2f919647ca7f55339d7ebeb0d10379ff6558244b779c85e4c138029053c1038ebb71f4a77db70abaf0ff5e541e3639b05817ed17c4c83ddb88d3dfc8c857d366a3a68089deb92b8da6a2ec87f6f54518689fe21eb4b02cf18e35910571bbc15dc43fa8f1e629c66197d22884e265a97575dee9dc679461e2491e17e535aebe27f9049e3dd61889bde3d4ca5a2e68825a57c4e60352227753c71e1994fb486224f9133c6d5c79e54addff03ac4da1f8bcf132f7011af84531e09634de884c2864adf6d38f79cdbce058bf9ff64bedd0886b55cf9f3324f8e73c36de76334c9b8414be5dfe8194167728acc2ff546a34d9755ae44d3e77a4060d2c0411521989d073fc088bf9c8798fc294b5d38beb2a104b724fe4b608e26538b760396489451e72801a86bc98a408262cd360c5f60c9ef9067c80d2e8d95ef3238956efe1a9bd0072bb1eaadb715cc5de60d8d7d574ff0d68226a863c429f106996ca48dc964e440018650694ee4d7b21a66a690c5a1efde4eb70b219f6c63b5b4c6813656f2077a0d66bff0052f657abfc852c648baaad53adbd71141a01ce5ca3089c32988cdfcd9e796cd083772144850df780e53b6aee79ff1f9ccc38105d73fca2a00093599a7bb7263288fd19980d05bf4355fe0f18066e16255df575262370061aa0f9efeeb7268cb7ce2256a7de42716c5417cfd0d9570e455de0bda6d7f4ea38a7473a273469c9452f6ef3468083208b5058566f1d158d48a8ddd350ba47cf9f444840774449926bf095a6d70c302ffb93914751d0f0bf157d529b27a9c017c5f31035af8f50e6c215934dbaf2f4cc7418fde43d32d2a9b16ec5a31d86f6277f03b4494a3a3ba4cd56daaac3456e934ad2795bd88d2c48a729ba55c6ebd0a559c3788c5daa54a99f55b2c19da98384bf7b8e6e38f40bf29f18d9fdfacba878228c1f478744e7f002cbf03ae9a32d766752475263cc44390b7db205313f4ba7c2a6e89e7e90b8c116608015e0549698056bd79306d92a7d16817d47203f290fd30c02bdac9b3a8651e8045f07605f2281bd6598c305d21b8059c4ee2c3f46bfe99213d46f15c4502b2a8f13b83303d135f6e93a67347c77072978aabd99b8e851687f15b55189597153931eaf5d5ee40d601786a6a435e6485a24ddcb6cdb6cf192105058ea096f5fb89252aac5f0b2595265b7f54998b24cbebe82066c36ace20cb014e6e0fff0c307c0776e0e4446f4c5e16969f484ca803c962ffd85e28b4c82b73d8a8ef0be939c6e3e3f369b177f19c70871f1c00b1cd8d0ebe3b6673da4fde0f227758f62260c86cd16e108638ae4229fe292a2259496a22c37613bd34c81a5a23718b2e1bbc74d27888c45716f598665fa9bfd104435416c42d28560a24afea071b6b639c04880e873ff25e7eb8e1a19bdb0e33387adc79e2c91a1d6cbe889e7fd63348129b951d44192a790533252f0b6edde1051338303eef1fed0f2de954804a7ec6e0a0d9376841c467ab50ba310ff6c938ab8cb126aef05996b500550bd9d21f122231a0616d4326f9ec44bade1842906dfd8d6a62a168c6a03e7a9206f771530dfd19787d2bb62526067c35895cd21231ee4b1104fb4d1ffbb34a1878ac8aa1b3eabaed3f361d512878f6afd377852313cd608dcfb06c67483206afa63713800940ec03e86f042683900ec8df5ec831914f99f1a71d157e833ec0a7c68b8938662a58bb4eacefa9150d448cbe99bb876dcee12c91c4c37d057c043bded05b0e7c3072e307294d94f426abe50b0c919fc83cd1d04dc99f178e4507920cb0cb20d293a58468248d6ecbde0c4508f497fc7533932b7a6c8647c79bb24e5b2071e29591e215efb73ecee7d8cc3e2fe0bd2b84580cd92774b301322f47b61408e44a2fe9503e9b9781a86327bae96df8e01183bd59e8256638eaee6e412304022e3b3963efdf956e6c0fb45530b8776b7199067f96ae06b2142208a9407c99d9cb7738120ed2fba416ec5ac6d44151f5e9780a024105df5fe564ac30d1e84a4dd7f40c6acfb96de0c581de6ff32f0b5e8fb03ce33a2104d2676e3f2bf4bd6c14229f4cba416e5d7c6e29e5bd56091c8c887d788f0135c6b58bd5fab669b67cfd875dc8b124ec74c9e72f207c969c6506730e26bc23b4e442bae734c6707924daeae415f916e97b987df10bb77cc07666b95da41fb8576c6107f238fb512b1af6d8980df4e4bdb1227783ec873b02d86a8da1b1554a4a3fd861d70dae571d91aa07006bc3105d9917efe1081f5110a152fbc7f50f95417ca7447ddb5a1d89a57d47f6a8daa1e93c19a13529ccd73ebdfd2fbee3874ec2242710064a7e5152a121b6b875cb2f53cfc77c333cfac6b51a604385b2b29658cfdda4db706f2eaa84d96920fe36c84396bbed02b29186b1146fa86b7190b229056f68e3963b0d63492f2a3eae9f886499e8de0f86e99215b56866d7e654224e0030304459cc604e14c73f7c420b73454ac86d04da9e08c0f16e1fd7a8034644d1df1a7654612d4f2946f4757ed1562dfe5cdc03ff5bb465065ab21cd160172c02bbe15fae44ef353b85cbe8e9a108a40ce4e76b4d2ea9dc7577aa5d161404627f9c65692847926db6054035afa8067e2c8b47b171b008adfd5cbef92256ef85fb7d427cd1dd9b6ff988e8dd0a7f8bae3884aca4e02d64ce6177a505f15262aa0e9a40f0c4b63bde494a5494743ff003917a611cdff6c866f23fb262c9829dcc88f09d79f71508d8cae2cb7630a83f34b6a884c4b6df073f22d32e330831c55c250b8596f129d2ed46a1acf22b24adf75730fb33a2bd74f522c3c6d05eaec17c7592be1d0450eb3ee3315b2e4382617725db7b4690275b1fc928e1637c6b59702c797514006b4e50fb0479fb1b569d15cf515dc05e35908e784acb027cba3c4e1b65013b1f78ffd71a4e7d87da2340b56e388209698344994fae45200d089c5fbf01052f56dc62102a281168028eb8d9b91feadf73721456106f9ee8d0e0b1a0d79bd1ba8e4d3818736d06176c2fd17fa8b9687b389575800401ef05e6ba0f6925f55c9c8240c4dac5e09a7d1614a88bab5d847135d813ed1a2c38b1b91f745218d3cf6d1eed6aaca723bf52b195a65789f2c815eff30cecb5d47221913f35f876c28cde40754c4fd85af0fe4e45832958073609bde2ce45b8342930465fa21c18c505ad2b9489406b2c050fa40336e69b4f491ef60d347294efe6e4246c91353350d49d091ce0a6be4d5365a41f8ce67cb1b5c4bd1506432487ee531ccf7be336d06fe3fe8a525170ae08eb12d3360e2c262ae40bea8de87afaad01e716af453e386777870e8c89dc227039e99216f4eae5bf2b05a9a36ee19d2a076087e69d4f02f09381892d97aa633623869c91ff18540d1274b4e8c2c1a0eed195da7300a954eb86cb51752683a01b7a7e504094be13cc2bcca5834af62901b45591026cc7880ce0eb31dd792b5da23ba9567180fb13fbe759084b52c2e15de218ba181069d31fd47a054a8cefff5e771decda36bb2d68ddd44709440e79474788e1f6344ca7f4d091ece65ac5e756bd10c0421095db97037e4ae898ef2fb0149471382dc81606cb10a242c1d8a29497ff1fa603d8ad6343d1eceb2d91e8b04419808f219ba9f34bd2f20ce51b6c679666036e7fcb4a15d7d00df8ef5acb6291d2b8dde187216bc8e65fc1b9c01e4b0b0c12e12fa208ea500fef331866c4bd25af64f7637377bc3310a2179dac7222696b4cb03806f0cc2ce9155433458e70ff9c5c42528256eb21cfb22b126971870def63f657c8771f0186a8ed7b0da1f69036a098e97c4e6edd8933cf3a0fc62d2e6ffc30a5d6a5fb56cc1ed6d7aad4e84b89f15b29c1789d2712128babf8e8da85e1035ddd5b11615e355464afebcb345841f4f30e8a05014a6c817689a95567a69314280b2929ca5f0d3b7aa0dd957914550d33dcbe74de4e2ad78f4338dd2c3ef3d3ab86680ce9f588676dff44481894549b2684f9a7c6854205b244701fb15fcb248cd39d79ab45de5199daf839067e44b5f4a758dbbd68bf33f81d427b2e2c6c3c63c13f78602cbbc11e94fb21092be255952cfc8cf005f2c0347a5b99171f0fea0e87e191306540041bfe50e8df407624fc31eca975f3431b2685fbb8d9217e1ea9f3a16bcdff05e0722ff971d4b53f7d0adb64acff3423e21505da8fdb062559c83aae1f222256313ee4539dbff086b518a6226e8f826460bd0e35109fb24d3282486674260825ea0c640d3274721bda381e16a2e2093d19803fc73058fe7f8e178059e7e91d566fd3eebc01903b74c642dd6ab5b50e374c226374ca64818243834ba98917ecd2351aac788ea6cb60e327fc52b8317f402a519e7286117324693301d80f66491cae520540ae5a193bd19640afc580a288f39882fe5a448fb5ce5a0404e42dc58141146563d243e68d986ba18f83921ca63a49c39be7a7bbedf439aff88f2411c5657706b66c81adfd46c0f75a7ef56ed7c783b068c4fa5cd219f3493516ed377d1036326e38cc297801a3a94c8c7fccc5a3ee35290323ae8fe1e84a51d2931f40e6a71ab34d5d6cdffd458b925f59ae59eef67a2ec59f86626a06d1a9f1aea2c093d6d0943f7655aa007cc5d55c390941bbcca46d9e9c88fc0e020908f5b8161a8111a4e275b55ebbec746c411612608251fbab1f3402c92ee366c601384b45aebf80451b9f9a9adcc3446d731425a9d885952a99f3aed186fb3e6d1fe821f3fa3bee988505894b2c8f0466abbf547ea4faaf7f93ba6e2a5a5112a92b0d5f9c546a586bed2fa0ca6e346aa0ed342185f8552c549ff4b61b38c767c5e7747feb61dd6e540620c8e43a930bed7c4483134fe51d265ef5998b4e35b4cc6ab8a69010747f4146f253f75f71b08a9c80d988ba4661fec9275eb610ab3f3ce0f1fd77113886e7a7ac1979ce9e15bf252dbd115cf3853046c784626b9aeaea79a5b615b1c651c1476eead475bc146dc216c8c650521cbe6becfc35f9823c9a2fec1ba87aac2e88c4206375011134cb81bb16f48abee1cc27a01f7728cd884f19afcd69a6d4c96fa35a07e6314bac51ddbcf18f7ce0be7cda7cb6714a702aa6ce78b0b6231eab6b81e9940997ae07b5745adf2930c44cbdf21ce30a7fee0becef174fb7044bccd4e8485c02035435b973e39514285e4572c9c7487ebf98c9c6902ccde21526b85abcd9f4024e486b4562f1265aed8d464d562096ea757bbfeb930ae732acd02ff21b252d7147f272757e0249e60bcc9f1300e9ad40d151b8630df19da2eba78bf6c0bfe58299e49155f13559790eab08bb0376da57bf4db1ca60f8efd7091c124325cec3d7a3f08c90b76925929328e7e646995dbdb93d71f149564b2ef77d7818719b99669b400ef8aa5f6df726d7ed636613aa2d861b4e5fb143d13e5f619f0c10bfa1b992713c6daa6432876bdea13ad487c12665dbf65a315ed1454708e5e07f7053d4bd8c257fb02c54cd0f03290b4b7d5b888125d0afe8ea38db42b862b135bb3b5a07e9620e8ef869f88751e724f96063c2298de701a0fbaf867ea35ca7b4c4c7908200e4751085120c1883c37780d84aa678a4b74641efbecabe8357e683324d06428e642b46080b88738273dbeaba6c91fa999fda88bf3aabbb3dfb377e8a2824d1fb06d56384bdf0f41ceb64531b8cd7bffea1c4c00c7c5efee5b92d542a4d4729e8e7c1c770886ab3436ce36d450dabf6798189f68edf9847a76359e268cc1129e335d5c75bf72b0f974019ca5a8c06b75a221f530ade8e45ce4ce59e7e36143e16a12121e2dd103a63d1da3ec5ea7fb326cbfd62504a8a743b900267e6855d7beb9ea03944d99c8ff93c237e3b42c50fa22a986e08a3e133c834ac5d19ac6b740d4a4662953c3721fe5f13a1145f774b9d8d9614679d53e648063230e790bf11d7f01b5bbb83669df9b0897e08792c2c08498bb2a223a908055d577042af80e4dd1cbd9e96057058809c444dbfc3509d26fb4a1195935fe2855413aeeff9fa46308b943973eeab078178086869e3865049fa4ca22256a2abd9a75421077481cd16d7de3797c1b9f59944b856ab0ae37b0e805738cda99a8767a4aa946ee5621fcc86e2d3d69b83cd65714da848428e017c75c4869a080400b12c677c9bf927b2afda9472adce6a04b9244ebd6ce8488c47ce61a1ccb51ee282afa72c739e39ba8d4b77db716e85f39ecf2bd3f6447b59bfaad27bdf886270c331a65391e50ad2f4a4f053df6db6b7d88b390f130aa27598260c25d5a203a0ebce5475b0d2a576211bde3b7f4f92c4727182320b5dfe1d131211bae9c5dd4d200219dce9649286ca9695fe2f28378b746d7dde7efc4c02cce23f98f9359d8b7153c3cadf15b8f6ed04d2e96dd6af307fd3545bb3b2981d6e1fa5ec9fda777aac0ea81c71e346e06bb939ea69b9c909b5bbba7462cc3981c70a6f16ace4e905217f4deeee8e4f883608b317f135f2f21c46c10f2036425fdc70ac8cffe949fe728f7f8db26c38ced547ee20f12fa25efe5f64ccc8b4c538ad520a3210087467d6ed8cac1e86739e6a7d5fa56eba4dccb6dc5f32e2a16faed899bc37a540d77f139bc394d62587385c9b1287a328ac87f6ce8b3374bfb8fa4fb339fc53cbcbfd1bf0c25491cf08b5bc9628c999bdd8daca13375c60373de20a0cf99f5bced96439b843d4a68e2961b59ce793a196e6e0da49bc53f54b6ac51abf7c992f6d1f346f269269ef4ffc01d464e8de841849cd1544a43d53edc2c9850d8cdd18b1766cbdd41d89b54a0a2725ee524ada969f9828ad52771c9f0a384b7b535cd0f6c94abba42dd4b136df4ded517061d2e1d29e59893e621a28b73b41bff23ad20621b8c79db340a35edeac21c89a90636207af0367b3538c22ee45e7631ef3d2fd3306a4448ddb05036eb49249e102903d20454852e4910dd291fad014b18b48a98494007169eded45705554631614bb82ab422d4a4981dccc3e28189e1b28a9d6c514bbe50d002ccad2083fe0e019e4dca6053e2dbf74d338545a2a26b8b8bb8b8d96486819f72cf0e2da190926c826cc1be395893b20ac332053a788a397a2fa46a066926a882d440e44a963bfe88435cdaa01022e390a45648685ad0915e66adb90bc3d01d364c90a88e3be3747c9d6064a6cf442dab3820baac5b4ede1eeb38a8ebdf0c1807925698da5b502c38b2b95fabed4637ceb148c75047437605e1db5ec30016cecc250dbc42bb2f27940c790f4bf634a0cc97115fcc4045e995fed541eed316d33c05eb6af3754b95f354926660e14c1c2a399383961214d7050a41dc322db9a2f95850a3ccdf79030e40ba62b8725fb00d0fdb9fef5eac3ccc849c8e3bd135ce3973753d066c6b38e02eb135d38b987b9e114b08d7aebc0e326d9c7b353eeb060df6f778984b05f1678bcae76a733169e4f09a04759f4c7d77f7a78da878cfa037056972fd861fe066ada74a3cce5e734862ebf03cdf10e7acb654d530e3b0d858f488b8c19dde62e2faf28173c2abf52ded24213f3ca0dc7c72cd50c3861649b924d84f8a2c2d8acd2c9ee85e1816bbae18cfc3a7f1d05e12b6eb9f49ed3dba328094ad3caa7eda0315dcbe46e63b5e8659d0b723469cd74ecb75b8f1805639d098f641af5702c15cd2bd779fe99742b1858a9a1bad82ef6ba6dbb9304ce43b93e366b1ad8ee5f4d571c081a8b5a3396ddf7b21d73585fa27572da85d4d412f89494a1f79be458b89a1f7ed214040459b4be511f58519f25a60e43d55f225fde990ade1dd739b86fd7ffa0aece8627646737d71d52ab6478167bcf0e995cf36dbfba24adcf557a88e8cd33f2206e764fd6808b879b078165f251d7ed67034b7d929805d8a1b0ed2178a7324ea158c1f20d950e0d77fb9a75416971117312d1a966cf51681b331d48d6225427b03b1c18525160f532258d6c75189ac8c5a2bccf98c269b58219f562cd252463e58e37766fa7d3a26a5f994cc88128769d39f44a234dce5a2a2e753fa8ee5b201f71c0fe7e74bb1115fff61fcd129454d26925f3b65e4716584692609b11223ac2a7f63ee4832742d161439d930731a0468b187c3360753657da38be7d0a8b735dbebda68ae4aaf4c2eff62db90e6190b0564a6c6cd60bb6b9c85b0f4a2e3669eaf5d35a702c35b885b2d4e11cd247b36af0f99ab0752e2551de508439254402cc2a1990b4eb1aa431c1da672c0a8df79a11ddeae1431978d95b3920581cffd136d93a9868c096e3289f7c7e41720d43634d5cdac9ff877af141c60d7c1595df3ca4802f7b7f03ae889503fa41812db0c978b09b1632f9dc78b6afe3c91ed5b718b70f7450217a001c82b34f5534b0edf1b2df46d785a20c8354afbf23bb9f2c6e3adf9b259b0da5e37623e3596204af2e33d9a3617e37630dbde733dded699ec599ad2d32dc64ce252008eb9ca549693106569bd8971532dbcfbbff038054323323de29e77a9073b71fbb7b100acdaa2201fdd5efdf7d077e041bd0574b43db83c5449192f5f4fbfd9ed82223f14b5085bc97a8a753484a2637f8eca2edd12fc1e9c0974042db60032bc7405fb8db58b784a1559493c677c4fcf6a8da6ad98ab607d330ee2faae848bd67a68328f7dfab613f53cab907f9baeccde03619825dd27b2530fb82e38bbe0404090972327b9f24d2c536b5cc40720e4b0ac7ad01f509f141123378ac3f0add776c1da4a7c6e0babfd4dd75966c0edb231d68cd215ac892d2d68f125e4645b9ea40405918ee02519c7be1fff9984cfcb38f25fd4da894ffe12fdb4e798b95dc246162606ba55c356f2e3a5ad9e3cc94ce06b52bc573d5c79ddf79cc9907b7ca1a26d231a19519ff72dfae8676e27ec7f6a3a0361f86fa146a2df1f2d750a71924abd5967d962b49a2e92aa844132413eab15f9f9807e174bdb5ade27a011d03f1ca06c52c74bb0737c84867a0c1aa2da891a490026bc8729c6c4da75004516235a8d7d50a4448d93205a85c1cc5356a34ed2dfb92490ea1579e208c9b4489c654bbe4082ef5bbb1f3e9706b43247691f0514e9ac5db08639145d4cf2d63f776fb0bcfab042859cb23f247b28c469ba7a8a482178a52e5f0d04ffc089395f0d24bcacd3afb00fac6e3dcea8d291766bc129a019dd0c23a7b7131f26c032b3bd5e73f7d03da84f1eac7ce6354ac057a6064a16d451a6f0916b96d98624e32ca95e3760f395ee7382d9c5abc76b56e2d4e4b0293726aff0dfa502ddb0035a302b1bbeb536d04c85afa032cb279c637c726af8425b97cf9ee7c755f4f90e759c7cd133b37dfee604b0587ecfc4aedc8d561fb425317c8505fc0c35996db0c404f7502545cb137282aad8e326c6974361675d54914f4a47ad84b37640950e5f1d4ecd022559fad963034f6ac527cee3fbd5ffac6e4efe037d4a58107f8a714055e0e3d9a62b0b8c1d982e803b8dc916763db055d6173dbb856bee11a6f8893555239df3f1c23921ee069e4180bdd8079d92dc5accae67b1bfb998749db962dc10c1f273ba8cb5f598e9cf7a84ed38209bd55ac5504de8d4d005fb1fdb3c046c80ee926c3abffa1002c8c51891e8fe5d5517dab44a7dfb96bb1f696c75d4af00bb74a30535e1eed9289696720b4969864f8e1d4d88d21287f094a74b69987653e37a3e1563b32c413b6b0bcaed6a634d0dac392671d3d433b2069af1a9f720c0206d9d21d6b51e22752d73f26cb73df8712ea2cb574d7ab7e85d25b9449f7fdbfd9323c113ad3ef9134d3a4204e1fb7e064f80dd8ab828703eb4098564615f1464823332e8d8d09a3a124b7c6ee31ef42b0249ddc0334721efabe5575d33dc1bc82700b443ec288c609fce930ff8370ba4db8d99978ba6d2b0dbd38cf2dca8f2eee206bcd5b28fe39f255216258571180fae983be9a2d9e90907b8e02d739ca4cd86f2f17369fb4ce94fa18779aac1c410bba4f611df7629fb828f51841a89a686b967920539bea44c1e0b0a86354eedd5df9d921b7edd1926274bd9e7c5b45d2d61941bf30653441eca283d7e27e80ac1e978de691c3c2a3e9a284d980584dd8d6963290c9ac0f882b5d15dc0106080b84a134fbfe2342282b29ba64763c56c65e6bff2189f26d3774bba731878b10b21f7e7d57af5e75c6cf630452725054ec826f5978cf1b9fe5c843766c75ddb65e8181f33c6326939f412ecc701ad166b0effd8690300e97de33b11f59c961953ac8bebe4fd7c88806126faec91fac0e30d3e0877a56e92435ca161b71b22eec98e273e0f0417a49f60a04ed9839b30a1701c96f096a0560a00987c879e3ecf4b1b3a775341c213726a33790bcb506957e2465cfb7e42d77466e15e7ed9ec28e0b76ecbbdafcc5224608e2a411cac348ccc9df65a3a698a382ed8810afe322d42caaae8839c5a4e45680a2fbc8aea071bb16a0d732094c9f5aa73fa6343dfcf09f045bbcf849dacd44609a3337e2cf90de853763e52c55320ba85849a404e4f75f4c6ce9a9f09f4fcec76299ba2244e17fb0563a2e2d18904fec86a13f770c1bbc4fa45bf0b5a6bfa4b05649c43970ab47559de2e9e251b4263e163e2c7ee0bef3e288959be114e3dfbaf0730d898820d481ae3c1216df1310d6a447f4989c988b2a368cf7aa7cb7bf988c5aa0c13d7a8a899368cdfeae230007e5ac3b8f28f4ce248698ff094da37cf8aee3ec9aadccee0867fd28ec34cc8a08863d175f7ef776d59670ac963a20bf6c8f25495db2c4f70d411cc7c9d6abb1b6bfade4768f58f11abc916826ca6db7482e9488d845b1fa11d54e9159cc29b705bf811853b2fd6543c6198f07f9ffff5f99d7fa73762f4aacdf71ce30cd61dbb3d970148afbf55ef80bc15f868e82d51aabca6fbf71bd356dd3fc88b3016e13a27e773c03b1c6432f4bbb4f3ed7cbe32ad34156912d24578ba4f9d21ed6119951d81699f96c6a39094d217b0768d8068384635f9de5ffaf30aa996c684696d5ef6a51acb67eaf2dd4de2f625aa7eeb34ae00a0532d712fd080e954317785b8394c9c8ebb0cbd1af0f1c65afa209ebec47eb86de6bacb8884f2828c332d3fd7cc9d334585ba86ba73e2f77f373d4647fb5baf6e53f7a79cdb760bbd54759f4ac4646a57f1c57ad54d646a54971d4bba72fd78d67e9a4f6a4cf523efb5a953c0bc7c8df32b1d63366835dd560b502589a34595959e66a7cbfe1c5958167739090279b8905cc3a2d6e3dc1b38ee8934d1757e7e61bdda304516788bc06c94c82db699c0bc5be03c7a5df1852ee2ebab8efbf8fd821cccc8dbe144e7115f5c2d114fdd2427eb7f2e8be30cd5dc0b7029021371200ae25eb9e9253c1b5458e133cf5a08d0ca609786f4366e43a37cc9946e40fd096abbd186330eace67cab38ac9aebb1616dcedb4a87457fa470e9ae8615fb6514b0a4e32212ad256f13528033b9563b3b71bfd3e6c0e757cfb12d362675933efe007822d20387c2d888e1970a3cb97dc903d6d4886a33b6b0fc341453dfb5ee3b0fa30255607ac7bd14290f38f797029dd45246a3d5d0ac390b197a4574d38853bf10b751650863c2a339409e82986f7395808405af106b0c6ae3d72cab26f7192b0dde86c7fcc503caf70ce8626988bbd19249966da3735ba60bcbc0dc8094c69ceb4a961f0a710560d3b7659185b9937fe9cda8a38981b15f7fda6a8fa3b43cc713afbff7060c193219b2c7abde9ac99590e2cb7461281b470a0242ca706c44d92724a66a4cf8bb05cc4a13bf0ceeab3b5be32335a084c37ecd2ca08faeece371ec5a7e254cb0e56b9ccab76f8533fe541a54d0edfe59e31cb7a9a5ab4e508296a83b1adba62c7bd367d10e4a09b0e9443c3bca6c28e53757ad536d52ad6cf30e32774074a20d570ca88037b4f0b198f6f21ad3f7f3fd80e84117cc4d7b8f6c92269c005b0b0d0e0e80ea3642012aff75e502403ed5bcefc0a2de7c7e38af89e0b16449c7273c87571e2fa88e6bf09e8d0f884b8fb470c05547edad8ad0f6d28881d0060c441be63b47cca0e5f7233c4db00dd7008cd2935c1986c98e49b406e00d938cb04c9d57650a5ded95a8cff4c94d8de9c612c5c0dcf22e9935b12cc3eebe3ec446203af541190239303e5ff2128429e55bde256f3a2d4ee63f5e7b0d6f541389f5dc8506d5ab510bd204666c28d47294fd4fbda988b19021bc5f2355690085439932c8280a01f7f0cdf50be06443b710a939f8af56e0593cc8d3321d3da3076f819f96abd850b0e971986227e164871dd3610c15d6676c892ecc84d9aeb7ca700ca89dafc967be906e0ec40d4d59cf271af17e59401fbbdf22190639e582886034e8b77a77776f42ad02363431a02d66a08df1638466b28eb230839d3c9723f890ad63a0a29110b7aac1c78f629943426082d2c671da5fe7cc09c7bebeaf50b562c53ebd29922d4d60beb356a47da1e04fd33371bc18372600bb254650d087fea903175a213dbf240b9bbe7c3c1285fcc5ca9af7bb5c2f40b6f6301090016fdd8bfc2b9649bfc1c8ab61f0637bcd823006c28b21b91081b3abac4d9093cdba729fad84f47d4bf67220f445a3f700d4c1531188ad8107d4f78279de39f50f2a65c21f23d5dff421e9eb03dffa49767c2ec8ff3da963410892312770890c49f084332b8784d9d8eecf5d277157f27cafa95b0ba454b98c9adebe92b8c6d74bca49a3a76e6d899b2ea798bca9860121bc8effea20d8c6e432d6e690b7b7833ccf2442d06e78169805f7ecd67fcc4a48fcf752816e31cb55ab2c0dd4867386da9386adc3468e56ef0fc6a9e560fd7dcdcfa5c2f662a1a6b9713cd28321c08e7563ac2c71a045d702bb15a39b4a6fa53009924c42c90818a4ab03d5d2ea32168b9b8b207cd1afab101fbfcdccceb5bc870fb70cf573fefdfb45b349c8b1ee8f1af2ab0a634f4e51743fe1f5e41e04184d767a1334356165bac342dc660e7c1aab343915e8513673fd6a53e6d606ec02ded6d929d8826168221efd77c16a78879c0b60b60ce9268e0dc558f7823a3917b7eef072c1566c22a9f1ea27e2844656df0003ea2d084788fd052ab2d481383d8d95bbb5a1e7df8d184e255be6f79f77a154cd664571230760f3ea5f7d7f60de4514e76061c06b022da341799852eb8c3b62b25b0f540483af855ffc4705d72ae555ca1a9d0247cd6095960a0b0bc50f1fa813cb6457716c7f7f20f42454ba7e077fe867306298e8a282bc068329e180b9b8b7f34368df6cc325cd9221b3c0456fe3c81806f189b4fdd41ad6426705fb72b88d9b7b3deebfd713937da946b3d198b7477a06fb407eee7047c86ce173b0e43e26e560adc44d8351139966c71bade1c74ea5efe25d26a5a8f8d08d6d9cba926b84f0d67018f7aa09cd7bbfd565247be5549a1b0d09d696508e3105f32ae9ce73631c2543e61026e3e333c239f50c483a6ee517e7889d2007ad02dff60fe8f40b2c06ca1cca51dc942ae89fa3dc00a46dcc76aae91edee85ab7ac640a64d4ac085bfecd0569ba68c28c31c0111622a2a933028801f9bd95fa1c3f3eb649c0d7cc73941d6920fb276592b2f77de3dc2dd8612851f066ded0b9ec12be3893cd5929c8fb7404926261b9dcfbce1c7139b6348cb8eba3a107c6eb79d17fbfd36d0700b795bda35df8761b05caccd11d85d5a650a03452809e5628b1f1228ea32b48e517fe91a430ddc61221b93dfb005feccbd4fdd913ef8b67e286e2f10cd6e3ba27f8c615b3075517201e774d08afd3d802e40586e7476c5a9949abf5889c821d2a3b0fc94bd70d879635079e416cf870ea355a1daab35f7a9e44db385d10aad39c22051a31f866d635ffb192ff3f3be8a95249b151fe4d8464c349a30f0abc918e17efd27eda54a2f560c6edd9ec8c83eda10f18c7d37c8653249cb4c210ac8758cb9576b4ef365d06ec82b03895c6144299bf82b06f582891956ba13b6b45831d00bad7c2c7921a3f6b318b6d2d97c0ae3b5ac7693b8ae762275b7dcdd842c2160354624a4741d85d348e0132cce79ef505ff859494a3077eab530264347cf464b709020e2cbdfe57850a9d15e77935d098f14575b00486caa52feebd965b4a387c73308fe18dac2bf2e146d34221beffabbff55f5e5b6e8ff757500e5d164c1354e2dfb3e576fa1d99e6cdf4e28a351db432f539d2ec68e9f3dcf2ea268762514b1c62994dd58deed0d2e658b95f4b33a1bc7e12a696a35c7fb3d5ec8d0e6d03969621ba38dfe275593c58d8547a5c0e9dac81f58676da60b891a75fcead06918c56b0ef508c437ecca34af67b6e68a29d3098545ef13fc40966e02209496bd8cfe2c2f1853dda2fe76e6327bb52d1a9f1df9b4fa70dcac5dc0c16a333aa36b750fee7e2edf979900e0d83fb10215e004e333b3d274f6e7939976eacfc40125e9b02e89b838a4e026b2700b8a60b8ea85d97c9de62ef82e55ba3c0d09ab24f21e1e16f9b2caa888da21851f98e9fece1c9f18ad7fed7637b0c0d52f2f034f82f9160315027075a2cc469d029d00ab498028a8d2fb23a5943c81eef8a5fe70261aa687325088f71d1818d4c0a24a08920668db7ce90759d8d6998eb02a92f4a3b3e6cb3402b0858014d9210a4a1f69ce96a5d32c9068b987181dce97741860f47ad48bda0e7a863654ad2881d73eaccf4f2c430b6314404c94ea0d055ec5d3d895044d8dbdb7b4f8ba58cde9a695859c44d81e6c741758515b64bc172013e32bac5b741e2980ac50ea85ddf68fe862d5647dcb02feb74ab1b8a7ba689b69ec4d19597da1a9a08bbe955eddfbde2b02aa99820e2e1b02c9f62a440c5c1fdc8af40293d2125625a6781c326b30b66eaa14418eb4f45f1701d32d349bc316c152f6df59ed354c6889434078e7de624d6dddd30f1ce69c1574dac4d6688744be1d82ceca3e8bd320b9656426d16e75fea67882c05abf7412e95141cf58f90d305521f99ee25c199267e64e9a337213564130a1da9095712e887476897294e1a824ea1863163a6988c5737b626393c937599055fa113e5d91ad26b598699a21eb45a0b2ff55e201343a9b3a9021da52febed0df22e5d806a1b4ccbac684fd72d9e653bbba7c272b960056f91721aa001e74ff8a16b83a4ffa6bada9d99a5ef7c625a58e211b687d0a8ee27117f9e452237f33c5810564f16b0f17d35b159ec5e731114cf9bf92699602932ad5d73594fd06c8d28d1c157fac7c5b38e22cae384924ba68a827cc7ece226f043827daaea98d910eb83057f3233be84a50205510f869d6982554659c3bf65b03d3f2fe2718904fce7023f1c084e923aca7ba294dbb80274a40dfb0f624770990067f29f3715404dfffbade16fd4d9a1503bd10eeeeb15b72840a9816f0b40a55dd3b2c274959f61695d20b6cf9e9348de5e5c6c97d7d6990f46dc7045799969873818703f7b9836754a85e615ebd2151e28a4a8360167813bd1fbe5b7bf684039ae165fd88f59c2bd102edee059040777e5cf06c4ae62b6f9094752215a5f996b2faa658b12ac87d90b73bb731dc6eacb5376ea259c9ac7a22eb6469e681c2689072d76e9bab13c1642b18d8a501b8f0fc2711654bf9742b9b4bc4e20a0963c19334328a40ea364e245ad2b988d04fdca2a00beeeac9ec90a4737311490ea0da60d81536c13ba7e45dc1dd166e8f145bcaf59070b4167d4c23111021fe65a15417d39105de8294899e5d7803f52d5bfe65013129c55ac402d8f1d0f9f659ad2485e939d6e5b5232a83cf0c02ea490492361cf1be3598f349461253c0ae155e98286384e49e68b15582e9cd7cce60883088ebbe17f4240feef707731f3288729d12712a6b5a9193b7d20086d8375de9f36d81865f641203e870856d83bcf9f85a75fbca2de9d3886735828d8ad55381d8b77f50dde20bf53588f510be0a850d79f338a1071b0b8d407e067c7195f4d5ed83ad3390bbcf61313e4d2fc48d258de9f6fc0caa42a5e34a4a779e21be3594d12df494d1f09c6462e9553ee64d2dad61a05cff5e324985c997e21bee0cf5ff788cacc8d9e1f4f3de791cddfa8e0e93e2518420d1e1e58c8220eebf915c2a2de0d89820bdee3ae2768c4a9080237b83fd7b7d80d079f3836a1afade4ac2cce047d01c91c5fd6157616b9d9dd7a4081dbe22203c6d9e6878a22ab64c1409b862147c1f00c4c3cd830ba9fa3d52ef010f3f28869ff899a974d0b2c047fb4fc505e70211057b16b113ac3dfc4d7b64b7524b4daaec8484ae63a03d3dcd3f1ccb3b6df3d2f3f53878d8d9004c9fd5548b33b9035dffbba1fefc543361c4d6ee7a8fc65a96f15c77189bc73fdfcfa36082d93b8a8d5ad630d42b9a62cd6d994feacce35c04c6a402f5aa2f189e73cf1072501489c7c748abc374fb3078a356677d9e20350f8e4c2f8319e8b47d16fb2c5a8a26d1495bff8b3392a64fdb61afad3e2578cb68b2cd6a1155edf259ae6afbc5ae7f4a5ae6359a462ef7610005664426a38ee5ce51ac94e63993396c90e7ae687c71185f61107d1546963c5e23f71d672b5aaeb6ecfd7dd8a4d29710ae6a1278b715976c4e60f1fe317c7b5c762ce402beec3cb64f53f347cf9288270a861ced9712eba04d47f10c2db380575f9de5b694786c13f5348781ef4302891731fd60ed050754b0d989ae4c1766144d5489e6f54ea871893ce1acaebc1c37b0306f955f62542541138f7f5537f565e10c5071c83f1df760967058ad3884509f6e2aefceaba9947fe55f30d41add3447b6576c4088cf9251687a4c1de62cc410da3e9345da65b347472c60af6e2768d88fa78c0c833cdf15ff51e39b0364f1aee6187c3216b30cb871619300cc069c013e77cdc689386daa83f2fe9494eec9ebec4d1f93d6b7b7a211d6a21336ef9a4cdc179c240fd04fb7dbce618aa7007697c101ce28ffc330d2e6f1c54fa4a8e6e869b8fd79f19ccdbac1815264f374cd36ba9575e3224e8ee4dbc9a9ceced538a9998d800e70486111107a8a89bb5108e0e96c7bccdf424dadc20d3f5d8624ac862df44106fe8a613da9cb8663985f5252ef3558499445fb18988ab08d8bf8454928efe6bcf90e503338ce89cfe3f4758180bde3378405ef1f99e29c7031ccf9917e742e60f1868b2161334c1e43550ef9706242a3ee0a9e8a09d5167bd7d92d9e79447262be67c7085b9dcd723b6bcbca0040c86a522095c0e4da545a2d91bde987051122d089813fcf18503d61f7324608452b97fc4ae50ddbcefef6dfb5584620a03429c213e67c706ebe5b2dab10e0609adcc9aa1cb579727e5f984e2d152b17ae24edd4d109fc1513d8cc878a6502fa0ec4d288eb6c97ddebbb2c7e827b4aa76ff0fddc9b2ee84ed6fa5d48afa7f38d81b4d675e3d10893c84889c856ffd52fc37088fe88798e91211031303b7cd83c73e4c440c5dcf71b51d8da3866acd9fa5398e13bbecbdf4148d0116a7f14727d71798a9ed549fe18a60e62489b1f2e96dd338b75af0af1acbf223d9b9dc39af489c8e50014d78ff5716077fba996a17546e238288483e24a7ec0c6b847c396b0b55d49dc59f14332326dca166de4b01aa85080ce06d2ae02491e369fa4cac3d2855e24b40c21389927ce2f6bc5d5c62e7e8d02161c3e54774b9dc2680c9506f609e2dceb73a75ea820db257420d2ee69639771d9b7550243fc4c57e0a8355759a43796590e78a207f17c427d09c4af7a42dd5d82fb92ac1e6d56cb1850ff581a0e6a5ec25e6299a405edcff3a275ebaada2a61f54010334e461e277f888f19048418f8dd7a459fa5d676c9c26b70963ce81cccaa90de10432bc6167a1ea5f86380a4eef2b0864a20cbbdcec7c0b362cb5e624881d104ae21a93b1910c82ae1046b6ff559fa7bed81d66f78594287e4993864241f37e9f38ad8d4d61586e00c2d5e01ed2a53f92ede025fc681029b6bab3dd8bca6104debe0f4014810ababc1c1b00c9a675588e8d397b580d6ddc65b3edeeb4f5ebe043558278f4db7eed3513909f188618e2ca7ef5afaaa7a9ae2af47348fc96b9306e8fca3ae3e1e2c53af3f4aa9bf133f870aac9784ed95717a401d1020087bb94c339f2919ee9b565a480525df1b984bb732c3552900e0cf538e6ae89079d890bc63ccdbaf25fe1dd6ab8ae1cc1d2f454ba744ad7d3274a296e50954aa2540f7f40912926cd8df494c94210404778a7df739a5e7f1de8d920810bc29d35dafc685a1dcceadb3dfd39223bf2d3ce2f762380c933715b9f6eb37f69710a0ad223c7dc42aaca8683122e131d2c7ce3d1c4d04497d5672ef6d4ebfe299dbf3244c16e276c70f9fd5a88151aa81058c42e1ebb6846a06bc57da1e0ca5ea03b1bc1a877443d6324ebada7ad90500444343da55e174cc9446d65164298c397ef46e4a685ad8c6439da6fe697da1d12431fb8fbf8dee4e75949d569a88e9ad4924e657c81df4d9a17bf2c3642790ad559c7f0b04ea3f029ee7eb0e4baa865cb21c1420682ce7bbc102385c4904764426cfa02f8c376bac4166c58b451c498f530792a85bf5fdd57833bda4bb2f88b335baeade710b844c58efc46bb32787cd208621f752b32a00ed5fcbc2da1b203407f88392259198bb47602f82dde580b9d33d16cf4a07d50f6adbe51209f81f035bf17dc516670e98e079d4b8c04a2faf13e4a6d361b1b65e3bfcf4957c76c666853f7ce1f7cb5432e9e77416ffbb0fbd00b1a1d92ff5c97834d3f45447dcafa2620be16bc1a22989e6cb15acd82d51d9fe27ebdd71d10c1b30bdbf9570205d21c54bda0469f7dbb9872202f1097be0fb6bf225d27d06bd74a2fb74ddce82960484cb5051e5cd0a125d8bb05525ae42aecbfc0be85f75afe3405f004df04a50ea2b710bfbafb6992a0eb3036bbb7aefee08d92fe101e43aaaddb02f128f63bbaa867d58e1a2b3ccf6df01613d4fa57906332828ab6094b35f3ef94819f7d68030d3c15b654d4cbb0569041d364e70b1bc44000a3a154bd56d3ca9cc51fb51bae7b9e040cdf7a1d2ac80f14defa339372cea2cc345932fca26614fb7dd9e84deb4360c4a06f22c7cfc6015da9b506d7750928c5771a2ea165d81eee2a71e85e9ccca917b6000a2b9f33fdfa2fbce0f900b44c8751de47660e302cb2f1c04206d13d7878a1c4e7f3ecbc6f188d441b10375e40b537b2f8d6387b93ecd3787364ea6902cfc858acac87ccf32fc57cbd246af26d3f6302b221548f01b423e8e10afa544b93e7d2384d333aa0cc46e412b0a26e9acd74e2cc4e9eeeb2777920d97e58550582ccb975b39abac6b3ae790d61e36ac55b3296109a54287319773905f5732089cf73a8da52e928ea7a49d8f2861d527abdc38bab7a02390cc1da7d7164e3850b08b5a65d757052009b918b5a5f806c85b1e945e3dd56bb2427fe21c36890b2ec5a2ca5742e9c15a888a69a00e11448af0ecb543787879140a2df1c2d64a3604f03ed645deb7715400b1c8dbe39ee0c830d9f0470dd26dbf5ad8df82b40511a96dc009542df8dcd662676b080abda1d73ace73618e32733cfc2a79033892969296a99260be826e38b07c7342cc906ac742ffa22abbfdc6cb62261ba9f6c04d3cab965a25ad3c6237137cbc88978452947795ff1e9a180fd4b858977edb6a1afe2742f475ef2764ead0c975a0ace01eeb853b9a0b472381c18c344c75058a5200eedf8908b00b3a184453b68bc5c1cb5a8f52a797ccd161dad2b05472ba67f9e842012527d15f328d9cfa8bd5529091a5be378e1b79dd929f001af6c4301ccd4c050ecd37c2c467c292f631593f3c711840cdd59ae94c8a02f3a42aae1fad654e9a813ece6b443b4c766880296aec3cd213a5e928657355b788a7c0d5c36fb487589c562827d4703336154ce0061be6d5f1c56c4efaf9f5b01473e39538b033eebc70669f52befeebc49e75642790f1fca3e63f8811f20996e615d1db8d5e0259b2e11387fa9aedbf4377a98a3b3813bf8f6f9a5ef604f59b64e0b8fa97658645342168761f85bc21e7002fd1811c0115ee894e28cc9184491e7257cbe6b80e7231790f1e9659b4cbcb107f172bcf39218b8185ecd34efd0f7d2608e0f36c611dfba1e341eed578cc5cb8b46d9e5de4a7e5e0f92befe4ff23edac13169aee37648d8af053b5436eaaec61e730efd1dfc8dc01dfe5f90fafe2a91877f2fc0bf0f7c452cbb74bd4721024291dc215d4cfecd0c1668362e8ed097f1bb8c10dc6e2fb779355f7681799ea42f26d2696bea0f514fb268d60ec4187a82c7c9c49dc9d4122eee73c8ab3ac545e0d3a898a47d46256403048e389591c8ddc11a5e2e573138d5c5b862f8eaa91acd63b9bdada64b12ac57f2c86faedeb0cf1037619c8477f0366e1812852eaacc8a78728543b63af37fe3e24a5e5d26fb5b478cb832bdeea7aea79f0da8cbefff2895ade636cb9bf61fcc733bb55edab456579290f0adcb5b50dda07d74fc3ad7da3f8236944abf0ebc81442afb3b13e5231b79e558ab04ac05588e09e3302919376741eca146942db16b5e7b7151db7718066bf071c02bb23768b9d53a8d8961520982c7864fca03106795b36fcdbe62b7ba23ee9c40493f60bea3acaaeffcf41276aadef6882b0d6c4ddd43d03b67564db1c8e7aca3466bf874396417fe90c57a92835a6badd3d5392150b8be594d5721fca3f59933f59c571e0d7f9c9c3efbf67256e311c74fa3e34bb38bcb5d17c8d5e66b32b33923716a947fe2a70b7d544f1ccc010ccf27d9138525545478d719e80d4dd58b95f506f3f6ae1d91fb9d97600df98abd6fcaf6cda9ecd65f3617dd1639904aaaf1d831be01622968562eaff928e9f3ba61ce4e5346688d1ab04036e55be8e78716fae5ba582d643fff16681858365518a2234f5b2ed6b27ef472422563bf2c2d11f21739174012d30a083c7c41a1bec1d11297620f52f62b7674b339dd13b8aa2824bd6406d169aa931eaf2b58cda7fedd1b50cb2d0118c4d14b92ea10990865d14c0186249eb0a16bf8800de482a274652094eb784d576d97d2dac382712c5cd328287479a88060e6cad68b8a4241a47fa46a37378b11ec9af59654a0de11c6032decaaf08c5de70e6872c3d5f82a9ff2ecfb9c76b88606464fe60fd8f7d7ed65de57a7889b346aa54046dc88353d22e37680cb22cf508edccda3c4473e3004f14003e5b60c10b356661ded04b770e6ab36aa305072ea785940d5c8fd4c911619507b93c4e3a4b04a86e425bb28d8abac547c37e8285f3bd77cc09c317f091641ac16ef224e9ddd5b8e4cbc81483ed6d88cfae155b9abdf3d3bf1bef1842c9086ec3ddbe671da5caec74a4cf315ca11a52499b332f4628913c8477aaf5595c702aac6cad388657d1c00800abc88ebc95ec2c9666ab2dd2545cc0ff4a4406e89cc4fc26488ff86197331dc7979774a034d1badf7bd852eb773e80f895c76be2fa989d2b63f54302853be125296f242a35dba0b49782f38ae5fa05b8c577228f2fdc205969553c0c8217693068a9df92b19f6976215d532ce8f7721b0f6fa3c863a31f814e143ea55c0f7505b6aefbb3d7d3c59f021a6373bc1bdd549ce89803eef73c1d989505116a989fc2c9da2a697c3770ccc50ab0f9913dd7722762caa293c07eda7cb5fcab0379bd093671eb83ec8f07807e1be7b96a01426258012f2f25109410e17b5a0f280b719e4bcdf15a4554da0a4833eef92fbd12956a783b354b448aa3c88fc2ee5d797f91e59b595148c49e0c4077bbddd4bf6114512e8e13834a3be177ef396fa3fb9a9db33c9f286a8ab1660c530318b9926f1dacea12ee7bf6c1019d02ad674554402a06a6448d487e42822331ce55bcc54932ef4545aa32507597785d474c790cbf315de9f6032267831320a8a9ad3530abe57524b44653de653eb5fa05a3c14d945d3dfd3ab11c09e90215afd4bd7f19be3251f60eee6363fba048d650d0b00f034c260180339d7fdbbdf6a27f914003addcf61b3a81b88f9e1a55158fd18b1f8b3d194e7d8a690822859d065e2452657ed95a08c55839f4fa6d54106ecaf57a4c4528863386a14bfba41c71dc13aeed48f54c3a100eb65ffadf86c86ada634b88884616024817e185d49b54bdff7b4deebbad34f68632718e3c670075c55f072e44f56f364aab0f95a7ea09e1d33d337e109f152628bd92a320b8c7c26cd84fc15f14ce88da695944cd30ad19e4e41161a50bc1bc48074dac4486e5de340cf7a41331d812a10f9274126a911b78e4cf096697b4e992e8eeda955bac6fd7e7a35fea3087fc0b3f5673a7272023cafff358edf666d18c2bfc7997245dab79843d160f0a7f562c8297c3b8ea508dfbd800fb314fb42b371878230f5dacd74e1a69d7a643e31b765c7b7a594a12834d41a9582cc5459025b0411e9adf8063fc496244d74327fc984e30a15ecbd0c89ed79cf2590dcc5a71f948d0c064de153b3ef164ac7b6ecba970cd864f49eb81dbf2beab9c80bcfe0839c189ef3f90a1222609985b591714687592ce5ed61ce7551bfc3ef5d6a677938da127148019b4ccf4e9f6723674855fe3125c43e72e51ce13576a7d68dd44dc5e98bd759b8924d8209b83c6ec9955390b68b6cbc73f2681a92eb2d18ade60fa01ae6cda48ccbd6467c0e794aaada070bd6843e9e4fa65e280907151fb2afa39fa710079512c90f0d324da37b9b08032fddbddb2063839e3d6d3881b024abab8d7a444746d62116da38fed2a35f09d1ffbe23c14302ca60134dd59cd2d10e4bbaccf645e1c8423b8f8244bfb5092616ac32a7cd43d3eb6f70c28deb9bff8706247d03239ebdde9f096149844b011e543305af912076996f8f60d1be51b1af6f86435cb054bf93daf4159b637d6f8e462c664086991737e8a17d058d837dc31c30e64123a6c3fe016d3c89ea587bc36bd05bb1bd6197a6b8c3c5b08f5950f6586754fcca72842e0877195885a2d0e8a02e5319043a76202649a115ccc432b7686a1421e63e59ec2e3553299606cfe7330e5a3359a9bf36079f95e9d8f1dbef9736a2ebef95cc55244416fa8faeadac034c9af46fe66aa13b39fba490f1941bca681dc53dced20286f29259daadc19d744a459ad8e54b2840b7474031daaeddf6b456d0582953c21c68bf3ce11be60ca8e0d895e6737aa5b3f908c6331b88c7e39fd9e43222ec25a3bc35a02b2855ac918e6fa66f8bf5540f4038ec698f9f4c015ac79503d0cbe045b3a33b50f476f4ab865b7418447326becc16c92273dba8faec685d7358f88f8d638dc42139efe11a171d85b181224ce89887cc4be2e297aa47ce4615ff7bdb0678dcb53aeafff3ba2464aa723e1b4852b188fc14910c39d2f7b1d94006ddb98601fc8ceaffe82b66eed0d521e93e5698e1a3b98791d0197f3b932cee20a21d7b7db9572086b7aab66a235e23ebe4de18e4c83f180f2e53557035dd342429ffa03fe216e060c092ae3498546de9ca82cf9e3f838047103a440a1b1252a466464a7e79a45ec7aae59b5ca728c4bc4cf7c2459c7cc52b2dc800181580708106fd454d764b54aa257170c9682a3ad772a101e3d5a0c428f25e18b47ecc9d12deead59c3d6a32f3886d6fc2441c2cedf268840e1059df5e3dba86ce26e7c353bd3de70082c876b4b0ca4ddfebf16b2f97ae741cdfe56cbbb1fa2b7acccff3ea6123951afbf325908e2c421ec8fc6e286374cca7654879f7bdef7dbcb4c032c1970b1ae445e9a7ac4199cecc12bfa999472458f988a994d71b3b4ae07ce0879501a03632cd6e6101950850c67c82917ca70b45709fa8177d0e6dbbd4aaf531d800b518432689e98b46eb243f078c340bf501c2a4f5da4fb5e4d1fdde01dc992eef5109ae7382131613b62c6e68ad368820ed1353c4e1434c0b6684000a96ee7d963f7432adb4db2bf579cd6fa3027df52891ed26e510d4455c78c2649c2909cd4aa05ce8b3e8f4edc0756bead4e48b9c489ad5a7d11f0d5de7899282c260dc15a6d6e755d7eceb633885f6c87ada7a43f2f18d01bae9d9513ecbec64222349a8d0c8e7753007cd0a30024165de488f0168cbf69f39df31d5113cd45950bb1f4988bd76b604f3fbbdb4eb4904eb4c2b81889a437901216774a97884df04c9be8a0c46c03934393b343ad09dd0b52e20d4c13c44d713e2e7def33ee2081c52c38620d584aab95a1c1febade44d50366477eb658376700bfc06d1f69ebad11a83d5a1e179bbf8cbc0ffcdb23dc0ac6f3085c87f57d80abb1aa5cad7417f10aa2e9668349e28703d5aea49a831500a9e7ad36b56f3d87647162d051fceb60539b8785cc0e3ff39f5c3c0757b46f80f8436df9beb4c3155dd8216b2d5f4c0ec0b2b24036b6a20f3a6d7b506a93fc7ec277c11ab7fd006d8be34c7e11da3ce2a80b237dcb7f6b1b5cc7c7b46d7a0ace89d983fb9b4d52fc23f4509095df86b90dc1ef6aca5e6912b00f89da3ed29a8c3875019c10457f36a9af544d807f486aa462daff16642b44a43950ee505b916bcea0697786aff0205ac0f2d8ef0c5e7c23be0aed40a76773b4a736a5d60c827dcc0fe191d8d7ca115276df6b4b94cddd5c8b67954b61ec4d740795d0ce54a2ada920eb3222f98ca5499ae6eb9d54617c2b2266c80ede0c8b070c6abbb3698fa9322e3c32d197c89885866ffaa3b7698bf496db0ee5ca7db56736756c5a87e29b0820205765049eb26d042f2c83dd15d0a2026560b3672a12376023687764800a8ca82524df43a8f38194c102b322718f7b440f220eb632d0aae0cb09f320bf221cabcd45f4f4291955f3f9835f9773803437336bdabcfab57e467e970fdbd0c49b05d506cbd34c8c95aa3fdb96a36ee69eb3d612de1f3bf961862f314ff65f35e56054ef3f07edfa589a1322404192336b8df16c16ce20f0ba0be241679b471a1925164e1e4148c55aed2ff1f351671d2719e28dbda10e6689f4f6d6351f0a00b9aa2339799ba733e33603989e0d23cda6f1939619022e25814d8821bb7d3b3add0b4931ec93e4b7ab2cd4f1e37fc48d01e70c68f5c5e729b2a9f8feda42d3e4b119e54b21532c83172a87d525d6fd82a4aaf5be654285b590d457061adb5339eb625b04879f59b4507883ddef5bf21744b3d5d4f67ceb22aa18a847e3170bdb3f505fc2f010572fdca85fdf70184d2d290fb0532e91a041d2402fc4549afbba93e1c13ad66c2bbfd25cbf7c63de56f992fc1c7d81ed032c3222004f1691f51f1e5a0385f9e22f9ced5e9587a8fe1987e4eb680f6574b243ab70f9156cc7fc99ff5432b99ec6eb3d466365c95ac403142afabd67bb1c49721965b75cdf1b78127bac51de7acab50baf9da99d196ff747fe4ae948f7b66f5bbf9699e58758ec473f2aa9d23699f7c5a486ed5d50b43b2a58957059bdab4a6f5b3052eba50e86a96648d5adfca73d33173d0c22f33ea487078ab40b4575419f2d1251ca3aa0bcbd3a1d56a512f3394a95ce221204551be07c28c18445c0880670b1ad2c79d09e1d3d13abe01b0e855155bf42043d8a995d5c983b4f7f02f954f09d1e8bff61c8b26f91c287f71a48721ddb53bd5735ae6fa727e6eaffd0f8c96a9351c29a7f7bfc26d30e039c3756575f73f383008192028e4a2489fcdd2d4f151caecfb1e808ea08c4fb97abc7e87282ce4c5ce0dbcb37d38bac61374063f9fc75f2df278596d85d2443a28fd0ac69e598eee9f8867fc1fa2fba96a3b92154e0b14439aaf1fe7d74b53664eff4186ab4c9322f46756dea90277a5909493798cf24d9200d188297029434490e2dbb769d8e5fc0034c3a829940af7669c021ee5e9cfc438720de6f32d46037b9e3aec42762b8fb2d34e4d56d96a3f000f1cf61abbef5cdb164cb0bf4c945760c84fad118f30f1a946e949444866e536c8acd900372994aedbe68759ce556211d83a4be0f8b29b4bb448ee7f4d1a916eccb5ebddb577620939b8383d50c7e4f299e5547a4329294c5376f74904ef4d0b096347e5242fccde2c7b18715ef02bc2223a62ac0353027229b7c92a9dc7fc5181b1699654adca6a66a6022eac1a226614b0a3f94483772f270040dc07177d506d3f643c1d6eaa00c845b454ef33b895814c06f4f72dbca249e07ed7a1382b84f99362fc6c071af6a98633d8081909e418c4630fdedaea71078ddc9975bcaeec2a1de297ad37c349bfc2c4ef86ff5db018d352b0280f99d4513605fba1d758f4e78e01f372d12bb6067baa250dc78c916bdfee0cc5e58bdbaf4a557c0e10d4720405e0dcac77ea17d6542ffcafca7e46609e20a840151090a48ac3feb2db4f40be41ec9e9a14c737d6e67b458395786a282def900e7374f65a556f5749aad038954afa7747f003065dbf4bdbd11742772f1d169b7c7ef8721c1db4bd52c82556f7661c071e15f41c6258152e9411b2cd43d89ac1f8dc03c89d73982a36880d3a8565e2a25c4aee4f887a7f08b65ae4872dd7a015fe51f4da01d016ab359a79a379e4178a3d196ef9269c1bdfb882becb594cd63e4061815e63e6abb38b111229abf62547b45e0de6c317648b02df4c62f559635ddf9458b29a5712fea1f818061ed3a558624b26f7900a41ac36990b352a391b2845d467f0b6d5041e113d56e62cfa2d6d042c99c3abe900d1723ba8268bd1443afa9cc88b8c6f1b444cad401a8ba57752748ced5112c7ffa54d4a53a6a9ebcdbc81fd77642360e0c81d140d0c30901834e192db3afbbfd8b1aee00f018445b4e605216590374388c893886e84163ea09f32385c0a3d36fc1d04ee6b1a6822ffa77ca975be73b9b991d6c59d2c31c26676f3ec10c992c70f1018cb8656c4666e2c2fd0aec52c766bde93c546d02cb281a32b4741bf80d4e93d6dc0e6dcc792c3ea4deb64f0a610f7c7e8dd2d8ed42d26e19233f0f82bb11dc174ebc37aabe04f8e92af90393f666b715153fa4a67b0fedc6a9a6b8fe2bf28f104fe59b6282b4c7abc6e6de458d9ea67f8f02bd90d2524b1ec33fe16abe28ef04bcb787a9699aed1964b726f09da2cddfad2f12cd6232592d4b508688c7aea4b087270e2e1fb879e92b139c3cbbf6d05147b51c9f9a91221af0209e7a29b02c7f9990cfe08fff95d7ebd02b62791e6b9726cab08823e7fe6c24e31c377774c2d0ac3ba30f2cbced16f75a6c52b46361050b07efc02cdd3920005010459b560cd486d72e3393d09548310c43cbe2713bdd628e3317f7925b56f45b6c2c0fe31744640605f837448080e9dfb75653e02631e5f07225ad64dd4d457d5fe5e436c1aa6d5b6f7eed31e05c647a916abffabf6ba81e3e2132be4acf70ace53d4e71d17380d9d142dce4c1fe4ffc6c2f357dc98747abc363d9429baeb627aa33a287e400e1da9212273079dc8d47922d4dad6eac9e5d7011fa2b61c1d77746c085e6f05132774faafc73b53a92be395b6f1797f9eb005dfb94c10d0c0c3e315c60337eb765afa0588c597dd198c7c34c8f3024047923fd86419e268d0df634281a51174327d2f491558e2a758118201678512768e877971b97eeb931096b62d9170c70f5344ddbe7a6b067195827beeee4ea85891803a4ae7fc3635188a42a7b206846a8a7fa66a837cc77a1bd06ba9779f98328b884046eb0bcdadf242f3f1decbfde4e60f91230028e23ddf89ad547cd0f4d8dae1a9795f086c2833f64bf3b9f32863046d44c21d3981d41b473f087e007e1e1f092ca30a088534b68707678c5199f63f8c21624388a80b3f3d7402eaeb4bd984775b9a9244ba385d36119db64b98d1501f82ffac28b9444799e3841d391962ec9e1fd778f5eac0e453cda87c3edc67e3f5638eaafc0c5ef18953936d9a8a894c49934a0382ff7d1bb45121dcb6cbc0a1c11363edccd91cf226b2ab4b348b7c75deb6ea8c8bf9113e6e2f677bf8f98523cbaf3ba4d2f646debb47efc24b91487bb2222d8f0f40009512026c6b31a3d6d3dce40d77eebc4deb3ec18ebd3ae8807eee31671f3a6f15c547bd20e98fd5945d67e67ed3b898acecf22c674e2ad31fbbc2e43c52a2cdae1b73e228b6d758acc848e7c56444211a825b58943ba89af83d00f603250261ba1b5201a97ca56c21337dbd7545ffab3aac67af104541c59a346bafb3c3b0a87a26210daa472a2de49eaed7d64c3983f92a703cf984f22a7b50904605c934c241ef15c277b64d4318fb3d8dbf3dcbb105c3a91c878b676dad85e4c33571fbb1d65951c3bf1049265b0f14f83a7bb44983de1a13118c5a7b1d43e594d8acbd1a205f121c7af56c32191bd00d6a54e0bc7f0fe055aadf0318637afa2a3dfd3526d78759a6a16a46a924ee16078ac0eb9e72ff5dcbe8e19425a3c1073558095c12fbbf4563b8e760ea3e1f832a18ec282a8d2cba74616b5b212751ff9fafb503ef4bdb5a6ed66a96d06bdd6d07cb5dd52779623ba5aedf7106c6084d9ec97e1d2619242c15bbf0fc9d453dfe1855cda9689968b1144e970de017bef29685dcb6fda1805cca026678e4e24eb8478059fbe1175fde9239c74a0b138fd4d112ccd5ac1584d8b4a75538d4d4e592ed6646eb531ae28cd5e27bd1f9da8f9dfc6197403c7b049e49c0a2f158adcb2f1adc732869aba31326445d0959aafc443530bc191af6d2d15d0c8aa2d83e5a21f09fbac70c9c75a0f4f72c2501e60603d84c112618a8534096870abd6fa4bd5517ce6a4727f2daa2734512342c57c7b7f6bdeb745d13d6fa88cdeee2e2d5138e30d20c435123e315b2502f34779f3576c5e25db5eea19fcf4750adc726c1281818a95f588301f4f055b33167f9e37de906be7c9dcfbe033f412e96e9e47745c3bcea83577c43dc7fbad4f513aac756feaddc2a7d4aaf385db6537960b812c29c6e4433f1e7dc2ffe60939d80e0d0f33c5ee7a7d895fc4ac8ab9b0fe29412ac7ca60b1b8947b4207987fe35c36e814d1409ff9cb9da8a2f8946db5a9cb12ff8f3025c3cf477726a310261b3d1d917b9e0b9c6ae29e94f373d7796c6ea1505ff06c4d000623122032e5c3e6fe2bc66c4ba3f541f9d49f48ae19dc6badc3ba3b37bd0933f2ebeaf9806f187a94ee77605e68a937fee9587a9e4fc30e641f228c30dd2fb6fc44031e38992cc2ef4a48f866a91ed2a979a2424f0ed793c2c970c42e7cee84ec98104a179dea2d5cb6db545bd7fd639e30727926720727a49a3f1e9de2205aff506351844e1025f37d8493e32cbb637f38fb2dd1bbe1eabd65a53839a8447fb72e3e1385acff54dd9e877ddcfc3fe6a12b26b47425b41c2a61e334f038967e1915cfae4c038faa21f91edc0a38bb45acac88efd17c915b3bdc24221048335e6010e09ad190543355a281b281b7f36f4e9991003227c6cd6b6e84137062a470f19e4aaad29e107b611a97d54c13e213105535293f6b6314f8dde1e490817b2eb08de519143e77e4763dfb290b32e839f12a3b3b939a8327e0ac358a9bfc3de2151d42785fd26fc30fd33ded30e3e9bbdd999d9e7a0f44c512d1ef10f6bf56b3f297d02106fd7929715228adc4258111cd2182e6766c4c2757dc1e6cf1374e466e0b9a0f812d86084165b6c614b05271c35f2afd0435e273e0b49af141c2201a64aec6e3c5d9ffd382ca7692628bd265c618dad7d566af2903c02aea79fa11c81f5cd5d818a40ce3e29786dde4db1e504c7a90c4694038dde95e0fdb76dd1dae02827d3a22a98790bf9b315e84c225b03ee20068896681c5021231442e94f57a4ec4845bec0d312ae8a8e287d099c702eb5ab609a5d8e588e4ed36e43c2042818c8a8df5f403771ca06ff12ae8c6a15e17face8e1c17eb19999db79dfdae97380c7eaee753a86f32ff2867975448ebe259aa318e2a494fb128b7e0eca96fbfe9cd7568723cb81ca838dd9523751b4dbc2ec29c134025c9f8c2e42e1d0f12b898e57ac3ac614fbe01e0816dce34ecb867ef8875de9ecc3c4bc28c87f574aad113f64df1c4233fb0c75a2599b09836a4a4d6a3b08493b377fb49eb7e93dd5d24bcc39eaaf11cf7c4c195194cb928512072fb6f7394e6d97b3b3caef95af1238ebff8a865456fb47a0c32962d475df1ba4ddc4b89d945cb4856d04624f8ca1a535d735eb1d094d3b1db69a76108ced0d048e56a287e644470ce0a91b630df8c9d400543c6816a01f469dcc80161d8b496dc7383052cf949c220fb1b10b37133fe17332c46c67f5df393057dd593b9bf4addd628ad66bfcc687067c7d5f16b4e2c4da0bf39b4998ffc948d13ccf186a1701ec2fd6b4f77664f93d74122849c5291c8fb9d7cead4466465207a3b914c9f1b1753b7ea37e90d0c0b444aadfa836d52e50e107bb777e0b014026d926e7459fa5cb03d78e1d4e94daa767feadf8064c36ca6c2b382808eff988fcc2d99ca1bc42c8fe08ab667b3e554fe783e868501b02b9852cf2e6e4e1316d5988127c4497b366aa791d242f220c9cfa7b61d364bc8621b30abb15f25d40447ace2954ccdac9c0b2abe91ba1e0f976e0f237073e55aa140338cb1f330c8309417a26814d60b920fa5fc72aa87e818f30ae13d4ce9d1dc0eaaea8373a8c5f4387cfbf8708c440f2af156382031dc50ce62bc72190000f59740543f108943cde5d9577aac15c3449c8bf656eb3ee2588cfcabef143c9b306698cf9510d3a2b5625a5c77d5987f54fb578dadd5eb0a600fd22b565b8ecc0c1c3dbd3f5036c1425635a28204401509b298ef219e9afff25e3274cedd22bf1d0e0d7deb28b49ba79aa7e586efef7f4c2fc00179364dd93f7370ba7b440c2c82673cead6d70f37270d4386a2b71d4e5446ae3eba0e979ff1746e8835d1837a3a629b9fbb532a89916b8af501b5f6d0a95d3371ec9b7e76b86ec50e1dc508ede07dbc542436c10f07d27c0248eee028bab518ce1be323a13b8886ae0fffe17503b32e99a4acbc3662c9cdcbc6fc6966d1d10cbd1d803c4268d37a3703f041b226c38df3979384a95531ffb378c1c0178776a467d0106b69b73d31f6280b8a773e3465ecd969f3e375f67ced457643cc15b9c6168a214c7aee13d63afdac5a48e7dad5d3c9e61ec649c0f2e9a3ac69c78c1c7295025cc9ae1843f6c4f8e7614544afb3c11e83ba4c31d051611e33c2f43f123bc6abfda8d7cb298d52c8cf1a89475fc3801a7921a24875fa890858444257f4f711801e5688fa4f07e28502116efd4a2da1ef19a0ca1aca9493cbeafc835dea5834b94acdbb561a91b73ae65c6d1410e18cc30a6ff3fa2bd295deb84dbf40d05ea95fa53d41cee679a4bbe428e717fb9965a26814a1d8e2dff96aa3c26296853e931c1603212613ffa9562935bb2a01f1c718ed1a05406639a595dec8d01c41b4975f1b3e436ef03d5510c269678f15b43446f469e90bd9c59da28b0643a67be90c21eb8a9a97dd24dfbda86993d9b59936901c0ce5e5e8a65d947bc9dbda887ea44d735949cbdeaf756a9155714fe5cc628bd5bc5bf9dd81246a600bb613084f90760519bd94b2bc7ba8a28cf16bc5a7e40619e095a4ef62bbedd95c42729b11da8148e24f1d26fb7d87a3828d3ee905ae77ca133787834e1a4b2bf104cf92a755fc1f7264965ee5028a0e6b5db1a44370d3bb4a8eda115549ab949e1a35487f1f50438e46ff2dcc5f541d104fd7dee85f8697718d6d329f0423e7f1cd52e732695b77e277866eb1f0410decb03ad19afdbe5c6389f0bd890c8bb905b66f0d286f980678059fb218783b3786452e70d8099244b48bda7e4f43826d7bc0ba6e76caa7ea2b6938be7e03a5f70278a397603370ba38602cdd21eb3f66281517a127283fae4f46e2de6c6403123afe033ed2eae65fe5dccbf5754ce6e7d1757b13dc5ade49208e13b5a902f453ade94fbd53760cd70766913dc45c6a6e3048c0c146bfc0ec8e752f4173c30726eaf92f380124c34e567609bf7afceb760f5b9b4f510170f9e6a54ecc337666741356d48b1eff98daea4ed810a04410294a085efb957c05766659468e819216286a27bda21218128c612252576c8a499b27fcb45bc811d28f46714475d6ddda945327e8ecbebf852c2a455f89d0ee15e69963b3f401e32ff64046458a09fc150ee040160af79ca4198b05f7f0e4514073caa17b3b7c49115c24fc93db52fde91cf4492276019a7f946e214a81d3eba30bec6830dc3ce055811e092c920dc99db7d25e3531a606e484102971fcc1d064cb187f0372b22de1583490a6a19a6504358692ebbb6e50b1f551df2a93d45bca010e2735df7689fe5f99cf615b628f0b7e76ea6fd4dc8c11ee470738667314725dc9bf2425039177dc0f2666c136b95be843ace6e15da51f9280d0bcc6a43f8b1030c08b2aaefad57101580376aa4fd2f8d9bf1a3084fef655338b924453d64003e780c41b694e1b6bebbc67655f006e421f4605e6eea5e47e099f9c24b7fb9e03d488a4e9174d90e46f12e0920dc76ed911110726c19e763831dfa8cd13a8c6a7f3ae333ce0ac1dbae0111b452ce12fa4e64c7a980fc073439cd68d123374428235a6dc234eb3676f5ce966ffb1fd76a2454f2b93f75328f11ef4d15ae6f4136bc1f626e5dc46be1fd2682e8da2ceb7b48bb39cd96e4f3c41ff413751cc46d8f0b7e919eaa90f9c6668d740df0b63f26c80de4bc9e5b553efb2cf947e362275546b75c2ac254bd76ec259c55f1aa6bd15cf666b835929683e1928b6abf5101567e17f9e9b72241a441db0ae1dec18f31668fc37a3519053b1eeea01513ed0df04e9e71e83a7438287b81fd8f2ded2a8b55ee636112f93bcac4c09d5a0c0aae908225246f400d078ccee085d0e0825a364ce5793b9fab372143bf1e28032c134ca2275a014e06a21b44245ad51e01a0d16787da5c3f8099ffc7c959758c2a34cc1eda3b20c12865d4183cc25e005230f3f8760a23506d8c04d7c7e759379326c71d58e5435b5a676e089944eec245871f25103bd3cf598d4421591dd854589cd06c3f1ba23eb04ad190c0666ddb66ea53c9e05525c15a4ffee92553554050d4d1d35e419910a267be2632cae4097b49cb1442c189ac212f9b6c9b2332b094db8d4be5535c63774da9de1b4bc2392a9941aad46721b9a9e7966c74291482de524fcf736bb6efe8b2d835f49f8e8e7018d2ad5118e021cf44f24697dbd9ff2adc241affae78256e4fda5046d4d4bac4757e5e150957c3c3c47b2dd62bc98c741efd421e41b8b472f871c2e3ea4e482781dd7f8755125e06cd5230622db2bdb169fcb9f69fa256c9b5dbd6da740def2d2f7677daaac7c45b48c0f7aa208076d5725d1647a112a4278b14470bce9d39aacc2181d6f515653d48c29ca8b133fee89f57113ee5866645f39ec97097622a7b75b9ad897bb0a3ef00139e283eb9b9c2c8d45d76f65b4bad2233c64a752f2d144f18b50399a2c446ab2d0e6da4d6ec7d147d23262a31e9a148e4ac52e2f59b4fa65e5c7e676f6337f0579cc1da8af7a768155fdcb9ace19accb3f594509dfe4bef734c2f4de5a650a07b7bc33db3f14667eb4478e39f2958945bc16dc93d52d448196a078ec6c0899c3e1fe6b7f7f1c5ef747710c401630c40718d1a6cc37a878ca0e85b21fd8a5d922a3f73a34b8ad68b56840472dc345052b2880183b587154f67e3e8d78fc8784b63581254f1f3d089ab1ca1d383dc5e9000c1bcd4eafed8fe5e1747eb090bfcd77a492936bf810c2f78c3daa47f6fe05eb9d74f10150afb6f762665e0ce75df5d6c809515587546e63f3b60f3376f32f1de96fdbb9b5b0639e08d1a226cf6a934f5c6aa3842bfa708fcd5ccd46c3e28dcf36a05436acbd79ff9a6b2599d3cfc8b9242ddf2eb35eda830f8295817d7d5928304fdcee948138fa0ae2f4c26ecd5aa061b71d5cd72307e2a992fb0a4290b546ba3540f7f30ff5ed06062a18cb745d44ccfb07d236a9579090c9e2df408c7f309fcf500c600ecf5a26f2170a6d5ff1d51191cfbb94b76e6f9d45d68f88d96a5e456b844724fdf66f4e62c0320506351e0c1a3fb1466bcf0e8feb81e43d9a4032e54f6a770d6f48c1a20ceb31fd1167e8ab04d5eed834fefe83c6f4e7d86241e3d7968c535042ff86a38afb00060f7032d6f163ed861a588e97fd56e4a55dbbe49d24099a1ed5162247caf46a33450d42bdebeca1e19e2002367c6c1b55ac092a859cb2b41deebd2bb25503a65670689842a3674a1027f38104a4ac1458432f8ee6c85bbafa04e5df29572246c01308d1df54ed28d6354f68fd49e0c35f95b91cc787ae01a8783ee9ca2a06e401246da8ad4416abd6b73e8fa293951ddd9738c1b56db0c109f042e44a2d246b8e7f1c6e942eb5d0a66981699e27b176b2ba9bed7fc4a63ed7ee1cf665a6ab409d39abb3c71995167f601998e8ce24c9ead9e54243feb6936c613125d884d41cf7a5a488adb112e7819f9d131e71b3a0411c383c819cb31560584ca0fa003a59dd397be06ddbb0f5733c07f7598ba308eecd85be61d2a8983972efdbfce32c2bb17f3a4945ceac0592521f1d8da65fcb2c246dcbd83d5889f858013d12e630a05523a9576a44ebf58d063255801f07c910066d4b944fc509976d12dc03784aff96bdb798ae16cafc2c0d4b2895ab6e3369ba8c1e12e45516d09eafefc20d8364a1f38a22aabe09abecdb172aa7f8329cca8a8ceada8391a392cd8cbc165a88f57e7092335182bb3a71490e1c3b3511bc6147a2f4c158dc7b4c704ac3047c575d278c268815120490710153877084aac088d3d6573d7c556761c761d7946b890a1aa8b2e1af1a2d1c0e93c7b1cc24af0a3bfc44a806fa2c506bc56ddbb9b9398774ef79821b094339521292472796e994e2d0eb1dee65cacd88e54948a395ca76a7d7717d5d0035abc3123a768448c6167c5df3fc66683a7847a41f52d999e520fe34f4e29730ba635e1579d6be5915dc79c2b0057294eb60bf4d462775f7f8c22d1522073fa11eedfe4094031f0fc8ea95563770ce4acabf62a7f55e5d5cad84ba8bf37bb7c5c528eeab5784e87f4c8759a634ebafe28cf3796cbee6083cbd44e2e5f653c81ef2b0a8179e9805cf14659f9bcab16b66c25c3fb2f94206e986f788608a06d9dfceb1618d3452fdff035e9f4aa7a38908ae128dfe1d0ece462c7e5d4b59b27db9aca73fdcbadc4864f20904e3053a33fee98625348691f3ad3053400b2e0e302ef966ee8e2394a9646867f17bf6458d8834e1c61728f43a9ec09694f5a5dfa7ea575e0856c7178dd567654015fadbc0b20aaab704a230124561b31bde23a824ebfd41bdb750c13374d00fcabf98eb98fb0e6a2b7277c74186de10b7b9ec35482f1d5e3fd522eb1cef67853edd0bd460a7d03b75a0a734a8173f9c81079c4ca19f9a0950ef8fa589b71d0e227fe9de05cf2eb4461c0480de06712c9b95eaf00b1a43730d3acbb00005d123817055ecb380dabb7ca24071cab534f86419dabd74da8af46b179aba0a7efefc50d2f94b11e305a920b0860bcd1cdd6bed7e7d0d9529170af253492145ac78035bb55245a16f65175d216ca4c47a87d5242c894b12e1fc6fe4db1a80918b50378dd8623c25c04eff959a541c2fbbd681580d144e82ee68ab1d78f0645ac7d731975b40925d931dba984f51ccd62c34d244d28414e03c58401dae3f1bf52d25d02f9961ed3cde12e2f4054f797188df1945793e6e985f2e97c46f658234c0dbb770f7f92b200fb9595612022954ed2c56b42ba71bd4b05b0ec038790aaf72a7248191de6e63529775f466052f6ddc70ad17f8e9a693bf61741b2ead72db78e564fb909b9d379455703fe5045d3f1c1c4dda9128617a10e98a440474972a680c84f171f41160f7872ee4108af3af5be7bf6c42848c18d5d5d03de692a1027c0ea41cee821a70c1a86c06dadc7650ac021c5e3719affeb70486bad1f6725f4828ebb5836d76db8dbfa94d25c61bb7ec72485a5d2e83748d911ede61fae31ae0717ee7a1600e0302c494732d70461462b067d836a65272a74147ddbcce9bd0024f4179589d60e1d489bf2b3182e0522c9dba1c3a457f97a1f4ce3156af5e2b37d7cd43de7c620e538efeb426356bbbdf1112832d8d327f36a9a95c9da093fd771c0af616b75ce6eafedd8036129e31d56a55516039f8958a98dc0cc5a3033155e517065b61b19cb531aae39fe1b1d02d28a192e085e2d238a5fbcab140f842795e191b27dbe55fc17221eea95cb03cfd12a3f185a59d5d1c0c110252759b04aa9ded21dd0d53b4e4595ad0908eb25ccb0cb741a94888c0622153dddc9443d587c17b0389f7549585bf6254e82b6275bbb1ff45e2dac1c2a60368244ec48e0bb1d80c04221aed1b3b10740e66dbf08b068fbd8f53c9b035d2b80d1ebb9549a4945840a075929ceaad3756ba6eadb98d2d5efccba1a425b44d10ad6e6c8461e933c32b4d75879495e7769ce7ffdbd87fcb298c4fca848e44f48594dce655b21b642ec68318c7c5dd07c0c6caf99fb7b318dbadf95a6281927118cbd84d6df57cab509be1295eb26be6769318b0d1b178d4487228344928fecc88dcaaf75d420b92b080e0319f0ffe30c62bb6d4ccdd980cb46d970d986f04c53e330a380458437a9741fd3c0eae1fc3a4ee51cb9f602c7019330ca201b40913925b6a2d2d374cebf85d5a89bdcf92cab00439399cddf364e8b4602ed3f28d6e02cfef03e1b327065b4680405c722968edce460b2ec750ca871705ca706eacaf34d88967fc850191d6ebfc1d432c100d632a02cd9917a83aaa9d16a4a4a769e7b3e56b22dfcafd3fca0521b68d935b5eb51253e71e66f86306e1b588c307064f3a25e393462f25ee826616b3f98f34a62cd56a5ff333db35b61b0612cc000525d417c97881d00714873b52b1c2f1822bf5f9fa606c0dafa14f1cc808d5c2da135f6133bb69bbf9b1cf184f044dd0bfe9bd4b9f13b15b043b677ad7a923bc1c902a2ad633defc2fe5eefd3808ec81e637640b1342d1927465de785da4b433768bf380b670feb5601dfe1f1fecda652cdd6c0c157f1cfc836089976c46e84fd9be2ec58261d194c5f5f290916cc2d2d7768d725c82cec2ed9888cd5b72a023c7e75fd286eea66d692f3c7f0807d400b76f630aab005c17c3db500ce861f3933f0707314f6b0fc401cc44cf2761ae517dd6fe0b9de89f7dc1e59f0b4823d4f11ed3a69da039d9f1e0bd85d284d9e6ce6aa21fccd70bf7fd7f2fb1ef8ca4c649e0f67a0c58c0d25b6635303fb1983c33bbad26d766f4da2d743c601b46cdf9b9626356441eaec5555ec3cec7e9ed51912a7b7ea97daa258d312747511598b67eb1460d6bec0297446f8962af79c9dd0254e24810811d3e0883ebffd3ed6cb2b0e0d7f7a857a8390ecd1ae38e7ba9fe625c5914263f5a50a76d627eb234e5f19d1c288a850ca06a001d1009469ae6b1d32b7e652949f0ed7dc1ef9c1376d50e941d5200640bcf5c2455832ecc567450587b2e4d375fec9881807e9cebc54ff06c0fa95473bdcded6776ca1aae3bf84638c8810ada66ce4783aecc95a993ff5b3aa4fafe0c79a55e4acd41b837f2e54a4adde676e6cb5e82a81f976f727afa23e46e8838d151a90555bb12d4d09c257dbd06292cfead0f0bcc2c37368f41876842fc8fe860f353dbd41d93b4bb470a5318d568ec386987426f394c37a619557d4705221ae648e25102734c07fea7733074840732c6cf818ad5f4f36badf125935b2b2706341a11692b535585e946edead46ce69694c3d2c10e9f5f41fc19db3aa99dca4131254ecd41f6e192c1c39cad9066a6d580bc8ff459e12e0d4121c05f358de5fd44ad700f97719e433b371ea2996f65bdf56285fedbd0d179513989742c92961c554203390a0e25d517c247c0bb657e4973ff8c128e5aa324b8ca07a67d342500e6d64a79b9fea73b8f41a7183ca6b3eab7e9d62613c25c18f97b41416bed111187e4b857b564c50dd0e3d03199650aa12e06f69fdced364bd92ed409c65c9829e2ced55bd4c2359853595d3b33a3c47f08103e428d6fdf6fdfb1bda1ecc1505be9c80b4da4688438f67a9db702339eed6786efc4cee5206281f1f22ad850fd4a52f9a8be4d7d3dea221777a21550a170ca63b89040cb6d1b225dbebe9e3721f0ef780e04d54748afc33d723e3b8862c4fa18770c85c83a01c751e667b9372be46b78e6f5235b2d9fc19eed20048e4cd2843704f951a8ce927c833e690e29cbb012f3a2bbe38cedbce24709ea230e3bbbd1bf3f88139c7e1f3f6bdd68a4a1ed4b3487be85fe12c7061378508df012db7a9522644624d42eeae69a456ed13613d25b2c5e3cf052ff6f1c636efaab1482200bf1b080d3ee7b2869e5956fac9c37a798b7ded991f00d8d6f597e56014c2df6f652e48517d5aefbf8daa7b69169ab59c7908d5f8f371dbd75e1cc9585e9915d1c362369b3a83fdea464fa0e2bb9170d04eec55d37eb6eaee86ca2c50b4a63a94b8121189a9331b4f8d7948ea7e8b88ce079de09aa5eb3d020ff6176f3620ae2dcddff0c731aa7b6b96d86fc87ef13d4bf62ee8d8c18c84a4cc54261e106a40cf9883f71ad14653011b2e51e7cd960d736b30555bf9177dbdc260563407eacff7bf65c8dc3fe8c5b16e2f5a6149366d80eb245ee3cd266f57afb8ea14daea48f0cab1585f19990f9f1de4243bf0e099618d6085f4306f342d5a3d3adbe57d3d89b8da5ebf31b1f544c2af559c79bdb23eeab1d26f97ee3eb51a8d830344a504a77fea92077225cdbc21dd99650d788b183a88a9c8db60b32d4240f762511862ce2c477508dac61fa598f733bb7a0909d3c107e134ea41ccf6bdfba59dcc498d8f3314aa005e0fc42f109dfc35a1d89ed4de514083cf07e7ab54daf69400077d9e1f2647d76dacf71bb14b612938e7ea88e3d68ffd915379daebdfa0d25e87d9cb0c51ec312b7b12766e474c1222433a038d2da71b07bba36b88f95820e362a644223dba74e7883edbb738ceb04d6f5551ee0bd34bf7267deb3416038556216ca0931278ffa4679704ae46424a6f295ccd4510d23fb358562cfce30543cbe4118f47ba2117413eda4070a15e6ca191286784200386165c3068e0a16b34b67485cd837ee0bdc0fa1d7b451b79b089c509d69cbe815c764a4b7d0c900634f41a9f303d9488f68016c5713b7fa1bbe3497db7cf6792bba47f6ef3d12ad75326b11589025015b4a9552a0c491a69af7780106b78269ccc1857253c6b2ea6c7c6da56dd6759100af486d46901945334bb69996e07d9b1ec42c23427d8a29ab256ecba00a71ca035cd673022990c5e030313bb39597420f924bf657009a259613432ed7403759aacf4c140e9fdb21db2028c2248fd058774da73fea3d0995d472e49eafac0231821cd6109f4224d2e334282f60aceaba62ee00bafdf98f590e55128da586db7187f3d7b3e11a47bae20d5cf9901c99093968aca580a8392ac908f3d0e200ccbbfc818fd6826195a120127c17923526e5fec0358fe03e398fa9e824de62eff37b3908065963957d8a57feb3af3bfc3df986e037c9bcd3067ad31eadae9e096b8ec02d9c7267dc7085cbcc8545342b82051f9ebfb67e9f331d6a09da92b63c316fd06fb1a33ce0d7cb82359c166e3aed24f0674b04ab2c54f58538dee63b2604a404fd550a7ef4f90845d224fe5686787f2b689959f68fe7a6382c273eadca5fd68e90df46746e044056952bff743670214ebb85cd111f304cef59fd01baea647e733a3b1e09fd4ea71b1b4004e4d2229c247c25c5b9d98375f17484b07fbe32b7a9a5808b83b00da62066651bb1fa39ba3d4922ffb3b4ccbc90ba4b5bb4f0abf42a86856b5173be1ad6edd3bdc19df3cc71657ac4e4ad3d56fc75d2c57e99a3b8a9efe2c153a886c5e0f852fb2019e28d6232ee147bfecde75a0638cbe03043a6d5ce9d00045284d8ba44c95554dc84330115c9c1cc7e5f57e95ffe702fac075f786f8004a608d0004283371fcf8eccafed0a180cdd57864880e36ae2f79b13a099a6419266cfe311115df9ad2d6b3a975459cdbbe9aa8e042abf82eef758d9ba6bbd42aebeb44ded71acdaf940ff2537b7c57c20279dd48b0e5256d9d4c002285e6c1f72c5477ef87a6f94264c239ddb0c6b5dd1f371ef521b9140baf07517c92caae9acb6709bd79494b3bdcea5945d5086cf4e66c83b4c2f3ab71d5f2cbe92e1f2b9363b5f39dca069442ceefde07e5a836e9b3e4e46e6175c60a097ff14a24b937bc0a1b3f3ff81bc6b7667e0fad54f51558e170445daeb4bb3a8020699a46cedcb732aaffef34342724367f9c4cf9cb3dbe787d1c16c81f85d810085691f4e7c3cf8d5276001b6050d2ef766458a5deb21f9f926700215a84b91fd8c550554f7522b3211955b442a80e6e0c9c6c898e958b466f8dd69d3c30b9e014756bb34dbe66cfeb490a3a976abae121d886120746c3381ae9415e2d36e467db964f6e5ea70617be13057da7c20221f9e7dcc01e3d47874ac191f514093ec2c1873a45599f21e278ee32075b845bfbed3f38425f33c778281dab919ab1334cad0f8e2427f92cf2eb8fbe906a4af78958716c59409e4a55a674016a9c6a63d6520d1c6e2bf7998dbe32f25f1465ca9de05e9094039b12e31d37f4d7be5b8aae9744b4fef19e1aa9b0d74f46d62a2c44d31a324e32c221be79c9d32ab449dc7eb705f95ccc4d2d148b290b93bc79cebeaf0dd73f7a048117e2ac12cdeb5a79ee5e0f7b2adee63fb032fc229d45dd653bc268cd6586bed7c84275b9810781ec0cea9c70dd9893a766247bc2cba2ad927541ee2f4d334f1143479f0ed60ada255f0003d3c13e19f1a5f4514fa98889fb0929f97e2aa676009c6e146fcf7c4c0f6cb7673080f2f2e5bcba19c0d2a133fd3099f6090c2fa1c1db70e7d5ef1d73a233530118ac646350f86ab5e1f77560cd51012da566d1538cd624c6bd3149c019f6e1486d2f369429bdf6b83e6abe917b532d148002aa1416a8add051f0b6675fcd1ad2627244344bcfabd341d06312d87a8e53a4fa1df4f462a724adf55094a555b6604527172b0ea480cdfc4f2c24d636d89c062babbff1e4d35e3d56138ece2c9de8dde6f8cc66de6aef4ee2d969a9f5a0333c4f5ccc42ce9a3b0a3814b37eb7e03fc5007ace041ddd1791161bcf008c3e1532d52d3b11477b6230bf7b56284c2b670e9e062ccf2f94d19b4f157715be666da0c890a4c12404c9eccab7271a7734f55e27c64f9f1d4262eacb0e18d9de0f570caeeb72e5fd240c25a13aa191c85183d5fbe18f444214a15e3a966abcaa0d5f7d3a559416c36d7740731013e4ee8d7ee6be4675045c181e2e2f532590e6dd9923cac69589bed9cb0bc5f07641512be2718c407cc53eeee1bc7193c3c9073e20ac680beedcb55ec73706133193f6f4dec1f5c47101965bfaac0b7f3e12b7cd07a6a0bfd70ddef9405b849fd7137b0b4777dd7323cc69f96ec0a5ce8da6b43466c6c5fd4fae5fc037cb7aefc927c98b7a96a9a48e8d84313bed1477391b45c93934c763727107b8318f7ba9e1890af6494a0f89eced2990e3b83c59227f4ef3d89b17acc7a43b1c5de3e4c00df891567dc231bb72f1ac08f5e1094baa5d76640f2361f843f25854bd6eb27f637ad270813ecec2fdc6a29c4a868364d3263382054d2a2e56098407af73501508b3ee379982edcc382bd309705cdc6c8b8c10481aea74434d7ab05c9133a3863b8965d3bd0581e87fd306f1e3cc0bbeec3d268abe0061ecfdf17c1316b6ce3302f7ee220595627fe7ecfca57f9b695789f8b459623712123fcee7f463f2e9abd3bf5480421393795226d3d098bf861c618be3c572a78ba7b3db07cb0bfa867fb40271a8e5c7c249bff8114a2b513a8d9326779756e6b718a3fbdbcc5f877396f21b336c7fe4b91578c3f23c36831e609b0aa6e7302412fca8ed7fd30caa1cb59c93f9bd11307c286f0899357b54ae4a61c2a65e448c90fbe1d8bea90941aaf32fac0e687c79157902c665c313b0e130f90e35aa82f035a22574c414b286d4ef01329ded7b5ee0ed211213c7f56f7e36a1db3b1cbf21a38fa2d357a3cbc39d6be3c2b01b974a8d9aa13a617c05b4d4f4b66405c17fdd831e7db7a6d516ae0b87de9f4c3e76b9501029e05590b90e440809edc00b84b8d318aeac352db540d17b4f382585381288c8f88a66a0be75c2fab8d046030e1145edbce64291783faa6f50897c00a10eafd403b0a2ae9f3853027d0d24bd0dedf15543ee8f55b967cb40b3de41f0b20d9adf04f2b5b4df77c3e3a782947bdcee81848362dee2f687895a9185638c40129a5955c7acbd341047e759fb52a0e9fc9e4cef187b68315e36debf0bd9ed88eb1f3ddc18da2769400030480298f56e6ba68a40fe7b01adc640fffaab49c8f7829a76c15cf12cc87591d47a0d182777f4203bf683b5c14255c0e1218d649026495aa5c9eb49751dbe8f2528489523641dedb0014f88f074b7e34eb54795000dcea06a427a78b90a7d3b41924c7faf8aadf87555385976d7b4f0d7e3eed7b4f69271e77a1bcd983617901ddc27c4c83a02861565624c670e8013ad05d8dc14c87f12cd40e78207837b293f31e0c3dba2095e17fc3559b087f12bc0cdbbb1995aa72ed6668be18bfb82660d7f2db93101b5b6727c8cd144e5e0f808886088f4ea85d0c93ad615028ec8e507492e62bf4f95632b90880e86655e12ad64c9cce3dd6bf2c3ce6994fbef13a3a8287e76ba6e9d3bf5f9f0fc122e723288e386aed6cb43d252dfa450b9618c47791d9f844ad3366c7702983cdaaf97b73f0df8ffd71262130f3c5712d9429802eeeaace0f06f39dfb62e46432cd785c4baa7e7376f245b91bcf0a7ea4de1e91bcb6e7a94591ddcb593ca7c861c02b30f343b79b874e64a3151a22cf1a06d9aa730f911e82e6afd2f41c280441abd099e41bba9d5682cc6c57d30adfdea06a644b78f3212d619ad13568c640d1b656fbf7cad68a68d74b255ccf2f5973f63e0b23ccf6b84c645f5a066ee105030f2fb859e79c8393d918530836ff321400391bd076d8055bcf84b407dadbb60c7c1ddd9290dd16f82787726ed29d89f713f54935c091ecaf1b9ed74c9b3207adbe546a4aa796a1ff524cb652014daab2fb342d305d1636a55c6bc0ad4ebba61469aac614f6c80c6f66e487d8e01167ae8fc02f9697960da6825e3b0d8ef2875b4200c0d28f573b099e951ed6e0baab47c7d087b61d1e433f333fa0d204d83a3960021a2cf189a59ab7d1aa381b18b970579a1643d28fb6919ccf5c7d98d10919fc4d1bfa7de31bb5cb477d3f6abdefaacc30a0332b59792568e5ebb1820a027c2d27007ab84b9431c9976e181d11c88571e49d4e08cf9b2819f90f87db1ce967830a74034f230c0f329cc7ffcfad9030a50ef76f86c031e338e7230b3ffeffb36d0eabf171c3e9284ed548b5d3657e6bd94f9c6b51381c4faf22ba3716adc8befa9584a44dde482f658fe35aa37a7c30876e95526fef9a7721aa1ba942ae42582a7d4fbf503d123a7ee17754e30ff6e97bb89d7a7b9809eb7899cdd394e27a229fb7dc38477b1ab20eee810344650d10f0fe0ff5456c7bd6bcfcaa2081efd79193342832bd5633359806173d52ccda5fc7536657e5ccc8d57893bba4da0d38e0ca858eb26f9f3844b65f28233e5088d3c8504e21d37f5a0e10ebaebb8f6e7afd604f32302f25dc232cc28116b47a32f83539666c07056ac07433edc1d15567616a63c6a5f0ce3afa59c7c7faf4ea5f3ba0dddfa849488e71faea06fd4b6ef32fe7d46aeaad5a7a9e57057b31648aa02afd04cf0e8a5eb5adb4e89c1ec28d9cec8a6ac0e9f017e066fdadb7f4d88e58894562f4438bb606d8f5c8d7bc6cb8c9e133b2e529e6bb4edf950733bcdda114199428e1e2e564fddc6e3398c4917da388abeef07c383fbfdd736970dcfaa715d75cae14ba72e6a2e256bb06e8d23626f1d92e60861e24be263e6205c4d76a57ce3de53eb60c8a3c7182869f2bc791adbfecb8b039e661c2f67f73bb72f034a2cc8fb10bd46546134c5b2fb8dcbc234019ca2dafad0bfa08d3b7b24f9c5d0a9bd831fb43f02a6c3bbd248e12736429a62402b7659ef2d4a04a56335dd0833bdc708ef4a054db851e68e47a70fca38b9b096df95370632897582e3668424732499a528542ce5e85410f282cc2a295d84f32207b8ee0622b31c3868015d01bfe5876a8a89e07918270a51bc94719c1fd5d6ff40abee638523b1100703f84003437496907e096e75f121b0b190e0fd041cf5a699d1d2861dc57ecad58a68fef30d0eb91695ec702a66a4f3b106ae032a5e6c318e9a7420bd5448fa826ec3c672c9388535aaf8a85e1dd9809c7dcc48686d4e836e6d005c9691e05180823efce0ccabb7001a0eba148b963e016991ee4a8b62b4b0c97e212d6670ed0e76597716df013f6f81cdce3e3db708a1225510641920384ee652c6375f4de784e16493b94dd0c4b07aacf8eb06d546301f987fb7f4dad3a9a2f88d782cc5b41d73f34f86eadebbadfa236e1c8a58b910e1756557b6f9432dd81dbc5ffdfa20dd5b11a2c06b0007e8cf549146dd1f8122af742042f2cee4b3d7c96d1e302e50ee124fdd86e0f21ccc5fd5b78a9c2b530159e80edc79d2857117b5d39943a7b204f9ede61caf7c58a9ab397f8ffc201973eca7213d0ac49c152b78cda672350dc569b51c680aca7ee2032f21b907b859e3764aed50fc9d7efd4773a9833ca41d34e744056114e7af22ef3907db942966d37598a7d0a52046c74c4f1eb61433aecd7ef322fe5642ca57505d512d9833170bb17c4e64cb222b760ebd505f42d4e7df9485b6d134c79ff07f187b8e5c08d51e68015f3d0c7d48203125814ebcc6e67e3889a8a11cf913a1566fcf7453e00b4e6610161c8921baea3d1c32ba56a35cfa753cd121cacfa601711123b4f7d5b4b96592bc72339af5bbc9de1beb8987136f449ccb4e06792475f5c75fb6b65ee8ddcece5eb8c6cccedb93653f747534f2b093d137f358e6fc06814d6fdf6426989796d83be2b3d7fcdbcfa0a157a3fdf106da55a5c3fded76ac71c18c87f87d55b363f3dd9243b61235d1a461c619774713848cbde3c5b3e4f77cf449f0fc5aba04146400d6ca3568d36dd0d54f1aaeced34d3c8a5fd9272ff247961d99ca7098bd26828b4fa0d2e2d7396e81a68e59d256042bf4d4d0c929ec99fa06f7e1f03a8f874efb3f6b37172e69786991e025737306abaef46459bd405234d5d53d88c81c27d6dcea252835a6d4c5d3f441f11437cf9386c6428313fe2c9ad0429d65ad206eb9a352c57102a5c9ec546dd89ff107ff7f773f6da3a85c14f360c43260e974b4983f23a34c1d31af8260f154c1d5398adcf8dbd892db6b106323d8c228c476a871f4d88ef51f98bdc84993ec94abc286c626ff6ff3bea751361062887b072ec61bbb10e42dfb09277678bf4210e6242b42f2e6b99183bde8d0c6fe70b5a02e689d27c38b4ffb9e8938d058591a1d1eac3d13628d71569f56f37dd1e6adef88466d57010ff1c7e41fa76c3663c5b508168e522df1f43f1196f2c2f6a37ace7cb963025785697d91e57f3ac403c3c35339eeb7499d71355b824b2f6b8a91e11ef2efabd6494008bd95c350bd229dd0c993d78d404f6343f0a62d578bf1f964cdca0f0b0ac5f6a6e12a93a9e075643213713f7f69127b3da0086ac7147b309d02647f1f3a67e977749e1e0f425b12937abce7e646e21fe581ebc5ef6c2b5d07e4b2bd70c1983114c897f7d3450388c9deb0e55fa53b919dd0a58ca19ad55bd806abe175ed7490234d678ff0c57ff77aeb62f4ba24cc5d982791b9eb77ea6801a491ca1dcf0296e3ab8fb4f79bb32bf9559766498b632681edbbb444c786cd056706591fc3bc1d0dbe4d5f7ab9bf65e6aa939ab97308373c07797cb26a136dcf542672f9e1e3dd6ce3a22241818cf9f17028af0c708419a753c28ae3fd8748090568620de41e8ba4df75ef4f36ebc3037767e7479ead703789e6a2eb2bfd36083d0f7a5e9bd23768df7bd2c9fec3ed8538cce149d140af821568c67ad153e077a97f68dfa521ee996929e930ed2508f6b201f16205be15e1a78c52485755fe7f660d1f89a1539bec6dd6dfa8ba67f8d9450275c6753ee9b74e7dbed590b350c8624d50be19009d4345af4e6815d54635db39e97b4eeb90e6ee5d36d1648bea3a5d21f829733f0d9fb289bc25dd0b11fcc0030e4b6aa4e3ab4ab8f0ab9685b6727a5e3be0dc584b2bb5a0c2164aefe93ac47faedaabc55b0d9eed01a2eb29ce115f6e8a6570f881d7f41db34b25a1b37051e1480b84983dbc4ec0c8a0dda3b98d7f545345d97783c38caacc4f5586dd332ac6f7a0c14350dbf8acc6ea66dd8ec336787978616c47e901aeab964f257ab1f2f25b820ebb04dc34f2b5f2d38d3d37c35a4a2825e99d8292c47086e4e1478194e69e13b17379ddac201b76910a083616b20892c74d2fbed68cabbe7609edb6ad6f8ef579557062b20664376580ff32446ed724f03a25b9765d4c74f05ca8c2694564b1c7f9d2a5021e10c02dfd39d92617200d57518a59ac3730eea9ee52aa1118448ae44c85e877bd60b834d16982911a8b3d81065fae7efdc8e5bd9c6c3ffe62930815c8f1a364fe37d9368e76a5147fa18c83779d299cf0b03c44e891119b8b9d91b9dc968eed66d5e9c3824b538f00212dd19dd7726f98adaffed45948ad0960b82353a4b99d6c771157140b6b99382f6fe8894dea0a4fc73b7589dfcae1c16b33167486ce86e0cf57a87d9dd6eb4d9dedcac650db2ff76511977f7d469088faf37624fc0430733890fae41a99b0ef09a8d5352d28417f6b27f4235bea67b652d8d8f0df4ee322eddfbe2b3438b4961b4fdf1bf46cb65549ca67b9986141f165c5df303d9442d0ba8197584fdb1a7cc46b0c3c91148d1af2ebb1e2725a5ddae197eb124bcda34849a9a8d70777fe4cc4dd5e84d8b940ac7a32c4ddf8899d65b1dbf76d348637e4cb8da6eb59748c09f6288af523fe7a67a96782bfd7d2e9bcc4f80cdd5467d08bd9f4c299b9079e5d1d44c8c714697c8dfce7e0460b923d28b40f8705bc3afed3ce212c6de80c4d65353b782e23c960af49b53c79d645843241d5369d8f41967ace2f5427f9928c3c9bc5af56809a7c4cd264bc0a30889c1a7d9e1593038179bf950d18c80d3bb53c0ebadbf2a8320d8b0cf2036d6b69df523336451655e8f43b8795fe93b404cb110b9b608c3db0f8a166a09d75c50b42c31f37419d56e31237106d67682b2d11a5fff1257b14ccaa4896cd61cb2a802e859e819e3944c82c106e4fdcc6fa7066bbd2279898eb7e083b5619e189d767ff5a44d33b0026616f9b2f9d01936a3e812a2635c80cc026dad80467cfb3eacf1126333e24e28dae65a406bb56bcc6d6e5c261574dd3aa7b19a1f424410334de9bb690769c8ed36754653e1df074a964510ab052d455587f0cdd741db789e73503537856ee00208e9bacfe3ede446c849476b76105130b77f3f77d6835fc44705acee732262e7d7149918c7def394a5feac6513c69f07d5db07e9a3e81825c0a94628f11ca9d5720e58bbeff537c13cd34b228235705f1c61ea995417d075c522dd46bca3815d1f2962739ac69250310de829af48bf2a934ae83236fc87af3de079e55168c6c05311fe1b0de0f39f532bd305e07d6d66d1a737c0f23a6796089be94f4d209ade250221258e29896a7dcd48ee48f1b566bac51d49a5897a15fe6b2080eaa5989dc4e6022372a639fa6580df0469053c7c37c852bf3b6eb7d9d4ea53b27a7e5bac7ade73f463dac5bc4db6dafcb9f36a60a2ecd3ab085daa1644d36d86265d5d6b51f8c79d53c20cb6343e3a2ef960c10c5ffba2cf5b0914e1aa1b5b59867e7e9ec60a96c065136251465a0437642ebf0b1fc41e323e5f9ef8448f4218a0558ca7c1133023e07387614bd71baf6c1ef6cd9a8b3e0cf260bcfdddc03e79115cfd1e4ad47a64a82911af4cdfa2990969cc8de1208b525d7fa11a01de1648c2aa39da9eb299deee74a5503649ba3281e1643cb5540206fba60950de65b3ac14555bcece917c9b5588e63792a0a1e7d22ef49cbd8e103a0fa8a529d542a63a1f13f05543ba67b76dab69c07de1a9d991ea2965c7ce04a082aeed57c999edce3c1013a43cf90b241b287236d967b8a74f72d258ebbdecb02e00d9a32cf8137bc690beec31735f72c1a5392e862a1a06b5f7034d462f99777337ef0847dca1c241f884f910beae362d350a63db40407407b90ce3ead2cfe9abf70a6b64531af3229e462ab2c337ca8e30e238d80ce0b8bea15c59eabb03f42d4af957bc277f28eb2a7fa1784b08d69d2571aeb0605d0e266e59857ccea71ab2008473e54c504ce06adf4bafc571712c3a58684d69eae4c19b37fe575afa41938c0b551e2ec24198200570894e6912f01a8b19c36b0aa925903369af261af9c8d080054b428ff80e61b38dddfd967be686ebc8bb0ed90c91d9991fdcba067cabc6447bb4913173853a1a9a3ddd979030e723aabeb23045b59776d01f4564c2aa493740acfb1f4d102831709d64f8b290954d59d244855325527f8e9c0e5d2ede1ba1579a07108324f26b685fa12e416bbc529c14cfa1662bdc5ea405937d218b6e2ec267c5d127d02b7027dc9a39a32c7779989058790a4e5311bc70d95a04a7ab4ddafda938eedd7b2d96b701936b25913ab69d78ac1617de16b038e9eaed0c5cc4f5e81eef0ee5f4353a659f76dadcf1efd53f3f9ef02df4a47f05b7db1be7b09a87e3be038b2893a6b8c2ddadb10b1323c2aa5d6b2542cd83a33614f9f4a19a2444cba5f5fc9737970f1e801a4b7497f48f34d408e3597028201d716aad68dce180ae115ffdba79803bd18a50deaa87d410cb0dca96e44315f5c2d6ba159bfea636c868685f07ded20b51dcc547f1258e48b67349754ea74faf446163735aee5d3e2c061b08da731063d454c5cb89f6b1cae45574ee8c7463addec7f69c63831afa053f4b900f1fc71da0a63958de27dd51b5b9de27d6bb1d807b1823aff67dec4f1e811e081e9e69511c9d61b52c87631eb04916df6b2efc10e3985ac20816d8b67c6db93526730605cf07b7822dd0a7945384c8003f08d88e856327e930376be920c0d7d2106304b83cd1ffb61a7b0e59bf2899b8bc9e6a13e913bd642e1a2295d757e3ac35877c9e114a7c32877654420d9359f28229c0eac87a543f501f125afbb27797fd1ee8ec4f3a104b5b0b50324402afc943209dcf90b0e1aa9b954b055ce1e66c6cf38d2a448bdee074487106b53b34063c368dda7223f0ff1ecb4bd6407167ecb60307e9c4ea91e85d23608fcbf3addfb5d51ee12bc321a396a3f5d23d3d99863c5ddfa122d6d64b52a240c314b929826f0d0f9dcaa8531f8f003cb92f8642e9b476d759a34f4ade67fb1bbd2f7e7bcf410751585d593528177b775cd4353187bf2280f26c53ced5abf72f63d54f7bb154be32f1687e1a567f77fed9ade568ae96f1dc5da6ef9d266f3a6f2f50e85b71532bfa715b2573d2611837c3afb5a1630e750fc7e156867de5bc4dd51749701bb78dcb84e9acca62a6260f28454692e83cf5e7055f44f1b0d6e1b8831a36b0e1812d689fb0f26beb597a4c73278fbae2fb252dffdb4ae9bde84907de5ec3c92a5dbef3a3b39a7ca312bbf35575b2239f471828f076b13f645d4eec27a085e52ef6bff1600a082e46a66bfc23f174a46170446a7bd0914711272f7a578bf8b7ea43f4156b512f0f36318e26e984fab482f7597fa282bb3573c7a0b4c4921c34bfcb5f170c41eb9067ec12cf0cdd55c066a53b6eb8cc6b188534fae7c18ad75c6c61bf781f78c161ea5f47a96823055ad07356fea43ada16d358613ab6044ac3462bd3ca49b37796582b27843510811c6469e32de991df0721f232bef2802081cc5889487a068f72cf5316223e314d2a5569d8b9fda9344eb007d85685079ac45edbf59048df83644d200608c45c7d9a4bfdc902e93a19e30826086a6277f92be771b3a0fcb938cf4b71f98585bd9889a50a77de43f12ddf55a8d6b182f10ec3ddb0505110e24de9839768e74a52fbadf29d31a27f452faaf9e134d8e53753a2696c454b5a9f896518dbd3972c86f14acfa4bdec29ac8d7e1ed548eb6695e41d7642e20b67aea892fb2057d8cf41a0ab5f4343e605c5e744eca582434c14e5554b1bd1d51ec7a2fce343f0ae1d9664ffc259515566eed59e4e1706ea56f408a8e49be237d21d1acc6b7e2e63740eaa8379be2b4eac7be79fa90d00bb240b679e291dc799c46203f7de8ade95b4082602bc02056ee96ef80a06d5073990d2b67208ac4b8918a716aade59b948dceee8b156ce68f48e8ec28e8fe2a39cef08213e40ff1b230406098277083d91ddfaee7736c02622f821015663679ca0f6a934534f7beff6bd0d3d6adf1d3add27fd9774967d5ab23aa295c60a42e4f40494240e2238dfd895aacd52acd3e7829619716b0835e0d1165c785c893970eed050d55e33dd919195468fc9a7a18a404c7a69481cb3909165b5e1145549d89702a44f1dc08e81efaa59f551d2da62f99ae228d406e19939bb516b0cae98702f7ef5ebc7d4b1231f662f7b99cb93625297cd8820b97f5fd18fc778444281fd27359a5f2e924775fbbab6bc651152dbf05a00ea93b055c528380569a21ad51cf6f76d8648cca9c093adb60bb081cfb0744b21d797994e38e7bd60bf1cef8fbd61cb017301a2de2b7fba0082650cbb15a38ba44b65f3c464a3f3bef49c827fcce196e146f97a09e0c230465fc27e0f3e1b2b4a2fd5123015fddbe694e1ea9bb60709882cf791ba32fe8130458d16935b3db9d8a33bc06ef0058a717d6f2794fbe5ba1f754240adc3416b0e34a2ffbf47c9a010c97bf3ac29a13f89cb6a7db3e5aa76af3ffab55d2ca240011d2bddab34a9c7f55320186bf993fce7837fa87442b54972e487c9ca3419540696a7178767890a23fb3880468341ad40606998737c9cba3338e4f5a844c7d54fcad61a5916e78972c08fae92bab9be182f4ea7447ff45155b59f280ed631426cca512acc270a47e311f664924744ccbd7402de781ae6fdf6af61def7d768465ce25378d925d17f7890287a7acfdf8433a52b4cef2437c392482ce42cc4372f1cd94350775b7b40353b8e01c4ec7834b006803e37e709458c625cd970bb72c574d3be3f9948f5ef6fa3eb846d4fabfeaf86b50905d3dfdba14aa6f421684e5b6c31e1e2ffd2a22680fba8a3edbb7bbc4c09938876429908e3dd74d795a2c9d947ad1d9ed51fd14544d16c5f9fd96d6af03bb7b8f2c092e7f5a4915b0f50bab079fdbf2975d3ee890852bf77373d1cd09cd55ef9a35f6a444231541ae266b7b96258a5829cfc8ce5fbc5c34a0d081b0bde605f9d0344e824756487a17be2e863228880bff12ad09afdb6441a01817f3701535500272a7e475abb4ee46f20b4fd1f06192bc5e4adb1a928765b368370434b6f9d7d6a5dce503a84ca84d1495890bcf5271c1442cc337f240e706cba29ca0ced3f295edc6e5e784a859665f82dc5c6720f43294965fa49931dc270ad44213345eefcdd708f2e79b6d380908b4507e5f6b03799215aa9b18b32be7b44bcbf7fccaac1e43e508c4389beab421300651346d0b66657c80a18d52d86410a7e58186e2ceb98f3ad1cbaedaeba76ce1bfebbdcbc757edf0723fc5c3fe9e948afff1b2f6cbd49a11a3be9ed07eeee9842ca1c81e98282c38dd3417d5b0ecb8c769dddc4840aca39103137c5fa5457b3f3ca875fb850becffa5082964a9f013354b2418730ba34980ff4ac288a967b6adfa56daedb0dbcee9f3442784a4e745c4922c908633fe7cd204ca91d6a9c40dc10744fb9b8bc649c76b6bed87b5d3db8fc7f672a64461fa453cec203ee0473c2c6528a4da900ee63938ce009c0fb0651020cf6e88078cedacb5c9b41ccb85580ebde7ced33267d754f59cec97853e7a202740c529cdfdcdb90f6991d9d48642f4d929ec7b0a13f5c107c237e006d5c31a1ff94a3240315e4ff48be341bbcd11ac2221d8da0870792f8a8e1b7ffa28c0f3f9e8b557a064364ece8beb8d39709dd185561bffd547c7c83411a78fe207878899ce1ea8190c369331d8ff048328f38766b3f8164e9c78e71ca9934f7ead42418bf2f4322f3c7216673dd444eb46cbb7e486d093e4a258dd4ceeede62c846f9c6491d321d7c37d37f445f7f9672d5051833c8a0a0970dddcae636cc8c3dbb85161843ffc98371a651e09706391dc66ea06f8473b224045e9f8babefa311addf0bfe521055cfa74906ba7076c7f9d86e266e111b60c14b7489c6c34bae72622529e77664cc517a5bd1698d067d93786e30ac7480c0b6546c11df4009d8e54ee67f39d94b74b9a6a89fa1ec40263554fcffc9dbb62b15e40041b7cb05e93a7e435ddd092de8eba3ddd60920e5309f3d3b9cc018c66deb6debadfbbf77b4387ab6a4e41dad3ef97987686a8cb65779257de41a61dfd96a6a4a7b99258e3ed7861929a060e57e85babbbac365ddaf58c1b221eca46b64ad108712dba002ce6ef938341eb77cca40c24448bc1bf0c162b8bfae0544b3c8e928b3e38f2e1472aac9fc31b26be0bf9fe161c98c237a3ba8fd43ffec8aa52ff4063f1324b692b6d8ad4dc446696bea15bb9b1c2957c2d2a5a77f176619e53d941127cf07d6f2c7ff6e7e9b42f13709fd533a4ce4f373f319a28f34ed65b5b99851eefe58f7a5b8965502b6799f6f2ff3fec5f958ee7d7dc316178883838048db1c88d5cc31f046e9e355723f345163e04a86cac811e7eb4a50cd22dd6ebea307cfbf9f218fd8c3c8435aa28ae42c32ad4f817b9bb4b944f4d929afbfa873deb854c1e7803e434363ac41a46e4b5885ed740728470f274cdeb114538e365d210cd58cb888fe1f3ddf135a83914118ba9799f4b44ad0e6652ddd19358249b104dbc0837f9f1445be017673f37c0ff525e4b1673eb730b10c46a701ea7af458624c40b92b5369217c13d4a316925e99874aa3988e1adcd06f909dc6bc39bbc047eb94565e2a14c69d6e18aba007ccc442bb07107f93bd0101f62e6dabdf2ea907b167579becf7c3a866877afa9d4d0f4abb575b102b21739669a9ed9186e02f1c8df97232ac7010dad12a7261e1a3924e310e4f547222c3dfb37e38c41410b2640a0e9f01d55dc5aa228c842c8981b172d801362a0966726f626f9e6317fa1a7aa8b0308288fdcb5015d5216a4f5f5c51ff24b459a750184ab0640e7458078704aa3d329273cf100591bc4a71bd99d1bd66c12c2f8f3702804c3542d6a45693d3de92fac64cae68db58e694ad6993537e3ff2b8c4ee00d161515b99472fe6395125b97df62d6b17759ff5115c6a203ec05c90acbec914840189504beeb2d193ab4b94e82292e06810bc2f92109987c9152b3ae303a6382a6cf3fe2cabf5135bfea210d3e13dbaafa20f8c324dadf90c6c92d7743285a4e9fbd7e6b50bb1faeadfc5533172f4b03a0b60be09aa44490264b74a8f04b6bd8fac40171cecf34036257ce1cb84823622c2ac852466ef9acec7d73407c206cad39d5ed9c613b9af800a441402fba7f5c5525a25d66f285fb9798dbc6e9ed8dd1c21b7a54df3b5ac8a2b2cea3bdcd21c5bef8d9fb73fbb8c512961e4390caa210c2e132ffddc11cbb661d185b2386ae8779c8e036d4b11f7e97bb8901ed942d88ab0e6e6cc348c0d29f3deea9a99a18ad104542054e9f6fb20c86bbdebe233e2bc5235ea112f511325267ed4d347f1c3d05141233f3455d68b5eaf588a8d2f511281cc7767093b6ea1c58ebd4d7ff03b2e0194197586041390e544b7c78df8afbf8d3c41e66167f20938a7955d8820ce8db75c9271a5cce539c4f4f1b8a487097581a713ba4f966faf971b3fbeb2f4f6194081d25dcf98027d6073c0a9e230d30b91189c2ca250d5a0688a2dd74425bc14c92d46380ee4b52497e9238deebd5aff1f29ed9416d2ed04a0c91fd1b144578fdb01550bdb357e6881fbdbf0d3194fead0e3704842532644a0d30837240b34fe88a0921e96d54144bb1148c23302655f351f56ae3ca547441f15ed1a251651ed311ad5227ae7ef68904be08a24ec5db3da4d1f18986a76f699dd514f4261867ddaf098c8ef711beda9ca730f6f0dabb2671b1ce597daafb3c18d9adf9289a72987f169fcb59702ca138cac6063ad9f3650c3c6b35fad78e220b3f44fc4a78c5c6e5fa042ed9930d28a6ce3026446e7504a70a1a8da1839a4158768723744d55c84e12f9041ff41672fb429ddf4c405d83476e0eb8c5f9b846b1f2b0d4d5fee4285cb763123c0d3703010b6747e3c1aa3b0cc887335c9e1834f6230213dced07680a0901c1218613addad2a3217278ca029960de14d0f01eb7974f17afd0057dac04cb25a7e06d4c7ac81d35b7b30325ebae8b79612abba22b88527467a0a484b4c2574c28ef1d837c1d7f07387a2b1335501b92a22ed5fe350535f9cb210b88e2b51f9d4d49fe54c76ca40586f69ceff74027c68e9f2ccace53a9df9ac2728de835b6ab705cd429e0abdab426b9d16273a75971575f4e8fb3c96f2f1a1f069aacfc09c9b959b183e28af95b582e3bb6e079319cd49de9abc6e342cb1241ec79f794c692afb07ab306c99cac83bf7290fdc37239da8003217d91a5513fb2d761a2638fde536ef04acfea1bd883f73dfb42927ccdb09682476a4d1ed748fc01845d3d140b6ac719d5d16246939b5de77aa113f0f92c2aa4504f30a5eb84f81c9cf2aa73925205214dd54527f168ef01ecf95a1db25ad5f1b996195907723912690fee5e056a2b9b76c2f95d7b00f7920e540fda126cb04033873572f8339559b0d947e67e4348ec6dc07001f6984d429fe060bfc2b52272e6ae1c731c87fe77b56c5ff56cb75252781e9f69a90579bbda4d590275ebf7bbf2a2fe8d8548d621c1bcfa71a714983a4057387d5735d04a69517a5f33e21a61ad95d6fba71b14a7c9272ebb571d72f3c81ec3cc53bf3b4279d1e3ac95f7e2dfa4e4fda029891e50dff5af1c132822088049429d7445b822f808c7d4d1fdebc1d0091b6f29d68560ab151fef94d80f02c5f21478bdfab3756a357f4884d43f804e5d9218cd64b8342f0e4bb18dc288c9d4c2b9bc83a8014999f39fdd5de60cdd762a049d0a9785aedd9a7f1529fc04f24bf88274ea9e00543359b2ab2a5347c6382b48455b74b3282b3fc840d032a2ee711c1e91e5d4342b84d91944b1fe56a8e88a032df9c738cdec302b93f71ad89f170044fb3c220c43c598c4c706befbd722785990fee0fa212f16344450acef4270b545bc4adc20dc1785d4a82908ef897e8591c87a8891978f07b0f499b2ec36284856272d21eaf58b62475c5728060d9008c0eff49627bccaf5461d7bd4cf844f7684e0dc9e19d6cbc8ad1fb9b10b675478a35fe0330c6eda535185869a47260715ee45c4f0bd6370c6abd284cdb8d7ef736335ebd16f6b9022dad9c41c7499bb795fe59664cc8c535bc18fc7de73015008dc71a09476ea59dfdc4ccd3fd19837faba50d7667a6ae6ea46e2265890a5d8ad748a59cde8ce7c2853498d07a501b8fc140238512fe9e52807b43a187fc06f58febb0df720f6dac47a14c7e1930de1b0926721bac79950f4735c47c45ec93627a54ac49fb83493c46a4857da28708747f43796d1f073ca3cb23e2f4325bf122c0fe8da0eff4448850beb9c21fe2470cda12fd8e351da61f1ce0cbf53da3b7064c1b1a8ffc892bc682749f0675ebff568d7f21c87bbf3e2dd962af0f0372bb9a57f30fd1643a8b9c0a80b36db54a31e694081297b52ef3fd2122fbd70644b45c0cc27184e94ced98822b37be8fcfc63f4a293ed1d0783cafbb983861f7e01af11f38f32f4d785fb4d2396b2fb408d0b2b88b645458822b481e4e59657bdba3647fd91d1f51a36f29ce3b3b47329b65c2c1b9fa08ad2e36931526a4cb76212477aa1c1cfe3890307837b1ff1a8ad9efb64683712a33dff38a9040246ef2727648df35bf80ec51d23615a37c14adad67043dbae58c9e0b3c02095d7e99911bd821ff41572c00ba9cfef1ea5b7a38824bd6bd88e836d7907bc5aa693ba20c67fc33c78b9ee31ca8eacb5afbf4d1e119545253ca9e98408ae153709184f7d373a86d041a78d30e0b74dc8f7392b1355f572b7ccf8773beba5eebe786897093107e524b0b3843849206423fec07fb9f32f1560cf0c96589b0f46786e5000354d3c724842567958b2400288c261c0ed29861d504a610e13aa28f03d5184075d4417dcde8e1d868c1cff25aaed6447a70e0beca7cbd1513e3ae92cbfe57b321eee040efba2b942883c747a16d93e244f9b63084d3ced24c4f82fabee77af2d2f53d07fceecd8aff4cc787187bde4dc1f75b4378920e76d08a2f2a73a35f498f733c71a9e5a977946caadc03ff6448b443e5b3ccc40eda9602c8b4ca7002e626d8d4a322d755288fb5a0d4d0a54e794ba9ee7f9a8f764fc6946b82a6207db455d84ab36e240511d6f792d5a0f5eceaa243bcfbd09c189324db82f5150851fcb8fab6da3f53a75205780a96793995563842331c72b8fa768a123e463d34577a4e741d0046a444fbe7f9cfa673bd20215c5627e0c22628e4fd9672d308317d9be5dc3cbb482792352cd29dfa784d0eb6ef090f4a9acc8bd795db1d055ee883481bd6b7078ca21024b0deee2c0bdfac7645edab4a94f11167f674c1476ad4b9b5a17d3e7e52dd6197ddbb65fd6022aaff9eb36109ec260f91f5440478234f282f9bde91aca9ef7b6b472abc8a458e88fe2f33499eb5adf735c89f6246997dd1ff3035e7851e9bfceb1e9e8d7cceea6c3427ef5a6082a726db6e01d58bc7caa3e259cd88b91bd431ae192a7021852ce3c92daf142e8d90bdd869addf9bd0b583e6884890f3acd0371b277d81db73a01301fed1170019a37fb23f9bae83b58272fea2c4685dae21aea884fdd1a42a08f46cf382855c33869348dfcb14b816be3257bdf0977e83c481e9fe95e741e2e73df5fc325ea694135b9815685a00c7162151c2ee937b4196da7eedb939ca421979e162643c1790b7e6225aa54767a47958daf3752bd11449adc0a9b5a25fea13878d32899498e2b78c9acde6f4fb57ae235ca57d8164b5a252871353e9a472ee3118db9bfff837c834d398bd4b844cab672fb8b2d3f867c531cca881ffce2443643e57a49e6fbf876e6e1a6c48b793e65ff3c0553e0c44e995f44c7f0780932162b5d76f1afcf8fd72f7bc5e08790b53b91e41f226c83f9172d36b4e337df9f29c76d226e3a3dc1be3a004b182b2d10c0a945ce743db084939cd2e88a3a5054c4716e49250ceeb3194801bd8fb024c10a89de9a30d4b78dc802651bd8e1244575ccc9befc8b02477785621e9f39157636784fb03555a81e67f9709332bd6d32e4d4c38163ba81d0352974ab5a208943e77bd67f3d18bc2d0b585e99fad0009d5e65d88c1a650f22d5bfdfe9b1f629294f30ebbb5385ece86a35253fef726d6b5b1cd2e19f618ce2910d472e706ec89dfde79ace96839dd97c572c3c5b2b6136819c49124b6a9b2565354620901b5a11598c679e0263d160d4420dd66c378e2bdb823a673fb0901340ad3d086607f8a831ce88892327a85e814f4b89d0b9095de3519eafa5a96365918a9b354d173da86b5a7f645cb77f2985ab631fa8dfeb84e6cd4edce4decc97049d6fced1ff38716590527d0e64387fb11579955c4a1ead70b04ecc9840ceca9c986da14fbd9dbb58f1b513d4f125bb17963c72b09e51a55a8d3193f9affd0761f47a5e21194d8e4662dfeff7c190923e7e965bf01fba82b5d7a926e56ddde765f50f2b3b571490757266b5b06272992054e6e08f3b0dc3e571f3d0c27b1d69fdc907b50e759c2e73930d24ed9268dbff68d2cc354bb1dbb10b0cdb632b1aab9c7bb2f34989b4bb781902974979df1b4840354389401c2a78331efacc62187b372343851af8d3c26abac951d1f0420740f8606b722a130a9c18117c1e59b6cbbe0fea9a3ae007f384cb7cdeff8c1cfcc4355d6823e0646cb6e686ade3064a878bc95091875132f0a8e58d1bd263864947ffb048b98c7bdd8e3f9c2c0b54abed46387a23d763eedf58d01f93ffdb872d536f5636d1cfe4e4bacc6683724af932dfdbf4da4b64030f30d18b936001eefdbb9ca83bdf77369de93ede36e92cd38062f31c2e6cc51dce75b728fe3a0c16120cc2804a0b911bd9138e2428bf6607c6299f67f097779167058a8b0be76adb2c99a0ab08bf962af8396d34477efff9c3a297d9dcc033ba41b0ce5f2430a1bfe80e69eb95360d22909c9dc95d702fe4e8a98213c81c2526139f754878cd2d4eb39029b6329f80aff9698dcc037ad640dc453198281d1c662a740a2da8a35bc1141c636bd63fea300e038105cd3307d0c4df9ba4aef9317f4d58987186a7ed691509eb8f55e8b359b83dcd04a4c645e7232b15377e187f559f102cc09f4512154e76e5a63a73135815e81fedfc8d146cb901387eeb949e6a8d11b03e69cc74acf617b6ad201417a9d47af549dac5d073ae2ab2cce47aa9846fcadbda46d04fd28be90842f01649dff3eb3de79ff75d39b174ab5023bbf06735f75ddace70fd65ab2c7f8acdfcb0ae7e307f5d06ad48f574352a3a9a7867501cf51d4e6414f2da9307edb0bed211b46fec140574d326fb6857197b88a8b088635730fb2ef8a720213c0c94de76d7a8998550954a5d9c4d3818259a55bc5d47e6cefb0e85bb4289daf2f27ab12e2c60acc558a4c33d65e66e33e63056b3f6addbd12daec86e5592063deceb9c28bd3569e91db15887a02f75710b2e98ff0413cbe3aa166cefcf106a8cbfc44f2286dad470206ce3c85701ee4d64a74b3bca3a0d686085fea43638db51a3c37f9caee09a4d75035e8e0a15f67fe9e65cb22a7cb6bd5257cdf3c204be6391721405d5c84dae55b5d10f943d8a93f49aca9692356a0a25d896760ddf246d42777fdf6874936ac7c3e31d05d3bdfabeec369d2dd1bd18b5a9778217ea24d0879e2fd1f9699a0e9eca30dfecdeb2f2cf0368599259a9c4beda1b5a07fd9f111e9728b5957fc5ba22dd55891938c9de32f45cacb0ab69378813bce72f7e52471ace6f97039c7e394ff939a3f2cf6b7386342b15279544c15b524aa1d6a92ea5fcc8279ddee9ecb02a74158425733c3dc3de8ea71038c64f73b679d29b901b2ceda55ca452487b495bfcbcb4c8393aefd1b7e5a17adf7818d2b808c11d853fd69f2794f53218e30041c664db775af3003761718a51494d5a7d1d62e13fda452949c053451b799dda480db74fed229bdbce516bad4aae7bfebbfaa0d04c0b7775b49731d097e817c104f09cfdb18619e3c3857125618fe12317d1d1c80d3a32e5f818c481a76c01709334acc4060ba1e4b6c48b7923541d00437f153d65fb1f5d56179692e12fa12b19770b65774eb430dbd8f5ceffff5710ae688f26164ba1cc19e61606760ec65be80fc2d445f9bb139ad6ce914ea14be47759edabc0f314b1b5334a82683df12764c0bf85c49a49c7b02ee2be5c59d60776b68589a8479f01d5bf32251e80c7dc02a6611812125b3faa14c02539f61d077d2670c719dbac368b210b079e9f32784ec56df8d6f65dd574b9eeb647b0da13772d816676d49538707fe159643b11bc84ddda9d0816dbebed4e8e449ceb3682708d62abd10640c557f29573a869a28c05eb631b842edd0dbf5f00c84e3a4fccc21f87cc375ff06923f5680e420a2a7d7be7c2ff40dcb607085595834574e999a6654e8160e962da405cb2d59aa85a027ba9b5dfe4921fdc133defc6d878d4d52157b08dba14d51bbe25716493a705a9c534f557d1c14b13af3984ed6f511bc231a97346b968566cb57cbf91c30b82f5f91265d46a0ce05ca586c6b4be1d5dad7c424dde83ca925a43fd54738455d547a3c7ba1883dfed54c97bb26dba05c92e93bddff33244cc2a44a667dcb939742b1fea182c3c82896ea098faba5169cea35dd91cedf7c890f3ec3259b0f2880c1b4249d75e9a3b85cb03ff6a9da63f2fc012f91ae765394bd74484f129c16cda8616d2a0984035aab0ea7e57bf107c440fe3bc4060a5015612824bf46db492b3fbabe06903fb7804c4ba98788a4d239c268867c5b6dc65ddb050c68d4a4e0b261795ae5542b4d9839ede1ba8ae8cfe518f14c11968fa4a9d83b6fbf4d872306db8e3078bd7f97a6f0abc0078f7cf2f9be2a992bc094a00bfdeb687b120115a573aefd689d2ecdc46a5d8bd40843f383a6bb89fc77cf5dbd2619e6a24d63afeee23d816c2d83af934eaa648157adafa18ad7626737e94d3722bd62104a8c3fd74363d8b4dc1242f7e1e72f252623166945614db917800bdb788c5ef9e582ad03aeda7d65017445eb0b88a91819795d6603cc6cfe592113e5f04afa8c5f5567b8945740dea0f6ffa67319c311e68d9c5ae6245bdaefbd0c1e0b1ddeb4c0c93beaa263c76b7e3828aa7c17bd0af2d9a75aeb092ece4ade90ee25f30e4045f0dfee85f4aa449ecdf0bc9574a02b3125bc21767e2308f353c5c67b76563e61ebb0860eb4686db37a9507ab76ca52c4e5a5ad6a3132feb6dc9819df60833ce13ce6293556a572028aa82f987df8fecc3b95f0465e33dd0ff435593d9cddeeb16e1770e960cec32d69d1930ce1ebf32dbe219a57538d5b559099d770ac131c272339e433781b64c5976ed6c6cd62b448a19cf6c734cce54e5bb88be02d46c2855385dd8361cdca76e3eb4f6b920c1d4f968e72fe64d31dd1d958ccb97f5fb1b504c9780cb0f1adc097efbdfc48d5ee3d8c39f9d8b5632eb289493ec4a3a33017adb286f8796b0095ff0beb597b3278fa8e401e88f15da6818ff43ad2a0fd40f8663bbf6cd591ab17cb1e3d3d8a713f11ad594db26e79f76a86e76048620486644fa1a30176506558ec55ef3a714c5a52d6668dd4a7398644d29fddbe3ffafacbc413d6ac62cdf6569f5e5a338989a4475c4236a3c309e4f80a5ddc69c8aa7c66bb7a39091fad58100fde0bdeccae36eefc07f7f8ec4b8480b0f9cb64f0841a407b6e5d7d791de6de90efa086a8196552596f8ed92962599ca8e5535d7b6733b1aa8b919188c34414d18fd53019674677bb25ea1a20adf8f4f6aeefa842b29b82c05947a4af35f9f9593dc32b682de939d689b75f08f8a2aa52a248131856de2ad520a27e09ad7849066d198e9cbec95abf7d384d92be7d383eb48cf13413d1946ad45353d8f0165d2e637080512231d08b1d8044a8118fc47575fc5dc616864a8e116dba220f30529e664cb7af4f70baae51194e2608245e1dbf3779a63da2eb5fcb87032e0d3b199e5edd67d0f3f2b9a8aaf23cdfec8f9636e4262307da8cc5ddaa368cc1d75f7cb51cd5a63e2405d6a33c86092630f7d3e05b4d4b15b0d21b91c4e09177b6ae54832065a76aff91cd6149907fc6fcdbbf146e6b47343ffe610bb7ad3f3bdf5652848edf636016057c815c0363c7562970205cf98d0ffe59d1b5c9dd926a1fa6a98faaca8146437ac412314f0d6755de7a7bc55f1a223dd0d2897f25dffaef06d2862e038a62b5c15c185d1dfa55fcb28db1f90d914a00dac98ce38c083495b064287bc9de79e12481e0c7f44cf9944a1cb80d625e042375eba8de442af43824910ba8f5f53e85ab2af3926f71e14bb5f9258e7e57f1e82d038315ad4437d94924fe167cc7cc9475cf074ae9466acbe27307f1f9bd754c559c80e9d41a5bfa3abb0ba2c8cee2a0faa46f22f7f4acddc87d7f6e97add9d7c14ebed0d262233bc906c9a49150917ff23b02d17b9b6f23cddf3b304fa06e17afe0b0ee13329f3f0f2d33a760973e99fedc73db936d20a486c569ca15654df58322ec9de28e29f5b0205b070c013ad258f9a38fe4c216bef9aabdd674a2824c4bcfd38d521718b6c65c935cca7aadb7b1021d5ba342d78a4d5d327276d270c3eb4fe037a88633f14d554380ca70bdacb32c384a842465a1404a6b2271e281a273b6f081ff08edecc88a493d7a7de174a85511d1e608d623eb57f6d2301f18c20038019ae934e0a0d7b01fe40380f7d0e1280b55b4e68f22f1013d31b73de0a</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-xray">
      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好，这里需要密码。</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>项目</category>
        <category>确定性网络</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>确定性网络</tag>
        <tag>CSQF</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 文件系统</title>
    <url>/posts/241106182619.html</url>
    <content><![CDATA[<p>Linux 支持多种文件系统，为了让应用程序能够对所有系统不加区分的操作，Linux 提供了一个抽象层，这个抽象层介于应用程序和具体的文件系统之间，就像一个开关一样将用户请求转换到具体文件系统系统去，让具体文件系统去实现对应的操作，最后再将结果返回给用户。所以 VFS (Virtual File System/Virtual Filesystem Switch) 就叫做虚拟文件系统开关，确切地也可称之为虚拟文件系统转换，不过我认为开关比较形象。</p>
<p>另一方面，VFS 是 Linux 所有子系统中的一员，还有其他子系统如 IPC, SCHED, MM, NET 等，它们只会和 VFS 打交道，而不会去针对具体的文件系统直接操作。也就是说不仅用户空间接受 VFS 服务，内核空间也接受 VFS 服务。</p>
<span id="more"></span>
<h1 id="磁盘结构">磁盘结构</h1>
<p>硬盘首先在逻辑上被划分为磁道、柱面以及扇区。磁盘在格式化时被划分成许多同心圆，这些同心圆轨迹叫做磁道（Track），磁道从外向内从 0 开始顺序编号。所有盘面上的同一磁道构成一个圆柱，通常称做柱面（Cylinder），每个圆柱上的磁头由上而下从 0 开始编号。每个磁道会被分成许多段圆弧，每段圆弧叫做一个扇区，扇区从 1 开始编号，每个扇区中的数据作为一个单元同时读出或写入，操作系统以扇区（Sector）形式将信息存储在硬盘上，每个扇区包括 512 个字节的数据和一些其他信息。</p>
<h2 id="盘片">盘片</h2>
<p>一个磁盘（如一个 1T 的机械硬盘）由多个盘片（如下图中的 0 号盘片）叠加而成。</p>
<p>盘片的表面涂有磁性物质，这些磁性物质用来记录二进制数据。因为正反两面都可涂上磁性物质，故一个盘片 <em> 可能会有 </em> 两个盘面。</p>
<img src="/images/linux-kernel/filesystem/disk-1.png" alt="磁盘结构" width="50%" height="50%">
<h2 id="磁道、扇区">磁道、扇区</h2>
<p>每个盘片被划分为一个个磁道，每个磁道又划分为一个个扇区。其中，最内侧磁道上的扇区面积最小，因此数据密度最大（但所能存储的数据量相同）。</p>
<img src="/images/linux-kernel/filesystem/disk-2.png" alt="磁盘的磁道、扇区" width="50%" height="50%">
<p>文件系统中有逻辑块（Block）的概念，其中每个 block 大小为 4KB，是文件存储的最小单位。一个 4KB 的 block 通常由 8 个扇区组成，每个扇区为 512 字节。</p>
<h2 id="柱面">柱面</h2>
<p>每个盘面对应一个磁头（读写头）。所有的磁头都是连在同一个磁臂上的，因此所有磁头只能“共进退”。</p>
<p>所有盘面中相对位置相同的磁道组成柱面。如下图所示。</p>
<img src="/images/linux-kernel/filesystem/disk-3.png" alt="磁盘结构" width="50%" height="50%">
<h2 id="磁盘的物理地址">磁盘的物理地址</h2>
<p>由上，可用（柱面号，盘面号，扇区号）组合来寻址，即定位任意一个“磁盘块”，这种方式被称为 CHS 寻址（Cylinder-Head-Sector）。</p>
<p>我们经常提到文件数据存放在外存中的几号块（逻辑地址），这个块号就可以转换成（柱面号，盘面号，扇区号）的 CHS 地址形式。</p>
<p>可根据该地址读取一个“块（Block）”，操作如下：</p>
<ol>
<li>根据“柱面号”移动磁臂，让磁头指向指定柱面；</li>
<li>激活指定盘面对应的磁头；</li>
<li>磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读 / 写。</li>
</ol>
<h1 id="LBA（逻辑块寻址）">LBA（逻辑块寻址）</h1>
<p>LBA（Logical Block Addressing，逻辑块寻址）是一种硬盘寻址方式，<strong>它将硬盘视为一块扁平的逻辑存储区域，每个存储块（通常是扇区）都有一个唯一的逻辑地址</strong>。这种寻址方式使得操作系统能够通过逻辑地址而不是物理位置来访问硬盘数据，从而简化了硬盘的管理和数据访问。</p>
<h2 id="LBA 工作原理">LBA 工作原理</h2>
<p>LBA 采用的是一种简单的线性寻址方法，每个存储块（通常是 512 字节的扇区）都有一个唯一的编号。硬盘的每个逻辑块都有一个逻辑块号，操作系统和磁盘控制器通过这个逻辑地址来访问相应的物理存储区域。</p>
<ul>
<li>
<p><strong>LBA 地址</strong>：LBA 地址是一个简单的整数，它代表了硬盘上每个扇区的逻辑编号。例如，LBA 地址 0 表示硬盘的第一个扇区，LBA 地址 1 表示第二个扇区，以此类推。</p>
</li>
<li>
<p><strong>扇区大小</strong>：LBA 通常与硬盘的扇区大小（通常为 512 字节，现代硬盘也可能使用 4K 扇区）相关。每个 LBA 地址对应一个固定大小的数据块（扇区）。操作系统通过 LBA 地址进行读写操作，不需要知道硬盘的具体物理结构。</p>
</li>
<li>
<p><strong>逻辑到物理的映射</strong>：硬盘的控制器负责将 LBA 地址转换为硬盘的物理位置（即 CHS 地址）。当操作系统通过 LBA 进行寻址时，硬盘控制器会在内部进行地址转换，将逻辑地址映射到实际的物理位置（柱面、磁头和扇区）。</p>
</li>
</ul>
<h2 id="LBA-CHS 转换公式">LBA-CHS 转换公式</h2>
<p>LBA 转换成 CHS 公式：</p>
<p>Cylinder = LBA / (Heads per Cylinder * Sector Per Track)<br>
Remainder = LBA % (Heads per Cylinder * Sector Per Track)<br>
Head = Remainder / Sector Per Track<br>
Sector = (LBA % Sector Per Track) + 1</p>
<p>其中，Cylinder 表示柱面数，Heads per Cylinder 表示每个柱面的磁头数，Sector Per Track 表示每个磁道的扇区数，Head 表示磁头数，Sector 表示扇区数。</p>
<h1 id="磁盘文件存储">磁盘文件存储</h1>
<p>APUE P91，4.14 节的图很清楚的说明了磁盘、分区、文件系统、文件节点、数据块之间的关系，看图：</p>
<img src="/images/linux-kernel/filesystem/linux-vfs.png" alt="Disk driver, partitions, and a file system" width="80%" height="80%">
<p>一整块磁盘可以划分为多个分区，每个分区都包含一个超级块和 n 个柱面组。每个柱面组下会包含 inode bitmap 和 inodes 以及 blcok bitmap 和 data blocks。出于数据安全考虑，超级块不仅仅存储在分区的起始位置，也会在某些柱面组（而非全部）下进行拷贝备份。</p>
<img src="/images/linux-kernel/filesystem/linux-vfs2.png" alt="Cylinder group's inodes and data blocks in more detail"width="80%"height="80%">
<p>当我们使用命令 mkdir testdir 创建一个目录后，磁盘结构如下图：</p>
<img src="/images/linux-kernel/filesystem/linux-vfs3.png" alt="Sample cylinder group after creating the directory testdir" width="80%" height="80%">
<ul>
<li>i-node 2549(8683543) 指向一个目录块，即 testdir 目录的实际数据块。</li>
<li>i-node 2549 的引用计数为 2，任何叶子目录的引用计数都是 2：一个来自父目录 <code>..</code> 的引用、一个来自自身目录 <code>.</code> 的引用。</li>
<li>i-node 2549 的父目录为 1267(8683541)，同样指向一个目录数据块，里边包含指向自身的 <code>.</code>，指向其父目录的 <code>..</code>，和包含的目录项 <code>2549:testdir</code>。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/home/abc<span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">└── apue</span><br><span class="line">    └── testdir</span><br><span class="line"></span><br><span class="line">2 directories, 0 files</span><br><span class="line"></span><br><span class="line">/home/abc/apue<span class="comment"># ls -a -l -i</span></span><br><span class="line">总计 12</span><br><span class="line">8683542 drwxr-xr-x 3 root root 4096 11 月 11 16:44 .</span><br><span class="line">8683541 drwxr-xr-x 3 root root 4096 11 月 11 16:44 ..</span><br><span class="line">8683543 drwxr-xr-x 2 root root 4096 11 月 11 16:44 testdir</span><br><span class="line"></span><br><span class="line">/home/abc<span class="comment"># ls -a -l -i</span></span><br><span class="line">总计 12</span><br><span class="line">8683541 drwxr-xr-x 3 root root 4096 11 月 11 16:44 .</span><br><span class="line">8663454 drwxr-xr-x 9 root root 4096 11 月 11 16:43 ..</span><br><span class="line">8683542 drwxr-xr-x 3 root root 4096 11 月 11 16:44 apue</span><br></pre></td></tr></table></figure>
<h1 id="文件基本操作（抽象）">文件基本操作（抽象）</h1>
<p>Linux 文件系统的 10 个基本抽象（系统调用）：</p>
<ul>
<li>open/close/(creat)</li>
<li>read/write/lseek/(tell)</li>
<li>fstat/ftruncate</li>
<li>unlink/mkdir/dup</li>
</ul>
<table>
<thead>
<tr>
<th>系统调用</th>
<th>功能描述</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>open</td>
<td>打开文件，返回文件描述符，允许对文件进行读写操作</td>
<td>pathname（文件路径）, flags（打开方式）, mode（文件权限，可选）</td>
</tr>
<tr>
<td>close</td>
<td>关闭文件描述符，释放文件资源</td>
<td>fd（文件描述符）</td>
</tr>
<tr>
<td>creat</td>
<td>创建一个文件，如果文件已存在则清空文件内容</td>
<td>pathname（文件路径）, mode（文件权限）</td>
</tr>
<tr>
<td>read</td>
<td>从打开的文件中读取数据</td>
<td>fd, buf（存储数据的缓冲区）, count（读取字节数）</td>
</tr>
<tr>
<td>write</td>
<td>向打开的文件中写入数据</td>
<td>fd, buf（写入数据的缓冲区）, count（写入字节数）</td>
</tr>
<tr>
<td>lseek</td>
<td>移动文件指针位置，用于随机读写</td>
<td>fd, offset（偏移量）, whence（偏移起点）</td>
</tr>
<tr>
<td>tell</td>
<td>返回文件指针当前的位置</td>
<td>fd</td>
</tr>
<tr>
<td>fstat</td>
<td>获取文件的相关信息</td>
<td>fd, statbuf（存储信息的缓冲区）</td>
</tr>
<tr>
<td>ftruncate</td>
<td>截断文件，使文件的大小缩小到指定长度</td>
<td>fd, length（文件的目标长度）</td>
</tr>
<tr>
<td>unlink</td>
<td>inode 引用计数减一，当 inode 引用计数为 0 时才会删除文件</td>
<td>pathname（文件路径）</td>
</tr>
<tr>
<td>mkdir</td>
<td>创建目录</td>
<td>pathname（目录路径）, mode（目录权限）</td>
</tr>
<tr>
<td>dup</td>
<td>复制文件描述符，创建一个新的描述符引用相同的文件</td>
<td>fd（原文件描述符）</td>
</tr>
</tbody>
</table>
<h1 id="文件系统架构">文件系统架构</h1>
<h2 id="VFS 与文件系统">VFS 与文件系统</h2>
<p>Linux 支持多种文件系统，为了让应用程序能够对所有系统不加区分的操作，Linux 提供了一个抽象层，这个抽象层介于应用程序和具体的文件系统之间，就像一个开关一样将用户请求转换到具体文件系统系统去，让具体文件系统去实现对应的操作，最后再将结果返回给用户。</p>
<p>这种引入一个抽象层次的设计思想，即“上层不依赖于具体实现，而依赖于接口；下层也不用关心调用，只用实现接口”，就算面向对象里的“面向接口编程”吧。</p>
<img src="/images/linux-kernel/filesystem/vfs-architecture.png" alt="VFS 架构" width="60%" height="60%">
<h2 id="块设备驱动架构">块设备驱动架构</h2>
<img src="/images/linux-kernel/filesystem/block-fs-arch.png" alt="块设备驱动架构" width="60%" height="60%">
<h1 id="Linux-VFS">Linux VFS</h1>
<h2 id="文件系统分类">文件系统分类</h2>
<p>从功能的角度来看，文件系统可以分为以下几类：</p>
<ul>
<li>磁盘文件系统（ext3、ext4、xfs、fat 以及 ntfs 等）</li>
<li>网络文件系统（nfs、smbfs/cifs、ncp 等）</li>
<li>虚拟文件系统（procfs、sysfs、sockfs、pipefs 等）</li>
</ul>
<p>Linux 内核实例使用 VFS 来处理目录和文件的层次结构（一棵树）。通过挂载操作，新的文件系统将被添加为 VFS 子树。</p>
<h2 id="文件系统模型">文件系统模型</h2>
<p>常见的文件系统模型（任何实现的文件系统都需要符合该模型）包括几种明确定义的实体: superblock, inode, file 和 dentry。这些实体是文件系统的元数据（包含有关数据或其他元数据的信息）。</p>
<h3 id="super-block">super_block</h3>
<p><strong>超级块（super block）存储了挂载文件系统所需的信息，是针对文件系统级别的概念</strong>：</p>
<ul>
<li>inode 和块的位置；</li>
<li>文件系统块大小；</li>
<li>最大文件名长度；</li>
<li>最大文件大小；</li>
<li>根 inode 的位置。</li>
</ul>
<p><strong>本地化</strong>：</p>
<ul>
<li>对于磁盘文件系统，超级块在磁盘的 <strong> 第一个块 </strong> 中有对应项（文件系统控制块）。</li>
<li>在 VFS 中，<strong>所有文件系统的超级块 </strong> 都保留在类型为 struct super_block 的结构 <strong> 列表中</strong>，操作方法则保留在类型为 struct super_operations 的结构中。</li>
</ul>
<p>文件系统都有一个根节点 root，其他的节点都是通过 root 向下查找而来，<strong>查找的手段都是通过文件名匹配</strong>。</p>
<blockquote>
<p>每个超级块实例对应一个挂载的文件系统，如果已经挂载，就是活动超级块，当然一个超级块可以挂载到多个分区。</p>
</blockquote>
<h3 id="inode">inode</h3>
<p>inode（索引节点）保存了有关文件的信息。注意这里的文件指的是泛指意义上的文件，常规文件、目录、特殊文件（管道、fifo）、块设备、字符设备、链接或可以抽象为文件的任何内容都包括在内。</p>
<p>inode 存储了以下信息（可以分为两个部分，一个是文件状态信息、一个是保存的数据，状态信息叫元数据）：</p>
<ul>
<li>文件类型；</li>
<li>文件大小；</li>
<li>访问权限；</li>
<li>访问或修改时间；</li>
<li>数据在磁盘上的位置（指向包含数据的磁盘块的指针）。</li>
</ul>
<p>索引节点和文件容易混淆，<strong>inode 和 file 的设计目的是不一样的，inode 主要提供了对文件节点创建、命名、删除等操作方法，而 file 则关注文件中数据的读写</strong>。</p>
<blockquote>
<ol>
<li>通常，inode 不包含文件名。文件名由 dentry 实体存储。这样，一个 inode 可以有多个名称（硬链接）。</li>
<li>目录也是用 inode 表示，只不其内容是录下的文件名与其 inode 编号的对应表。</li>
</ol>
</blockquote>
<p><strong>本地化</strong>：</p>
<p>与 superblock 类似，inode 也有磁盘对应项。磁盘上的 inodes 通常分组存储在一个专用区域（inode 区域）中，与数据块区域分开；作为 VFS 实体，inode 由 struct inode 结构表示，并由 struct inode_operations 结构定义与之相关的操作方法。</p>
<hr>
<p>符号链接（symbolic links）和硬链接（hard links）都是由 inode 表示。</p>
<ul>
<li>符号链接的 inode 数据段包含一个路径字符串，指向链接的地址。</li>
<li>多个硬链接实际是由同一个 inode 表示，只不过 inode 中有一个引用计数器，记住了总共有多少个硬链接。</li>
</ul>
<blockquote>
<p>硬链接不能是目录，因为每个目录由一个 inode 表示，如果多个目录指向同一个 inode，那么从该目录向上查找就会发现由多个 parent，这会破坏目录树的结构。更糟糕的是，如果把一个目录和它的子目录互相硬链接会发生什么？进入这个目录就意味着直接进入其子目录，进入子目录又进一步进入父目录，产生死循环。</p>
</blockquote>
<h3 id="file">file</h3>
<p>file 是文件系统模型中距离用户最近的组件。file 对象是文件被打开的时候创建的，该结构体仅作为 VFS 在内存中的实体存在，没有在磁盘上的物理对应物。</p>
<p>inode 抽象了磁盘上的文件，而 file 结构抽象了打开的文件。从进程的角度来看，file 实体抽象了文件。然而，从文件系统实现的角度来看，inode 才是抽象文件的那个实体。</p>
<p>file 结构维护了以下信息：</p>
<ul>
<li>文件游标位置；</li>
<li>文件打开权限；</li>
<li>指向关联 inode 的指针（最终是 inode 的索引）。</li>
</ul>
<p><strong>本地化</strong>：</p>
<p>与之关联的 VFS 实体是 struct file 结构，与之相关的操作方法由 struct file_operations 结构表示。</p>
<blockquote>
<p>定义 file 是为了让进程对文件的记录是私有的（进程间互相独立），父子进程对文件共享。由于一个文件可以被多个进程打开，所以文件指针要放在 file 对象中而不是 inode 对象中。换句话说，一个文件与唯一的一个 inode 对应，多个进程打开同一文件进行 I/O 操作（如以什么模式打开、读取的偏移等），不能直接修改 inode 对象的数据，因为对 inode 的修改对所有进程可见）。</p>
</blockquote>
<h3 id="dentry">dentry</h3>
<p>名字查找是 VFS 当中非常复杂的一个部分。前面说了查找 inode 是通过名字匹配来实现的，但是并不是每个文件系统都能够快速的实现名字到 inode 的转换。于是 VFS 实现了 dcache，为快速名字查找提供了可靠的保障。VFS 处理了所有文件路径名的管理操作，在底层文件系统能够看到他们之前，将其转换为 dcache 的入口。</p>
<p>dcache 称之为高速目录缓存，由许多 dentry 组成，每个 dentry 对应到系统中的一个文件名。当前活动的文件名字和最近使用的文件名字都缓存在 dcache 中。每个 dentry 的父节点必须在 dcache 中，只要在 dcache 中存在一个目录项，那么相应的 inode 就在 inode 高速缓存中。反过来，如果 inode 在 inode 高速缓存中，那么它一定引用 dcache 中的一个 dentry。也就是可以理解为 dcache 的存在就是为了加速文件名字到具体 inode 的转换，VFS 三个字母中的 S-switch 和这个功能息息相关。</p>
<p>dcache 是一个树状结构，每个 dcache 节点对应一个目录，也就是指定名字的 inode。一个 inode 可以和树中的多个 dcache 节点联系，因为硬链接可以在多个地方指向同一个节点。</p>
<p>dentry 是目录或文件路径的特定部分。例如，对于路径 /bin/vi，将为 /, bin 和 vi 创建 dentry 对象（总共 3 个 dentry 对象）。</p>
<ul>
<li>一个打开的 file 一定会指向 dentry，而一个 dentry 又会指向 inode，所以 dentry 可以看作是 file 到 inode 的 switch。</li>
<li>在 VFS 中，dentry 实体由 struct dentry 结构表示，与之相关的操作方法在 struct dentry_operations 结构中定义。</li>
</ul>
<blockquote>
<p>请注意目录项和目录区别，目录不过是 inode 的一种形式（目录是一个特殊的文件）。</p>
</blockquote>
<h2 id="注册与注销文件系统">注册与注销文件系统</h2>
<p>Linux 内核支持约 50 种文件系统。如果文件系统（更准确地说，文件系统类型）没有注册，那么自然就无法使用。文件系统注册可以有两种方式：</p>
<ul>
<li>一种是将文件系统编译到内核里，这样系统启动就会自动完成注册；</li>
<li>一种是将文件系统编译成模块，在模块载入的时候注册。</li>
</ul>
<blockquote>
<p>当文件系统编译到内核时，在 start_kernel() 就会调用注册函数，如 rootfs、proc 等，而永远不会调用注销函数。当文件编译为模块时，在模块的 init() 函数中就会调用注册函数，在模块的 exit() 函数中会调用注销函数。</p>
</blockquote>
<h3 id="注册文件系统">注册文件系统</h3>
<p>注册文件系统并不复杂，可以直接看源代码。但是，要理解原理需要先理解描述特定文件系统的结构 struct file_system_type。文件系统类型最关键的是要 <strong> 提供两个操作——挂载和卸载</strong>，对应到 file_system_type 就是函数指针成员 mount 和 kill_sb。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/fs.h 结构体已删减</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> &#123;</span></span><br><span class="line">    <span class="comment">// 文件系统的名称（如 &quot;ext4&quot;、&quot;vfat&quot;），用于标识文件系统类型</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标志字段，描述文件系统的特性</span></span><br><span class="line">    <span class="type">int</span> fs_flags;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_REQUIRES_DEV 1      <span class="comment">// 文件系统需要设备支持</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_BINARY_MOUNTDATA 2  <span class="comment">// 挂载时需要二进制格式的数据</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_HAS_SUBTYPE 4       <span class="comment">// 文件系统具有子类型，支持不同的挂载子类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_USERNS_MOUNT 8      <span class="comment">// 允许用户命名空间中的 root 挂载此文件系统</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_USERNS_DEV_MOUNT 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_RENAME_DOES_D_MOVE 32768</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数指针，挂载文件系统，返回根目录的 dentry 结构指针，表示挂载点</span></span><br><span class="line">    <span class="comment">// 参数：文件系统类型、挂载标志、设备路径、挂载数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>* (*<span class="title">mount</span>)(<span class="keyword">struct</span> <span class="title">file_system_type</span>*, <span class="title">int</span>, <span class="title">const</span> <span class="title">char</span>*, <span class="title">void</span>*);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数指针，卸载文件系统，释放挂载点的超级块结构</span></span><br><span class="line">    <span class="type">void</span> (*kill_sb)(<span class="keyword">struct</span> super_block*);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向文件系统模块的指针，一般都是设置为 THIS_MODULE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span>* <span class="title">owner</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向链表中下一个文件系统类型结构，用于组织多个文件系统类型</span></span><br><span class="line">    <span class="comment">// 在注册的时候会找到最后一个文件系统，并将其 next 指向新注册的文件系统</span></span><br><span class="line">    <span class="comment">// 链表头：static struct file_system_type *file_systems;</span></span><br><span class="line">    <span class="comment">// 保护锁：static DEFINE_RWLOCK(file_systems_lock);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span>* <span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表头，用于记录该文件系统的所有 super_block 实例，</span></span><br><span class="line">    <span class="comment">// 由于同一文件系统可能会被多次挂载，因此每个挂载点都会有一个单独的超级块</span></span><br><span class="line">    <span class="comment">// 链表头：LIST_HEAD(super_blocks); -&gt; struct list_head super_blocks</span></span><br><span class="line">    <span class="comment">// 保护锁：DEFINE_SPINLOCK(sb_lock);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">fs_supers</span>;</span>  <span class="comment">// 与 list_head 结构完全相同，只是名称不同而已</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注册的思路上非常简单，如果找到同名字的文件系统就说明已经注册了，返回 -EBUSY。反之 find_filesystem() 会获取到最后一个文件系统的 next 指针，将其指向新的文件系统就完成注册了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fs/filesystems.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全局变量 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> *<span class="title">file_systems</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_RWLOCK</span><span class="params">(file_systems_lock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	register_filesystem - register a new filesystem</span></span><br><span class="line"><span class="comment"> *	@fs: the file system structure</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Adds the file system passed to the list of file systems the kernel</span></span><br><span class="line"><span class="comment"> *	is aware of for mount and other syscalls. Returns 0 on success,</span></span><br><span class="line"><span class="comment"> *	or a negative errno code on an error.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	The &amp;struct file_system_type that is passed is linked into the kernel</span></span><br><span class="line"><span class="comment"> *	structures and must not be freed until the file system has been</span></span><br><span class="line"><span class="comment"> *	unregistered.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">register_filesystem</span><span class="params">(<span class="keyword">struct</span> file_system_type* fs)</span> &#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span>** <span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    BUG_ON(<span class="built_in">strchr</span>(fs-&gt;name, <span class="string">&#x27;.&#x27;</span>));  <span class="comment">// 文件系统的名称不能出现 &#x27;.&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (fs-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">    write_lock(&amp;file_systems_lock);</span><br><span class="line">    <span class="comment">// 找到同名字的文件系统就说明已经注册，否则将其（入参 fs）挂到 -&gt;next 链表最后</span></span><br><span class="line">    p = find_filesystem(fs-&gt;name, <span class="built_in">strlen</span>(fs-&gt;name));</span><br><span class="line">    <span class="keyword">if</span> (*p)</span><br><span class="line">        res = -EBUSY;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        *p = fs;</span><br><span class="line">    write_unlock(&amp;file_systems_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(register_filesystem);</span><br></pre></td></tr></table></figure>
<p>不妨看一下 find_filesystem() 的实现。所有的文件系统类型形成一个链表，链表头存放在一个叫 file_systems 的全局变量中。所以不需要特殊的参数来传递链表头。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> file_system_type** <span class="title function_">find_filesystem</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">unsigned</span> len)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span>** <span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (p = &amp;file_systems; *p; p = &amp;(*p)-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>((*p)-&gt;name) == len &amp;&amp; <span class="built_in">strncmp</span>((*p)-&gt;name, name, len) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注销文件系统">注销文件系统</h3>
<p>注销文件系统的代码也比较简单，直接看源代码。这里 tmp 作为一个二级指针，它会向后移动，假设这里移动到了 fs，这时 *tmp 和 fs 指向同一位置，需要注意的是 tmp 实际上是上一个节点的 next 地址，因此 *tmp = fs-&gt;next 实际上是改变上一个节点 next 的指向，也就是让其跳过 fs、指向 fs 的下一个节点。接下来由于 fs 已经被 file_systems 链表所抛弃，我们必须将 fs-&gt;next 清空。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	unregister_filesystem - unregister a file system</span></span><br><span class="line"><span class="comment"> *	@fs: filesystem to unregister</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Remove a file system that was previously successfully registered</span></span><br><span class="line"><span class="comment"> *	with the kernel. An error is returned if the file system is not found.</span></span><br><span class="line"><span class="comment"> *	Zero is returned on a success.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Once this function has returned the &amp;struct file_system_type structure</span></span><br><span class="line"><span class="comment"> *	may be freed or reused.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">unregister_filesystem</span><span class="params">(<span class="keyword">struct</span> file_system_type* fs)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span>** <span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">    write_lock(&amp;file_systems_lock);</span><br><span class="line">    tmp = &amp;file_systems;</span><br><span class="line">    <span class="keyword">while</span> (*tmp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fs == *tmp) &#123;     <span class="comment">// 地址比较相等</span></span><br><span class="line">            *tmp = fs-&gt;next;  <span class="comment">// 跳过将要移除的节点（上一个节点的 next 指向 fs 的下一个节点）</span></span><br><span class="line">            fs-&gt;next = <span class="literal">NULL</span>;  <span class="comment">// 将要移除的节点的 next 指向空</span></span><br><span class="line">            write_unlock(&amp;file_systems_lock);</span><br><span class="line">            synchronize_rcu();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新 tmp，使之指向下一个 file_system_type* 的地址，</span></span><br><span class="line">        <span class="comment">// 换句话说，现在 tmp 指向了上一个节点的 next 地址</span></span><br><span class="line">        tmp = &amp;(*tmp)-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    write_unlock(&amp;file_systems_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(unregister_filesystem);</span><br></pre></td></tr></table></figure>
<h3 id="rootfs 和 ramfs 注册">rootfs 和 ramfs 注册</h3>
<p>以下是内核注册虚拟文件系统的示例。</p>
<p>注册 rootfs 是在 init_rootfs() 中完成的（将文件系统编译到内核里），主要工作就是注册 rootfs_fs_type。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">rootfs_fs_type</span> =</span> &#123;</span><br><span class="line">	.name		= <span class="string">&quot;rootfs&quot;</span>,</span><br><span class="line">	.mount		= rootfs_mount,  <span class="comment">// 挂载和卸载操作</span></span><br><span class="line">	.kill_sb	= kill_litter_super,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __init <span class="title function_">init_rootfs</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	err = register_filesystem(&amp;rootfs_fs_type);</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册 ramfs 是在 module 加载时初始化注册的（将文件系统编译成模块）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">ramfs_fs_type</span> =</span> &#123;</span><br><span class="line">	.name		= <span class="string">&quot;ramfs&quot;</span>,</span><br><span class="line">	.mount		= ramfs_mount,</span><br><span class="line">	.kill_sb	= ramfs_kill_sb,</span><br><span class="line">	.fs_flags	= FS_USERNS_MOUNT,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">init_ramfs_fs</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> register_filesystem(&amp;ramfs_fs_type);</span><br><span class="line">&#125;</span><br><span class="line">module_init(init_ramfs_fs)</span><br></pre></td></tr></table></figure>
<h2 id="数据结构">数据结构</h2>
<h3 id="各对象之间的关系">各对象之间的关系</h3>
<p>这里，首先通过一个示例给出下面各种数据结构的组织关系，然后再详细介绍各类数据结构。</p>
<p>Figure 12-2 illustrates with a simple example how processes interact with files. Three different processes have opened the same file, two of them using the same hard link. In this case, each of the three processes uses its own file object, while only two dentry objects are required—one for each hard link. Both dentry objects refer to the same inode object, which identifies the superblock object and, together with the latter, the common disk file.</p>
<img src="/images/linux-kernel/filesystem/process-and-vfs-object.png" alt="进程与 VFS 对象交互" width="80%" height="80%">
<h3 id="超级块">超级块</h3>
<h4 id="super-block-v2">super_block</h4>
<p>超级块既作为物理实体（磁盘上的实体）存在，也作为 VFS 实体（在 struct super_block 结构中）存在。超级块仅包含元信息，并用于从磁盘中读取和写入元数据（如 inode、目录项）。超级块（以及隐式的 struct super_block 结构）将包含有关所使用的块设备、inode 列表、文件系统根目录的 inode 指针以及超级块操作的指针的信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/fs.h 结构体已删减</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">s_list</span>;</span>              <span class="comment">// Keep this first，链接所有超级块的链表头，便于管理多个挂载的文件系统</span></span><br><span class="line"></span><br><span class="line">    <span class="type">dev_t</span> s_dev;                          <span class="comment">// 标识文件系统的设备编号</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> s_blocksize_bits;       <span class="comment">// block 大小的幂数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> s_blocksize;            <span class="comment">// block 的实际字节，s_blocksize=2^s_blocksize_bits</span></span><br><span class="line">    <span class="type">loff_t</span> s_maxbytes;                    <span class="comment">// 支持的单个文件的最大字节大小 MAX_LFS_FILESIZE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span>* <span class="title">s_type</span>;</span>      <span class="comment">// 此超级块所属的文件系统类型</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span>* <span class="title">s_op</span>;</span>  <span class="comment">// 指向超级块操作函数，如 alloc_inode/write_inode/destroy_inode 等</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>* <span class="title">s_root</span>;</span>                <span class="comment">// 根目录项，表示文件系统的挂载点</span></span><br><span class="line">    <span class="type">int</span> s_count;                          <span class="comment">// 超级块的引用次数，决定何时可以销毁超级块</span></span><br><span class="line">    <span class="type">atomic_t</span> s_active;                    <span class="comment">// 超级块是否处于活跃状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">s_inodes</span>;</span>            <span class="comment">// 文件系统中 inode 链表头，记录文件系统的所有 inode</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">s_mounts</span>;</span>            <span class="comment">// list of mounts; _not_ for fs use，记录当前挂载该文件系统的所有挂载点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">s_instances</span>;</span>        <span class="comment">// 链接所有 super_block 实例</span></span><br><span class="line">    <span class="type">fmode_t</span> s_mode;                       <span class="comment">// 文件系统的访问模式（读 / 写等）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>相关函数：</p>
<ul>
<li>sget 构造函数，如果没有从已经挂载的文件系统找到需要的 super_block 就会调用 alloc_super 分配一个。</li>
<li>put_super 析构函数，当引用计数减少到 0 时才会调用 destroy_super 真正释放。</li>
</ul>
<h4 id="super-operations">super_operations</h4>
<p>主要包括对 inode 数据结构的操作（操作系统 VFS 层面），注意不是对 inode 的操作（磁盘层面），对 inode 的操作由 inode_operations 来完成。如：alloc_inode、destroy_inode、dirty_inode 等等。</p>
<p>所有的函数由 VFS 调用，都在进程上下文调用，所有的函数都可能阻塞。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> &#123;</span></span><br><span class="line">   	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *(*<span class="title">alloc_inode</span>)(<span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>);</span></span><br><span class="line">	<span class="type">void</span> (*destroy_inode)(<span class="keyword">struct</span> inode *);</span><br><span class="line"></span><br><span class="line">   	<span class="type">void</span> (*dirty_inode) (<span class="keyword">struct</span> inode *, <span class="type">int</span> flags);</span><br><span class="line">	<span class="type">int</span> (*write_inode) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> writeback_control *wbc);</span><br><span class="line">	<span class="type">int</span> (*drop_inode) (<span class="keyword">struct</span> inode *);</span><br><span class="line">	<span class="type">void</span> (*evict_inode) (<span class="keyword">struct</span> inode *);</span><br><span class="line">	<span class="type">void</span> (*put_super) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">	<span class="type">int</span> (*sync_fs)(<span class="keyword">struct</span> super_block *sb, <span class="type">int</span> wait);</span><br><span class="line">	<span class="type">int</span> (*freeze_fs) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">	<span class="type">int</span> (*unfreeze_fs) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">	<span class="type">int</span> (*statfs) (<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> kstatfs *);</span><br><span class="line">	<span class="type">int</span> (*remount_fs) (<span class="keyword">struct</span> super_block *, <span class="type">int</span> *, <span class="type">char</span> *);</span><br><span class="line">	<span class="type">void</span> (*umount_begin) (<span class="keyword">struct</span> super_block *);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> (*show_options)(<span class="keyword">struct</span> seq_file *, <span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="type">int</span> (*show_devname)(<span class="keyword">struct</span> seq_file *, <span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="type">int</span> (*show_path)(<span class="keyword">struct</span> seq_file *, <span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="type">int</span> (*show_stats)(<span class="keyword">struct</span> seq_file *, <span class="keyword">struct</span> dentry *);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_QUOTA</span></span><br><span class="line">	<span class="type">ssize_t</span> (*quota_read)(<span class="keyword">struct</span> super_block *, <span class="type">int</span>, <span class="type">char</span> *, <span class="type">size_t</span>, <span class="type">loff_t</span>);</span><br><span class="line">	<span class="type">ssize_t</span> (*quota_write)(<span class="keyword">struct</span> super_block *, <span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *, <span class="type">size_t</span>, <span class="type">loff_t</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">int</span> (*bdev_try_to_free_page)(<span class="keyword">struct</span> super_block*, <span class="keyword">struct</span> page*, <span class="type">gfp_t</span>);</span><br><span class="line">	<span class="type">int</span> (*nr_cached_objects)(<span class="keyword">struct</span> super_block *);</span><br><span class="line">	<span class="type">void</span> (*free_cached_objects)(<span class="keyword">struct</span> super_block *, <span class="type">int</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="索引节点">索引节点</h3>
<h4 id="inode-v2">inode</h4>
<p>inode 既存在于 VFS 中（内存中），也存在于磁盘中（对于 UNIX、HFS 以及 NTFS 等）。VFS 中的 inode 由 struct inode 结构表示。和 VFS 中的其他结构一样, struct inode 是通用结构，涵盖了所有支持的文件类型的选项，甚至包括那些没有关联磁盘实体的文件类型（比如 FAT 文件系统）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/fs.h 结构体已删减</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="type">umode_t</span> i_mode;                       <span class="comment">// 文件权限及类型</span></span><br><span class="line">    <span class="type">kuid_t</span> i_uid;                         <span class="comment">// user id</span></span><br><span class="line">    <span class="type">kgid_t</span> i_gid;                         <span class="comment">// group id</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span>* <span class="title">i_op</span>;</span>  <span class="comment">// inode 操作函数，如 create，mkdir，lookup，rename 等</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>* <span class="title">i_sb</span>;</span>             <span class="comment">// 所属的 SuperBlock</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>* <span class="title">i_mapping</span>;</span>      <span class="comment">// 地址空间（用于处理文件的“内存”映射）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> <span class="title">i_data</span>;</span>          <span class="comment">// inode 的数据地址空间</span></span><br><span class="line">    <span class="type">loff_t</span> i_size;                        <span class="comment">// 文件大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">i_atime</span>;</span>              <span class="comment">// 文件最后访问时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">i_mtime</span>;</span>              <span class="comment">// 文件最后修改时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">i_ctime</span>;</span>              <span class="comment">// 文件元数据最后修改时间（包括文件名称）</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>* <span class="title">i_fop</span>;</span>  <span class="comment">// 文件操作函数，open、write 等</span></span><br><span class="line">    <span class="type">void</span>* i_private;                      <span class="comment">// 文件系统的私有数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>相关函数：</p>
<ul>
<li>new_inode 构造函数，调用 alloc_inode 从 inode_cachep 分配索引节点。</li>
</ul>
<h4 id="inode-operations">inode_operations</h4>
<p>对 inode 的操作，包括 create、lookup、mkdir、rmdir、link、unlink 等等。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> * (*<span class="title">lookup</span>) (<span class="keyword">struct</span> <span class="title">inode</span> *,<span class="keyword">struct</span> <span class="title">dentry</span> *, <span class="title">unsigned</span> <span class="title">int</span>);</span></span><br><span class="line">	<span class="type">void</span> * (*follow_link) (<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> nameidata *);</span><br><span class="line">	<span class="type">int</span> (*permission) (<span class="keyword">struct</span> inode *, <span class="type">int</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span> * (*<span class="title">get_acl</span>)(<span class="keyword">struct</span> <span class="title">inode</span> *, <span class="title">int</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> (*readlink) (<span class="keyword">struct</span> dentry *, <span class="type">char</span> __user *,<span class="type">int</span>);</span><br><span class="line">	<span class="type">void</span> (*put_link) (<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> nameidata *, <span class="type">void</span> *);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> (*create) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *, <span class="type">umode_t</span>, <span class="type">bool</span>);</span><br><span class="line">	<span class="type">int</span> (*link) (<span class="keyword">struct</span> dentry *,<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="type">int</span> (*unlink) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="type">int</span> (*symlink) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *,<span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line">	<span class="type">int</span> (*mkdir) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *,<span class="type">umode_t</span>);</span><br><span class="line">	<span class="type">int</span> (*rmdir) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="type">int</span> (*mknod) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *,<span class="type">umode_t</span>,<span class="type">dev_t</span>);</span><br><span class="line">	<span class="type">int</span> (*rename) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *,</span><br><span class="line">			<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="type">int</span> (*setattr) (<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> iattr *);</span><br><span class="line">	<span class="type">int</span> (*getattr) (<span class="keyword">struct</span> vfsmount *mnt, <span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> kstat *);</span><br><span class="line">	<span class="type">int</span> (*setxattr) (<span class="keyword">struct</span> dentry *, <span class="type">const</span> <span class="type">char</span> *,<span class="type">const</span> <span class="type">void</span> *,<span class="type">size_t</span>,<span class="type">int</span>);</span><br><span class="line">	<span class="type">ssize_t</span> (*getxattr) (<span class="keyword">struct</span> dentry *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">void</span> *, <span class="type">size_t</span>);</span><br><span class="line">	<span class="type">ssize_t</span> (*listxattr) (<span class="keyword">struct</span> dentry *, <span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line">	<span class="type">int</span> (*removexattr) (<span class="keyword">struct</span> dentry *, <span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line">	<span class="type">int</span> (*fiemap)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> fiemap_extent_info *, u64 start,</span><br><span class="line">		      u64 len);</span><br><span class="line">	<span class="type">int</span> (*update_time)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> timespec *, <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*<span class="type">atomic_open</span>)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *,</span><br><span class="line">			   <span class="keyword">struct</span> file *, <span class="type">unsigned</span> open_flag,</span><br><span class="line">			   <span class="type">umode_t</span> create_mode, <span class="type">int</span> *opened);</span><br><span class="line">&#125; ____cacheline_aligned;</span><br></pre></td></tr></table></figure>
<h3 id="进程与文件">进程与文件</h3>
<p>文件是和进程息息相关的，和文件相关的结构包括：</p>
<ul>
<li>task_struct: 进程的表示，包括 fs_struct 和 files_struct</li>
<li>fs_struct: 进程和文件系统的关系</li>
<li>files_struct: 用于将 fd 转换为 file</li>
<li>file: 文件的表示</li>
</ul>
<h4 id="file-v2">file</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/fs.h 结构体已删减</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">f_path</span>;</span>                  <span class="comment">// 包含的目录项</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">f_inode</span>;</span>               <span class="comment">// 缓存值</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>* <span class="title">f_op</span>;</span>  <span class="comment">// 文件操作函数</span></span><br><span class="line">    <span class="type">atomic_long_t</span> f_count;               <span class="comment">// 文件对象引用计数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> f_flags;</span><br><span class="line">    <span class="type">fmode_t</span> f_mode;</span><br><span class="line">    <span class="type">loff_t</span> f_pos;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span> <span class="title">f_owner</span>;</span></span><br><span class="line">    <span class="type">void</span>* private_data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">f_mapping</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>相关函数：</p>
<ul>
<li>alloc_file 调用 get_empty_filp 从 filp_cachep 分配一个文件。</li>
</ul>
<h4 id="file-operations">file_operations</h4>
<p>这个操作集包含了对文件的所有操作，如读取、写入、打开和关闭等等。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">	<span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	<span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	<span class="type">ssize_t</span> (*aio_read) (<span class="keyword">struct</span> kiocb *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">loff_t</span>);</span><br><span class="line">	<span class="type">ssize_t</span> (*aio_write) (<span class="keyword">struct</span> kiocb *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">loff_t</span>);</span><br><span class="line">	<span class="type">int</span> (*readdir) (<span class="keyword">struct</span> file *, <span class="type">void</span> *, <span class="type">filldir_t</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *)</span>;</span><br><span class="line">	<span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">	<span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">	<span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">	<span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line">	<span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span> datasync);</span><br><span class="line">	<span class="type">int</span> (*aio_fsync) (<span class="keyword">struct</span> kiocb *, <span class="type">int</span> datasync);</span><br><span class="line">	<span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">	<span class="type">ssize_t</span> (*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>, <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line">	<span class="type">int</span> (*check_flags)(<span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*flock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">	<span class="type">ssize_t</span> (*splice_write)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	<span class="type">ssize_t</span> (*splice_read)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="keyword">struct</span> pipe_inode_info *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*setlease)(<span class="keyword">struct</span> file *, <span class="type">long</span>, <span class="keyword">struct</span> file_lock **);</span><br><span class="line">	<span class="type">long</span> (*fallocate)(<span class="keyword">struct</span> file *file, <span class="type">int</span> mode, <span class="type">loff_t</span> offset,</span><br><span class="line">			  <span class="type">loff_t</span> len);</span><br><span class="line">	<span class="type">int</span> (*show_fdinfo)(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> file *f);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="task-struct">task_struct</h4>
<p>进程中与文件相关的两个成员。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/sched.h 结构体已删减</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span>* <span class="title">fs</span>;</span>        <span class="comment">// filesystem information</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span>* <span class="title">files</span>;</span>  <span class="comment">// open file information</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="fs-struct">fs_struct</h4>
<p>主要包含两个路径，一个是当前工作目录，一个是工作目录所在文件系统的根目录。主要体现了进程和具体文件系统的关系。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/path.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">path</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span>* <span class="title">mnt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>* <span class="title">dentry</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/fs_struct.h 结构体已删减 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> users;         <span class="comment">// 当前有多少个用户（线程或进程）共享这个 fs_struct 资源</span></span><br><span class="line">    <span class="type">int</span> umask;         <span class="comment">// 文件权限的掩码</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">root</span>;</span>  <span class="comment">// 根目录(/) 路径 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">pwd</span>;</span>   <span class="comment">// 当前工作目录(.) 路径</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="files-struct">files_struct</h4>
<p>我们通常说的 fd 是一个整数，而这个整数正好可以作为下标，从而从 files_struct 中获得 file 结构。具体查找是通过 fdt-&gt;fd[fd] 来找到对应的 file（在默认数量内，这里的 file 地址就是 fd_array[fd]）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/fdtable.h 结构体已删减</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span>  <span class="comment">// Open file table structure</span></span><br><span class="line">    <span class="type">atomic_t</span> count;    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> __<span class="title">rcu</span>* <span class="title">fdt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> <span class="title">fdtab</span>;</span></span><br><span class="line">    <span class="type">spinlock_t</span> file_lock ____cacheline_aligned_in_smp;</span><br><span class="line">    <span class="type">int</span> next_fd;  <span class="comment">// 下一个可用的 fd 索引：当前 fd+1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> close_on_exec_init[<span class="number">1</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> open_fds_init[<span class="number">1</span>];          <span class="comment">// 记录当前已打开的 fd 的 bitmap，用数组是便于以后扩展</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">fd_array</span>[<span class="title">NR_OPEN_DEFAULT</span>];</span>  <span class="comment">// 默认数量内，fd 索引对应的 file 对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>fdt</p>
<ul>
<li>fdt 指针默认是指向 fdtab 的。当打开的文件数目比较多的时候，就需要重新分配一个 fdtable，并增大其 fd 数组和打开位图，然后将这个 fdt 指针指向新分配的 fdtable 资源。原来 fdt 所指向的内存会复制到新的 fdtable。</li>
<li>至于如何判断 fdt 是否指向动态 fdtable，也就是最后是否需要释放 fdt 所指向的内存，可以通过判断 fdt 和 &amp;fdtab 的地址是否相等来确定。</li>
</ul>
<p>从 fd 转换为 file 的关键数据结构就是 fdtable。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/fdtable.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> max_fds;          <span class="comment">// 最大可打开文件数，即 fd 数组长度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> __<span class="title">rcu</span>** <span class="title">fd</span>;</span>        <span class="comment">// 当前的 fd 数组</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>* close_on_exec;  <span class="comment">// 位图：带 O_CLOEXEC 打开标志的 fd</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>* open_fds;       <span class="comment">// 位图：已经打开的 fd</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>fd/close_on_exec/open_fds</p>
<ul>
<li>如果打开的文件比较少，那么这个 fd 将指向 files_struct 的 fd_array。</li>
<li>如果打开的文件比较多，fdtable 本身就是动态分配的、fd 成员也是动态分配。所以，是否要释放 fd 所指空间很好判断，如果要释放 fdtable 就一定会释放 fd。对 fd 的分配会尝试 kmalloc() 和 vmalloc() 两种方法。</li>
<li>另外，close_on_exec 与 open_fds 的行为同 fd，如果 fdtable 是动态分配的，那么他们也必然是动态分配的。</li>
</ul>
<h3 id="目录项">目录项</h3>
<p>目录操作使用 struct dentry 结构体。它的主要任务是在索引节点和文件名之间建立链接。</p>
<h4 id="dentry-v2">dentry</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/dcache.h 结构体已删减</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>* <span class="title">d_parent</span>;</span>               <span class="comment">// 父目录</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">d_name</span>;</span>                    <span class="comment">// 文件名称及哈希值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">d_inode</span>;</span>                 <span class="comment">// 关联的 inode，NULL 表示 negative</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span>* <span class="title">d_op</span>;</span>  <span class="comment">// 目录项操作相关函数</span></span><br><span class="line">    <span class="type">void</span>* d_fsdata;                        <span class="comment">// 文件系统特定的数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>* <span class="title">d_sb</span>;</span>              <span class="comment">// 指向超级块</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_child</span>;</span>  <span class="comment">// 父目录中的子目录和文件</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">d_rcu</span>;</span></span><br><span class="line">    &#125; d_u;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_subdirs</span>;</span>  <span class="comment">// 当前目录中的子目录和文件</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>相关函数：</p>
<ul>
<li>d_alloc 构造函数，从 dentry_cache 分配一个 negative 目录项。</li>
<li>dput 析构函数，当引用计数为 0 时调用 dentry_kill 释放目录项。</li>
</ul>
<h4 id="dentry-operations">dentry_operations</h4>
<p>由于 dentry 主要供 VFS 使用，所以操作集中的函数一般情况下也不需要具体文件系统去实现。这里的函数是针对 dentry 的操作，如 d_revalidate、d_hash、d_compare、d_delete、 d_release、d_prune 等等。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> (*d_revalidate)(<span class="keyword">struct</span> dentry *, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*d_weak_revalidate)(<span class="keyword">struct</span> dentry *, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*d_hash)(<span class="type">const</span> <span class="keyword">struct</span> dentry *, <span class="type">const</span> <span class="keyword">struct</span> inode *,</span><br><span class="line">			<span class="keyword">struct</span> qstr *);</span><br><span class="line">	<span class="type">int</span> (*d_compare)(<span class="type">const</span> <span class="keyword">struct</span> dentry *, <span class="type">const</span> <span class="keyword">struct</span> inode *,</span><br><span class="line">			<span class="type">const</span> <span class="keyword">struct</span> dentry *, <span class="type">const</span> <span class="keyword">struct</span> inode *,</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="keyword">struct</span> qstr *);</span><br><span class="line">	<span class="type">int</span> (*d_delete)(<span class="type">const</span> <span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="type">void</span> (*d_release)(<span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="type">void</span> (*d_prune)(<span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="type">void</span> (*d_iput)(<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> inode *);</span><br><span class="line">	<span class="type">char</span> *(*d_dname)(<span class="keyword">struct</span> dentry *, <span class="type">char</span> *, <span class="type">int</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *(*<span class="title">d_automount</span>)(<span class="keyword">struct</span> <span class="title">path</span> *);</span></span><br><span class="line">	<span class="type">int</span> (*d_manage)(<span class="keyword">struct</span> dentry *, <span class="type">bool</span>);</span><br><span class="line">&#125; ____cacheline_aligned;</span><br></pre></td></tr></table></figure>
<h2 id="数据结构关系图">数据结构关系图</h2>
<img src="/images/linux-kernel/filesystem/vfs-datastruct.png" alt="数据结构关系图" width="100%" height="100%">
<img src="/images/linux-kernel/filesystem/vfs-datastruct2.png" alt="各实例组织关系图" width="100%" height="100%">
<img src="/images/linux-kernel/filesystem/vfs-datastruct3.png" alt="数据结构关系图" width="100%" height="100%">
<h2 id="基本操作">基本操作</h2>
<h3 id="从 fd 获取 file">从 fd 获取 file</h3>
<p>查找 fd 对应的 file 结构的线路图为：current -&gt; files_struct -&gt; fdtable -&gt; file，具体可以参考 fget 函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> file* <span class="title function_">fget</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">file</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span>* <span class="title">files</span> =</span> current-&gt;files;  <span class="comment">// 1. current -&gt; files_struct ⭐</span></span><br><span class="line"></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    file = fcheck_files(files, fd);  <span class="comment">// 2. files_struct -&gt; fdtable -&gt; file ⭐</span></span><br><span class="line">    <span class="keyword">if</span> (file) &#123;</span><br><span class="line">        <span class="comment">/* File object ref couldn&#x27;t be taken 要求文件不是目录、可以引用 */</span></span><br><span class="line">        <span class="keyword">if</span> (file-&gt;f_mode &amp; FMODE_PATH || !atomic_long_inc_not_zero(&amp;file-&gt;f_count))</span><br><span class="line">            file = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> file* <span class="title function_">fcheck_files</span><span class="params">(<span class="keyword">struct</span> files_struct* files, <span class="type">unsigned</span> <span class="type">int</span> fd)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">file</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span>* <span class="title">fdt</span> =</span> files_fdtable(files);  <span class="comment">// 2.1 files_struct -&gt; fdtable ⭐</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2.2 fdtable -&gt; file ⭐ */</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; fdt-&gt;max_fds)</span><br><span class="line">        <span class="comment">// 如果 fd 小于 NR_OPEN_DEFAULT，这里 fdt-&gt;fd[fd] 便是 files-&gt;fd_array[fd] </span></span><br><span class="line">        file = rcu_dereference_check_fdtable(files, fdt-&gt;fd[fd]);</span><br><span class="line">    <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rcu_dereference_check_fdtable(files, fdtfd) \</span></span><br><span class="line"><span class="meta">    (rcu_dereference_check((fdtfd), \</span></span><br><span class="line"><span class="meta">                   lockdep_is_held(&amp;(files)-&gt;file_lock) || \</span></span><br><span class="line"><span class="meta">                   atomic_read(&amp;(files)-&gt;count) == 1 || \</span></span><br><span class="line"><span class="meta">                   rcu_my_thread_group_empty()))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> files_fdtable(files) \</span></span><br><span class="line"><span class="meta">        (rcu_dereference_check_fdtable((files), (files)-&gt;fdt))</span></span><br></pre></td></tr></table></figure>
<h1 id="块设备驱动">块设备驱动</h1>
<h2 id="简介">简介</h2>
<h3 id="字符设备">字符设备</h3>
<p>字符设备是一种顺序的数据流设备，对字符设备的读写是以字节为单位进行的，这些字符连续地形成一个数据流，字符设备没有缓存区，对于字符设备的读写是实时的。字符设备包括键盘、鼠标、串口、终端等。</p>
<h3 id="块设备">块设备</h3>
<p>块设备是一种具有一定结构的随机存取设备，对块设备的读写是以块为单位进行的，块设备使用缓存区来存放数据，待条件满足后，将数据从缓存区一次性写入到设备，或者从设备一次性读取到缓存区。块设备包括硬盘、SSD 等存储介质。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>字符设备</th>
<th>块设备</th>
</tr>
</thead>
<tbody>
<tr>
<td>访问方式</td>
<td>顺序访问</td>
<td>随机访问</td>
</tr>
<tr>
<td>类型</td>
<td>数据流设备</td>
<td>存储设备</td>
</tr>
<tr>
<td>读写单位</td>
<td>以字节为单位</td>
<td>以块为单位</td>
</tr>
<tr>
<td>缓存支持</td>
<td>没有缓存区，实时读写</td>
<td>有缓存区，非实时</td>
</tr>
<tr>
<td>调用层</td>
<td>由应用层程序调用</td>
<td>由文件系统程序调用</td>
</tr>
</tbody>
</table>
<p>块设备的速度通常比字符设备的速度快得多，并且它们的性能也很重要。与字符设备相比，使用块设备更加复杂。<strong>字符设备只有当前位置，而块设备必须能够移动到设备上的任何位置，以提供对数据的随机访问</strong>。为了简化对块设备的操作，Linux 内核提供了一整个子系统，称为块 I/O（或块层）子系统。</p>
<h2 id="块设备驱动架构 -v2">块设备驱动架构</h2>
<img src="/images/linux-kernel/filesystem/block-fs-arch.png" alt="块设备驱动架构" width="60%" height="60%">
<p>块设备使用请求队列，缓存并重排读写数据块的请求，用高效的方式读取数据；块设备的每个设备都关联了请求队列；对块设备的读写请求不会立即执行，这些请求会汇总起来，经过协同之后传输到设备。</p>
<h2 id="注册块 I-O 设备">注册块 I/O 设备</h2>
<p>要注册块设备，请使用函数 register_blkdev()。要注销一个块设备，可以使用函数 unregister_blkdev()。</p>
<p>register_blkdev() 函数执行的唯一操作是 <strong> 动态分配一个主设备号</strong>（如果调用函数时主设备号参数为 0），并在 /proc/devices 中创建一个条目。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_BLOCK_MAJOR 240</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_BLKDEV_NAME <span class="string">&quot;mybdev&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_block_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">    status = register_blkdev(MY_BLOCK_MAJOR, MY_BLKDEV_NAME);</span><br><span class="line">    <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;unable to register mybdev block device\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EBUSY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_block_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    unregister_blkdev(MY_BLOCK_MAJOR, MY_BLKDEV_NAME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>cat /proc/devices</code> 命令，可得已注册的字符设备和块设备的主设备号和设备名称。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /proc/devices</span></span><br><span class="line">Character devices:</span><br><span class="line">  1 mem</span><br><span class="line">  4 /dev/vc/0</span><br><span class="line">  4 <span class="built_in">tty</span></span><br><span class="line">  4 ttyS</span><br><span class="line">...</span><br><span class="line">261 accel</span><br><span class="line"></span><br><span class="line">Block devices:</span><br><span class="line">  2 fd</span><br><span class="line">  7 loop</span><br><span class="line">  8 sd</span><br><span class="line">  9 md</span><br><span class="line">...</span><br><span class="line">259 blkext</span><br></pre></td></tr></table></figure>
<h2 id="注册磁盘">注册磁盘</h2>
<p>尽管 register_blkdev() 函数获取了主设备号，但它并没有向系统提供设备（磁盘）。为了创建和使用块设备（磁盘），我们使用在 linux/genhd.h 中定义的专门接口。</p>
<p>在 linux/genhd.h 中定义的有用函数是用于注册 / 分配磁盘、将其添加到系统中以及注销 / 卸载磁盘的函数。</p>
<p><strong>alloc_disk() 函数用于分配磁盘，del_gendisk() 函数用于释放磁盘。使用 add_disk() 函数将磁盘添加到系统中</strong>。</p>
<p>通常在模块初始化函数中使用 alloc_disk() 和 add_disk() 函数，而在模块退出函数中使用 del_gendisk() 函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/genhd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_BLOCK_MINORS 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_block_dev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gendisk</span>* <span class="title">gd</span>;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; dev;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">create_block_device</span><span class="params">(<span class="keyword">struct</span> my_block_dev* dev)</span> &#123;</span><br><span class="line">    dev-&gt;gd = alloc_disk(MY_BLOCK_MINORS);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    add_disk(dev-&gt;gd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_block_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    create_block_device(&amp;dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">delete_block_device</span><span class="params">(<span class="keyword">struct</span> my_block_dev* dev)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;gd)</span><br><span class="line">        del_gendisk(dev-&gt;gd);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_block_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    delete_block_device(&amp;dev);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与字符设备一样，建议使用 my_block_dev 结构来存储描述块设备的重要元素。</p>
<p>请注意，在调用 add_disk() 函数之后（实际上，甚至包括调用期间），磁盘是活动的，可以随时调用其方法。因此，<strong>在驱动程序完全初始化并准备好响应对注册磁盘的请求之前，不应调用此函数</strong>。</p>
<p>可以注意到，用于处理块设备（磁盘）的基本结构是 struct gendisk 结构。</p>
<p>在调用 del_gendisk() 函数后，如果仍然有用户（对设备调用了打开操作，但关联的释放操作尚未被调用），则 struct gendisk 结构可能继续存在（并且设备操作仍然可以调用）。一种解决方法是 <strong> 记录设备的用户数</strong>，并仅在设备没有剩余用户后调用 del_gendisk() 函数。</p>
<h2 id="gendisk 结构体">gendisk 结构体</h2>
<p>Linux 提供了一个 gendisk 数据结构体，用来表示一个独立的磁盘设备或分区，用于对底层物理磁盘进行访问。在 gendisk 中有一个类似字符设备中 file_operations 的硬件操作结构指针，是 block_device_operations 结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/genhd.h 结构体已删减</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gendisk</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 描述磁盘使用的标识符；磁盘必须至少有一个次设备号；</span></span><br><span class="line"><span class="comment">       如果磁盘允许分区操作，则必须为每个可能的分区分配一个次设备号 */</span></span><br><span class="line">    <span class="type">int</span> major;       <span class="comment">/* 磁盘设备的主设备号 */</span></span><br><span class="line">    <span class="type">int</span> first_minor; <span class="comment">/* 磁盘的第一个次设备号 */</span></span><br><span class="line">    <span class="type">int</span> minors;      <span class="comment">/* 磁盘的次设备号数量，即磁盘的分区数量 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在 /proc/partitions 和 sysfs (/sys/block) 中显示 */</span></span><br><span class="line">    <span class="type">char</span> disk_name[DISK_NAME_LEN]; <span class="comment">/* name of major driver */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* (*devnode)(<span class="keyword">struct</span> gendisk* gd, <span class="type">umode_t</span>* mode);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> events; <span class="comment">/* supported events */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hd_struct</span> <span class="title">part0</span>;</span>  <span class="comment">/* 分区描述 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">block_device_operations</span>* <span class="title">fops</span>;</span> <span class="comment">/* 块设备操作集 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span>* <span class="title">queue</span>;</span>                <span class="comment">/* 磁盘对应的请求队列 */</span></span><br><span class="line">    <span class="type">void</span>* private_data;                         <span class="comment">/* 指向私有数据的指针 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于每一个分区来说，都有一个 hd_struct 结构体，用于描述该分区：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/genhd.h 结构体已删减</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hd_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 定义了该分区在块设备上的起始扇区和长度，唯一地描述了该分区 */</span></span><br><span class="line">    <span class="type">sector_t</span> start_sect;</span><br><span class="line">    <span class="type">sector_t</span> nr_sects;</span><br><span class="line"></span><br><span class="line">    <span class="type">sector_t</span> alignment_offset;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> discard_alignment;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">partition_meta_info</span>* <span class="title">info</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如上所述，这样的结构体是通过 alloc_disk() 调用获得的，在将其作为参数传入 add_disk() 函数之前，必须填充其字段。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/blkdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/genhd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_SECTORS 1024</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNEL_SECTOR_SIZE 512</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_block_dev</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="type">spinlock_t</span> lock;             <span class="comment">/* 互斥锁 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span>* <span class="title">queue</span>;</span> <span class="comment">/* 设备请求队列 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gendisk</span>* <span class="title">gd</span>;</span>          <span class="comment">/* gendisk 结构体 */</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; dev;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">create_block_device</span><span class="params">(<span class="keyword">struct</span> my_block_dev* dev)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/* 初始化 gendisk 结构体 */</span></span><br><span class="line">    dev-&gt;gd = alloc_disk(MY_BLOCK_MINORS);</span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;gd) &#123;</span><br><span class="line">        printk(KERN_NOTICE <span class="string">&quot;alloc_disk failure\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dev-&gt;gd-&gt;major = MY_BLOCK_MAJOR;</span><br><span class="line">    dev-&gt;gd-&gt;first_minor = <span class="number">0</span>;</span><br><span class="line">    dev-&gt;gd-&gt;fops = &amp;my_block_ops;</span><br><span class="line">    dev-&gt;gd-&gt;<span class="built_in">queue</span> = dev-&gt;<span class="built_in">queue</span>;</span><br><span class="line">    dev-&gt;gd-&gt;private_data = dev;</span><br><span class="line">    <span class="built_in">snprintf</span>(dev-&gt;gd-&gt;disk_name, <span class="number">32</span>, <span class="string">&quot;myblock&quot;</span>);</span><br><span class="line">    set_capacity(dev-&gt;gd, NR_SECTORS);  <span class="comment">// dev-gd-&gt;part0.nr_sects = NR_SECTORS</span></span><br><span class="line"></span><br><span class="line">    add_disk(dev-&gt;gd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如前所述，<strong>内核将磁盘视为一连串的 512 字节扇区 </strong>。实际上，设备可能具有不同大小的扇区。为了与这些设备一起工作，<strong> 内核需要了解实际扇区的大小，并且在所有操作中需要进行必要的转换</strong>。</p>
<p>要向内核通知设备的扇区大小，必须在分配请求队列后设置请求队列的参数，使用 blk_queue_logical_block_size() 函数完成设置。内核生成的所有请求都将是该扇区大小的倍数，并相应地对齐。但是，设备和驱动程序之间的通信仍将以 512 字节大小的扇区进行，因此每次都需要进行转换（上述代码中调用 set_capacity() 函数时就是一个例子）。</p>
<h2 id="block-device-operations 结构体">block_device_operations 结构体</h2>
<p>就像对于字符设备，需要完成 struct file_operations 中的操作一样，对于块设备，需要完成 struct block_device_operations 中的操作（来告诉 <strong> 文件系统</strong>，块设备驱动的操作接口）。操作的关联是通过 struct gendisk 结构体中的 fops 字段完成的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">block_device_operations</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*open)(<span class="keyword">struct</span> block_device*, <span class="type">fmode_t</span>);</span><br><span class="line">    <span class="type">int</span> (*release)(<span class="keyword">struct</span> gendisk*, <span class="type">fmode_t</span>);</span><br><span class="line">    <span class="type">int</span> (*locked_ioctl)(<span class="keyword">struct</span> block_device*, <span class="type">fmode_t</span>, <span class="type">unsigned</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">int</span> (*ioctl)(<span class="keyword">struct</span> block_device*, <span class="type">fmode_t</span>, <span class="type">unsigned</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">int</span> (*compat_ioctl)(<span class="keyword">struct</span> block_device*, <span class="type">fmode_t</span>, <span class="type">unsigned</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">int</span> (*direct_access)(<span class="keyword">struct</span> block_device*, <span class="type">sector_t</span>, <span class="type">void</span>**, <span class="type">unsigned</span> <span class="type">long</span>*);</span><br><span class="line">    <span class="type">int</span> (*media_changed)(<span class="keyword">struct</span> gendisk*);</span><br><span class="line">    <span class="type">int</span> (*revalidate_disk)(<span class="keyword">struct</span> gendisk*);</span><br><span class="line">    <span class="comment">// 获取磁盘信息，包括磁头、柱面和扇区等信息</span></span><br><span class="line">    <span class="type">int</span> (*getgeo)(<span class="keyword">struct</span> block_device*, <span class="keyword">struct</span> hd_geometry*);</span><br><span class="line">    <span class="type">blk_qc_t</span> (*submit_bio)(<span class="keyword">struct</span> bio* bio);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span>* <span class="title">owner</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和字符设备驱动不同，块设备驱动的 block_device_operations 操作集中没有负责读和写数据的函数；<strong>在块设备驱动中，这些操作是由 request() 函数处理的</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/genhd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_block_dev</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gendisk</span>* <span class="title">gd</span>;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; dev;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_block_open</span><span class="params">(<span class="keyword">struct</span> block_device* bdev, <span class="type">fmode_t</span> mode)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_block_release</span><span class="params">(<span class="keyword">struct</span> gendisk* gd, <span class="type">fmode_t</span> mode)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">block_device_operations</span> <span class="title">my_block_ops</span> =</span> &#123;.owner = THIS_MODULE, .open = my_block_open, .release = my_block_release&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">create_block_device</span><span class="params">(<span class="keyword">struct</span> my_block_dev* dev)</span> &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    dev-&gt;gd-&gt;fops = &amp;my_block_ops;</span><br><span class="line">    dev-&gt;gd-&gt;private_data = dev;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="请求队列">请求队列</h2>
<p>块设备驱动程序的核心是请求函数，包含请求处理过程。块设备的读写请求放置在请求队列中，在 struct gendisk 中，通过 struct request_queue *queue 指针指向请求队列。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/blkdev.h 结构体已删减</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">queue_head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request</span>* <span class="title">last_merge</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elevator_queue</span>* <span class="title">elevator</span>;</span></span><br><span class="line">    request_fn_proc* request_fn;</span><br><span class="line">    make_request_fn* make_request_fn;</span><br><span class="line">    <span class="type">void</span>* queuedata;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">icq_list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">queue_limits</span> <span class="title">limits</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blk_flush_queue</span>* <span class="title">fq</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">requeue_list</span>;</span></span><br><span class="line">    <span class="type">spinlock_t</span> requeue_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span> <span class="title">requeue_work</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="http://mickyching.github.io/kernel/linux-vfs-introduction.html">http://mickyching.github.io/kernel/linux-vfs-introduction.html</a></li>
<li><a href="http://mickyching.github.io/kernel/linux-vfs-source-annotation.html">http://mickyching.github.io/kernel/linux-vfs-source-annotation.html</a></li>
<li>磁盘结构：<a href="https://blog.csdn.net/weixin_37641832/article/details/103217311">https://blog.csdn.net/weixin_37641832/article/details/103217311</a></li>
<li>LBA: <a href="https://www.cnblogs.com/suv789/p/18536525">https://www.cnblogs.com/suv789/p/18536525</a></li>
<li><a href="https://lan-cyl.github.io/linux%20kernel/Linux-kernel-05-vfs.html">https://lan-cyl.github.io/linux kernel/Linux-kernel-05-vfs.html</a></li>
<li><a href="https://linux-kernel-labs-zh.xyz/labs/block_device_drivers.html">https://linux-kernel-labs-zh.xyz/labs/block_device_drivers.html</a></li>
<li><a href="https://linux-kernel-labs-zh.xyz/">https://linux-kernel-labs-zh.xyz/</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
        <category>文件系统</category>
      </categories>
      <tags>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 网络数据包接收过程</title>
    <url>/posts/241015195205.html</url>
    <content><![CDATA[<p>本文将介绍在 Linux 系统中，数据包是如何一步一步从网卡传到进程手中的。本文只讨论以太网的物理网卡，不涉及虚拟设备，并且以一个 UDP 包的接收过程作为示例。</p>
<span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> serverSocketFd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    bind(serverSocketFd, ...);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buff[BUFFSIZE];</span><br><span class="line">    <span class="type">int</span> readCount = recvfrom(serverSocketFd, buff, BUFFSIZE, <span class="number">0</span>, ...);</span><br><span class="line">    buff[readCount] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Receive from client:%s\n&quot;</span>, buff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码是一段 udp server 接收数据的逻辑。只要客户端有对应的数据发送过来，服务器端执行 recvfrom 后就能收到它，并把它打印出来。那么，<strong>当网络包到达网卡，直到 recvfrom 收到数据，这中间究竟都发生过什么</strong>？</p>
<h1 id="Linux 网络架构">Linux 网络架构</h1>
<p>在 Linux 内核实现中，<strong>链路层协议靠网卡驱动来实现，内核协议栈来实现网络层和传输层，内核对更上层的应用层提供 socket 接口来供用户进程访问</strong>。我们用 Linux 的视角看到的 TCP/IP 网络分层模型应该是下面这个样子的。</p>
<img src="/images/linux-kernel/linux-net-arch.png" alt="Linux 视角的网络协议栈" width="80%" height="80%">
<p>在 Linux 的源代码中，网络设备驱动对应的逻辑位于 <code>driver/net/ethernet</code>, 其中 intel 系列网卡的驱动在<code>driver/net/ethernet/intel</code> 目录下。协议栈模块代码位于 kernel 和 net 目录。</p>
<h1 id="内核的软硬中断">内核的软硬中断</h1>
<p>内核和网络设备驱动是通过中断的方式来处理的。当网络设备上有数据到达的时候，会给 CPU 的相关引脚上触发一个电压变化，以通知 CPU 来处理数据。</p>
<p>对于网络模块来说，由于处理过程比较复杂和耗时，如果在硬中断函数中完成所有的处理，将会导致中断处理函数（其优先级过高）将过度占据 CPU，将导致 CPU 无法响应其它设备，例如鼠标和键盘的消息。因此，<strong>Linux 中断处理函数是分上半部和下半部的</strong>。</p>
<p>上半部是只进行最简单的工作，快速处理然后释放 CPU，接着 CPU 就可以允许其它中断进来。剩下的绝大部分工作都被放到下半部中，可以慢慢地从容处理。</p>
<p>2.4 以后的内核版本采用的下半部实现方式是软中断，由 ksoftirqd 内核线程全权处理。和硬中断不同的是，硬中断是通过给 CPU 物理引脚施加电压变化，而软中断是通过给内存中的一个变量的二进制值以通知软中断处理程序。</p>
<h1 id="网卡到内存">网卡到内存</h1>
<p>网卡需要有驱动才能工作，驱动是加载到内核中的一个模块——负责衔接网卡和内核的网络模块。驱动在加载的时候 <strong> 将自己注册进 </strong> 网络模块，当相应的网卡收到数据包时，网络模块 <strong> 会调用 </strong> 相应的驱动程序处理数据。</p>
<p>下图展示了数据包（packet）如何进入内存，并被内核的网络模块开始处理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                   +-----+</span><br><span class="line">                   |     |                            Memroy</span><br><span class="line">+--------+   1     |     |  2  DMA     +--------+--------+--------+--------+</span><br><span class="line">| Packet |--------&gt;| NIC |------------&gt;| Packet | Packet | Packet | ...... |</span><br><span class="line">+--------+         |     |             +--------+--------+--------+--------+</span><br><span class="line">                   |     |&lt;--------+</span><br><span class="line">                   +-----+         |</span><br><span class="line">                      |            +---------------+</span><br><span class="line">                      |                            |</span><br><span class="line">                    3 | Raise IRQ                  | Disable IRQ</span><br><span class="line">                      |                          5 |</span><br><span class="line">                      |                            |</span><br><span class="line">                      ↓                            |</span><br><span class="line">                   +-----+                   +------------+</span><br><span class="line">                   |     |  Run IRQ handler  |            |</span><br><span class="line">                   | CPU |------------------&gt;| NIC Driver |</span><br><span class="line">                   |     |       4           |            |</span><br><span class="line">                   +-----+                   +------------+</span><br><span class="line">                                                   |</span><br><span class="line">                                                6  | Raise soft IRQ</span><br><span class="line">                                                   |</span><br><span class="line">                                                   ↓</span><br></pre></td></tr></table></figure>
<p>1：数据包从外面的网络进入物理网卡（NIC）。如果目的 MAC 地址不是该网卡，且该网卡没有开启混杂模式，该包会被网卡丢弃。</p>
<p>2：网卡将数据包通过 DMA 的方式写入到指定的内存地址，该地址由网卡驱动分配并初始化。注：老的网卡可能不支持 DMA，不过新的网卡一般都支持。</p>
<p>3：网卡通过硬件中断（IRQ）通知 CPU，告诉它有数据来了。</p>
<p>4：CPU 根据中断表，调用已经注册的中断函数，这个中断函数会调到驱动程序（NIC Driver）中相应的函数。</p>
<p>5：驱动先禁用网卡的中断，表示驱动程序已经知道内存中有数据了，告诉网卡下次再收到数据包时，直接写内存就可以了，不要再通知 CPU 了。这样可以提高效率，避免 CPU 不停的被中断。</p>
<p>6：启动软中断。这步结束后，硬件中断处理函数就结束返回了。</p>
<p><strong>由于硬中断处理程序执行的过程中不能被中断，所以如果它执行时间过长，会导致 CPU 没法响应其它硬件的中断，于是内核引入软中断，这样可以将硬中断处理函数中耗时的部分移到软中断处理函数里面来慢慢处理</strong>。</p>
<h1 id="内核的网络模块">内核的网络模块</h1>
<p>软中断会触发内核网络模块中的软中断处理函数，后续流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                                            +-----+</span><br><span class="line">                                    17      |     |</span><br><span class="line">                               +-----------&gt;| NIC |</span><br><span class="line">                               |            |     |</span><br><span class="line">                               |Enable IRQ  +-----+</span><br><span class="line">                               |</span><br><span class="line">                               |</span><br><span class="line">                         +------------+                                      Memroy</span><br><span class="line">                         |            |        Read           +--------+--------+--------+--------+</span><br><span class="line">        +---------------&gt;| NIC Driver |&lt;--------------------- | Packet | Packet | Packet | ...... |</span><br><span class="line">        |                |            |          9            +--------+--------+--------+--------+</span><br><span class="line">        |                +------------+</span><br><span class="line">        |                      |    |        skb</span><br><span class="line">   Poll | 8      Raise softIRQ | 6  +-----------------+</span><br><span class="line">        |                      |             10       |</span><br><span class="line">        |                      ↓                      ↓</span><br><span class="line">+---------------+  Call  +-----------+        +------------------+        +--------------------+  12  +---------------------+</span><br><span class="line">| net_rx_action |&lt;-------| ksoftirqd |        | napi_gro_receive |-------&gt;| enqueue_to_backlog |-----&gt;| CPU input_pkt_queue |</span><br><span class="line">+---------------+   7    +-----------+        +------------------+   11   +--------------------+      +---------------------+</span><br><span class="line">                                                      |                                                      | 13</span><br><span class="line">                                                   14 |        + - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">                                                      ↓        ↓</span><br><span class="line">                                           +--------------------------+    15      +------------------------+</span><br><span class="line">                                           | __netif_receive_skb_core |-----------&gt;| packet taps(AF_PACKET) |</span><br><span class="line">                                           +--------------------------+            +------------------------+</span><br><span class="line">                                                      |</span><br><span class="line">                                                      | 16</span><br><span class="line">                                                      ↓</span><br><span class="line">                                             +-----------------+</span><br><span class="line">                                             | protocol layers |</span><br><span class="line">                                             +-----------------+</span><br></pre></td></tr></table></figure>
<p>7：内核中的 ksoftirqd 进程专门负责软中断的处理，当它收到软中断后，就会调用相应软中断所对应的处理函数，对于上面第 6 步中是网卡驱动模块抛出的软中断，ksoftirqd 会调用网络模块的 net_rx_action 函数。</p>
<p>8：net_rx_action 函数调用网卡驱动里的 poll 函数来一个一个的处理数据包，如 Intel 的 IGB 网卡的 igb_poll 函数。</p>
<p>9：在 pool 函数中，驱动会一个接一个的读取网卡写到内存中的数据包，内存中数据包的格式只有驱动知道。</p>
<p>10：驱动程序将内存中的数据包转换成内核网络模块能识别的 skb 格式，然后调用 napi_gro_receive 函数，将数据包交给内核。</p>
<p>11：napi_gro_receive 会处理 GRO 相关的内容，也就是将可以合并的数据包进行合并，这样就只需要调用一次协议栈。然后判断是否开启了 RPS，如果开启了，将会调用 enqueue_to_backlog。</p>
<p>12：在 enqueue_to_backlog 函数中，会将数据包放入 CPU 的 softnet_data 结构体的 input_pkt_queue 中，然后返回。如果 input_pkt_queue 满了的话，该数据包将会被丢弃，queue 的大小可以通过 net.core.netdev_max_backlog 来配置。</p>
<p>13：CPU 会接着在自己的软中断上下文中处理自己 input_pkt_queue 里的网络数据（调用__netif_receive_skb_core）。</p>
<p>14：如果没开启 RPS，napi_gro_receive 会直接调用__netif_receive_skb_core。</p>
<p>15：看是不是有 AF_PACKET 类型的 socket（也就是我们常说的原始套接字），如果有的话，拷贝一份数据给它。tcpdump 抓包就是抓的这里的包。</p>
<p>16：调用协议栈相应的函数，将数据包交给协议栈处理。</p>
<p>17：待内存中的所有数据包被处理完成后（即 poll 函数执行完成），启用网卡的硬中断，这样下次网卡再收到数据的时候就会通知 CPU。</p>
<blockquote>
<p>enqueue_to_backlog 函数也会被 netif_rx 函数调用，而 netif_rx 正是 lo 设备发送数据包时调用的函数。</p>
</blockquote>
<h1 id="协议栈">协议栈</h1>
<h2 id="IP 层">IP 层</h2>
<p>由于是 UDP 包，所以第一步会进入 IP 层，然后一级一级的函数往下调：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">          |</span><br><span class="line">          | 16</span><br><span class="line">          ↓         promiscuous mode &amp;&amp;</span><br><span class="line">      +--------+    PACKET_OTHERHOST (set by driver)   +-----------------+</span><br><span class="line">      | ip_rcv |--------------------------------------&gt;| drop this packet|</span><br><span class="line">      +--------+                                       +-----------------+</span><br><span class="line">          |</span><br><span class="line">          |</span><br><span class="line">          ↓</span><br><span class="line">+---------------------+</span><br><span class="line">| NF_INET_PRE_ROUTING |</span><br><span class="line">+---------------------+</span><br><span class="line">          |</span><br><span class="line">          |</span><br><span class="line">          ↓</span><br><span class="line">      +---------+</span><br><span class="line">      |         | enabled ip forword  +------------+        +----------------+</span><br><span class="line">      | routing |--------------------&gt;| ip_forward |-------&gt;| NF_INET_FORWARD|</span><br><span class="line">      |         |  DIP is not local   +------------+        +----------------+</span><br><span class="line">      +---------+                                                   |</span><br><span class="line">          |                                                         |</span><br><span class="line">          | destination IP is local                                 ↓</span><br><span class="line">          ↓                                                 +---------------+</span><br><span class="line"> +------------------+                                       | dst_output_sk |</span><br><span class="line"> | ip_local_deliver |                                       +---------------+</span><br><span class="line"> +------------------+</span><br><span class="line">          |</span><br><span class="line">          |</span><br><span class="line">          ↓</span><br><span class="line"> +------------------+</span><br><span class="line"> | NF_INET_LOCAL_IN |</span><br><span class="line"> +------------------+</span><br><span class="line">          |</span><br><span class="line">          |</span><br><span class="line">          ↓</span><br><span class="line">    +-----------+</span><br><span class="line">    | UDP layer |</span><br><span class="line">    +-----------+</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>ip_rcv</strong>：该函数是 IP 模块的入口函数，在该函数里面，第一件事就是将垃圾数据包（目的 MAC 地址不是当前网卡，但由于网卡设置了混杂模式而被接收进来）直接丢掉，然后调用注册在 NF_INET_PRE_ROUTING 上的函数。</li>
<li><strong>NF_INET_PRE_ROUTING</strong>：netfilter 放在协议栈中的钩子，可以通过 iptables 来注入一些数据包处理函数，用来修改或者丢弃数据包，如果数据包没被丢弃，将继续往下走。</li>
<li><strong>routing</strong>：进行路由，如果是目的 IP 不是本地 IP，且没有开启 ip forward 功能，那么数据包将被丢弃，如果开启了 ip forward 功能，那将进入 ip_forward 函数。</li>
<li><strong>ip_forward</strong>：ip_forward 会先调用 netfilter 注册的 NF_INET_FORWARD 相关函数，如果数据包没有被丢弃，那么将继续往后调用 dst_output_sk 函数。</li>
<li><strong>dst_output_sk</strong>：该函数会调用 IP 层的相应函数将该数据包发送出去，同下一篇要介绍的数据包发送流程的后半部分一样。</li>
<li><strong>ip_local_deliver</strong>：如果上面 routing 的时候发现目的 IP 是本地 IP，那么将会调用该函数。在该函数中，会先调用 NF_INET_LOCAL_IN 相关的钩子程序，如果通过，数据包将会向下发送到 UDP 层。</li>
</ul>
<h2 id="UDP 层">UDP 层</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         |</span><br><span class="line">         |</span><br><span class="line">         ↓</span><br><span class="line">     +---------+            +-----------------------+</span><br><span class="line">     | udp_rcv |-----------&gt;| __udp4_lib_lookup_skb |</span><br><span class="line">     +---------+            +-----------------------+</span><br><span class="line">         |</span><br><span class="line">         |</span><br><span class="line">         ↓</span><br><span class="line">+--------------------+      +-----------+</span><br><span class="line">| sock_queue_rcv_skb |-----&gt;| sk_filter |</span><br><span class="line">+--------------------+      +-----------+</span><br><span class="line">         |</span><br><span class="line">         |</span><br><span class="line">         ↓</span><br><span class="line">+------------------+</span><br><span class="line">| __skb_queue_tail |</span><br><span class="line">+------------------+</span><br><span class="line">         |</span><br><span class="line">         |</span><br><span class="line">         ↓</span><br><span class="line"> +---------------+</span><br><span class="line"> | sk_data_ready |</span><br><span class="line"> +---------------+</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>udp_rcv</strong>：该函数是 UDP 模块的入口函数，它里面会调用其它的函数，主要是做一些必要的检查，其中一个重要的调用是__udp4_lib_lookup_skb，该函数会根据目的 IP 和端口找对应的 socket，如果没有找到相应的 socket，那么该数据包将会被丢弃，否则继续。</li>
<li><strong>sock_queue_rcv_skb</strong>：主要干了两件事，一是检查这个 socket 的 receive buffer 是不是满了，如果满了的话，丢弃该数据包，然后就是调用 sk_filter 看这个包是否是满足条件的包，如果当前 socket 上设置了 filter，且该包不满足条件的话，这个数据包也将被丢弃（在 Linux 里面，每个 socket 上都可以像 tcpdump 里面一样定义 filter，不满足条件的数据包将会被丢弃）。</li>
<li><strong>__skb_queue_tail</strong>：将数据包放入 socket 接收队列的末尾。</li>
<li><strong>sk_data_ready</strong>：通知 socket 数据包已经准备好。</li>
</ul>
<blockquote>
<p>调用完 sk_data_ready 之后，一个数据包处理完成，等待应用层程序来读取，上面所有函数的执行过程都在软中断的上下文中。</p>
</blockquote>
<h1 id="socket">socket</h1>
<p>应用层一般有两种方式接收数据，一种是 recvfrom 函数阻塞在那里等着数据来，这种情况下当 socket 收到通知后，recvfrom 就会被唤醒，然后读取接收队列的数据；另一种是通过 epoll 或者 select 监听相应的 socket，当收到通知后，再调用 recvfrom 函数去读取接收队列的数据。两种情况都能正常的接收到相应的数据包。</p>
<blockquote>
<p>了解数据包的接收流程有助于帮助我们搞清楚我们可以在哪些地方监控和修改数据包，哪些情况下数据包可能被丢弃，为我们处理网络问题提供了一些参考。同时了解 netfilter 中相应钩子的位置，对于了解 iptables 的用法有一定的帮助，同时也会帮助我们后续更好的理解 Linux 下的网络虚拟设备。</p>
</blockquote>
<h1 id="Linux 启动">Linux 启动</h1>
<p>内核协议栈等模块在具备接收网卡数据包之前，要做很多的准备工作才行。比如，<strong>要提前创建好 ksoftirqd 内核线程，要注册好各个协议对应的处理函数，网络设备子系统要提前初始化好，网卡要启动好</strong>。只有这些都 Ready 之后，我们才能真正开始接收数据包。那么，我们现在来看看这些准备工作都是怎么做的。</p>
<p>下面主要结合 Linux 3.10 内核代码，对上面的流程概述进行更详细的分析。</p>
<h2 id="ksoftirqd 线程创建">ksoftirqd 线程创建</h2>
<p>Linux 的软中断都是在专门的内核线程（ksoftirqd）中进行的。因此，我们非常有必要看一下这些线程是怎么初始化的，这样我们才能在后面更准确地了解收包过程。该线程数量不是 1 个，而是 N 个，其中 N 等于你的机器的核数。</p>
<p>定义用于管理 SoftIRQ 处理的线程化机制的全局变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: kernel/softirq.c</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">smp_hotplug_thread</span> <span class="title">softirq_threads</span> =</span> &#123;</span><br><span class="line">    .store = &amp;ksoftirqd,                        <span class="comment">// 指向每个 CPU 的 ksoftirqd 线程的地址</span></span><br><span class="line">    .thread_should_run = ksoftirqd_should_run,  <span class="comment">// 线程是否需要被唤醒执行的回调函数</span></span><br><span class="line">    .thread_fn = run_ksoftirqd,                 <span class="comment">// 实际执行软中断处理的回调函数</span></span><br><span class="line">    .thread_comm = <span class="string">&quot;ksoftirqd/%u&quot;</span>,              <span class="comment">// 线程的名称，%u 用于表示对应的 CPU 编号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DEFINE_PER_CPU(<span class="keyword">struct</span> task_struct *, ksoftirqd);  <span class="comment">// 定义每个 CPU 都有的线程任务</span></span><br></pre></td></tr></table></figure>
<p>定义一个内核初始化函数，用于启动每个 CPU 上的 ksoftirqd 线程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: kernel/softirq.c</span></span><br><span class="line"><span class="type">static</span> __init <span class="type">int</span> <span class="title function_">spawn_ksoftirqd</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 注册 SoftIRQ 线程。如果注册失败，触发 BUG 并停止系统</span></span><br><span class="line">    BUG_ON(smpboot_register_percpu_thread(&amp;softirq_threads));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统启动的早期阶段调用这个函数，确保 SoftIRQ 线程在系统初始化时被注册</span></span><br><span class="line">early_initcall(spawn_ksoftirqd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file: kernel/smpboot.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * smpboot_register_percpu_thread - Register a per_cpu thread related to hotplug</span></span><br><span class="line"><span class="comment"> * @plug_thread:    Hotplug thread descriptor</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Creates and starts the threads on all online cpus.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">smpboot_register_percpu_thread</span><span class="params">(<span class="keyword">struct</span> smp_hotplug_thread* plug_thread)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> cpu;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;smpboot_threads_lock);</span><br><span class="line">    for_each_online_cpu(cpu) &#123;</span><br><span class="line">        ret = __smpboot_create_thread(plug_thread, cpu);  <span class="comment">// 为当前 CPU 创建线程</span></span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            smpboot_destroy_threads(plug_thread);  <span class="comment">// 销毁所有已创建的线程</span></span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 唤醒新创建的线程，使其开始处理 SoftIRQ</span></span><br><span class="line">        smpboot_unpark_thread(plug_thread, cpu);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将当前线程 fd 添加到热插拔线程的全局链表中，以便后续管理</span></span><br><span class="line">    list_add(&amp;plug_thread-&gt;<span class="built_in">list</span>, &amp;hotplug_threads);</span><br><span class="line">out:</span><br><span class="line">    mutex_unlock(&amp;smpboot_threads_lock);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(smpboot_register_percpu_thread);</span><br></pre></td></tr></table></figure>
<p>当 ksoftirqd 被创建出来以后，它就会进入自己的线程循环函数 ksoftirqd_should_run 和 run_ksoftirqd 了。不停地判断有没有软中断需要被处理。这里需要注意的一点是，软中断不仅仅只有网络软中断，还有其它类型。</p>
<h2 id="网络子系统初始化">网络子系统初始化</h2>
<p>Linux 内核通过调用 subsys_initcall 来初始化各个子系统，其中网络子系统的初始化会执行到 net_dev_init 函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: net/core/dev.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">net_dev_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    for_each_possible_cpu(i) &#123;</span><br><span class="line">        <span class="comment">// 获取每个 CPU 的 softnet_data 结构</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> *<span class="title">sd</span> =</span> &amp;per_cpu(softnet_data, i);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(sd, <span class="number">0</span>, <span class="keyword">sizeof</span>(*sd));</span><br><span class="line">        <span class="comment">// 初始化接收数据包的队列（尚未处理）、处理数据包的队列</span></span><br><span class="line">        skb_queue_head_init(&amp;sd-&gt;input_pkt_queue);</span><br><span class="line">        skb_queue_head_init(&amp;sd-&gt;process_queue);</span><br><span class="line">        sd-&gt;completion_queue = <span class="literal">NULL</span>;</span><br><span class="line">        INIT_LIST_HEAD(&amp;sd-&gt;poll_list);  <span class="comment">// 初始化轮询列表</span></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 打开网络发送和接收的软中断，并注册处理函数</span></span><br><span class="line">    open_softirq(NET_TX_SOFTIRQ, net_tx_action);</span><br><span class="line">    open_softirq(NET_RX_SOFTIRQ, net_rx_action);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subsys_initcall(net_dev_init);</span><br></pre></td></tr></table></figure>
<p>在这个函数里，会为每个 CPU 都申请一个 softnet_data 数据结构，在这个数据结构里的 poll_list (struct list_head) 是 <strong> 等待驱动程序将其 poll 函数注册进来的</strong>，稍后网卡驱动初始化的时候我们可以看到这一过程。</p>
<p>另外，open_softirq 函数为每一种软中断都注册一个处理函数。NET_TX_SOFTIRQ 的处理函数为 net_tx_action，NET_RX_SOFTIRQ 的处理函数为 net_rx_action。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: kernel/softirq.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">open_softirq</span><span class="params">(<span class="type">int</span> nr, <span class="type">void</span> (*action)(<span class="keyword">struct</span> softirq_action*))</span> &#123;</span><br><span class="line">    softirq_vec[nr].action = action;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管理 SoftIRQ 的数组，它存储了每种软中断类型对应的处理函数</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span> <span class="title">softirq_vec</span>[<span class="title">NR_SOFTIRQS</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// file: include/linux/interrupt.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> (*action)(<span class="keyword">struct</span> softirq_action*);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>open_softirq 会把不同的 action 记录在 softirq_vec 全局变量里的。后面 ksoftirqd 线程收到软中断的时候，也会使用这个全局变量来找到每一种软中断对应的处理函数。</p>
<h2 id="协议栈注册">协议栈注册</h2>
<p>内核实现了网络层的 ip 协议，也实现了传输层的 tcp 协议和 udp 协议。这些协议对应的实现函数分别是 ip_rcv(), tcp_v4_rcv() 和 udp_rcv()。和我们平时写代码的方式不一样的是，<strong>内核是通过注册的方式来实现的</strong>。</p>
<p>Linux 内核中的 fs_initcall 和 subsys_initcall 类似，也是初始化模块的入口。fs_initcall 调用 inet_init 函数后开始网络协议栈注册。通过 inet_init，将这些函数注册到了 inet_protos 和 ptype_base 全局变量中。</p>
<img src="/images/linux-kernel/linux-inet-init.png" alt="协议栈注册" width="100%" height="100%">
<p>相关代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: net/ipv4/af_inet.c</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">packet_type</span> <span class="title">ip_packet_type</span> __<span class="title">read_mostly</span> =</span> &#123;</span><br><span class="line">    .type = cpu_to_be16(ETH_P_IP),  <span class="comment">// 指定包类型为 IPv4 包，Big-Endian 16-bits</span></span><br><span class="line">    .func = ip_rcv,                 <span class="comment">// 接收到 IP 包时的处理函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_protocol</span> <span class="title">udp_protocol</span> =</span> &#123;</span><br><span class="line">    .handler = udp_rcv,      <span class="comment">// 接收到 UDP 包时的处理函数</span></span><br><span class="line">    .err_handler = udp_err,  <span class="comment">// 发生错误时的处理函数</span></span><br><span class="line">    .no_policy = <span class="number">1</span>,          <span class="comment">// 不使用安全策略</span></span><br><span class="line">    .netns_ok = <span class="number">1</span>,           <span class="comment">// 支持网络命名空间（Network Namespaces）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_protocol</span> <span class="title">tcp_protocol</span> =</span> &#123;</span><br><span class="line">    .early_demux = tcp_v4_early_demux,  <span class="comment">// 在早期阶段做 TCP 的多路分解</span></span><br><span class="line">    .handler = tcp_v4_rcv,</span><br><span class="line">    .err_handler = tcp_v4_err,</span><br><span class="line">    .no_policy = <span class="number">1</span>,</span><br><span class="line">    .netns_ok = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 IPv4 协议栈的函数，__init 宏表示该函数在内核启动时调用</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">inet_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 将 ICMP(1), UDP(17), TCP(6) 协议处理程序注册到 IPv4 协议栈</span></span><br><span class="line">    <span class="keyword">if</span> (inet_add_protocol(&amp;icmp_protocol, IPPROTO_ICMP) &lt; <span class="number">0</span>)</span><br><span class="line">        pr_crit(<span class="string">&quot;%s: Cannot add ICMP protocol\n&quot;</span>, __func__);</span><br><span class="line">    <span class="keyword">if</span> (inet_add_protocol(&amp;udp_protocol, IPPROTO_UDP) &lt; <span class="number">0</span>)</span><br><span class="line">        pr_crit(<span class="string">&quot;%s: Cannot add UDP protocol\n&quot;</span>, __func__);</span><br><span class="line">    <span class="keyword">if</span> (inet_add_protocol(&amp;tcp_protocol, IPPROTO_TCP) &lt; <span class="number">0</span>)</span><br><span class="line">        pr_crit(<span class="string">&quot;%s: Cannot add TCP protocol\n&quot;</span>, __func__);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 IP 数据包处理函数</span></span><br><span class="line">    dev_add_pack(&amp;ip_packet_type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中我们可以看到，全局变量 udp_protocol 中的.handler 是 udp_rcv，tcp_protocol 中的.handler 是 tcp_v4_rcv，都通过 inet_add_protocol 被初始化了进来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">inet_add_protocol</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> net_protocol *prot, <span class="type">unsigned</span> <span class="type">char</span> protocol)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!prot-&gt;netns_ok) &#123;</span><br><span class="line">        <span class="comment">// 如果该协议不支持网络命名空间，打印错误并返回</span></span><br><span class="line">        pr_err(<span class="string">&quot;Protocol %u is not namespace aware, cannot register.\n&quot;</span>, protocol);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 cmpxchg(compare-and-swap) 原子操作尝试将 inet_protos[protocol] 赋值为 prot，</span></span><br><span class="line">    <span class="comment">// 如果 inet_protos[protocol] 之前是 NULL，则设置为 prot 并返回 0</span></span><br><span class="line">    <span class="comment">// 如果已经有协议注册在该位置，则返回 -1，表示注册失败</span></span><br><span class="line">    <span class="keyword">return</span> !cmpxchg((<span class="type">const</span> <span class="keyword">struct</span> net_protocol **)&amp;inet_protos[protocol], <span class="literal">NULL</span>, prot) ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_protocol</span> *<span class="title">inet_protos</span>[<span class="title">MAX_INET_PROTOS</span>];</span></span><br></pre></td></tr></table></figure>
<p>inet_add_protocol 函数将 tcp 和 udp 对应的处理函数都注册到了 <strong>inet_protos 全局数组</strong> 中了。</p>
<p>再看 dev_add_pack(&amp;ip_packet_type)这一行，全局变量 ip_packet_type 中的.type 是协议类型，.func 是 ip_rcv 函数，在 dev_add_pack 中会被注册到 <strong>ptype_base 全局哈希表</strong> 中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dev_add_pack</span><span class="params">(<span class="keyword">struct</span> packet_type *pt)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">head</span> =</span> ptype_head(pt);</span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;ptype_lock);</span><br><span class="line">    list_add_rcu(&amp;pt-&gt;<span class="built_in">list</span>, head);</span><br><span class="line">    spin_unlock(&amp;ptype_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> list_head *<span class="title function_">ptype_head</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> packet_type *pt)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pt-&gt;type == htons(ETH_P_ALL)) &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;ptype_all;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// PTYPE_HASH_MASK 用来计算哈希值（哈希桶）</span></span><br><span class="line">        <span class="keyword">return</span> &amp;ptype_base[ntohs(pt-&gt;type) &amp; PTYPE_HASH_MASK];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于特定数据包的协议类型（如 IPv4、IPv6、ARP 等）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">ptype_base</span>[<span class="title">PTYPE_HASH_SIZE</span>] __<span class="title">read_mostly</span>;</span></span><br><span class="line"><span class="comment">// 不论协议类型是什么，用于处理所有接收到的数据包</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">ptype_all</span> __<span class="title">read_mostly</span>;</span></span><br></pre></td></tr></table></figure>
<p>这里我们需要记住 inet_protos 数组记录着 udp，tcp 的处理函数地址，ptype_base 数组存储着 ip_rcv 函数的处理地址。后面我们会看到软中断中会通过 ptype_base 找到 ip_rcv 函数地址，进而将 ip 包正确地送到 ip_rcv() 中执行。在 ip_rcv 中将会通过 inet_protos 数组找到 tcp 或者 udp 的处理函数，再而把包转发给 udp_rcv() 或 tcp_v4_rcv() 函数。</p>
<blockquote>
<p>扩展一下，如果看一下 ip_rcv 和 udp_rcv 等函数的代码能看到很多协议的处理过程。例如，ip_rcv 中会处理 netfilter 和 iptable 过滤，如果你有很多或者很复杂的 netfilter 或 iptables 规则，这些规则都是在软中断的上下文中执行的，会加大网络延迟。再例如，udp_rcv 中会判断 socket 接收队列是否满了。对应的相关内核参数是 net.core.rmem_max 和 net.core.rmem_default。如果有兴趣，建议大家好好读一下 inet_init 这个函数的代码。</p>
</blockquote>
<h2 id="网卡驱动初始化">网卡驱动初始化</h2>
<p>每一个驱动程序（不仅仅只是网卡驱动）会使用 module_init 向内核注册一个初始化函数，当驱动被加载时，内核会调用这个初始化函数。比如 igb 网卡驱动的代码位于 drivers/net/ethernet/intel/igb/igb_main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: drivers/net/ethernet/intel/igb/igb_main.c</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pci_driver</span> <span class="title">igb_driver</span> =</span> &#123;</span><br><span class="line">    .name     = igb_driver_name,  <span class="comment">// &quot;igb&quot;</span></span><br><span class="line">    .id_table = igb_pci_tbl,</span><br><span class="line">    .probe    = igb_probe,</span><br><span class="line">    .remove   = igb_remove,</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">igb_init_module</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    ret = pci_register_driver(&amp;igb_driver);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(igb_init_module);</span><br></pre></td></tr></table></figure>
<p>驱动的 pci_register_driver 调用完成后，Linux 内核就知道了该驱动的相关信息，比如 igb 网卡驱动的 igb_driver_name 和 igb_probe 函数地址等等。当网卡设备被识别以后，内核会调用其驱动的.probe 方法（这里是 igb_probe）。驱动.probe 方法执行的目的就是让设备 ready，对于 igb 网卡，其 igb_probe 位于 drivers/net/ethernet/intel/igb/igb_main.c 下。主要执行的操作如下：</p>
<img src="/images/linux-kernel/linux-igb-nic-int.png" alt="网卡驱动初始化" width="100%" height="100%">
<p>第 5 步中我们看到，网卡驱动实现了 ethtool 所需要的接口，也在这里注册完成函数地址的注册。当 ethtool 发起一个系统调用之后，内核会找到对应操作的回调函数。对于 igb 网卡来说，其实现函数都在 drivers/net/ethernet/intel/igb/igb_ethtool.c 下。相信你这次能彻底理解 ethtool 的工作原理了吧？这个命令之所以能查看网卡收发包统计、能修改网卡自适应模式、能调整 RX 队列的数量和大小，是因为 ethtool 命令最终调用到了网卡驱动的相应方法，而不是 ethtool 本身有这个超能力。</p>
<p>第 6 步注册的 igb_netdev_ops 中包含的是 igb_open 等函数，该函数在网卡被启动的时候会被调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: drivers/net/ethernet/intel/igb/igb_main.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_device_ops</span> <span class="title">igb_netdev_ops</span> =</span> &#123;</span><br><span class="line">    .ndo_open               = igb_open,</span><br><span class="line">    .ndo_stop               = igb_close,</span><br><span class="line">    .ndo_start_xmit         = igb_xmit_frame,</span><br><span class="line">    .ndo_get_stats64        = igb_get_stats64,</span><br><span class="line">    .ndo_set_rx_mode        = igb_set_rx_mode,</span><br><span class="line">    .ndo_set_mac_address    = igb_set_mac,</span><br><span class="line">    .ndo_change_mtu         = igb_change_mtu,</span><br><span class="line">    .ndo_do_ioctl           = igb_ioctl,</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第 7 步中，在 igb_probe 初始化过程中，还调用到了 igb_alloc_q_vector。<strong>它注册了一个 NAPI 机制所必须的 poll 函数，对于 igb 网卡驱动来说，这个函数就是 igb_poll</strong>，如下代码所示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">igb_alloc_q_vector</span><span class="params">(<span class="keyword">struct</span> igb_adapter *adapter,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> v_count, <span class="type">int</span> v_idx,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> txr_count, <span class="type">int</span> txr_idx,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> rxr_count, <span class="type">int</span> rxr_idx)</span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">/* initialize NAPI */</span></span><br><span class="line">    netif_napi_add(adapter-&gt;netdev, &amp;q_vector-&gt;napi, igb_poll, <span class="number">64</span>);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>NAPI（New API）机制：Linux 内核中的一种网络中断处理机制——在网卡收到数据包后，触发一次中断，然后通过 poll 机制处理接收和发送队列中的数据。处理完成后会根据需要重新启用中断。目的：通过将高频中断转换为轮询，可以在网络负载较高时提高系统的处理效率，减少由于中断频率过高导致的 CPU 开销。</p>
</blockquote>
<h2 id="启动网卡">启动网卡</h2>
<p>当上面的初始化都完成以后，就可以启动网卡了。回忆前面网卡驱动初始化时，我们提到了驱动向内核注册了 igb_netdev_ops 变量，它包含着网卡启用、发包、设置 MAC 地址等回调函数。当启用一个网卡时（例如，通过 ifconfig eth0 up），net_device_ops 中的 igb_open 方法会被调用。它通常会做以下事情：</p>
<img src="/images/linux-kernel/linux-igb-nic-start.png" alt="启动网卡" width="100%" height="100%">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: drivers/net/ethernet/intel/igb/igb_main.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __igb_open(<span class="keyword">struct</span> net_device* netdev, <span class="type">bool</span> resuming) &#123;</span><br><span class="line">    <span class="comment">/* allocate transmit descriptors */</span></span><br><span class="line">    err = igb_setup_all_tx_resources(adapter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate receive descriptors */</span></span><br><span class="line">    err = igb_setup_all_rx_resources(adapter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注册中断处理函数 */</span></span><br><span class="line">    err = igb_request_irq(adapter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 启用 NAPI */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; adapter-&gt;num_q_vectors; i++)</span><br><span class="line">        napi_enable(&amp;(adapter-&gt;q_vector[i]-&gt;napi));</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面__igb_open 函数调用了 igb_setup_all_tx_resources 和 igb_setup_all_rx_resources。在 igb_setup_all_rx_resources 这一步操作中，分配了 RingBuffer，并建立内存和 Rx 队列的映射关系（Rx/Tx 队列的数量和大小可以通过 ethtool 进行配置）。我们再接着看中断函数注册 igb_request_irq；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">igb_request_irq</span><span class="params">(<span class="keyword">struct</span> igb_adapter* adapter)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (adapter-&gt;msix_entries) &#123;</span><br><span class="line">        err = igb_request_msix(adapter);</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">igb_request_msix</span><span class="params">(<span class="keyword">struct</span> igb_adapter* adapter)</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; adapter-&gt;num_q_vectors; i++) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        err = request_irq(adapter-&gt;msix_entries[<span class="built_in">vector</span>].<span class="built_in">vector</span>,</span><br><span class="line">                  igb_msix_ring, <span class="number">0</span>, q_vector-&gt;name, q_vector);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中跟踪函数调用，__igb_open =&gt; igb_request_irq =&gt; igb_request_msix, 在 igb_request_msix 中我们看到了，对于多队列的网卡，为每一个队列都注册了中断，其对应的中断处理函数是 igb_msix_ring（该函数也在 drivers/net/ethernet/intel/igb/igb_main.c 下）。我们也可以看到，msix 方式下，每个 RX 队列有独立的 MSI-X 中断，从网卡硬件中断的层面就可以设置让收到的包被不同的 CPU 处理。（可以通过 irqbalance，或者修改 /proc/irq/IRQ_NUMBER/smp_affinity，能够修改和 CPU 的绑定行为）。</p>
<p>当做好以上准备工作以后，就可以开门迎客（数据包）了！</p>
<h1 id="中断与协议栈处理">中断与协议栈处理</h1>
<h2 id="硬中断处理">硬中断处理</h2>
<p>首先，当数据帧从网线到达网卡时，第一站是网卡的接收队列。网卡在分配给自己的 RingBuffer 中寻找可用的内存位置，找到后 DMA 会把数据拷贝到网卡之前关联的内存里，这个时候 CPU 都是无感的。当 DMA 操作完成以后，网卡会向 CPU 发起一个硬中断，通知 CPU 有数据到达。</p>
<img src="/images/linux-kernel/linux-nic-hardware-irq.png" alt="网卡数据硬中断处理过程" width="100%" height="100%">
<blockquote>
<p>注意：当 RingBuffer 满的时候，新来的数据包将给丢弃。ifconfig 查看网卡的时候，可以里面有个 overruns，表示因为环形队列满被丢弃的包。如果发现有丢包，可能需要通过 ethtool 命令来加大环形队列的长度。</p>
</blockquote>
<p>在《启动网卡》一节，我们说到了网卡的硬中断注册的处理函数是 igb_msix_ring。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: drivers/net/ethernet/intel/igb/igb_main.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">igb_msix_ring</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span>* data)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">igb_q_vector</span>* <span class="title">q_vector</span> =</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write the ITR value calculated from the previous interrupt. */</span></span><br><span class="line">    igb_write_itr(q_vector);</span><br><span class="line"></span><br><span class="line">    napi_schedule(&amp;q_vector-&gt;napi);</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>igb_write_itr 只是记录一下硬件中断频率（据说目的是在减少对 CPU 的中断频率时用到）。顺着 napi_schedule 调用一路跟踪下去，__napi_schedule =&gt; ____napi_schedule</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Called with irq disabled */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> ____napi_schedule(<span class="keyword">struct</span> softnet_data* sd, <span class="keyword">struct</span> napi_struct* napi) &#123;</span><br><span class="line">    list_add_tail(&amp;napi-&gt;poll_list, &amp;sd-&gt;poll_list);</span><br><span class="line">    __raise_softirq_irqoff(NET_RX_SOFTIRQ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们看到，<strong>list_add_tail 修改了 CPU 变量 softnet_data 里的 poll_list，将驱动 napi_struct 传过来的 poll_list 添加了进来 </strong>。其中 softnet_data 中的 poll_list 是一个双向列表，其中的设备都带有输入帧等着被处理。紧接着__raise_softirq_irqoff 触发了一个软中断 NET_RX_SOFTIRQ，<strong> 这个所谓的触发过程只是对一个变量进行了一次或运算而已</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在禁用中断的情况下触发软中断（softirq）</span></span><br><span class="line"><span class="type">void</span> __raise_softirq_irqoff(<span class="type">unsigned</span> <span class="type">int</span> nr) &#123;</span><br><span class="line">    trace_softirq_raise(nr);  <span class="comment">// 记录软中断触发事件</span></span><br><span class="line">    or_softirq_pending(<span class="number">1UL</span> &lt;&lt; nr);  <span class="comment">// 设置相应的软中断挂起标志，表明该软中断需要稍后处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file: include/linux/irq_cpustat.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> or_softirq_pending(x) (local_softirq_pending() |= (x))  <span class="comment">// 添加新的中断类型：与当前 CPU 上的软中断挂起标志按位“或”</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> local_softirq_pending() \ __IRQ_STAT(smp_processor_id(), __softirq_pending)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __IRQ_STAT(cpu, member) (irq_stat[cpu].member)</span></span><br></pre></td></tr></table></figure>
<p>我们说过，Linux 在硬中断里只完成简单必要的工作，剩下的大部分的处理都是转交给软中断的。通过上面代码可以看到，硬中断处理过程真的是非常短。只是记录了一个寄存器，<strong>修改了一下 CPU 的 poll_list，然后发出个软中断</strong>。就这么简单，硬中断工作就算是完成了。</p>
<h2 id="ksoftirqd 线程处理">ksoftirqd 线程处理</h2>
<img src="/images/linux-kernel/linux-ksoftirqd-softirq.png" alt="ksoftirqd 内核线程处理软中断" width="100%" height="100%">
<p>内核线程初始化的时候，我们介绍了 ksoftirqd 线程中的两个函数 ksoftirqd_should_run 和 run_ksoftirqd。其中 ksoftirqd_should_run 代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ksoftirqd_should_run</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> cpu)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> local_softirq_pending();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里看到和硬中断中调用了同一个函数 local_softirq_pending。使用方式不同的是硬中断位置是为了写入标记，这里仅仅只是读取。如果硬中断中设置了 NET_RX_SOFTIRQ，这里自然能读取的到。接下来会真正进入线程函数 run_ksoftirqd 中处理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">run_ksoftirqd</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> cpu)</span> &#123;</span><br><span class="line">    local_irq_disable();  <span class="comment">// 禁用本地中断，防止处理中断时被其他中断打断</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查当前 CPU 上是否有挂起的软中断</span></span><br><span class="line">    <span class="keyword">if</span> (local_softirq_pending()) &#123;</span><br><span class="line">        __do_softirq();  <span class="comment">// 遍历处理挂起的所有软中断，调用相应的处理函数来处理事件</span></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        local_irq_enable();  <span class="comment">// 重新启用本地中断</span></span><br><span class="line">        cond_resched();  <span class="comment">// 判断是否需要主动让出 CPU 给其他任务，防止占用过多时间</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    local_irq_enable();  <span class="comment">// 如果没有软中断挂起，直接启用本地中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在__do_softirq 函数中，遍历当前 CPU 挂起的软中断类型，调用其注册的 action 方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">asmlinkage <span class="type">void</span> __do_softirq(<span class="type">void</span>) &#123;</span><br><span class="line">    pending = local_softirq_pending();  <span class="comment">// 获取当前 CPU 挂起的软中断 bitmap</span></span><br><span class="line">    h = softirq_vec;  <span class="comment">// 指向 struct softirq_action softirq_vec[NR_SOFTIRQS]数组首地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pending &amp; <span class="number">1</span>) &#123;  <span class="comment">// 检查最低位是否有挂起的软中断</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> vec_nr = h - softirq_vec;  <span class="comment">// 计算当前处理的软中断编号（指针运算）</span></span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line">            trace_softirq_entry(vec_nr);  <span class="comment">// 跟踪进入软中断处理（调试使用）</span></span><br><span class="line">            h-&gt;action(h);  <span class="comment">// 执行软中断处理函数（核心）</span></span><br><span class="line">            trace_softirq_exit(vec_nr);  <span class="comment">// 跟踪退出软中断处理（调试使用）</span></span><br><span class="line">        &#125;</span><br><span class="line">        h++;  <span class="comment">// 移动到下一个软中断处理程序</span></span><br><span class="line">        pending &gt;&gt;= <span class="number">1</span>;  <span class="comment">// 将挂起的软中断 bitmap 右移，检查下一个软中断</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (pending);  <span class="comment">// 当有挂起的软中断时，继续处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在《网络子系统初始化》小节， 我们看到我们为 NET_RX_SOFTIRQ 注册了处理函数 net_rx_action。所以 net_rx_action 函数就会被执行到了。</p>
<blockquote>
<p>这里需要注意一个细节，硬中断中设置软中断标记，和 ksoftirq 的判断是否有软中断到达，都是基于 smp_processor_id() 的。这意味着只要硬中断在哪个 CPU 上被响应，那么软中断也是在这个 CPU 上被处理。所以说，如果你发现你的 Linux 软中断 CPU 消耗都集中在一个核上的话，做法是要把调整硬中断的 CPU 亲和性，来将硬中断打散到不同的 CPU 核上去。</p>
</blockquote>
<p>我们再来把精力集中到这个核心函数 net_rx_action 上来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 用于处理网络接收（NET_RX_SOFTIRQ）的软中断处理函数 </span></span><br><span class="line"><span class="comment"> * 通过遍历每个网络设备的 NAPI 对象，调用对应的 poll 函数来处理网卡接收的网络数据包</span></span><br><span class="line"><span class="comment"> * 它有一定的时间和工作量限制（通过 time_limit 和 budget），以防止一次软中断</span></span><br><span class="line"><span class="comment"> * 处理时间过长或处理过多网络数据包，确保系统的响应性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">net_rx_action</span><span class="params">(<span class="keyword">struct</span> softirq_action* h)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span>* <span class="title">sd</span> =</span> &amp;__get_cpu_var(softnet_data); <span class="comment">// 获取当前 CPU 的网络相关软中断数据</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> time_limit = jiffies + <span class="number">2</span>;  <span class="comment">// 设置时间限制，最多处理到两个 jiffies 后</span></span><br><span class="line">    <span class="type">int</span> budget = netdev_budget;  <span class="comment">// 获取当前可处理的网络包数量的“预算”</span></span><br><span class="line"></span><br><span class="line">    local_irq_disable();  <span class="comment">// 禁用本地中断，确保处理过程中不会被打断</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 poll_list 中还有网络设备的 NAPI(napi_struct) 对象时，继续处理</span></span><br><span class="line">    <span class="keyword">while</span> (!list_empty(&amp;sd-&gt;poll_list)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">napi_struct</span>* <span class="title">n</span>;</span></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 poll_list 中的第一个 NAPI 对象</span></span><br><span class="line">        n = list_first_entry(&amp;sd-&gt;poll_list, <span class="keyword">struct</span> napi_struct, poll_list);</span><br><span class="line">        weight = n-&gt;weight; <span class="comment">// 一次最多处理多少个包</span></span><br><span class="line"></span><br><span class="line">        work = <span class="number">0</span>;  <span class="comment">// 记录在本次循环中处理的网络数据包数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查 NAPI 对象是否处于调度状态（是否被安排处理网络数据包）</span></span><br><span class="line">        <span class="keyword">if</span> (test_bit(NAPI_STATE_SCHED, &amp;n-&gt;state)) &#123;</span><br><span class="line">            work = n-&gt;poll(n, weight);  <span class="comment">// 调用 NAPI poll 函数处理网络包（核心）</span></span><br><span class="line">            trace_napi_poll(n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        budget -= work;  <span class="comment">// 减少剩余预算</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>函数开头的 time_limit 和 budget 是用来控制 net_rx_action 函数主动退出的，目的是保证网络包的接收不霸占 CPU 不放。等下次网卡再有硬中断过来的时候再处理剩下的接收数据包。其中 budget 可以通过内核参数调整。这个函数中剩下的核心逻辑是获取到当前 CPU 变量 softnet_data，对其 poll_list 进行遍历, 然后执行到网卡驱动注册到的 poll 函数。对于 igb 网卡来说，就是 igb 驱动的 igb_poll 函数了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">igb_poll</span><span class="params">(<span class="keyword">struct</span> napi_struct* napi, <span class="type">int</span> budget)</span> &#123;</span><br><span class="line">    <span class="comment">// 从 napi 结构体中获取 igb_q_vector 结构体指针，包含了网络数据发送和接收的队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">napi_struct</span>* <span class="title">q_vector</span> =</span> container_of(napi, <span class="keyword">struct</span> igb_q_vector, napi);</span><br><span class="line">    <span class="type">bool</span> clean_complete = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">if</span> (q_vector-&gt;tx.ring)</span><br><span class="line">        clean_complete = igb_clean_tx_irq(q_vector);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q_vector-&gt;rx.ring)</span><br><span class="line">        <span class="comment">// 清理接收队列中的中断、网络数据包（给定 budget 下）</span></span><br><span class="line">        clean_complete &amp;= igb_clean_rx_irq(q_vector, budget);</span><br><span class="line">    <span class="keyword">if</span> (!clean_complete)</span><br><span class="line">        <span class="keyword">return</span> budget</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在读取操作中，igb_poll 的重点工作是对 igb_clean_rx_irq 的调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在网卡接收到网络数据包后，负责从接收队列中提取这些数据包，</span></span><br><span class="line"><span class="comment"> * 处理包头信息，进行校验，并将其交给上层网络栈。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">igb_clean_rx_irq</span><span class="params">(<span class="keyword">struct</span> igb_q_vector* q_vector, <span class="type">const</span> <span class="type">int</span> budget)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">igb_ring</span>* <span class="title">rx_ring</span> =</span> q_vector-&gt;rx.ring;  <span class="comment">// 获取接收队列（接收环形缓冲区）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>* <span class="title">skb</span> =</span> rx_ring-&gt;skb;  <span class="comment">// 获取当前用于存储数据包的缓冲区</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> total_packets = <span class="number">0</span>;  <span class="comment">// 统计本次处理的数据包数量</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">/* retrieve a skb buffer from the ring */</span></span><br><span class="line">        skb = igb_fetch_rx_buffer(rx_ring, rx_desc, skb);</span><br><span class="line">        <span class="keyword">if</span> (!skb)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* fetch next skb buffer in frame if non-eop (end of packet) */</span></span><br><span class="line">        <span class="keyword">if</span> (igb_is_non_eop(rx_ring, rx_desc)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* verify the packet layout is correct */</span></span><br><span class="line">        <span class="keyword">if</span> (igb_cleanup_headers(rx_ring, rx_desc, skb)) &#123;</span><br><span class="line">            skb = <span class="literal">NULL</span>;  <span class="comment">// 如果包头信息有问题，释放 skb，跳过处理</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* populate checksum, timestamp, VLAN, and protocol */</span></span><br><span class="line">        igb_process_skb_fields(rx_ring, rx_desc, skb);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将处理好的 skb 交给上层协议栈进行进一步处理</span></span><br><span class="line">        napi_gro_receive(&amp;q_vector-&gt;napi, skb);</span><br><span class="line">        </span><br><span class="line">        skb = <span class="literal">NULL</span>;</span><br><span class="line">        total_packets++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (likely(total_packets &lt; budget));</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>igb_fetch_rx_buffer 和 igb_is_non_eop 的作用就是把数据帧从 RingBuffer 上取下来。为什么需要两个函数呢？因为有可能一个帧要占多个 RingBuffer，所以是在一个循环中获取的，直到帧尾部。获取下来的一个数据帧用一个 sk_buff 来表示。获取完数据以后，对其进行一些校验，然后开始设置 skb 变量的 timestamp, VLAN id, protocol 等字段。接下来进入到 napi_gro_receive 中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: net/core/dev.c</span></span><br><span class="line"><span class="type">gro_result_t</span> <span class="title function_">napi_gro_receive</span><span class="params">(<span class="keyword">struct</span> napi_struct* napi, <span class="keyword">struct</span> sk_buff* skb)</span> &#123;</span><br><span class="line">    skb_gro_reset_offset(skb);  <span class="comment">// 重置数据包的 GRO 偏移信息，准备进行 GRO 处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 dev_gro_receive 尝试合并数据包，并根据其结果决定是否将数据包传递到网络协议栈进行处理</span></span><br><span class="line">    <span class="keyword">return</span> napi_skb_finish(dev_gro_receive(napi, skb), skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dev_gro_receive 这个函数代表的是网卡 GRO 特性，可以简单理解成能够将多个小的 TCP 包合并为一个大的包进行处理，目的是减少传送给网络栈的包数，这有助于减少 CPU 的使用量。我们暂且忽略，直接看 napi_skb_finish, 这个函数主要就是调用了 netif_receive_skb。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: net/core/dev.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">gro_result_t</span> <span class="title function_">napi_skb_finish</span><span class="params">(<span class="type">gro_result_t</span> ret, <span class="keyword">struct</span> sk_buff* skb)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">        <span class="keyword">case</span> GRO_NORMAL: <span class="comment">// 数据包无法合并或需要进一步处理，则将数据包传递到上层网络协议栈</span></span><br><span class="line">            <span class="keyword">if</span> (netif_receive_skb(skb))</span><br><span class="line">                ret = GRO_DROP;  <span class="comment">// 如果数据包处理失败，标记为 GRO_DROP</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>netif_receive_skb 是 Linux 内核中接收数据包的通用接口，它会将数据包传递到相应的网络协议栈进行处理，例如 TCP/IP 协议栈。</p>
<p>声明，后面的小节也都属于软中断的处理过程，只不过由于篇幅太长，单独拿出来成小节。</p>
<h2 id="网络协议栈处理">网络协议栈处理</h2>
<p>netif_receive_skb 函数会根据包的协议，假如是 udp 包，会将包依次送到 ip_rcv(), udp_rcv()协议处理函数中进行处理。</p>
<img src="/images/linux-kernel/linux-netif-receive-skb.png" alt="网络协议栈处理流程" width="100%" height="100%">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Linux 内核网络栈中接收到数据包后，通过 netif_receive_skb 函数将数据包传递给协议处理层</span></span><br><span class="line"><span class="comment"> * 它展示了接收的数据包在网络设备驱动层和上层网络协议栈之间的传递流程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">netif_receive_skb</span><span class="params">(<span class="keyword">struct</span> sk_buff* skb)</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">return</span> __netif_receive_skb(skb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __netif_receive_skb(<span class="keyword">struct</span> sk_buff* skb) &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    ret = __netif_receive_skb_core(skb, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理接收到的数据包（核心）：为每个接收到的数据包找到合适的处理器，并将其交由合适的协议栈进行处理</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __netif_receive_skb_core(<span class="keyword">struct</span> sk_buff* skb, <span class="type">bool</span> pfmemalloc) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span>* <span class="title">orig_dev</span>;</span></span><br><span class="line"></span><br><span class="line">    orig_dev = skb-&gt;dev;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 遍历 ptype_all 列表中的所有协议类型</span></span><br><span class="line">    list_for_each_entry_rcu(ptype, &amp;ptype_all, <span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ptype-&gt;dev || ptype-&gt;dev == skb-&gt;dev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pt_prev)</span><br><span class="line">                ret = deliver_skb(skb, pt_prev, orig_dev);  <span class="comment">// 传递数据包给前一个协议类型</span></span><br><span class="line">            pt_prev = ptype;  <span class="comment">// 更新 pt_prev 为当前协议类型</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    type = skb-&gt;protocol;</span><br><span class="line">    <span class="comment">// 在 ptype_base 哈希表中查找与数据包协议类型匹配的处理器，处理与 skb 类型匹配的协议</span></span><br><span class="line">    list_for_each_entry_rcu(ptype, &amp;ptype_base[ntohs(type) &amp; PTYPE_HASH_MASK], <span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptype-&gt;type == type &amp;&amp; </span><br><span class="line">                (ptype-&gt;dev == null_or_dev || ptype-&gt;dev == skb-&gt;dev || ptype-&gt;dev == orig_dev)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pt_prev)</span><br><span class="line">                ret = deliver_skb(skb, pt_prev, orig_dev);  <span class="comment">// 传递数据包给前一个协议类型</span></span><br><span class="line">            pt_prev = ptype;  <span class="comment">// 更新 pt_prev 为当前协议类型</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在__netif_receive_skb_core 中，我看着原来经常使用的 tcpdump 的抓包点，很是激动，看来读一遍源代码时间真的没白浪费。接着__netif_receive_skb_core 取出 protocol，它会从数据包中取出协议信息，然后遍历注册在这个协议上的回调函数列表。ptype_base 是一个 hash table，在《协议注册》小节我们提到过。ip_rcv 函数地址就是存在这个 hash table 中的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: net/core/dev.c</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">deliver_skb</span><span class="params">(<span class="keyword">struct</span> sk_buff* skb, </span></span><br><span class="line"><span class="params">                              <span class="keyword">struct</span> packet_type* pt_prev, </span></span><br><span class="line"><span class="params">                              <span class="keyword">struct</span> net_device* orig_dev)</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">return</span> pt_prev-&gt;func(skb, skb-&gt;dev, pt_prev, orig_dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pt_prev-&gt;func 这一行就调用到了协议层注册的处理函数了。对于 ip 包来讲，就会进入到 ip_rcv（如果是 arp 包的话，会进入到 arp_rcv）。</p>
<h2 id="IP 协议层处理">IP 协议层处理</h2>
<p>我们再来大致看一下 Linux 在 ip 协议层都做了什么，包又是怎么样进一步被送到 udp 或 tcp 协议处理函数中的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: net/ipv4/ip_input.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ip_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff* skb, <span class="keyword">struct</span> net_device* dev, <span class="keyword">struct</span> packet_type* pt, <span class="keyword">struct</span> net_device* orig_dev)</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, skb, dev, <span class="literal">NULL</span>, ip_rcv_finish);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NF_HOOK(pf, hook, skb, indev, outdev, okfn) (okfn)(skb)  <span class="comment">/* #ifndef CONFIG_NETFILTER */</span></span></span><br></pre></td></tr></table></figure>
<p>这里 NF_HOOK 是一个钩子函数，当执行完注册的钩子后就会执行到最后一个参数指向的函数 ip_rcv_finish(skb)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ip_rcv_finish</span><span class="params">(<span class="keyword">struct</span> sk_buff* skb)</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">if</span> (!skb_dst(skb)) &#123;</span><br><span class="line">        <span class="type">int</span> err = ip_route_input_noref(skb, iph-&gt;daddr, iph-&gt;saddr, iph-&gt;tos, skb-&gt;dev);</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">return</span> dst_input(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟踪 ip_route_input_noref 后看到它又调用了 ip_route_input_mc。在 ip_route_input_mc 中，函数 ip_local_deliver 被赋值给了 dst.input, 如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: net/ipv4/route.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ip_route_input_mc</span><span class="params">(<span class="keyword">struct</span> sk_buff* skb, __be32 daddr, __be32 saddr, u8 tos, <span class="keyword">struct</span> net_device* dev, <span class="type">int</span> our)</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">if</span> (our) &#123;</span><br><span class="line">        rth-&gt;dst.input = ip_local_deliver;</span><br><span class="line">        rth-&gt;rt_flags |= RTCF_LOCAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以回到 ip_rcv_finish 中的 return dst_input(skb)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Input packet from network to transport.  */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">dst_input</span><span class="params">(<span class="keyword">struct</span> sk_buff* skb)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> skb_dst(skb)-&gt;input(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>skb_dst(skb)-&gt;input 调用的 input 方法就是路由子系统赋的 ip_local_deliver。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: net/ipv4/ip_input.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ip_local_deliver</span><span class="params">(<span class="keyword">struct</span> sk_buff* skb)</span> &#123;</span><br><span class="line">    <span class="comment">/* 检查 IP 分片重组，如果是，调用 ip_defrag 进行分片重组 */</span></span><br><span class="line">    <span class="keyword">if</span> (ip_is_fragment(ip_hdr(skb))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ip_defrag(skb, IP_DEFRAG_LOCAL_DELIVER))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 重组失败或数据包需要等待其他分片到达</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在本地 LOCAL_IN 输入链中处理 IPv4 数据包</span></span><br><span class="line">    <span class="keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_IN, skb, skb-&gt;dev, <span class="literal">NULL</span>, ip_local_deliver_finish);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ip_local_deliver_finish</span><span class="params">(<span class="keyword">struct</span> sk_buff* skb)</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="type">int</span> protocol = ip_hdr(skb)-&gt;protocol;  <span class="comment">// 从 IP 头部获取协议号</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_protocol</span>* <span class="title">ipprot</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 RCU 机制安全地获取 inet_protos 表中的协议处理器</span></span><br><span class="line">    ipprot = rcu_dereference(inet_protos[protocol]);</span><br><span class="line">    <span class="keyword">if</span> (ipprot != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = ipprot-&gt;handler(skb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如《协议栈注册》小节看到 inet_protos 中保存着 tcp_rcv 和 udp_rcv 的函数地址。这里将会根据包中的协议类型选择进行分发，在这里 skb 包将会进一步被派送到更上层的协议中——udp 和 tcp。</p>
<h2 id="UDP 协议层处理">UDP 协议层处理</h2>
<p>在《协议栈注册》小节的时候我们说过，udp 协议的处理函数是 udp_rcv。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: net/ipv4/udp.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">udp_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff* skb)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> __udp4_lib_rcv(skb, &amp;udp_table, IPPROTO_UDP);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __udp4_lib_rcv(<span class="keyword">struct</span> sk_buff* skb, <span class="keyword">struct</span> udp_table* udptable, <span class="type">int</span> proto) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span>* <span class="title">sk</span>;</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 根据数据包的源端口和目标端口在 UDP 协议表中查找相应的 socket</span></span><br><span class="line">    sk = __udp4_lib_lookup_skb(skb, uh-&gt;source, uh-&gt;dest, udptable);</span><br><span class="line">    <span class="keyword">if</span> (sk != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到了，数据包 skb 排队到套接字的接收队列中，等待应用程序进一步处理</span></span><br><span class="line">        <span class="type">int</span> ret = udp_queue_rcv_skb(sk, skb);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 没找到，发送 ICMP 目标不可达消息，告知发送方无法到达目标端口</span></span><br><span class="line">    icmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>__udp4_lib_lookup_skb 是根据 skb 来寻找对应的 socket，当找到以后将数据包放到 socket 的缓存队列里。如果没有找到，则发送一个目标不可达的 icmp 包。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: net/ipv4/udp.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">udp_queue_rcv_skb</span><span class="params">(<span class="keyword">struct</span> sock* sk, <span class="keyword">struct</span> sk_buff* skb)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查套接字的接收队列是否已满</span></span><br><span class="line">    <span class="keyword">if</span> (sk_rcvqueues_full(sk, skb, sk-&gt;sk_rcvbuf))</span><br><span class="line">        <span class="keyword">goto</span> drop;  <span class="comment">// 如果接收队列已满，则丢弃数据包</span></span><br><span class="line"></span><br><span class="line">    ipv4_pktinfo_prepare(skb);  <span class="comment">// 准备 IPv4 数据包信息</span></span><br><span class="line">    bh_lock_sock(sk);</span><br><span class="line">    <span class="comment">// 检查套接字是否未被用户空间持有</span></span><br><span class="line">    <span class="keyword">if</span> (!sock_owned_by_user(sk)) &#123;</span><br><span class="line">        rc = __udp_queue_rcv_skb(sk, skb);  <span class="comment">// 将数据包排队到套接字的接收队列中</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果套接字被用户空间持有，将数据包添加到套接字的后备（backlog）队列中</span></span><br><span class="line">        <span class="keyword">if</span> (sk_add_backlog(sk, skb, sk-&gt;sk_rcvbuf)) &#123;</span><br><span class="line">            bh_unlock_sock(sk);</span><br><span class="line">            <span class="keyword">goto</span> drop;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bh_unlock_sock(sk);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line"></span><br><span class="line">drop:</span><br><span class="line">    kfree_skb(skb);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sock_owned_by_user 判断的是用户是不是正在这个 socket 上进行系统调用（socket 被占用），如果没有，那就可以直接放到 socket 的接收队列中。如果有，那就通过 sk_add_backlog 把数据包添加到 backlog 队列。当用户释放 socket 的时候，内核会检查 backlog 队列，如果有数据再移动到接收队列中。</p>
<p>sk_rcvqueues_full 接收队列如果满了的话，将直接把包丢弃。接收队列大小受内核参数 net.core.rmem_max 和 net.core.rmem_default 影响。</p>
<h1 id="recvfrom 系统调用">recvfrom 系统调用</h1>
<p>花开两朵，各表一枝。上面我们说完了整个 Linux 内核对数据包的接收和处理过程，最后把数据包放到 socket 的接收队列中了。那么我们再回头看用户进程调用 recvfrom 后是发生了什么。我们在代码里调用的 recvfrom 是一个 glibc 的库函数，该函数在执行后会将用户进程陷入到内核态，进入到 Linux 实现的系统调用 sys_recvfrom。在理解 Linux 对 sys_recvfrom 之前，我们先来简单看一下 socket 这个核心数据结构。这个数据结构太大了，我们只把对和我们今天主题相关的内容画出来，如下：</p>
<img src="/images/linux-kernel/linux-struct-socket.png" alt="socket 内核数据结构" width="100%" height="100%">
<p>socket 数据结构中的 struct proto_ops 对应的是协议的方法集合。每个协议都会实现不同的方法集，对于 IPv4 协议族来说，每种协议都有对应的处理方法，如下。对于 udp 来说，是通过 inet_dgram_ops 来定义的，其中注册了 inet_recvmsg 方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: net/ipv4/af_inet.c</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> <span class="title">inet_stream_ops</span> =</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    .recvmsg = inet_recvmsg,</span><br><span class="line">    .mmap = sock_no_mmap,</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> <span class="title">inet_dgram_ops</span> =</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    .sendmsg = inet_sendmsg,</span><br><span class="line">    .recvmsg = inet_recvmsg,</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>socket 数据结构中的另一个数据结构 struct sock *sk 是一个非常大，非常重要的子结构体。其中的 sk_prot 又定义了二级处理函数。对于 UDP 协议来说，会被设置成 UDP 协议实现的方法集 udp_prot。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: net/ipv4/udp.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proto</span> <span class="title">udp_prot</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;UDP&quot;</span>,</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .close = udp_lib_close,</span><br><span class="line">    .connect = ip4_datagram_connect,</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    .sendmsg = udp_sendmsg,</span><br><span class="line">    .recvmsg = udp_recvmsg,</span><br><span class="line">    .sendpage = udp_sendpage,</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看完了 socket 变量之后，我们再来看 sys_recvfrom 的实现过程。</p>
<img src="/images/linux-kernel/linux-recvfrom.png" alt="recvfrom 函数内部实现过程" width="100%" height="100%">
<p>在 inet_recvmsg 调用了 sk-&gt;sk_prot-&gt;recvmsg。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: net/ipv4/af_inet.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_recvmsg</span><span class="params">(<span class="keyword">struct</span> kiocb* iocb, <span class="keyword">struct</span> socket* sock, </span></span><br><span class="line"><span class="params">                 <span class="keyword">struct</span> msghdr* msg, <span class="type">size_t</span> size, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    err = sk-&gt;sk_prot-&gt;recvmsg(iocb, sk, msg, size, </span><br><span class="line">                flags &amp; MSG_DONTWAIT, flags &amp; ~MSG_DONTWAIT, &amp;addr_len);</span><br><span class="line">    <span class="keyword">if</span> (err &gt;= <span class="number">0</span>)</span><br><span class="line">        msg-&gt;msg_namelen = addr_len;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我们说过这个对于 udp 协议的 socket 来说，这个 sk_prot 就是 net/ipv4/udp.c 下的 struct proto udp_prot。由此我们找到了 udp_recvmsg 方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file:net/core/datagram.c:EXPORT_SYMBOL(__skb_recv_datagram);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>* __<span class="title">skb_recv_datagram</span>(<span class="keyword">struct</span> <span class="title">sock</span>* <span class="title">sk</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">flags</span>, <span class="title">int</span>* <span class="title">peeked</span>, <span class="title">int</span>* <span class="title">off</span>, <span class="title">int</span>* <span class="title">err</span>) &#123;</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span>* <span class="title">queue</span> =</span> &amp;sk-&gt;sk_receive_queue;</span><br><span class="line">        skb_queue_walk(<span class="built_in">queue</span>, skb) &#123;</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* User doesn&#x27;t want to wait */</span></span><br><span class="line">        error = -EAGAIN;</span><br><span class="line">        <span class="keyword">if</span> (!timeo)</span><br><span class="line">            <span class="keyword">goto</span> no_packet;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!wait_for_more_packets(sk, err, &amp;timeo, last));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终于我们找到了我们想要看的重点，在上面我们看到了所谓的读取过程，就是访问 sk-&gt;sk_receive_queue。如果没有数据，且用户也允许等待，则将调用 wait_for_more_packets()执行等待操作，它加入会让用户进程进入睡眠状态。</p>
<h1 id="总结">总结</h1>
<p>网络模块是 Linux 内核中最复杂的模块了，看起来一个简简单单的收包过程就涉及到许多内核组件之间的交互，如网卡驱动、协议栈，内核 ksoftirqd 线程等。看起来很复杂，本文想通过图示的方式，尽量以容易理解的方式来将内核收包过程讲清楚。现在让我们再串一串整个收包过程。</p>
<p>当用户执行完 recvfrom 调用后，用户进程就通过系统调用进行到内核态工作了。如果接收队列没有数据，进程就进入睡眠状态被操作系统挂起。这块相对比较简单，剩下大部分的戏份都是由 Linux 内核其它模块来表演了。</p>
<p>首先在开始收包之前，Linux 要做许多的准备工作：</p>
<ol>
<li>创建 ksoftirqd 线程，为它设置好它自己的线程函数，后面指望着它来处理软中断呢。</li>
<li>协议栈注册，Linux 要实现许多协议，比如 arp，icmp，ip，udp，tcp，每一个协议都会将自己的处理函数注册一下，方便包来了迅速找到对应的处理函数。</li>
<li>网卡驱动初始化，每个驱动都有一个初始化函数，内核会让驱动也初始化一下。在这个初始化过程中，把自己的 DMA 准备好，把 NAPI 的 poll 函数地址告诉内核。</li>
<li>启动网卡，分配 RX，TX 队列，注册中断对应的处理函数。</li>
</ol>
<p>以上是内核准备收包之前的重要工作，当上面都 ready 之后，就可以打开硬中断，等待数据包的到来了。</p>
<p>当数据到来了以后，第一个迎接它的是网卡（我去，这不是废话么）：</p>
<ol>
<li>网卡将数据帧 DMA 到内存的 RingBuffer 中，然后向 CPU 发起中断通知。</li>
<li>CPU 响应中断请求，调用网卡启动时注册的中断处理函数。</li>
<li>中断处理函数几乎没干啥，就发起了软中断请求。</li>
<li>内核线程 ksoftirqd 线程发现有软中断请求到来，先关闭硬中断。</li>
<li>ksoftirqd 线程开始调用驱动的 poll 函数收包。</li>
<li>poll 函数将收到的包送到协议栈注册的 ip_rcv 函数中。</li>
<li>ip_rcv 函数再讲包送到 udp_rcv 函数中（对于 tcp 包就送到 tcp_rcv）。</li>
</ol>
<p>现在我们可以回到开篇的问题了，我们在用户层看到的简单一行 recvfrom，Linux 内核要替我们做如此之多的工作，才能让我们顺利收到数据。这还是简简单单的 UDP，如果是 TCP，内核要做的工作更多，不由得感叹内核的开发者们真的是用心良苦。</p>
<p>理解了整个收包过程以后，我们就能明确知道 Linux 收一个包的 CPU 开销了。首先第一块是用户进程调用系统调用陷入内核态的开销。第二块是 CPU 响应包的硬中断的 CPU 开销。第三块是 ksoftirqd 内核线程的软中断上下文花费的。</p>
<p>另外网络收发中有很多末支细节咱们并没有展开了说，比如说 no NAPI， GRO，RPS 等。因为我觉得说的太对了反而会影响大家对整个流程的把握，所以尽量只保留主框架了，少即是多！</p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://segmentfault.com/a/1190000008836467">https://segmentfault.com/a/1190000008836467</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1966873">https://cloud.tencent.com/developer/article/1966873</a></li>
<li><a href="https://cloud.tencent.com/developer/article/2378177">https://cloud.tencent.com/developer/article/2378177</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>数据包接收</tag>
      </tags>
  </entry>
  <entry>
    <title>项目之低成本确定性 CE</title>
    <url>/posts/240826210159.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，这个密码看着不太对，请再试试。" data-whm="抱歉，这个文章不能被校验，不过您还是能看看解密后的内容。">
  <script id="hbeData" type="hbeData" data-hmacdigest="2a767c39b1ab420c5f03dc66cc6185088227896d1aad9be70cf0b2472abcf231">296e0e11e5707115aade5aa86d82978cc8e0b187f577349bdaaf317eeb18ec7142b0fad518b4358232daaaa360da3cba39c8d374373ba424f88c1efb7c24d02ea4080011cb6491cfacff8d20e9af3d55c5edf876a55095c92bc6ed7fceb4d0b2df79aa776f6198aea56d2e83891f91d39d670e68a663a24a1840c8bbfdbdc3ed9209a03a08a09db53edec15b9a15cb835433c0607e95e3d804e1a1f1642b212ff202069bea6ecf46bf00e84f0603c170bf7b3031e5c18e08f26eb4b232e1b65a22e23ff4dac2c56e479aa02a229bf331510c3f2084aaa05b170c1b758c41f40c31cb372197babeb55ae3162af14e50ee86aba7ad25247410722477cc1b7724d48a77e6d8c4567372cf815cb7c082a56336f6ea0760b70dcb57fcfd1de70aff6d5f86eb3aa38661d3f8920ec485647d67eb998d70f04c9e3f70c7d3534b55da7d1594c55cd7488b18b4cda3fdf1ee1a4a7a0bd4a2056ba62bfab85ea019ef8d41bc8cc85216a8995b9ea10646e20432fdeb25aebf713ce4dd182e5423a13eca0a22f6b76ab4ec71ec361a4569af5ff806ebfa5b0f67fb6d4215a8309672b84595a1bd45c9ae8ba211ff440470ea3621a801551bfe9a4703a318b53605c6b277f7a86f4cef913d21fc468b6cc65d6f35b5d3ddafe81ea6e9302faf597877613a620c7c3b72f9a7e3055bf9cffa17593c401f00451039eb9648446bbeb046dec1b2d5cd312d1ede6e77714e3d4f20ef2780898379c7b1e5a1571c55c93ddd47022f7f5644ef4578bda2332c6f596b05efd012b44341c780a049f20ddb8fc1af7d42dd3623547a8c754fe0900680e957c7581fd805bce9b04bcf96ffdf0d9893270a3aec88c647748c7bd298f0035ccba88226d1e7d32bf878d30c097e1c526291875268fd605f2a3182b971e6144c4c6ff9109310a983eea1bca68169d9313ea1010e3c84dfcce51eb71d16cfa8a6a0bbeca1eebae1b007155af3b07761c485bf27bac19a17235d20ba7474ffc3de758a9e07c1b38c39be6de170ba54de5e4c6617dd18bd01fbff7071aca851bbf71f1dddee9cb596fe75ab0c5b853c5bb348319756cb830c0fafeb4c792caadecec6c8f8c840b3e0b564f26b1b9d706b51abc7e2b2db41e9e5e656a1b48e08388534b07d3ed3a768a00f24441278e03ef21f0759d29cb33161625d485fc3c74f03dccf7b28a5df6a43d4f7896266843550e62225c8bd5ad37dd04afd986fc58e93e261310c74f38bbb95692754a2df08e3e57a4127c9c7b2ddb553745c40889542a1f341a2c9a239a9267dfcfed5dff0d8134075acec400b014361aa5272e5538a00fa0f3dfdaea4c62406b257005775ae227fa43118ff6110eeece4749cbd95a3886ec06850f81d9f0fe8ca462810b04582b7515692124b349143f13e7f25d165af07592c68d7b757372f7273c9959ee2645dbe430c0f1cd1897e7aa99ae01a2fa9154ca0bfc9bd5e180df7dacf6cd1db04bb785ecd7e4436ead1d1524f1caabcd4cd1972c14866c2dbd1337683a9c7df63a366ec4269993aac38d912ec2dc0155090bbcebed13137dbdef873f5e4d80839b9e89345cee5aec09e4cd4d54ef447010c0301288da8d782e09d8832ffa34f549d4997542f31e4426c1d174ef72c1ce76ab712fa1a348cd554374f5fd0b0e1c8b2034aa1902ee135685f301a2fd86370715d84f45ddb7457fb59dc05056591c897622dcf6c91a8abd6da9372a3eb186e5620d30e75b1fa2f0e2b12ac9a95bd68285e4aaaa3feacc55b1558ef5733063f69794ba26d35d96c6a4042c197c682cce673f8cdccb69636ff408320c1f3b5145e8c5a2b7056e7b8a2490b049a5ea26ba80cabc17d2a422384cb10a264079c2b4e06d2b4977d99c7326dd97c0dc240234d0b5e9fb5fa094d5949108515eef1ccfa1e025f5145d14c8e413e5b4afb6351bc1c11e83e84d796573400f7f12fdc133e83434383d0685a53f56c50b2e51982b1a51dbe6c9222fa06b341f5494ee7def8b0eea348a8c9b6c26e4c795fe04fe6a0054fc6c1b51195c9866a34eb6e6d413e9b30c7900c49c55e0ce16d599639851120323e20f92e3780baec1dd576c61446663224f5710b4e9f40b05c48c1376d24ce07c50ffea79b172035b5e30c355ae9622a3468099c9017dc794893fb23fe0bc782dab87fa7046f7efee9e255906554c174bd1a81cb55b25abfa0b2be5556cdc52196c7dad2504ce0aa755bb7ef3ea01e9861aec8dc0df96d57502b42736adda379ddb313741cc442a4ffab374d38a6885b05501ac7f5626b0d6ba60a21afc7a2d1261542a1054fa026baf9b592613082bc6a9abb21aaaa3b036ac2a6298fbec0927c8755b5d2c8734301048012ab3ca6479f72b37bc380ede2ccecba23ad74264195fca102ee77acf389391a8409891c0bbc52d33b65d14996ba3aeb8769a037cfc9472aa3fd9caa02e9338d039f7040e0ffcdb6557a3768aa3b083161644dbd3b5bd6b1d4fbbe75948149571f0c5499aab7c5105b8604c1af96fc1880dd22b889221cf0d70ec06b90df90e67b999b94011d0b07fbeb7213d791c39443e3956312b85840b5016a42698eb937fd1d9bfc530b08e5caedd2d8b13eef366e181dce83ad993e25aeb7a34ca4729361413a4f408da54d6bd28d40262345b27e5ecd8866b4774bb1c4e23a36bbdda796e34f25456fe710cbae28656d777fec67c21d7f442084d0cfa3d497e8ce0524bc6c9d2381d916e63d11c7241d0ada7944cfed2acb27cb380f9ddef1cb9c34fff7eb1aea6a8c803a6b25fb1ec2a41467bc616a2316090096d729e42c30b5efe403286052d59e999e9b2532129ec1001a21c27c0d1218f82db004e79599a304b27bc37b0ae13a02c5fce236f7909422d3bbfe38758a6a5b04cd0f41065b361adcc154e89483ec1218fe2fbbe91d0f207a18b0d7bb592f9817208d273d8d08d4b1f15b2379cb10c255cbd1469d3729c7e71431550244c6c7b589474705f3cc5adad88d8544bc629d5041de5b3dc89efea8b7618f23b5fd45314def2a419e86bdb5d2c237a858139d58b3c5c1047b83125ed752c3cba588cc4760731b1fd141c127593690b3825bce03ead65a08c1387c8e051cbaccf0e1e2c084ddb03e7cc1b9815a98a9eaf8cc2d9e86da7729e8e295569ae8b98c279cf41837368d7d8948db45185ea7fd2efaf7d874465b80a7d3e8605279ffadf8de7f903e894efe44b70f3627851407b3889e02dcee09b43a9f37bba5ca43cc6274954858c971b9e674786b210fa5a1162ab1e0f984f921f5720c5566f2b8228d9f72dffe80b84fe66c7836da7e9ff03f6a03acdc4c5f1d6aa4e731c0143dfffab4bae52b0379b6417c0c45553c0888c2fa57eec466d367e3275bb96c4cf6a71642340c563488feb3a8fa5f79907bd89c4bb949cb7a9b264b651630361f14af93090068e253459975f802d0dd7fc99fa06397039104f0e0f8a6e121f986e0f20caf6c4ca802efe21854024dda26d20db3f4ba431a717dcb861c69ed782d15814f82acdf612cc10a95080844e1b605cbf6c5e1c30647fe49640203a7cdd71e12dd3befbe3ceb5926b1d282b416d8cac00d49b1a406d907c7362c97a0ebc37063283cd66ac58b77fbe37e2bef9d805b6c0d31cb136564784ad205f2947f9963eff8fd7ad491102ee5638b50b8de2ff9f1acfbe0e2ba0720824e0bf5b8f4391f824e6160a0aca8584de65408e193b49df0108d8b5529b03e23e493fc51576ca99bd12d9b73dc4182a514d9df3381b6e31d7c77fff61b4f2e33efc70f9dbb8e89b1f65bfb03d9e2305f023e9cdf45e44a3635e366a05490cc4320dbe8c74b7bdff756b23f1f783f512a07cc5b0fe68021cd4de9671b3a7809d76ef56aaba7dddb72be2f298ca1218e1d617044b22a2df791e0ab233c1e2ae6c61b7b7d50a96bc2851f76cdf61547e589a4ce2497485ee7a7ad1db71752319d108de34e7f4ee2c25ddbfdca1eb67ea8348fc3fc7ed87a6ed5e4bcd57b21c31759551588380d659b90a96bfe0f75a7eafcfb3f63d2787de7527a18e38df13233417f2f7ba2729f9c9e8f070f38782a3baf0a94195c0a3aa6f054e65a31682732b409e8e623b5ae1c5a83613b9ff4b784b7faad819d969abe95102ece1fb0a939b8749e66604784a9ef9183475d655aaaf74edf9bbd213a5c44ac332e21bf4682cdb789ac4881f43832955be5b3ac9c1c6ac542333a07b617078da6888f8e95c554553264a85005a01bd63e7687e5c8d72666bd31b1fb7c5e987be70a9c1ae97599de1ec04cf6936b5eb52fd1d4594728b31dfca074cfa21b1691711d98b5deee746bac9379e7966885667445a518dfdb584911cae069a7f082f250601d1e2f54825700f2eb83a3c7dfff7cc73be3a9bb7152a8bd15a205a007a09e628deb1d4b39aae36ceb157fc5f00229abc9c589faed6bd61d3902cabf41fc2a27dfd5f4146d97d1868c41310a7699e3a5db7dc1579879ef07c1a56b34461dbd07f7ae2cfa44a6f4d354864c571e242928c5c752be92a3c6a05a6e4fe14e57189c5b37be9f59906efbe2525760b59779aad21a3ad5cf11732aadfed880d6296b0014692747dcb20ef6318d67ee29bfe479279b00f54cf2273f9cb2ad08f9bc0dce162b2bbceb726e1bcb72e6d1dc2209b4ea7f2eb0696c55945f96aaaa2e6d2c0245975eee323b743cf708a4fdd1baba858576193370b361e28979e63aeca9db2b48d44128f51b73dea60eac34a40d9b5e38c512181753f93040bffdd792d7263e256f382ce81b58bdbaad26b72cda7f0ba59cee0840ca243ea021f3e1c73177657fa91fdc52a0034210c5f81936ef90dbdb42c2080621d5de86f711025c3131dba1ede72a3e38b79737622220999668b3934ab3fc7152375764cf7526b4b392465cf0b31f3798443abceef598e3557bd266ac559542c840d273d2509bf2c125c735ec297d1213bbd5ae7f9419fa8cb48553e41ef3be1498a8f073b8d7dc78508d7c67f9a672cab803e3bda447bef76be455dfa4f99ccd30e3bbea2b1c68e13d59af9e1f0df2a6f71e76ebf2ea4e41bf91bcbd9516e75f3b52b3937db6b380261cd22f3e685c63149b323659ff616d9848b014c8d842a360a6bbc1ec24dff5fc6f544044f3ee6ea00c0dad4966304a0efc386ee0821ba2f1039a9fb4d94d177fb5ffa3c9f0c55036e404ae80d0776663e1b3318c10c67e7e0facdae87154f23504297fe14e0de8c959814a90b3be21e3951bb6b0f39b21dda1b59107c942695f2c9ea49da50fdfdae8ce2e319b9fb819ec5ac39ed84aacbc4dab5aef970746710cae79001c2ecf4285d9d9e0b2d0dadda78254768f0d8cc7189b9a697ad608115dbd68f2be7f1fb2dc662f5d1a1710199b98004d12cfe81e2fa19086463154caace23196953b7511d782de1f8f0db8ba8117f8b74b9f3b40664a74995e8dd66c9714ccbfe23fd80c764aaf7e697c9b781828c8318266212c5ff6af474aa6778097814336f4936b2d1ea6c4971cb4ed89d7a8772d11aa4348511f8457bebb7fe893197fe48b3cdcf2227bef9308278745e7cb42977aff0ded9f4b1811586997020352ef3921c113e157f864f3755ed767487518211b5d66b5d13bbddb4ae00dcf6a7ec7ea2d44d4b60619021adb0cb91f2e7858435ee280e50d96898b053d1f24001c993344a1156ae8b50238b06a6a8966ab3c894e00cdcd9e86d725913e687a980218163706224a4e569bf1cb5eb49377501fb448831b0cc4b2c23e51ed089f85b3cde4f1c6fc83987ef50797a2df95c7be3d2c4f27b0fdf6a530b2096846519787bc39c76df150341b52554e1b46b8e8119ca12125094f588cf968cefd16110464bb80edf9a19efdcfd71e47ceb799e41226766cbf992627958f0940edc2e667447a62ab3d80fd115dae6cb1e16d74c00d67cde5bd410004c4250bff5dcbd5f2607fdd17088045385d126ff4d7c9b0d278924a2c15965e658eb8288e25c91bfcd18c8c74d6a10530d6b89455f787ef76c1ea098bbb5b046d95428073004102fcff39d0b37ebe1f764bc2a2b43c9fb3d61adeabef560f9831121d6a3d71130459300e3ce0c41914742c8edc00e3ffe9a3d8ecb57b0973bd122c3dcb3976bfdc8d2b6bf2f3180a83c3d15dd6dca6a9dee309367306b73562ff40f54219670bbe48085a117c77e90bf11c1197f5ed282beda66c0e254190bb542692c90dbca0ec7b1604ddc2915723358ef629d6179d12397d829970f7de8242d16000e29edb944ea1ddc5c85c3819717c5c0bd68b9b0cdf1e2a40d8d0d593e8d2dcae0960f11216ef652de4955c8adf16986755e263b30f69f5025a53b14fed94957a2a334145c06ce3e817f8d43490650d5d1f8fe27673a31f149b6b46bf987bd1367bd31e6c089a99a40738c2ff1ff801c4cf4b56c599016c210308587b4b911d03e24901c3760de269d5eb6d60ac249856d36b67a768e289d4421148be0d862f4642494a3be4bdd8ef7b3956d94ee12f44afecdb8fe8b6a1055599ef8c90566621feaa90a643fef9e4d18e261ce29b141130c9790de3c8ddd7b5e1836fddd8e77a879c9374f71c5341252776d0eea0cc311b8f9a28d29b0c35bc8a139b5225426853c30c65c6a51739f319b9532d91081aff26d57256c3f7b01c75758db42280acd39fa4ac2a0627964c0ca6d23d2362fd954b09aeacb816cbd2bf7feb8773c243481186af695f4132e3660a9157bdc4eddc7b40680d3ec4935b5023b9a8e9a9fb9a4f6260d6717aa9db9928d5d7b7ec4f821844e08af8177c5fef23efb24af1bcc1ecc8ca82eb7d9c3e5cdea12044dbd798dfe032a6947baee7987e3e523533091c2663c15aeed0ea8e2fd2db33d774afd8f5ab0737bc6b177814faab1e9bd3df28a1fd48a9f145f37046d18ee20178c9dfaeca32bbed5bad03d756f87aae9fe67882c9737dcc161c2d01926fed72405b028da9d7536f48708454a31efc567992d2028a8e88c04aaa3840e112012f150730516353315c4bcd1f717e0c129c5f5a5b8ba0d6a6699925059ff1fb85ca949a671bb304390fcd069e9918c249e220f6e777aa29c9a7fa1c7f3bab66b41facbdbf1cc5a7afbe3a36ab7579199ce97abc80ff890fe221e845789cad0a310f6c538a867d3bd92eb39992d437709eefab9cdeca1ce377c5d8210d6bfd1ec99c2891f7700610d975b78e1a5f3a5cc7b23c0244f102fb01665eaf4d2d49110666467be52abc5e3f19f65ccff55db672d3d783f205560b91f313b3eeb762a886582aabafcdcecbb180b7e36144dccb4ac931e216dbe61046033543c1bc1b95ae334ae68ca11af27fb8173ed607bf14fc11d118500d10cd0db84b363e8415f3262b61212a6599194d3729c07466da5f01b24e3af3e6f7ce314063898ad3b37a1310cdc15d215d44b8b2bac475c7b43df6118fdc23457fc0bb4b7ce53debdbdf29b7eec19823e1fff2cd01a92fbcd4981586f6b81056af1558920640ec2bc842f7eb964f4785c3c7e8a99235fc88e892e8b8843474eeaa9335db2c6737c9d227852d95c718fe758f24b9331c4b068725d6f5212aa45451c713d51297bd393d74a2556513f78e2f2fd68cc354c82e9f7c20aadf1bb1666b6d2c0b35f5fd0139bbddd9b10dd048cb12c7bcfa451422a223782f70fa9adaa36969038bb41387f4faeb579e5783ca01a7114919573cab4069639c072cf06381e363456064ed2664cdba4f4e90e14de3a63905cf0557f88d36bf6b026928aabe8e7c411f253475def6403138685bafced488fb03068702e1ee315ea2e9a89ccc4f6155893ce2a8ea56e021ba36cae99c1473091dcadde2cd5a07abc2f9b95ef08b284812ed97863dd26259b6902d0e13b93276b7400b2d530c4801bf9f8c6627c1c9805b593400cf270db42f483547c70003b903c1cc988c5d35481b3d72c548c4b30f01428b9ad2bcd927868dcb9649c8e2e50e5865294f19eb228f0af7d0f2e0dcc1f21988a5771181ebf8db208f1ed059f6b11210410acafcfe74c12dc25637edf47a9e3b2cb6b09809cc34325179235cc4d3fa61f2372cea1724d337b71a765dfda87ea207554966e65e75c60e50888165676525fa73b16f20b2828d76b0e0a3d668172c58bcc095dc452c967fff0eb7d1f3500c5d87927975b9d53f5251f8da049cbaa6f4e20019abb54b784d127d2ad221ba4e755cbd1d6bac38fc362bdffc4c376ef50483fe1ca8331afa82c90fe1bc2a2f204ec52316dba4c6934279e00fa5c619780b6500a8c6a77bca2dc970513b8bdb239ecba1a587ee539b1944a1b5d49122e0e4870ef311b103deb0f68f9c171dbc95bb22a9016cf9d5ba149bf2801684a7b8701a1cef8310eb0c36a18e910549d3cef18611f039856ffa5e6b5ee25cc9ea2f365c4dcbf8343cd2f6792434f0e12b4501569276a8caf1531aad4c3bb79ccda401cf301295329305cae04e95c7832a74931ed9b11c282f25b24bd0a553e114b2c5db008f4e52673aa810e283a412578c4ec113e559e0063e9f4b1c6a4e48a8fa3c3c85b00d287d71a996f9f161c4aee1a4a155c36879ee7efd2ef6e73d66d9fc01d939b9c52e07860aadf3b39bade6a36a13237b298ab856194aedfb43a7aa22e2b4075e319468fb562187996daed71d6f5d246d390c19691e1138fd0ba71b729fd9741cf0d4a627197362e7252dc4b24e57bf46483cb46fe8315d725e63f34926c1a66ee7e2da7a72d37b2136bbafc698c06557aa3690f8addd8595b6bd9702932aff0a37cafecc135309b78a9ce5be396900f27ea5575408a2cb830272247c9f3e5ce8ef51f24bde8484fab7da3fbbb73b6cdc47190dc4bfa47edca03dba3257eb0a237d47afee48662c7b49bd4b20af9192a4b774f21b00e0eb93fc0bf709ee5f1801937645ec9dcfca7850d1f1c6233b751b97cf20466656d201ea62b2ad1083c5142bd0293305215280268ca4a252f081e34c946bf23828be083ff988c4da1e8bf6c4e7411d83c7ebd174f4d295fb44d4b8705ceb6c62dbd1f4abfe66ee01ffda81b76c3383ae33da2f69168ff572c8bcb47f414ecad06c301e7edea4678eb647abc0a5f2c2567670affb83ef2661c64d6b54c6c0e180096e86caffb94fd7e253113d1f5b58779ccb4a527ad99cf76e52bcf82f5ac6a6b71e5eb8a1a512a4eda819f632741a037803936137399df3c4862023c16a4d5b04451c45662d8c3bdacfdde79345c7de293beb8ce1d621d1b8853550e6c101a2dc9e1261add3f529e5827b8078c452e99e3036527ed3477c48adc9efad3b322c061a3d89e631171a190f4094c2d3cb268ff7ef15d0683c91b20c6c36c3496b0e554a3a084396c3e8b1219b0e43d2f5193e8f97cb531d3107b95f39c4f6b01af7ab6ab4211a357ce4c953aa9f121f241484eac1ef35d6b965ea9e9356f272a5c2652bd4bd05864007ac423a935a1bd7374ff7b28c64a8322fa1f53e60a29cb7ded8e49bdbb9ad5a31587620a3dfee75726d7f6415a1c14c6e862db14a8ef2c108abd3b0b64a4db7b061a884461f3f640b2bb6815d003f74f9d9921e3de28af75d558d458bf6edc055f7ad02c9218cdfd3d7c6b565f5912c3f00fdfb8763336971aa389ba9241da8d1937774ec8909dbc307155ba7fd1bc76a4f46e53c4fe090ec49fe96bb0a7b21f7d45fdbc7a48111d98f689c214ba39de44677e945b06faf5787abfa79d0ac8df3f4972ade4c54b2024128ec0f7b807a3e3c650b0961751b6849546eafe03c05f287dcbecc37e44636c3a562769d6e6664f05d401137614df527c59a8d11307c113ac8545f33d25eafb88ecc0e1df12cc8db89d2fe2a39a841093318232e1e59fe9155838aaf65ee4bf97eb59962116d8b650b08d1e8605ab133c9c4c7eea47222d9672f02b60ba918f8a12d0959fb5fda5ceb4acd21f408da88b0cd19e9ca0435d8bd619d4288ef416daf496c73cb179bbbb4a4ac55a57f86180dd582e0d4c4ec25c67caec869953e5c07aa4b0aa6fed13a3e204d87bc4b3dac6b04f95b4e0d10985dcc2caaa6843d766d099f3b91af25bcd2f89efceb46f8b649610fd301327331cbabda23fbdd5026fef99e7e12577cb28048087d085dca46616e7a9c8dafb935a5743c6b78e1d33755eb260349f281ce327652011239bbf1cc9d6de2074df3f76d423bf4d7fa016073d24699e579a1c633193eacb27f76d48bee10e99a44f0855be61525c87391b5d793337925cbe2629a37fb16ffa348027ee57c6dd4a3a241c335135e604dfe1d1f57d7f35c3bad638ceca2725adb72058aafad9dbcd4a6bc5639b2976bf6c7b82c1eaa59a84289bdadebaa0e0f06c8acdab3ed308c439bc2df59302d1541d148d4c4d2d648deabab9054d0b85dbbcd6cf97602bd4a8b6657fd8a02e8f6b4f105a567316577cb699dd81db9e5aeab17c697e4bc3ef0544e7565081a183ae09279543cb706ea5efb4e56ce1d9de666bc4bacf476cfe9c1436c0227b6ba049580246993465634dd2905174f33dbc0ebcd44ffd647f173f10d60591c11ae44982305fd8cd4a6ab790ecffebc31278c59edaa7a96d4c6cf3e03be9b86a73ef789a708df9d68c467284b8603eb85defe64dae74377bbe9b9373a28e7eb2e183154ff560c151a3213e6b09af54d2fd9394c480ebd4f5d3c40480947bb203165bdffdadd7361c31df3ec17f7cb9c9e132d079817377dac137d5d4ee06e4b6c752d175aac869e49fe0274efe202bb7e5633546fa7ff5256705c0ac0e11246f60da2fc26386b378940ef21f70d76c1e3a6f7d80da40dd3821ab678c03ef2e277e775b7d076ec4db113c20349aa9ff2a5c4b80244006b7bf4b2fc51d200852b0db80b5b287212127a5f43ac3399658acffeb6c98f3261017636ede09176b6c4a5a95e1303ba31574e61308bc7a27144ea3b85d04017fda082917e0544fd38fcd8d4cefb053070fa286e823c7fffadc312d48ffc00a9fbaff29e2df1a8a138b00a6ea354efcd8d65510259a97900eea89d767ac1bf20115f6e30e307af21416f0830e935cb797376778b1961a6dcfe5edb00dad8818698fb57f0395fae8fba096e6c52e059f8108a9ab9a863a59657447d12b0e7fdaf7a94c9717cc7895187912b7946fd554977219eed0dc2104c5a07f685dd39b447589d007251f126b5eafb7374cc110e20aece624c57cc150ad34b1b5c213040f464bcdac75b0f620f91b5e6737d1cb01bb16d3835fe40b22fe1e948394d60a6eadb9feb24f3aeddd6e70a0de3d75b7f217f2d4d3e6d27f5d6a72071fdfe6053b6f36621fb8f1e8d91f797a30e50749060dce0e905d8ed18ae0ffd57c5d5f409133844e5c60c6f637fc6495d8223aba3a7f6b329d3b4d78417b59ff52cd0399e4fcb63e23ef0e98fa1e5c09ec4378981fd18608776c48ccaff1ff96362e65709d521b034c84b008fd7f88ba9ad8be202f228ea25e7dad21b7425d6d8a69d40f6d0d4810ad5d231936b352aa0deb5f947d9179b4c04df7249ab952ace1bec16b457b09cd493b7e34e8b5e10d39ec8358d5d73b715065f120c199524d18320bc8b2b6dcfc2702e4b3671268a9256a97190ded00933765bd262116de0c63021fd9b09fe7cddba7afba2082a82cbfdd94a6731c7886c181d9e6f55058ce8d9d290a528eadbab863438c760698795eed9969c24f0f86e61256111330313fe2d3a31c9dfc31b87e2356eb0499c01d889939d62b94e8a5d2c304ae1a97087e8e1f76ede7da52e822bf4da45e536560b745a876eed4fc8b62d9ffe3116e4cf5f7b755d6eb5fb0e102accd159c5fc1243372829012b27aa8279f0ba809a9d321897390ba43ff3f98403a389d91316baea6dbb7c4ffa38f8864f76b69d354345113a7a5e0ece7ed4bba94ddc52d91203099f865c5770803fc92745a0d1ead89cf630d651d9d9ccbd3d681e68bfab696cf16bd40489045d592f34e96a38ffd60dc0ddcc4275f772ea32cd0e44797f8998953d0a2a11a98f602c241b5d7aa86fafe26dd3b4fae421a96629529237289cd121f5cfa29c4bc8fec0c158697af663ba779d8263034150bd6f2a5b9ec2f2c4443e83ee7b2208f9d52aec0f32b489828daea93ef744b60ab8fb21c848c6b3acd0abf619576b2d97922643e41a7656f238f10e6acb9c24425eaa400cfec809f27bbd13bd5fdfdc48a3d2bb4f114174997fd0ce4319ba427e9c4a0504ad2c0bdc9353653e131905b1915fb913cb54aa3e30713aec017795da2be1133aa3a1df561828da7497d0903a3342d3722ed0d2a26c6c0cc6efcd09172807f9dc47b6424edc10595dfcf4fc78b7492169816ff504151c09a83997cab0573b2f1e34ae65d0fd4fac11111a06535778477ea306a493eb0e92c937d68740e2743879f444c7d8952ec6c276cbdf68c81afe37c4b3321b49bd7b3c06bfaff5a88d07d69d1df1b327ee58fef67635c4830a4dc31a9def97bb1317d278207255df37641a6b30cb20a20ddc3f37fb653668bd179ad4b947dbe17165b521f5ab488f65daf6496a0f22f8950e0faa5e42568c79219257938aea64762096e67fe2f19989e8cfb4e513e160ddc3df9ab10b9848a83336ab64f19c2b32380eec7bb97c6077f4e4af96ff5bf54daf80df1b01de6da7a33d947cf2f6fb61d49c9a722a1918ab41f790430f8dd2c9d320a76327b8b8f7c5cdfad2dd4b5eeb47186e4ddd8f0c4e501ad251bdce5db7067deb047f067ef2d4a3b26c655f23d56f9f1433e5687d2f1bd1bee963f0143b80eee68ea4665509768080018908d5319e75123c34bf85b5331ca10fe3ffa9d2cb498a7fa48ec78499fae5d56e881140cc89a1907fbc0ce111de801f7d28c852d80b952a29b8405e7e67a6330233cebf16f3778e7a171668d684248d01f7d401783f90287417a423f480dd124a997d06d1a1df409ab3f2c7d0973a84ef37350092e98744dd123641f35b7aa734ff8aee7bfccfd616f781750e0eb37e6f9328709060ba4df81d79c11764c91011f3eaa59b85a1eddeca5e315cf124b9790a94a0eecfeb05a7d42b82bb55713240fd1a646e8315dc70ecf15da42c1d1ff2f9aa0cef7b25bc099ac22890dbdbd2c1ebef930adea393858870365fb528ec4b0939a3e50d7ee3f0bb6588f4a6ffea72728edc4d0b168b3727dfed3ca48a8aa724fa70f53cd6a99d30f0c7d4a3fb997b7d56555ec54d61150ec1ba3fb6fb58ab9e7c9e5105d5bd709b5d83a59b0ab6d59079e9ca28bd7d624bdbe02198231706f60b6d1f4f5e506e89297bb464c89f96d29980e13b9e32ee94b3d198bbdd3b5a3d4a0d6c2e0951e5bef6b15f01c4c7ed93f930cfbb9ad49fc51790929687f3004c877195e51146e964d848e11c87d039e30fd085c2021ce49a81407c7c9fa5664458ad9c80869979f75863fa3c33b414b9462bdcb67d73697b00cdac4bf601ba65904e33b1ccf3c276b405e26ae73ded95ab37f5b05e4dd0b3f5eae8787eae7eefd2955a1e786979d0fe5608a5cf77d3153d7c2fdd896a9c2ea4c9b018fb4331dfdc2ab0dd3bc6c89d71cce175e9aa474c6b1381f6525ef515b3b952bd4f712cb03a78fd1e5a3929bdff6966ccb650763ffe13ad99c5c73b732d464e52d76c0ef2d591b2c1f5f0e2c3ffeadcb8be4c895d735ce129d805da285a089bee94eea1679dfc7c37990e8e1ee604d851a88635020ce5431a71e25ce105dbe6305026a219564b3b3d42964ae7ff9afbd47f1f6988eba8c506857cb40436d0a2a3c32a49555515c3ddeac4b7c4719949cf29f8d3f229b89d989c80cf86c1a52b5842a798fcd26d9402e7da46a52c777819aa8c89dfaa5a3c5315d5c0f859d732e95092812c680cb5207540a5678c26ef28ecbc62680a8a47a6b2966faf9b5b90aaf56a62d5d7050155c55cb1c9269cf66b28983726ff4c032950685e3285f98f6661e7437d880b152aff3499557dbbbffdd913617ef456006e8fc046c3b6b9074d1ccc4665019c489d499bf987c79effcf07774ba86154d073143c7ddca7a9e9b7740a68df1566890b329072ddb01d66663c430995c928acc6646150c44bd4acf0872c104242b5c290f05d79200f6814f2c0c2bd49531fbe2b27d39dedfbf5a772d79c8aaa1ee9d104f0407d12010a9ae11839f9dec280d5f037d6763f38dd1cd2477fabd8cb2f9ecc110d862fcf8ac7d581efb22dd588141ccc7da22b6bdd942304064627b3664f8d0cbfbcc8cacac9a79b407eaf7df589c1ad9aee2b552e4d49d9d0df7d8aafee5e6d78720acdbff41dccfe380c6f218c56175d13611fd5fd69af0c3164b1df11e323ee12074a743a95da3f97bef2f1b620f26cc0dde9ac1abc6a04ab3f316f6b094087033a88791291bcf4875660e451faf52bbe13a9ff67643e70acfd20e60f6ca6ce89de92d07a62036fcabeced9ee24efe3f2bda34bfb0a33631f64748f6863911538c50ca49fdc5bd7b4738d65da6f6a9531d70e5ee7c68815330c198a646a4c6e6e6e4d97d6e037361d17ada449bb831d15a6fa2db13d36b19100ce519812c7763a9e4960ca2c67840e25fd7e3b96effa92eaef3400022ae7c1b7f4d7bb2dd6ff1ade59029c121484d5bde59fe3d25369cd318cc2e32c8a90657430e4ffaf0f33969090841c5c42685dd1cd1ebdba64b963a543c4473426321b20d1fc5685ab3b78ebb13f27c68f336bbb6c6f74ff2919056515261b7cd1213ea4d083d0ec09b6b4ebb61311c434de13c65381bb6cd13b3a1713f97f212a4e19778748fcead0e09d52999dab6c9ce0a3ee08224c38b7c04aafcd6e029e945acf4fe6376ce5a6e42859052eb29932344f196ce8db6223ecdf334f5e647c00e0ca6549a3a54ee938991c739b075bf3a200cd4d1ede80b3ff74db69c445777863be3b0eac52968db4b8d204fde6c24b704836e14ab0a8d7339b55db1d216feb815ec0c0b67a5bbd28811f42ef98a46c849c05f53022add587ac2ff68cdc429c0cba523f4181625984faf0a0979607e55d226823a2fa2d4d44e8f665c48f4139c92a080b53b747e57a39ff3c8322cfde1de7751ee08769d8e456c35087da010b4c4d850e6885e9ae6ab9146a4dbecc6dc4ad4d096a7f3c6539b85d630461860521bb7dc384a92dc9ba8d8e59c5ffd02c08668462f100865505b5c3932a61c54ab0baba833dd5029d6bad9246621a132888bd1c8a08aea7d2ab872b25d8f020f9fb99706ed3e4d1534bdd8822e9ee08d74f9bdefd894f875100ba2182d173b82ffe2b74266da58d784b199b76b159361b89c4af6bf1a6e1093f571cf8477bfaa19262e9e6d41b6e72f94052082782b8595ac6422b9555e6df6ca4059a1c762b1b3b4e5220d664270b01b8a31918d6c1d81c3bc50532a0ae8d4b386439cf1fcbb25e88e86b96bb3e382d67d4ed643aef4ce4f25ee4536a1be4e138878b3cb92251dd92666e54ffa80c2e338b25c9e450abdc11c929cbaab32789527309edfee7d57410845885ee1966be8de5a02cbe3e5d068758a640818706ae7b199df4cc2072b27d6a42ebf82c23051eca6c9e359f9ae46c5e54c2d730219ed4aa757c9a1198827562824caa50857eb53cf87bbbece0a16e84ba7de3c967130fa7527ba7ab13d79d0a308daee925c211b74e7ee80a335fb14b9bc4c1883217585b7d54961238f22ce0b57e4d62a86363c014afc65966b5d0e2684fe81be7f59234696a5d2a058c09d3a1694058ea55aae96a55da9f54528313fa33ab0bccf2f630ec4eb84b2e253b1694ceccafd3098ebc2a3e09a9e1c4972d5efc68449be350f5187abd3eda3e5debc928103c7c883abde18b7a7bc746d4fe4cc69500077c4b28be99d2cf25147f57c7c253ce851c0fc648d05f5c701901ff8c9399b342ecb2bcaf3c79164b9f6e66f01aa3a9a15bd575b64221dda1c9942557ac3fd4663a466f61e51303d4f9e9947ba6659a59f97782e0e16febb633f9f4dfcbb76a54868d1cbe1b15118586ba80e4c76cc206d8314f25ec169c3de2ff2a2ab1e643d6a6ea23fdac395941cfe07f916ec0ea71ee51627d484f821fc4cee118fdd657c1135f5c408aef82657342d04d129c6daf253bed49573b99523a18744438f44ed7bdf53489426888861688abaaae0f37b1b2519971783ea64481809e90dfdff257b82ebd2479c2f5dbc8da8ab3f2a8928556149f94957fabe576182fcc9d1f89448578e4817eebbdcf2f347a23f0b9ef4643117e7f27b71d4d43882708ef1b5478c72c55efa86f66a4b7c32835699644d106f0385f391f8b5cc59ef2ce3a32b1fe97f012086c6bd402bb5d9fe0e9053d013e6f9f7283e9f71ec320a91dd0ceffb1cf1f307d799669e5534988decc420cbac0ad695dfd5eaee51b50eecffba463070f0140d4f228c9b94c2b974156861b1ee230dc6235c80ee4168f52db82c1de19e80a12c0916b31d041c87c03461ae48a02bb28da0acabc9330a3daf826f260cdf5a582411b4192b64e64248af11f112b0fa71ad22f73aff06c4335fd3fe603a8b03fb9daa1d4e48fa44fc84165740d66cc173d60ace20af868c3a1d5f7354b85cb3eb2f36fa8c1121453ed59471186882381537c818364c238d489ca66296810102e775a0f41cd8fc0ae47ef1e0c9e1f4a32ff78b77a398d57c02611eb6dc84073156661a4495b07f60b3d1092961b5ed40122d5fd0e95b3080f5401417d66278e66591816f95386b9777223f5268ed995a37f468e073813c842c6052ff9969483672c30864cdbd869791c77c0817e790a4dde2e8c275d460655464df96a9336035a764a98505774ed2eda2555bc62271e11295069ffc35fb97d0944705641561c656f80a52ab2924da9256b5f1b2e1cec85678cc5dbeb11abd43ad3c8f606cd9281701c17ee8ab59002ab09b5d508810b5bddd9624620cd3768c705960aeef266124d5c526ecb7f8f98730be18d3b64df0165628493a69b2f2252b6a961f5533f3869e19ca633579bbf420aaade980b8d2e8c0fc62a857f175fdd6273371d4e5a0816356ecec486ce651fd377971a50035db80bd1b14505e39be76fab6cec028e7833b99bcf3a6ca39f2895847d60b6d16f652fe3037c324cc5d2b4a9eb58cf584b8e2714337ecd4a8b2de9e0ad0f339ba23cc45aa92d5d56e52f3908735f9c591cdbdbfc2a6a616713eeaecec08dd0af5ce9877394337d3764f89439cd4cb25c5d48e0f749022126e73073baac8fa9aa0408001227fa5b9ff44b7cf4fab9a95df8dd4e9ec61424682221c73ee34bc6bce450cee82fb7c359b15e4d91e4d84b57ad8a9afd50e73559fb418c6c07ed15a9c5ad58e9c691e19e35526ec0867e4be7a9f1b14d590119c68097a5f5fb8c835a6998bb259c2e789803149eef4cf92e349866069084dae80d2e885d2d7e16105507243947ce915e9852a2941343f2c44a4d236452351053e2ade5e5fb62a593c71e059ae76abf3a36834f65d064f0e666ffe739a00481adb163122793ea638f8a3d7267478cfb12fe200dcc4613cd38ea037519a762a90c528b875589a59d6e10971e1f1149c6b51f1290117b06809e3b30d11c9b43516c507977491e32836862f99a5b01669812dc1869a60eae736b7500d9da8de287de66ca56fd1435cb6748e89a1d20fd19928e66defe8edf4e0469928f1099cf29d230c4e2ae195c6a1ab94396ce8e464c9c059b916eaad3e26ba9c2eb24bc1244b9cae96361ba0fa8b6ef73fdfd1c6953d3eba92bda3a9efaee4ee2d67999104749fab8e69694a49246bfa7822ed4ac759de39ec289b70d9bc537b351452497b9deb6061789a3b28a4ee221d447706a4a35bedcefd9da936abde21c3114c2cdc4a0a468d947ddc2e42d27fc3749025b4c5d1840f42d551153acda6d867a7f7f9caf95cfd8175cb6fc4959c76ff784bd1860f96341f9a9ec378d1d7696923866f9239f53431dfe48da85974b43f13e1e0a84544f9ef1a5d8d899b7319d6f5948498cc208af5fb196de565994586aa23aea072072167f9642be129f5a475f9504c0951f75e15224da95b33e35b868d7e1be8b9f3276dedb161d6fbd12d4a161c75c93ba6c6dd0a7233f144e2f919759e1ec78a063695761ae2d45bc46e5838adb9a708f3b3bcf7602980bdf99e7a1a95e645570b7226d27604bc1c3537d52a3487c246a0f260e5750b194669fa8758a3467e94226e3b0ac5edbad17988187d7deb9ed5ffdd59da45a6b38b2941c5617dde593f248d56726d2dfaf8a797499cb4d306652e1f0505b142f5de84a969db779d3ff0f8417167e743a28f704603f5d8d1fb869cc8eb9c1d334f1887a0dbb4ce2c182a253d8d04c1aeec4b88d8ef5a2a651748f36d2c4bfa52b9e10db1ec1ea06228a2080af62e6679aded150466ae90a710397e8d0282600fbd74cc27ae62048f794b92a0df5de11b9bc79b6d57d391c1cc01cc019f8f63b7f54ec62fc1374c0f95f82fcc279e32a2ffbeaecf1de9926aa486b187e30c84390ba7faa96e5980e61ced514162b8ce2f7e56ac803525c676df200657993152f382d456a5c609a753ca3f50f26355e6546c26ca23c1aad59821f9c2705bc0adf35475359060b1ea139ae98f3de8838c3cd673a4191e72389820c769344394fdefdff9ed73ef8d1772e94e66ae0d652929a8710cbd49cf4fc74e5aa9c56aace59a663c62f7f2583a7f9104038c342d86a0a7a9f2cb940c08631df8da01bea88f48f9a82db05736dc4c8a76a2d306144b49fdd3cddb4a16b40445a0971a7e8cbcb9d2ea13ef98a51aa956bc5113a99044241bb6b19f24edca30bbad808f90a1e87f3d9527385e010619aeee6f1f40209fb4fa8491779b5fa67daa9f721f2ffea7739fab3ad4e38131c2a78b5d3d9db51dfddcd68a8d2f365a923606eec66a8deacdf588ac2374df00858515bd160dc72a68756676a4e98963465b01e2d3ddd02f524836105214ab12d356c7b8bb05773f20a5e3ce0e76e141df0c95adb15bdd70bbb7dfdca9192eff577ce40e5466de2166920708d8c5ae0347f4eec345ff5b66bbac1466b2ad93bca9a954781ad3717d8e111615aadfcf7c28c3425ac891dd39c61c69a8f98d8217b4ab7b0240acf5c3f9780180a44c318d5dd5557cf34ecf08f20514653166d70d4f1c84aeb998de7a0a995335b66b7fad6a950dc75ba0bb492ceef276d1c82ae4c53f2d09b2a31a1ed0e023f7496d9383b70889630b11f093a1514594fec80a109359ba66f141bb701e3c0bb1b50bd2b7c7a1c931e070210acf71c5e76e17c76bea01ae2c48a147669039f8c1e41d9dbd325fb08610d735aaf6ec4de805cd10aa7210a4cd7c01fa522f04aebe4fc717f12441f11728efdb29c5608734f4e3b8db1c2c22365bbe4337351c12d5c6981398d5cfd606e4703ce180b62f4de0b8fa96f8731747eb919914faafafa5836e318e9878b984c165506ef0a6c5764d21470c5e87ecb7f32c33983da384999f738ae8a73dc2d53d4c71b6182b6c806db5f03bd41d169cd395cd788068260719cf23bb73bda61019ee1acfef8500a5175121908862baeb0305f6661e0a763abcf1708a6ed12751b5de4ed4ab1454da8131efaccef57e0c3665722397ca1885a9de6b27d87636bb67874558a69568982d7436e26877b50f281988c2b3f22e65ae90b4520d81116e0a78cee281876159b4f1f64276578b04bccb89ed2bcb587a72d96aa784b93a3d4e029cce3917d5845ccb0b81a16971b74080030a1e7e91c6f65618515932cb5c864e16aad0c57bd27878b502b7a11b774f330eda787c09d9f0216d9e92c70c5e1cd350bcc643cd703a7fc97f0db71e1fd9ffc0433461a235bf4efef47877669b1d96bddd6d6b0038512d86566d2df2a0e4f4f80f64f47ed7e6530ab305725324601f3420abeee5507a4c3d5b036280bebdc39eab277b8a4f01a7a257adf28e08ba3f090ad57254a9076a1169a30d469d863e428b265fcfae73106a020e96b357961a8d31b096db22c8677e1280c95293855f1bae02fa2065bca37063d1c708e0d514b12482dfbe3243599c9f458fe9f6029fdcc4fa51670720cd350470115070db6ce06f75fcbf3927bdf57ca60ea3d4e72f9b708c5a487bca0179a3c80b3952e7e4201395df880f1f57f721b3797f9e35c9115910e7b9032e130a003d2ea9cb3da0ca2abb34b6103b2e3694c8de94b34c48c5e1e3b709aa583a30998aebfe9004b068637183b8484439f6a0517343e90b5e8f3e8acae79b458a2c7d53eb2cbc3444cb430fc3a136621b85094d3c550f25d8f34ec9e2b87e463615bfb4b6c2356007377394068efb28d4ff5597e0dd26db9b7f3d73ca4da2bbc738deeb391dea2b78470094bf2dd65d8edad9856edd7a6815b54c28e59dc48fbfb8ab60a6d0eda45147f1033a5cef6bc7e14ff77d9b81c0694a52ee6ea792d1ad480f8b7233d9c0a9d7a8a145e8c1163875ab3339c7fd2f99012690de551732a18c63d230e90249ad27c8fa055547917b743d18e2cc31cee7aa0d0a3651b00ed9250d8b2c5909aeb1a9ac63849c39fd59b61a5ce129271a8632f00ba86a909adbae6063bc5be5db8eeda4e494321b3d16bb506d22c47b44e15ad491ffa2ac823717d0bdb5882cd6f06c1dbc1c2505f47737e8d2c2a84e2472a9232b97ce7df6b3e2ff66598fb61d982ee1f20a195e44b8a2a990d5a87043c5c96b4136b132849e45193b624aabc4814aff7875b809356023f099c39f49dad52bde365edef765b04115a7dac53d02173fa8f434f7c009744208d6066dfee91028b1aa886657ba78df4cc7cb4bb26f45a054854ebb07637d5de41f837195c700cdcf218511668ddb58bc9d92e8262564b4dc33fd7668dd8b689b13dcd64bc6845bb0ec412e4baec66228613233764f8133f036504b5236aa7c309e4accf983afe96718f2043597d8b3e0f069dcec98938abeaa2abcbef955b018539f52ca526492ab809754af03576c87561022fa92f0c61cb331bc951383e494f3ee0f19aee0953e206ba6989f45ff707ac1d60b5bbfb0335692ec7367fed15c97732f4dec54ae67e80a5ff99eb0a549758dd34b5b018dc85c7d10e5c3d23dc66303a7959be2a4777e40a84859be6d5c54d27877cc1337198c8efdb519b96586b7422b151e42bb2246e0176c670469e24db0222a86919b6f2c9a11d38819f9516fcfb05ac1e05f6e9829239f4518a4dbb4a6ddfd22d806f8f64f6605bb16ffc4baa2171f7dca8995d2e5724419052d8f388518dad90d8fb2bebdd62c230f1b29d679f5520a006a4b93520e9e0f4a38d53a61121f6f72eccf6c0790d65e4aa00439b179bb5bb54425836aa4d27a7c2b2b5fe8642862c435fb9256202bb826cf14af8fb7bdcee85a5414056adf258c7ba4ba8d05d689ca0c5327151afe8a74e2a629ac448e637c94ae2e3dc0ee6a33736f0f7b97d59b861ca572053573f154db8b47b901ba88fe3512a00531807150d722f720894e170f120c1dddc628092ec4ee7a524ed90ec2aee36e421a7421420f14cdb93e629331e8141739af43f6589c830fefd7579e02c56d29de4837e9d123449e64c5c9e806e8a6f8bd3c63d118ee6a9f8b699589c1f62cc5dc01e3b7e011fad0ef732bed00777348df7ab6b1d047d847627a574adc0117e86fbec7cf28c6e59e04724759e7dc050a5c47164fb3be89a948653d9508bbd337247437851559a72252d0b8087ff07a7649c281746a29004fe8354b77838a3feeb7820d6c50b8df3e7c51faf1b2e9b9b29eb5cf8c65ad108cec113b51b14d632bb6035075de9f40a010c83f75d1391005984b66406acdc03151f84988912d6ef8284d7a0c6e4d5b1580843cda703ef73dd7d2b63e0bd2cf1039b4649a828952033f483d9fc7566f8323e2b6f0ef7e66033ba4a9bbed784c4d6e112520a6036c87f02e5bd6dee9ec96d411f3d30da5a9f40b839b4c0bdb6e0380f21d394efc9f6f0eb6ce14c26e406209779254a8173cee63619e59b333b56b153de8cd8a03518e978cdd9eaec8cac7f872111d0d00467a8e5db1fe5eaf90d3679f776ed1f78622c1fcaf96c4eb817a86678b558abb7e87857f880303e76be96ec6c4ac0d200ebcbc253a964fff47d2aece9b3c1db6786d0b3c382efa9821b88e87ef44b9cceadd639326393a144496f56f11bfc3dd6eb74f43d44344910d8245d7d557f3d7076df029d4b182ad11cffd321ad13e5238162d82ceb1ef6b345c7d2a2af263c6d66808c5fc66fd152314f7f48c51cc80d656c6ad064ef72c502e1b7c8919d55d295801c2ccb48a4c9bcd6ded2085e641444568e5526464b5e010f7394e255fb132770c1517df9babc67879a7fab2154f8ba976f768c6fb78ff491f311bfd02f8712af3cf340fe5643c134b84d9366db9e65852ae2294c318a4241944f11cfa901933e786b17c5d1d1317122aec9d5d720be7e391e86cd26d0639aa6c12fe83d0a75f74a07bbd7be8031b72bffaafba42e6a51c36479e68a5d47e0c85a7c1c81f5594a19cde05a76159d8f08d1f6bac0bc6ba70a7580b3335ee28d40ff2a40cf9db5d242a1f022348072223019f1518d325c480a4832d1e460cdb402ff10c99b73d8f4340174a06c4c14a6eaf1d532bc1a3c97f7b5da071018292e2569e5efb11d091c785c86ffbb5c933a443a3052e29e06536172eeb0ed6014ad3f16ce3397350a4ac6ae9eb1a0b1ffc6b98e59fdb6a03c286df524f9108dc529df0b15952e0c44ee5b322e7aa76e23424cc874d42cb86589a40ecdf402daaec0c8d9e84f403e18adf5f0495639ff946e143bebcf983fe58923ebebbac11e36fbd616db8ae4e0f21b81ba7d2ceeb5d790dbe1b84fbe83f19c5fc7b6cf664e33cc792853bdabfcd86bb740902357c7be4e026b26001f3487c022215477b68283dc03e38b11dc383dd11be2d2d489d051634e64ab1d80b6d3bbe802d0f9b9e6a17a0f18e5c7ce385acdc98e724fb640e2eea4b2aae66c39f4ef590de412f360156304ddc32d8681871627a50b5ebb0d8a0628236392ee6e233227c82ca12aab363fc53673e04f3f7d2197740d8b0894f4f2d47c542f3f2dced60e545e0ecd647fea8d4964dbdca29c8233d2b8db54cadea255aeecb590254094be7d006079f96f8406a3fe8f9663c8ed404be059466fdbf6c156e0acd3222b0981083035ba06ab07b3d7cbf3285724344d18e5da5cacb30b3977892134f8b7ad733c4260c2f4331a6799844c5301d28ac5571f73c14006d6db7b5e05b35c951b92855d29001187ef9838369e8d42e22f662479b57a87ee3c07181a7fb05dd9abd39bd82c410b89b675c077ff3970374592916f577e33a8cf400fa1a9cf4b42b0130bb7eacdb1941ced5928aff8c3b36afb0d1bb9ec6afc7c0930b67fc2bcd16b7c5a20558e36cf679c658d177884e6f8c4779dee8c5680487d05a2b2b45579356bf87adbf1d3477cc7f0ad87fc24fbdeb2f7c6dc130e23fce376b3f621be5d43cc3c6bbcd48b85984af5d946f6338c17eca8eddd49d3d34dd4a668ec3ffa5682d5b03ed53ccfd321eec8b62ace6c8d1baa914eedbb76f066be7c02bbe2f715ce9f75b28f996f7072896e0f42c40d1e9e727daed7e4c62cb701b853ef567d4a7b62266f9a852354b510977fe9f56fb790b88c5b08e4b5eea6a188baa7fe122855fda5f915ebfbde68f821008f91b94d6ece05508d496957041023ea87264921f51913990a77feaf6ab23fd17f539d6d1d69df3bd31b50a8dd67fd781bcb6aa00dc6fc907ed899d77dc96f31ba09352d7a09b074e1cd0668ce1faeee0e372cf170770953d3b376b8cd2a94fd100fca3b87f1d7a7b444ebef90bd6c932d649a3f4294fb3b44f2660bc98214c9f4f7d39e53a776ec045f55565623380e039d5d0aac27234fc5de1ba8d643328e282f0bc3328282d7db023189cf296f7e1db511f421f543d8986b4013afad6ad8750d10830236450965c2b5ae18caee1057c8bc48a6551d81f329de788f20a6124ea624d012e27274f54e0e8aa4d1d1c83520bc5b563487515f7d50e8281f31a77f487f42049fff9f75cfcea8e66e897c91ead4d818cc0417f5704fd87307afe440248c5a585da772322955ffb16cfba15cad9efc27fc6e531394b2c765bbd46dba728e7d1d04a6466c1812ee5f936d42a26a10752817efad39b2066dfe979639539258e246e8973fc4f543d65b7f8e98a4d3e032a4050262f4492345f934fe080c60e468e651f6bbc7f151dc2d6f93fba69ee8cf6274c08e54fae58b7d7f7167d82deef00ff5c2645759751b8b43df99883e28c2c86421a6f6fa1486f8c91f5436d80819f73a67d8d8fc2646e503e77935fd7e185f0ff323ba8bb7eaa4496779214a3792462b276f7aa6ad0ae4f91269687bd3bf1c1cf950289751f3a2f87bb4ade0b3cc217d967207bfd6995e0b82af7d245c2dd403c8afcbf15cb0adc49d74bd454793e3c88d8229c10694fb84a8d8bbb5cd8464223b0b6967b4767a1049a758095695a8959712c43ddafb5638444fd42ec53f6dd9db372108c1bb4a007f7643914e7f7d1c383314770896e71a15ee74a697538a1fc653df14c3f26df228d7df307a7d948825dbff64e66139055f2e098dc8520e3cd93eaba07b3c9be025ee9cfc143d16670e166a8683a688acce8cd3d0e9e9c6fa5d0e4e1e8b68e62eda09d1cafcc5e8f85f31673f55c0883de9591a2d577c2d7f1a72304bf868b24cf5aad01a319af178f6c0747409a40098b080805bcf3420b59ab047408e76b16f9f64a1cd2055c6c1cb85db08741f869d8670cbd7612a66c1212aa9153513cd6bde2f60e516fa81630a8af20567ba19b03eb9617e3a3c414f92c328d8253d931f54b44f27f7b0f681e473c03bc6730fee2bffe8d28dd81bdf8630217c404789a01deb044aaaca4b389bb35ec7e58b75491fafe64bdd8ec82b8bc4675747e92e8d767f399b36a13b508e6b93fba389ba309c0424e32b9bdae9ea8fadfd866d6b9876afd74274c769635b8f4dc07e771ddd846455494ca4842e51b1138da763c2fd25fb66bf6f07c23c132c0f16cdf0691e23603e927a943416b69aa973393b9c323b8684ce665f9c4932c52ed863f0e542501da9c5495616638f24504c580063f4ec8b03f493ec3bdaaaa95bc9fb7e05164a37b03aaaa4ba1ec6a2b1dabdffb501c828223dfb8bbde758a504f422bcdd17fc09d2ed367ba1a89a2a2b3b6a7545dbe6bec6867219b1d29ce33d4f258defb4bda1f480626bdeb0f8659965d70bf094d17803f11b3a1c08f20b887476746eacc6089c2fe60966f2d6d77b2a9bb15bfb6f5c0d83cf2f77060373f9241f813d6c130e03022bbc310ff3d0e8faa62bd5df7df94ed784f851c10f9cb1274686c3a8bc8995247cd0ddfc0eca87ba6aeb1632f975cb1e3b85b2a8121d19acce5b1b27cff7b032d7c74d6c800890c47db389d01bf1fdc6fe1e905c32ba6321b84536bd7dd1f256c28c0924480c79044a488a446254ccb2d88cb3a08a2528ca633848bbc11a44d4a060f0bae57015901c1866711cb87b93fc33f0d427ff7f543bf58953d32fbbf49b94caf41d415d944c8acb52814e2bea4cac4a4c4ce00bd25482be95cae1d6922fff78534a13d47714b4cd31cf584fcce2818e73ef4e60934a18217d0d5e8a831cc605abbbf50a05e5e76a639fbef7f1bfb9740689d01c392bf93c38ecb2a94231389a753f5d80c70f8010780850286bcc86d191c50dfcff42a8eb0a56b3ecfe7f89acf0f1b96af5278cf7994fc7f116fdd0e134f2621d08868491accaadad0181ab82f15e9d76500d5fdfcb05d82a1d1a305bf1436be7e2c2d11b4046b95d7a9bc7ddfbe5e6f8293e3f588b1889975b91b57ae5f9ef68ecbc47638da672dee3f3c7c3eae0d13a2e8a616f1db72aeda447329634d011cff8bd8025998d2ca71e8ecfba4bc3a3632029883242d8d6dddaabc4bcf47bd93871383f171e6214b86f4d30e2ae1de1f6d7184936993b1a5f98b45c694a90a52f4ad0e6b7acf1d326fe7889152027bc4a2c5458e1b8a7112fcb934a861bee7e007611d46e79adc3c9162be3e959bd573250e6ee25d459aa44935f23fc2d9d65e9d5520a264b1cd6248f54d3b06290230eb140165c39c5105e943e43acaac6a939c0b4c4157dab5f548ed15f082166887e674e9ba33f31194f86acd43624e80088c7a66ad9fe060b9abc743d6c79b377a9dc123b8b4a0cb483dceee0d70eebb6c2003a2cb498dcde725202ea4ce8545cd437562c97750081ee2073bd87a1980603bd53a4dcf360a1dafb42152395c7d86f6cdb6669b6050638087dfd120216c1a75dda355029689e8e6882beed286f2ffe2fb25ac91f8b188baeab903d263f93609d80bf930e3d0b284733aa7c2136bfcebdf73b91e6488fd5bcbfb2a97557cf1ec1f7bf9565592d6ff365054fea24068a0944db0353f9a7109edaf978521d51b09dd049f4c90cc34a0f7552abdefce5e6c8b2db2ea1717ab46f29571c5f0debc715091a07665346c04e1fce8a0b58c6cd384a5f91a88a4bfc9ce1f489b753d942653d2d9e9e23e0d306de128852ae3c77909913077c955792886e08baadcc0419d054e5ad2a4db39b98e95ed91422de581af445820a959544ad397ca783a7b19675070811bdc8dadf1b469e19e22a5b7f8729e7c94ae6c79ffc86444644fa402dbae7b22fa057267d0b462038ad3f2897b5052efd946dec45488796899df5ab1526e54bc4401ff9536f59e3c2295806a73a99166832c2bd12fb82e207fe525e714cb830cf17238f49386a9b32552ede5e1cbfcbbe86e8606c5764f8bf1460802fed08a7f442804362067e16b0a56145686245bd872aa1ccf46aa0ee5a7232585408d6564cd33ebfdc3c58b26268439f7930b3a6da8fba23ce4cec2aa27917b9b1ffb0cd2cafd74c246034a1f17a6959bdd608a02ad72b11eb82264fe35dbc96ce4b63726adb549e3f9322f5a9924515c951f744e99c46b081c1806b1c6049d323d2b20ea52ab04ce394db5d5ab79f2b51c5124d31570325d32e154cb7ecfb1a3ce08ab81ac0d4aee3386db92ad6681a94d6c1a111bffdb3a4945e6063c993a0bc164cede075635a3b95265dfcd0d9ce1328bccf6eaaf152db6c3b9f98e95a04ce022ede511e6fe2794cdffeee78633c1bbc5bd192ecd5688143545994e3183a6969e5742df57c74700fc6ead4378dbae94b014cac2a8f20dd54d392415b1a838572e7958ff94062c66c30a4787391fcb3f833a25adc8880ec91700c59535423c1a87c1aaab600018621c294cbfd8431766d0c1e314e1080cfdc5797f4d6586222793fbd840ae05dd2c9728698d4cf4a4e2360a5f266185ad9d71e2941a1f9c26f2fde00dbfc79c63c260532fca32b70de2e33547128f8e6d824abfefdde101bad794a9a312332b9fcd80db79cadbc9de67395695902d212e9a0427abf483f435899151bcdf8cf39695d565aa3fb7062fff72edcda201f7f7b3cd76e480b92f1fdd253f1407f1e71e58fbd57ddb8d267f2ca6a7f50a1358e53392663b272cb26fa215bb59e4eafe4519767193ce7e04a738e547d642e0d0edc02c4701c8a41c15e74f485c9c616d652356abc93586a1ac2f3d14d071f49c51afda904f241dd8159815b34967fa1fb7a3d674309ceefd4245b64d6ca1d2f8280a20515f89ab9b417b0b85dd1122071fb3bf28f74966c9149f7968cd2c089bfb77a0dc7d84c039712ec8e5986449fcc49c591def571e8ceb35aff853e291a3d5dc527e58f15e76fdcb3a283719e830a13722420117a740a830e4abda75ff4ef5c757f7b2388aeaa2a26ee58055c8358abc746a9b4f0d51dab0048f2ad910c8a7e4456227b2d0d5ab567ebc68c56343482b72e2ea16cd77dc73d442670377ea5f14ab6359c7493e5b6c6eb2ccefeed26fa4bef4fc6ffe001de8760fe8113112dcf00cbeb78b5b7be024f64f2d13032781bad5a246ebb20a3067c04a69e3ee0b6a8acd7ab8867976015ebdc519a6195504fa20a731299addcb200583c278e08b14ee2dc820754ba00144cae1cc8fb3a2f2d2b03657bd06e213debae71a74de8a6c47e8c6766a3b53fccf089dde6b151fd7c4f5636ade0db00725a1eccde701312397b9e3b159d4982be20032f81ece35abacc28472f462d36a064f2229d7470e3e6de3b0b03acea454cfb90741440be0a321421ebcfb49e0e61c6a8c219d1fd1fb9111ba6feb87455af279b89328fff9071087d82dc19f0ef525f083b74a4c4a691e305e353c276a8e5026bb705a43864c6a7e3109387cb3c6d35a4a42ba51dbe69863fbd31b149a1725a40409dc29d854325217946a845af3cecef3f89db7eaa6ef3b6d0c255a140c7f33c316a762370c10795fb1f576f2ba00a735b3802b848051c2bab6a4cd64e5aa169d5cf662d36ff9e922caaf9049ff5e8579a8f2c8d8f5846d74c0f20503e9e740a21c6d8cfc187087029dce5e86b96489292842d8e092ecb162a71515dbb7eae5a3e3997f2904e2fa85aaf9f6679d11ca442a9caa535b7c103dd81fb69a851d4885db10e79176914181512b0eb0d3d34d1f6704954dc9eb863ea3b58da9d0907e03b9cac069f41466f4270d06339b7156922edb06b3b2cf1bacc548c2b03a18d229e7a18bc699d6492797ea808674965fe01e2b8f7681a877d71069523b88893d7468fce4a0ee7f83e4b7cb725f2cc05e58b5268cc370aca0d2778e78a305688d6f5868dd4d7f60f84b180ac96044bb38a35faf108842a2929f6f1a2b47f2769dda36578cd3912931d1f46c0d896ec1d1c6fe8548aa9496565a2f546918170ca379be81f36c93879a3f7baa03f8c0a7845a6e16dd6c7eef09cff79bf2529113e0f4d528b11eb3835d927eb99fc183aa226c9d2c3cc5b8aeeffd67090732d148e7ad42f21f0dd2170f4ef57037f544b7c5027f3ea1b8da4a8af436fee300db510143a7e04b22f413c5630228449c180deaeba0aba336a3c6153cee9ba111c550a2e957c62624bd2e1f7c3aaba6876e0674762dbacd34c6d96c8308b122878d85252546b065dbe3a7c81bde4052cdc47ee2c690ddd449e3e40496f94d96831f6b25205bae5ca0c0b9d3275c453208a3f6a4f7a38c508f722cb0487bec2e23eeb1814ce496e47768901b2e336d21057cce31661cde00428ae0138a31672731d991dc954d36929f410951dcbccd47062a0e69c59da238ed718dd18cd0d38f2f6c86c4d20124ecd0f5aaf8737d2204e9803cd3902a5aa7acc7d126bf92a0600968541132d19c67e38adaab2bc7d81b5243a18c01665dd606c9e9c1ccb0b35716a30f9ffd52a001a40a6b619e76f7157524fe7eecb0a397fe697a4c34b61a3eae175bbfe9993451275f7f9a25cf6c16cb07d347a5ea05237b00aa19779d31af3e6e13ef34a0fb9e5e2e6fca52305627001d19f744d78cba36496348a5fd49a943f56c769e055e30e6d0526372f68bfedd75f9208a0b42d1ccca1520a0a6091315edeaa588e86c524b55a074e644f5ea2cfc36d29d51ede028fe60152e748da8ee12ae4ab711e73565288ac6eb1c6334d352d1bdfa82dd3efbcb595b3afbad26490bc8294531f26938fc83cd8e61809a1565ee81c4922c5e2a4a94aa3881d32f67c82db27928d3f82adedd7c9a390922dd8b1f3eef378fc35cd778504d44ce6d4afdc28d62c278d47c4bdea65ceaa880b3563a466eca19e7646540fa7ef9dfe30060f1da516dcea1ec69699ac8687ec0a1aa8e32c521cefe742d3ed8d00c73c2d89fce9719753a68b74343e0ecc89e4fbbe4c22ad008a61c66f886ae320b4df8dc6918f15cf382b08e665d52537de88531135a1f7f9f8162620a03176c6957a500c8238845752d398ef9c4e88f72aee081e41a4f35f096948f3b86e76b5dad16014b5f1f871d1a090a8ee553c103ad462c51bce93c18e871917b510b9f9a4820f0241cb6395f13287855ec4b47e597fd980c05081a83e683752efd348f13b2cb21fb56aba9477ac2974dfe20ec7445c55b09ef3ad0940929df8498e4174d13fd1538cf6e6bccce0926752f9d1d86c47f9271d8e6cc8d3728fd5b15746a1230159d0f4a0e20aa225b53bfdf45df5f3dced97134fb4a3f79f8d3adf76a63f520331f57a7f7e3b250526176ad625f01d46ff618dbcd74e07e52e882419c2cf26cfbd784e4bae20563099592b670b554449d67f445cd1ad9d18491d66d1e61e5a7b617a2663cc171882f6adfa2e14169462f34cae27092f31feacb76c1cd140e8937e31dd8cbe85637956bea33410f9128a35ab43b53db7483ae931c8895fbb850bf00c640292640cfc33468a2dc9ab75509889b0591a292958ba43ad74c141558e59d1d36b4042bc92c05ff126d53c11a584f569b5ff85cda8dcd27c42333cf4bf12c24fe5afd887fc30270cf9de6068ffc96d430cb530367d309c5edd5c091a9aa85d54496eb87efc48ee9def4adaf56266f1b40bf3b301bae3d9ed278c3c16e451681ba57072cf8ebd66b4ab1405ed2f0a45b769f2281083e8baca53e8faa9f89dc41e92dde693537aae49e6111c243ceb1f4faf9917725ef02554fac68f30d1996f8efe44efc0218a5e0fa60231b1e7519732c70d811402a1cc33aa48b1e7e8804a021c55024178f44d7797369d36610c68dab19f3f08bc7c628fd5fb700d3e5ebf3a4655887c4f7f1d07afbb9ff7bb6dcddd292e5776aca5f3128c47a4abaaf768be4d8f8adc0945867676646d8559d1dd0d23eee7886fc5873ef97ac35b8791edda147fa412248b62ebd77708efad4a3c40db1c17305858d7f877280c27bb5d747ee9cf73b40a6db0febd3b0f95dc323647372eb9494c1e43ca118080ed95652eef11b5794f15ac37da457faf4753c8f935e0642bced5a6c932977bb94235c27430d1b212953d082a3d101f3f4e3a197029b136621de97dfefa8dc1656fffd4defab17e679ac52daabf154701276f06288d9cdcd5029de40ab3acb77cb50df13b03b1775de6b58c1b4bf2f787cde93b97997ed596ab611cd5791fcb9213d5e704d142a20a8e24ab5bdb67cbdaf2baa700f65e52eb367579909b4a6d42d8564b42d649c57cbe3e9677de3ef04dad081a47f70044aeebe00d781a9c42fad424116d417bda5cd12ceaa6ba14244e0da0f79378445f2176b6120bad4ef70a2a3df15dc41fa5143af60506b3795ad32c1af80d61792914496cf7e2e69b63e0993a33f18058ef35cb7dbf05b2b21014f60d37ef519cbf6ce3d1bc4308827c46ee755982289573bc29ffe36ffdf56c18d565402c989add452f8ead561af011688b8bb9dfd571627371739d0337b92d2f97fc96e641bf1ea16714203f3d4836957591cbe8c00513464a7d31f953bf4de0485617ebb292d6d8d3212d26095abf994beabc286e2c31378d0660c6ffa0e5192580dc12931c846c67889baa94c614268fc7513e38a7a13c3dc5b4e28a46aa471f51c6e080fec6f67c5f332b87c140a06b8c43d1261eda63882fd748cd2f24c31f7487dae54bc648ce6971d6d3f9d68373e159efbc773332a49e9d57fe0642979f06fc04fcdeebe011c584948bc3a4d7b923ac5f69fa59e7e50ec007234b52a734650029ac743774bb793c13517a1d47fb793eb56e06b44763a66fcbd603e2c99855ee325f2632c36921e29fd4415ec61dffc069e2cad09e24901ac38c326ffa71fdae997d6ce00f9dc3e2b63aeb04018a31ea848c2ae8b31d1c6afdcf02d65666061997121c31f2b97e2fbc351b2ba194e51d7b448152d38199c86511b5027818d9c83f8d5d2741441ace30be1750c262fa30b0f0cbae5972795f8c0651fbbcc6f53d2fdefffe797939fd46cf87060526f2d052f385e5a91fc9482af2357ead9a9edc558bf6afafb2ec932f9a6db7154b3bf54b397cf623baea44e9f0243b6a0496a0148f329236f22af87dc1befc932e49f4212736d11ba3210834d738e1595f96f0878edfd52133895a11755a1018742bdcdfea1d2248c8f0dbeb46358991eadf1c59e986623ce757194c4ef9e64b03f76b7a51920283153a5c74403caa74c8aacd3049c4aac358e3f78238b29c3ecd9e8877f516e80d4a912590875412f36b183fa1d66226056d2e770400317357f65503f451c8b4e6c370563f5dd67acec50253fc064db8b8ffdf53eff55985f2d67a2db48bf967bbce305fb271365c1342238753ff32ce1d725edfd7fe4aa2f2c840e0a0272c1e0daf1d736cea340ac37038875a65af78541721810d9c6c660a773363dc47b4eb8e5df8a27b4f368c624e5412edb4bf7496265ff35b115c0ac4360a6f9f65ebe9336357140151c2bca0269809d4018548de43dd830f218553c1c86cdde828ff971364182a72ff99b79c0e567386d840bfff30f60c3fa957a4fdce2d7ac291dd06f0d31a081f3bb6e2e8c3cf60686785c0d26b81733aa62ef53deadb16bd8c9c5faa505906cf701684db4d6f7489a51b31655db70a9e5a934331a0ab4d28178333bb9e0d06e754d43bb11ef0c3e52231abcc41adbb24f6ed05779a124c969c415c1165edf3a04f570aa49353670222763bce6ee9fa958e11454979e968fa9bfa251bb9b85fd0d2ccee8fb7c5282bc1ca2988876c15a03d37b059314b381c41903fccbc829ec4089c554657404323dd838df5207bc36d41da1ea289bd2df7214ea7d5ae349cba2b41fed3e7fe1b9444d7f9b86d6634d69c0644a78f33b05525b584fd9bb214ffb0b11f6c9f6884e3bf3f68b4377420d83e4e204126eccaf6f3f8a917ed2906efc38a3c2f42bd6d1e418a04325ef9ddd850c84a1b2496076bd01302eb802eac94b491ec1739f03a2158ba47b6b087ef187a2eab372956b6904f34a9ab81d13d36930ab70791d4370b6ee07198a56d8a8e928ba15241611ce5051f787fbdf87f42ca9feea392fe32967145ec0b293c54eb3bb2a56e73caba6b4ac7a67f3850ff7798c2bc6e09215938cbfd80c43ce6e8fced2fa0862e578fd86f8798302b43fb9199df68f2878442665c26de61ffe16fd85a7853bbb2cbd6e3d6d935c2cf42a77e34b17eed5466a35c342413c86e058ad731b24194073c07abd6c5f9c5775ac3c890ec714e47546ad61e6e0c6079e55a653ab1a13d2856960bbb1cc47d92f66b130a58cb465c3e358b6c439fbe4cd069b6e9eb2e96e41f13e13658ace2f6f4ecb0405ba30c47d0fe944a539cc4d561b607f455537eb7ce9e217c9a5169ff67282f0b60b6d42bb0ec5b7a88450c8719f66221b78e343f2608855b8cf015db4761151785d115226df0d8e1d1bb503b7ea2987bf224538402807490bb12a63af93f0ce71b6fffa72ca3a5f149fbac8d3840fe5007ecf5b4235f1c56fa6df2631a19418da22dadc409e6cd9f6b206402daf95b94d4dd8303677188efd9c24d13f83ead92ec73be6d2934f5d772653bfa185b2f79abbc9b8f881f39ea64b4b1a5734227de1cdbe3b6fd5e5dc45159ebdeaa007bd6831f627aa9e6aca9e93e25ff30c5fb77114e92bd26fa29018111a162b56134341c6623731052a65ae0dd5aa226f9bdcde3f8a19d1c8c2e148c7e89a08c8ffb52f8372d63d31fbb63cbbd08dac9bbf1e60a11ed854e014fcf25f469870df364222bc0a544ad7fdc4d36023c50b0e5f1800f192fb1bba63526d682e026a5b8a966816bdfe3e0d1cd17251fe47277b3fb6230a8cb6a49cef9d8b8bc693b1eaef38dd57246fadd9930f256763835e3952d0b27b1c0cebf47c95ed6be5f6343426d45d509efb7c758ac885840b4a058a035af7135894f4508c1afc1d66a70ca4b5dbc0f38410a517d1c838a0a68f9caf4a7b1de20f7c890f0c82dfdc956e281bd85b44aa8697680b61363712058ceabe4618a70391882b0b36bc58ac9ba4d8ceab8472a380d50052a0c071241cb6e9f7b3920274ebede2eb926bf6d81e5673daa64304df57fa18be1de7f75b76dde38297ea4a4997503744d3a23ab49456ad82ff54a49f96db2c98489ccd52bb48460533d8835fa324b347c7ebc631d706db06669bd9592e0147d516dbbddcd5155723ae0fbb25b7802129f8e503294fbb1118c4b68fc9a8b6fe4c01a38641c064102c98068bdcb31f55d380fa7d8771543f914540eb2831b9fd9cb886290e0db5893e2887b1b1e0d4660b0b7dede96b1509cdb94db1281090d771aa89be19d8a4d0ad446a6e8f60dc54a0c0ae4068e68e21be730d061afaad6e8a33a57b898f080c8139d8734c818a72f20c338965a84fb9515884eef41436a5d4d1478798742eb7901b2a9db2a3caea922705a6383de38dc600e8cee81200937bdd2e78bb16ff43606dfea9bd7d1c26aff163132a1dd22f799d3f4fcb14a4a357063e1241cde07c5d1b2c6a575b81437f146f53a2f07f6a84d1638b15a5a465d981b5c819b41cb3badde09a68273fab30b664f760c903039ccaa1a86cc5482a51ba88668b16ee6a95db58588e9d3a4a98829a40de3d859a8a0d368f658ab9e69d288bc78fbc86f20244f79098f47e1f88e1b0871563e1708428b5ebf6b0d531c386be02d0154ba3bce8e19c3c080a218b9c33e4d6ed4cf67bac5b57e56b55c2a53d39c148deb15d351b3de00e016299340d53852716e43328612fa4b04148ab12b7d56dd481d19f1e9593321f1fc3765f260ea6625ca48ac08b593210a53605926e7ddc7d0b2e1bddf8035d057058a9fbd08a81ecc22242b224fdb5af58bc7cebfd976ffe771caf290062088ed0489867131954622f5748da429d03e63544f4fe6a7d88970c953fa3419bf2d200a7ced07c46b6b0c975eb7b061a1af58944be45789403bf3b1198dcc3c4e1deffc709534ff07c87912f8269c5de5ac4eae9a4e69e69c751735e1988c1e7947f045a9a5e1cec2758e8b6dc47be6f3f927cc8d76dfb57a586692574a6873bfc5f215be34388b43be3fd1df8dd6ecdc666e92589bb2c3a2e0ffa3893c80bf2d627de7e85e01968909c348cc604956de812ffd6f852c09045b4cdc809c2e40eb3dae36b39a90dc7116881556afed20bcb5edae136770221ff4c30bf780f16fef44130fb08bdc39456a64b0d5a956dcde9feea94f74e45c72b19af0f9a088a726e820b041914294cfeeb0c27e5a0b108731d531869825c3a1036919c8a4023f74200c2065debf3285c206df939abf4e2e7042e33e091bbb29b0b961514740a2cedc90de783364408b1438be81e9c08c050efac2a6dd0f221508f991f2b0eb768ad1e2533e3dad4340c9b972d493c94e13e46693941c9ca37dc528293fb3e83eabcd62ef236c44c70f2bdf6c9dc65929b29d60691a1192aceee83566c4ab9c1ef45c931f2d8fba2cf2c7f0ad5086aade9cdd71bba070e9dd82e8d36aad68e04c2d2300527203e5a5ec7ffc38efde9a653e76fc33490bc8044c9bd4201d2cfccfc40ee91fe42533fe075c5bebb0dc5c1c462f4a2a682646d3149983b85966df6b0988932de6c9ac1eee9f222ed926a9c545481db6cf0d2c86008d141127dc1e86baaa1ff996721b52939619070b97fd2bfdde80a974d0abb6ee043bde7d232181ab93a804a3de609085c0db595a26c55a0b108d54a98c94d9a21d9c7f819daeddbea8b3481ad48f5cce30fdf64a33f3a443e19ade87d0d3a82f4132db9bc01dc3e221458c4b4ed18ae56fc52425059055402ffb11bcd879d642f1491f2ca81931937d73a5a0c53d247ad1369b58f73d959a829f5bd7637ba0bcc8c514439ab9310e7811088f0c3c95ffcf8e0ae16e89b19d618c02290af7e97724e26e8ac3ca94e1a9010869656c68edd65fadc997d41696b709bcb424985a7cf9891f2cd5e75abc07febc296a3a81fc0854fe8193a10871d0040901f88a45cadd11382f1b2b3f102750795a76df384bb5c74d9be8bdbd4576b4bc67f69f92d3c4452b064d23e72914fc35c61a064e2404e7812ed468003f3f9d290394beea74c5114227d4556cd6d568ecedc5988ae4fa2a5a0e0bb76753c27fef4407469330e82354b3e872ed32b6b68ceba668a149e69afce6b7d6b7ef627fe07120f102dc4ae2a91df94569056d117160af78b31bab2b0c6607415f50f5368ce6690c68b14c651ad82348500452cb0a95f8e43705fa5e6eddec8ade5737716ea74fff8a3e0b8207da866aff99d05d5ebea84121414d9a01000a4e5b1d9c81cf122fe638cdb814dd0982595cabc95f401c1d5882cd4dde574cc115def25a80af5af3f8f9ba91f465c645ef2ece4df6b092db39ae379931db30169ddae7fee2a0dd543e78e6d540e15b648ee277ad341d57e6a4ca217f1cc9f15e5436a44e842e2633c3d00a6d111883d270bd232cae862a84079b1fe7094fb5994f5f425a1e8729478f022e247f44d88306b4e6f05e9af1400b630d7ffda8b2687ac1065b40fa490eb5491682c60b370e13f30b277f38356d59ea4874dc6940eceb0622d5b07ff86372046bdc8e8b818d1d5391e412fcfbc01d3df3d44b17871a432e1168026ed8dcedb4169f142dde329628632d60ee61dc1fab5b8308f1a55ff55e9e8c273de2ac4c1645737f465d39a9b18c47579f5012df0aa7de9ae3ce0c1dcb89a8c4157193e3f42cc23f3ee8f993b40e1bb5b4db5f10f2115cb691ec0b114dccf477fe60108ca4aadf5dd19ee67bd1459a1713189277297b02ca47dff1601860fe113453e6d5fe95c60af69d1686b9a89f7a8221e425d37102a1964f2d48f81fc7099116e659aba80d11c31f5064d732bb1f0750e9f67e3d541eee171c6e825dba86d36e351c5218cb85a940ec635d3a6b859e113d39a4ff593d2b46d632e5f954d0be970e865d31ed9f8bdea5cc32e85a224315ad0f00d6d1b80c42565570e416a48af4c0c9bee6ec367e36703736d33e9ed179203bc5d2d09b2be8c2fdd58f8519a8621471cd01d2305133e3f33cebca33d1c228d8e5312d679bc0061b9f9e1bcfd5ce0456ebf65562bfad6eb558903e1835cff02b1a481de3058c2e85b4ecb6151aac80b0e603a7226af967ba24a33aeffb08805f8559390d6bb28b8c2af18fc59be4cba1c66b66a8fe87fa7d3f10ad795a0ce6df058df7bf4f120be07d8e81849836c6da6f3dafd2c4ac4f8205f3563c3946b5e98e85220c3d93c117ec5e13a377f10da2849e4fd81eb775bb50ca01333eada706d936649231011345dadbf8db04771ed1348e686f3bec8e1a30f23ac469c4df2c74301acbda97278e3416ea71921fccb61ff341a801576ef2149e73fe4a60334aad0c8a730380a2db8b376e5eb28de6b6af7189a3c46fb5a1712757b9a9dcf054de69539eb894df50a8d9a256a17f7821dd2591c2cf4e4932a2af3811064bdf0dbe86b4bf7479a233f8affaa9216101e9ff7606018b57a80d2e28527f0c59ffdb9fc5beab8bc6a65e19ba354bce5ec0b1ebc8665b7fe86b73c36c652a49ec14ac0a6c72a68d550fbe2afb14cbd774c77eb0415a3f704e3e11469680e3c8f04e445e6e520caca66760a1263e62cf03715d55ac0a6c3ed16efe5b5a40c14be95c8484b17324b7f8d133f33ff7e6046a5f9d47b53267a836a6e6b909a2f9c95bb1235238926600fee7282f5659c124adfc3e0e0da7baa1cb0a8bc018da559015c5f2b44954aaf7940f9c50b3b34f7efe38ae191fc7a7a73eb0767efc9e6fad3183d48a1b1f085770881c7098c915412841c24cdb0e2af5a1e256a486df0811f510145c61e26f1720fdb561855faa341e62d990b29bc8e18d9ce59f0946ad14c6e3065952b068e25c4822d70ac689aac856c15e5644eccb16db47e11969f3f34953c5c0a99553eb79c6a4f1755caf7ccb9c85c444ee3a556fbde8415d67b0342b69634b09243121ddcd7abf2198dbf125350b382f886748b0579e0881e9439f3cb3e7471b50126cd4d2b6c3091c871d049539ab7a7e3fd14e42b3c1893951e1f513e065e1db792723d6c5a231601bbfa59b7dfee08ad6689b19941be26c744dacef1c3851277a461611b0e64a702bf53e344cf698d659e5f84c6efa14960faf444e33a93882e4c09ef4f899a2cf74c4d1660130cb30220daadae7ad6de898073d1326a20478b9efaec8a1aa93b045e3de264223e598fca6bbee0f237998d1cd9acb937cace7d710f3bd5985fea050e385277a3c828cc5570f6fde6ae1bfb694aebee7524e929727b512875b701bcdeb4800577d0cf03178103d52693e1608f43f88ffbae626ecd3289ecf4956a0191f7fa391152f1a76151a14f8f7b7f9a2eac4dccfd2bd3aeab836fce854671ee51279ba339651bae6a0c47fa9ede855f023ddf3c011f9ef75cfb2ffde919b8fbe63a70867878a8662e79a3ae2d645108881aff228a59c7337eac21ce08f803fb8373e07a4c767bc763663f861caaab3b4797e604dd3f42782df97abedb7938e8f83cfaba9dc5de3043496cae8c9eea871ccdfcffa33401206b6ae982d7bde165ebce1198c8166d12c73165b6fdf278d1286d183f4c9b7b5e9cceb06325344a03bed5b6efc7e186cc0373409de93f5c4668dc2c5ee51b2bbaab2a6fb84500383cb24359bd8df21741e358227486c3e046ff6a0cc1a8c1bb35e5f461f630093e473cad26ec9e666b0fa4a26106baa54ed42025b088a3ec7e1f71331440445d47f3fcf765a17a60ee7bb04224589df7371c9c0572689ec3129fca22b69dcad324b45a10bd0485ad3f3c814e96abce8e7f7500a2f3cad2a6f2465f21f0177124336c9e63125cd3c4e88f96343ea43dd310e8d498f297cfe93c04773be5a80c2ea6e87bd231f9cae64374402346a054c9ef43fbc21ab13e65c189b96309032017e7dc049ecc05d380cbd7b4e39a24d39b5864ce92d01f52a2a81ffdf1a9185914c16567ee33bdb66fca8ee06de4f7f87639cba1b348998a0b99f5922b09afddb8597323e4c09e347fee2a5cc8a8dc1e4e1f3cadbed11caff3c8989c3a3a87b4ade62aef70380579ec626e139db44d93feef8c0ce5e5e5ad2ca34346e4b933434657e4a28cc66603909c44e6727621ced1fabf050af5651807326c25621e3fdf49aa1d3eb6c0463cd09e537e81500f04ef3189a8a08c157ee5a8657f9da323790def5e202ad982ba3a504eebf56551022da1a2ae530f48fe4a69a1d350c2d2c93d699b61e8e9c7d01965f95d1161bffb1002489ed3e1d2df79210266f0af4eb33cf4afbf1e3a3449cc8e93ddd2a1ea7b0197584988ca1e242eade4c55e73facfcbc4a2967cae1979ddf9b824838574db6699743d21ea5d2ad8a6eec0d71817db97189dee1b6a05429084b7e1b437c36969644129ea6616c76de9bff0476f657171cde008adc589877792814ef1edea3e637573b2c37eb86ed1484ded97d5e0f30985f132d11457f876088069d057bb5bf7e59863350fe029a3375c1ea15aa706187a2cb9d72d54a18b239ae67f4e6e6fd940eac304b1ec64fed70e42d6107fb36a404197472332ccb5b799426e178858942227daaaac0578e9ba7275f11691e701072228ef2601330a44084003fba0f6ea2df610c4893ba7614e0722ba0afb040c49effe1f2e9ef22a339486c146600a63a2847a0ee59c2e5263967f3058b296909a829069f88f67ff64462c174cc9fc76eb43c3e2ad095137c3cd0e69b29907f015701666f38fad04ee0c0f6abf62718dd507036b90243d2c50064c8bc0a567b17074d90d1832a51c09af240ead92949348913a2f67eaff8e6d97ddd87a9906b5249f81b70e56798418161ddb10cb95115d90bf9abf660bb700baace9105da4cd5d84ac43163dcb6fe77ad179bcd0ab8d81298f222c68f81cfd0a89501d08a15ae398c821cdce812a36c16029327bcd956655c8947f22510497bc27677773dc62bfa78821009325cc439bd3b7643dc88e6258560a64a9b588cb4360f789a4c254b7a8fdd0df8e8812de048931b6851df815864b37240313177ea6447461fc66b5179435f8b93d5f90ec57ec8a8f74b465decf75fd9feaee0b5f98c9730b441eeeb5843ff60f10f0b6a322ff360e72a9d8e0309773636422a53b1e621cd36495ef88d7a22a16acc4c45a697bb115775dbd0a135ce65ae4bdae9d5bf01b256aba52175a7e7b7d0d515cc94f784059479f533d85f33eec7170c4821c070365727ed952109ca8f3842ca950c5759cf40ad06d773a2aab7147d50df3c04cf4f1da93736f3f803e8068f1a87910e7fe2dcebb11dcb67ead5ec832ed42b475560809b7dc59db5d0fe51b608be3ff972011224562da00a63cdc9a816eea3f0ee3db46cd4a477cf74cfc46e4b9f6d773bb6a2fa0e11f0f505c7ecf0fc82108f7f3c25d5a098e3aba7eea147969f7c5db61bf4ce982d6f907b92f12bb30402cdb214f0212cdcf834a5005cfb069fc3af8dc32c17109781c0d75e527de66c3ebf16a543c3340955d786838d69ea6b6e90568c1f3c18b9e4143558ebcb908e38ee548db70a6092efdf74317a788c51dbb6420ce707c056bd43fa9aa39617a8035cb4ff58949f763adc2bdfe4120fd03d0053d3ebb023e05612163262fa430891d6bfdca748a6204e413ccedcc8848cad34ce0664fd11daa43bd094b8d8fcb0aaca249ce9c6210acbbfe6fc3c217b116bb196b00d8bd0431a3f7db432a877999a0ae1f57f58e9584e58da77669574302be9e962668afa0adfddf757e13676d9a28028fe1f1e03b4ab5f55925484388c51564b2edbe59b12ed8af3a7682092e2c2104d2ce9ef0a4f75c04c120d7db585e68e21bf654f965e757329486caa1114245d86491de7d1bf4624252263e92b57c21222cadb39c2b22c488ad09593507462b6b31b8efadb0746c3ac7093ee4cd408c9438e1aaf6c0435cb8c9940178c3eb655a1f481c76c21328719d37c6a48c5f720541f2b6efb709f0b8fe96897004333f929b060645ac6cbbead56ec440219aa226cf6f5321c4828017d93d311b358c68573f77c324a904fa9874ffb17bca71124ac43d2ce6e443d4416dffa4b432169a09e2d7d0ff04cd67366cd071b15d19a2941fdd1dd7e2e5f822517053553f47fbd0efaed8acccc7e67ad3164f7819c8d993141f644af06c33bec91d5f0aa6270de852f1d93a70916514b0ba79e97b2a67f7f88c9462eee2fb1db2b2a5c62af3d187c7996e0a296a30aa71fd324db2be2d95f176ab8dd7df1b365b88fd3aaaa1e6f7873dd5f57c27d94fc99562c4e4e8065cdd3c6c80c73ef6b6e7b04c38df2b70c123d67e08aecd756ea986ae52b03f583d07a00fa03660b159ae1eb317cb836651e962f5750f546bfb2f4dbd8fd3453c1384ee1684677f6ef3a9760a4bda81718066655bf74529f6c6c2b3d7315d6e97ad24e92afad22390eacbc01eceef2429abb893ccf45dacd25b00faec6c6c447a17446319b731fd5a231fc051fa9643d7ebb8e6b2857c8598e415b8afa847eb176f6bed812404c994404b7448a11d6ac96682448e9726442b3fbf46564a8ddc2f16d17617aac58f8d3a2689577becb50662c167e991be7ea8bcc6322fa06820df6acb95ba9bb8b297cd467780aced91fa64b6cc347dc54b1f19cd18d18fbc0c49a5f15f4e067d3988cca036ea60de9909a1d93a581f17f4c7af08532b3dd227c9e6e3e6dd71a1c8ba5f241623c1f2c9f94d7adc1d482fca65ba4a4a600c1ff9ae7c822b03d69940f1e0b3bdd143d98256326595dadc4db8b2eefd2a46d5bda081e40984b46a626843fcf7ddf439ce186336284d91eb0e8db87bea79ef7aba25974ca5f87096e58183921ac345970b785e004e0e1060f8a6194a101d5968d45239b4d8be34fc3ab86c102d22074aed20d9eb45c1213b14c3b2c8cc8907a9621b99baa669f1c638fca913646ac756a4700f1799c1779fc1c6500ce5d94d24d66d18c00818353ef899ffd3f80a2c2c81a603a2008f7d548c416f8d44df026486e212429f1293dc00b86387269b9f46d3b276c179c003de770f6d69e8cfcf3422cd2b6abf5c246aa6c4d7c124e0a6451c1d5ba651e5e8c681f12446bd810d55c5745ec4e94a270f234c73ef50a89bd10ba0f2279137350f9f0226e1bd4862945cb763373efa04013ae855643e2133f438e5a83bf5392e0bf2e4bcc5eae6b9bfb71dc65e381e4206dadf49190fb48f58f03af9db1f52884c740c88dd2991af81b103ed70084dc3eff9eeaa96c60953ba60d5910479fbdbcdd707a9327379328140b787631c85c793eba1c4692e4d2f317f8d6d883eb1e95dc04017b8ab370124c7424d833d8deee88cbb11d587d743b844c766dbcd29df611eeeb2da945b6f47e78beea6c73bfd80abb164adb19f098060a1c2fdcee90d4b1fd9fb86b3fef4c18e4ac71fb7bd5acfdcaf0e9edeb22552a7e9442466c378feba5f297eff7a75ede9e833af4b96ce2aac2a199c6082df845b182f4277d00fc23a43f7412b737fb157c4b0c4591f3d616b39c656194b8b4c2f0af4db73bd0709ffe8c8223f810878065fac284727cce83baffc5390b332c3e128cafde4be7b1df04cf17f0ca2c5396f7314e62ca57f331cbc2322a06973bb8723bfb7eb0c629b3e3ffd65b43c79c774547d31511fe5a027cbe6151cbb698dc6e05de0d1b1cced8357fd2f020b4ddcb7dff995be9a35ee7cdf790d3d49cb5f7bd20bf84ae323589275135d9f7743251582057a4c36b6af7c507a8465869b0c57b479a7b97564efb593b0b708270e60d92810062b0d5837b1252fc48160d0119912970bc428d045c8beacb7850d2885b4a3a95aa4dd356672247212f5bc95a5060dc97677e5bcbe6bf4e57985c228639333e12fe282a11648b5f5e4c4357360a759231dca3f56634f888bfcd62ac084c2fc98ab230774dc0ca68cf132d05edd11172b70fb261b4dad145e51c4717416ebad20158781836a0ef759323510b31118823e1b2dcd68ff9c5cf0ca430e020ca142944c59a7ca6029d7f271a7e939db598f0a654cb4825e98398fe08e07f594e39f2c74bd325db415980fd3a4b7bc2d8f87aab7e636055153fd760e2e716d19bcb955630f327b718b6c0a799e4ce082741d2a21275fbb7bb5482dca6b1ce215feb9a05a0c8cc076e03eb3eacaa93358fac7835ab4b51d009f35c869e946b3efff5128b0c5f44543657fd598384744342f3152c47d04185e6367ee54ff303ca6c7696661ff3881a45cfb43bb82424d1a4598b52cb8039656e935203e6ed0cba52470340218dd74e2cb5bbf22413c02414d566b015a47be5bb439b010c21339128a763bf5720865af834539fc0b40311a0cb3c46759a81979ba57f3e243b94486930e829b78972575e1d3fb721d45a5fe0afeb48ff208f2e1b38195ea8104379e3e44e6290ffedebd1430b7e4a8f185a4f7675878240363f2fcea6acbb9c30a8724f44b9acf2e277517e6e2ba2c67543d66172dcee21e32b9d2c595f75dee0c9fe884fde3bb5e2e09d2db078a8197c00cb3f2e9d214a4a16208bcc4440d2b9460ac3d939762395f93174ee6e44bff2eb97bccea12b4220efbfb1d6acc50508906fc9225b3ccae9b08bfe7128a0e2058d6e85da7816319938f07ab453be95de7bc3950aa56c688ca137d9cbba1d1f1200d3b8f4bcd3d4ffaade3f0c59c3dcbf6a5abb6f2947359ea98cad8b7e4613b181cf5245c43b01b0927c4eba266698d1739d9fb8e0dea84e476b0476b8bbfc02350dc0d367cdfb36bb5eb350421e44d640962bbef798ba64fe56274f3e92502bc8cea999f69bb6d963bde5d36ea6f4692b2822e5ff1e8e0a3a1939bca35b7e88ba1ea8dbee07762ec6252a0b3a9f46c707ca7c803054f3eb178340f8100bce6d75b83a27915dd719b22e4a7994c035247ca84f0112a0c51005ba5d55b1e05532fe4f066ce53f7314f7104bb13ffa8f5cd08b3f96607665cadfbf55211f5085a3a51b370c0e7a7ed19b6fcbc6c81ff29f7ce890086b46596044c8f9032d658bc4ec3ad7aa2fd06a07be346a45ac8a1b152c01f3978df16dabf8f6af3b515a07e14cb93242f81cb150a1fbebbc6cbfa13dfad9aa5bc4d434ec3a5447e4e97d12512f9cd4ebe04267d7e132a6c7a829d739fca8c94181325151e1a48dc8ee5e2b4423a23f48da24be6acc436d285306836407c01a21bbecebec9a4011e734d6560aa1920beacfad435f2361ff2f33e90461fbc774f39779bd3eb898a482f87323c875b5c3c5a863ce1becb7afccd27058fa6a97ae36820463ec4cf01ce3eec90b3fe27c19f6b62dbc1bdf22c0424f233944842a0ae68d0799463c6623030c83893fc1f3085d2e9ce8da7ce5766370398842e68541762ac9fd47464e009f2ceb9e19a526fa524954c37367db21f10342155d226fb12f69b14e93cf6e8667aeb2ae86986ce38434834728699e4a266e3e5bcc90b8cd9f77143e7c110ca7dafdb2c34ca01d932ac202190c0f4816ddd6bf12bb129ac6a9d485cbc3cfc0cdd56b8a4a9278ac12280ddb49cf03d65b97cbfed12d2eb72637329cd73408fa46e53c4c1c2b36488bd25445323781a1615ebd3e3c7cfb0131e32030797ee747c74e0c2f7cbdba3d392946b6edf5f6db06c6bae7fad31e484660efc4a25cb3a8a1d8041136b37ab4b9d3c6444032cdce4926106a07f108f45a47a8f8e4b9b7073463db7a34c4e798336db93f1980ba2670828151ecd0626a4f6d222ef9d49578233e2f80186c06f5ca1d553cb22036cb23a3ed65170bc0f696ab40e02f826b8597477588893e192370455121d1f0bfbaa4fd059d76c62fa8ac0075c9a23d57bf76310f0e6016795500d7a4befb2d12fdb843f28f302034e588ff1e02318f69622b5d593092a907bc55f6279903e70761dc656ceb0095cc4f1a2cede473f93f5ed4ee99f8b2ed60b2d3debee53288fc3bf27aee7a4cbf30c1e7a6915916ddef005a4db5118433482a264e1e2e5e026d1a5cc5d55a3ced4c81c909411bd6bbd15b2c2e18910b51ab1986251e06a7e1fa96dc076619c14654fbe0c90ff64efa239b82a8d0c33a7786a38bc39ce91a5b7004a029c3cf98148a25c32e749b9f4efd7b591f6b381e530f45f8b24ffeb1d6a6b66e119b45b81ae8704d8022f7db99791c114e1cae2e110ba4d2cfe477dc34f308b3aca147b807d9034e9468b5c897d66b4f36b595853128f0f154381a997588b0eb1d3111690017171f612ebf3ebbc08100d764b1c442f314831aa4d65ac38c98fb9bc85923af9c035ac4e089b5d0c896b514af9a0447ff52f4c4c9c2c8138875139043d7bb519a0cff6db9201c0fe2609e6eefdb053dd3f76529f268ad81bdea9337affb31ac7cce466869924403c93007c690c6338729ae7dfa7f54d2094fd1e4ca6237b9cc0513c53f2ac2e2f55e3e85d2b27562c801e039b925127c660c901a1e8a4ba7ff3c2d064f3e3adb42cc12f3b97be1f634b9190691db8dd31a6e5523cdc86c086625bf6568be9e37c9cf2b83297e0031caba5151ef2b4af9a94f8c977ce2dee12651c88061cf9de5f87841edb8f175780c0d48de278fd4c04c70cfdae90b7dcff7008207cae5ee5db156a5b22fab1ad89f20d1a9fe9d8e4486a7ca60379855c339a853711f418e6190bb874a249ef236e204f91b9ed7e7c270015ee8a03384b9555af890d6787bff3ec0304a6209175eb31f58f2545c70849703662cb4db9e98f8722eead769d985940d53fb70dc7962a5f9fddb5753162fb6204d1719337109d485cd430998fb6f9d42bdcdaafd1ca7e804e12672cb7b33f1bdc37d650361a72c25ea20cbc79777a3e4d0899fd1193b8e40057fa7538d2cdb73947f2a37701227c75ca1193c56e7fe2641bc74803fe5d467ebcf9c02107ecb5b8d3084626c679d3f214a694f3c72d0af85ab28cfd2009bd73f01abc135bff2739a37caa197ce30e0ac62fe91dc3342ce3a9acfb041abf4d4b4534003d55ae08d2f2bd0a9d41cef2c6da13b3c412f78af5355b066d5d8fd24132b8c8a089f4c1e1947d28a7680f7b38f87f74bd06fabe2860968137cce1bf849ed4cc2e16afcc3344e28813d39668dabfb8af3015b75d9815cea483bdc56d96609ae31e7114640f9df35c300e0abb36c74957533ec58c08d1004f86e2785cfd92764aec46da5ffb46019135c7d0b78849e5b7af5db9436ee3fe2afb7be8c82b7e7a5d7eca67fe7d93b2c99377a5b688a760aeddfa961dd657623cc2bd3dedf7a206664b0c37203f0a03a80fccb086b02a0b729b6fe18a59a9fa556cc980076c66fc1cb907a0f4e0078c5ca73d4368ffb452596e4b25f7a4583a1c51be9a190add4872813fa7914d4c2c094f382416747e46e0d5076d4760fb7a1360835ecc7481d6a0cdacd03ddef5bf6736c9a6395fab4f0c2cf2b3b27e5e632a2bca3a91fbd15bbabaf978893abe5372afc25dabc6a79382be491c3177428f60b361b8dfa69d86ce257d3ac4a065d6d7e644cb00de51e76b512f0c65ded7c18c4556c08a698f34fd5da76f177307a809f05d8b42a3306c56f593ca13fce2cfb13cbeb185202cf7cd9b364be5a319c61b2c52a2c0f78f2f204dfd0086e966e005502910ba944dad0369e826c10d5e28a1a4d45c74e47856c678eead13c9e164c72e2caea21f7d1783b7f4dc2f53c49393d3f8e18ade25e15945ab7bd0fd395f94e05b943bbc28b8ef311a9fd6b20b96f39e88632143c8f7a55ff4cc9d3bfd96eb90d8cd8c85bc1848a18cfdea300ca5472f5b7cf8e59d4274f78e1d3f276cb1f2cd5fa67ff2fbe9f3ad2d4e4dd4c4de64573cace13135cedb46845179ed35fec5dfa87ceef771ac1ea0bd01ac7ebf6492c541db416c0e8783c65ec0ba78c6ea63a544e75c1ce73e90b1650ffdbee22fac8ef333f7ecdcfdd8c01fba65e85098cdff9b5e2a0d879b0944d3dd69b96e60ce01b7b758c49fdbe48ea811e0a2391ad7f981ad44ce3ebf5b682f8a7ec0f5ae8ec2905b9685ff7de9d4282e4745c8e10fbeacd3123ae82103adf12dd1c358733b50684baaba548fb9d8e153bea1d73c16704f1bc6b48c01c805160d0193798c7608cc55a17ed64158a048c98d6b54d9e3718ce0428845e7f462400016685208133355a1b488db924f8d35d1ed598e960c93439bf561faf11ee6be4409cbf4f4b784bfb9d8c40aeb4c5c00ef0ead795d1a177d6b557a7d76bc3bfbe32f6898dfe1b37a60b82c68d91a6d5b0285a110fa75f3337967e6cb5af9cbe13389be80254174802b6c194d5afabe43e356627acfc46cfaf69aa9ec8ab86d4ee23251419761eeb0b5fae54e0ceb0a3eade7b3e2b2fe830c82d679e2f7f0ecb6ab0af87bd0c6d73aa785230174eb72424815c159a656e63634a08bf4ff3d38aca7812bf865bbe5e914cdbd613011e9b57eee08cccff240afab4a96657d3813290fd99672f3842cbfa13dbe4c9335db0819d2364c2700bc850c6653114ca511ce8828db8dc53781767d9e544d1d3509049b2bd584dab95ef3d3b16e059e5f46a985716402ac809769f128ee4e175e555e3b1ca251c2f50d1c3399cce7022eb65aea617f81821dcab35274c9a07d1f8b73ec6bbc7c0c96922817f7b673e461b0eca5f1fbdeb76132ba37ecf344b01f1b210cbfb878b1ce6751fb448b2efe060b0f49db93295c20fd9787f267d765ef26cfd3c4569ac3f424d58e2b32f8ceae5df91ce1dd27afa96ceebb7acd67f5deb0297559a7f2cc2a2f60921282f6fd507781bcfba471ef35ebb7b974757a4aedefba7adbfb4757fd660c2c167a5ca78be28ed4131290909fbb4c6d136716a77f452a18cab10b5d9f84494aed43dbc1206b03e2c962058571a97b1fa96d0e9b021db51497e710aa05d84e241e54a403745a4b543a7dbf116fa83868398de3542b030109a991d6d262c5c8231aa053d5c00f7fe7fc82c194588e278e5f1eb968bebc5c782ec42d69bcc593c917e07f0f03c914d36ee611a108dd5016ec7adb796e7873c5c3ed1516215f4afcbdee42fcf9be9cc4b18817914627316cdb59b93f4de4df0c09168474872fe8f88a34743372e4c250fdc8bb762303c50a549d119307c7bfab81fccba5075a1526871600fddc510c72a12eac0bee4d6d4ac212284cbf5f06cfa31d4d6d6ae02c4bb31596b88d3b72c276fe73fc9ddc8f80c887457cb7721dab85a735e4a505f158a7352ef11d5fc80303ab150c22a1806d404c2106e31700633ece371302e7397777a2a03a4a7a1bdd19d3d77b10a0393e4a660778b33e69fa7cf27b7c6ef004b83296123b627dbbfe0715b826f183226e1ccb924cfee15f80aac22bbd039823042f839adc8c1e05363ef883e75045e69a1d5292b64e69468bb8499970379be3d1692cf6e2f7748d943c26a50b263e2c33c2ffcf67b0a806d5facc6fbda26301545bf00a1864509b1e821840435c655297cbbf0e573bd3ec5989af34c0eebc6fd51628b8fa88a87c4a38265f847bb754e07866d5836227ed0f87a9ec37d28423f46712a6ec9fd7bade251fe86327fdb78227d2a2ee2b2ca32426c20101618119e4ec9fe84287d32bc69e8014f0298d48134751e87cb363f4372862b448a051118d1efe079ec3492c25db61edefb7ff48fc73283f2d0abdcad00b2afb07b3ab29f69b961363d2ebb6e2108002fc2e54d8e1a58fd5fa0550a126b5ce35eb2b36f1bedf572cc6596156fa26622daf60c10257800661a464e9b6d6d7a240af74776f1f786680fd882bdc0316599b357d471e6c3ecc39dd02d910031885bdf07e17c0ea1ed05f54a1e1914c99f9259edc2a1f4c8fa911114b8c4fe00314e3bad402303bd5215c4f5fa7fed100aedb5985e07d0ed94793d8ff7c93e5fe06887d5179f8911150a25471731d329ebedc118e42c7add9ad12c6acb28aab1ee78d4765b8837c8043209535d38a11d15268b8ef4e1b734de1d7927f0a06a08560fc9943a4621897f79b7ed5df568cfeeaf0b0a131055aa83d3212ac4a0d448176299389acd00a55c3d8e68ac9f284901aea8a925800838df15572dc68c499dc082fed37a57d46ff3d60941616afd7adcd027073dcebefacd36744ebf1cf9b0501aa65bbb803a857f2182fcd38a98ecb70e8218b04b905abf12ca897e6fa3d28d20bd5c19f9ed5e3be93ed8341eff35893338bcea51cb7dabf31b8fecf180a2b32f889008e8db9a51481696c60eabe5c5745dbcd9a10cd045184e4c0595d316a10178ee8e5e0a44d7fe412b0f41e9cf9ed9d31c886ec089752822e281d2759f804459b021d26323add745c98c786844f3539b61971cc6d5cd7d107404e91e9e52b7fedb9f3f843d9c6991ce9057765c759d01cd65b6387d3a4abed90b5362280ba9e2b0e1065c50df61c94ec237226b3015871539e7b07f9b5ad6b74a51214a66ece4b4194088d1f374da4c7b0e663998d2620964a9c73f5e76796805bd1e3e1c9bd32860cf64072eb552b5d9ef725a0d08768f2670eca623fe5e651ae6c74dc85e3056064122eda7a1254093d30aa4103e611322480d11df4b19872b45478b7cbe75b659b6ddd4ea01ac559ac053c3f049f2083aee01c567ff80b7b0d281d587f2a3068bc12bdb7e29b78db4d9778901afa6c708d2edd8a1b1d32991da62064a8d705f459433413f3b7e0c395596b42da0b1189e8fd3408bd3c71eebb21590fad987abd30f0c2270182532b6f6d1407d41e4ecd1d46622620680ecfea41b7724b7d3fbd5ab694fdf3b7f406efbe3bebb48cdd7488799c8e36f6dacd15a891a20604aaabcd86459369835a5b99c1138c5ee94cbfafbacd14dc337778ef1534b5f228a8109b4c8a82d038f12057c34b02e5c59a50c9a62e347d888e15486f2fb0fbd1c96c85559def32b725e2b4957dea3c792836b5ccc35cd484cf96991a523b257b652e394e2059e979130b985fa78207f398d2081afc62fe53edd357bf169f2bb7d956ca55590ac32ad70c69855bf1dcd1dfbe10ee5421ed8d9e901c12facc313b0bf88a578bfe1c4cc4dce6fd686af6e95df561487e926afb7819128958838f8cee539ea0d29515c0b40f1d729b26defe8f0c1817c59b27912bfb5e4770047d40807a40e890226625768ebea7cdd2b5e73a621fef114615b13d9c0d8ab9145af629d35e152710082253829595e1d623e0933fc1c4d19b1e8788589e759f7a403bd6a5234e5570f6040482b06675b1521e68a2ebbd73e9d8d803d7e18c472c893b5602e3d81d53bb7100f8ad3517d736ffa3161e0ae4d13c54411822c73c9a68f2699d84832ba845840c69b31144a85ce94a77cf723b826e3b6f4ef588442257d56a489d756b1f220ee562458985e0b9d737622276a2e4563849522e5f20522812d9799e68325f916f26468adfe5e405f9deaa248fb7195ef0bf3d8e1b4162af673df1734b58c83aaf13789202f279c6e66fc37521a9ff8ce1de411595bb323ec44b0e56a4660ef23e287387d7cde542b94ddf94ece4cb5c2f064f400f009e6d9a86f2326fc663db505ee4fb4154e5a014f5905c8e1278490e07d285e02d443eacc58daccb629509bc01081e84e049ee997c68bcf560b38b3201a9a95db460aea671f581989238775e10842f41807fcaf2f86b7198219b312c355198e6158106f61985631e6800f964245265b6fdefa9c164edf6f2d4a87ad5af48489233d16b84cd0a24e418e93677ea9743cac56a60f180ed2fea7c4132d82460013b0e6c2a1f6467f63b52250c79c9d47411bb0c61996ea9d8334b390f000bf93e2cf7df57e080fa4084cc89b7745e19b8c758541cff272b60cb3987dc7e42600855ef37b9e4749b2641d9c362991600b76e3dd5b109f03a7ee7267f6d297b3ee4dfc76d8a06ea4b0f9e18f915583fa7a892a8ced65e937f0b330c45018ef8d2bcfd100c13e902edd0ec47b939b53387dcd2c8de071d6d33d16c8c36f0483aa44041d75e4ed47031ac2fb2398865872d153370d55b582c65f5db9ecfc98b95dc3c2e064a6a474c012928861b54b26a89e19c366f5e578eac2b4a784b0f0d76bda29b0e81ef1353ec6af38f107efdaa9dfe95209a2cb737096714599eb8b5de77266150815823ff3762de00670e68910fe5c50ccf16ba591e0c7224583e6c79e469956686dbb91969c2a8c701ec9addbcec125e3cda6f76d9fdaaab40a28c431dd1cb68e853e744b131f388b188aa7d796a25f9f434c9e05d828772328ec3a58e7a473ece894d58d385444f6c8bf975947529c5ca67734d40cc3388b5754cbe3e80a7210dc8253147a86553e71a5f51b7ad31d594942fac51d8b21cf305f2b2b80cc6a4f44a8d4e79dad3a05a4ebc30eca43af4c84b08782c1ee3d790fe32e0a4c79aeb655d9d1b6e6193769ae35f3a3e42319a4a4a2c7f75e6f4a54977b368fd41f8fa4cc5c2c35b4ae1955ac11f113f4692edd0943d2aecf2a72fdd3a35602b8c252e3ddd8960f908ee9ba1e4a68123d2aea87c17d3fd48ae9a274611c9190219d33467b424db7c2f0f5960e086f83bd970be448e3e53007e2e1f2064b4e2998713f2ae898bc18b4b08f658ca5022565c601a276194064dbd946a9d516fb9941e3f70420c978ffbaad2d7842358d2d3214e25ecc403a1722f6a353c23f0d76c77b54a77c56cb803a4b89bdd2d0476d6ba519d1fe04d3ce92d907a970d2bb80bff9315c826420e5221eb08a358b1f15d11ad6d17a637c2dd82ad90c1691a922e642e9eb0f9e80504c2287c285d3a6e34505cd3a6ebb9bf9e93d38ef1fbdce049e6bc2b5afb39c3ad094105e238e79820d6af6f4c18a395f755b68c5d49b5cc9fd27cd3ae2fd9c1d234af124684febe661263bdda229117b2a86f2776fa0ad003e8455c167a0df01599e67f9498503e230eb8cdcb63f3fdabcdfe74849bd7f8749b953926c8a6cd341be80d9eb685edf232872fe64c6f689e7628ad15698a6806b24694a6f4d2bd8feec748a31b78b2e1fe7c5594d5b57932a582e8e40fd48433b76edd16f93935319b8d27d9c2456988935c1e48c678239d5d285b5326172a16ea3d6d506cae6bd4257b796582aed38efa5dfac9906b5d41da97c1ab8f9e03fade037b8e5a224e5dbea799995ccd854e7ae8fed004f206b96a56c9d4ca1a0f4344a7c683d77ca3b8decace96662cc3f59f2be7e9cbda7396305f1bbf2a738bf3f5b5a36ee507eba9f50c8e5f83794c8090dcdd9ab69fa959acd7dd27062489dcf843a4db82b9f00770be12559c68241f926a2418509af62ab3c800e237862ee04bc84ca219cfe7696d216ea11f2abd330e8f04e068426bda5f48d5bfb03b1fbb5fcd4fb00bb7e920140a4b3e4049e3eb7091d1998f905816c008721b18e9aaf695bdafe0ec55fb5bb240911e46d6e660a38b836a5e1b09a3b0ce7e6dedc2f8f41f9e5d555808144600bfa08e07d9f5c5ee5a7f5fcae29d781d66c7d5a72b5ca1b2403da088fb56d3f794d3d64d3e34f6e51be4dd818ed91257f8da3fc96e6dbf4888acf4a0bf17dbe254050e1e14d539825a6684b477c50849c828444885940f32a66cce4891402f93db4ea33053f703fdeb45c02f0e95edb51a73e32ef6610b802877769b07d7e75436219580b502fd8a9ff0d92b179f10061df1e6e22aa24836db1b6887bc5b108ddddd2c2d79426662e68933985911175b028e78c527c07d47392a58c35a4bc365baaeaf12ae120eb7ccefada9be263cb04fe142d1374155a64df7d2cfa727ee79ff2c838a4f622cdf4a1a77fbe56c8c0613fb6282f33f0a65de1ad9d715a045ecf439c844ab60993a49ea851ae7ef809a08ca49e241f1c2446ea25380a4779d1e1ed38a6c2e428389567b4254b8104b33edf353af02650367022d7b6b1b831c85b11c453f641c2821859da27426f839a1cf34e98fec4969a2d402488c77dd7f53e613a81a773a6790179a9018a01bd88c970e7ed141648d0bf1d774e6c755353817f26632b107899db95fab4e3a19337e406c3349a96c383e7b943506919e1287e79965bb0447840d6cd01ea80f97598d67b405b631754fd02b0261a9be979219815467258ce59086351cd8100ea1951d7c3773b508f33759064d50b4e1ea092bdc4b9756ae8033b839ce42f6523010780ea9e71998ae089018edaf9e2634563eecbca445611b95177f8c202e0c22704338ae7ddbab50c07d5b29a85aca9f1d1210b488a8e7cdd46ee707ae9c77f04d2dff4cb7f9fff9ceb67d0e739d114367444d920053ea3e14a7ea6e28978d5411a38aca86d80fd1a0780b8d9f28bd046d1ae1cc4ed0217a017c62f5725593176964a4c0faf1d234131ffe4eaf49ea95f264174249d01fe90d6b40829901a65855cb8c80ba7594b88fbdb85057a742221877f763d49c5e183c8f87588c660ca9f2b47634e954a75da05d2c542a9a4c62f05dc4fb36f1a3b6125e9431bffc49e84d0e4094ebe804d662e4f53f382c6c0d358ffd058a0514cdf8a73c98eaa852b6af5554e9f7d446c5b714db99108cdadd26edfe69e0557ead97fbcf5f04902b4216a41fb1afd86083a324f2bfbb1fd1f9d9e6cb3f7410bbb543262bb7cb2f5d203896ac2f13e4f61406b4695e4c07a4dd4501bdbf99d898ddf602595e24ab06843acde01c6de0d13a426a64faaf25f5da63954477108ce208f726f1457fcd105836c5d222736228824d309fd1923dde88e6eaf9062fad78330f7defc6f709e8b2dc326994688eef2fd712145cd614a631d425ad44f15a46106d8a2b2010c9956c42809f00302cc49bb3643888067260faf45b9d8a68b9c44dc8d96c372adcf54476341c78d690b49d7c42143109fe240a940f612175876a55992de139b73f5df21fd446899442be5d23669c3f83171b1c5789b36f5f6e2714bca200be460768cd26c48c169a17ef6bdd3e1a721caad8560891618f9ae3261464c2b30c8fb4041b7d6ae0c27c016d35e6d6225b8332fe8dd10aecb7c89f6e804851b25757707ed8d8ae0bd167398578a6b5addf3244844ede9d491940fcbd4bef41f7d50c046efeea0d06be0fde52722e68d2eb49df909ca99c2010d4548fc17de6074c70ea0d3d70dfabff5ba85f5b7cbfc7c812ed8dadb0982fd1465272f77410aa2f82a31bbd06b3c306db906d07ebda85af576e243dc1c2732a8c3d254f37287a236930f12a57e2b7a6cd7fcfcc1e2c2bb984892265e3536eebcab76498ed8283626fe37352e087768641072652410336595487338d497833a68b879f322fca6499a4465c9fc019170e30ae5f7fd86b7cc55c6b173defd8dc33fdabdd2f80c3ef66f1ac3d7bac06d7533217398c72cfb65d4879c1559deef75f005d705b1949bd04a8d5e3698330ebac66f36990763ffe1e7caf27c0dd5ab8b0db4d367e1a736c8063f70e7cca06af9c192b625960e4695256c44a15fc81273285ea794a42225cd13d047e5b8db3484946a85c03bef149cf82aa1c92653b225f2d8276c4632a1f4a19540cf5e1f47ef116f834dcd032a3a76eb07b046d3e38ad4c32b74f99f4e60372bef5353a8aba8e907888815386ac18856e9e99a13164deaddd9e092b4ea8854372a06c4a397049a71d528a83405b1115cd5a632f454fe5ab75f3a4edc9036a33c2eae21f056452943c731d659b5f547975d82769796eaae811e71944d556977310ccab89e754b1b90ba8eaa499338e152af36cfb60ca9a472c9539e4deb64006f51180bc6d8463fa1fd21604eb883a41ce77b5e45fbc301cdf937ac5edaee11b7b9b137ecbf60cd91a7bdb4b8470a21bd40851b0d228df96e6f196a40035122d5eaf047548bab342c843916ac4f85e0db2ac3d0ce00520fdf5dfb404999a4c6a26df185f7092c0df55843c2391e9e63d57be3b4983c311b513efc9f0774cad6ea94c3ce896ea9c0f5b68b2571cffc0fd43233804f88b7a6a3b8b4d223114514a0e3c2d0e5a11356501fdd9b07f73ee7ed7c42f8ad1c6e8f6a601eaf5772c8ec7969790aa1f332829c389ad5985f1035c5d5c1f348403d307e59c52cfb81e3d8cab03ed882312b8b46c1c7a28c0fc693117be343b21ece3fd9aae6eee2c13d1a2b413ed4e7b46aeddc6f2d05cf86373a071bf6f0d60ca8c6ed9c1c2e1d7164e516416f7a652ddbf0c59ba172de44219551a0c19ddb64a1878713fdc77c0cefebae10fe111e49827ce4fdf2fe3abf12c346a85fe2440681ff780077ed0bddedd0d0cdd9c0e0447ea86c004d1ed39ff3ad0084dbd6019121a2219dac281a6470892f8fb11e9e986f65ccf63921f5021b6bf6583a6ab2b39dd5680f31adfa776337f2f5d9dba770d06fe981371ba9db835240c821068d6e58fa5789eb093b886aed5a7efd092f4364eafb54561258bad8fbdb295ccac2c70622448795a26918196788dd917387c5cff744f3cb7a0614f12fe83ab05a7ee5089fccccafd9943fbdaf059729c733a4226d4837977ac67c805442514ac21611e4ae30e59280490864d850bc513d29a84c9af36a1a0affab60bd5f83c5acf9b982cd21a2d25e1821346e637ad861910f48f590052faee467a61ab153529cbb0c4024d7a5c9c9cad1b66e6599ba782974efa7e102618686fabf38523ff7e5a4b2846bb7d96e71806c227184761c5a47ed08396ae30da3285528815766d62495079dc5f551161ab01c7ee11ed065bf4e1af381f267e93619b5937574ac9b23f8667817cbfa639fc2ddd907e408a9821978d1d338712eb35b9412d88704c075f527e9c5aca7ead48ed07a796f2ad675272206dc890a9c6c19410172c44d841d8374788d9087480b677fefe124715e6ac5148fef3db831138a9370331589026e676c40df7699c50f63ea73c2917dd4a17ea3958da4061dc67ba469ed45ee71293f24935350066eaa2f0669231dadca6bb34f55c9260d295d22856efa9e54d66b9bc6e9c6a59adde968a2fcbdb356174f8a717b1f530827a587563562605909f912f9071749eaa06be55a26b680f5eb933cbfd4250c8458ca911b967fa35fe4df2a564273cea2568952293e6d4235d48c35aa4a2af2eebdd5eca088df01dc8d620c509da395e94276e773d6a529dab1efe738799e2c60001d4c62db6df1a3da098294f467bf55edfb0ae52f588866ca64f4fd841c0fb5032f12a22a489e68cb7b733f758d05c7b6d542c1cd57624bc6ba45bca6cdadadc0f9cb7c0d70a2f3da531a3bc414d66056c944db3118f4bc6aa92dcb9b20a1b62c387e311b28e5c08891f11ea669202c5758d699ecc4aacffc3bfa16f847ae714cce2e59ca292fbf860022b9152d6ea6be1d728b0d8a447d68b8f707fc9a96702399becbdfe8051e3be6ced54c0f3ee4e7303ab2bd0b36703f95e6d247a647f88f46d21763296d0215eb652fa5cd9b2ee7eef8bd7e0b274b850a9513e7f121f675b41328a3740419b8bc8ff5bfda20ef74e29b625efdc493f7bf061dad0632c34c1750316d82a85a8446975fb4fc0aa7c65af3af2f61281a979efe4289500e7a1e748070b3da188a4d061cb0a34531a26f3688d0b1aef2482cfd707342943015cc8b37d95b962d98baa6d0c6f93c0c796d5253c22e70c2f112a92ed8ce2c1d859f53b1e58d1f1b7155fc42264580d4d2bfb9a203d649e29619c3238f13fe8a88d99b9776df9f7828c848c4df2351da1ce23c1739afd2bd87ba428a7bab24c924297b22d555836cbf26e84f39a6704a9a0e74caa88e953825f82d3daa7d2b1b585a0581d33c3b2cc4bc7632042a2f124d2347a6d9c65dbe70edec32d0fb89a5614e3432f9975a827d12bf04f6dd03b6c13e5bebf425c267ef4951d6f03408bddcb9b414dc3a72cce7111e6188fe428e173ad33b8b1259319f2c0fb3a787f3bc215fb5c7d026e58c39597fb4dde34be6d5dc2ab0a03fef864a296fd037ac6bbdc4f96be5bf5343d2c93e9a95e9570c83007526b92d9dce6cd1adf90b0a6001d9759d785a61eda6ac854476d22faf99809ae44afe1e2a0b3eacf5ae979240461f09af6cd401d67b20682b6d34b50a38a9c99efb285b2a87bb9150b1300c9f324a8aca51f301437190367f3287684152b62749afbcab725c5ad03852c10c619fc67dca9a3ebc9be5e2d9d9e65694ad0095c664c422ba779f72046f1ca9ee5baa655973feebd57e493f5c3bbb8faa2e6e6702dba76a1b0cc0f402a3b7af3d12d5d97b4dc8ac6278964c9b0da74c050cb57d21535b95c0f1c7dbcf870a5d399b5969ee612d6e15e9fe73faf6f6e40243b04d145810ce4fbdf9592303261d4ba546def6adc69e4934b7882088ca40b0a5d89d1c4bb01b973dffb9d2fe34f076a4b581b69c16ed7694c2ca79a590efd03a4f5ad28c9982013e28a28166f75de6d577ee6eb64eec591dd7be11cefeaacfa6548bd373438b02f1861df56b53ace4ad7061332fab5e351a020b4973cc19bad2f20d99c33a55a120b78aa911b440c74ff734181b493f941129e5c2ea915a151648373e9b426cdce1a82c70e6c763e9cbb0bff273778f1f343081f5f5c528869a656470244bc387b1c8effc53ed31228e08504411e418e2339a6c87f507dd947e05e6612583f3ad325f81428541cf024d033a7e27916f76388f60a9b87ef8d5c3330d71ab54390e50fc88b5c735dd446e58e56787205c8327dc144bb11a793ea46b9f91efbfdeef12ba7aa16db0fe97c5b63f2a9c93b7e02f7c50fe8e6ef311afb180ed0774814baa439f9565bb661facc0089c5a07cf53cc0c4dc76a4e03396ace2f3efa70242654ec6bc765d155e6c9255c6107a37e100b5d03af4efe62824c3934c47f1d2cb87b245bb7577aa8e176d205637fa95a4ec61a6f3ebcb8216113b33431fcfd40e16e654bf4ba2445be5015ad5eba14b00f8ef587141458f11e415dd635acdadf48b5a7090a33b551045d0477b8cdf15aaabdcf69a1f886845d7636d1d6e71dddeb2c12e6d5910a8b6ef328dbf1b5d3601405de07897db7354829913edc7499c67321a27fb39ae57e63f7900da25624d441d63b7f1873e51820a2bcaa3b01927d8c48708c6f63dd91e49a540c7aaa12d1cf1e065caed65d370a721379e3f8d29acb872fdcb5fd6e7efcae4997d643c6af47ac453c7a89280ce7f5818befb2f41f375e14433437fd995b91b8f0a826bdeac10d3580da30b3e18f7714cff98f0a5b95975eee58a10db17ca8aa17273c62fd2f58e5c8c0b17bd020ce5192db05a235b82799f72d1d1e96bd017fdca883d72537bacd5a2cb585dbc0fa03a3a4b1319dc901f98b4384c2d28d674ae60668b78b10802b32727cc45c91ed8ee6ade4605d585c8ec9fc602ec8b1839cf852f40a46010adda5bf046e33fad64867fa10f6d7b05708981b67bcdc08daf5bf8f0e2cbc17da714329e16e2128f7a92013ac91320bfa2b9f3550fe79be58b88484c56ba7b24d5fad42af992d9f17ce951c4577168c10199fbcd9a5b793d230bd7e3414d459249dfba01255bed38d1ff1ba93b36cd1ce25e9ddc707531b7d96ccd489fdd56013b3e00b6ca3c8c39d75fb5eae172cf101b9842c994df730b4fdf8144883b69a26290e3cf9fc1de43ef83bf97fa6fb9fc677296a4bbbf3783f78baa81a825df2cc8d08e8775058d3ea22ef76ab32c2643fb575f8ea43b763130b24d91d963f58b673746914a5dee29867c4496ff80655bb14286335494d5422f59d97c66a7621371e566401f73407e9236ab0550ebd86acf90604c685b75f4e26c869290e906ba64e8b9c242c876be868abbafed8110b28c646b535f36a8f76bc59f0b0c2d24eed15fe68cf279b489cd74a1e4dd6be8a20ba2eb9707ae7eff5fbea80be16239349a85f8dc67ca8ef6e87f27b7ed42dcf45a668979d4dd8f00463e67be2a528223233012993cb831bf282d8a72533a3f6a0dcfdf2ed70a03ddfc3e41596c9b57db3648cae3061efe3271c6e8b2b59b97639eed5912ba348a319a609e783c6a0220c6b13d10816673a2d349ae363d2a5951933d01888c6de271541d1fbcd603a1a074463ded08a3e12aab06e37bce76cad883a1fc36d7c4b12b8cf07753a8dcb710a51dfa092c7e210d864e2e0150a996dd8b3e1601dd6a6574b14d84f3d675d8132ee65ba767da6cd0d71cee97e01c57722f1759c9648339fd8076ef18c6144745ca0fddb889b2e4db5fe2e69a5febc5673cedb714ff7c2030aa9aab1fb736e27aa0ccc26e7298dc0c4f5a2b7015354562a4c3565e55f2d3d5079c9e666ad78629fe11857e683c2d3785548e56f295cb4a3d07dac0798e93643bef275802210476634f3684d062a7184dbdedc80cc41684c758d7ed21469bc251bd14f51975894869639c1b0e93789ba8906c176438fc14f228fb734d312ba999ea1995acf5ddadaa9be509d01ecaf39beedee29da54fa3213b1f620ca87eb8459b5f7fa4f3b1e51b38a009191b29a760d4637bf72e5918040f8fc51e6887587958a44a812c45d71ba5ea7e0731a446b2d0bcc4b6e9ebc0beb3dcd8310b33c02f286f1b495fa6e730e6e6574693a863c4c66581fe48b73281370bafdc17c199c1b27e89dd235359d64b247aa26345d8896b16495bffb0f6543a1abc48d6e652acead21616a4099b03ce6b71791948af4fe68323dbd2d1aaeea260bba136b9bb01c56016feb877d68329067c10ca83fb052470b9dc2dd1aecff6398851323b9075922b89be20a3f35e0e8225a2229a800556452ff9c14d54bee7c39a4aa9a963a6870ba69c7b4af70bdea1b657440c16c4a9557e5ca27b91468f1024bb1bb2b3da18ad6b0425ec3bd635f89aad75563d22479a257376ef75378a900e7365813c1a6c0e6bd6c1062e04fbf75f626fe8c86931ef923e2dc0175ebd9b7260b17f9f1d2906965300bb205b6e256a5d47fb3cb44ffabcc99c70de2a33cabab8721056cb26dbee0bc3e52dbd59b67a7f50823f1a18aa29e8164d50379caadeab0d8c7ee99eb0d5c1397e2549628967f9f7223d008243a95cbaa628427744ff93990cf9b47d0e8ac8f732c32c50f07a062faeeaaad7fdf37254b9b4519d28e5efbf405697ed45e2456b00a8e91ad7669d81cd447d1e453f01142d1456b4754737c73d033dcb0d392f44afdfc3ed945c96358bc9a35a2cceea4913cdb4e9b4f98d53724d9ca37e87d0d2a18280ee814f950061bda9e48c1e91313862940ca1bdb6174ad4f257e5530f30c807db7560d4bc3fc67fcd70510ca1ba676af798c68c5019b56c93593f5e7f0775fee0b9aa17d0e621c0f4d2a484b05ef16e631948187957749258e89c3e6deb1e8a255f930c8e1bdae97f2900ddcd680b5efdb76e789fdebb223c6af65b1aa8fa89f2fdbe9bc64c872ec9967228c59ad9fc4d5b451158e37a9e95a6a904fc9d215d1439f9f6020b42ac5927abb157f7b8b3a7dbcaf4fe1138fc5bd12f4a0f0ee742247caa16a0cc0291040a2bc37077baf0061429150098962ea242f829a40bff26d51e91a41f251f9e7566315bd41bdbcf630072c8486a01161ebe25aa453c361482f038155c59802c31de9ac9be01fe0f91d9db3a4d975fc95c9f552159d2e1500e7353cd171ef853d763c45b27361474215f9a6b7e0cb164f32358093fb6ff7f93f73b81196d507e236cd4c28a822b4473c29f118b2d29d6ec4ac9bf34005bc5eede588aa3f53d9bb52173b482366db2e1544c14fc9f4d807d9e4845a31667191c13e23fc9962bea8bf7a60ffd11929b727b38dcdbb7be8dd5fc3bf87b5674040ad5a50a1770b5dc3bc2659561964602b3f6bb25882ef1f3cf0918f56d45597663723bcc9d859598fbeefb89005b766e01197881b4845ac9b56a52cab3964de61bf18af6b04d5a615f196e4e2e1c1617fa58213cd26bc4024f3d19e1f20b02d0beed5e717460997dd3bdfe9da6f3ec3ce0b39282da5a7219b3b9f5d88f65792d85d012c0fe6d89a6ca392403e46d4dcfdefbd65a827e2da095a7b7499b705a96edd974846f66fbebe3d6027c994d798f9dfee037d051558df41eb4796fecbe26eb8ea5c9a61750365fa068f291eebedb5d0d7186b74a2d79512ac13f5a1d45666aa18918b0292affaff2ccf9a4226d7d2107156736cb14a20880d8af448872fe831010ed9e4b67dfb7740ae90d86ee52070d3fdcb7fd293179eb24ff3a5d625b707f40bd4ec8e5bd241987b9d1a3b3bcb5f9b3b83938af52b0fbe078e2ace98c70acba61cde53627eae9935a05727db9ebfeef84c43b7b511e614041b35f66c335682df058c2d6d67ec31c84ea4c2557e69712de4b1b1caea57ca50551e67de0de7e1ca27f59a0bed53d91b756f3a0569868fe3f6603b7b5ef5f0bd548c469faff081da7d7a6e2f8bc98bd0faf43c2e8b07f04f628976c9bea0af839153726890e1b187ad98caaf8d087ff4436ab19bfcd009be1dbf43e072aedeac0429e12b4ef0c8bac8655f9f883024ec23ea7610c71c3cab5a1bf2a4bf08231cdedc44f03bd7b57d22dd74d96a6ff26cda7e3345a337880e81c47cc627b3bb0199672bca31f5d2319ab941d89401d940c3ccc58d59ab43ee05addae7936d9c2c15cf3be4cd4fa2ab8e08beaaec9f3fd6c8ce422dae0e9ba7d464b32d3d85cf40ed4bdb930401c02ef1acdd2635863a8fb393a1a87ab9c8f8d7bcc1dacc480262a2403370366ad77bbf7787df5f23d3175613d81e5c766aa872bf62c13b5ef6d830f1a4a024d6e97048165529929d92c944ab56f53e69d13b6a0556aef4bfda6e695142574c4382ad1239c1ef6550cca169e7cbb90735639d66b344f86cb688f47f60d5d87641f9bf0a4de10783de7018e697dccd784587c82667aae41dfbbd52ef56b3e1a8df46b926a608f9a4310fa2c24cf14102c18889adbc407f79c76d762161512bc9def4a6283fa519fcc1262779b611e4932d8c2d83c76b8a22c702d9ba9243749a12b8a99b079f1426f7912aff682cc71fdc16ad81744c8f5d1612b55079c5455f9bf3da393b4e7743eb0f2aa5c2eacc401eb6d668c89e9bdf4aeb9960457a7b37f56e1254c382db86c3e3b75014bdcaf759e2b08dc4d8b2f7021cd9d6375243b77d191bcbfe178346959cee71c66f6d48c5c5eeaf0ec52481c8344547f92c825252a1459e90c304dc98019d8816f3ff3f0fb46ba15c34720e5e51c33f11f834477326898d59d26398e50388e4d27b6f55e1adf64f0394612efd4bf476064e535f8b6e9f2009f14b9e63d1e6bb071c9fc59b32c1f7620eb47138390ed4b905f01cfa85d78af3c6669e8758a7c6d61065f295a89251994c3bcfc115f77a13a9114b67d060ad70bf36878982bb8108b0f697cef0863d46660de38325eb88292e5a83ce6c9617bef388c9e7689ac957156d99eca60cf58dce159b5240501691e200e9ec5284311f905ae1a2342c40ee092cbe316d2388f316fc213fa23255fc7f397994cd86ab758a58c591609423207066accd47456d9885157ff044ea9127b31a9e9321e3388f65ffa37ffbffb7f2162a031ceaf2e24d1de0d6e69d732754d0d739cc1ad513e8a8e75f4c1a085d952ad96a4396999c3ed06d5948c1b7cc711d86bb436bdf7851fb8b6d4084aa8a1fac3d25a79d8ce8ad474975a5faf1628d0229a26e2b283c36d6d3b5428375642b6605663f3a433552128dabccb33834bcfa77222960d0b6cc999b399d56748b0570bb2eb34cf8c95bbabe318d2927ac9f97b0077c0a4481175a101152706cb869c9c63f41c214b22531cf332079d67d440431b12c7e6b2bf42c1529df9eba3f1118adc57617ea7a54bc27a8043aaa96bffc6a488e5b9efc658d8e19cb9cc7181058143cc5ba0dfe19b8ab6344beb5149e669f3408e5dcc0c201342beb7419b2973fb88434422edeec1ae0de50ee69d26a290990309abfb1e4187c02dbbcfe6cd967c5ab1b7d4e5928449256e876ff70f3cdb38cbdcab0df49431165c0d1f32ab1fb4dfecc5a0f3a24a4651fb609c64130b872a537d8fd12eca1c752108f91a08c903769afd531f550133623ea07b958dfcfc6706e18520cd71a360266d6a9744fc747a4ee1e7ac3ef279bb069bc6ecdfac577da93c91041bb4cd6cf365a1e6ce00dc46f669244b535b7da0d10a2c3c076da3d3086a98b484c9f1bb1e3678bf4746beaa2b418d5d4b390ead866ad9dc4253a97d2b97ffd80568bc8ecf89d49f7856af969f4ee32acb3ddc7337c68aa5749963bebc52b047b996c331bb777971c87947c40e103ec89b86b9a9c7a64bf20ec1d25acdbc70f6487c18e55662e5884b9b960ed3f5aeaad4a4ab2ebddc9b9f79b3b9a273dcaa8271322a18b07031dfcc59253e9aa20264d43dc33982be18e499f153b55cfa7b0d6fadf33182f8f26cebf4cc13ccea25b0b98498a4eefa0f40d2bd02cdb51e5d651a71ab4bc0a804acb3afd0ed6c2ce52ba71fe6cb5390f01ea9815387d7fa3ae0044d22b71bdcc53d0ecedff76aa5bdee2e55d4f0e3de2b45ed92056e778fa42aab4e70307b1a2d7c6a816c4db48b996482b8842c51c78710371344aaae494bc39db81cc4529853815765d0301e706c2ab55b4b82845b78d6a0c0881f57ef3989a4cc69cd23193d324d08d514d20cca9d47c76a68f67906b2835edc762e88a2a5800949393a3488d534f5f6e8feb85a37a97afc1f304a933b1dba0d5ef199e4ed9d0ec8a9f4f3b66dedf7fde2b4ab47abdd0bdfcc25dd5a05d46fcb6bf6bbdbd52f07cfa8ec084252c4a93819bb0d2160b5f35a70adfc6b4964e04272293f316162283644c431f8b7b089de03cb6ef455c0f913280d0727ef1e621072c432a10ccbef26daa366cb36848691949b1dd23d1169aab9ce7d83302d62a33ee6b4e162417f9ceda2a554eded61d377372c004951518a055c3771f7e10106224cff514e2813f1e1ddd260539af20da95063dfb1aa41407ffce5b55e6b2c7468eed56b61352911bbaffdfa6477bcf8758f8bae0dc64e7f7082d03383bc85801fc5f85e6116a5694a399f9416c670848a10f1a9e574041bf4dbd20ecc130498ed788badf8d9e833d8714e6a57ba1fa4dc9b14389ecaa4c9127594d77c977c1add831aa0e807b88ab5eb0da920c37291d39693a41949c775d48f9893a4c3d802c047036f14ea5776b27cd8d2fc37770e771c3318638f1a482ff5a0be39ac20b11c5f9af82743a277d632f77a38d4d35b41bbc2e3e29086a1503a081a93d2b7ba91471bae941c9ec0609f2b1ff5978e6854ddffb5e790819346b7b8c717d081c561b06d4d35966694da6cc3fdf3534ea1a9e987e696b7d2e8fdba28f3fd80c8d5c834e5aac3ea21504d6a08aee630560694a57eb931d966fb76ceee7c18e24234e7d82d6e0679930d3ab0419bfb0bc4b21790f28ac499bb632f4af1cdd750a2934e2a391bebc0ea4683996cafd5ac719e7a8d520c1e6205d23ef6c8b459d1f620d15415655bda59c9d836b508b8fe58086108374dcd724e38348a2da3489486f8cdd8dcd77b5b2d58d97d20040d279a68444b17225a35ce6ad4d4159b7fe07018c119a9bd17b186a1a83a5cae174d2c96d0ad0e17612395dd4ddf0f5c0c06db0e7ebee4f676c48a7a8518fa4db4ce2695d8572a01239e70f4cf6548b557163c3cc2ce745d088d66f69d6e9b1c4b5bd039c0cdc7b433d729959deb22a063b36280b759069da7864ca09e6da1355d1ffe9e945e53b7594f240ea6590363c3b0df46f86a4f96389279fee49d26df76ee67a4b0f0544624394196d2533fb54b17384007ebafa781e145a096154721ab9b5b73dc0aa63576f29f94a95e0a43b8796836b13429a6d53bad0a57009126eaad450640e3ce30c50d956d57d84eb73a276027bf2ca830e6a72100c31c660fba8ca99dcd61c1334ceb6690104cde043b364e6b33d3178da3a25985611d449f65a39fa43f2f5a9a1c3485baf403bfdfc2dc1d5d5b5499ee3f71b1dc48fbac1aa3b4adc7a27544650a91de147f6344a3a0ad309a39d0bc8b73304217a177684e37fe2fd0532e27e004fbe2dc42c5d053121821d46ca88b51a1b2a72f537038a3b3e991a6bb3dd7c04f7c3da758a2d7713bdc3e828342079cb60810a31db338764b5d33cbae61aa89373c5cfa73d43d58776a19c04f93b669afcae8a32ea1e09b2a164987f61c689ba623420cb97024ca0803a6a0970d4003e766d158ace1c2bf0367de495e4dbb91721ad3f031e6342f3c1db1caa7861779a2e5baa67efa3353580bb6ad177146232861c0f7fc1a249b75eb3318f020c46db91c810e90aa789d28b7a852ca246e96de0e421e8c421066608802e63eafc2b198e71fe93f50f031c766a9b66a24cc1dbcec647569d928237d3965eaac9d870706e25bb3c3ff5e2428bf4ef8840c9e2f8fc12e8b9e7a239d6c6110d2e30816e61f124fb81e634dfe9f79700efc93a6818be4c10a5a59b8e6d539c21070112a33f653c15701be6bb5cd68bdf0edb2d859ea10f2578c3ea254c812cc5269c03672ac05aad73d2e3feb9f189a0e743242724fc7d35ce3903fe01a8311456cabe9a27ec9b38022845ec44b7b99972bc4f9add85ce3f59ca400ff834d0c28ce18429fdbf3f6a03a5ecbc4f1b943c4c42bd4e7675f759115d9719ae0b26dcdfe2ae2e28c3062841a897feb042c29e8641aeca306be71e89b4f00f20cc9477300352df724fa268d6bfb3a41e8f08991b0aec2f5c7d966b9dcc8c444546b3d28f2041a126465c0834645916a8e0c713299f117a6df2709d637d25e098ed868dc84847204a58e8b33eb1d0e5575d6c59b5936940c4f47e3cf052a18e5689d25a090ce57a827dba6f043f21989df1ed26ffced1b8540e40ef1b1ffed0f7879483ae83d83588fcf2a9696cafcf0d42328eaae75110e4591132c5dd9e205013a801b1268bdc5faa638c852f1850a820af34a3871eb3e52c6a311fe9455050c471673e42f047fea41639072ca6bb5643b312389b6ded0704bfb9dd3374b837f3efa5084c6f5f6cff1934632f458fb365f1256f3a8202422ef059bd9702040451f9ead188a3a8a5164ed2652312e64bc59f072e20d7420532d0852141d3fd548c79f58986f348a226e094013cec3d3c06e08515ec74ab6b49ec6f788ae4aaacefd5b38455ef4555d074f6c21b6fd2455c15d3f45b3685b954a2a42edc9e3e3ee61ba3836eaf2d32aa7e02b93da262cb935edfbdb93081809b9f0216a56b909ddd65ecfc75b89c080e8ab59709d476ac105ab6a79afce67d46a98a58e688f5e1ae6f4c6d826aa70f5297e4a4721af0ae10bdb233efaf50ebb3db4d3340430fc4d09b7c652fc36a708873a65638bffcb2556e67c29d79d0254b6a67f9ed01863f3df61aa5cf6590e971557fee6417355ff8e6e60f93acabb8b7d8233bbc864e39a43c30c5d97ca96fcbea674a332f4f4ddd4797be15177d59d901e7aeb7c3376b172c71a0b82135bc2f6c79af44c52c0793c11048c9eadf743ab595dcd429b2f017cf07f048f5643612cd1d46ef85d3bf5b3fa7daac904aeac36874b2ab9539f676ff6863ef906cfe715e1e06a06443de6a4b18401f670d010891aec2fc6102d9e37f9f595c2c55ad2085f2eeed5b4d193fe646fcb31784f0880a48b1f951b2575d5c69afe233fa3b5eda41bbba5428c923e1884d5af05c845f5aaf22fd6940f2730b65bc883402afd87510fb389daacec2d6f779438ea7599af985638f717b6d747bbb74845a1502bfb675ff38490534191fe51609eee2f93ab92ff9313e5aa900f1b6d45e7303a1a956a637ec965c5693295c35ce645a512d5b84a16f851869dc7fa4f23a486be4a829331ecf3cb5dcb3dddd31c2aa05e9f145513ced87b653eb13286473b6e609165bbf81125c091b5233d1f52e3d4d3cc12b52ba3e94ef3eaf22cef25bc78f5acb2ee920bc747793aed6e5f5a1df1136d013ac166498fa37c8e73693fecc22f588f5cb5b0e33c117390311d2e3ccdd88cbd7ae76758b9cb098c24b7644d3cbf29414b050e52174bb7de5d6608c63194f80523cdc1ba6a11eece7d35cfb825153ab6ee4c733dc332c06cf4cb474d62d31faafce7b6f63df1775a39315ea2e27e07b2f2d9f363f65a787321f2aff6b080aba23bbe6dcd4ab94ea0e88121cfb841c443dec54cc79e5ff5244f56bb117e6d772ef7072477e95b4bf6b706791d25c17554dcb3a5a76f1a8d2355b331ec45f78eda6b8edd87e9d5b20eb58fac77e40da93869639010c0cbe5da66be6e40b515efa53d91a0db6abbc2d5d1e1402374a4cfb9e464031101500552f8da485673114bbee20b19ee390afdc2ffcf096677b8acc68b8223cd7808d19d4474b6e4186d9347b26b90de259e1d9b3e7d9926cbb3820ef71d6048d5fe2e7a996af0ffceaa56c3689e7023f7e14d7f64aabc93ff5b2dec83c4b1b05fde47db7d3b9fa008f7eee689f8d30b23f060f5938e0c5c5566dafbb96dd6c7c25bb445180d0c73be4eba4ed1686a791a05a71fdb799c74d14a6b7f73f541a1774d30607bc14a67eb730579ebe023079841e1dea3c739c9c284c8235dba781b43b6150362e89c3b33b88c1817885fa3239dbae50b153f957dcd65234bc97b4c9bc96ce8f646d3c297c71b43741c567a249d208c782ae322c4c0916c253741d8036a339feb37d3dc14771d91096580162f4ea56eae5dc47d6a9fa5e347b71000d7c63fe6f1716a94cd23ba1ab432e2277de0629f6050e1f89217557bdf604acc9ed5c88be3cbe355f9a778f2aa09af9aa8cddf0a631dbd4f6d943f425cb65b9e57dbb2aa430430e7e22ac2237e654b09977d73dec83db12f78930e05677ecab68580b3dfe22dbcfab8ea7f96359c913862b15a4f1b5aa6ac97731e53e1383211f30dc863eca898831658023c9f2d5a451784ff1829cdd00b9b86e7cb391012b54a5534bcc3426090ff2716ddec1e5b5a6cdca152b35834fe22feee4cf84dab3814d65338deffe968af1d2731bba6ca730b5a4fd27ee6b44f667f2a6b958d6518e54a5d3e64921c7f1ca36f07c9e77f733551aeb5a344fa42e746628e79118a099fa5e6da4989e605eba2b390becbccdf00b2ac782fa66998c663e7d672501390456f73f4e20f0633c220e23b78d990cfb20b6935feec45e6c5f80b4b9be85df64205a8ad0f183abcf4bb56783274a2a481334204550bd9fa6af6328939c1ba32891252f503848e6b6b52a36b5df4bd1227a3a61adaa9fc04469fe274ddcb6e849aa471fd9465039a73a6bd01ef86de19f6d04d021bf21e906e87157096fa8e4dff83a0bc2c7f65df07e8131bf71643060490238f38135a548fdcaee667ab1d64c6215f6292c624bf8d8673c5ca870f995c33d0be03c36d4e610dbef54498a4dcd78c1bcd991e2f5049f63eb57620bcea548a07aad6d7e3d0dd761a45f15b1b6e7f57882017bf2292bbfe442cb0cd015210e20ecea1eecf0b76cd9a2b1624bd5c4c45c3cb3decca3f853f80e3cb22a58b525e186ee9bd97d058d48a5deb40b11e57a4038eeda0022be89457b9be8ff7af69b3afe68b050060b693e2506bb7095c4f212a97157f49f4916d56715c861e0689b880373f3133c1d3fd4e1a205092fb5d0d12d4861578b1fcdd49a04ec8aff6e7b27cf7366b745e70d3fa2c91d0b76fefb2aea2cf756614d3dccefe2a4a59cdd7284b62b3e906f2b57460f2ba2e303ef0866358edc1fe5b2d1d863171e70f0650983175ac51ca390ad7895a21dec76634d9533b54dd76bd78c8e3c89b7fec93f8eb88cb8e01c1a051bb20537c3f9e605d3470dce9bac87f8c3aa17b3fd51744557204fa0d22f6fcb7098085bff479d098930442dc1c1e6af9f584def72e07cbe58f0b2c4daa67bd29511c521e3fdd710fd06c7ee05759dacfa785fdde2dba3c3008a14de44879affb9a1848f49981579ae0ab3f1e08100f2b4904a6ef0ea85deb8af1884e5305639ce9f025b3c8e76ab2e1d1fdb7707b995a8fa42459abcf7005429214795614cd39d238e5b8a6adf8c787563f158873f41a6648034c2891b519772640007b4cda0aa35db09be2977778444a0e596ec8b743e897660abb040bc58e457cad841cd8f8e4670b1ab46313df400bfb4a0c4d59270dac64b807e24bf31fee03531381d0138dde302fd5b8a8f51b5126c31ac4dbf89d5d88171f88a3f1f463404c7fe503409734478b0183641114ac5c3a1815aa1d9ad9a7c4f092baf7cd9d5a4193a20b82c33335cf5ab66b92e82a27aceefa6bdfc9255aebe37e8d466dcae08daa673e9ed8035adb0a7f497e494df1d869aa02cf62f856231dfbf2fe409f097d7026de9042f3dcd9f08650d5b834a67ad35079508a69f42e62b67fe37e54f99835857a6f46d28185f322bf3d0a878edb0473bf3a7a390e9e171a2fd1a4e03c2b010e06277eeb4316383aad0313026790edcae052b9183264be86751174fabc23b3c74d3e23e71803b21f37c1c28d08aa780c71611b07f6f1faa9cb4e868b96593949c5d042e488d8bcdef5b45b469519d9c08e3fa0dd2448d662e15fe11b1557e254951608cde74463b45e266e787bd90638c3256917a678ced7e9bcc4dfca6e6a4a466c8b5b7b8bb1ed03a758e1e3e930c8de346be4fc22f2f15dc080b06bcdfee2f71fe8564c9929111ecb27cf16b2d2cd549fb9b8435bbeb4675983c422d0f45ec5b17d5d416e30620d60382ca2862a801ae0bbd23b7047ad0fc42fd2c9d0a73973cbe4b4c8c4667df3eff2e9ff9d251af1348b0c880c1451d212e0641c4806c605bfde0e9bd2a1e55bc6971192583fc44026fc1ec2aeb7aa67e51cd98fdace4f2d97f98c562a6043f9585c83fc08c877f7c0f825b7b5f4f981bbcce8d61346e978f91d2af65906f303df408f7c52e816bbc13e621bea0b45d0397c416103e4050664ff38dbe2e235bb38dc3e12a9ae643d8ccb90858d4c2fcaf8b2b3d57abaa0039ffa2e7409f75abd6db57cf227ab3f76b2bb74d95162792236e5363a5ce3dc0c8cbc072791cc747eb75f0de0ac8011f895da781ef2b504c26cc7d3d8b7d16f26245174f0487633fb642eaec393f74d0540cc65d105e66b2e7adc796966e3aebc746e97b375604fca73970b7d56fc74e4d9e03647d376be4450c1f6a1d0f3c5dea652b728b1d96b0ead1bc6ef456a568ec3cb1d8782f764d79cfe091a8dca5063d3979b3f0818040bf3391c31f4e025d1ccc0d00302aa6de68feb92695686cf685191e6757e2049186f5474f49bf54e8143d57a85aaaf221f71e54c08f1cf990eb6f8adf7f1754dc8d04f095444abe921dc68f184e3933018d5adecf094adde248c3cb5e05d5a0f711a7a16c48ec0f292ebc922cdbaa1e9c47e7fa1ca87f91222f6b1edf75af74a0ad0c44245f22a3dd2f54ea0c1cd76cdc74d9485857be0613cdd9667f65c4c6f360e72603aee78e55861a2d99bd458c34f9c0f450d42976b9a7118128e5ed85c96fb8a89b694dea9d4606ede95aba02d708225b23dccebb983f57f04fc145920b5f96ebe1ee054bf5675096259d3d61ebb7b85098abc34e5d56bb14e67c1927d917abfd46f79ec346d39745e582c5a60cdf999e27f33147ac5d4c894187826f39c5bd3cbc19bca7bda88197552e12988fd58aafb4b7a172b5f4d9af75afb96c0d0444898d4188b86b413094cd19ea6b02ddf9024b538e3a135e47938bd59f6570edbddf192e98bf6e14569a7fbf53ca8f2f051201392809122e2bc1a973b652ed29222b36a2a845236ba4e24df36028a3bd8405e89fe1281c7090e923d8494c2922ab5d01cefadf7785fb986b9358d8a502e0e32fa7587558971a947d5e25da8cb28a980720e6e5f8751235d62f529ba7dfc3af27ae11f6a606cc89f0ba7faca8399935032d1cd062cc37f05011c5cedcb6d6d7e971beef296b0c19a109e55a1c35e6bf29fec29f555684b89ff0775e9608d6e53dd43de5ee8b085f96a3ef281dc151b457770501467d379d57b63fb88d1957f47c4974b938dda316a4ba483970618ac45d8507bf9a4f9f0a69c2d8b865354a221d61474d7e81035f2a19eb15bb102ee673dd2492a15f1ff57a02c089527f567b814a5021390a17a4752285f817d14b557da718fa53ca0e4e7cd45d9af6a97ab15081ea017626726e2470d06e4b8f193036f045375aab7b978155c8818bc1e86e2cc7beb0272a1dd5b72f897143462eb65dc0aa5562e61b8f0c1776b93759d6b1a281deb2248bd58518e8569575339b2f0b89dda50b00e8d9eda6b86064c6c278f6e930df3d25e1035d6b55d06a9f8b0c04eb6802f78f99dd15bce8878095e3221a183604638ef982d56921b24f9338e7a0f7568158f03cfe970c253d50198b0e67ca5f01f9dae9e98eda581d693ca16b9b35f40bb6a88deea334070bb6acfe524921229c168d2c92b968ecebca7c8d49014ba94fff36eb5ea64a6b7f6e2808cf72b48e7e09231fec1fad1d5ed59c107f8817e4c6c0327c56926f95533b1f0012427c4203abff7c718a3ada1e3d701ff2f4a1eee497f2cc9b31102dcce285887f41e979cfcdc71672b63a41e44bb2b6f7f95f520ddcbecfdef5cdaf4a6857a78f13707973277d3d6b3efa1f5fbca5901aaa2e0e6c46e70677c59153770225d8db2eadd3105bcb0593ded8134e8e4c35aab4b83bcee6a17e9c1e47dfd66c2baf3f40884581b49ecfe8d6307f60fbebfa6498c6b58a947a082a574bad4290dd16210dd83417389ffa479d71debc7dba5efac0347d22d22c3b2102de0646c059ee48fbdd19cc7f4ffb6e225f0186b746087f657d841d30361dcecdb2186538e312c0f25b9845729d730f63d2d2483c6bbed1af7648a4399a217af2dc6fb587fd46e258e2a563a981ca3a337f4353b340120f950a1c48e00cf4c48fae6f297d0483e876f7ba1071981e88a6977484427d9d9bf4da2f60fb97cadf38cfe8249ad1e26fa09852aadc95dcdd24e7c6265318175e550157f830a6910808be73189eb262affc27bbe0c1ceb133a6f6fdadf1e74b96d3e23848f32a6e3c11ee0618ed4a696a2d0f963f10c408fde96c4998020709964523ae627fbbbd137309d2de548160e80997627472d70c35b9ac1351f3795773d0a67d67af9e108a864eb48f35067990368f7fbffc9eb8dd3d5b2e72c062d96b149e459c84587bfd7bad59ecc7a6580e33d8c9bcca03055c85e7c98da3a6435c797086fdb32cb02929daf289d9f992e49bf5defc82c9f26ef6b3d91fe8a0003ae057801d7cb7928278400ecb1fa7d0cd3863d87732784d12ad38d2e7ccaa794addb32b8c008fc70a64e01792834480bb8e4d9f6df45cb10baf9e333822620ecea04f6c135474a7752cb3c260930c0f1384ca510079e12dd268617c26e37e14a03f3484b870463b715d8d07615305f4b26088c75686c54453511bd41d8615d2a1b54af6e6be222e6091b4a6f460553eff8102a8842d99c08de50e287dd8b3386c2b71573772bb6b0f937c919bca39d2604fd745d079bcae0f158e97b3ff28fe1dafdb6e7141b2822ef042f1d4f0f68b26da15937f95f2296f01e44bf25f5b2cc97a0df996c0bcf3136b26121f05533c307abb2337bb7cccffb594a4b942961967d137f339011519569548f0725d5a9940e23188932e851ef5dc048aa346d8470109bd79574dc8fa5cb190ec259b1e0e2e590dd74150695304883371f3e45b1ee26300bffe0bea63b758ab9c6d6b46072ee57dcc81e0b07eb2a6559b7fcdd2039650e63581c1e6724702ca9f49e6ee66e83c46ba31acba4d643adb3d8f6bee6a2cc1ee6284a5be5225ac29f07a692d3369827fb401b41e10a19e4b29c332737a3dd184e5e975ede94ddb62a62fbb33c7ecf8cb7bbc7e2e2b55c3878abffdec064046d4b20fc8c7c7980473c004d94634ae94cfc99757a810aaa806e643737cb7df6aa98f2fa1f59a5a9f18557e76ca36b0bf5db88f855b005112c5e360db283e85656b446407bd65a65ca8fb370c338ab5f51848534c7ae14d7143ed1522d7aed716b4c233141389bd6a717e746f7bef450e56998d24bda76e15c19f0bbd474cc11bf0c3343a93e89974d76398c207c541863a09ff3352303ca59fffb30c0cd4c77ccff68560b221af9bc647241982f8b31fb37946f4c09a5e6f8385bb5abdbd8a4dec1fe48c600933b109a92f6a325363f54606f272d8a7d99b967324f3ad917fb98a4d75acea3304b849415d0a398f8ea8b7bec7992f5e8ef76b81b3f4974cc01c28fd798df9ea8d627489b379179e2ffe4e3bae162141d138d2dc4d63c58892685107c8f50d64fff183d5514da36f63a45a725712e6b7277a5e6ca9ed500ec9a3670e326fafa2abd8e945868a92d12ce7e53c4b06fc07ab5cfc148f0b381715e9e2fe4c5fc9738577f8bbcabf2cd722eafb680719463a57a4438f94cf22ebd7f2c3e05e31908a45501ba8244cb50469841bbb7349ca7d42983230653499510bbbb3de7aa1260893889dfff43c457f7a4a057b8ebb5c765bba30d87679af4f02fc29b97926b8bb2e1a727139a4753f371a0d2ff350685c76357b4f9b5765637e0de7ff88af10dcee16de5032e6bb0eedad4f891ce7d2924e04bd399741123e2dec6054f79cc8ee9ba6ec2c39f8c684f30e837735a35695a7365bd261d61c8d012947c239934fbb7a8f3719ac5e459b11d1bfc6ab2ed1667e89e1479d3c1ba9af95e4e70f44d2bc715673d11dd3355047bec0dcc016b2c793b0460f5050088fc7a30b385f6926dfcd045aacefeb7ae8b04fa1a4f0c6f18fd41fa65e11a2c6e1b3e7e03f5b0c2b3aab3a07a8ac7733ea429eee0ec0ed0e24644fab6cbcaa5c651e6e9f0bb8a589aa2e55a4173e6a896eba498bf983b6c392fc6afa31aa09d46e8f9e8edfccda96d43427e3997228f2878f15de92af9494948c4d81bf4a864f27aa63fdca555786c36ad184d333dd2a5c37b1aa43b9df748f755ece8aa5a15376678275a9b59565616266e98715ed1f37cbdad538bd53946d49419ccf42bd459a1864b20b490cd315cdbe8be34ea49580fbb3e961b221a9237f7dfb634343cdd0cdbfff961d5f537d570e5c9366dbed419f0d172ab951b1444f5dd18b8dc5515d3bb4916f3fd0a7762df9ef6e2a4d9a3ce823319fc68569e1e9fb874b5e5bb4c4db381f2ac0a69d7af5179b5392a72e05e2bc90015b8767997835f5784b59ca4dfc0491e584b749875bfd930fcbd85a92aed165afb23f0f89845145c4d97a5b0c8a38f586846906470a0ce7e7d23e1f134fbc810c2b338bf7809048959e61ed1d80aaef6eac91a65a1da7811a28f41e4233d62473948da37be5b12e197c9dcaf97de02ddb54183e07f4a889a3afeccd25a5d7a30b769e59e1be39ca96207e537d9985cc10e555e6fa77a472fdf2a6f57e67de6cab1ad9f10529af830751724b917a1c81e54d82eeb4a447f7cb593a3094185d74c644ee4c4edde5fa806acf1ad2ad2b031d0115b8f9b5a69c55b5a59658a4297cd3eba930dbd354dcdebc1118597b0d503ecebe0e63d724ec7da488859ed08bf894d59f9d76f75e32fe6ed6fc7d8dfb818d511d0d2420ac23b810f46ec3a020d918f763c7b5806dfa2ed5869f0a04fd2d57f145a2ff4d254b6e59363de639f9f1f2855adb0ddedb9a460ba703144fae852fce28fae79ebe54589f3e45ba5893fa0486b2009524b09247ff8c7a9ccd747d8326d537703a630330c61ce1ae9529813c023ac223d965b9b97e59d9a0adaf1236282f25933ea247eda7f8237f3c1be5e71593b45be44af8b7eef802053464981cecb684425be99d9ff9eff2c2f36fa5cf8df7c5a78fcf387b6924790d065882777b11adf0d2b28eb48758d58ad1813b1b060d473b33d126d061da4cbaf8f8cdaaff9a1f592da23b794fd966e03a4f11e4174edeb2ac6fa3a44fb3908d2218d2f33e3d98c7142d99548c9a589b69acf5c86726a38653bae05161264be2dc32c2390154d85b200fb855ea384ff52d5c5e17375a41bc2b8009601eace1a4df47bb24b8a5855f527140b55420ac8d6307729730d883cb2828f3fc6af5e4992c755d71528464e514a8e20cadc700c9e1ff44fb6d552c1b1bddf62a64fb2840519a02b78b98b92479d4bdc8c263002382f005d83cf5a589c1415793cc3f160876e8bd9f0b0b5145bf6b9c16caad6e5a8ee96b4157d0f4ee3586936397e9e135078ef241704da46e795a1009994f145e4c624b44955479e870ee4f87cdcc6132b597c2eef1607bd55fbd3545d6b7b151db926f325c1452074aa46675d3f95a7e65ece7f7c9248450b1c250da3f03c6a5f88d03ac0faf0adc6b2727a2d2f18511de7c2cc078039d2694af84db5c2e795176167d65a480e2969a9d8de52111dc748655e4ae97a7e114dce8724e4f060dfd2196908ece2a6b093601ce0e3f4232d1c0cfe0cf8e6ed1ba446418db616e8046e8b4e9f2c3ebed27d504ddfef505395f736636ebddb671a39f69a1bb25c8013babf81767952880da761ba026951d44a0641fd9d4f9ef0bba52affa8cbdd27c1d30cc1a0314ad9d04fb8776fcae1d007cbcc2e04092491f21dfb0d712f09ff847c83c9597f3c1ccb8096828da2c0bf96b61b66297b846071269f62bde0f0bb6d36af64058502a95204c42b52009252fadab8aba6d1de51ad367df90cddcfa04a630061f695ba178281dde1cfd73ea079f7b4a9619808a91d6008abc159b02fcb1d86ecdd644049d616638728f53fdcd18670cea265716837d0fcd705da7f0ddd89ed1f835d8978255809d413812d1c9924d8dfbd73a8d7cbe0f58d72575a8642af399682a29130bf489c45cd7e1c5683b04843c57ce9df892c6ca344d6cb02a54ab59139da31228a9d23da015c265f51f2ca852f05ff28a0e933e1b3545384fefb1a2227a19af9967b4eaba29cff20522ca5b9bcf37551930889c07b9faf22fa0d498b73e08b665cbb825036bb9a7f570c47d5035ab1e14a7376cba85a01b3af42e07fc72a886f1d0572712e7cf3cfcdda8afc2852be32b3441377b9b84ee1e2663e5a4f176b3c2aaa244d9a553c09e0c4bafc997ac865c1018cb42a61ddfc1046033da88c9f5643e29580f21724b958f42782c8b5a52df548e00431afdc4568fa083b477a9eac99dbda44b82244dcc03626381bfab55ce7e9bcf83662f0dd5feb3a5702e17342f8af74223fca0f45c65915d098876199ddf7ca370dbf20d5132d641634d815b5d2466311786ef10702f4fcf1d65e7b5f8b4eca4745b3fea691351357aa007bf4ccdcabf935e6dcc7d4737901c1db68b6efeca88ec1e297410ea87c14a7fccb3b644b631d966e8cd94bd15c7356e1412cd985f2c9f2df10108429ed37203eea845a921f8c085f1f71e64f87d1746847d50257fb2e1cc2c8712a015e385003072f90bc3e4faa8675232aee3ebc427a9ed42b582cfc70da982e2e661260323908e285f18b38f0ebe187d76ac80f7c2418a2bd21f2ff5be06977e581a4d29ff14868478fd8882bb2f73684e21ab93104b3261ba69d48f1d60eff9dcfb07aeaaefaaf47740e00adac20728a9c49eb16dd6e2b7617f4d3c365481e75338adbcb1a86a2cb1becb777b1b1c8842a339930e6846c88b4c057a3f7b2a9a5166e33edc9ea2d51fcdd8422ae2ceb5ec1fe9b9d8a7b5bffa5d938f0aef9e669f203a208099f7ecc750590de59af55f99488eae255e48b6aa9d3ac2a1354440f25298393c6c0465492b39540dcb2d48534992ae6aa7ad3fbab4c8488a85f237fc9f5dc3be2f47cea01455232fa46f54e45079a397e51decefbebb9b5b0e276b946a8082449371587658f80856a53722b6ea25382fddb90ce5dd21e98d714cbe05a2d5c587396be78756fdcc4d827b084320187d8dda71caa1ba44cfc7d31e5325143842f65c8544268b08663a94d05d3dae6261274dbd116ef19e5e46a6dd6223fd2ab0ad4afa8b49536b6ad3c862e1cabe9684b0752d895e0246469a1cbf3bd754108ac8dd6f5ddbcad336f92532e57912815c612926dfaaf46778c6f33a160193f53d34574004cae504ff296e7990ce49a584ce877aea9e0376449b0ea50ca1f8ac380bd9df3c4398e74cc2695d38ccb765e3491d0919b82ced5ab8a86daae08f379eff81a2cd388615197438879c30f0e6024dcf0d05832c72205f2554902ad5a0478ded14f7dcd89834dedfefdf9097a4b6f9733a2a8217377e2dba1d70373f9ea40e84b6207d4148b24bbd1d7ec0295aff462bd52cf11ace9b6bdb3f9b77ab601c07d3f5b28d78f46d9d20d6cb416d4409e5b2aab22758ca0f8d1caa6c0cf6fb8dda892ba3e711f0a7c65765611cccc40c7ca9878bdae32de12912cec83e251d423bf8c4ccd958aeec11ee4586f97eabe1b961e5d8fd60043e0eaaf48297fcf045d621910a4e29c6320f93bbb9fbaea2303ce83af683eb1e094dfb7f629411f2199df445222c62a1f63bd175e0dd71d20c4c5351d065bdacf913466022c600308c6a723d1bb01885578b62be75714eed83aaff474fa7220cb5741d0ea5d9dff65f38653295baf206485488ea8ab1438a6a64fa9f1467377194398265058d9432306e8129a5030fa12df4b7ced747ed410441490956520d709ae8aaab83c22ebd164daff973e7afe4af27109baf21c1e3984940aeb518a533d1cd34c297edb31ee5defc050fa2a740fcb91ccef8d28c5e91c7009b112dd97768cb1f1abf0d9e40b0ff044d2049f71a85e3413fe447fdd5510e1ddac18b89c15589cb6bfa104f0f7f380bfaeb1f09a15271de7750511c62b53641973bd5bf82d77afc0fa1acdc701dc0f16993595d473359948c11d03211269a23898d44ba76eacaab095132d6718ada62a6f8031e9cebf212f2da128b4ceabf0524f0517557ff12df086c13945fbb20bcf5e42c75ad3eaaf8820e85dd1b54b5fad2bdfba09509aa008b523fffa58ea9d7dd7eae6507b4ca2323154804acf7986f5486c6d79c965db29c940df5addb78062a897d36e50373e4d813747cf84dc9b61674e9a1234100723e3b1feb88a8f82b9c67447674528398c442b01755c71e713ed0dce63cda2e9d3dd071671841cc52f2529974c22210ad8e776d6c25ae22bea6630385b1779821770ad96294a09901dd461d0b72937614927fb99cb0b3d5b807c7e4e684b21e36e635a0b278b833bf7c38493a1a84f2985f7880c9d8166ed84ed8c061e46af2352c4b52024313bfe25af79cec9cbf1335092a5956cbf77111fc02f5ea9d22254179a423cf51c33a8b43f13312845122a1536a158db61a6601b2a67abd7bdf722ab14c9cf47ffeb887ccd3b04726f6d2f62d68914cd98c3f1b339ee5925028df02d7f56f9208baa6ad8c600dc531a8cafa83ecc2f37b3a25572090bf8afdef780dec1297e8ecdf75dae26ce810c126ca18e686e97e74180b1d476ed320e6c32d3895cedf19605d86347e830a1c16f263a43e9b913b80b3f1a71165d07bdb2c54d2f1c24052b91b845bfa8f209edc088d92ab1375d0b2288908812b55aaceb35c00d5d6cb660a99c036999ad6d99daf97f945cc55a63e0d958efdd9f4aa99e6aa7510e6d83a6b115d0fbdb06c34735e7bc8e587800bdef9f3630c8e6d9dd477b276416af4459235932bd17dca9c0a7f98f966cec9e2901a1552c51c11ff2ae3ce79b4800cb0b303b9af6dd81ba215ce90e3989ee2c1729af61c06b8522e332432f3e60ca3305095db0a0f98aa2f353e15290160426151f00bca62bbae2306869529ef167035616173d1ef95b9b11a70692636878cffac01c3d437055c512e61ed23c3cb8767505cd62c86d19de2246f6509a60c971aa6a27f586b16565054c3e5540c9e28fd37b82bcafedf29c68c57ae943bd838549121bfec3b604766bb9e40d5843bde38b6daea84ebb3d0a42dd2cd69dbfadcc15b418c6df24241f57acabc1c483f60720d105252a197d0025e423c4b53956d8f1dabd24a5e75f065ba3f817791a8c44ff4742036be0ee6c690aea9c31a5396bef917812103472d3930c574b37f5bce74f9fcbc643b2ce453dbec317e8692526bd41392eb5ee2c33f00df3bd7510d21c997acec4b8ca4b289f9d221ab5edef3b7291ceb807bfb597f532e0cfa66a477d1d74131cd5d0f48d9ac951a5ae7c69a1853b9704a5f18bae2cc514dfe01ab638d5a808e474c93d1609016425739a081e6c9fb943f72d6ca09f2ef8336420dc895857ce0dcf8e1e3414140bdc6e1ca3d8b31b78b278d2d9390a177640f21704d204462737e5cadbd6e2fba54dbc34987876404e95a2b6c8ae784cdfcc9c3f28591ae692cb053db3bb796fa8462657d2c46adb73af514a8e5208809c8baf13aedf327ff2a82bc70cb086ec7943a10acb09723dd4f24ced5b85af3dfbdc6d785d241a90cad129cf7bdbde561e31f32b7dda07154fe9ddf35b7b57a8bf24d29d394b40d1f8bc84038d16c5423fd0f09ebba8b4baeadaa5bf7a8434cdab41f7d93139849a3fe0ccdecc3090d9dbdda021fbae3b34b1b4f6de82f9997387633ce5be603b572933086977c6f2fff73dfa89f882280ecc6772ac961b0ecb82d8e17d04841eb8d96bc9d33699c86a45bfc16d92a9b3602d33c60eceeabfd5b2ccc86a5eb4e4bf014bd2ee2543f89c7b515b45839d79f07e668d1ab4ae1b2c07bb8cc0100d3c6b76ef55ca38e1d0fa30961a1ad26381ae4f58207991aa9ca904860c02a78e007708f9eb7aa253d3b4a9b2d71640657f007717734f66fa5ba73732cbb5dbb16ba5ee9f0ea778fbef66a4e4bfc58948d4d39d4aa642abf76396d68a02349c2af8090bf81b220f1f17d22cf0454076e8887d3107d65ed5644b9c59c992eefb320b38809b043b1a4db74d33b36a49e3de23055a1b2346733f8f157bac4cd9144c3acf899c98929f1ab1c5a6504613161be47be8145344e140cbda6a9c63b345d53a040993cd8665a56deea925c29fa4a2457282d74e1cc00901dcca0bf568d2005f94211cd890290e92e2122c125e26f790e54228534b22e6c41fe693e65fcbfbc6920804702e8b84bd533b2d6cba95c20a0d7e3d05849d664c5511bde2907157da97866b1f79ef612f59e8dd05b8bdd9ad12bb44899eec3051b86baa957e5237c96c0c75700b1cc73e6ad9ab1a7401d0ccf97753503316feca05e6a4601cee746eee58e55b5068f7fc650916f1441d7e7451d56eb5a5e7c0697fc908a666e57392d6409179ce3ca72f8680e4b5b71b41eb81a10c5b9ebae39381784fdf48b8d1c6ac930c61d397b21563b99b49ed105d07dbaf088b67bda8b5b7b5b5f3aebfca5a235a17cae16549635b63c3dca4673029e42a20bc044d769777a0170db14048ca0adaed62ca9da39ae268ab53ea7e46f8a959cf6337f7ac8b2051976a71da8a0cd9c38c39c8f5bffbe117f3a0018cbcade235810f98e9b4a22f04dc8f15d2e25fbb1a8734b6abbc5ee2ada01a9407ef3eacb35b2e74c5f57e9f590ab304db43d47c9c3aa0b930d2d72913ad9e67ac2c04796fe681df141053ed24b123ec114413feeb1558b3124d49ed315a58d94f4e685aac00f2a26790697ad0b5d62331159ee058e48c648b07592cc53442ca78926e447e26f150d2330089b2e2543838a8f9c1a3bd99136a251eab518188365c8b3559e5d44bf1cb37153ff8ad7af072bbf53585353494c4b7cf6f42071f7bf83be3b3254c8a05707274bc85d7685d165a04cd7928f495a2e1791f148ba039575752117cb1de7ff6ddadc78ef805dc3f297f2662575d47316118380d8d8471a8b5487b97c81d2aecf41d3f984076bcaba98fcee66806e19ebf11ed57e37a33849384235e34a833e88f53427b76d5e07c9fd9e8bd9a3b20cfaf7b120b416a0480dde05518cf6da6d745d149cdeaced3bcce68b0a7bab90741c645a31bcd374a9d63ff02aa90ba93290992be923288bbd49a87daaae00984486c673abe2d5b7437d54e57e991a85b81370b14b6002c64ad5b639a59a2c35713ce5f741d7e5f2590c55105ac7b3fca55bbbfda2f06a9e25751c684a9bd9f37512a32138905e5fef10b8cc2d599ceff36d0cc389d654d0caee79253b312b9a98e5ae01222cbcaf4ff65c496f280ce5ec1d10557ea60652e704ce3f5662d3fa4f58f7ba6d06e7a90f0cc2d630eaf580e9d733fe8002e774e03b6d3859d177e1e86ba55bf9dd0c611f7a8f2072600340bd6f2e38e0ec0372178bb7c5d501b0c80acecfc38e0b6ea0ebbfa06c663062aaa1d3e68084c6adfbf3c2d5b1841bc3c7f4807cad25d82524b48a0a63f533b7840ccb1a037d77974d53dc3c52834a9cb1b5c7c98c84537af3f230a4bd9ec817922548e1dde829c478cac4dc2df59e0fd37f6efd1482e35710c6473f059d175a5604edd8ed5f7f65aae55aca64a258e732117e9452b62d4426d30f1d59cbec8f589e83a7288f8a073ae4d931f9b01ab28ef4438f90a539fdbffabc0a40e92abefd9ad024729bc5346c3a64cb2c5037ddfbc8eb886f325f44cd84236ce90eb0b4de4e04107878bb0e57f7eb39e655cf7d554a989a3b32c556f52d764f6854a6233d9e7b09fa8f26263b2e2824bc23822528946e9f2279576c36dfa3d74f24fe6e6b19037c793e1186b6272066ec763971a0b2e4621901a619599e5b0b3eb8d31bf92bf23fd03fe01dccc60e09cafb6e42442e4caddf50e8d550001f540b0c029a13ae7d88c455ee741671840e1e767265bf07b8c8c0d80179af5b95a50cca3b995ac17bc189b5e97aeff38b3eb35b931f047e0c10216924b36fc1ca8953edc9f560b53cae05dd6d8bb0ca24281f4e4586e4ffd8891350067b7092bb97688f8d763cfbd61b6bb831445a47751f1043ee50a5f31f0180a6629842cf3b62c303c571e689f122f1255a51fed3fbdd5bb49f689a732c094961bf99766c118cf9ea1f8d28142094e4ba558532983b4c2fa80ab08d59af563a350e8e18725879bdd0b570c31f85bea2ca03f9fb6fec920c73629d88bf088321711877c1bf5a6f7ca31a997a1e1eae7db02f3a2cc57e7be5860e529251e46fc379900d8ebeaa1db65f3df109474248ef2b9e07e5062d2d8e21e98735478a600af97d7868884550a4712b868b2983e2b861ed267dbf1f01876131f095c3b3f7e8c817e817c21659646726de5f56bcc13dbdf303b077a7ddab79b4168778bc5fc592cdf293168031636f4da6b3a99d1b4c2ede81f53eb00255bf9993e86c94ac78787156b2ce782fb8575c06feb0e57747833499f776dbc7aad842e30d79ee7795576554fc8194f1bb5ad2dbc886ab53074bfe9dcab307f4b7f743f5ad42ac2b94ac8d1c49ac323f8bbf1f7ff74f96b0867fb5885608e52afe992150e076e1ea39c9e9ec7d6a9fb1bb654996d42e6b79f677a82af6b7d7dcf581d1f8f2905770cfa0080cd4752c89e1f1494f6bc7522322eb3ce8db53b4ad44569a2f0df8f8038522e6a763c42857168d85b4efdb53f9a3370e1392a089b33b40fa95d2cc4510cb4ff3f2b4933c3c433f27dbb56abbb61c6346a5712f50be86bf016e2201e8a7ba1c80d07c40491ed05f9452e8cf79d6c59744c1ce2fe4c8cd586da654cc20008b052b988a2b4d3a635415bc3f880734f3dc3183c5b07866d77f6ddb6a1c30106bed2f46265353e6c9a77a534e7ee7a5dae9673c357ee30661a0f57688691ff49c366452e7b9905d008957b8304c8fd61f71e6936b330f471a68b3c820e87a959853777b064cc4ad5da017d9deba53d905fba9b7ef850e3cad85dc6bc2ab1cf62f8977aee6ac0c454fe59dd3b7327c961bca4bc8d9970e8c84fd7144228da6ebee923702859660290b92500798945ca1bc09881f107aed31daa6556a37fbcae5998bb82b468d5e65530b8f80a7d03a439cea5654e5a77f07fad26df3fed6b17b68731dd0101a80687f4c931ec8c7885f60e7743d546df9e65ed6e9c72fa8a8688bd8b7ad3f3767a76b18569172df36cd5072af4e7f356d01389f310fb617851db88c4710a28c25f66495596887fb8cf4c4cb665fdacd6b3321d989e72bc8a5060ea02bc89469454f60cac4ce39b22dcb3ce489af568df964faa9c859cc2af51bde761be98d9d9295a986bbd222d7b182b12cd2b898f602a50ed47a340d1a49e71ef47cc8e8fd4de62d58d331834ae3ceb65bb35a91de1527e6ad45d040282fbdc8a3e5a8d39ed4db39382060eef4fecf6e8e52613b08dbe992d85893d8699b5e51b08900a00a4967aba0ea0a9693addfebb900c3c320eb2b2de3ef95664e86327f17842c54edaf05164e5b7195c627a548837c9adab5fc28dccf2d89b050fd4f9936652a40e8332e7c9c74b9e8e2353a2fb16f04f8c9eac79d6858a57634950818e01718a78bf8f15c86c90d9673ca74beed4625f88ca0b1ca814b1ea02a3514cc177e8038dd3bf16664ee43d004fbfdfb24707833e457d16462bf0de08174769980818fa87446ee0a4d965ebc8095d70b9fe35c73bbea92b02a450c0416823b26a4e36e8cd7018a831c0df74ac3aca750d4b27e835ed99093c0371b059adc04050cd12259b99d4c3a149b39a54349a0684e04539e8351ad9af006964c486b1078673f0cfe80a085000e12f312930844867438bebd2d5b858354d5c6993fc8756e454e0c532ba14703abb41bfb25522819be54e28f040c6eb85befe94b09f1519ac3b6619732fdbcbb0d23ff140be74f1ba7f477677a9a238434d6eb873ae22f63c191174996fac58b8824933964be6c5a255e2c59492d8a154a6fb44c756f1763abb806bd6ef0703351c21dc28e7bc611496b2f04b48baeb3bccbf85e8632a17565f9c9b0a3e511753c68e292757f704629192aa2fce92aa203cb4d85bf250ae6625e7fd3e1954dde634dccfd182b8faced0470f7fcaeba993fdecdfcdc8707916115c05d6a9176957dde9ffc08764b474d2e6264a05bda0eaadea1044b46fd19702d36394a4b6525b1e5db5ab91736b0002f34fb378b6a62579763117ca88fa61c0a1cbfd66318089ac1268aa0ff394eddc02cd3d58097882c0ba8f0661da50db7ac57386623959255aba468c504779023cc7c4406f5f353b194105e0a2fea62d4b8eff250e8e6a02a6566f5f32dd5b6193079818cf8cb38f36abeab6e303f994700f07cac278fc40595ca7b7675e98b142dbb5e8b018d11bdbd9a70f6fee5b4bc8efff8f940a0227aea51f3e5c31c3007c4079085926ce8ec8d86fb7a41478034eb99bf6116ca5cda937b45e83f5e47c8358e345b52643ea52c6c662e0c4e65ee14e29e6ec0dc3dc469fd48a1877478de01274d6fcfd9ee8af5ff299df3f42a8aaacda1babae3b26467347a68b0acbbb7bc1f1f4c27b0f90afeccd6719e99b14ebb18963640f8170b3724e8c92c0380f8717c6272d64921e0e7bb26f137302ec4e72ec79a00d0610b01018e90aacae5f67c5e2729f6a6725de6ab1a0f9c99177dff61b60ee37e2d9fd6aeba40190052bdb4fe9ebb0b828ab26a68c78f4180cdeca9d0d7824017ba582741ddf91d9348fe2b7602dbdb2e15e318c7f372e45c15a09a6814e13764b6d7253566758daa90efea4be0eaef999d54c53c55fe4e5f33f8777a1161e0880a34e25af7ba79d6711345eb25d4224881e97b8f46c811519eb086e0d800cfda6702ba8ca8d19dc9ffc090a711f221a9994afb8bce46a26bfdd628d8542901350573a919e87f332fc85a9a1c3e20ac815505dab1387fbdc95e383c5c538d80b41dd15c2a4e8e907f2bdae52274e7285b82d0ce3876c44decfa12a5a62ec6cf3df7baa001cc7ea5abe3191b5a2fae7f46e18dc49bd2aa9101d2004d0804b584852dcc4995b06d678d4919d79df9883ee896fceba71e2d58ba7c4b7120458566d3013f000ebefe1cbe258e93e390719a3a5986e0aadbc72ccbb4373e57ad80c8feee933f36fcbea4b6f91f2efa34c8dbeeae80c41d98023971440ecb8b9d55c0e7d56c4fff68f53d9cc87b7f8bc28b4ffe9b9516066c6f73347792858e1e950c683eafd13c347bcbe22f19ca85826191a52b0489b43ad9d0fd504b06b382b5b6e6764c4881dc09f8332a5853294467fa396fb5a2017b0bfaa4130ed3e27298ce78cbe89448be8b8c9c97e9b1cd122e60b62403a3f28f298dbce408b27f767704e6c05a17f2224c4ccfbd88d94fb94ce28edfaa523a63ef6113ae8d5a3b52bfebcfdcde2b8fb0f5bd4f87f828c994fdd67e0e8f4bea1b1d0d0a0c01cf4aa92dbaa482c43d3870c430c77f619eceb57e0a38757ff2004167c16e7dbf1630089b44084478a406d4d6022a32ea4e6660f9817bf48d8e08d35210116ccc73866c967282a5e04cf9f7841a96bd71b02d1de1866ea109091e7400fba7fd5541ebbbe4c2cc0b545aeb416ae2d86c3fed6143e80a5b7971b6cb14d7f6a950952c5aa8f1fd39648ce4a0d7940014fbc0ccf00a9d4be1f0adc83b2740c41fca58910a8bf2a446ea3c961847e685724c821c4043d87e9ba097cc8b2e2497188cf3be19bd730d763ead4ec1ae5313d044d5fd5d1097f21978ace222712f2a8b2ecb4c57e30e31d71c5e2e5e05a1152484917390aede045261c0e579eb079f99bd68de483891fbdb195f2157d75630dea05e5839310664e33d1ed13e00bd5def1529ad95ce120bfd4d816f2e1546e441966b35744b1704d606204e27def6f2079d7ecb2384116d3df4a332a7753c610e9eacc5044b2f04ccec7c1e2265e9aab53d67c2b058b316d0fb097a4ce655a354e5762f6610ff35a29b50f95d84d45343e85a5d816a3b44c76ce429e3b25941c6627643349a8d6d291b9e36f67b4255936fcf4384e601ff4f8268f47acc1f81352b7a1051b19a1d45163e3d33a2fa54bdc8c69e8def791d89f84bf855abf23b2d7c0a5c0baeb9681325cbbe09499a2b48c0ef13c30a064b2590265361679696b8ba183ada3237d1caa500d73b5505691c27ca77969583a5e355cf8b798268920ee0f8076242cd780b539d9b3890940ab46ced542a39d0c9890db8d32164c059be9e91791d0428806a751455ebcb054c44faeb943eca25ddd1a9f5a15681a7c5639eb34320650d98cb4f28c0ad6b3e30a2960c0c1d0348847cea34e365d205574ecd07a25eaf8e8cf311dea5e6c748169a1b08e8c67e8b3af0ba0994c63bed05fefe4ea42e85a8db3f9459b4869880109e542fb58f115a1eae8f340b49107a2e3a4e4cb422f30364fc4febe4561d756c174460372e6dd4c355fa6b2408f6cc64afc62408c6c8a539911ba2e755c26d702cc4bab01035cc707504af4d7ec89c95393ed7aa10ac0b443dcfdcca1bdddfb8ddec16439284d35db0e7759923fda1cba5ba42fe903dc596b17333d68199c2f7816dddb4d451b30bd9fb875d852a102369b932f3e0edd41a8c8e7833ac8aa500d059e5924fc04fa3bd6a457228c88abdef214d4b7005e9538b7ddad776d5b375ffbbba341e3ef44d052ec94751b6cd52dbd3afe360148ad31a4c421bd9eca35bc3d0f3468c7ce87b094c8080e40175c1b00e4fd335eb7bd19cfceb9eba23396eea4f2d60eaa6b1b8052e3b69c063b3018593691dbe05a55feb8d11f7307ef214a591af5361a0a110a20c7c75026ac939a0f0dfb8b8c4e5a18bf11031491b8189ff00cf2f002fa51f8253b9b3a9192295500a6bc4ee23b6ed7251e262e51384ac8a5e9d3b35b85946d740f20b0d81006c7fcaefc49951020dd73d228be6f2a89c677ffbcd38de8597c34bc6355fb1fafed965b006a0b78d1023f9301cde0c30219d1dc1d04831d6769ca600284ecf4b982b12cc473a8dad03e9f21b36174a6d4f89099beed91ac62d0b664ee6ac559df7394b5a2214caa2c766ec33f605f03deb6474f83df83bda7b9c7cd9b27b2bb48be41aeea3b56ab635abef597281010584858a676be8b4827b9b4c998a63c3bbcf94c42c8239d1562d50cdd41533a9d9cdd473501a41f5d2891166bf0d973f00b119003ad9fb30ddaa319b4ab9d0966dd968d7f1bc21676be5c4489d6156cd65e6e09d4180d9ff2a9e4ae5a86e7870ed953d6ceb50e617f533dab11e28151b38a740be4361576706432cc83db505b589d58f9a6b3840135fcc848b28d07afeb28839a766da6e668917622f6992df660fa6f819e55910faa6af5ab0b97bc313f0b359928c03ed11f9e0eb56e2e236bf0ba6576d91849b115d4f46812bea090d0d1083fe73be7816f30e2f356c1da91664c4111e66b2355dc0640c5752a12baac878c27c7b2dbfdf82a8e7e541cf8143f10a34bbe6911858c481751e3bad1d369e1dc08cb04f445a50f5a6506d9a8722b4db166d2b0979e6ef8a63c74f7dc26e38d5d1aa55ac8a6b70563a2af6423e3998e4f922d6b7486b11f24ccce098d6f0fdacc19b8d82411dd21a35fbfd442ca9aff076631df77bc8ffad45939b8d3742c32b32f2aac3d88cb1b67ff68fe9b70f01138e7eb734fd19a2bc181e3ac0f2463a038610c79dee2aa7c3a08b755e976baec5c77d2ab4f7b801bbcd6de8c2aa71236e694caa0d8da123ccb1883d9f6f8b0379f0b43ad00ed9954dabe03173981e6b483a2dff6a1e305751b778b3781e2485297c689d75bd6db51f5e6cf75a17dd45c30e5100302ed19f034d0324d951b0cf519bf7aa1f6aed2a876a62abf0f855d491b6e77320616f3be9a6ae6200b1ccb41707fd8b5a7d72b96722645952277f97eae3b645c527fc24a9a6a568b86bda6b1cdf83a105fe30a14d476d6d5df84ef486b025969d83613f5efef4e3dbef2523091c436cc8fdae2083e74ca3b4205ff6d72d191930337be929d912a9d7d68347fee8688126be6ce2dfbe0a65df556b86ced9a0b1cb3084ff68f2a770dc842c445ff6682f701dd7cd637d14c145aa2dfe8a98a10b808fe6801833b61783b63366e673ee163345bdbcf902ce5e1d53a3dd620eee57e32fb531be70b961548d4d2ce8a3bc2ef86a5290b7ca4ad3f89cd63267c86362471b396eb42a99a9ca2a60256c9f08d89578f4a919a3e73ecbe2d8173e645ca4439459c741704564f689f09bbc9185437b324e133de7f43eaa9393c5d32d07e83e81b85e12525e94b494d460d9d2ee9b189524a7bf3c28b7fd23f6f0fa594e3bb4804707ae7e1d9c660a0e601b18f0f198291b18e8f011d39e28d6c6392a94b1523da334e33a29683fd375e23e55988d34dc07175a8dc1efb1f11640fe427654bc80727dcef43bbc37f44d66b5fed7fa7594d108c15fdf2f692e42fd99b003c52a5fdea82bf006a2d71186068becaffd8627edb0c362685bc5cffe1393fcfcb8ee90f6055c2eda044b20bdb04953ec8b6127d459bb7d4b818520ba93126801271862e3e10e22502fd4fcb151ae34411f74d31eb66a6ae1a3987f1f73cbba15515cc151f39b2f68b31111a10eb9594067ce61c4602971c10791032bf5bde085144a0d4ef5eacac4ed656b90c0499f24a630e312d59e4e0739f15a744d9f877d059da32cf123b8bc6491e705b70df9652b80ef8d40c0639a56d70a0be35fcd5bbbfdee72d69cb7728ed8058da4891349504999d999ac978fbd44d3b911cba01c402c9b003bb869ba6fae5bb915c2cfb4e3a3c52b3e06725ec62a06b2434925aa133b1d26a3534fe04ec655dca4a6772ca2053a4b76a596c25d4a55c5af35ce12b35867b022fde75655f8aea11a57f7343bc077b9c8003af0828f9309ab5f8f1d2a596811583b798ebfa909e45253e55335f6aa14d5c3988e0feb304d9dddfaf0bae2408833946135eda90bad4f8ecd6971801e16a1c39f005af9396374fca6130ab0146766320b59a247fc6e70295bf40ab402c8ac2dd6502d5e6ed66cc97be2b11648808d8f8e2ce8fc0f9707aa816326d203d0f81403fa104d1554339eb4fd874561c308a3d04c4f9359923982fb3bfdc17b2d1dcc5a0ad08c653bea1282a6029d3be1af815a6d4482dc7fc4c80f9029aa415db29fb8078e0d19391461bf24d7f47f1a420db8b4742f9bfb643540b707a041f8fdb4b2466415a7cc86e264bc89c8c8dcd3b3eeaeccfe9d6308f6c200d1b8f99ef188fcac42a8735a30df221503533019c4d318e1a958cd387bbd19d6f26f04536e2d3acb0836cf21805a9fefa97f9161473555ea4e3d44d62b8267e88f9d2ab8b8b028f8f329009b43c073a037a765f29b6cfb75879f5c3267af7ee9cc448b520f68528ebe2d0935bd0deb2a1477ab97cbfbca3d861782812a6a1753c370915289d499c73fad1da286af275cdb7274e0ae55e1a6e1e6ba7a8e35d35703896e62d48a06fb921d0134b2fd2ff5cb27e59d18aeff91b570d7ec7f91961c9ec086d6c5346ca88dd6fc495f4b364f22339e82b36b2acf37187d3d39d8130e8bb7d9ec7d0f011a89ff4ae3947bb7859ac5c23db4987f436e7207001fc19a4c22ebbbfe7437d62b5affe24fa771b48857992b9ac0a95051afea14d46c92ff572029e53bfe614ed1ae3693275d7ddf48821d225eb61253de4b01e6af0ec216e75beac0941474e32ae5b0867dc7b8f9247dd30aa03ba06763373954beb721eca31e206b4831f102edf3eba259bad4ae085c3864c511d8ad25dc00c552acf668790c53f376f2b5c35b008bd80943a84b897a815f7a68223244c6573e0f8ccd407897206752fa281576a23f409e9fbcd8f3e1b52326a8e2a908b36ffdce302e17930c3a79883cf8d2b907fb5a471cb50affede459e2cdf2d06afd2a8eca0d4cf9f3fe099594679ab8afd364c86d89dd1f5db9d9ad95168e470d98607c82d841cf7d1cf39f1633829d24d7fad0a0d438098795f475037a1ef4dcc3d78597ebdaf3571ee2d6bf0b364190fccbdc5fde14de3dd4dd0b09539ffa8028968967b1a37275eda851e5a326f043fb8466b2a760acea054343e470b4fb01098467d8a1ef1a9adb7751f244f06a6ae3d3cf303fb17ed9617d3984b6a77ee585ed8b69119c51629fcd344f5ab9b73d3ea403aa4d1dc03a9f2f59e05d7d50984f2962cbaed90e8267ec7f867b23c7dc37e8c4b1bc0515eeec1cde6f7c9744be2f10d32d8a2950e0f585d91bc03f2297ab56493a414093524d1e3bebea3024d7435cebd9f3aab2543464194f7ff699293bc930888c4f913d8c119a3f3e3b29e9e54faa64f7a60c437d79efbec81039b2efcd0f7a974b5544a9857d5d804be5bb7c110d987aa4d0474d8c81b83734a899d05ea87194547b50d76a82c1c2195bde2e6461b2a364e53fb1e0c01ec38d88de3169c3ff171988af559b7bb04c4763a77969fbe21951455ad4988c5dbdeb11055a661a903f24232a3ed836a08315fce976c49aa3b9dbf3e8fff68199a11b9cb19fbd1d53217760617e3dbeb9eb77808bddc303b8867a2b7e290da9357c52defe77286f56a8bc7fd8d76c55f3caeb0b63ffc9069ad798c5a8e29b1712bf910469449ba368f5a39695c0343d64c87c4e38ef90b8a210bf10e786e88cc1eff855bb9108ed7e91b6cb4a02d464d8f43dbbc9d35440f19ffcc47fe79f7355d32a922d71904ef65e31fd46d0aff1c215c7da894f02fb271301c489a39fde04d32198d4a03f4c6843096d441ef693a88dcb2a37082cf547794dc13ffc58d9e54f161be50e6f82be349e4a738a0d93c6a3d8d90be40aafdcee49adba223eef7f59946cdc6f1ddc209ef071cd6a0dc105124b11ae122211b0709f3941dfe4882c73cf2d9aa2fb63c5c63524836c26531b9711b82f5c09e1f36c01bda0be35cbd2e92603f8299190f6334c6c88c4191b0ff838d5f9b25ea683bda2d5f8fad327af8585cee2ebe45a1a2105be23a003c4df1d5d511a4f0152a423c4b6907a214daee2ae9e68fc41a238c3ba7dc203ea17833adbaabef060c4487887f6d3619d091648d2d0ffad3974d4ebfefdcbf231521c6eef2520c4d5bb93276de2de85ce7c1221d8b60a1b2c37615dc599ce4032d1995eeb85480daffd40765dd759a3bcbfabdaed8122159a874d3beb99b66f25bb047bdb784bf889db2f04f6b1e1d9b82c014a55bd7ed44baa40cf1407fc5db2481bd4a84294368c18ba26923d272009f22028755365ce4d1cb0b1a5f4473869e79cbc15bc2dd168f6beca7694dc976565549b8247703193f9b2c8b03d0ef613a51f329a53fa8ae559cd3f7ed6e9837bc6b7e893c54c9d5bcb754928c4e8d8d5993742aae5c34eff28bc5573fc361f87597d6775985d823efd3c4c015fb3987620e4d0534505ce44a250f81e64225ac56830cef5573a531a3f79160e2b98876a4358c50754f88520d59806d3b4fa3bac8e71df7cf01d1e91767c945b645c184272fa1406c30c85a87fe111da869465f004018ee780f8c10c27229c1b6ac733881d93f49d7e7034f3541a787fe2abf581cff7a034eff076a75765a1d7a4fefc9f6b95c6c19564eef7a5b360c64d678d69d6b1ac6cf777e2c27dd6bb29a7e000fa0b0a9bab6acb18b1af39fb85c9bcb368e5b1b3082de416603d3498d874a1ea7ce342f3969eff711dbc282b992657c9b3dd10807dd06e751df110ad15f6a87be0c40536e43325550cfac2911ed09ce686d53e6f2c5d7b69f99770695f776038e916d0e7da5114586d4e944a9e9e1dd641a4fee3018a2a654a88f102ca7028e8914cd11aa13fa72de806edc7f65830d746dd8ac5e65ba81216c980c3dc1afd9316ae9a942b95d0e80d2e7c090a58a3df2cb22364bf36a570ff7550d51c4bfd45aec977b83e54600a216235e97022f7248c597383b85554e385c9bdbc7c1a28f9b4cf62227bb37680a081c9de85913b5b1e34bb1fa6dc52524dc77e494b6715919aca87d6e48a3600d93429716310c3e94761fb8f8f2737fac507cca57d4f890f3bfa810f14f398fc47577c11abc4205add515a61311d3ab796502f4c85314c45fc27e58135e14849782aaee3244c1c288ae5a8c13eec1366e61550f1edcf8f5b7d13cf21eb6829e3ee02e6f7cd036d11723e1d903b3f7b1fd745e6e6cd4c83e43aa1591d4a4dac72d738aef6fe6cd0b1f0b55584138b378081442db2eadee85efa30721d3100a1cd91a69e1e96f2c5a9c0abea1e66b68518de45f10985966134eb1cae6e430d0418c58d15fed06ce69740c621ef862c102304f75480de76eee6ef9cb38ce42a0cacaad69c1883451c4d93931f7933036e3ad6517f22576850ab0e9390d8a5615aa8146dccd0b754e2e8837510feff20747178f733f009340fcf2f5c7607e3d81c40fbfd140a0b771be7eb0271d80f1bf886593e4fa998a32376ae36c95c32e50a4103a85f4fbf7190a65c16215a34f5cc91e4477246ab82e3be13b580cafee3f6eb66fd913687370b610aac59a570029256618a60f3416c5cfad8d88bda88b03532c911821f231c81f20316eed16286d0ee3f207ee833dd115e91a635ff8081e344979259fe09b7c1990142e9da11f479aa425988ddcc02fcdbb55d41419c666f9c93aa9bc632dc62527fffac844bcb93f4beccbc810d3d5bc802a7ed86873ce8012d8d43e07d286429fb2387fce0a1445b5f7021cc7d08b489927e0883692886ede784cf4270cbb0bf795f9eaa6f94b35a91962a49a91e10997dcd41619de853270db5a3fe71980b1157ac5ed88791f7057f8821d60bb888954503bd4152c283baefc9f0e2314908c7cdba2c91ab007c746e3afae8e8d7c89bd8c2384186e954582676dd80c89c71bb8c8f08f667945e8161f2bb6a219692df0c84d7ea3348bca8cf3f68567b81a2dd22ba0c56cd95bc88d20ab038981c0045e50cd1793058d475b30965119436fed297675128a7ce6db13c1826b04092999fa5096b6abc51e8ce0ff9d29210ea2e17befb8ade03412cbacac48e69dd8164549e3d48624531624ed6579012c867c2873cb1cde5d4a82e02f40026768d2af1cfb3aec809696a6928b3e3276c5816e536abfcdc3ffb1d6e73b8a35ffd9f7eebee87c0b700bcea4558e23c1b50683121bb735fd21c83d7a6fa2ecaaacee7e587862aadce1014c8bdcc15d9ad9120f5d6cab714e266a369e7a609cbb5cc17dc2fbface8d2cb5106a369757880c3aa744e11a7905174e042c43a10a6ea39c28f2a53147be81d7a6efe723551a076deae033746aeebc11c66e9bbc872f5de8c3c92eefc28c5495a7c1a1fcf9fdfad18b2c5a2b03ea7a22d0a6337e6134aa110ac2ae461f138fd8d99c4325191217a25b04bcdc7cfbb8ce0974be55330dc2dbb802496c8392b7456d1c5ba2f7b86a3770cdaa875306e19496df7b382a1fada86e49bca84305fc49e9c89b43c8eb0bea3d8b14ad824e056656ce0458c42419b217de1ff628d3389898e1eb1f98caaf7048d77ff398cfd0d9f02069a7a4d8b42bf7d7f613e7dfaa44cbc66100aa888f529eee0a61b532af11ccd4f8a24f7571644353734416f090f6358ecf8eee160bac1f0d1b133742dbe7122d333c426ededc3d001a0308b4f712205fe57696a544e42593975b473459f306f011fb68a1e6c28fc1d283b301246c7a11796565a6b3c76dc350c924d0cb4a685b70255cc4657d40f586bcd90ab0eba8e6496d8e3c2bb4d708bf997de039d37e9276982d96aef0ee1c7bcdaab6c9256a65f261ed8bec3fba4abc0cdb555e8a1ca39b4624d379d1380b9c9ebe70699ec694e01533e0c36fd83cb4a285d4d24e20bbaaf40fc1f3422591357443c3b8f2ad145989500b82a2e2024bbddc06a5ed2430f0f2076c1ec32e81a7b83f2608521da50d3f8c279bfbe3cad382755c331b7874042d7f179fe24adf7dca8ccaa4ed1c22ed26efa13bc06e3a4c6b0c4461c584c412214b090c0009e0554d1ac0d5a92f279c2b3d9233bc3cac903676badb58d71a59ae519a0041f5da29020f5eefcf01cf957b348f690795a44640a0692d5e06cd12f68ca18bc5e23bf4583dc1db47cd0822bccfb2d1381746cf82e9b61342122106812e9ff4d953483c958032980aed4c8b3cef226b3a9b90bab9f1f347768219b104af07d2ba87c7ae99c1bc3f1c3aad2209c4cc038b108611065f96fb22de337946d3e6145b3634561d1c08d142e6d28e627deedd83c5f641c58cd22d7f6bda26bb131ea2eb4223d08df1a2e250eb36ecc5f488d25aca82641856fa2ea97d21c67490909510f984d8f071327424b494e62747f2944733b4e030bbc42d8d6d5f188af508ba5741b4e35ee4cc9a388ce524bcfccd5be794964701834a1bd9e83228830831a78c753c947f76c6ce65437cb028351e82f5ec6869bf0eebd4817647b33ba8924a2b4d99148164e6b2511a476cca7b0c25176658d4e548f188d4e7ae5f9420aef16ab47bc9159c52f6b508e4bf45eacde97a2a23df946212016640814cc206cd6e01988edbe89a565e1518b79a0c648e4de69235657dc1c4a97caa9d105790faac32fc115e2d52a7f3506775a5af4e73dd92741aa03656543049d24229f257456e3431efce0349b0afcb14a3cee0ca5dabc3cc977a001b7f461fec16ecd6393e757f59f068078954bac77b2a74b5dd7b9f9217ca7e9a943ded3cdb5bf0fa1cdcf40650991243e8f1abf3914c3e9f752ebad08515ed1aad2c39a58a8f27b48d030ceb102dcc3c9a3e643cc113a7c0ed1789e20bce5e5a0c30702cb807bf63790b7fdea4f8e6ca8caa3e142185adbf5b269a974b5ecc9d0c1b3e86f88a929f9aca5c42ddfe695f5f62f515a9fad7a41202e66d8fd91ba557941e2d9bc7fd81a98d8904b6778dd8fe52dd21168c3635c5f5d62e09bcfab1067c19ddb2249e5554246c460c6e09d35fa4be60ad50ccffe2f19654dc840069c4e989f11307f861ec11b7c3901b47cd4af18f86b8265aa22757ca4713f63c99b8df269a393de32eee0464b2b599c800897ab2e79268ffdfc563e0cd25ec81fee855a7e7126f5a90002d87685006edf8fea0a557fdb9a17b68f05b307fbf788f24f5d49162d5660f8f57136560daf4078ba8c9bb3615e24043a0fd364038273a5090dde90482b621aba351ed5f0aef568e65938c07d7b6a4756879deaa5504bfe35c0df16dd9d81dd8f2ecf56804399caedc7f875dd5225f271a31613036b4e0562b6713dc842c90477aaa95ba6053cfd44b1f63938b72dcd83a53e96ce5777e82e19c101981106393be23b3f8396ab6fd97c70b6b8ff2beb27cffad6f6fa8de5aa1df1a655a6c552150dfed5488e68c4747313aeefa437f5f7a95ba010ca1c15d46f6707d6c0338313d3ca0b3de642ff79be866ab47a26ed5b76592721d35cf3e4fa3003a4b0a7517d74f376175ac6d0568d73d76f87d8b4ee2f1b573c86e081816bb6a18f0ebc565d79335d51bf0c0aec1135056157db8402400be18817293545e9b24349c65a1925cfb77d89c265638779c706ef803174c43de5ae83a9d3bf59fae14d63456e8820afdf318e443afe416f9438c320974eb6e3243399f00aabadc8a0c2a5cdafbe457924f0f1c84de640dc6047e56a5a83a7a7a8f9ec4bfddf3bd0e4a22c563cb16881496c48aa3d0736ea572faa837b2d61d36c46a2582926667aa91cc2c6212921d1d5a4dfad385cc627922500e0e8047cc735f8c7605734580203ad76167449b73ad626b42043a61c0d21f6c34f2486e5a03a094c3c8e95637ae46fb5af54201028e779b1e9d1d1fff0c9722d96938c66cd0a5c01b1d97c145d90e823d24067555e129208897e016685a0da4c703fe7661c7c374bdae24d304ba0c876401571986f756e82506ad5c387075957d1bf92afc51b0f6204ffcae4b3267e13b635af70185394c473ef8ab02057de8910c19c7701137d39d51eecb10a0ebd48453c2ad7bd7fcb6f8849f186fbcbd68628ec41b614793667beac9f46f54288972ecb2db57c2d42ee305c9058fd124d6228f06f4960136bdd47f7fc190b6ff77c9c9388da9eae4e640655a90ab759b85dae70ebbdeead53446249d4f3a7550ea1d0e1996e171844bf398272d4016ebaf8a8ba7e6017da7efbffc471ad4265b559e05bfe8c3608e4f4210f6e1174dbc65b1d2bd13433b11c4957bfe66e138d4829750f7d770c213d1e0fbabe2221a45b81cd04b6d22f4675bdf860d0ffba9a7b1fd44d624811977dc38ae3fdb53c0b81a90d32f80c1f93f64a9e7b22f8c366c14a5569d83297527dc85043b0f93c242934fd8059348906d0e9edf53ac98a5d0640276288f2f1950fe70a00b4d21afc4aeabf017625588723aae609fbee862026538d641c9cd30e8e03ecd5dedcae1896a5f9f83de33f98d533715cf89c714f4284cc94a02bcdb4ca52dd2bc2e5729cf9ef72a1cfbaebec2f5769f7e6f47b4cb6b6ed1c6253b55bc7bc40d005ca7d73335acfdf5dd589824d06a6ab7d873ed3987b2549fb41ddac327bffe8984d38cb4eacaef9c8b7ba4594ece36c5a15094569005c9f3c7ba6374cc5648f8ef83944316642f830695deb289631904c12033424266205d9575d1287fed02e930acbaf178234430850b1025c90d65f26c64269c2878a625245bc8184dc1eec6b871ddee595336a57f21ee9365cf1708f9c95bac5d887dee017cf0e7dbebe3245a7da55b35ba871c6e1dc0ea7c4b92e4466de2ebb22dc5f9d02ce93827bd7b11df1d5c35ed0a048a707d5065e107fbb7c6bace6e103a7b8bead97523a829fa39c60749806818fc1b65f4225665a18e0aa7ce63a788f3587000ef666ba0b0c7c0882c90f0415ba02a567bf2f7ef23a9d7eb83679c6ba34fb078992a08fc040eb09e9106bfae97e5db43dc04e04f1c9d75191ac1af87c01e91d78d7cbe14eb3dde383cb209722e3c832c9ab643e0699387c6f7063572a2a45a4c82ee36e69ae22766b727913813bc66c88ff4a9586ae7e297b7fc96fce10e04a53a3c77d9bbe450b347dcaaa2d66b1ab2ca379cbc225634163aadb4ed9cef083915ca6da62be2bebd7bda2fbc13b308462f87cb8467a3c28e6feca65a38661008dc53f5356a7591f91baed79d8d40b112d27eaea46f12a5d26a8747f33c3dee943783146d78d559ccf1c28272f478ebec31b99c7598197f90393fabc1e9187c3e0dfb0564a2379ba6e802ba596724ca4e4d22fb5f3c8faf0d04f8a7ef1a6504f4b3865f0d9c51b1138c907b8d7b1f510dc410ae102cdd9043bcd7fe03b0aeba9afb08af0e43f8756c241dcaf34207522e61a981ab3631a06375f31e9cc16b3d819eb09a99a9e36952baea764df5ac0ed9bab22ce2cb4a6fcadba493888f56f3c83dd5197af5f90f39f14fa809fc20bdba66985bc9a22a698f25e6c93baf5f6fcd0bf72b466215ab7754bf61068a85fcccc2f2fa017c1e71e3eb7a2e346b5b5ebd01704a26d3f03fbd35d0bc0a3a86dc02f7c60030f6fcc7ab44266c2d38b3c1f0e94230aef37e76cff66b34e76164ae1144e9e321a9f5936c6cc9dde4654a92f0ff1ca33005af922fe9b60cfc6275c0446fe02d5c23c183203a599f838f254fda09e3e95810d4013c935bcfb98632519212a740dcdf8f4ae15d872647fdb3b82688e1f0216998e2d2872ddbfe4f980e63b3a04f4c316e6ca6b08fde1d20ef907e8b6868e0d4b0a6f5134db346ef8e6de987c65fce387dbb7c4bc6da206af9b6d2573ffe7b352427f528ad91dbbc2a796ca1d9e57ac8885d74927dcab7d3d19270dde344e925871693afea025789a8b5f9d8d15f0786eab8e37edd37d1e705a5a467630ca2b119e52fcae4e490566765ab7e040ec6081e4a65dbb6b4a826ead86f9a051d70c4d9187c78d0b19c2aa3d8c50e9d82c8f6390e9a0d9a46e414509df584fb139be5ee46efa8c0ae199113b5281780bc0cacf293ab92bdb807f8191a983660a72da26b41500daabcbb50b41b09944e93d089ca441ae6cfb61be86bb7ac319cc787e41f3c10b61ad3ea713e283f9b97c31721d7c50f157a7ddc98c3152c41282bb9b4163b04f9a00656d4a1a2f79e46ac61244545d149e3aaa27b370c191e1c342413df20bfc8a1c8580104ae29206637b4a6e7e6481a486d1a203f22e3843ecb560fbe769e5d3bd9efe6ea7ef1db70505d3f8ed3c1c14b6f00af70102bc78bf521744d52a48c1b147fc31847e3bc13a5c526624f7dc9043212d61bffa83b4e48c8d2c6f1fd1d72d13dcaf692c6f864556e74aa0d753a777d3bf9cb6ebb2b6567d57c50b9c2db33f62389c55d8a36f179c332cc814c62090f0ba7eb41e34c7295e119d862c263f199dbb68f701ba903035a3e1de8fc6c5837da0eaa12a7cf454c8a9d2ff190f2a23ab9d30126ca799413e9a30caedc4709710dda8f9337a706b07703b09995f244304bb5fb648770c0df66bfe4064b2a1f560dd15027f3515758a0378c4bd8ed7a5886f4de655ad8a3d47dc5239b3ed080f2633ddedd8c841e99e28630ffc8aa270ce21382f84dfa8240d84b90c74060a1fa8bdc5f5aa9310aae53155ec17db18a96220ac41c40dbcff03dfb3742207399b1e24cffa7dd47eb60f3b2b83f72b7407b52c176101c4c88dbe6b7e67b4b480954dd239a52cdb438d77c598aa3b288dbb6925ec886930d2dab3aab702836aafee45dd2813954134952f0c1846c62198bb89671b48917e6a02d5a434c32b318cdfc824de420af42aeab2e18d7400ca44b8b2bacace1c236764f7b07faa1490195fab2767452ca5c6cae70902b3b016bfab92924f81e3b17159cb4c76e928181e3ee52711e75f428b03f5aa3ae8cc80fd7f1b1ddcab431a7bba18994a3ca644d37d0b0f0ef86eefa2fa7950b9ebfaba169a8368832735807d5d40088b929d4ba2a1883e98d13ce1cef046152eda273ea8e9c5fb4baae907369e7789c73b4e26aa6c00a26a07d8994dbc111bcd0f8c2e0520bb85d839aadbe3a95316d9545576febd66cdba9a7c0c7052d4ffd0ecf6bfbf24bca45799f0e06d35b250976ddf1a91023ac8fcf8a1c4437f81d4edf12aa8f2492bdb3ee548d1a2db6d5a190fc276f6033059381aed13cacfeb59ea957aeabce87e79ab5c5437c3d9a5f193156eb5653b2a25c48098b63980d91dd8c3a972a08fca9af31f3e26b386b635b5a3e79412d6b487ff32a7900ed11d59e4e00ba4a0c10018d19227e766913195eb7e04bddbcf68580739d44b43ab88cbac3c1fd4818f3318ea36d6691fd7c2cb1b977c1a23cc09ae03a901a95b8c4550814706e8ca8cb09525b5247543238524422431c93a591965119e0927e6a912d32544dc6c113401ccd7bbf71abea80c6206c9d051b03f713874bbe1f8666f333e3b34fc0821c9148e9a739b50121a451ec1e8a081ba70fc74c443b68f329632ff8cb45f859d998425cbc766320a93f2ccdbfa7b0de174033b2dd59b36fc5b098762901018a4b26aeb76cf2a53d7c60c89c441c90fcf94e099257f38a4293694e8892d74c270bf7896ca36a5c8f8f429a74faaf8408a91f7f952ea2224fb9815852c2b5c992bf42bbc3cfafbe312a553ae31bd9812823bb1fd9cf27361b08a8ec968fd4ad2aac79d9c7895b484facf5bb06b99b67b6ec22422ac03409dc360b382bb5caf8ad06d65b2d1520c0894a66d37cbe14378d9de2ac84bea8d49bec11d96792fdb6d2647f80e8b61164f1352f355662332a5cfa5839072b4c0c4a4189e4b52857c4112e2b143e31086f6c9698dbd37b5c1ae022a989b60c7ed7a31381454fd7576b1fc2bdff1f130fb970b09276d0627d2193861758cbaa1b2595286b5465bd49d64a604818cb4da16d1db0e7caff2feaaf3c0f318a4655cf59bcdce904492a943c1be881b23c8d78bc8ebb14cc819c8561ee528f9e1432142ea9bf27cfa880960e83d8add6c42275769c0a556c31e72c5769b4c74a75c48b0652b222406d6af205d936c511d77f164eb2ac3d83221dbb5d91539b0ff68552c21ada9ff8c0d64b05db68f4837c47c61bb8294159235f1ed634643eb008730943a234a761d877d134e452336fc7f639d3e42832bfaf52834e9615f4d18ce3a913c92f03524ba9a284929c16380ee1a549f121600c03a22836989b5dba6eafc5a7dc7b95b95088df069bb0ffa2f2c3d98c16e3c53fbeefe6969c5436bb2968702fd221774b6fc54a2c165b789a9157a7330339dd83b796c9649cf53b2990092bd88e5518c29ff37efec56925f1254b7829437ad5d8456436bf66ab57d8237d920a464450bbdea42ee586381914863cec8d8d37ac692e7d61bb09da79eb4554e085738b5db587fbfaaf5a51f395328712b49f1b38080b4846c8f67a2adb142249fbfdd794f06d062f8dd8a8bcaa280e81d11fc2d9c94fe89cc8f7fc641cca0d8e7672cbfd63a220110237249e2095a6a7b6cf06f22d3a0e28648a3ea113aad480e1b14e5941002bc26a848d7a26ff5a26aa5250df3569358127930958b0c83608393d52b5094f587b422a46ea0b87c6cbc2b8338eb7246d5774185442027c254d02e4b07a6c3ccea517b482dff05a77b34197e27a74caa95665aceb1b667133824fb2e6db14a27945c8a5f2e2c7298f56590dea902f8d409343a04f37254c5ce49ef616887fbcf5e09229e3cbae73446e15c72e4843582e6283f4f051b17fc6f936eab35198949c0c71aa8ef96ed91cfaa8bb2c1309bb4ec0e3564e58a95d53610e069185b3f0e933f0329fd36c93598fd9a6a86dac47ec8a81e3a75d65a7f9f9c35cb503bdc8c897331b5afeab0296581824126f540c3a2c7e372433f1d8711617c045252bb3bdbe026e77c7e2e3d2e603c19b4d26bdad956bb532346260968b09ebcacb2c69757ab8c6f3710608d2163696de44279da6891f947460bfe21d9a5eced1969d6bdc22a3c60480d947fa48a3f73fb844e281c12e2941d0c9efc9101cba8b13b5103901948df04ceee3919a86f9d171f9ed5b98cb12fdc54bfff4c94ffc795522b42838774825ecc61e50f4e3dc3ae3312588df98d4ba3f17fdbbad7d5f60f757552b630adbb649710eb5d02b75bb7dd071cdca3f81d61a0da94bdc8272a66113ae5a950d43a43abaf50a7bf05f4e52b87a9cc39a05a336175cfa0af7736d20b405e58fcb912d4daa7ff989f2b552c305b5d2820c4e97c5b324a9fdd860d8b9f7e0bccb3ef271db4296753d2b90a93faad30e0119ce818ec88b2a2caf1eaa558f863715061386331fd422d2b5e0050ade364422442b86eb32c42d1cd14e5d5a8d17497f1bf455fde2aa2276e1e79ff73377567b7c5cf5d09f0e8f5a0ba01b98e80e41326bba2cb152bde92c60bd0cc08dca1df93337faa431f1904714d4698714d9280e6a0bd7c163ae641ec3de99ceffb76bd3cbc7c68da79e5f0ef89a0b6ae8c8bc4ed045f5986397d529bbc7c22ce5084b4ef5c483dfc3bc99eef632c1e88345f53a8d5c44e8a382d2f12c3d616d7cdf817c91bc8846f1729f248500e57c8e73f0da8588b4a9e354150fa0ff71ddeb1fb5d1af6bae57489cce22f3c103b2eb1fc13ed6b708bd5ae37f46d3924763e5e014373d74211fab82f1ae417fdaeaf616349e28fc778052b3c34bb209f098ca563ef786f0c3e09ca8f24138c7e7566f5d514be168b1275e1b27fde9df0510380b5e2d7a788f2c02463a0fafdedce0b7418291b7f0ab91b910b0da4f651ce0608b5172a4acffd86bd12d172416b1bf97d3ac5158ab1d2f751b9b8e2f6cbe3f76aa1f8f08d65a79352a057f684511066b6f3c5a33cd7fc1c7dc6b79fe6595215f051650bde060a494702aea7560ab9e105c4e320789495b87e505bf89fa8cc1a18ecf333ac9e0d38ed6d7ebdf0f1515736f9804d229525ad3c14d8d9f236b1f04519567cc2e1f52aba9af9c15a0cc794fa60cfa056cf6ea4964d3e8764ed87454b21bddde2a2b44921992d0201f0b6da3a4bd5329863607c0b491e1b7dae7e45d96ce8a4cc176e9a15408d6d11c9a7b96e564112a2c07731e963a84b86e152c8b6235c38a9e01b1f1927de7964bfb919e5eeeaf4451df630b5d9ce1e7e15b11397bb38b26e9d2d8f7fb02bd5c77d6b28da2c786cd12a984113729ced8113e3fddb4f12937a596eb9591e506c3f69d1383c96d351f34c65b71e3e2ee3ed512698026454e9e5db94f2c9efacf3ef8a04bd3ce29b40feea55f6d1880b7286e45cd6e4a3700c60d47ff3fe8db59642f0a38d44c214d19d0aeaf622154a1ffa7385b011f8d171e4f847bbadcdfbababf5b8e03f550e5184d0926bcb5ea53548ab09f3db1e65c3c7381f1e96feb8c7c9b943cbca8d9f5460b2e692ed1eb36bfb17daf4482a5fe297e3c35f71a4a1a7f14365cc1db724429e6ee67acebb5bec31c09ee1be0e7c665134c5d55f625475eb4411d7fb17dd1317af5799c6bf7e0f3ca70517895d74f7d76efdeaed26cb6c775f9b72d7d03a0757e5887a6e8f934a2f811bb672a9444ba9b6e7cbda6f489933f5afac9a7d386f7c40c50225d5a9079a952728c55f8df5fd615e81f733b8391ce5a829005e0dae5eddf5b80d19767cbbc25c81782b1695483c678e1ccc1c4879533e830f1f466c71788ff07f70b471b8079f1360706f5599fab48a1947afcc035801ee3a7f92d4519bee7e1cb02113cb1985ece2888a78866fdbb94aa21b7998cc4f8fe3d4f9c67ca091a419207ca81d8d5813e470d7775a83fa4a7d2ee7f63d6bc0d8bd7d9a03655d94ba7e0645be7a0bf0af13847513d958e186dc3ee49691bfa10e8db9d06c1f2ad75e52af9df3c2728b0e3b76b37834092aa0deb7f2eef42aabd1e90def19ac31d42cf0378f580173a21b450ba5e740d8428f8214a5f08f84323c57996c9c9ed6e31238978dbab6d0a9613827c3b669dce109ecc32974855ff72e5369d04cb6e6f18b226cccbcf17872dc7cd118ca43a6be6ddc4978d81634cd42a03de037f8fcabd98d2d0286b05a6340bb1d09bd87125bbf5c7357cbe10e185ff7cf0e4dfbd33e3a7c51156be75d3cd45df63364aaac32ad7afecd88af505ac976fbf2f2230ba54fed770cd38997f8233469ab7bb7623b856c32105a581ac7d21df0dfdb7a51dd267d144a50e563a6200614398f5182e042799f2687a57b639ec8fe35f773b7bea038962461e83202096a10aa3143b511102e0512e329c0cd99146af629260a3f082fbb67b4bcd7c3e08b760ea981ef345ca949f4f062d8cbf6c0680282b89902b04b6192a8021e69ba12db3aaec107573cf3112f856aadc12e2369e9b88e5bb2bdde8137977d05597ab199178d2d78ab311b483cdba4573539594f3d52836aa334b47e0d81709a86a863f3a20fb2441fc80bc24f146353004b1bdd6600eadce076ec3cc1ed2b1e46126027768e97c8974e9977f26657a3f9126273e240c05072a8f47041c5a5134872dd297f6ef66f2c84c2f306d4fc8d638e4185646853c62f8b8213cb87ae0f03fbbc95e0af0aeb0057c374718d3e0321efa8e3bd58d84da9eb3e7306e3c43b7dba1a237fd9dda0ce2c45ac56a4fe013b2b883dd6c754eb07f98807bc972af1e780697aadf45daade6650abefdbd1fdcd4d581e37d7aa5c88c0186dc78895054ac7d28d2f1f37388653242ee92e27fb21bf30f2c91a9c0feaa56a77e39619c6f7245c6c3b68fd8acce43f7f87d4df7ae612733203b1ebc653e3483e27d66b262be0352d72df72b3e8ebf6c4353fe77d2f7f31c45bf38bc7c98ea01df2aa6f683debfab42662e9edcd136a236a9a25f247d159186791066c775005d73ab5bacedb14a5fba6f69302b8b193c7508c565e67ac5113a3c3fba9b11ccfe3b140b3fa96dc01b052ed014b11127eba7833316632424f5eb3e459f3468807e87bbb47a221b2cc6645ca2fa2dd65d347a9a58975ac92f03e9071be1260d841128502a87f6a9844f0f066d2f4442416b455a653ae716d509b58ccc755da4374b8d90c3f1fa6ae5e3ea292dd01b718553b84515e5651c9576c8334525efdc6c6dd80d3a0cfc7be3e7388722e5575d5590f980edbab7126def07995938667203b3c455b11b20a11365ce19bb4db94145c0b80dd0c5c045e5fe5775346c1044f6598ad4a613bdf654c852b3581c53d52f0008c10ce387787dc88310ff9d67e9c5afe86df6fdae8a3913148f9358e1cd113fe5dc1cfb4bf1916308eea25a86c9fab774611acfffa8015091eba56dc41a031b7124ffe455e9746ffbcf2a6d6e8232904a2ebb985e26ba91ceca30d7fd7e1cc1045cfedf6f016afc071a2faea49c73ab0364206ec6223ee300bfc2f7d1b99d826676e36fc9fbf074df7ea0ddf40cdc2258e0fd4d8274c5f0d7e8e487b8439987e0ea5ce1564f82dde38d378e3e9cd92cc2abe80bdb081301d4e5a3025f7a575c3731c69a500396b778bc97dea86de4c9f9551a939c748643e3ab8c846be29b409d53fff05cbca75217dacd556588ca477f844a93f7b4cdfb0fcf733c8e54a17b0e761ff3bb6da480dfddcfee7bccc4408542a3c0b926d6c9692b1322cf9debac40e5ca6fc63431b826aa10f992c0928bc67e5a741a3b244c252c581a08ae819adcf366de760d05644fc44548e6e18ab008d5efdde4b548d6b13e7d8541ade32cf7235a55b08d1a43cc6dd51ce0eab79aec9c8cddd4fe2b92d25032a20c3cca4b2d9933d828fc0e630e4c73518ab80e84344eab8fa48367f7e95fe3f3c9501307b2d91a60626c906c3d07d14cb0be47526bcdd89a70d56167babf867e22fee57e8410bd1d0a10f1622e5846296ac3ce394b9645d53dd8d3bd3aca53a8a608e9df3709fc2b87f19ee85df27fe57c7aea02de606825f21d1e0b9041363fcdfc7bdc53a4d8417a493db4c6156e570c28805f46e6437037065bf57cae3caf3c777e9f2ea97929ddd23b8f2c9da9437e5a509c8769e2d68917ad264127d42b1bb16c00e2c4bf9bcca1ac60e47ca39f589e3cd8b359b000107224a6df48e0d76c2666c31d54d8a68ca62f3334c1c5a1615c69994015cae2d98c9f204ff8f2271f1eebb3edca0d644c5124d9258e253dfadced0809144e48e0c04fbff41376411e383f22513f702842f646a2ad190342a191cecbe326ce2b1b8cb58891c316c3e64db4a8f9016ec1d2b85270a7619b70ffaed42d06172e8f1aa10efa66c2bf6e5cacbf7d6999037d74cf3596b6c6aaf453673025188a24fabe2f5b95d85cacc5d66640bcf92bdb6f8fa4052b4ee4b8218fdf69634a89cc491f8f97e9d4689c5978869a16e999e2f8e8492504f816b41376c5701975dc2286a1eef1af53092a1dafa1ee3d306d50cf9020ac0616add645011c2b3c7baabb250616db5c0b87a65c32cf6451f76576f724bdb85ffc20c50dc34d206755b899f8475c0b163cafbd63b62059cb134cad69e8f4dbae253d12af09de6f285e7eff93f8293284e731533d05f0144e9ccfb39a07a3b50367e096684fe7b375037e04042ecd9d16150cd6bcc1cea115ebc065c6b5405c5ab0ce05867814213a809aa04fdd06d506dca3955ed2dfe03b3f1614a5ea756f156914076bfbda77f3b72a1f3a1b628329e217d293b81f621ea6442e39a39343504a8fbd11f4000fd4e2acd712c43714427faf41e2ed335a6f6c14e7216b1b1d1992354bfda50c4ef0972fce9de0868d2bf1ac81c5d3ecfc4576b53b92432b21fbf57daf74f49bdd55a7c485770c96c022ca2b21fa4de6cdaba37ac8106d1a10ba2ff5f3e8d4fcd17ce2fe72ca10b5ea334b21361c02d7ec6ac963efd5873f0fc8b775c9962ddb07cfbef2046dc2648e717df3a3609862fec989c54b60ba024e955c73791dfe5a8eee72923e5337614313c5c0486b45ef7cb53a25e287138422f93b0f5502f2497c2e5d90254e36e72f1b2c1fef5e4094bf38e25279a9e61804adfefa72cd73a0db9242b7a6831d8ecb0e87e83cda559c901f60b77d006ad3bd060aa3a3beeea11c8f4afe3e4200316bca3ebc94369ff3f2e1001ec890ac65deb016ad1a59b059f3947d334b6edd6b9bfbf56001a87d6e7dac9e29b8dfab74a622d09f36383303cacf4b63c2cc9553ff914a78832eaa532ac1d39f7ebdf64545fdcc17278a951a81e6409f8ec94645092a32df29bdd0362172055b8b32a4e694ba48151be383c198ef858d9548eb717ffbaca14c79c2666a93bff7ed3911344a00d18d5e5bdfe9cf47239b6a405109f7db4f5850d63182bdbee58fc8fac0596eec318f19ff736b3a29fcf5e5c2001b53c9eb6435d6d57cba71db5463269aea1b7644c64ee0a8146b788ddf4b1f60b04f48fd7ef38657b4149b6586eede9855a98e97569abdecda708a4702edb5fc6d93b29336444c95350403f24f390f9abe848807a27049ef9abb848398aed836f6049035955ac17f83af898a1fbe5b83f8d68e8571336c2df33f20da4f5430fdfa0a3576ce788335a140d0dec8bd63b6ac71c38c04f1a822b5163714c6bf9dae40214489dabb32deb6820bffe8f3d3b8d9c5eb89b6e4ba15f9e8c6c6eb346c156cccd56721ebcb6f3c564b9208e18aefc14ed257cff9fe9a4f9ff44b5f0ffe7e0c1403f9af2642337273275f59f4ccc4be09a776cc95097de917e113de6ad012da168d38501b745f9fa21b1d32057b8bad706213d805b0fbb44295aa5fc7e959d47a9a69754030f659e918f28ec7e6030c90a718f2990ce2989cdbb0c2d16565e8256c7e4519e1ce0468453d93122f4c9cab6b2f99672c7501651047a54c2e3a92721c9af7fd7cffb49412be4c26f8fa7375e9c241c7f16447d390112330d38274fe8d5547df9d97349a54957e6464fe15cb72874b3f2f5445c0e274500e94b36b7574ffcaf87d780f36977f28a03955bb73c99be8df6032bc3c86cac86ce92ae09f0499e46c92850275d27533ceefb8845cda1d4cf866216f2bfb421ce77d93603a439a30e2eefdd3f686254f62b668ca4eb23c07a1826fcd4613ea04a537c7c1b2862c22d68b89dde3bc40299bd28ed72a11e5bdb96ada0acdd4770f4f2aa0bef1703e873a3b030c4b92761ee5c1cddd9037ce2b8b168707d76a7499109f047cb692d13c09a44de7e0c67e1f8236ca84744c040ee5adb3b23bdcd1f763e6ecd6aed8a67558b8530bf0a727d2ad20a4dc23aa7b56c8182676b0de3542f820589965aa1ad09990a40a67b55db11a73a646f7b669dd4724a5c3a532fe21852a7ad80525fe287bdd676bb6eb05807012123c569b398d04afd9b0e548eb745c9e0b1b61418ecf37ebe03f9a350d636a55a42f96abf895cba2de61cfc2e4a25bc292f07db22269d319351febc73d3f54bc870c064e186727e8dc977fc57ec89432b513c9e424747c2ce3e45ec7ee9d70b00b67688afd1237e70dbd22e8d5369b24638c078de7744efe6f682bfe3c20b26f9e72a6cba0258026c8593870260c91ee096d2bb40146955176f496e7405866421d0f51f8a8ed3157482d67b12727f1c54937b6d221e77ad20104b58703240324c8bcebcad6b1a15b03e35194703ee943884f86b9dd1e396b32297c93e09e7f609883ae9787f468b83cd91f12b97213f9df16b09c14c5a41e8770e5d41dc73c63d42088a771944b6cdcc9e112ee753d499f0cf1d205f703524c7ddc5f9c8640e1fd3008e9b434880f95aa14952b7cf5a358e72835b028a6accb0c2710b5fa81d850ac89e5732add0ea274867d7b599763fa7974c9dded4bd2d3971e1eca3dc9837de1728c234bba9789dc96beff3472db084a2dbb5f4e6987f3529df1d9425809d528836c1790c0d48cfa2ce7c956f5a0fb40de865eebfd773a9674ab0875153adf53641d349804543881598a4dd8500c8c45cdcfa343f97f43410b59c89db8df553a95a1265c19c0b9c0ae7302bfe69d636aef57afee25370d9d4a52a043046d0fc464c103554a8b85b421292c729a09e7985e186834e4c2d4e17847e2629015f00da9c6ea18ee4ba8cbf717ae177b9d82ef65db2fe48565ede852339dc188ed0987ee9258307fa3cf925e81c10219ed55c9adcfc7b52be46d217cb862d480d1960a326b4780c9cae5a40abd43cd0266f10e86b93b425ac74fac03911edb2916c23a4032be5759d0de7f19bf16a16033e85f3d3d02288c6ac5089f086ebf10e5f51b272012c45034b7d252e1d80a72e755831bb39da688880a1b4aadbac2a0de63f2be114e3182a1e837e51d796129a96c95db373204fcf5b0695fed319ee8942aaf3cdadd59bedb9c53fedba1fd7ea4ea486ebc89647085269bbecf536e60ab062a485703540cc16204894f348bcc19116f548a3689cf0c1b9485c10b105540d4c4c46da57e44a2533bd382a1f45b6f82f033a91b025e623234f103d59232bbe28c86bcc1afa195763dc8541ac54fdb544745fe9146749ca13eba7bcd5bccd39f3a23d5e0219bb0e0e4159f90e7bce7217fd97de3584579293afd3992d84be766544eb6f4dfc99a5df8b40e192aa4359b177b0f4c78405173e74b57c93d1f58bcfc0b98da6da93da4c1aed3c60df8a06fe540677f0ec0ed792d6239651add9d9d0b7c0b1319c72d381f72330b7453d5365286d4d15045d22fa6046bab1eb606ce2f075293dbd4aa6789a07d2f1d9d5751001d2614ad9d033961ccca9141b70a3fe746de55f9e5d1c0db6bae0bd11808f4237a082ce314355d9db2d0346336a8b05877719ba27460bca35b333cb3650cb95de56478035574478347bbc0663c69908962cdcd4654c7402bc3f22391c0194b0fd85cc772a452a44497bace74df4597c4fb1bfaf61bd0986e958316d578f30235880455dee29c8cc21783a34d96e42d8dc1d25703813872846d069b745a06a6ec9c1de9a479e51b2b24e32a6ca5f4733792aefc6eb4f1081a00f6aa1c4b4f93cb0278b21995ea92daa268c71fa9e12a725cea45d52d85b9c2c4776e780f738bdbf60f1578c6f37b6e88894c2f5702554c101bd7746e3762ae54dbed5bb108ba23b32e21d274a7a58b58ce85100f85fbd5a56f2749040159ded988c7f22589269bd380cdb4c83bd41020e49bca3450813c8f1a9edac858668fb13aa072ae80528fce8de72641b392fb7c8f4c15f921d306ea931ba80b5e65767329154e025629ee1d69f31bbbba97ff7389a17e1b6e50ab5b2d249f7a599e33b4eea166764db0dd1cf7d3d056c9536fe59199f717c265cc12596657e37b8ea1759bd918874bf6abaa51a9de2cdda7919c73f1caffaef99c2e0ec37e5f084b17da482a026a1d134f42b39a8452b8de88cf1d89ac7efa77d8c37282b5d91006cc715720c54f3b0c5dd47864d4d77c6f134edae1e4a6245b0c8029c9218da37a348615ecc5e6a12a91ca49533f01a7aa7b257bf2217f4e2f31e1bd8f15a3daa9ebfa0c83f3da5ba4165eb8166cf8fc62fd7471e489d74708ac57ea89075ace046fca05c525d860cb929ee5f2ced215828b8a43b8e73190e812c6e98a4d4c41c3e85936a47440b96fbd66a40084c5ad055a2c5a029a1a3eb548e81db586a9baeffc304167a72d61789490ece4da1dba649b718e93d6454a41bde9e0e02be9926e9c8f7dc7fd964dc4f24bc4fe3aba1146abe42006014e68052b6d65f2d797e9b91af788764110566437c8da0f9ee100be65833fcfef41b229cd15360b234b23d2acabaab80b87ecccc04442f6819c8250a80fc4634e8290d79c9dead27e9da501c4bcca253d38269f4b9c7255d427936dc184b131f52be28e03810d74c77bebf97faccef6e3a4cab1988a19d980f944118c7f7b5ec4b670f62924510fbace2cbb57c60fc126b2fec55127fc89c0257dacc42ba476e5223cecb0b408b313468c162b6d3665f6f71508451e9f82d672d6ee9b46c54ee0cf5923616cc782eb0f5900a2a35e5bfda2c5206c0f7b592c2c6d7df283d7ec803894efd9d2fdbcafc003701dc79356aafe9a58c22aab0dff3b874de8afba2eaef57d3a8bbe8d0942e2fef93cc6cf431d2134c53c256568d3ef5b531ed79fe71db261b8cf7d208d3ea6064ab913c47f60115bf6fa3ae8db3529a10fbc553776d8a66f194f0aee205edb2027589570440a91a7ed272d8941754aa14444803479b743937a482a14c3abaa9be79c97b23c7d9059fee736c67aaf29803540ec2d6ed9fc221a2a7ce5bd5c2a7fd67b70055b3f385e1ba18263b73ce0db433bcc0b982e5388352fb2b28a5f0769799bcb2fbc606338effe4e24144b9194813944745638d1bc6deea0ec6fec137c55c1334b953ac5f8542bf30c633e8f09f197462b0c2491a0e5145ead7be997468ab920850e53095c51bac91f85f6b56df40d2de420343d9779c9be6edd30b19f796b0dfcb7f5e0fc653f49726f678f642508ed74b01cfe2d6c12691fadbcf41931418876b0938cfe090342bb50c43386577b580716a29a8e263302bd018fe043b556255cf48ea14d8a4af14eb5ffb1232d8404262aab3d7cabdf319f437c96fdf06f54d1ab954b74c4914b370b84dcda6d254bc273d92d471ee8d94625abdcc393cb67470284d4188563b7fa86279a0db5eb4faff7d2f5450f61297ae7815efa16f5e2ae8053bfabc462338ac86b0fb9cba8bfa596ecddeceacde4fad46c8062b1cd04b9e4877af6caf6f9c51e0146fc363bdd6a97879dd1ca1afbe5bc92cff7ca2e6eb74fcedb09f7f3db2155b518a2f44d7655485e35a57452eec1582a308211c330297de78c0a17d6785ed6b9c932883c94b486549f926aecb72b04097ce6e49f3e90313e1c9328c6db130960b0780a5435cba547202eb5dbf00bd53fc79a238d89927f00dc0018761322fdfc7203c89717506f06c53cd8c25dd5189b8a5399b3eba71b1510ffe234ef7afdfc838bfb634dd17a4703131e2061720b9e0862d57821f81b5e480f1f1b14e9a82c27eda60dc8fea37088976a5b5b63a1f15fe5ef3c9798ec2c1b0751d7641e0c9475fc74d6781f4d308451691a71a380192d29008784bb8de3c80a7f38f2cc51586df7fa7d670403b944e70cb8ec0527d014b14aaf1c89985ab92323a00f25c85a8ab597220f3b837c75d9d66d8cb95ec1c799ef0014c4b096d9256384c6b02720477e50c9d6a8d971dc6711a01a19c4b0c2331dd431e131ee68aa8dfed5c4a70fe58a864e8c7983ce434a31ab8144212982f679ada6dcea10a2d7fdff14fc6640bb896007db4d39e11d8bea73a41453bb53a89fe56dcf0d004fe151a28b4bec94fd12c8fe61510461f00cb0e352dbbff8a7da678f6b9a346dac3505cc7c4f46094ad2e329d780fe5b521f6dba9f3378fd8d441f7158dba40dd5a40129035fbe1e1aa7df3148a3d22c8103fa915f8ac9c8c1fa2dba5ed7da0ba9199f22af07769c5ad780181bd1fb237afcb1179443be4e0bd9328f043a198e1749027b3081f320ac83e2165f95c6816aedba818d5a99b3c8458d68510e80e99e5f31862ed373f9081c416064bf074a47b10c880add20943092a6dbb3b9a8f37357e61591608cc87a98b2806208b08cbef3977f68a0723e4685d3a30cc0ef75faeca3e32f08c658646bad4c2a63241a9b875ca080b3b0b6ea6ce3014d736738ff8236859c9979b0bc64f580d20e696439c1999d353a58e5a1b920e27c24d1631e6f7953d9ff23805a419dfaf6484836ab4c7681d8da7d951c3bdc53676c3a57fd382da6fac3641684563cf317b256894cac4e89eaa94cfc1b87b5f279b52c935ced47766c708361940ed02ed9c8302c696535dd7ec38b2fe1a0f3496525ab6a3a2cde36347ab31e11cc8b9e4c49ff36085f7ab4a4f114dafe90140b6cd66ec101511cc9f681f866afd2bacc71dffb94b176976473632d1fd50755d5c70d3513785abf54d83d6e85ca5521b5e766974d0319d15217256c114f66982d4e3972f365d542b40e67d25ec3372b290dd535826aa301c61b007929ab6d1a015a8bb02a8f3b21dc781b8e9c863b133e3231e31af84edf79c754d4f148719f8692d4cffb2b8cf7ae910dae891e03a0a4532aaef981ba640164044865e5343bdaa21c6f2cb332a99bf177774e13d5b7872d927451497925f1b2c5ca9d1b3b79862c539b864ddb864b2f7cf6c8ad6f5e3c876da8ee5c7a8fcd220d7a616623f80c6f2d72ce854f95af142c5ad8136de9614c764d443e33578131e8e2fa34b5a81fcb840f080d685a695de786413f5bc1558f7d147c81372454f80d653144caea328f17e86367529b673985ca6f15672637682234056b37224c5c0f6e954a780eb10c484c72c25a993deb402478917fcb811b3d1164c6e0cff5367962f18d651dc24cff3076b4708061f1f106937433200aaf9e018224ae49bff50956faa9373cfdecc86322ffcfa10f7d5f58290727111c33053cb17351515f64ec71caff745e42bf15210cd5b359e4d6117d4157c42f7f98410d62cef9441de8c075c3ff4d955578e0c1419b32fb36592053d4ae7a2894f526a7177551a662f6067ff3c75076e19a9da4f0aa02457e545ac90c5fb0f2b71272ab9886056414dd18307536ae00f676e2f4b663e724f85010bbec0bc3986921523965c240bc67f30e0e79cd2d6774bbf3ab9b1f63e0206894a2d039decc3a00933b24de2308873acc32151ebc4dfefa417080a562a7dcb592e7a1135a6b6dada49f3e3af146c46a3828adcf9d0fd0f1e44ec41bec56da0252b164aa75476d8bd34a8ec3bec5dab0dba7c1c9c1877e4dcec5a69b12181957ff8bd438ce94e9bd0be560b3c52973723c10b93c1bc1c8c761c3d63bc491cda2e5a74237b00cb75c171b24c28fdaa0b9658705dc0af5ba932c04c5d32f1c41cf815bd09c7c63c923ba85611162065cca26ac718d6b748cb5a6857135129f38b00a59a73f83519625f37354a406bec673ca1fc3466e6f2add8113be1e50675f176075567b7f92319ecb3ac009152fa7f6a913a422165b204f372c2b34fbf7abf572c5e2accfd1aa545a81db63e2e6ac6ade9d9943bf856de34547496262185f839c18a9881a975aac32ddacd684049f810f2aac9a70f0bcca0c078f2e20fb50d082d348ebcc6f3714df21f320978490a223eeb811f2dcb4b287019e274c54f6037aecbd549eea3d5055f7e73d74718725f1107a684359f336cf9f29c0e7930aa44616cec8e3820b9c347fa4628559f1f5307139d5397115a6ad3187e96aa1638bb9f26fd12340ffbbd2edb093781f1211320d2909f5e164ccc9ad2890201537bbad76584a24bd67c27457bb1cf4ecbbecde688d295838669ca84018dfb708138a95d595b95248802d5862f7ab131c4633617905561e93b761a89edf5aa577f6560f4fc9d28a9ecf6087b20fbc1ef1f9dfa404ce6255f4f695d487c89c2690d8a616b2dc594b8560b6a38c3a6730e5265aa7853da5a838ed9c1c6205826c472c3ea0f0cf4babaed04b0a66b642a03967a6e951c7db0211a061f24b58a434bc8eefd4c4804a352db4764c8ba113de18716bb82d1299aa732da7d1bc5b4572bae220bff97531a18d1b566db86bbf6e12ceb1e05b9ac2f963432f7ce8f24c7fdbcc9b53d231995c4ee921ed255e3a3757459291e44df6348ecb75ca22512c9ff74e61f6daeefb1038e2b20e348f73b67bec301147854b90a891f79270893f97b3b2630841fce69e31d710f48dcec8632b5dd8652fe466658d689f32587aa155482f5b7d2a7e242c843613dc6d3585e3e4264b235a4c9d7fe35e7cc40bd05612359f9a85ed6df274476c9d6efa4fb26f1a3d5851e74a89b45257e4577928e1cf22f468ea7d149a6958e27d397d297a1a658ab59b5dc90568bbc70442cf4be2a21c2c99ba9c843ff861ef439b1a6afa5e23387d845ad954d2c81db54e59f25386e57673b6e4d6752d64e7bce34f25fd931005ad8521738ae069b766ebc9ee8fdb28a3cfbad5a2f09119bfda057fee4a4f544d8367513b7573433524f2ff0652313a6ff17636e1dc379e6da6b0e5206defcbd59db29c09d9caa59d065534e16760f61fd170bebfc24dc9e4f133dfd1fb874aeb9b917cef40c07da61ffdfa49b6ae7fc017f8a5e6954b0139bdc62234d79e1708ae6f0879581ecaffdfef3599604a318153e12944d1b78c7abf9ee56e1142288b20e68198e996d78a221beb7532aa33f8a68aeffbca099a8eca70d2906984e5ac90984b9eb57c4ec560e356e1225c3bfad9e9a4887c241da1284d5cafb98ce0a24d0cc4478b60e86f655d0ce38281386dab04588a73cea2879863efba703e3dc0627b2d19172397b003f68836548a125220dec0dde7dbb75c04d0d89b6c3c84c7d393aac2b41ea309f96030ffb56cdb8a321650af246c02579f1ddf850603a3b77c4ed7e6773228ec76e4befe2a793f0f2f9ebdb3c2d13cef879ea01a07487c07e35932229953b24582a6d6ced2051d1735bc5332217158dfba0be4a05410dd2b4b0d9c909f5a90ae83a1e5b89ecdc9f21b7ab46528ba38a280e298f61c11db185549d2a96a36df97e8827b78ce28c5613ad8bdc4d0ea67d99dc65d8052d7ce5842c384819344537d785547fefcccd942cd0760a702dfda8f694d6790397d2da4edcc4e0343ad813fb764899a0ee2fea0e49bad671fac2594a6d4d89881843a547039c193d07b506c5d0d65a8ba8f6bce24983fad0cddd7de66a02e6bd64d9db775136c5f45f69d1119aac336f3dd3bd6a94458ea81007b54113f690352f64d9a14def995f04a8a03e91b612b2803937be68c3ba72138a3808fdf90b5aab885332616e3ddc620c4cc5bafbebc1928b4fc1465eb849ca8564b3b07edfae0009f7a47b695dd5a9781fb5db16724d42f35f19eb1b01cfb5fe6ac76b26b95d908b5880d7c8a4c1a9c5af328d74d3010b988fc5de3b0833db53cd2696e6cb08bf3bef172c660a018a6a9dd690e668dc7e6dedadbd940fa3fce34c730e6ad44f703b298bd3f695042954e97a1e2756c4c15eedcee116a6bc0527f54d7e5128052bde93dbf46d218583f5848a12d137ac71f5ddbc50713910cbe648d3f29a94925d0015ebc8ac87c45377b06c76c5be1ba978a111fb9e0c58e201dba7210b50de3e92067f66ddf0a02fe4fd1667fd938fbddddd43078e6ec55165b1dcdaff857e1c1f4fa8ddde0b15e1e4ca97febbfa00b0690ac311a204c8d667e4a068927bc5a1eb1c4aa93bec809d066cd13b9e6b26a77844c2ea84161e515997f7b42857226e27c48f2c2146785f0ec6518b79ad3441c215a9d159fed86b675e76ad5652d572e3d9269a023d457bc155d1e04d5a2791187ccac4117370ec054fa6ffcf3c82d68d2395ef99f475225f39a8e1e7900258bb0347c741794e084456fb83f39540fbd84ec63836d06f223d5ba77cdee24ff4d664f6b99202e8b33deb91f7b1c931f45dfa4a8a235d075cf8923fcdfd5c16395d1bd942eeb2e6bab0a6e093d2d0958732acc4805feeb092c42cd0f1908335fda2d18b43ec939091b901a0b7fb1a721d504cb4b171f8ab582f287f459c96fea1ab4c53502b1ca9827440f7b7fa1331637c85da0cd3f0119eccd37d412d2f908f667290f353ef63ff72039664426a78292975d7cabadb66b0ab798bfd0a152687264b826349312c27776e87a45873e0e2459ab6a8555433b7ab8f1a3ee594ad84ce97685beebb5cf4bfe5fccecd0aec1736dd9c04a22064c64591760ec3e1a5067e725cc02085da79d0719f0e76f88a08cdb2670dc866f87448b6278e4b5f7ff7eec044f6f92f010ef3ba0b83bf81751355e9f43984b6923c09c50834572afcb7c5d351933411b62c14539de22d6fbff76f3ce246cc991e97bfbb637538d771cb53f30e9c07ef6ac3918c61e29d6850976db00ff0f55f4fc9ddf0cb1e3718dddf5827435b1c44898a6f874dcc8dc7363cf57cdea5ae79780636f4b6c41e8d456a564eef55cc8a2f5011dbd7d55e27e483abc9c455ca20151e6a0889b4dd7cfc8632e369a25657a1e7f66c38f79e8a4de7abd237afca49e366ace303e50ef9c83b11d2888d562c0413abb4f16ae5475729af0c4e1d9a4e97f8121dfd11f294b09b2598bbf9e87640904e5e4ae569d1ac7ee31ccdc83b26eed4d4ccfb78ac86857936f469de29e280cb7d84850545dad3762001bf126502c3799f552357d0001f0cac04c5e78bf3165aa62d7a9766cde4b3525f414c137fd99361a4b33d620cefeba6585fd8c12103bce577671e79c3f0224396457893363d7ca6bc2332a6bef9d6fa78516d5629e4a4593920c91385c556193dba1aef34a5b0e423a78b86ff95575d986edf527b5c81b692b46cc26a7e01cc066008caf20922990f0386678d032f8ac475bf40afd873e0bf70a0cc1cfa40a5eb54808e0a971be3b3512c3984d8f644587defa14c96dc7762fb7aaefee8a06ac1e0e59499c6a9cad06c758d3af224a3b5980e9b29b748b5859f2588341d30df51da6695c11922ce3a0faa40f18ba6873206f49e870ea4bd0e6d16bd125a2c82f2cbc3afec0e4a58ddd95e12c75e8091412831f94a3cc4ac9d30006cf0a31a69e2c229c79a0f1d821d7558a8cd869287632d18add49187dc21c0f946ad5d796d53fe2c75d8ed4f36290acbd543347cb8d269402c7a3f5f314ea49e7d4cd788d4c648321d6115bdebbbf79150d299d86d1820359a2a006c06792567b96a9ec55782fdd64ae73dfd74fbaca5efd47458240b07d7aa246e85fb93165c89f1d67a3cc003b6009c93146fdfda3da35df631a36a2f599197819e6c47aa84f7f7a42ed5763f7e34ca42bdaa41dfd4dfc9b0a3d0322bdf6780f5881a7431625fd982b01a872b21cf1e1cf6496133e3046d55c38c31e842fcd23f163bef87ff0dd1689e6899b316c79ece4fb61f291cef825c3b8339cbb6d2bb164b7b04f685dad1e1d4a63ec2feb919840b4fc56f912d36ce8f9eb852832174d4d845ab0f0b493096a63dbdf02db634d748742ba9f50b26af87ec9debb374a4b55dd9e18b5b158b8e63e031d78fe70853542bbcf2fbcd400a5261dc29ccd3ea45b9a1de6f04d038dde3b0ebaf3b1d64909733e20334474f76d386b979c9c778ecb1086eddfb2118f114709a478f60ff9ffcaa68cb80d5c18df44a3e0e66c5e28d8960eb67151838381e632e565f305c747e98057b7be1195f3188974b1b0c5a47fde940246a198f6068f7ce605e2ad03f801e40461729cba63ffa96833b9198414c42b5ac6007a330d615f905fc20f9e8e69237522d8bf857d4c34a6092ce6d726150cc43e5729ce988c23a9df919deb37046a34a9e17fb898240156e64876a8149489da787fc02498aa20999de58599f7cedee5c8035990a259fe99812a6240b6f9f0a089de463837c9e9e0faee220fb0d7f812bd4b71b08568113af994f230c48fd58b56c8dfaa8abbb3417d428fccf83ffe98686bd1585b279f34bcf37deb94cc87414cf89ace6b4f47fcdce9ea4beb5a0b33550e21cff5e3606cbe877f9af4fabc8863d14cbd79a7f8d34cea2225ce9397c44cde1e22b60ed97184d0b344ba1e514d6ca617986dbbec1b21e337fd4ddf473e511bbafb2c9f46ab782ab2a816c87782588b4844636656692851750e2458145a5fb24acf1c3b8e58b0c3ddcb2a90088c3de44344a0b1e2eeb4b9e6370f9e391518eb2a5e899724b2dca4712ac7ac9ac9efaad957b237a3dca4a0531cd796c75c8b9465483c1f24c2d2311c9aeb50eebb6cc6fd879d713f77f8ad83b743fb385756959b4042e1aae56d0b942fd09e070b5efc5012fd5dc4e2f09c272adb1d2fcbedf1456a517e9806ce8af0fcb2aecc6cdaee3448b9a1b286d899770ac9b04ab110319c4f5f43f957bc881288a9168555f6bd84f9d4c83fff02d38c773333dbb7428b8acd288baa1bb40f2a1bd7afb4a544dbd648468638030a682bb28d9538f65a23aed01e092de665cfef5ba0e7d5adb7c54a037332a4108beffb800027fed984c3ea98ed494808a0c432c52100d5be9e3d2531cd99da5be7adcd4df27a5820fd78262fff10d36491798b110f427f7dd5bd46d3dbdd42d51cca55b3a67a0cee795fccd0cb6043122667b6afd82f0fa56422288c7f9de3f495e532ad7da6958540a8fd0a4635b2afd1fccf20c5ddf98b41ade1d0adfd9cca077bde2acc397e7796bb77b5aad2558db97bc1681dac6d8576fa787d6ae19b3342abd8c7961c7a535e89a1993bc8e8f08ea333705bc9d4a96cd117441a0b53cbb3c893e6c2e391308459091c48bae06ca01dfb6619bda3ec58b9096b32b202f474f8249c5d5ec0d6ea20467fef59702911c5fd9adee4eac0af1aa96f364a89c0825a39229117a4e6516cdf2ec4d4b5c7178b07b4670df5539f5c71987d571c4a3d733c4d7bd3bd1ccef150e6f0e3b000e9877db738a682ff544b8c320a6e1878723f6754c6225e6b8bd53dcf0a6c6255fdfcb7126565302090868b49b66d403e27da0619997e10284f53d750eed7377571e4452b6daa88882b8207d31e4104860bb344851c8c1101787ff496fc5a92fec610769cf53125d3ab56637ef587aafa356f1b10fb53e86d716fedc8cae102219dbbe8854cbb212504eb0d3240c5f86b516ffd3d02fa54588adbf8e4aa9169812d1c59d84bc1b846c9d904b820ba5ecb4b09d508379ec920fd57aa9160b3658334873698017d4d57c96197ff3d9a676230c4bc181819863d1aedf917005dee9b2ec766d01a12fedf71e0802a8e4f51f7891244d9574193df343acd784ca484abffcd3d79637166f4ee9c691bbaf7e0f4ca8a185f5bafdf936cb8e411df7290cd8ea7d75a12bdbf7d76fbea21a0bc290c98922484be526604a3b8a2d232e57e0b4532949f96e2ae850203c0ccf6afa452c9cdc4975bdd2944c984abebab2a3339257b257d8f49d3d7781a55e57a9f8dc1e54c0458a2ce7ee8aee9095a304b12e807d1138a05276fca3a27344c2b1346ede0d89f6254b1f5ee2f5b7ad0e72237a4e13cb157ae115ce29da6d0feec494a02757a7aa72ca243001f9fc53218642c22c4f43e5eea43bba4070ccd47bb1d4eefbc74b5d0c5969c76c8d4db06d644c949b13bdf590698630a30f83d7d211018f9b78742df6ed067f7f66d727e14107952eed4218dd9250cb5886b2a862a5b8f858a0b004775d3f45a9d114a753fb183566b9302b01f4edd0848eb3f67a7b70249a6a9af7d0cf99862577080b14f2a4c9736769016e6d3094e71588bb252826c822d79dc044c9a8a597d091ad79d8616fe77583ee226f4768a4955d580f40610021b8d06ed7fdb86289b10e067d3aefe0db4b2c5b70540f90cf8dc20f531ceebffab25f7f374a45a53f83214a06216e5123cfc1c433d40449500e0f759d2964ba1538d3b506cc4966062db49e07f53003a8cff27b542d00679f715f7c45f7ddb0649b3c579f9c65a566cb444eb880abc417465f6011b39ed00b811203cb16e271176065c2550a596e3c660603b98f57c9a731b12781ced6117b3e0a5771d637357cc2cbc09287725d66a9b2cb43f920641031135ae33dd416a9ffff434e3c101657f612532a8e49a3d9aac3848be4eb4408bd87ac2593974429ff40d2260cfd0e2c3fcf759242e6c7cd1fd2cea78e3a583c4251f946f20212e424d9c3b1792400191f0bae519aeb5a5139ea514f5511fd0767501e21a628f053d49c7a84c55ae17a475e58b0cc9ef7a0a1e4c8fdb71904c5f9af47ce0e382dad16ea9ce092537ec2b95c4cc784d75c451e0bbba30ebe1ae3a67e4bdfab026dae6a08fcdc69a750ab3593322683ea35c8034f903d37eb1a0bc103ffaf381ec610f5a9b7637e9f9b4d3ba0cbdda9f26d1e37bf021f68c523a3d8c8493a11a58bfc301bf6af6464156524aa617f86cf5748b14a0d0b8ec3f65223d9709f2c2a973d9204ed0ef664466e429990a3bafdfa6755289790ce688281b4ad9da4d7d25324de1cb0aa23a090eb3577b0c4484c7707a621ec0eb25a2a403f17e4d4b9c693ebfe45d60cf050e65e4cd28d80375d7e8e29074152e6bdb9bd3f1bd7bbca89dd83eecb75f47139b559fe87c03cbc776d0a6429713dc4c4e63d5d9f02542d94e7fc01b1c86188817ac1af09adf1579091ce0ab5d97ab06ca42fcbef99e18996c0aad0391f82329518b0d8fb7f9aff06dc4e53ca48a4ce4affd0df372d45a88e612bb7edad32978efbc7fea1aafb11f724155dd0986f21abc30e09e0ee1e988e64242f7ca4d7f85331824fb2fc9a547150c436d248c752ce5fc5e42d63200462497e6c966dac995efe4daa0f8cd5220eb33e09350df50ce69cadcdff871571e38db27871f8dc6bb66c9e89b2baeec076ba3c765cd8473231c19515b3af3557879c1bd5240adf42a7b51980407c8cd4dea4ee440736354c2268b5a0b1b7d85a564c3d2f0296da7183e5dc6a4958073a9657a9b19b7db43ab07f82ede41411d48b10930e561949cd6037bba81bd94c3cbff3788ab1968616169e9ddb83499b21264b635e589021478ee17e615c32180cb74870ec7bc7a0ce701fad09d6b21b41d72e6e290842057756744eb6dc4befd4e92c9cce8f5f21285328865f3e8fad761bcf84a5b87ada0929db5c96066121eade50ae7aa6577cb09cff2c1ee9e685bae9bfcc3fc0ef164381f54bf47602c156a2272fd186439445b70fc7c2fd395cf36f53b1570599ed10140ce3c4386ddc6a5db45b091d1eb51faa88dd2d14ceb3330a45f0dafa2d71f89eeb183ecb61ae78af5c70abcc05a2fc1ef441e1bea1f4ebaeab8bf12a7d705bf1f0999942626475ba6879d47c782e5ea746409cb95cc84f58e1ed447167cd7612ed4c080568429f7477bb0f461dd349e85c2256bb628dcdc108469d70359fabb789ee7d6d5561dfb8675d0108116a420be56ef0c6c004e45f4d048b8ae5d29096f829eb587b49b6990deda0b3e68847087ebebdaf4b9a1fe94d09dd952ee052b19378d1c1a82e498653ef1e6beaf1a92a8bc73cde5f3917d0dfb85f15250f869b1660a5af41992543b3cd998c25234a5a3d35b367c567f795bcf3209ad5313516493b3347a690c5061992933da33b26609e819a7cae7f09de2f0696d29b9099fac37e2d58cd6103625650f3d79a2b47bbab3c30ca70f9c941f1e2539e3e8b00556a4b68cdbfb9982e0e6228372bbe3f174bdd6f4382a51c19165467e999bde6249cdbc975b8a33bd06b9c8cb2a72ffb5ad5b388d17c0b0adf86d9ea6e8beeb46662768255ac22e34fb5f3d850bb674ffbb22f96eed343d95cc49db9a619288efaf1e31f510a31bdff282e68b41d2bdae4ccd81ec1c1272c8efba3701d9dcd288d4e0c3c3bbb82fffeff58e1327e783cc94e3f2234d0cd416dac6037a559ed4b34a78346e134b3845050b170201a3934ac1bdd132ac3aa1bc4ab91175a509ddb23188f33c6004a1855678adb4f58661145b560e726e2f3a86d1686dc81a2f5094614a0e9a478b6f466641225060ebc5d4ec96147a037bae25b77aa85def10f3b8f461621962125e27ae16e8a76c22d6bff7b7e05a6ab396e0f4a8b37e3f6a7a011d9e34f5168330f109d36e9ee83eb9119262e041a53eb6d7747ec97c5e0a9333212af47381bfd48657ef918544b2ce95ac17c18e29998f4bb262a7931650c4a48a6afe5f5c0b9914b5e506f8d976ada9797b78ef035a99bdec617c423ead868b414845877b460d8a23ab4ece9a320146c5f118a665604cdb0bd0d76e4c8d93e1e2dba6fd140987ba29133ec4f440d7f410b6dd3230fbc5519ff449fa3dda09ddbb5411f33019ad337bbac6d246cb946e2c470608514b58b33cb117ae6e9e21aaab7c6c73381501b040c731dd22ac301513874bdb5b7377d8fc918629ecf1b6ce9f251c0dfd3c3388ac77a954f50e054ff6533e63c5653052003aad837d0929cd6c875471114fc9aba260904a3c2b69d60bc34001beacc982df5e7f5cd904d316d39e81757f7f4c2834c6833649132d9b37611aae6a850e39b3eda1dd16cdd151e6b0ac0d3141ea400d7e27e40b98c9882b30d62c75c4ca5e03fde5beeea37147c94554f81344573dc7036b9eb12faf0c1aa873509dea57dc263d19a98f8380621c5d828c80f865fbdf48826f47e461b939881ac48aeac5fcb9f1db942a7fa3870029a72348b29fb8f6febf8756076bdf0e90e9f10d18849a1c4eb2479a268392c304ade2fc4cc4fd2488f83118898c1d39807c5825c53079ede84567c41a1cfab24fdf0dd3a33bfbd45f3b17a7ab4830ff42d039021622b5ae2ac74bb10a8f2719ccd055c7685d43f2f725179a8267d28f15f92f6d5bb371595a94e5fe1a08a7722c648182d1c8cc323c027e6c52de688e1dc919b42f7d8751871aabda52c399cecdfcdda9cd2ed3873ec28980747e854234f0b33c70657d3141003dfb9e6f651cf581f65f4531359c40b74d6f8ebf3f043d087f8e7bc58cfec3a80a14e964e2d8f861087f4920fe2f36a257c838f70423ee3a62b74b3af3a552e064770498693d905e8b0e19b95f4d0e4fff691364352b680102c1bfb8b4cebdb84c9fb3b1371b14259448323c2d934200bed1f6a5d11629017dfc05150ad63acf060ab6bee4c0192f5e96e23c84445d7cab9c151a73755befe689b5f0d61c8043c3ef6fca5bd4d8f7183da277577cc312865cd215d749b602c06ba3f6086c364eb3958f692a33d955d358b781541a1905b2f73bf9f7b11cee9f47724365fabbfa30a56d6712cf6c96f367eaa55ddda7fc0fd795640936a2c51467bb526bafb6314c5683f354f4ca7d60c735a34a292a000bdd4cd0a7c0833aa26c9fadc51f8378aa41bcaa7b1e84ba0acc8a1b22569d9c6c39a86110573355fa3daba06666f2143253d53a9aeff7b9e0e44d9f38c99c239daf700d648d755be959fc3116d17a3f99001aee4a229f58392139a88d4a3a90f5a526964f0064c6514c9e0db48ca362a8322217da4a84acde92543e2e84e272dbb23eaf56893f5c23ebb5cbd32ca7ad72d718d60852604538ff55a2a6d21bb1e97aff0feb43a5d7075f2c0ef93420c00f970d8b93c31f9abc946c327753452b8fbe7695fccf54ec02bbc6734640366d919cbf2727f8471ad28e53ec5b03dd5a310eef502c95e890f8b0272654984a389996a218379faceaed5d306419f613769c7de69261e498bd28a9827bf4b6168c0f2252ac95b5a3e1d7f669ad34dd54642f16fa0a73818f94d2ad78ac24e6745731e53d294459adac59be5cfdd2385f35965e4636db906c0a082f732f1db67dfafa7a148cafbd2a94940e9de3efc3a174d025153f7cad8bc961a469994df920bbefda680c54e439e34a13fac3267f5e96834bb54ce7adef6ea1cd75cc201dea448666e220717386fdb7353cd23b00071dfe833b0a08eccb9b5df02006567cfa6076c300bad9b8f3163cfbc923fe3f37ac51b77f93af7562c5558f220755ca9dbea0c4cf4317541a498718be589592abdcd821728833961df61341b2ee665a937323c36c85ad573d84579650e0730c4f6ede027a95605296ebcb333329b1b0d00ace768a9157387c096938f510aea3185bc0645ad9230ecc3b2d7273e1001c877f0c05b0aff317052c4a5e0ad9100cf491e5ba08201a232278525c0ac40767150217ff3297223fc61c688539129e5f04c9df82bb7d90c64168c6e69d9b56ff76f8cf72870d75abf5e65a71ab3b1eeaec7f67c2afb2a22ca4dddadc9f22477c27ddf860496abb84563de628394671b95536df1d629b156d1cd7c730b907b49985aa58da0518865a780bdad67be5fd8c1aa84e06c156b26851f586157b76afe7f3d9a0c850764e61f220a4f5c6579594665e5f6ada6e738be0f6df91f9eabb47e15e6e8063fe6da5de8e6a130172898a61365263515dc4b6c71f722109820f6e024e6f2d8824cae5298edd975c754bd8f9b40dc108bddd799f7d7817bcee72a5c450f07ef3ddd5c9f7eb63670038942a1673454875cf93a5c92a2c8c974e55e71405476226d3f5c224fc9cf75385fa51dd2b7db6e7da64b09c959a9e6a0c6bb0bf11ea9f85c05a6fe6f70016a97811766106e401a2edc94a0e13ecdf5f4d0fd529c8cd8a8ba2da7731e8dcfa982cb991257f114e059873b6eed591a2ce665214c773f4e03df2687c7e32dc8daa1af714ca8d8412c845f68700a1dfb628ea1db45a44b6c90a9c5109c378540076e9ee74126e8c7d6112118c561501b718ace764c01335709cee71644be6ff35e9d5695fded3fef3356c5e4b5a0cb134c4baa343c8ed8a5a6161e545f6e9fb1bb265354ea5583031ffde4cec6afdd557a11e0531c9262c2dcd959296c0203f2e6838b6f0bd7a510e6ec0746a7fbd8b65ff7d3588a5657c36fe2491ea850eca5d4bf922bd23c3d5173195b9e57ef9e0ec8bc89f74d9b005f41432c78093db0c474b9b181b0ee0c979bbe376f64b50ce1bbcd482a9016e9e3d64fbc47885524034386915fa6d6cc1c656d5ee10dccbea76ebcdd4fdebb90e12f90419cb57f695eeee874e06bcb6ad4febba88ca846948a7f220a066a6531fc135871ee8a1e97831936f404f39bb4c26b0573471332c0ed54f0a743c7359123e0e7a74fb31bf7a19a5909f1ed19a1a0653d533c8c9d6a7352b3676cda319a6c076f8cf13e108eba6545bc1e4eb65e2266f55455db6b03b09ee1be344d051540bb6a6cffb1b7b4ab6762880b05c47719affa526a4760327eed22955a60485cf5e02cd7ed42b290267d0b1af9b157b56767a32da344d8c43a98b40a9db38e979a68f9b03aa2828c2d7885e2fe33a72ff8badad70d708e0c9503d131748de5b78f11e9134b187c70db991c28e5ace425a56b3aa2db590747c74e50cac7751ad258b9c9375d161f8ada41f4ef3b1150651033ed62686144ec66f4fe00a2105bc7f96f40e7d25479528a751b002026d95a9ffbb33f54fa0c3117093095eea3850a117deff404ce456cdc01be2a546894407c778c4ea1ffb77dabcfc008b505de343034c1f0eef2751ad33efe3eb056e9ae0faf110eb498197be126df3746bc3935aebc6d7c355d0d2365d8be1595041f70825cb880ae12795a7f11a832e90ec96ec30ed59ddc83a7f4475e0b54ad7a16f51ae2165cfab24b6e08f5f3eba56a3bb1929b94936302f73580b313d92901840f3152ef6e9bf5068d1756b363d6072b54cd1feb937fccd685d198ff358cccad6415bcad117247fb93b9b9bc48731f3d9514c4e046e47b0470e6e63fb033b26a6440864c93f743b5275987a5f4e12b2322dcf39e135910f2c47c42d66ad5923b87b42b609d825e7f949e39271a35a7c1c42f8ab9baa57bc841c2cf636d4b6226691087c537a8b65bd42a1c216a189fd1899f5701766aef9b2a9820f051ad234c0df37096ff79e31c8425a1f9642f4b3648fdee41733a435712c9551391dc730662993a824e2f59b3d07bd9f1daee7901e9cc5e8264820dd379448d8356fea5146ca4494392452acc9dd5b7d73a222bc19fcfd80adc829ee60f3be753763a8bf480fa196f0496b60f6231b61ce8382d47a995d2af9c9c568ee7da4cedbefcc3913c08e6a46cd68659dbd1b8211c2363d3f5043bd550cd98cc9a43db6256b130a20f9d5e8667516c1392494b8c1af421bc2a283fe1c30149d1de05a3a28eaee2c58ab421a43175561ae5982556b927a574a07bb79112bfa2e3ee32d27d6634a50302510488c917e851afc76dc1cb6b3989f499a07a78b799572033833f6044a9ea4fa667826abfad89cfeb918b6619b3f400e8d9f47855bdd8b066694203b5cffc8182eb035761810c9066d7c79fdff5554b9cfcf7f8f0c2d478e9c587ed3150943fa00067e1149809557a6e84c2dcd059d6de39d45aeb492eff7bf422ea6c31188d7fb432e43b3f96ce7d40266827a3e86124c393c13b7ba942fce0285fbdfa69641ec6cb2c3e7d5525308a5390afe0393b3eb822401e8f6f67633c03d2d1e2d6d6a435a42cc1ea7938f10bdab848426724a6a0ee86a320fc2b0b4c1af05e9aa988b789c16abaf001b5036c37355f7f2e4d5dc5c4fef93b4ab2bba538ddd03104b34e2a07345570e15bd348fa85d5671f8932850f57ea8535a154fd2fe1ab9e36dbaa2f420d8a643614baa8fe396d14fc68e7a4bfd882edfbf8cfcb0e37a43f04514afb8c0468b94d8e72d276906f2000a98f28ad278138480c12f5785bb6e445d8289a197b4b6706b5f01f30d262343757cc892236bc6ca7b54d0872e3a275e165f95144f741ae4c8455e65cd7b16d76a918fff9a70942f5cf26f94ba8283215a6ca4712bb7abe4ee59c10d4889dfb791a2274e9eb70a1433d19aff4beb68c38bcf2da29179934e4ecb51cd862a9750b3c56bbb551142f8099a886a691952f659a2570cb087f29197b5a5ad52a64f88ebc80da7a08f187c181f8d81c5d613c565004545a547ef4c0fb4a9f93c3d9838a7e089ab8854101223deaa1fcbc413ffe4ea6ffdb59663796af31252f67279b6230067031dadfa89a8b157f0a7f81496c261736434eb2aca96a7f9040819707a97042e171abdb696c04884c019cd17f27f6752911d2966383a904efc8b4761c5774eea37d8fef51567c5071df7c2e2d617e5346e6d931ccda43ad8f9f8a38df194f210f6d646c41baac453c671465fed63142233607400fc0ba73645f18d16a3dfc400597fd785faa78cbe376b3612ed5206a672cb958a10f3ae5700c7a2d7debf706cf8bad78537f885345663f7895ace6636e069c66b05be2462d13c72a1cd7c2149b91a560d2f053d84b49eccd23b26c85d113310466096bd0124293c3e1dd0c38423db04f8ea440b9bcf199cdbbe0e8bb5bfcb099f6718ac8977d379529725c1ca29862336d539fa44d24ca66865d149150171baaf03cf3348f4ca79eac5139cd51ffcd26bfc3cbb211c157aa032fb789e0555637d2d74632a871c506d0955a6701a4a199d661f0c2c906a5a74f8b7694060cf1bab3523077897caf4a024eac160f1c999b9ba3acac8f7dc63b8700c3fb18436d9de4125cd48c9837d3b9a4ed8bcb18aa5a0f9d7ee20fb2345e11b121cee5b42558933f68e3e0f481289275ce2952375986dfa5d5c9a160ec8444b315fc13cb20a2831cd068a75f411ab13d94855ed84e26a84bb98326dff43a39a2026e522cdc238264cb69da850c69b51f59d4bcba117a84976df4428e4a80d29b2fe27ab4d0a4b607657cc11c1515e13ad269b04f02df252c90a021f683a8b7f00453c45c0b967f40b48d0952a84c34a087f921b72db3b9f3b2ab5bbe651555eae921734627f1762d9062d14f3010aa3fb163300b9631eb4b01c7b94c1cba8adf48696096a507b2d44712be7ac795661d4dcc637f1825cf9e75f146b7ff091704e84bf63326d55f21d103c6f92b3d6534bacf16f4bbcbd1a6cc296500a6c22465ca6dfd6782b79bf14bef85c19fc4b7b332b6a62690d5a7836479daecf8d81b20975029f74e8d04947744da07ebe24a9beafb777eff9ffdf2667001eca428a4b22bde3f439bd851296920140cc0c67ba7eebdc0fbf00f466000303fdf63c66eef8a1c9b863f2b7b9c77297c73d7aeec6629fbb749ffd922c2a30d155e055cba40c79b4d1bc71fae549f1178332fe81812fe155030b6560a040fbee0c40a3d29039ab56a793d33d401412bf7a408a2f0d72631f0ffcec91f8055f98d2d077bf59ecb078c6c9f307a9debb54f4ec2c19b3ff1e3b54f6a9b52e42b77e48231f7610e3525ae7ef7e9261f1b8a8a3ba3fc754595fd06bb5f4e86d48cd83c95b02287050128ee7ef82160557af3488a6a7ec72fe0882fc08eb8c7c773c7ce524804d80a8cdf6aeb00153c7ea3dd189a40e0f64ba8e43b80ec08259109d944d1080f81c74d95f5117ab48ee472bbd76bfc42d837a4ad133843b179e5bd115eb4a109e4a7698ba3f7ebacae128618d400ec6a6629d5289aebc3d81bd5ba5901e485df238a2abcbee6b9b475eb60019c19de8f03eb0b6b2292702e3f5859a18065415a05d7c1596789e1cedb1f7b12023aafbbbf149e71048acc12c87966c7cec96e45cd1695f736484e4b984bc63afd172561cc2f1eff21c1eef3cafe6ed6cfb428d08d376d5d396a575c4b95d963510ef0d4cc49bbabbae0eb6b22390d4d58b30fa742b283f80f997227ef37bdbba61ff9ff28874c72266ecc104bbd1b18f01567208e76c35779045cb958807d4b1d3804282933e04debafc657c3e0df2c2cd2ad9e54148052bf156795e43a91699d1a93f68965cc683950da23fea07bbabeb275806e0f33da12092a269139742bb130f6977d1bc8de2d552f9c438e8216064fb3791b863e5f50eca59b14747339a3adb400850f75943a921bd78efb8d9e4c2f5a98e1170b5ff21b6d03a1fba9996e5f5b0b7381a43a7fe5cda88bd82f7afef3de7971ca4115315d9d09f7dcdc8840707f8cbabaf8de7ab6bc31a4a6c417713589a24786eacbf2d5844555bef717602777c25524c2e662884a36127590b451c56f2a668a21ce8e9c8e31950069ecc4197e3908b8afa3ca9f0410431708eb80934dd9d465c1744350734ce7a8a657f9715f805c1089fd857e400505d5a12224969bc3e8f4c3bdc5f0b55e9beb15848e81b940f88c6013b243832dbc17fe7988e47d7c91b2f9082a65a4b55bcfb6acf312643d37a9df64a364628b3f0971d6c9134a52ea71b96dcb757ba1e3e13c494c38be02fb4b3700ea7c1483a981415a9a297e33c2574baf873152bdb06321775287a242359ef8b31a684319b049c48a2603711cc02a62c14dfbd4d7f8081055fd2d10f4a4605c42ec29ba994533eaf4080654c71a65d6e1f54b0f5a6fd9f79977cd959a4db1cb98265edb02cf77920e61cd2d8f33561a4c0b527a552440136f65acb359e45ce2eac354096197ba740416a6f14240e66bb3da12a7898eff4c6d39a06ecaa65046fd1e1b535b95a3b8df2266e55e98499e8154ab5dd9509f34bb7e35516f81304689763134828a2a730a1d87a5b25b22fb9081deb7c96be0f957755a95edc94f0a627259ca83288e1f229aca59ecb69b0338b828108bc1a04006d1f3ca4544378aa71810b0b688eae8a839b6a0c300fd1884762f3e924b8dc9eef4f74f61dc0108d9f9554a3b5f2713bb345199bb0136c5deeb75b1df424ef54bfeb69b3634304c150e385d0c621d6f54085481f931454c06401ed26fbf538320cb256abbf748028cfcbafb57605d8c59dd759461e814812a9798d2e5aba380b084a301ae84718c71bf59fd609932c18c13a74528ea421d89391fe32e5473e4cce85fcf9153ba8efa4ae2c9d734837e183094ef6ff57863705468d425fab958180b14830ab99cb4301dc7cbe4ea29bcb58580743b976609773201c5ce3dddbd0cc1d5af251265b87f303d6ae84b9d2884194397bc9e848631dca5843b78f2fd2b43c0b194337f670ed8b7f044f44f082248b405097f44654c1bcbea32fcefccba1ba8abd58d1f898b957e0ed482afb19774ff3e412c336f0c98bf533eecfa8c2edf48e7d082e7ff93cf5d17e2c521fc30fbf2d969469403187408bebf3d4da61d9fe557d9d4c2b5e1cee98c2b0cc856047c853c5e1a587091d68892253c4d51843b433cd359c8d5edb4b4cb74f82720b057fcad55d5ff9277300c60f2b4fa4460d281538dcd8a30a47acd6eb0f63a8025d4645bda5d9438be486c1b0db93bbed0abc3f026013de54459c70ec94019b93f94387e4d9d8b97ba2b6d180b82fb1739ff97bac0eeb2004c9ad38e56de4cdac591cdf463c67f3462d42236230042cc860bcc320cb141686e85bde933a0321a61e04ab90854b1fd029ce40afbd8af639a58c17da58e9864a49284e8a296a1944a02783a8e1f9e51d5dbd284fe0aa9dfb931aff628a0a5289d1afb88b7242aa58665db1762d5db5979bb0653827e9a69d2735ec136a9f64d198cf7333011676a0717655344d8ef3d7c24dc6aea7217dc1e8596b8e509722278ad26a26ba3a33122009ed0ba9de777d2a0ae594aef7b1d077d411fb361d7a9a1896276d9dff34bbde8801299b47d0eee0757a60ec7a12654156a5ea352f1d8cbedf2228ae3a6343574ef661efce0f768db998bb2bf724b59b5a3dc52dbb3b69c33342c56d522de1837d084e31db64445a479d98f8292bb478c73108f11eee1f0f796f309d0b7550e5f7f10f527995e1d20ae4b51a787db0d1c4f9389bb4923025735304234bb871b6fe7c9339a273abddbfa65ad37d68be9073991c76a69b3b27bf5dbac067593ffa704d2e3c9acc6920f4b768a49b8edc2465d9d8c144e1045babe2efc6b32f4e1a16a1ff740b64d00325dcbab9abb798135afe4b26598c856205edf5006e59ac3fb075576d2a6beecfdd5cbc92dfda9e08a0a57d0a5dda865747a99cc49f9ae7dd187621d3c4473a80ad1db3ae9502e026929cf89bd7845e2ae79af2a27c5beeb70921b3150023d6b6ad6cd6fcc073f704dd17310bca598352eafb4086cde7ea1736aff847fff59bad4a9c58b49afe45dcdf395359a97d954c82936e396090da01aa53a5666bb1440020d0b1e84163d9aaeefd6afe68b71547a9d543785856f9a266f844224cc6ffbdf32f37fca91cd04315f9ada1f1e3ca0ed7778ac4c93d5cce57b590a8dadc1ab902260c4516809cb61b8ad923c852fb592dd980d02c169dc3550560a6189d55db1ada4efae217ab1f7a1244c5d5f1261fef2af16734022c11f071004104702b38d5ceb3b89bb2bd530ba474c3e498c59e3c2a58cc8cf4d0a80c0d0cdf4e0afeb10ad9c385703e280347acebd9ed2f6436fb57d89b84e5fef59288122b990e26233965d254ab078800378e2aa8eb9aa052c0b5e4d15080adf2a910517ecea8788fca2c623a24ebae592136261b249609b9b7dcc1160ddae0e8fa48035cee3146cc63eb67331d2659771e00a1053b44c73f99163b5ee1e3f140113fcab5cc7e3310c18b061da379fadd397f92117e28da9a16eb05cb543ffbbbfec0a9ca49086e9d2d23346c2edee29edc6a68d0d5e46ca8d805b0b16e7b959d6c556d6e1980377be6f760ecbd4cb4303f99ec5a38eda6d13b498c470706562d9501edfbf24ea33394c5651d665f9aa3b47e92ac5a76ddfacd67377c150e4824572b9c4dc502536862edf3a5f24369b4fd4b6cb18cb19dfbe27f66d825ea2745d56cc85114a3c678dc2e7e51d9c9fa58cd207015e33260cb6b2b1b94e3559a78324e4a694afeaff8a1e95edb41410c0678a4a552a82b26b1d8e6d2b47e00eff8618f6e99f1103ce6960de96fdf34dfa5907f3d7cbe6b2d6ea5d58ec1edf5af6fe588707db025d4ffa815e464bae2b10a318792131fd5d6386377ae621352472b4e8b2fb632c05f3925e2ff59f9f7aa5f699cec89f7e71cdbcdc2e2e8aa02e976ba2de98d3dd671a06aff06396f726ae8b113ae2d9b8f75dbf068ec87d025a0ab5604862e50e38e4a1336fc25e7d22097e261b3a0b4351d8fac06de35e58471c01e726192052a50be91be7bcf9ce15cd9276c5884d59ba3b9754c419b7c88eb10b5b43b810675849619351f0fc6c24e8d3f523c3a937c16c2a2ccfe890885bf72227245c8d55b29d71e675e2d0101087ef348bbc63d7afb2e1e1c284ede812fac97488a6c9019d9c0ea2f2358439374984c36a61dfdf5a21688bbdbb4f39c894c62e954a11f704ffcf8804a9d883604cc9d5a122848d08e9dbb55e0e39f0cf6e4722be5ec29f242c70f3129d75c6c6119873a38096a460f633bf63043f6dab62f62261e211080c1930eb66aeb4f9704505391735bd7d6817ce460e2157a7d0ff0d3aa8b0eca76d5e34183620db80d49d5596a0f06de07f8064d73944d40647ec53488329878712f0f7d479261d12332815792494016b8f1e95afc13880832e82824092789ee1411b621a20dca59fe8a4394e0e6c02ae2e201252b8c5ad84c301faaa92f3fcaf29b5c457ddeb247f9a291ceb536cf541f172d21c46f25b7ce0aa04ec81760ce2637e669f904073c61289538208970e44db5f922086a6101019b2f196323e6f0391e5f08705076a4f3a7daf88ccf615961deff58e953fac960dcecf7aea181a80514024bcd1bb4b1fd1d12eeb90cff4506caf3d3e013ada7f04f381b1c0d875066a1ae7153a2d60516b094d01885a1665e9376ab90ff1c187a33b049c1b7e80d20c6ba7d6a436a7c44f89d65053dd665d16d2b13ac944396e226167d0728b2928d81282705127afaa4e0572cb975e8e36d214c071824997f7a095fbc22e87ba5fe202c1c0ac21faf110d64660e8e0ac746dd77ffaf98f687289e55f494162e542e727759efa4a61bdf5e4bddfdb7652aef25c666383bc32fd1658a0d474f58cac250164c7e0bfc22a3cfc616a6681fb6f2f177a964c17f0efe670c84fc99084a2314c71e1ba721dd17391ee4ec338f844ec8fdd56f0eda174612f5b6a44017fc4b747f6d6527e886658221c8ea37343db6b14a7b80291a8afb396d265edcdbaaff35e631ef5d6629e2a64d6dbc20653813b11b3359eb57d967f8c0c545cac9450936aeebd9c0bc8c42f9299f490e8fe8bdecca344a79e83df53486d059162bec40ea0cb2888c1a24011ecfe9bc9c9152c9b8c83863113368ce1e9bce162c712a54e65dd950fd8bfa9f33451f6b4a268b245162d808d3b0e35b1951123c0f9efc109aac306e05ec1ab6a9f5897feaf487f1947c66c142ab23b59e282eea427e56598c4da819d52b04cad46623cfde65fc441bfc52041b575bc5f6fce3eb5d1624cef486fc78db631419b64d2b941705e916231f782e40aca5411b5790ed077f3453441db053a5fa1b042b7b8e7855d3b42b9194d2792cc1803684e9aae1653677cabcc11884ef0af7e814fd0a4ea91d5b89ca4db9b3e892fcfc02c6110e2fb5415ba4ac3f838ef776525121407d0e032f0abc3e285d8502e6cb24cd787d05a1b3c753178ba43365ffd258e22315f6d8b66ecd1ff39f07b5713cd91154461cbe06f3e2752f4477e2ac1f399a804ae675bb75db3c201d04bdea62f44c2efdcd96e3602eb036cb185a226b0485ebf7ffeaf704c6993890b131f7660ee2f610709a0433ef27cbde22c334153762b3ede308a3f1c1b3c336f9f0a9b478b636162b933fae71458e9871083462c0bc342de905887cb6a8df4debdd9a08bcf4e0820efb52cd36055ee22269aa9601ed04c2578e1be7be561cf7d5a43cf08d07645ca4bc85c4d80e87d2c72c065f7ebfe433047df3ecaef8ff871326f8cd1cb99af800950e136525a8b1c30a2a7f2a0ab33c15664dc47e67dc0d2ddff9360d8e8543e96f05221b70b956994c7318c5e6a69452e9e80f109a3acb170a6cfb2c97f543b16fadb4739756a2b32709787849feaf494abdc75831a445d8268dc52026c8ad9303b2480deb790d16378b46b487687aaa7021947b68c0bf1b0e8a81567a9e267099ddd95daf8d01b028dbb3b2256335125504727630a9f7cf320ab0cfb3022407a3d68cea4097daa6307ce13924eeb7f829021dbc7e9643268a32d1e8f28a963420ae4c83893d481f47d3f2ce0c4cf3c5b6a8d541e4791e205200bfa51e0faff5742b4e83a9aac461b58c0f17833f4c4ac41613a7317ae5c42e3a12ccae73178c99512e6a503a8041fda9044f30c0d15e443116efaa6fce543bd9fdec57bcaf518a794057d64a210b7efcef6feda4d859edabe84616a098d742559bf69b07643e74dacd9d690569b083fb1b3c0e2cce05df02147ba57c0fb868a0e0e0b73f4427f091afb4f5ae2812a97909fc027bc6babd86d664e0c69a4b2e48cdb9ad3bbcda08e55efdc46e09fd33807916f81a5555f4f9c4702ee68e051208e6cae7f568da4149acea0221cac24b9b163c696dc48cc23ea93273bea160e8db6db2f3e47d1cced07a46636d9babc5067b989eca8c6c6ca27a42ee907fc58660ef82eba26baee6a980de117a66606d107b6d7567345aaec8b9b5be99e10ee9361eba5d81e3be6eaff21b5b3aed447948dec2495643dab13115125341aaf4dfccd07e827ff7fb7e3d0bcf9008d6c21017a37dc39336ad71f004ea6c5ac7b85efb86510db781f2c8628da7299b2deff0f2d10b55425e719d4deb75b715a504209e61002de59639347d069776163341ea5dd72b4bab9755cf4b7594180e9536f8074154d7556db9946eef45b0fb4159eb4ccf12b9f88876a5f4af5b80db785481efc2d02ea1fe95fcccc31bd692460ec5d33dac8dadaebbff4f6c7c040c8aa0032025032df3afba49ca5fc3d6e190b6a67ea66454eae54518256f49d123f7f5925d85a2dfe2bd445a6a45f759dee75e6d899ac720b806eca6af122b005aace73355668768581883fc1c7c173aeb20f9d156e9639cbe930760003bc7ef8193d837e4f9b59739c1989eee5764fc9d9156a1433bae1ec7ca308379fd1e1bb3e23f4c573376ea0174d48c602966a557bcb0f59db19e0ada4de9fad6c9f474812aff8c8b881e87fe19d7f964942a0dfdf128f564ef136589b86671f45d7b0826112705bd68d27c084a27b19f3805e66dd4009831b4098794ebb7b0a3e3d18602c87ccd7d075fa50c0ad2ca1341f0d3bcf893f9b42824604e07aa88e24e90627a8a0ac4cb35a8c131678150201251ed9046e015ef83d06c8e30ad0b80d5e32c4e47d0533a6c72e26047ee0412c9cdc7fb422b2f23a125b55bc6701106447da4c7031990ec70b29d1d031e253a4ffdc88cfa701900a3d0bdfe5a44737d87adc5262c3b4e036d50873713c587431e7254db0f831ad0d737979b3104d1e8b8ca1b9473c27fa243b0e72c1b3cd0aa870ce4dc031728a0ee07699f85a1bcc8a9785b94d20c126b1a8ae3d780ce4ee1f95ea339ab7516a52ecac24a6fcf33fa5fd942450a42c61a31647c35f27931913f58a490e5b2aab886abf7cf9fd7de7cf9da2d72af98f86c683700039963c7326abf449e7a6ad2be629a8c5290ceb2bf1837f37bad2dbbfd5473070b244a924822d363fbfa5a1130a55d577c26f669e03493818f05c9ab068b0414fd3dde2dd2b97ba26c2d8f9ff6c2fb35a2095dc6064d144da5e84654b5e3d372212b79eae0652f7b0b53b5b3d2ca4bd21ebf81d8dfb1f1c5836d29faad240b14d758171ebcf979151de9c080b5e273b9b868bbbcec5b7cc30717c32a26d807d79875f316fef3cba8b59487ac860fe3431c181cbb02ecb0a0ba03a167986ab0842c4e9c9ef38ae996f5676c9c476b26aee037ab08461d571f689b898fe1fd94a3a4785c4c7dd6b332ee60a69d9d402e31d7002b2408a2f5cd1c5b166ad9ef6294e0ff1ed975a37f4b7d7a76b4a207747308a5e76dae79568fe31e0cd719597b55766409dd945b226eddeb38c90e08d30cfaefd6c091efc9a79ae7dbd7f693ce94dccc7954b1ce5d9c6cbdfd7899a297909ff24bbb5ecfd7411152beadf9e6b1125eca6c6c5ba6faf2c8bdc78336453d8e1a0874051214b5415032f88146f15af808dbd631352f3bdd9912ffd60160a11dfc688efb223e2a2bd6d050bf0b4e1a53d3603e92b126da9bfbb111f55bb63139f41e9244bd68a6b94f5ac41fce7d7ad56c54effeafc48d642b3cc7faf3845c86c5b6f9d198d54a1453f2acbcd080e2d731a459b5fcb71f1a27ae468f22b395f671ddd8ba4c5ab2e45918a4c10ce8140f7d26ff6ab85fdd046f318334468c497dcb1e5e9b678eff87789ffa664513facdc946aecf226719c11d982dc20be4df50c5cd457d5667e459a75e8b9771efe97eb23fc74e2d5b9691c5ceab29788412e79f27833a478af490d69187ed175234e5a5e440973034ced46d2afbbe049b1f765a25cd8a6558e3ed6b2a204e0e1646abb17aaf7b04eac5a0c8c1ea4fbd51547da1ff4a7604fd77c4b23461e4f711a6f3748b9865be5d163be8245bf7b08a8b1bfa4fb4ffd58df51ba2c2db620ad328b9e2d5022b99ea7bab253562d5f464eb5cce1fca34361fb93e008a731500c3b5a83d4f4e539e27af8b99ba1c521102e2c8c65bedff3ece575b5b5eb3ac8ca83f8221d9b1899fbf68b0885258c7c79ade5a660a24fbc9a74b701414518011b4b5804c79acdb9eaa599db893d634ca408ead2d20f0513a59190c94452ef7aacce705eae60aff7ffdfeb1d9537fd3dd7b2e6abdc8000df9f896f3afdbf427fa2ac8a784d4d53ff88e59735f312131ab8342ca855e6044e5305877d9d94c98008b81a42e9963ad0ff61876dd0ca74ab65c38bbf7ceacf9fbd2b66cbaf21de9fa88ada9fd1cf30f6dfc452857156c8fcbada5944a10777e102c893c1d5d35638bcb6558b8a75fec69fbb54aaf6835d2472f464abcbbd10de7f2674ec618f2f47fc4447d688fdd976dbf68b00591d7a67a24429b3567add0d5a0c2faa809d4ef8725ae66b372108a4a609e90f3f18ed67216dea4452b86f95f4c234271c40dbb4bf2642c7ea0a8c112f4c55ad07d388ef658fb893cb76da4b0c5a9bf9507df6989a968f18c2a27e48c4e44fb7717d686987534eed54aed60b107311e5a4683c7666cc5a0d8ccef97190608ab3c4a419e8b09f31c2e07fd78598049fa9b8547e40744775e246c5b342af6a047e8f1854616952cfd61a74d66aebcbb8fa4372ae4ed91fb781b6fd9fb612cbd6de2d203ab67494b311e84cadcbf6137df9d89980318c7cba6cf58fd5c7200aaedb4cc7d55a23737983fd75425bcb4772f8475e00767b2b24eae4fd1699a07788b2415d25b2d4777db4dfc655295c979b2950605b27346d2a39c9a286c5b400ecb48e9bf31a92c639d00d6df9ac9d3fda9cd3a2a304d8921be1b6de03440b6353df53b487f871801fe993182f7576288e529ebe95a8e29152347e1d5ab29be25167176f67b4b0e6a9033207817b90f374b7d02b95ea08a75c542e9d45f687700ea19a4e9fc98d23737b708f64de3b151cec71e4f4eaee31a5cf941ef0ed105e7c1c4816b692d9d74b8c231007a74758706d1611168f5fa5fb996d55f6e7f28b69389c4c7911dd602e970a212286d36cae9d7d1ef623029caa7b53f82a3b4e181ad522a735741ea395330c6d33793bdb0a75b08735184708a8ec59a3546a9ecfb07829f29883c8503aceb6c1e28d8e4e7785fd1e19fac3604a63b96609f26fd5e584c5ae2dd20b6732d657d059fc3b27d147960ac4d559beb66b96bb798bd9845a46eddeb8cd56cb451261adaac02a5ed0ed2b67af43a5c17f60dbb071e9312034f4c192162a34f1aab57d324931e84fd5099d70bc870db49063173573585e4d3a293d85431170680dd2bf8d6773e9588e51fc2b69bc1d37f44011fa44c75471662a59891f5a77be78ab1af8c161cc3d9c38b831b9c3d242f096a2f9438cc1493b16dc8ef2e63546268e315a619946bd2ca5cb32a1634e1df54ed7db34278bc22f0ce23a949ecdf54e543f7fb6fa4a93d226b2aa27832c8d1a413c4e64c9a40ed84c1c64626050e115ac6fa146075488d25b4a1974b1476c7f0b37c6757a692350956b1519a9fd4ad05dc9e38fc7ba5fb7d60f602584f369e5b490ed68732eab795d52fa4fd41bfdc70c1fa6760856a9197f8c2fee1ee8084ad1e6139d9572b5d9126ff969471a18a9c8a46c6933bc0641774b1caa92ff1ca61a5c171cb47d24930a31354ff0b9354c1ae84a4e3a875f7c4f9e807ddc5db261d9c415ea5216761d0ba9764581fe385f64901910b15c7bea0bebfb3a9629c9ffb3e65054008f51102e52053ff44a6228bf62fa66334f64cd3e802326ede41b21691b1cb1c7baaeb7ce90b1e804e059ff3d96e20b45000dbc977fb19353b60155c202c63efdebd03820485d823bc6138bf02f0314c58a761cbcee27856fd4a067538ee0b17349c60042f77174241c0b550f7210fd752aaff44ce3029f9fb2788d5c4a3f50b49192d618da60bc7c058de5af4a0eaa191cde198629089e44384af92cf893b1875b9bd6d5d4cedaa3a86f6e2bf0fc87bfc6f3c9caf99262f86d5f90882f50d9b4c8845293068c872002e0058a43709690be0e2ad34c23a7336376e2201842ff3235ed971cb27a91c9be5eeb87d25745014fa303131ad17e561c1008f88b203a05e3f03a810082b712929bcc5b96068a65480a0c38f29be70e565eef489f65079450964236a5efebbd92c0f846656c76080349e13d75ebf96c7d53c0723f030252b0ed8ebb1dcfb7cf4baf8d938117a06192e207fa150fdaecc3dac850d4b1f23c1d3c529fd95252efaf06050fb98cab014935fed52d61d07cea48b93bc530a26b54497a8d7fd355e22ce87fefe5c34d3768bf64856167c783843376d30dc3d783c6745a87656fb2614b1656a423d7adc884c3f5d0fc1dec9fb67b3b15d468db077d7779161ad47f0bbd538f3844ddea40529a634b30708b84b4811ca0d742f99f17b2d368b85ddb33fa993dbd37bcf9e4e67624226921d96b09ce636a367c34656b6cec31e98605def8c11a7e7fb3c2c940c085978a72a3aeb01345beb25c47c8438f3c7669753001495aee204240700df2b64e44b6add38eadc004abcb7c3cc0a5d894478414858d909dc0911f325593b9b895261221bf3e2f4310791884347032db34444c5cff24dd2e77b6a537480bb42779b503ea3aa0e998bc1257cfde5f445532181eaa6bf78a47ef3b114b0eb7be38c558054c4dda0da9c5b5dc08f11cf351d8f65e8c26e374252287ce725707a32171a2bc41bc435318d8aabf833328fbf208d10ada81bedf58ab6466ae21c3f81bf8f4cfa4fcc76e64b96ebd260c8a02a89b21f6074d9e43814df4116541bd73d9f8226eafff0892dfcb244f540a5bd43c39644887f93d9a65cc23f9c98a9244019a84a85c11eb2bc567fc17a6774949e1e52608b42651ce4f88dd18e4c0dd4d2e4def7ef42b957423dd707217ac92085ab3d82578be650ca490918cf80dae74e23f8184ce522da00d730fbcd45f4805bdf2d6ab9c690f7ef0855ff1a0135a390b06859521ddfe079e00d50414631d3031076ebac769f8f654995e66299559857c623d4f0f7a42842da147bbb1be3f6d9c5a986a638569143af89d3ad70b6ed261ef94c25af51eddd71ffd0fe07c104686af20b2a3ba5bdfb1250144568515ad6955ef4f196ab7f501fded7267ecc849ae5f7c5577f2333a052aa63b4e583125f3423f80fbff01b1e127c49f2e761bc64117c375208e5848512599907f0cea0bccf599a7ad1b8f729ed41fd4465121aad16aaf2468b9b9c752f8be24330dcfa7237149cfd251f909456e9ab36a655ddcc740751cd1ef2e6c5c119d2c75725a357f84d0ae7d4a3eef6870b6a40ce014b7165afbfc080da86eceb8c4ebbeb7e958e226b934f3c40dea3a176988ea8e180b2004c055f8a80d8e1f6eab2a760baaf62cbebe7827cbc9093a30b376e951a444faded838f2bde0aa0f2e5ecc3f7bb51fcf186bebfcbc8542b8330537f6c3f9eb863ea0baa8b06cd69e33d508036ea2f1a93f68abc1ef88ca8005ff16c15ca5f0b41083bf0068b83b49b563ff07269011ec30c97b1f2d06b415d7038339773cf08437602736ecc39967cc0960edb58df48883b647a0dec295a69fd3670088c6d7fe491fa857407b0d806cf1fc6db885268e683c5fe683994e72cedc3596aca33fffa697f21984b62a66e06b3bc4eacd49041fbbf9bf6aaefe9142dc32d1f39aaa5162d5dfa7a516b5ff49ddb1db01d707db012f2f97c131bf1bdb9cda6ca570bce7918aad66a2a8a4b2d421c19751b77e92e491c2412670b61450c1380101ac40c636ae445b3fbe3514166c6ecbbefcaf17a040320c7f9ac742ece834828fedc989015d9e1407f64393e8ee0dd12861d216cb04c4960c175cd2d04722be2484d9920884852f748b8743cfcb7ca8efa98e375f3f97163fe0007eece964b212a4884f9b8230ad66b1e5978898666b3996563d5e88909de715a95085982f9d5b114a87bdf1067e7bf41ffe84977e4399d49d091eef455abe651d605c45a2ae5026f648d580b39f95079f8bd4eb1e4b1d38a4b47674fd371ef68efff4fe7dd68fb093591b738752dd700e01be350f541a825638d1127aebf284032cfcb05aea9c37507ba8450948eb7c2a2f3ca57af38f1abb781108b769ad0c8fc7e57d28aa7c4b686ede46fa6297437803428b0590701e2f5f15aa94569ebb2628b2bb2ae21abcc75cfb24d3394e8a07fdc329a4ba61775b085c6142f6977305a19fc3cb3f4b6e619521fedf7f9d66418a1b8729a849acafa383dc3b2b9f4f8cc9ee373cccda32131c4904ca76479b01ccf6c5c189bbdd33a8dbc658e3d615522ede8a0d943f3321a29f7c5dba7ab9578e31f1cde1be4245ca7b34678e7b98281d85ff2e86c8447dbbe2dc320608c228c517a6b0126717cc5dadb08bbb740fdbbac8d4104b907ffe528535b8a2e7418873abfe91c7539618908efd1be97fc2e89d27ddfe6ebb846a26285c0f4926aa5e557c33368d5b8c7ee06787b128dc16313fa2643d1ea55c9db8e3965e2a66645ebf4d31ae663372bb6d769c35d06562d6c5f81146745b97483b08ea86cc681945fd208e9d2cfd7f2034c904a6b1d5c8023bcec8964e5e1b4a652b98b09875e79d9226938b232543a5ef8216bf546a94df9e79550a78c779fab20ba36bb91307034135d322a5fc17dec8205419605f11b203b106f6877705338f5ec0d19a9430013e3856ea9382d597b34aa2b7bfb5db0fc38d07e9b7ca6985d301271913e95d919da354bafdfe90b65dfcc7d6250c750a93b89474ef60d155a74bc8fd80781db68fd94ba01b17c68e99ac4592fd4236e589e376bfe8092df66fb27038cdd23f2e7a69d8db9da7cca0b61b3a83b78927fb659450a215ff66f1c0f6f292514a2113b441acd2a6be994e67cab3aee822848ece89ce85fb0bed34b7eb53054df2ceadc704e9f6bb388d1f334bbc8492c94992b68ae94b3c10ebdec2677e6fa8e683bc4af5ec0745cea32dbce42bb82e7b4e3e94c6665b340a7c9b817685381487f090612ff69b57b103fd64d6a9420745b88d24fc1359ce873e2c09dbc0cc83502c2f569aa2d41125651b80725d9ab4f3f89ebe0df6fe26d4f675b2138c358f621cc52fee674469f0fd206f5de63d52fb8ea4aee30e5ed8393d9b7534b94f61d9d178a1f9c69091997c1e7e09e1a244eb6927de1babbab75f2829f80b616005bc0be4012013bbd44c98c4a3f2c390e257567f5e15a724abdb20da13c4564029cc98b9d1177dbdf919baf984c3750f1dba9d1ad415983108905dcbebfb9d1c8e2350d8dda6679d9448f57fe435d2df6a50b93f36b4fe0ddd9cf510e80f482d1e49c180f7bb391ffff27f79b15cf11e5d73aa7d35d3b7cd0a2a8a2e1aa965bc24535fd2b2562b0ded81e007cbd1c7dd5414dd8078ac46328ad99c17b6fdd809e1a29e0434385d395b02a7611b4026a5d515f8ac507bc70c0be9018636f44c3227c0d008fd318904d90107784b4b5542501de29d96c8d03fe0a53f94432c1693602f1b4d62d0e327150861a7074c127c50ceb953eb4ae9dc6195d02e30ca29b35ede7db4d6ef1893cf06607a1e79b81461db274c22672654f4b591b537ce6b89099b6fbbad4bd4c5b8872be72f87248476de790a520dff9bec22a1af73ddbcaaf1b8e5ef95b49515f3f1a0eeade2edbf2e14f168049a78a2e4a2d30fd5fef2b9abb4614bce42413e37fb7756e939d520264ab86c09c771d50fe84aa44d6140617c0b7d617c62c21378efa9da36e322ae2fac6dc8043e30c680062392deb8304e46626225062c694d05315c20995091cf1e52831230e4576c0cd15f68619523ef6cec98693f284d96d8d91316ddb968fa2d8265c19d1f24f0c87eec478f2ecb4fd26e293a60d591840cdaa71d3ab9997fb9e98b2ef7f8d553230852c81eef765b733d8263d5b0300536f14516fbdc4be6e7a8418b618644f33d66005673801b26371f1e5edb533ee95c96d3b3214d05fb10f705f55a952d8d1b72ed429d4245c464122110781a35d9b5361378cf5582d351b511ef456ffa60f093e3f8b9d0d1eaa3792d0c9ccca80e401028386751a05f8d1ab05a07492270865db639887cffbb2d7abb6f28242dd6b320cc00372c2c4d049ed7e7bb1238cbcaf90dfc3d36a4829157d9bda548a5fb3615876b5970db2152de05141b2763a81593a1d9e6f326e0786b70f66f8f5c9919a7c54cdb04e1b707aa66d3858b102c723f899d4cf89c3334030ad9638d414199d363f45ea962d57e552aabc6b3d0cb0a020054f236eb54a032d4144239f4131125041473671c3918ed2ece15306c748fcfa2ff3ca7aae3b6c490685317d84882252ca33fe89ff63f22e0b0ddb8322f1251686db94f1e4f7393a18964e16e535f6e3a8c5092536b3e3bccb61b4206eb4b403b426180d21abbc4d3a18f8bb7d8534bbc00905a8882f9bfd877dc7893d262748f7a0b2d8cb884b643f7a4f2028d8438d6ab2aedd71c92a1b518fe1a40d6483676c53a64da766cac9f3b124f2d017033c3542444367bedbecd6b1d7b07e9403de7b77eb7e09de38535d1da785258aee0deb3dca1a7c3d76d158ed5712d3c68eb5459059857648c86ace624573d8d5797bb03b7e4df24e17de8c3c037c67793bb94fa5e0dd00315ffcd250fce9de9edb2e2ffaebb1dc02e0cbbfdac16211c800559091af409fc4ce99d14e5db04f1cef49611fa31536d0cf15acb3cb8f45c7bd56c9a92310f5128b1d6c096372c1466f4f7ce1a58964be1ea3764ce487a58a02098384bf495dd08b2b2001a273e1121176b529dab17f1c64282bb565b64785c32ee3d4fc0e0fa14845397a10ab0c1e7ac08f1f0a7614cbdcf6b624fe9e30d9cc187b5d9aae4670f2da7e0c48ade1054a21a7996fd4aaef6e280c1699e9b98dd8f742ebb0aeb4b7ef79377aa4d943180573a630e0ffda76cd8ebf6556bce420176220b72904f25ca7de0e4ea0d03b842276aa8108ee0dafe5dc4f63ffc3ce42a0eff6daed329768872de5837a82c9744af2ca59f4200f5437df5d849286aa1de0eaf050b22d5c6c86c6eea25d21c226fd779786005a384e2a2e1c805c629a1141475ea8f5a249ee34fd034ef29827be674c27b4152820193b823f727cc325ff923574edb1fe4dceff754ce57a5eed92df6c7aed19ef3ffdda75d96c0ee423712ce19f219d3541124711305975cfac668365cbb2299bdce21590a189314ecd6b3c220c36bc7b5bff5616f077aa0c6065ec0e460ffaacf0c515215e933f0dd8ba64f191669147676b9592e39707c7eac17b6f134f9316ae06c22d6248bb7224a70b82a7f914dfdccd7b328a3442d5ede91469326a142302373c6886e521f69290168f6c15eff23831406218f7080e54702617edb24edde9c2d5d7a946809dde4aae24cf130f0b4dea5b99a745a5c9bcc00f46b0a1a98238891e2f1128c5c1b5f4b99c86d7dd40501f85b455eddbefb4f06a09d518acaecb1cd51cc064567beab43a8685475c6581425abd64e48f4fb948da83a71db8ca8651be4b48dec7e438858ca20f2198b3ace04e5d8420e19881e7ca85b2ec85039622c4e7570620e98d7b10d1aac61d26b57c637080a9ed9f3d169524e60799dd274b426e023845bef5a2f0b543d3e1a596b497cc834069109b000dd052df95c39fe9284a23f9edcc11410efb56bcb76c2ed1109d78609b6a5c5135d11637f35bee144fa49b0f2d9544691e9f0076776b5756951790c7e734e04b93179f84b34f24ec78a653da06052e65fdd784d0895700aa38f33661fda43a9c574488c3efeed904d526f9fc84f629f09d42d24829a52cb39d2a35e6d04314f6735d77149797efc776baa219e2e80590fae04f4e61808b98f9abf12222f86c842941c3f67dc8c6f1795df2ec64a764378586ed293c19f419cf19115dcaced337f56b457c42fed8e09aaf794cb3a747fb9f596cbfdf3ce29d9d26ebc7026fa83c63a91b2d2f3a0fe05944257b13fb3bbc67448b240fafab07f42097ead9ba157a7846fff35787b6f9d4964d3cdf87abf367544fb6d41cca724d16b0cf41ccedc7e0324f63c4a53ef8c55d34b2b2f946426559111703177320725e5134304a11811d95fb4ec2f270eec2e866168fbd0ffdc7dc33abad7b1c46d5bd046aa490023eca6f52a0b6cde70c89a890eae7a51176e71d89a1367b3ad5551b51f96dd3a6f0cff89d8ba08143c894cf7a0094a2dabf6ced71b7175933a33bf07e031b16b8bbca74ab342e1d18dde2fd1ad89ceb6d24e5c2495c7e0b60004c529fa3c4c6649c46a59ab714bbf8195f6e26beada997b414d9a0e5fecf46972bcd15e288e980e3a80db7b62dfd870f243177f556afe7397a8f91ebc08af30515852f36b380f9796e6e73f9d5dcc73d8e6fc3fa5d91f6bf34af0170980db3e743d8673f946adaf0e96ee07a909c545622e4182785a76183c7980c4948e118e896708ef5e5dd2693456c01e005edc294e74226baa08bed55deeb307a9777814968762c3df2d6ea3ecbcb07145b31fa211fce52a443e3be0bbfca97ab2819218a9f2c477bab1d803d3a40350656b579bb49008c26e7204cb75a26d66eb36dfc7126c73d69191a520b234fd0357d39552d10a7998a85b16b45b04be4620be659501d4efe1ea20c4fb64fefbadca56d5998eb021f862797f00676c297279d4995b03b48d4c1344870db4e212f0fa2f657b6dc660ec3caed29671c964d1a68e0e1947b3d68a32d0827deb297ca838a2660cd009d485100c3d4c780310f694956fef033b2c5c3bb4044212a4d668aef72e71f98c82472516eec08fd4ac05902281eed8fe54dd7d58337552c46138d7f90a8ad82062d72665950c3d150764f675708752d4aa73da815a847319617e78452acbc86d17e63f0f51f35dda7fa8f6056fb25088a6bf4aa0e3ed82eea7e67ea5b468178b78631100cb1f1c76b374e38f4220db333405600675a74b8d524dcba127f96349f672748544e45c81268f9acad021e3d21ed1e20e6b72f8dc065e04586882e042077bee50afa4ae35240368601d018358937dcc231c88b7c269f75ca608c9644bfc6a299f0b3ca801e6f41629a18cd6b005636d22bfdb64c6ae60f4da5abe339a9dc913597c9fa534dc0989c5aed49c8bf7fc06575235fd73734a7285629c98b0f433e61317995af9a4379eec2cbe0697257b7665dc93758774b767957d186dc9b9665acc40640b77efea9ef75c3ee514bb5962f211b8c89fc13ab5e2fd2747988d13d04f5ead7ae3294e8b134c12da60f2c05818c55bd018ad8b2349c419d5f1649c73d1ede3cca2b2b7de8013fa0e60c1c50f2aead10426c9c3f6f70fb07cee90d61ff6ce61bd6d60a7f01f446d62fd3c111006b3dd0cb2bf75b9a681e514983ba30a974f7617352cd8043683389267ad6277554957f2cc464d2ceb7b2ebc2da62aeff191c15b77ffcd87ed5494ca9ddc2065148f017c0f2d8d1f4a1c77fee2c9687c69c63b8663b577f664825f97bde45479957216d4280735bedcf189a6f038d499632979936f2ef6ab82beae10294913db4f611dfc328b67f96be0760c2a23f4b0547074da2b3aef40eb451772a9367050f485e05fdd2ba786549516095518a1ec74918f34464178964909453d162076f4d02ca87ed45c368f8c809d8064ee6824cf8c4a1372fa2d306cf90662b6eb3a1d2aec5004c95a9766f4cdf9410688ee1f1817b488b414f089745332f78c741df248eec6e42b60684d7b8d1d9d63efa686b4bc0adc904e79bdef397e981fb91fe4a6c4d023377e7a1c1805e3702a801ed33a8777b47dbb69b4eed8923c51a341a8331b33f67dc35adf4babf5920be6c105c6db4e67474630e02be1fc5f82dbaeb9e33d1e8fa8f19b430c5944a7b0ccd440e219cb65b9d98868da01105029dd46e99f02e6a1aa4905fc9f7f8e1c0540879732b3cb152c1aad41fb01f2582ec742b1444f2622d6133546e19714e809fae0c96eb8f3a601ae140d1678704b5a17e3f231a2bb6dca3fddf113d083e998d3872eb6e06a6113f94d4ceef2e0c03b664215ce8f5c64c679ccd0afd03e6dda651340e64c73449642fb1cf15e29844e93ca97f25e6b81dbd622961aaa1119c704a81e9da601b052b83d8baad07304ab2fdbc17a6dbe3adfc513250542db38341d7853b7f64ae58d1a21058df27233f9116fdfea653038a3303579cb74fc14c1f19b73a2056782d71216e7f3c83617373035267109fe264815d5c9406311b98c64de0bf8004de28c45b254f78157c73857cf6c6307d9f2ccb886a10b7a2d175574971a0fb2ae71ed1721b1d7e706f5cb997eb33c3bd5fb2f6bf678a509ccf89729c25672d4dc416fee3d5a895a734d78658bd7b311116a7f0883f11f04ace82fb277facbee4de198894e2a5e60decf639654400a914700ed566cd8daec895d016de460c1e27842ed46b1c003376629d84a02b4b642fdbf4b5ca2954ac13474e524310bb5a7b06bb08d16a5daf30435ee00da49ee5770259551e796e8c494bc0a9970283e6b88f584b7021a2332cf797c74758d81b8f6088563ec46cd9686c01e1aad4aa604d4e683e169322eb6105470d45a137fc1ef38e09bff63a8f9f6bd9c52f723c964299cf5a088e620ba5aaf6e42c9b08cf06973df3867259ae56a7283fc1ab39bd227e7ea6381f5e0715661812c389a2836f8e06276d78008afad6ff8130be443a1ef3f16645ccec039ba43e9283bc00890a3f43f87f6dee952685900b48c8b86289d31ed5f2760dce09e46a025b3aba657d55082cada23d0f2a504eaaf9f6435b45b01d89f1ea4a65b71fd49c089265292e555219b9dfc4f046f116c05af8ede2665240770c3f52f898c76f651091eafc3c629d93b36d971078264ba8680e6bac0e368e4f3e22ceb6cee80a86645811865ddbeafce32569daa42246538280c4589b067f22d09b89b6dc4739b82db34e77240ee01c827a2084ae9e22491c86134977473a60e78abad99ac872aaa5d466f4d3145d596e43390992ea6d5625be08980788e3366ea7a055b8fb10dd3038bcf4cbe2282a031e7889c23cbc8cf9cb9848fbb11d3a52c9a38c152a48cc33667cd9be33989ae407b89657a96379a907c68619d401ca37bd88d6a89afbaacf42c1aa2b9f89460b4b8b3ac4beb21f840ff524471672d320d9399e9733b5a1b076247187b765429240719f13d083e6002447f9beecd1c29cc65242f96b1df9d3d459527ef207b02b2667c134b2c2a13cec813d08bdab3ebf7121a208f7e29f929e084efc1548f6fc6e9f14863ad39ea67b368f94cbf4eb89daf2944abc8f78f9e148baa412c29ebcffbf65d9dc6ca2847f82fd8ad7b59ba180c63d1eb6bba6e061c9dd9d38f9f68ec7265cc9ab9a9d19d61cc124d5b836a5226151cce8063490e480d1b5c9a9daac81d69552177703b7ee04706191e17f15a97566abf637a6413ea8906e6600fd4b18a31fe0d6a8cec43ebd75836187c46a86e9ef8c148c05b2590cbf061c5fa916b30589987952d9eb602631ec913d708a6c94db299c2696348910c62464870d61f951da00800c2e5b46931614666de3e04d33505e5a8f89cbf1c877c53fa74654b6d360212fe983b166959d926545f5b34caf3d8a3edb871c25179eb512a80ae7d6cc972b8dab9a2a11e1b920a60cf984e55d1b4ecf0af1bb2953116602f6e8b8c95d7f47b3cf1855d23c4dd90c240f67770636ecf5a8b472ecc54000b015dd4ce44256bfac4e9116c9a9f99eabfa33589fcefd6ae5b42cd93892adce968dc70d85780aa126025407823d10e9865e4d7c5061f101b952950cffb1947cf2415bd75b77bad29bbc8007de20015184d1fc0512a63daa9430d477bc5c63fef8d2cd5ea0b48ed7a88016134eddf8f4c8ee492959a591e43f1a720978277b732e7c06b2a37c0d012678af92bb68247cc865226a757419b072bff3da0aecfd498f765265597ab53586d3bab72f730ae7882201b904a784fa3330ccb272f57e989d21d119662f8b5ce3088cc9dcad18bb22bc36009480feaa84ac774a3b1a2f93fbb3548034017a54a5d354d433f3e83fb59d6171c2f035410fd6cd47a81194599578878a447b035ce9fd95740bc5b499be7237843c8f474dff4f18535b498772893a7f2a54915bb4a949abbbc5b8cc08ffbb30645d57f762b1b1bc5fc511e228fd9c2cd6efc60ff416509d6fcf4152a61946be446970773635d3a726313c15da038b96899132c78c84fd17058823c94ca7248c447570d3e597dc36221216fe9753afee82f0742b1bcf494b447fa6ef9740ccd5b18ec1f67065d4c2791a0f6537cbd31acaa437c5a1b891fb805d9ae7376a4bbcb905799ef705fc7d9a23fd1398ffb0ad2fd1ed815f290cdb450367bec753ba0923b84640361acfb5d01c70d453387488f20330c52a988f65d9cd7355a273501ba3deaf097e3cc2d73466bf0a6f76198db08c08a27a4970a45a599bbeb9f32df898d54bebcfae96f39db705765dca31f3b6235b41d9b37c56a797eeaa615d79db59dfc1f80e2f1d484d030385720e12f68ceb6ef3ef5e17ec32ddcf73af4e89806f742a0fcb516bd624a6cbc02083de8bf9998004a2ac5df76b0118226e2993ddc4571a2c10ffbdd411da8356133aba9ffdb4d31eac0a5c96b847dce12436f9f3c5d572f380e49570d17d74aaf0fb1a822bea9a5e0bcc8f448b87478169101d56dc211b2d269fcb4d0c9777a0ec966a35e78fe48a1c9f93be2c30eace716d61e081ecfee2b7af71668f9ac8bcedd95b652f7ce7947e1976c483c56412cb5e9ceb27eb71e4fedf65e8b67fe322a63de99498156affeed3640df99779996a3d44e36490de26f4ebe8603828bc702c9e8777338f11f14a37686169b739d9d944d4ed3801a050426218359ded923ba91671deacd462557a5c5426ba56ed334c93ef3b7517c5c2b36bcd08c0bf2d9c9388af064ed08172e890309c9cd2566930ffde2aa2fda983ddcfa0a91c4d540682af1f1686e663ba9b31d5c017425d69b2ac97a13760b851b7bb992323a183aa6536138b4bb60ccdbe4435a3e4c270d07c96ef85a9275c0406de8f5b5bd02500de9dc30cb7d6bf0dd2f72244642fd6379c18e8ca875eaf70c193124cafa6fef71c962adc7eca6e2197608160f226d51dc643caf87e37ed2737048ddff9303206d92069b5e935b25149e76c7c55e879f850bfe285f4495cb4474ae1a41df3205d0d93215a20c61a7e8f8003e20623054a7f0b9d77949490643e86c6fdbc01ad5af5bd9393f1c63ceb9d066442a136223e235b166176c789dce6f6c7919ec4888409331104c38bfea9fec016a2a6ec93a3da125c4bc4dd60dba7ad9c61661dc09e45ce656d0bf4e5893486a400aaa6ff289a316b112cbebc0af606cd17a65d6118ee3993551fe2608870bd5d8b88de1ef18f197e310baf47fffbb1e3f67912bb153d930651117b1280bc49d0a4ea5a49306eb7a972c0d392d52a0d66bb18b7df4898ef1a77b60d375fd39a2118e7bbe48d3be5724d2e8700e4b6cfd34a15a55a4a82483a27588836043dd7a0a1ca4d8cd10ca0a3a6bb27559da63c1d3de5da420a535e94c22785d9e8bf88d839c475304ebda64b7a1f00f8acc282275f6e8bbb1c34bebe8dedba94347e6301c18f46c6611587c4c86295ed96ba7a6b03ad5921a0cc93bb255aa5ad0d5e028198c59950cf473f680d1c965af98b78b9cc32b19c0c28fe557294bb787198577d8b9052fc8dc6af9729529957fd8c4960e7b4b4b1e91d0ea3f700e6ca30473609c8a234fa8650f00a6380149b5b90bbb358a401a40b22c03c77fe177821519073d1697568da1e44eefed2ad8e1282cadc5409a0a7cded7ae9933f8d4e3ab5b20af37f28350004b784cbaf28e46d8c9b3e28d419d5605f498eb0d255e24f93b37a0c9276f224a167b12968330921b555d80522af996012fafd713bfb474b11459137f24cfc543d79b16c26018456e73de61aec37dec537815a24701512226090226d9087a3a8956dd1de36295e808ddc33fef7bf6bbba64e49a972cf61b06eec6ac51b964fd62b12c32156d0684716e5da1dfc62143dbc2116633caf649855ca601fdf4c3f20c461a7595b7f0a78a5242ea1303b7942ec45b93964720d2213e7cd23d4b9f2ed68557723c22172282ba61a0e3c8999acceb3b7962cf9dbf0a4e724b411b780692dc16f9ca05541fc5fc003a6ecb1f5a0de92359f5d41a98943e61cb25de19276beda1e1bc286894e3f34bb1df9a44e345827c42c906cb67230d47935998ba75c4dafc9384dfa931102ec56ec03b292c552112d027949dcc982284f57627bb7ee4b76ff81abccbb2777e7d1ed29ccb14793729e867f90e9c11e1a0ec2e3da8dad0415ea80733eb5603e1fa53f1c9c484ec4523d4b9f51ac1716a49f5fb72d8f8a81a2e8de66b054b66683ef128209062a7376c74d003c709740b91719ae96700bb70b4ee269cd37baae6ca9d2202ceb40920ec06212fabc6897c5c12e97c7fecacb4e04b90fb754baa76af93dcfdb91b58dfc7978de2b08a9291d019169a6694acd8683ca816ea1ae553fa12c7a87e6178b5f1d829bc028cea1b9bfcb8b09b3a60e34a4f54f43741f3ae6807b618fa420160ce1c1cef2ff249e3de2a1dbba4a312e512ee0e36d3ca0e3e0e3fe49f9dd65e6afb3d54e67e4ff0e36a028d7e37cd6d00246bc25ad9dc5d08192d8ad15af9ee3785deb48ea5a7a38ff33694e7583c02bfb79e2869919edb8bb37f9264e75150ae917fd975e2b04f78fc44a7ff4410ebaa5c2c8d6a6e76b91f8ce007fa9c2b981a57b86f5118366e6c39e9d55e7289d509f938e20120c895ef2dfffd2d963c337963b33fc3cba0791a59c65ecf32cc497d922fd3b1bd7ec2d87a376334421bf2345ff2882091e93033d7338da131e3735ab75bd979cc1141ff4d3fd3d32e6735b78a47acdfabf860b251244ece1d60627b69de6a8e7cf700e38757c2f0d1465adfc84ee46debbe6cfcd41bb129494ff4664bb59d6c2ec57a05d97adda5675734e213e178c492be6a462d913900ece86158c8f3edd7d5aeda48d52406cc7e2887f4baeb97993b80a00bdd1ab2a1ee95d8f4dc5294c5e910902492e462f09d87b01ea17fa1c2988e851f41c2bea515735d7a99fd35f16244cba583a680877c12c76e75ca14f435f6291847d96bfd0f0bd62c2ab11d255d19c4674b9a55f119d40e06f2535a0a213695789b06984b89b6ad4f5429ba0c207fa87705c8ea71b92af4fc857fcc169c8f2e1c5daa960e4607729506cceddb8751ebcd117d56dc144fff779f9faf377945accb41ef9ade6e874ae6bf3b4470fdfd9f3cf88a2316cb57580fb9350652d07277a18d5f446ca1bb38a9d32bdcb318fb8059af8991d80460b9aac8ca9be2f6e47473857bd103b046fb72220d4e511c0738ebb33e9774f27e13c97f229edb5a548cadccd8e3d00f861a7093badd2328b6a71fe949cef78cca506ccff956003e6d100a26ab817408449550fb679a5073397d5ca7b7f6bcbbb71165fdb6195e2ff7d1a93d087886662174df50bee4f44e4540baa6f50a2acb63f527b7473bbd01fb6504bb9f1af144807a4c1e4a2cbb3a9fe7b1d941b4f6c340cc24f82952e74cc83f4285287a1dd67ca70508e5fa8cfdbe8aa72db11cb25ed21fe54cafabb21c47a1b70e0efcf9432e6950fbfa0c47460023c5f8e82732f7165bec64ca125882e42c10de8d324b1a443a7543616c8cce72e6ef1ea1eaeff397daae2e5675f11083f2212ab58f4b5e56e67c28b94a94183728ab4fd215f5b0a5091bb5f7cb72532697471308dc339e758cc7548ddfb7785e7f0e5e324a806c51e0c3b3d878797d4cb0cce8f3a6a12e576de89e73b2deb4ee737c40b8fe5d1f4ddce745d87d0c6c966e3ade8eb2cdb0e903b2d18ed5cb2136e4dc4423eef2f4c26d4f74aa74f0116795d414e7262419e5adf0536ee1f1b95f4ba3cc555afb136087c8480012f0fb56cc1b346c0e2c0da32d225a6bd00fc350efd46c7e6e33c3edbe78c967325c06208e8ae3bd78fef34661c30879ede5cc790daa78adcb1bca55fa40ebeb7a3f181d9ccf24f77615492236304fea48ea63708dc8cf1f565245c4c7868bc45326cd013e5762cc419024f0bdd3396b870f28a2146738f2ef9d5a2e5b3a1612a2134321a1ffb8bd46f26e335cc6093282941bd6d2c9a45dcecf27c13fb05dc36baca938bb6cf7f19adcaa90889e38928a62536a161846554084e28ef7279e3be006d9c5d68c29c7834e3203f7edfe4948c29dd081d16e828a946f9ac8027c460d7c1b1a19d4c414d91190465481353f0b834885f040fde61fc695da50fbfb052e41090f5a0cb74aec6006312810f7493469a8f1ab73fa817d3128035863417351b6bac8fb032624d5591056464868c3bd708a0d32f8483146bf545418f8aa889346aca611e4c905b1de7ac0f9f2447312adfd7fb1ad82bc145c915435e4df70fe919095bb46459ac1905037f431dfb898a0c5eb94eed9e0caba2ffff36eddc8eb864210ee1fc55f85c5aa70cc17ca5bdf554dc17910e08dd3659ac4bb95fea33e0388724088d65787198b27c4d318272e4581a182cdd55520c5fa4346eb40eb844f14c2e5a69366cbc4633b2e944a774bdb77314565939fd85453cbc77fcd0f5d693db166e59f8a44990c600a93b4f9fbe49ade14d6d432b5b46330c4b1008a6bd8d0805715ad5ba4f75206d94d7e4d57b68a4893418395ade4229f829fde33db64021b5f6e3f19e1ffbf29e832d36189e11452f0092ad41cc596169f217b7424f334e1b4c9fa54c1d308a50ca95631ec2ab6f9c1ec477e3449696b4a1e2a6453596976c340c4e5ecdd9a3bccf594166359ea52abca85a1d309a421f3e6d97fc80b92a319bc93d33ce4287d8bbbb570a14b316704a9cfd22643ea8a0c931b5b89a1d3f84c24b83f4af04483c3c2411794b1b0f7cd3f270a1a8e35549c14b7418952e11b322c19f6e0bb3e2190bbfd74d8c0403fa2b03df9dc16d6dc0e886e50909d502f78a500b5748d6890aa0800b0280dc37472aec53a38cb0ec7d3171bd9a995fffb548c42a8444de5805b48128d32129013c94d803df85e067df8edffd95521b9859861229cd6d7c3a4d8ee635be4e78dc03c17645f79b2b9588a8df5b7e13bb2803669956a3a12e3891b4dc00e59209082ba94f5543506deed8eabaf2ba7ae4e4ce4e8c0211fc6d2947687b639ea5c9183dd2fee41caed80145147f74b24fa83c493fcb6b95790478b8fdc63fc3f6bc8ba89d482eab04f4f341012349df98598ed83461a369f163071306ea25fe768a1526881fc81ea963c4208bd677c93ad5a33f97e293e0bdccf1f13190111e0e685bfdaa022b65c2a277ecad1ebb23ffffe2e49e97e7c621b46557783cce4f9d6be4e348ac8875c68727bc222de7b59fc40eb05f95d7ab9ff89adc37c724980b5421d6c972ad55efcebfa8cfc96ca08badd23e804a7be5e1ed0dd624f2018c012f6e517797bd4fa2fd702dec9bea47eb2bab4482df65813d1b02e9d71aaf46809467b2d0ff8a9cb23c5e9000661df59c154a1d7e1ee9e13a2206bf9d158ef579dba4f6001f8899f13ccb5670e470e58606479d27516a23f1852fe8171906156592868c4538bda460cadbd8388dc4aeab46942609fb89741719471c991caeac3c4c1233d54cd6386c1d328d64d624eee4744e7b4e831f71fd84316fbf7a1c90f94cbbc324be652a8d2bdbc14db508dbaf1143d712eeefc8f6e1603431ce6ef33a6e35a05fe1e6eafa281df4443ef10b928fac8dd60828c7771f67faf7f9b3f50de7149e772ff98ea88aa95c72a4bcc798dd52b1fce34ebbcc0f081c42ba52caf2e4c9d3ee0cd8abbf4660dc33a87a8a802986a1c59f5289b7d4ac6b852965686aec6db32c662fb08132a100ed46b47cbef9cdb2ce0230d38e778a9835f2f8b1930697c99a96e6f7f6abd6fe199c584552a75bf286fbee3f58ca455b3e5668b4e8dae580852951cd3bff226395cd28345b855d4f07e96be55e00e8755307ad2a42425af885e84f4a336e2bf6da573ce9ccd6cb4d8b80bd6cd0c9702adf60ac2384468047d7736dffb793b5d5ecaa80074086f3a12e9e032768a8170ca3d27d91e6fdf294553312f2a6b26516c6b92f7154bdedd55e2c82101ffd1aa759d5294a61b66cbe66ee6f8d3a77d099e75b456b84b09654789e4ce7fff08ade2eaff99c4138b42d8754eb6ee10094254cc1290b316a2d9445d4351c21e893c4510b63b7b1648450b20e4482a2e4830ef7137e97119b38cc3d8d4a1a382688746bd6f2a7d8683eae1019f32983ae2373e4ebc5c3f133984fac291e0b033fe62a68d4fa72f79a379bfcc09be48397803ca0b2a7a953c74cbed81da93170320ee57f79a40a3f292df8a6c4fb8a8e504ae3566d8088999a240f2269dfd94cbbf2015f821212d3ac80394ea445e26f17b704f6f457aa5ef34d32042e3cf1354422f17307c9d5b8c7b8513f1250a4c8f2958c6383aff5a184ff2dd8f9a02f1ce0ff8f15ae4975340d148e1f801da419b09fcd8069ccaddc4b4da39f3c9eb0f914da017436254310c19934a6e2f991ea2a7513d96c89189e5c324b5da9aeb4e90137031cf79bce2e7683a3998961960d1b57eb3f7d320bc5833526701574bcd345f7372494c0a143a04bb44ac1c64bb7b9a47e1c7ee06e9e38ed100b89b547a5056d107b3ab70e7c89b14aae83307275d9d4cee0a413f4a593cbf6c39c8d3993d1ab21cbc53df48be48c574eb56007797b027d92c24c062a7b179d2ca5cce2a9f0795b35b8dd5a7bd6e861e0b31e326ef4fb1dada2992f326a04d76c7c797dff4c93c36b1e2f9024bb9ac49cd611198e3f4de11cf3f443deaf6f09f0102402a095c5e314cb90bd8a25c8dd6d5d654128697cccd8376aef58bba7416e678b45541231a29ebdde4ca7e969496144ad9710c509f26c3a3db68d05e4a27c29177dfa1d5b85bf9ab7d64caba15321e893e9845731614b318e238c882ccf263774a1ce33cc9b3eae5bb00c92c37f53afcdcd6fc38a89cf2d1a15356d23a1be7d13b85d210d8cc384704851434f7993e8e147fc7c70a7f15acba0334b7e4c83b632a86390c9153596e7852f7b294dd4d58ff28a08a40287a789246d5a9d74cb12c1aab6a71d7819840e99b1fd9cb715013754be72cd004984d3cec243226552735fea578a563830d402c362504a367d4985031a00e74e01d6d4e510eee61527199e83c2d55226f9735def0372a13bf071279a4d456ff1345fd9cd4487df8c389514c7f8a994a7355ae9f200d0a4155904c1153209f4c245d19352b9d7f2921b60fbb0c206705569d22bb5cc1d21978075f5759424f912457bddf807501230f1419b260218c640f1f85790091b7da1c99220bd5a5102d5ed79e25cffbcd8888ee6849b7453382736bc835d5c016b4fbdbd4431b12d9c3b3f479c7399908c0e83cd13530679c10a02563ae5d47f988d58906f42189736f27eade0e90595abae37cb8003176b86f81e03d9ae5e02182b5d45999246194f4964f06e63f2bb5288cda38cf82ba95267e703b5ece396b3a593a84a620db05c4ea71ae5b59bc3ef14b7a3577ad14a02a7c2e4c2fab55a3ee86ba73d6cc763d132f79c7f9ccb457fd601d2c11bc4465efa939885d482f3cd9f03a0dfce0fca970d3a882beec4006dc0c585bd38ecb735077e0ed202acc3582d641eaaa2b5d0bbdf9ec94a884b3769981386a993ed30b558fa15ae6c062aad3fb897873edd8ab60094c2ee835746e019fe9c3e941b8327b4156084c2f7226fe9778e56a9411e16eb4b6513ccb820d29c404f982c6c594312c4a992643c4288ade974fc9f1f935f81c771a249bc5ccd4c323d6d54a0c74d5d28d0a6b40d11b86971586191484b7d870ab38e6711af57b919828e0550d952a03e4b6fa694c989e61206b361dc26c5952d782580007ba2227fd5336a6a4d7833ac4a313260499c55a8d403becb6b154a89c2d54191fd79116ca6b07504369e1f313c332a4a7b49ebcba582e2a852e4e3590deeb0d76f3e9a31239d7d902f2b9096f2c1fa91e5ca6fcbc9af28b8b0099639b65f0c99f6b8f76c8a6eab1cf27a14a2d91366cb1f834df7bbd239898d73e2ff36c540fa7b510c354abfa1457ff4951efadb5ca97b0562cd1ff6ef9f0f50639e70d432dc1facd06aca7528208f86a270db833c4c1813a0c93a4180822fa36df1239a2a721c195d057edf153be7cde0d902eb5f640bc02fdc54201a8617001f75534eea63d858eb3aca1070902d7f5117d6f9f4a03526fd4f27ddbf4ea1c050eeb3099c052b0e95a58c76791c98542c2c80b3be566bf517c8d97e36def2b76ccb7acda425f19ddbb76b7342cc70cc44fcef887665f154bb0706ca9cfd230a97729f6a1cb15550ea9d4a2a48faba8cf1ad2b03ecefefb029383a9d81e11ef82af9399df0f5efa470f1e159ffe83152962fb7cd0411313d7b02abf3d0f7399619ac5df5eb1597228f5c59dafdb4319d7896a2f4ae6f7d0cec4ff75401bf145279307c3fbb52f2b3e6d2c280125459642917aac84ba3dec8d11092c3fd53f12105d3f48469fe726bf9662861f7dcfa8c5c4c18d171f23b5a91a9e5d4fdbb423c7d5fc9e9c9800383cb100d625eef09d8159e1aa9d828ec282b5888e3b6c59d082f0a8581cd28cfd1e01b3e011521e16aceb231d3fb2f2b5c6b49b721063ad755d75ffe97e4bc99d29b9b981fc71441d56924f2ee241aaeb543b919f228c21c94055cdef0c57d58a3a04ce89ad670cf6a117817be560528014cb71bc03864ca1c418756c28d799b613c2162b8981161973d57492778766c4e30f689717ebc7069d5b3d87ce3a461c17311cd33c41e17adbb09a4b005c5b32b349f4bdc4610ed09af5da4899d4a8fd1becba8ae9458083ad69e313d68bceb9471a94c95645a40a50ba22f71acedf588610c28f2baea350bc29d7a09ad93bfaeecf31c648c2c516df43956972eab0640848d689f060d747489046a954019f7c19afa482fc4f899e7c3d5148c35e5edc9a3ad3ef35720e73052e75f4708edb2a62644c1260941da5ee09882ea1176b7511233387efe652c789010e64b3a0d3a68cb491649efc035a78a204f755f5962b58adb4309fedf2906d77cb9ab5589c1ec56bfddb33a74260efde06cbabb623064de3fd262237c96ccfde1b8872e0f68e42e29b6555fad2b3a474c6c8e62f50a14e686c5013576cbf538e0a9140f920eb54462aaaac90ed9eaebe8cb25d1261cd800f950439db5bee68b609cc34e38794efcec9f551455087f5a063106dd2d5943b777c02a2a1757dda577434ef5c7163f38a9505bfe7d851ccd6c3ba042a3266e7362c72550e15a211b07cfb16b9fa3b4ee7c499e26f69c3e590c48dfce347ad59ab30b6cacb29e20c68ab53a860606150d4bf53a226f8c73365d3e6483fd7e8c5c4681e6f3a830e336bc685d75d6eca7827e2844ce1bdc00c11a0cef41325083d08db6d5e9e9ee185e0f31853ad6b8e4da6bb5b4d9a125a3d282bfa9038c344b86842aff26c6cd1be1c18653b2675141c817549aaf69e891f50297270478e8a30128d8693d88d2bfce7c33177d95f42236f4e79ff6acf4c8db4f99af78a6818cdce1e9fe43a76ba122a8f95ddd4bac0bb59d7fa5843f0278ca13dae6e210a89737f67f60123f40474e1af567f7e23202a16d2e34294461c3e99de25df265bb7f24ef5f52d62dccad3b07d67205e0b6322a866c1aa684bffa205a6b4e3bb4cae15b50dbcb512e767298e33051101af3980168de8e3915c6a34dffcf21e772947d2ab4f3d00a5070e776ad65e3c9585da85381fd894eb3f873a4ad520d1e7f66c05ab71d4350299961c92d30f8e1eaa2e637df2e6199b3b8e0b3fb4b00e666703f50857afaabc1b6131fdcd99c43b81837e4579e23811481d312f190a1e9ee6462774ad4fc60a78e802f838ccabeff706c995bb81491ea2dbbbdd680b16952661d99b16a2c65aea64419569f9edb2383f30a1ef9926343603bdadf2f20b310db51d9cc9a5ced4640277d7790ee2fe07b0c5e8b8fa9bf521152f7e45ed8ebee020a031304e3644fa7cee74d3e0a485dc30a58dce0a7b99c01011af88a53482e14792cc30c99fcb056ff3ef4a931725a0e66ff1c0f931e52e2df0fdf7eb4b063f88488d8602ff3551a7b269619bab7ef4cded346dfd7f325f472f3ba78ff5603c9da4e5e6b5210c504bcb880da4754d57eb9e88d88f01e64b9fac2a753f7348bd6025bf075debc373dbbd319fe59fd0146216abbe641c574c1e4f2ddc5b7bd35d5340ebe5774a32ef1bbd081912fa8d28227e59a62cba8aeb244ad3e803391425880898bc598efa30e8282ad230db30cb0a961a56305a127f441bf2271decf6c46568b93139fddfdbf93d279728a630d612bb590556b70f0bf8d378bc02cd82e968d50f7f6c26ec3633e16628464601e919ad9f1c8b7f6bf607266a896680ef6b0fe8b77c41b50c88f49ce8250ac8db1f354f1409f157ca265f4c6ce731ccc42967c62f7c22d0de5213c6c7caad5dde80baa95d4a82d03a7f6bd53b4001f56b329948740a156de17105c662e87d61a9aa7ea845fb3e9fd452244b1b9f8c676532caeb2130c8adb05ffd11e83892a3ae8edde314df5e76fc711bb31df9b01f71f933ff2d3b179f394202546bd1fe06b666ac4e43b10fc3cf4212df54589cb8b6271e86073c2912450ecc1ccef50bfc7e1b0070d791f5e09302a24f92ab8fd5bb49c13daac0f77156df3d45ee28216fa558c0f0c5c2ae012ee3f9ff38ed9b60658b27fa10a4bd76702ce31f59aaac23897e1d7515698f4f97bc2c8b40d61af8301d57acd1a7e3998cf8f7fd21234ab679ab1f8742c9ddf2d0f79565bb54d7794ad6138b3e63a147ddfb2bc45f6ffab8fd5a7c97c19c0aa636c1be3dcf607ab388a67bc665d2e6aa03fcd2ba94ab7fe48212fbde8f5676958c730a5fa681a6e7d3e25ba40ba7545899d850ba9b9a4b18368be1f5417eebde41401e23ab50a4867e0383f7a321c221e3e67386187b8907b48580de2742821a87d3ffc5bee3fb185c962995acac77810a02103e7e019ce85955e69435ff9b49722b4b56d45c0c1d3b372bce97a30942fa2641dbd8f522b9933c6beb67dafc10dd541cf8910e89d24349084919f3570b0242d735dd5b7f5f95e9a896203cc008ef06a92983175c44cd606839c4f33008be03c536cc4947e799125ff67da62454039970abeec2c35abb0b5a8da0de1670bcd9482f75ba0f882d37f2219f16779428da759be066943feea4d4527e0a946f88db53d375e7b212f995a90fe4990997a4a1e7fe8eca3c3363b848afb7831d58ee2227c63c9a9863aa2280cbe8cdbdf3e0d57738a6a87f97b35ea73ac7e97f97434767e016e61b24e1523db16a8595fb57b85fb148c96016a1a5379f47e0b821fac28cc87549804b7f11a69bbcf280e19b1a8fc28cec0d29a86f49137220ef65edb44c1a0923ffda177e2b533fef4aa577e10a575264356f127adc2aafaae2dce48a9b50f3a6c3b6efe429dac95441b2ce31c6699e0821e60acabdc24495a0d0431330271d60cb3c7d72aa6dd61fc98db31ab1a84b357737ac992ed5dac38570b732f7c20728c24fc519288dde046de0696d695194890e386e298ff46f0204bab06bef3e29fd664dea6708f315c25a2eb25d81d5aac5f945bababe067d9d9fa7ab64372656466e8f6799a85a9efc8cd2223bffa12d1ebec17ff5dff6d67606b03dab555370bde55a469cf86674f5940502ebf37c30bac3e7f6ffb5829c5723783e63408efd81fa54bdab3f668663eb4dea6f77a25657096656231e47a4ed7485df483c7cdf5f615f496eddc3242d779dda6324eccf14edd1f805cb71a721ebc676c6a152ec11e8e1a414057f787006621d1da164208af29913a64eb1c67549cfb7b27e263f1cb4bd600c1982ee2f36c28491d38b69ddb34122e96715ee7e9aa11732501488fe291472748944ffa3beafc614df80c1bea12995b126a8e568294567b22052cf6f5d66e76490752c40254e89382b293debf7203789b7285703d4aeb75c6620af64c76032f3c6643a7fbea0ba88a6ecf9b544db3ea83ffea14b97994e865f99be1d9426a3776be7b3e12486e0b3154ddd59fad60d689b6fe7c424f9d3fe4cbb2b1fdef9419a451108f9b3559e67c92ee7daf9ce9abe5f486180c40185e924f95555a57287490cbc1a616fd8e2dbb292f954837ba1277eb633391d77e4886ab16f54f364749a225f0ffb07276d31cb074aa4df9476cad4c131ffcc647cc1513d31c7001a23dd106e6bbbebbc108f05616b079cb7cce2372e21d465e7e268b23356dd8ef808bdf635d16198a2ec3181f2993aa477877d0c0c27dfc67c94c895dea842b2de2bf0c58fdc7b574bd3e40fc4085e18e72d93482bb626d240817c2efb57b5eb4a8305b5cddd8aa8252bd498e1f7d18b513fdbb0379804777ef38a216f7ad27fd424c3f7dfa362d7f0e42122be32a13b7a45a446db8e1033cce030f57ecf94ffb11a8dd069648abc1a0df1e3cafeafb6344b7876ce18c7c341f1cc75d44a52278f82d71d9d858f4eefcf6c73d478f7c0ddcaf8a07a37feadeac1ee48b44f554634922b11ae503da48a613862c63655b8da42e241dcddff742082f387ec2a5f9e364ca9bfd68035a1b2c89460dbaeadc3014f72f9e150e53cf19a676311c8be68c497ab685231986e2279360eaaed4ad3cfad787a0b5ca51c7ff42c7ddd919ebb8548c79d198e0ca42d387ced91e52dbe5fa0cbeb7cc43abfcaa4225f1dc7054e2bbce0d6bdaaf61374a4dc5dc0b548408cb52a1b13083a1b1c79caa88b6f298602b52e47d738d6cd6c7c5ccbdd0c4e4c34d167f5b1467f62e877444eff4f6c5cdd83fb097738b079689a04913286ec3cde41d1aa42d4f7fc711bad4befd016a3a0ca88cfb890207db9398ded1a4d3c223604980de5e0d5ee670df7bb48cbbf51d81c8b3c20897525d2256f209ada24ecc59c932e5f8436555ae41244f4a0323e5a4bc6497bc8bd8199832953d2f0538abd7259373118b6b526ac072b9c280287ba3f946306467006ba9796f8edec5375f93ae1eb33fd320805f1c1f49a79f4446d4833e3ecce8a0fd10eabfb4e69179e9cc3d1f1a1cd15562f5b3fdbbba7d05dbc8d2684d4876ade22b88203c1743ef9e6ad0e6cb4aa6ad42c15e0132407d9aef178d217dfe9c445f8ae3b31f6bbdba24c7d62852cff2963ddc46fe89c6d000cf8ca49112f5f5aaa4e3bcc6adcbd9f0e0fae7040577038eddb29360f808add287636583471fe60865c6aa9ddbb1cd0e59dc18a37de1a292febf40876eddc272e550dc2e87b9d712dd8fc2d9c1bdb64e0e0eceddfe1fa9a238d6a0b0b8ffae33b4728707514c8df14c30ddbd2521117c9fc912d000642e03add72069d8fe1fef79cc4afc0ba4b91f4c8631dda83f6690335cfdb55820acd443be7952bbea70afbc95b9e2e0be87359183b39bda36cf2d068cc156c1c683eabbca823b4507513f50f69617d4c4c01a8361e5d3b705609adb9d843fe005664663212e2fcb47a6feafa8374c92177be182916a55ff4a9fa6b22d9286c98a95d9b413aaf736145705d00f990a969eafcb3582c004746d02de6231636bb5cdce74b607757d6fe8345a2ce9f034d3a781e015ff78d83e7a46e4041f7888bfc99b1d7eca9467846ae9604c2b581765c9b278399bb0884edc6dc0b19e4eabd2ff64a563437f79977a5c6fb8d9f745153e75d0c0b98d8fa144ecfde0f8075</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-xray">
      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好，这里需要密码。</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>项目</category>
        <category>确定性网络</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>确定性网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 进程间通信机制</title>
    <url>/posts/240414190410.html</url>
    <content><![CDATA[<p>进程间通信（Inter-Process Communication，IPC）是操作系统中的一个重要概念，<strong>它允许不同进程之间进行数据交换、共享资源和相互协作</strong>。在多任务操作系统中，进程通常是相互独立的，彼此隔离且不能直接访问对方的内存。因此，为了实现进程间的交互，需要使用 IPC 机制。同时，本文章也记录了各种 IPC 通信机制中的常见系统调用 API 的功能描述。</p>
<span id="more"></span>
<h1 id="进程间通信方式">进程间通信方式</h1>
<ul>
<li>
<p><strong>共享文件（Shared file）</strong>：共享文件允许 <strong> 多个进程访问同一个文件</strong>，并在这个文件上进行读取和写入操作。</p>
</li>
<li>
<p><strong>共享内存（Shared memory (with semaphores)）</strong>：共享内存允许 <strong> 多个进程访问同一块内存区域 </strong>，这样它们就可以直接读取或写入数据，而无需进行复制。共享内存通常是<strong> 最快的 IPC 方法之一</strong>，因为它避免了数据的复制操作。</p>
</li>
<li>
<p><strong>信号量（Semaphores）</strong>：信号量是一种用于控制对共享资源的访问的同步机制。它可以用来解决竞态条件（Race Condition）和临界区（Critical Section）问题，确保多个进程之间的互斥和同步。</p>
</li>
<li>
<p><strong>管道（Pipe (named and unnamed)）</strong>：管道是一种 <strong> 单向通信机制</strong>，用于在相关进程之间传输数据。它通常用于具有亲缘关系（父子进程）的进程之间的通信。管道有匿名管道和命名管道两种类型。</p>
</li>
<li>
<p><strong>消息队列（Message queues）</strong>：消息队列是一种进程间通信的方式，其中的 <strong> 消息被放置在一个队列中</strong>，并且可以由多个接收者进行读取。消息队列通常是通过消息队列标识符来进行引用的。</p>
</li>
<li>
<p><strong>套接字（Socket）</strong>：套接字是一种在网络上进行进程间通信的通用方法。它允许 <strong> 不同计算机上的进程进行通信</strong>，可以用于实现客户端 - 服务器模型等应用。</p>
</li>
</ul>
<blockquote>
<p>如果需要高效的数据传输，共享内存可能是一个不错的选择；如果需要在不同机器上的进程进行通信，套接字则是一个更合适的选择。</p>
</blockquote>
<h1 id="核心概念">核心概念</h1>
<p>进程是正在执行的程序，每个进程都有自己的地址空间，其中包括允许进程访问的内存位置。</p>
<p>进程内的线程共享各种资源，特别是地址空间。因此，进程内的线程可以通过共享内存直接通信。但是，不同的进程，默认情况下，不共享内存。</p>
<p>启动进程然后进行通信的方法有很多种，主要有两种方法：</p>
<ul>
<li>使用终端来启动一个进程，使用不同的终端来启动另一个进程。</li>
<li>在一个进程（父进程）内调用系统函数 <code>fork</code> 以生成另一进程（子进程）。</li>
</ul>
<h1 id="Shared-Storage">Shared Storage</h1>
<h2 id="Shared-File">Shared File</h2>
<p>共享文件可能是最基本的 IPC 机制。考虑相对简单的情况，其中一个进程（生产者）创建并写入文件，而另一个进程（消费者）从同一个文件中读取。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         writes  +-----------+  reads </span><br><span class="line">producer--------&gt;| disk file |&lt;-------consumer </span><br><span class="line">                 +-----------+ </span><br></pre></td></tr></table></figure>
<p>使用此 IPC 机制的明显挑战是 <strong> 可能会出现竞态条件</strong>：生产者和消费者可能会同时访问文件，从而导致结果不确定。为了避免竞态条件，必须以防止写入操作与任何其他操作（无论是读取还是写入）之间发生冲突的方式锁定文件。</p>
<ul>
<li>生产者应该在写入文件之前获得文件的独占锁。独占锁最多只能由一个进程持有，这排除了竞态条件，因为在释放锁之前没有其他进程可以访问该文件。</li>
<li>在读取文件之前，消费者应该至少获得文件的共享锁。多个读取者可以同时持有共享锁，但是当单个读取者持有共享锁时，任何写入者都无法访问文件。</li>
</ul>
<p>标准 I/O 库包含一个 <strong> 名为 <code>fcntl</code> 的实用函数，可用于检查和操作文件上的独占锁和共享锁</strong>。该函数通过文件描述符进行工作，文件描述符是一个非负整数值，在进程内标识一个文件（不同进程中的不同文件描述符可能标识同一个物理文件）。</p>
<p>对于文件锁定，Linux 提供了库函数 <code>flock</code>，它是 <code>fcntl</code> 的 thin wrapper。第一个示例使用 <code>fcntl</code> 函数探索 API 细节。</p>
<h3 id="producer">producer</h3>
<p>Example 1. the producer program <em>producer.c</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FileName <span class="string">&quot;data.txt&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DataString <span class="string">&quot;Now is the winter of our discontent\nMade glorious summer by this sun of York\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">report_and_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span> &#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>); <span class="comment">/* EXIT_FAILURE */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">lock</span>;</span></span><br><span class="line">    lock.l_type = F_WRLCK;    <span class="comment">/* read/write (exclusive versus shared) lock */</span></span><br><span class="line">    lock.l_whence = SEEK_SET; <span class="comment">/* base for seek offsets */</span></span><br><span class="line">    lock.l_start = <span class="number">0</span>;         <span class="comment">/* 1st byte in file */</span></span><br><span class="line">    lock.l_len = <span class="number">0</span>;           <span class="comment">/* 0 here means &#x27;until EOF&#x27; */</span></span><br><span class="line">    lock.l_pid = getpid();    <span class="comment">/* process id */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd; <span class="comment">/* file descriptor to identify a file within a process */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(FileName, O_RDWR | O_CREAT, <span class="number">0666</span>)) &lt; <span class="number">0</span>) <span class="comment">/* -1 signals an error */</span></span><br><span class="line">        report_and_exit(<span class="string">&quot;open failed...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fcntl(fd, F_SETLK, &amp;lock) &lt; <span class="number">0</span>) <span class="comment">/** F_SETLK doesn&#x27;t block, F_SETLKW does **/</span></span><br><span class="line">        report_and_exit(<span class="string">&quot;fcntl failed to get lock...&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        write(fd, DataString, <span class="built_in">strlen</span>(DataString)); <span class="comment">/* populate data file */</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Process %d has written to data file...\n&quot;</span>, lock.l_pid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now release the lock explicitly. */</span></span><br><span class="line">    lock.l_type = F_UNLCK;</span><br><span class="line">    <span class="keyword">if</span> (fcntl(fd, F_SETLK, &amp;lock) &lt; <span class="number">0</span>)</span><br><span class="line">        report_and_exit(<span class="string">&quot;explicit unlocking failed...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(fd); <span class="comment">/* close the file: would unlock if needed */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">/* terminating the process would unlock as well */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述生产者程序的主要步骤可以总结如下：</p>
<p>1）程序声明了一个 <code>struct flock</code> 类型的变量，它代表一个锁，并初始化了该结构的五个字段，<code>F_WRLCK</code> 使锁成为独占（读写）锁而不是共享（只读）锁。该变量主要作用是锁定整个文件，但也可以通过 <code>l_start</code> 和 <code>l_len</code> 来锁定指定的字节。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vim /usr/include/x86_64-linux-gnu/bits/fcntl.h +35</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flock</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">   <span class="type">short</span> <span class="type">int</span> l_type;   <span class="comment">/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.  */</span></span><br><span class="line">   <span class="type">short</span> <span class="type">int</span> l_whence; <span class="comment">/* How to interpret l_start: SEEK_SET, SEEK_CUR, SEEK_END.  */</span></span><br><span class="line">   <span class="type">__off_t</span> l_start;    <span class="comment">/* Offset where the lock begins.  */</span></span><br><span class="line">   <span class="type">__off_t</span> l_len;      <span class="comment">/* Size of the locked area; zero means until EOF.  */</span></span><br><span class="line">   <span class="type">__pid_t</span> l_pid;      <span class="comment">/* Process holding the lock.  */</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>2）第一次调用 <code>fcntl(fd, F_SETLK, &amp;lock)</code> 尝试以独占方式锁定文件。第二个参数 <code>F_SETLK</code> 表示对 <code>fcntl</code> 的调用不会阻塞：函数立即返回，要么授予锁，要么指示失败。如果改用标志 <code>F_SETLKW</code>（末尾的 W 表示 wait ），则对 <code>fcntl</code> 的调用将阻塞，直到可以获取锁为止。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span> )</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   <span class="title function_">fcntl</span><span class="params">()</span> performs one of the operations described below on the </span><br><span class="line">   open file descriptor fd.  The operation is determined by cmd.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>3）写入文件后，生产者将文件锁结构的 <code>l_type</code> 字段更改为解锁值 <code>F_UNLCK</code>，并调用 <code>fcntl</code> 执行解锁操作。</p>
<h3 id="consumer">consumer</h3>
<p>Example 2. the consumer program <em>consumer</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FileName <span class="string">&quot;data.txt&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">report_and_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span> &#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>); <span class="comment">/* EXIT_FAILURE */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">lock</span>;</span></span><br><span class="line">    lock.l_type = F_WRLCK;    <span class="comment">/* read/write (exclusive) lock */</span></span><br><span class="line">    lock.l_whence = SEEK_SET; <span class="comment">/* base for seek offsets */</span></span><br><span class="line">    lock.l_start = <span class="number">0</span>;         <span class="comment">/* 1st byte in file */</span></span><br><span class="line">    lock.l_len = <span class="number">0</span>;           <span class="comment">/* 0 here means &#x27;until EOF&#x27; */</span></span><br><span class="line">    lock.l_pid = getpid();    <span class="comment">/* process id */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd; <span class="comment">/* file descriptor to identify a file within a process */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(FileName, O_RDONLY)) &lt; <span class="number">0</span>) <span class="comment">/* -1 signals an error */</span></span><br><span class="line">        report_and_exit(<span class="string">&quot;open to read failed...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the file is write-locked, we can&#x27;t continue. */</span></span><br><span class="line">    fcntl(fd, F_GETLK, &amp;lock); <span class="comment">/* sets lock.l_type to F_UNLCK if no write lock */</span></span><br><span class="line">    <span class="keyword">if</span> (lock.l_type != F_UNLCK)</span><br><span class="line">        report_and_exit(<span class="string">&quot;file is still write locked...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    lock.l_type = F_RDLCK; <span class="comment">/* prevents any writing during the reading */</span></span><br><span class="line">    <span class="keyword">if</span> (fcntl(fd, F_SETLK, &amp;lock) &lt; <span class="number">0</span>)</span><br><span class="line">        report_and_exit(<span class="string">&quot;can&#x27;t get a read-only lock...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Read the bytes (they happen to be ASCII codes) one at a time. */</span></span><br><span class="line">    <span class="type">int</span> c;                           <span class="comment">/* buffer for read bytes */</span></span><br><span class="line">    <span class="keyword">while</span> (read(fd, &amp;c, <span class="number">1</span>) &gt; <span class="number">0</span>)      <span class="comment">/* 0 signals EOF */</span></span><br><span class="line">        write(STDOUT_FILENO, &amp;c, <span class="number">1</span>); <span class="comment">/* write one byte to the standard output */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Release the lock explicitly. */</span></span><br><span class="line">    lock.l_type = F_UNLCK;</span><br><span class="line">    <span class="keyword">if</span> (fcntl(fd, F_SETLK, &amp;lock) &lt; <span class="number">0</span>)</span><br><span class="line">        report_and_exit(<span class="string">&quot;explicit unlocking failed...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者程序首先检查文件是否被独占锁定，然后才尝试获得共享锁。<code>fcntl</code> 调用中指定的 <code>F_GETLK</code> 操作检查锁，在本例中，是上面第一个语句中以 <code>F_WRLCK</code> 形式给出的独占锁。如果指定的锁不存在，则 <code>fcntl</code> 调用会自动将锁类型字段更改为 <code>F_UNLCK</code> 以指示这一事实。如果文件被独占锁定，则消费者终止（该程序的更强大版本可能会让消费者稍微休息一下，然后重试几次）。</p>
<p>如果文件当前未锁定，则消费者尝试获取共享（只读）锁 <code>F_RDLCK</code>。获得共享锁后，消费者程序从文件中一次读取一个字节，将字节打印到标准输出，释放锁，关闭文件，然后终止。</p>
<blockquote>
<p>为了缩短程序，尝试获取共享（只读）锁后，可以删除对 <code>fcntl</code> 的 <code>F_GETLK</code> 调用，因为如果其他某个进程已持有互斥（读写）锁，则 <code>F_RDLCK</code> 赋值操作不会成功。</p>
</blockquote>
<h3 id="特点">特点</h3>
<p>共享文件的内容可能是大量的、任意字节（例如数字化电影），这使得文件共享成为一种非常灵活的 IPC 机制。<strong>缺点是文件访问无论是读还是写都比较慢</strong>。下一个示例通过共享内存（而不是共享文件）展现了 IPC 的优势，并相应提高了性能。</p>
<h2 id="Shared-memory">Shared memory</h2>
<p>默认情况下，<strong>为共享内存提供的 POSIX API 将共享内存实现为内存映射文件：对于共享内存段，系统维护一个具有相应内容的后备文件（backing file）</strong>。POSIX 下的共享内存可以在没有后备文件的情况下进行配置，但这可能会影响可移植性。</p>
<p>下面的示例使用带有支持后备文件的 POSIX API，它 <strong> 结合了内存访问（速度）和文件存储（持久性）的优点</strong>。</p>
<p>共享内存示例有两个程序，名为 <em>memwriter</em> 和 <em>memreader</em>，并 <strong> 使用信号量来协调（同步）它们对共享内存的访问</strong>——因为无论是在多进程还是多线程中，基于内存的竞态条件的风险也是如此。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file shmem.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ByteSize 512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BackingFile <span class="string">&quot;/shMemEx&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AccessPerms 0644</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SemaphoreName <span class="string">&quot;mysemaphore&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MemContents <span class="string">&quot;This is the way the world ends...\n&quot;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="memwriter">memwriter</h3>
<p>Example 3. source code for the memwriter process <em>memwriter.c</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Compilation: gcc -o memwriter memwriter.c -lrt -lpthread **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shmem.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">report_and_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span> &#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = shm_open(BackingFile,      <span class="comment">/* name from smem.h */</span></span><br><span class="line">                      O_RDWR | O_CREAT, <span class="comment">/* read/write, create if needed */</span></span><br><span class="line">                      AccessPerms);     <span class="comment">/* access permissions (0644) */</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        report_and_exit(<span class="string">&quot;Can&#x27;t open shared mem segment...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ftruncate(fd, ByteSize); <span class="comment">/* get the bytes */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">caddr_t</span> memptr = mmap(<span class="literal">NULL</span>,                   <span class="comment">/* let system pick where to put segment */</span></span><br><span class="line">                          ByteSize,               <span class="comment">/* how many bytes */</span></span><br><span class="line">                          PROT_READ | PROT_WRITE, <span class="comment">/* access protections */</span></span><br><span class="line">                          MAP_SHARED,             <span class="comment">/* mapping visible to other processes */</span></span><br><span class="line">                          fd,                     <span class="comment">/* file descriptor */</span></span><br><span class="line">                          <span class="number">0</span>);                     <span class="comment">/* offset: start at 1st byte */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">caddr_t</span>)<span class="number">-1</span> == memptr)</span><br><span class="line">        report_and_exit(<span class="string">&quot;Can&#x27;t get segment...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;shared mem address: %p [0..%d]\n&quot;</span>, memptr, ByteSize - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;backing file:       /dev/shm%s\n&quot;</span>, BackingFile);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* semahore code to lock the shared mem */</span></span><br><span class="line">    <span class="type">sem_t</span>* semptr = sem_open(SemaphoreName, <span class="comment">/* name */</span></span><br><span class="line">                             O_CREAT,       <span class="comment">/* create the semaphore */</span></span><br><span class="line">                             AccessPerms,   <span class="comment">/* protection perms */</span></span><br><span class="line">                             <span class="number">0</span>);            <span class="comment">/* initial value */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">void</span>*)<span class="number">-1</span> == semptr)</span><br><span class="line">        report_and_exit(<span class="string">&quot;sem_open&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(memptr, MemContents); <span class="comment">/* copy some ASCII bytes to the segment */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* increment the semaphore so that memreader can read */</span></span><br><span class="line">    <span class="keyword">if</span> (sem_post(semptr) &lt; <span class="number">0</span>)</span><br><span class="line">        report_and_exit(<span class="string">&quot;sem_post&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">12</span>); <span class="comment">/* give reader a chance */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* clean up */</span></span><br><span class="line">    munmap(memptr, ByteSize); <span class="comment">/* unmap the storage */</span></span><br><span class="line">    close(fd);</span><br><span class="line">    sem_close(semptr);</span><br><span class="line">    shm_unlink(BackingFile); <span class="comment">/* unlink from the backing file */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二进制信号量是一种特殊情况，只需要两个值：0 和 1，充当互斥锁。共享内存示例使用信号量作为互斥体。当信号量的值为 0 时，只有 memwriter 可以访问共享内存。写入后，该进程会增加信号量的值，从而允许 memreader 读取共享内存。</p>
<p>以下概述了 memwriter 和 memreader 程序如何通过共享内存进行通信：</p>
<p>1）如上所示，memwriter 程序调用 <code>shm_open</code> 函数来获取系统与共享内存协调的 backing file 的文件描述符。<strong>此时，还没有分配任何内存</strong>。随后调用名称具有误导性的函数 <code>ftruncate</code> 分配 <code>ByteSize</code> 字节。</p>
<ul>
<li>memwriter 和 memreader 程序 <strong> 仅访问共享内存，而不访问后备文件。系统负责同步共享内存和后备文件</strong>。</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="type">int</span> <span class="title function_">shm_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflag, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line">   <span class="type">int</span> <span class="title function_">shm_unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   <span class="title function_">shm_open</span><span class="params">()</span> creates and opens a new, or opens an existing, POSIX</span><br><span class="line">   shared memory object.  A POSIX shared memory object is in effect</span><br><span class="line">   a handle which can be used by unrelated processes to <span class="title function_">mmap</span><span class="params">(<span class="number">2</span>)</span> the</span><br><span class="line">   same region of shared memory.  The <span class="title function_">shm_unlink</span><span class="params">()</span> function performs</span><br><span class="line">   the converse operation, removing an object previously created by</span><br><span class="line">   <span class="title function_">shm_open</span><span class="params">()</span>.</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">ftruncate</span><span class="params">(<span class="type">int</span> fildes, <span class="type">off_t</span> length)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   If fildes is not a valid file descriptor open <span class="keyword">for</span> writing, the</span><br><span class="line">   <span class="title function_">ftruncate</span><span class="params">()</span> function shall fail.</span><br><span class="line"></span><br><span class="line">   If fildes refers to a regular file, the <span class="title function_">ftruncate</span><span class="params">()</span> function</span><br><span class="line">   shall cause the size of the file to be truncated to length.  If</span><br><span class="line">   the size of the file previously exceeded length, the extra data</span><br><span class="line">   shall no longer be available to reads on the file. If the file</span><br><span class="line">   previously was smaller than this size, <span class="title function_">ftruncate</span><span class="params">()</span> shall increase</span><br><span class="line">   the size of the file. If the file size is increased, the extended</span><br><span class="line">   area shall appear as <span class="keyword">if</span> it were zero-filled. The value of the</span><br><span class="line">   seek pointer shall not be modified by a call to <span class="title function_">ftruncate</span><span class="params">()</span>.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>2）然后 memwriter <strong>调用 <code>mmap</code> 函数，获取指向共享内存的指针</strong>。指针类型 <code>caddr_t</code> 以 c 开头，代表 calloc，这是一个将动态分配的存储初始化为零（initializes dynamically allocated storage to zeroes）的系统函数。</p>
<ul>
<li><code>mmap</code> 的第一个参数是 NULL，这意味着系统决定在虚拟地址空间中分配内存的位置。</li>
<li><code>MAP_SHARED</code> 标志指示分配的内存可在进程之间共享，最后一个参数（在本例中为零）意味着共享内存的偏移量应该是第一个字节。</li>
<li>size 参数指定要分配的字节数，protection 参数指示共享内存可以写入和读取。</li>
<li>函数执行成功后，系统在 <code>/dev/shm</code> 目录下创建并维护后备文件 <code>/shMemEx</code></li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> addr[.length], <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">           <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line">   <span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> addr[.length], <span class="type">size_t</span> length)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   <span class="title function_">mmap</span><span class="params">()</span> creates a new mapping in the virtual address space of the</span><br><span class="line">   calling process.  The starting address <span class="keyword">for</span> the new mapping is</span><br><span class="line">   specified in addr.  The length argument specifies the length of</span><br><span class="line">   the <span class="title function_">mapping</span> <span class="params">(which must be greater than <span class="number">0</span>)</span>.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>3）此时，memwriter 已准备好写入，但它首先创建一个信号量以确保对共享内存的独占访问。如果对 <code>sem_open</code> 的调用成功，然后就可以处理写操作了。</p>
<ul>
<li>在 memwriter 和 memreader 进程中，通过 <strong> 调用 sem_open 时使用相同的名称标识，可以访问同一个信号量</strong>。</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="type">sem_t</span> *<span class="title function_">sem_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflag)</span>;</span><br><span class="line">   <span class="type">sem_t</span> *<span class="title function_">sem_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflag,</span></span><br><span class="line"><span class="params">                   <span class="type">mode_t</span> mode, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   <span class="title function_">sem_open</span><span class="params">()</span> creates a new POSIX semaphore or opens an existing</span><br><span class="line">   semaphore.  The semaphore is identified by name.</span><br><span class="line"></span><br><span class="line">   The oflag argument specifies flags that control the operation of</span><br><span class="line">   the call.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>4）写入后，memwriter 通过 <code>sem_post()</code> 将信号量值增加到 1。增加信号量会释放互斥锁，并使 memreader 能够执行其读取操作。</p>
<p>5）最后，memwriter 进程还从 memwriter 地址空间取消共享内存的映射，这会阻止 memwriter 进一步访问共享内存；以及其它关闭操作。</p>
<ul>
<li>如果省略 <code>shm_unlink</code> 语句，则后备文件在程序终止后仍然存在。</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   The <span class="title function_">munmap</span><span class="params">()</span> function shall remove any mappings <span class="keyword">for</span> those entire</span><br><span class="line">   pages containing any part of the address space of the process</span><br><span class="line">   starting at addr and continuing <span class="keyword">for</span> len bytes. Further references</span><br><span class="line">   to these pages shall result in the generation of a SIGSEGV signal</span><br><span class="line">   to the process.  If there are no mappings in the specified</span><br><span class="line">   address range, then <span class="title function_">munmap</span><span class="params">()</span> has no effect.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在 memwriter 和 memreader 程序中，主要感兴趣的共享内存函数是 <code>shm_open</code> 和 <code>mmap</code>：如果成功，第一个调用将返回后备文件的文件描述符，第二个调用将使用该文件描述符来获取指向共享内存的指针部分。</p>
<h3 id="memreader">memreader</h3>
<p>Example 4. source code for the memreader process <em>memreader</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Compilation: gcc -o memreader memreader.c -lrt -lpthread **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shmem.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">report_and_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span> &#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = shm_open(BackingFile, O_RDWR, AccessPerms); <span class="comment">/* empty to begin */</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        report_and_exit(<span class="string">&quot;Can&#x27;t get file descriptor...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get a pointer to memory */</span></span><br><span class="line">    <span class="type">caddr_t</span> memptr = mmap(<span class="literal">NULL</span>,                   <span class="comment">/* let system pick where to put segment */</span></span><br><span class="line">                          ByteSize,               <span class="comment">/* how many bytes */</span></span><br><span class="line">                          PROT_READ | PROT_WRITE, <span class="comment">/* access protections */</span></span><br><span class="line">                          MAP_SHARED,             <span class="comment">/* mapping visible to other processes */</span></span><br><span class="line">                          fd,                     <span class="comment">/* file descriptor */</span></span><br><span class="line">                          <span class="number">0</span>);                     <span class="comment">/* offset: start at 1st byte */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">caddr_t</span>)<span class="number">-1</span> == memptr)</span><br><span class="line">        report_and_exit(<span class="string">&quot;Can&#x27;t access segment...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create a semaphore for mutual exclusion */</span></span><br><span class="line">    <span class="type">sem_t</span>* semptr = sem_open(SemaphoreName, <span class="comment">/* name */</span></span><br><span class="line">                             O_CREAT,       <span class="comment">/* create the semaphore */</span></span><br><span class="line">                             AccessPerms,   <span class="comment">/* protection perms */</span></span><br><span class="line">                             <span class="number">0</span>);            <span class="comment">/* initial value */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">void</span>*)<span class="number">-1</span> == semptr)</span><br><span class="line">        report_and_exit(<span class="string">&quot;sem_open&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* use semaphore as a mutex (lock) by waiting for writer to increment it */</span></span><br><span class="line">    <span class="keyword">if</span> (!sem_wait(semptr)) &#123; <span class="comment">/* wait until semaphore != 0 */</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(MemContents); i++)</span><br><span class="line">            write(STDOUT_FILENO, memptr + i, <span class="number">1</span>); <span class="comment">/* one byte at a time */</span></span><br><span class="line">        sem_post(semptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* cleanup */</span></span><br><span class="line">    munmap(memptr, ByteSize);</span><br><span class="line">    close(fd);</span><br><span class="line">    sem_close(semptr);</span><br><span class="line">    unlink(BackingFile);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与 memwriter 一样，memreader 在调用 <code>sem_open</code> 时 <strong> 通过其名称来访问信号量</strong>。但是 memreader 然后进入等待状态，直到 memwriter 递增信号量。一旦等待结束，memreader 就会从共享内存中读取 ASCII 字节，随后进行清理并终止。</p>
<blockquote>
<p>共享内存 API 包含显式同步共享内存段和后备文件的操作 <code>msync(NULL, ByteSize, MS_SYNC)</code>。示例中省略了这些操作，以减少混乱并将重点放在内存共享和信号量代码上。</p>
</blockquote>
<h3 id="输出">输出</h3>
<p>先执行 memwriter 进程，然后执行 memreader 进程，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">% ./memwriter</span><br><span class="line">shared mem address: 0x7f924123f000 [0..511]</span><br><span class="line">backing file:       /dev/shm/shMemEx</span><br><span class="line">(...sleep 12s, then to end...)</span><br><span class="line">% </span><br><span class="line"></span><br><span class="line">% ./memreader</span><br><span class="line">This is the way the world ends...</span><br><span class="line">% </span><br></pre></td></tr></table></figure>
<h3 id="特点 -v2">特点</h3>
<p>共享文件和共享内存示例展示了进程如何通过共享存储进行通信，一种情况是文件，另一种情况是内存段。这两种方法的 API 都相对简单。这些方法有共同的缺点吗？现代应用程序经常处理流数据，实际上是处理大量数据流。<strong>共享文件和共享内存方法都不太适合海量数据流</strong>。Channels of one type or another are better suited. Next part thus introduces pipes and message queues.</p>
<h1 id="Pipes">Pipes</h1>
<p>本节转向管道，管道（pipes）是连接进程进行通信的通道（channels）。一个 channel 有一个用于写入字节的写端（write-end），以及一个用于以 FIFO 顺序读取这些字节的读端（read-end）。在典型使用中，一个进程向 channel 写入数据，而另一个进程从同一 channel 读取数据。</p>
<p>管道有两种类型：命名（named）的和匿名（unnamed）的，<strong>可以在命令行交互式地使用，也可以在程序内部使用</strong>。</p>
<p>一般来说，基于 channel 的 IPC 是并发安全（concurrent-safe）的。</p>
<h2 id="Unnamed-pipes">Unnamed pipes</h2>
<h3 id="在交互式命令行">在交互式命令行</h3>
<p>让我们从一个命令行示例开始，该示例展示了匿名管道的工作原理。在所有现代系统中，<strong>竖线 <code>|</code> 表示命令行中的匿名管道</strong>。假设 % 是命令行提示符，并考虑以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">% <span class="built_in">sleep</span> 5 | <span class="built_in">echo</span> <span class="string">&quot;Hello, world!&quot;</span> <span class="comment">## writer to the left of |, reader to the right</span></span><br></pre></td></tr></table></figure>
<p><code>sleep</code> 和 <code>echo</code> 实用程序作为单独的进程执行，并且匿名管道允许它们进行通信——该示例是人为设计的（没有发生通信）。问候语 <em>Hello, world!</em> 出现在屏幕上；然后，大约五秒钟后，命令行提示符返回，表明 <code>sleep</code> 和 <code>echo</code> 进程都已退出。这是怎么回事？</p>
<p><strong>在命令行的 <code>|</code> 语法中，左侧的进程（<code>sleep</code>）是写者，右侧的进程（<code>echo</code>）是读者。默认情况下，读者会阻塞，直到能从通道读取字节，而写者在写入字节后，通过发送流结束标记来完成（即使写者提前终止，流结束标记也会发送给读者）。匿名管道将持续存在，直到写者和读者都终止</strong>。</p>
<blockquote>
<p>刚刚不是说“默认情况下，读者会阻塞，直到能从通道读取字节”吗？那为什么是立即打印呢？</p>
<p><code>sleep</code> 进程不会向通道写入任何字节，但会在大约五秒后终止，这会向通道发送流结束标记。同时，<code>echo</code> 进程立即将问候语写入标准输出（屏幕），因为该进程不会从通道读取任何字节，因此无需等待。</p>
</blockquote>
<p>两个需要通信的例子，写者写入字节、读者从管道中读取字节：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">% <span class="built_in">sleep</span> 5 &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;Data printed after waiting&quot;</span> &amp;&amp; <span class="built_in">sleep</span> 3 | <span class="built_in">echo</span> <span class="string">&quot;hello world!&quot;</span> | <span class="built_in">cat</span></span><br><span class="line">Data printed after waiting (5s-th)</span><br><span class="line">hello world! (5s-th)</span><br><span class="line">% (8s-th)</span><br><span class="line"></span><br><span class="line">% <span class="built_in">cat</span> test.txt</span><br><span class="line">this</span><br><span class="line">is</span><br><span class="line">the</span><br><span class="line">way</span><br><span class="line">the</span><br><span class="line">world</span><br><span class="line">ends</span><br><span class="line">% <span class="built_in">cat</span> test.txt | <span class="built_in">sort</span> | <span class="built_in">uniq</span></span><br><span class="line">ends</span><br><span class="line">is</span><br><span class="line">the</span><br><span class="line">this</span><br><span class="line">way</span><br><span class="line">world</span><br><span class="line">%</span><br></pre></td></tr></table></figure>
<h3 id="在程序内部">在程序内部</h3>
<p>Example 1. a <em>pipeUN.c</em> with two processes communicating through an unnamed pipe.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span> <span class="comment">/* wait */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>   <span class="comment">/* exit functions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>   <span class="comment">/* read, write, pipe, _exit */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ReadEnd  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WriteEnd 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">report_and_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span> &#123;</span><br><span class="line">  perror(msg);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">-1</span>);    <span class="comment">/** failure **/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> pipeFDs[<span class="number">2</span>]; <span class="comment">/* two file descriptors */</span></span><br><span class="line">  <span class="type">char</span> buf;       <span class="comment">/* 1-byte buffer */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* msg = <span class="string">&quot;Nature&#x27;s first green is gold\n&quot;</span>; <span class="comment">/* bytes to write */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pipe(pipeFDs) &lt; <span class="number">0</span>) report_and_exit(<span class="string">&quot;pipeFD&quot;</span>);</span><br><span class="line">  <span class="type">pid_t</span> cpid = fork();                                <span class="comment">/* fork a child process */</span></span><br><span class="line">  <span class="keyword">if</span> (cpid &lt; <span class="number">0</span>) report_and_exit(<span class="string">&quot;fork&quot;</span>);              <span class="comment">/* check for failure */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> == cpid) &#123;    <span class="comment">/*** child ***/</span>                 <span class="comment">/* child process */</span></span><br><span class="line">    close(pipeFDs[WriteEnd]);                         <span class="comment">/* child reads, doesn&#x27;t write */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (read(pipeFDs[ReadEnd], &amp;buf, <span class="number">1</span>) &gt; <span class="number">0</span>)       <span class="comment">/* read until end of byte stream */</span></span><br><span class="line">      write(STDOUT_FILENO, &amp;buf, <span class="keyword">sizeof</span>(buf));        <span class="comment">/* echo to the standard output */</span></span><br><span class="line"></span><br><span class="line">    close(pipeFDs[ReadEnd]);                          <span class="comment">/* close the ReadEnd: all done */</span></span><br><span class="line">    _exit(<span class="number">0</span>);                                         <span class="comment">/* exit and notify parent at once  */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;              <span class="comment">/*** parent ***/</span></span><br><span class="line">    close(pipeFDs[ReadEnd]);                          <span class="comment">/* parent writes, doesn&#x27;t read */</span></span><br><span class="line"></span><br><span class="line">    write(pipeFDs[WriteEnd], msg, <span class="built_in">strlen</span>(msg));       <span class="comment">/* write the bytes to the pipe */</span></span><br><span class="line">    close(pipeFDs[WriteEnd]);                         <span class="comment">/* done writing: generate eof */</span></span><br><span class="line"></span><br><span class="line">    wait(<span class="literal">NULL</span>);                                       <span class="comment">/* wait for child to exit */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);                                          <span class="comment">/* exit normally */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的 <em>pipeUN.c</em> 程序使用系统函数 <code>fork</code> 来创建进程。尽管程序只有一个源文件，但在（成功）执行期间会发生多处理。</p>
<p>以下是库函数 <code>fork</code> 工作原理的快速回顾：</p>
<p>在父进程中调用的 <code>fork</code> 函数，返回值为整数类型的 <code>pid_t</code> 变量。<strong>如果 <code>fork</code> 调用成功，它就会生成（创建）一个新的子进程，向父进程返回一个值，但向子进程返回一个不同的值。父进程和子进程都执行调用 <code>fork</code> 之后的相同代码，但大概率（人为设计）走向不同的条件分支（通过 <code>fork</code> 成功时的返回值来分流）</strong>。</p>
<ul>
<li>调用 <code>fork</code> 失败时，向父进程返回 -1。</li>
<li><strong>调用 <code>fork</code> 成功时，子进程返回 0、父进程返回子进程的 PID</strong>。</li>
</ul>
<p>如何在程序中使用匿名管道？</p>
<p>使用系统调用 <code>pipe</code> 来创建管道，数组参数用于返回：写入字节的写端（write-end）的文件描述符，以及一个用于以 FIFO 顺序读取这些字节的读端（read-end）的文件描述符。数组索引 0 对应读端文件描述符。索引 1 对应写端文件描述符。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   <span class="title function_">pipe</span><span class="params">()</span> creates a pipe, a unidirectional data channel that can be</span><br><span class="line">   used <span class="keyword">for</span> interprocess communication.  The <span class="built_in">array</span> pipefd is used to</span><br><span class="line">   <span class="keyword">return</span> two file descriptors referring to the ends of the pipe.</span><br><span class="line">   pipefd[0] refers to the read end of the pipe.  pipefd[1] refers</span><br><span class="line">   to the write end of the pipe.  Data written to the write end of</span><br><span class="line">   the pipe is buffered by the kernel until it is read from the read</span><br><span class="line">   end of the pipe.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在这个例子中，父进程负责将数据写入匿名管道，子进程负责从匿名管道读取数据。所以，在各自进程的分支处理中，先把不使用的另一个文件描述符关闭了。</p>
<p><strong>需要注意的细节</strong>：</p>
<p>1）父进程中对 <code>wait(NULL)</code> 函数调用的作用？</p>
<p>虽然，子进程在很大程度上独立于其父进程、子进程可以执行与父进程无关的任意代码。但是，如果子进程终止，系统会通过信号通知父进程。</p>
<p><strong>如果父进程先于子进程终止怎么办？在这种情况下，除非采取预防措施，否则子进程将成为并保持为僵尸进程，并在进程表中残留一个条目</strong>。</p>
<p>预防措施有两大类。<strong>一种预防措施是让父进程通知系统，让其知道：父进程（自己）对子进程的终止没有兴趣</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">signal(SIGCHLD, SIG_IGN); <span class="comment">/* in parent: ignore notification */</span></span><br></pre></td></tr></table></figure>
<p><strong>第二种方法是让父进程执行等待操作，等待任何一个子进程的终止，从而确保父进程的寿命比子进程的寿命长</strong>。</p>
<p><strong>wait() 系统调用</strong></p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *_Nullable wstatus)</span>;</span><br><span class="line">   <span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *_Nullable wstatus, <span class="type">int</span> options)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   All of these system calls are used to wait <span class="keyword">for</span> state changes in a</span><br><span class="line">   child of the calling process, and obtain information about the</span><br><span class="line">   child whose state has changed.  A state change is considered to</span><br><span class="line">   be: the child terminated; the child was stopped by a signal; or</span><br><span class="line">   the child was resumed by a signal.  In the <span class="keyword">case</span> of a terminated</span><br><span class="line">   child, performing a wait allows the system to release the</span><br><span class="line">   resources associated with the child; <span class="keyword">if</span> a wait is not performed,</span><br><span class="line">   then the terminated child remains in a <span class="string">&quot;zombie&quot;</span> state (see NOTES</span><br><span class="line">   below).</span><br></pre></td></tr></table></figure>
</blockquote>
<p>系统调用 <code>wait()</code> 用于调用进程的子进程的状态改变时，获取它的状态：子进程终止、子进程通过信号被暂停、子进程通过信号被恢复。“子进程终止” 状态下，允许系统释放分配给子进程的资源，以防止子进程成为僵尸进程。</p>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> wstatus;</span><br><span class="line"><span class="type">pid_t</span> wc = wait(&amp;wstatus);  <span class="comment">// wait code</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;parent process (PID: %d), wc: %d, wstatus: %d, wait if normal exited: %s\n&quot;</span>, \</span><br><span class="line">        getpid(), wc, wstatus, WIFEXITED(wstatus) ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br></pre></td></tr></table></figure>
<p><em>pipeUN.c</em> 程序还采取了另一种预防措施。当父进程完成等待时，父进程将通过调用常规退出函数来终止。<strong>相比之下，子进程通过调用 <code>_exit</code> 变体来终止，这会快速跟踪终止通知。实际上，子进程会告诉系统：「尽快」通知父进程，自己已经终止</strong>。</p>
<p>2）如果多个进程同时向管道中写入，会不会出现并发（交错）写入？</p>
<p>POSIX 标准确保只要写入不超过 <code>PIPE_BUF</code> 字节（4096 bytes on Linux），写入就不会交错。正如本节一开始说的：基于 channel 的 IPC 是并发安全的。</p>
<h2 id="Named-pipes">Named pipes</h2>
<p>匿名管道没有后备文件：系统维护一个内存缓冲区（in-memory buffer），用于将字节从写者传输到读者。一旦写者和读者终止，缓冲区就会被回收，匿名管道就会消失。相比之下，命名管道有一个后备文件和一个独特的 API。</p>
<p>管道的基本特性是先进先出（FIFO），写入管道的数据会按照顺序被读取。<strong>当写者进程往管道中写入数据时，如果没有读者进程在等待读取数据，写者进程可能会被阻塞，直到有读者进程读取了数据。相反，如果读者进程试图从空管道中读取数据，读者进程也会被阻塞，直到有写者进程向管道中写入数据</strong>。</p>
<h3 id="在交互式命令行 -v2">在交互式命令行</h3>
<p>让我们看另一个命令行示例来了解命名管道的要点。打开两个终端，两者的工作目录应该相同。</p>
<p>终端 1：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">% <span class="built_in">mkfifo</span> tester <span class="comment">## creates a backing file with FIFO named pipes</span></span><br><span class="line">% <span class="built_in">cat</span> tester <span class="comment">## type the pipe&#x27;s contents to stdout</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一开始，终端中不应出现任何内容，因为尚未将任何内容写入命名管道。</p>
<p>终端 2：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">% <span class="built_in">cat</span> &gt; tester <span class="comment">## redirect keyboard input to the pipe</span></span><br><span class="line">hello, world! <span class="comment">## then hit Return key</span></span><br><span class="line"><span class="built_in">bye</span>, <span class="built_in">bye</span> <span class="comment">## ditto</span></span><br><span class="line">&lt;Control-C&gt; <span class="comment">## terminate session with a Control-C</span></span><br></pre></td></tr></table></figure>
<p>在这个终端中输入的任何内容都会在另一个终端中得到回显。输入 Ctrl+C 后，两个终端都会返回常规命令行提示符：管道已关闭。</p>
<p>使用 <code>unlink tester</code> 可以删除并清理已创建的命名管道的文件。</p>
<h3 id="在程序内部 -v2">在程序内部</h3>
<p>Linux 有一个名为 <code>mkfifo</code> 的库函数，它在程序中创建一个命名管道。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   <span class="title function_">mkfifo</span><span class="params">()</span> makes a FIFO special file with name pathname.  mode</span><br><span class="line">   specifies the FIFO&#x27;s permissions.  It is modified by the</span><br><span class="line">   process&#x27;s umask in the usual way: the permissions of the created</span><br><span class="line">   file <span class="title function_">are</span> <span class="params">(mode &amp; ~umask)</span>.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>下面的示例给出两个进程：一个写入数据到命名管道的进程，一个从该管道读取数据并进行业务处理的进程。</p>
<p>Example 2. the fifoWriter program <em>fifoWriter.c</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxLoops 12000 <span class="comment">/* outer loop */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ChunkSize 16   <span class="comment">/* how many written at a time */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IntsPerChunk 4 <span class="comment">/* four 4-byte ints per chunk */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxZs 250      <span class="comment">/* max microseconds to sleep */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pipeName = <span class="string">&quot;./fifoChannel&quot;</span>;</span><br><span class="line">    mkfifo(pipeName, <span class="number">0666</span>);                      <span class="comment">/* read/write for user/group/others */</span></span><br><span class="line">    <span class="type">int</span> fd = open(pipeName, O_CREAT | O_WRONLY); <span class="comment">/* open as write-only */</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/** error **/</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FIFO named pipe has created and opend\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MaxLoops; i++) &#123; <span class="comment">/* write MaxWrites times */</span></span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ChunkSize; j++) &#123; <span class="comment">/* each time, write ChunkSize bytes */</span></span><br><span class="line">            <span class="type">int</span> k;</span><br><span class="line">            <span class="type">int</span> chunk[IntsPerChunk];</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; IntsPerChunk; k++) &#123;</span><br><span class="line">                chunk[k] = rand();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;debug, verify if the writer process is blocked\n&quot;</span>);</span><br><span class="line">            write(fd, chunk, <span class="keyword">sizeof</span>(chunk));</span><br><span class="line">        &#125;</span><br><span class="line">        usleep((rand() % MaxZs) + <span class="number">1</span>); <span class="comment">/* pause a bit for realism */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);        <span class="comment">/* close pipe: generates an end-of-file */</span></span><br><span class="line">    unlink(pipeName); <span class="comment">/* unlink from the implementing file */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%i ints sent to the pipe.\n&quot;</span>, MaxLoops * ChunkSize * IntsPerChunk);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>mkfifo</code> 创建了一个指定名称的后备文件，并指定了文件权限。然后使用熟悉的 <code>open</code> 函数调用打开命名管道，该函数返回一个文件描述符。同时，为了更加真实，<em>fifoWriter.c</em> 不会一次写入所有数据，而是写入一个块，休眠随机微秒数。最后，关闭命名管道后，<em>fifoWriter.c</em> 还会取消文件链接。</p>
<blockquote>
<p>当仅运行了这个进程后，你会发现不会有任何信息被打印到屏幕上，这是因为：如果没有读者进程在等待读取数据，写者进程可能会被阻塞，直到有读者进程读取了数据。</p>
</blockquote>
<p>Example 3. the fifoReader program <em>fifoReader.c</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* not pretty, but gets the job done efficiently */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">is_prime</span><span class="params">(<span class="type">unsigned</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == (n % <span class="number">2</span>) || <span class="number">0</span> == (n % <span class="number">3</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">5</span>; (i * i) &lt;= n; i += <span class="number">6</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == (n % i) || <span class="number">0</span> == (n % (i + <span class="number">2</span>)))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/* found a prime! */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* file = <span class="string">&quot;./fifoChannel&quot;</span>;</span><br><span class="line">    <span class="type">int</span> fd = open(file, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* no point in continuing */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count = <span class="number">0</span>, total = <span class="number">0</span>, primes_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> next;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">ssize_t</span> count = read(fd, &amp;next, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == count) &#123;</span><br><span class="line">            <span class="keyword">break</span>;                         <span class="comment">/* end of stream */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="keyword">sizeof</span>(<span class="type">int</span>)) &#123; <span class="comment">/* read a 4-byte int value */</span></span><br><span class="line">            total++;</span><br><span class="line">            <span class="keyword">if</span> (is_prime(next)) &#123;</span><br><span class="line">                primes_count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);    <span class="comment">/* close pipe from read end */</span></span><br><span class="line">    unlink(file); <span class="comment">/* unlink from the underlying file */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received ints: %u, primes: %u\n&quot;</span>, total, primes_count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 <em>fifoWriter.c</em> 创建命名管道，所以 <em>fifoReader.c</em> 仅需要以只读方式打开后备文件，来访问管道即可。</p>
<p><code>read</code> 调用返回 0 表示结束流（end-of-stream）。在这种情况下，<em>fifoReader.c</em> 会跳出循环，关闭命名管道，并在终止之前取消链接后备文件。</p>
<h3 id="输出 -v2">输出</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">% ./fifoWriter</span><br><span class="line">FIFO named pipe has created and opend  <span class="comment"># run ./fifoReader and print it out</span></span><br><span class="line">debug, verify <span class="keyword">if</span> the writer process is blocked</span><br><span class="line">768000 ints sent to the pipe.</span><br><span class="line"></span><br><span class="line">% ./fifoReader</span><br><span class="line">Received ints: 768000, primes: 37682</span><br></pre></td></tr></table></figure>
<h3 id="特点 -v3">特点</h3>
<p>命名管道是一种高度可靠且高效的 IPC 机制，因此被广泛使用。</p>
<h1 id="Message-queue">Message queue</h1>
<p>管道具有严格的 FIFO 行为：写入的第一个字节是读取的第一个字节，写入的第二个字节是读取的第二个字节，依此类推。<strong>消息队列可以以相同的方式运行，但足够灵活，可以不按 FIFO 顺序检索字节块（byte chunks）</strong>。</p>
<p>顾名思义，消息队列是一个消息序列，每个消息都有两部分：</p>
<ul>
<li>负载（payload），它是一个字节数组；</li>
<li>类型（type），以无符号长整型形式给出；通过类型对消息进行分类，以便灵活检索（<em>通过类型达到不按 FIFO 顺序检索字节块的效果</em>）。</li>
</ul>
<p>考虑以下消息队列，其中每条消息都标有整数类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">          +-+    +-+    +-+    +-+</span><br><span class="line">sender---&gt;|3|---&gt;|2|---&gt;|2|---&gt;|1|---&gt;receiver </span><br><span class="line">          +-+    +-+    +-+    +-+</span><br></pre></td></tr></table></figure>
<p>如果采用严格的 FIFO 行为，则消息将以 1-2-2-3 的顺序接收。然而，消息队列允许其他检索顺序。例如，接收方可以按 3-2-1-2 的顺序检索消息。</p>
<p>Example 4. The header file <em>queue.h</em>, use it in <em>sender.c</em> and <em>receiver.c</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ProjectId 123</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PathName <span class="string">&quot;queue.h&quot;</span> <span class="comment">/* any existing, accessible file would do */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MsgLen 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MsgCount 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> type;                <span class="comment">/* must be of type long */</span></span><br><span class="line">    <span class="type">char</span> payload[MsgLen + <span class="number">1</span>]; <span class="comment">/* bytes in the message */</span></span><br><span class="line">&#125; queuedMessage;</span><br></pre></td></tr></table></figure>
<p><code>ProjectId</code> 可以是任何正整数值，<code>PathName</code> 必须是现有的、可访问的文件。这两个参数用于使用 <code>ftok</code> 函数调用生成 System V IPC key。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="type">key_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span>;</span><br><span class="line">DESCRIPTION</span><br><span class="line">   The <span class="title function_">ftok</span><span class="params">()</span> function uses the identity of the file named by the</span><br><span class="line">   given <span class="title function_">pathname</span> <span class="params">(which must refer to an existing, accessible file)</span></span><br><span class="line">   and the least significant 8 bits of <span class="title function_">proj_id</span> <span class="params">(which must be</span></span><br><span class="line"><span class="params">   nonzero)</span> to generate a <span class="type">key_t</span> type System V IPC key, suitable <span class="keyword">for</span></span><br><span class="line">   use with <span class="title function_">msgget</span><span class="params">(<span class="number">2</span>)</span>, <span class="title function_">semget</span><span class="params">(<span class="number">2</span>)</span>, or <span class="title function_">shmget</span><span class="params">(<span class="number">2</span>)</span>.</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="sender">sender</h2>
<p>Example 5. the message sender program <em>sender.c</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;queue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">report_and_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span> &#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>); <span class="comment">/* EXIT_FAILURE */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(PathName, ProjectId);</span><br><span class="line">    <span class="keyword">if</span> (key &lt; <span class="number">0</span>)</span><br><span class="line">        report_and_exit(<span class="string">&quot;couldn&#x27;t get key...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> qid = msgget(key, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (qid &lt; <span class="number">0</span>)</span><br><span class="line">        report_and_exit(<span class="string">&quot;couldn&#x27;t get queue id...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* payloads[] = &#123;<span class="string">&quot;msg1&quot;</span>, <span class="string">&quot;msg2&quot;</span>, <span class="string">&quot;msg3&quot;</span>, <span class="string">&quot;msg4&quot;</span>, <span class="string">&quot;msg5&quot;</span>, <span class="string">&quot;msg6&quot;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> types[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>&#125;; <span class="comment">/* each must be &gt; 0 */</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MsgCount; i++) &#123;</span><br><span class="line">        <span class="comment">/* build the message */</span></span><br><span class="line">        queuedMessage msg;</span><br><span class="line">        msg.type = types[i];</span><br><span class="line">        <span class="built_in">strcpy</span>(msg.payload, payloads[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* send the message */</span></span><br><span class="line">        msgsnd(qid, &amp;msg, MsgLen + <span class="number">1</span>, IPC_NOWAIT); <span class="comment">/* don&#x27;t block */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s sent as type %i\n&quot;</span>, msg.payload, (<span class="type">int</span>)msg.type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>msgget()</code> 系统调用</strong>：</p>
<ul>
<li>描述：<code>msgget()</code> 系统调用返回与 key 参数值 <strong> 关联的</strong> System V 消息队列标识符。</li>
<li>返回值：成功时，返回消息队列标识符（非负整数）。失败时，返回 -1，并设置 errno 来指示错误。</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   The <span class="title function_">msgget</span><span class="params">()</span> system call returns the System V message <span class="built_in">queue</span></span><br><span class="line">   identifier associated with the value of the key argument.  It may</span><br><span class="line">   be used either to obtain the identifier of a previously created</span><br><span class="line">   message <span class="title function_">queue</span> <span class="params">(when msgflg is zero and key does not have the</span></span><br><span class="line"><span class="params">   value IPC_PRIVATE)</span>, or to create a new <span class="built_in">set</span>.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在 <code>msgget</code> 系统调用中，<code>0666 | IPC_CREAT</code> 表示：</p>
<ul>
<li><code>0666</code>：八进制权限位，指定了消息队列的权限，表示该消息队列将被所有用户读写访问。</li>
<li><code>IPC_CREAT</code>：这是一个标志位，指示如果消息队列不存在，则创建一个新的消息队列。<strong>如果消息队列已经存在，它将被忽略</strong>。</li>
</ul>
<p><strong><code>msgsnd()</code> 系统调用</strong>：</p>
<ul>
<li>描述：<code>msgsnd()</code> 函数应将消息发送到与 msqid 指定的消息队列标识符 <strong> 关联的 </strong> 队列。</li>
<li>返回值：成功完成后，将返回 0；否则，不发送任何消息，返回 -1，并设置 errno 来指示错误。</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   The <span class="title function_">msgsnd</span><span class="params">()</span> function shall send a message to the <span class="built_in">queue</span></span><br><span class="line">   associated with the message <span class="built_in">queue</span> identifier specified by msqid.</span><br><span class="line"></span><br><span class="line">   The application shall ensure that the argument msgp points to a</span><br><span class="line">   user-defined buffer that contains first a field of type <span class="type">long</span></span><br><span class="line">   specifying the type of the message, and then a data portion that</span><br><span class="line">   holds the data bytes of the message. The structure below is an</span><br><span class="line">   example of what this user-defined buffer might look like:</span><br><span class="line"></span><br><span class="line">       <span class="keyword">struct</span> mymsg &#123;</span><br><span class="line">           <span class="type">long</span>   mtype;       <span class="comment">/* Message type. */</span></span><br><span class="line">           <span class="type">char</span>   mtext[<span class="number">1</span>];    <span class="comment">/* Message text. */</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   The structure member mtype is a non-zero positive type <span class="type">long</span> that</span><br><span class="line">   can be used by the receiving process <span class="keyword">for</span> message selection.</span><br><span class="line"></span><br><span class="line">   The structure member mtext is any text of length msgsz bytes. The</span><br><span class="line">   argument msgsz can range from <span class="number">0</span> to a system-imposed maximum.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在本例中，发送方按照 1-1-2-2-3-3 的顺序发送消息，但接收方随后按照 3-1-2-1-3-2 的顺序检索消息，这表明 <strong> 消息队列没有绑定严格的 FIFO 行为</strong>。</p>
<h2 id="receiver">receiver</h2>
<p>Example 6. the message receiver program <em>receiver.c</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;queue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">report_and_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span> &#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>); <span class="comment">/* EXIT_FAILURE */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(PathName, ProjectId); <span class="comment">/* key to identify the queue */</span></span><br><span class="line">    <span class="keyword">if</span> (key &lt; <span class="number">0</span>)</span><br><span class="line">        report_and_exit(<span class="string">&quot;key not gotten...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> qid = msgget(key, <span class="number">0666</span> | IPC_CREAT); <span class="comment">/* access but not create if created already */</span></span><br><span class="line">    <span class="keyword">if</span> (qid &lt; <span class="number">0</span>)</span><br><span class="line">        report_and_exit(<span class="string">&quot;no access to queue...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> types[] = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>&#125;; <span class="comment">/* different than in sender */</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MsgCount; i++) &#123;</span><br><span class="line">        queuedMessage msg; <span class="comment">/* defined in queue.h */</span></span><br><span class="line">        <span class="keyword">if</span> (msgrcv(qid, &amp;msg, MsgLen + <span class="number">1</span>, types[i], MSG_NOERROR | IPC_NOWAIT) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;msgrcv trouble...&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s received as type %i\n&quot;</span>, msg.payload, (<span class="type">int</span>)msg.type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** remove the queue **/</span></span><br><span class="line">    <span class="keyword">if</span> (msgctl(qid, IPC_RMID, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) <span class="comment">/* NULL = &#x27;no flags&#x27; */</span></span><br><span class="line">        report_and_exit(<span class="string">&quot;trouble removing queue...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 <em>sender.c</em> 已经创建了消息队列，所以在 <em>receiver.c</em> 的 <code>msgget</code> 系统调用中，<code>IPC_CREAT</code> 标志位将被忽略。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="type">ssize_t</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp,</span></span><br><span class="line"><span class="params">       <span class="type">int</span> msgflg)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   The <span class="title function_">msgrcv</span><span class="params">()</span> function shall read a message from the <span class="built_in">queue</span></span><br><span class="line">   associated with the message <span class="built_in">queue</span> identifier specified by msqid</span><br><span class="line">   and place it in the user-defined buffer pointed to by msgp.</span><br><span class="line"></span><br><span class="line">   The received message shall be truncated to msgsz bytes <span class="keyword">if</span> it is</span><br><span class="line">   larger than msgsz <span class="title function_">and</span> <span class="params">(msgflg &amp; MSG_NOERROR)</span> is non-zero.  The</span><br><span class="line">   truncated part of the message shall be lost and no indication of</span><br><span class="line">   the truncation shall be given to the calling process.</span><br><span class="line">RETURN VALUE</span><br><span class="line">   Upon successful completion, <span class="title function_">msgrcv</span><span class="params">()</span> shall <span class="keyword">return</span> a value equal</span><br><span class="line">   to the number of bytes actually placed into the buffer mtext.</span><br><span class="line">   Otherwise, no message shall be received, <span class="title function_">msgrcv</span><span class="params">()</span> shall <span class="keyword">return</span></span><br><span class="line">   -1, and errno shall be <span class="built_in">set</span> to indicate the error.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意：<strong>当接收进程通过调用 <code>msgctl</code> 显式删除队列后，队列才会消失</strong>；否则，队列仍然存在（即使写入队列进程已经退出）。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="type">int</span> <span class="title function_">msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   <span class="title function_">msgctl</span><span class="params">()</span> performs the control operation specified by cmd on the</span><br><span class="line">   System V message <span class="built_in">queue</span> with identifier msqid.</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="输出 -v3">输出</h2>
<p>上述代码的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">% ./sender</span><br><span class="line">msg1 sent as type 1</span><br><span class="line">msg2 sent as type 1</span><br><span class="line">msg3 sent as type 2</span><br><span class="line">msg4 sent as type 2</span><br><span class="line">msg5 sent as type 3</span><br><span class="line">msg6 sent as type 3</span><br><span class="line">%</span><br><span class="line"></span><br><span class="line">% ./receiver</span><br><span class="line">msg5 received as type 3</span><br><span class="line">msg1 received as type 1</span><br><span class="line">msg3 received as type 2</span><br><span class="line">msg2 received as type 1</span><br><span class="line">msg6 received as type 3</span><br><span class="line">msg4 received as type 2</span><br><span class="line">%</span><br></pre></td></tr></table></figure>
<p>如果将 <em>receiver.c</em> 代码中的 <code>msgctl</code> 函数调用注释掉，再把 for 循环改成 <code>i &lt; MsgCount/2</code>，则接收方有以下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">% ./receiver</span><br><span class="line">msg5 received as type 3</span><br><span class="line">msg1 received as type 1</span><br><span class="line">msg3 received as type 2</span><br><span class="line">% ./receiver</span><br><span class="line">msg6 received as type 3 # 没接收完，且没显示删除消息队列 -&gt; 还能继续接收</span><br><span class="line">msg2 received as type 1</span><br><span class="line">msg4 received as type 2</span><br><span class="line">% ./receiver</span><br><span class="line">msgrcv trouble... # 消息队列中没有消息了（如果这一步前再执行一次./sender，则这一步还能继续接收到消息）</span><br><span class="line"> received as type 0</span><br><span class="line">msgrcv trouble...</span><br><span class="line"> received as type 0</span><br><span class="line">msgrcv trouble...</span><br><span class="line"> received as type 0</span><br><span class="line">%</span><br></pre></td></tr></table></figure>
<h2 id="特点 -v4">特点</h2>
<p>管道和消息队列的 API 本质上是单向的：一个进程写入，另一个进程读取。虽然也有双向管道的实现，但作者 Marty Kalin 认为 IPC 机制越简单越好。作者认为消息队列仍然是 IPC 工具箱中有用的工具，尽管它们的流行度下降了。</p>
<h1 id="Sockets">Sockets</h1>
<p>正如 pipes 有两种类型（命名和匿名）一样，socket 也是如此。</p>
<ul>
<li>IPC sockets（又名 Unix domain sockets）可以为 <strong> 同一物理设备（主机）上的进程 </strong> 启用基于通道的通信。</li>
<li>Network sockets 可以在 <strong> 不同主机上运行的进程 </strong> 启用基于通道的通信，从而发挥网络作用。</li>
</ul>
<p><strong>Network sockets 需要底层协议的支持</strong>，例如 tcp (transmission control protocol) or the lower-level udp (user datagram protocol)。相比之下，IPC sockets 依赖本地系统内核来支持通信；实际上，<strong>IPC sockets 使用本地文件作为 socket address 进行通信</strong>。尽管存在这些实现差异，但 IPC sockets 和 Network sockets 的 APIs 在本质上是相同的。</p>
<p>配置为流的套接字是双向的（bidirectional），并且控制遵循 client/server 模式：客户端通过尝试连接到服务器来发起对话，服务器尝试接受连接。如果一切正常，来自客户端的请求和来自服务器的响应可以流经通道，直到两端关闭，从而中断连接。</p>
<p>Example 0. The header file <em>sock.h</em>, use it in <em>server.c</em> and <em>client.c</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PortNumber 9876</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxConnects 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BuffSize 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ConversationLen 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Host <span class="string">&quot;127.0.0.1&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>下面的示例涵盖了 Network sockets，但服务器和客户端程序可以在同一台计算机上运行——服务器使用网络地址 localhost (127.0.0.1)，即本地主机地址。</p>
<h2 id="server">server</h2>
<p>Example 1. The socket server <em>server.c</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">report</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> <span class="built_in">terminate</span>)</span> &#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">terminate</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>); <span class="comment">/* failure */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET,     <span class="comment">/* network versus AF_LOCAL */</span></span><br><span class="line">                    SOCK_STREAM, <span class="comment">/* reliable, bidirectional: TCP */</span></span><br><span class="line">                    <span class="number">0</span>);          <span class="comment">/* system picks underlying protocol */</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        report(<span class="string">&quot;socket&quot;</span>, <span class="number">1</span>); <span class="comment">/* terminate */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* bind the server&#x27;s local address in memory */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;saddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(saddr));          <span class="comment">/* clear the bytes */</span></span><br><span class="line">    saddr.sin_family = AF_INET;                <span class="comment">/* versus AF_LOCAL */</span></span><br><span class="line">    saddr.sin_addr.s_addr = htonl(INADDR_ANY); <span class="comment">/* host-to-network endian */</span></span><br><span class="line">    saddr.sin_port = htons(PortNumber);        <span class="comment">/* for listening */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(fd, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="keyword">sizeof</span>(saddr)) &lt; <span class="number">0</span>)</span><br><span class="line">        report(<span class="string">&quot;bind&quot;</span>, <span class="number">1</span>); <span class="comment">/* terminate */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* listen to the socket */</span></span><br><span class="line">    <span class="keyword">if</span> (listen(fd, MaxConnects) &lt; <span class="number">0</span>) <span class="comment">/* listen for clients, up to MaxConnects */</span></span><br><span class="line">        report(<span class="string">&quot;listen&quot;</span>, <span class="number">1</span>);         <span class="comment">/* terminate */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Listening on port %i for clients...\n&quot;</span>, PortNumber);</span><br><span class="line">    <span class="comment">/* a server traditionally listens indefinitely */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">caddr</span>;</span> <span class="comment">/* client address */</span></span><br><span class="line">        <span class="type">int</span> len = <span class="keyword">sizeof</span>(caddr);  <span class="comment">/* address length could change */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> client_fd = accept(fd, (<span class="keyword">struct</span> sockaddr*)&amp;caddr, &amp;len); <span class="comment">/* accept blocks */</span></span><br><span class="line">        <span class="keyword">if</span> (client_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            report(<span class="string">&quot;accept&quot;</span>, <span class="number">0</span>); <span class="comment">/* don&#x27;t terminated, though there&#x27;s a problem */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* read from client */</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ConversationLen; i++) &#123;</span><br><span class="line">            <span class="type">char</span> buffer[BuffSize + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">memset</span>(buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">            <span class="type">int</span> count = read(client_fd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(buffer);</span><br><span class="line">                write(client_fd, buffer, <span class="keyword">sizeof</span>(buffer)); <span class="comment">/* echo as confirmation */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close(client_fd); <span class="comment">/* break connection */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的服务器程序执行经典的四步，<strong>为客户端请求做好准备，然后接受各个请求</strong>。每个步骤（也是调用顺序）：</p>
<ol>
<li><code>socket()</code>：获取套接字连接的文件描述符；</li>
<li><code>bind()</code>：将套接字绑定到服务器主机上的某个地址；</li>
<li><code>listen()</code>：监听客户端的请求；</li>
<li><code>accept()</code>：接受特定客户端的请求。</li>
</ol>
<p><strong>socket() 系统调用</strong>：</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   <span class="title function_">socket</span><span class="params">()</span> creates an endpoint <span class="keyword">for</span> communication and returns a file</span><br><span class="line">   descriptor that refers to that endpoint.  The file descriptor</span><br><span class="line">   returned by a successful call will be the lowest-numbered file</span><br><span class="line">   descriptor not currently open <span class="keyword">for</span> the process.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">   On success, a file descriptor <span class="keyword">for</span> the new socket is returned.  On</span><br><span class="line">   error, -1 is returned, and errno is <span class="built_in">set</span> to indicate the error.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>第一个参数指定网络套接字 <code>AF_INET</code> 而不是 IPC 套接字 <code>AF_LOCAL</code>。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AF_UNIX/AF_LOCAL    Local communication</span><br><span class="line">AF_INET             IPv4 Internet protocols</span><br></pre></td></tr></table></figure>
</blockquote>
<p>第二个参数有多个选项，但 <code>SOCK_STREAM</code> 和 <code>SOCK_DGRAM</code>（数据报）可能是最常用的。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SOCK_STREAM</span><br><span class="line">   Provides sequenced, reliable, two-way, connection-based</span><br><span class="line">   byte streams.  An out-of-band data transmission mechanism</span><br><span class="line">   may be supported.</span><br><span class="line"></span><br><span class="line">SOCK_DGRAM</span><br><span class="line">   Supports datagrams (connectionless, unreliable messages of</span><br><span class="line">   a fixed maximum length).</span><br></pre></td></tr></table></figure>
</blockquote>
<p>第三个参数指定协议。对于这里使用的基于流的套接字——参数 0 代表 TCP。</p>
<p>返回值：因为成功调用套接字会返回熟悉的文件描述符，所以 <strong> 套接字的写入和读取语法与本地文件等相同</strong>。</p>
<p><strong>bind() 系统调用</strong>：</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   When a socket is created with <span class="title function_">socket</span><span class="params">(<span class="number">2</span>)</span>, it exists in a name</span><br><span class="line">   <span class="title function_">space</span> <span class="params">(address family)</span> but has no address assigned to it.  <span class="title function_">bind</span><span class="params">()</span></span><br><span class="line">   assigns the address specified by addr to the socket referred to</span><br><span class="line">   by the file descriptor sockfd.  addrlen specifies the size, in</span><br><span class="line">   bytes, of the address structure pointed to by addr.</span><br><span class="line">   Traditionally, this operation is called “assigning a name to a</span><br><span class="line">   socket”.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">   On success, zero is returned.  On error, -1 is returned, and</span><br><span class="line">   errno is <span class="built_in">set</span> to indicate the error.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>功能：<code>bind()</code> 系统调用将 sockfd 套接字 <strong> 绑定到分配的内存地址 addr 上</strong>。</p>
<p><strong>动态分配一个端口号</strong>：</p>
<p>对于网络套接字，如果套接字地址结构中的端口号（如 sin_port of struct sockaddr_in）被指定为 0，则在 <code>bind()</code> 系统调用时，OS 会自动为套接字分配一个可用的临时端口号（如果 OS 定义的临时端口范围内的所有端口号丢已经被其他套接字使用，则会发生“EADDRINUSE 地址使用错误”）。</p>
<p><strong>动态分配端口后，如何获取这个端口值</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 getsockname 系统调用，获取 fd 绑定到的当前地址（位于 addr 指向的缓冲区中）</span></span><br><span class="line">getsockname(fd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, &amp;<span class="keyword">sizeof</span>(saddr));</span><br><span class="line">port = ntohs(saddr.sin_port); <span class="comment">// 从当前地址中取出指定（或动态分配）的端口号</span></span><br></pre></td></tr></table></figure>
<p><code>getsockname()</code> 系统调用：</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="type">int</span> <span class="title function_">getsockname</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *<span class="keyword">restrict</span> addr,</span></span><br><span class="line"><span class="params">                   <span class="type">socklen_t</span> *<span class="keyword">restrict</span> addrlen)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   <span class="title function_">getsockname</span><span class="params">()</span> returns the current address to which the socket</span><br><span class="line">   sockfd is bound, in the buffer pointed to by addr.  The addrlen</span><br><span class="line">   argument should be initialized to indicate the amount of <span class="title function_">space</span></span><br><span class="line">   <span class="params">(in bytes)</span> pointed to by addr.  On <span class="keyword">return</span> it contains the actual</span><br><span class="line">   size of the socket address.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">   On success, zero is returned.  On error, -1 is returned, and</span><br><span class="line">   errno is <span class="built_in">set</span> to indicate the error.</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>在 <em>server.c</em> 中，<code>bind()</code> 的第二个参数为什么要强转成 <code>struct sockaddr</code> 类型呢</strong>？</p>
<p><code>addr</code> 是一个指向 <code>sockaddr</code> 结构体的指针，用于指定要绑定到 <strong> 套接字的地址信息。这个结构体的具体类型取决于套接字的地址族</strong>（Address Family），通常是 <code>sockaddr_in</code> 结构体（用于 IPv4 地址族）或 <code>sockaddr_un</code> 结构体（用于 UNIX 本地通信域）。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Describes a socket address</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">   <span class="type">sa_family_t</span>     sa_family;      <span class="comment">/* Address family */</span></span><br><span class="line">   <span class="type">char</span>            sa_data[];      <span class="comment">/* Socket address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Internet domain sockets</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">   <span class="type">sa_family_t</span>     sin_family;     <span class="comment">/* AF_INET for Internet domain sockets */</span></span><br><span class="line">   <span class="type">in_port_t</span>       sin_port;       <span class="comment">/* Port number */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>  <span class="title">sin_addr</span>;</span>       <span class="comment">/* IPv4 address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">   <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UNIX domain sockets</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">   <span class="type">sa_family_t</span>     sun_family;     <span class="comment">/* AF_LOCAL(AF_UNIX) for UNIX domain sockets */</span></span><br><span class="line">   <span class="type">char</span>            sun_path[];     <span class="comment">/* Socket pathname */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>listen() 系统调用</strong>：</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   <span class="title function_">listen</span><span class="params">()</span> marks the socket referred to by sockfd as a passive</span><br><span class="line">   socket, that is, as a socket that will be used to accept incoming</span><br><span class="line">   connection requests using <span class="title function_">accept</span><span class="params">(<span class="number">2</span>)</span>.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>作用：<code>listen()</code> 函数是用于使套接字处于监听状态，以便接受来自客户端的连接请求。当调用 <code>listen()</code> 函数时，套接字会由主动套接字（active socket）变为被动套接字（passive socket），从而使其 <strong> 处于监听状态 </strong>。在这个状态下，套接字将开始接受连接请求，但并<strong> 不立即处理这些连接请求 </strong>，而是将它们<strong> 放入内核中的连接队列中等待处理</strong>。</p>
<p>第二个参数 backlog 指定了 OS 在内核中维护的连接队列的最大长度。这个参数决定了同时等待被服务器接受的连接请求的数量。</p>
<p><strong>accept() 系统调用</strong>：</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *_Nullable <span class="keyword">restrict</span> addr,</span></span><br><span class="line"><span class="params">               <span class="type">socklen_t</span> *_Nullable <span class="keyword">restrict</span> addrlen)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   The <span class="title function_">accept</span><span class="params">()</span> system call is used with connection-based socket</span><br><span class="line">   <span class="title function_">types</span> <span class="params">(SOCK_STREAM, SOCK_SEQPACKET)</span>.  It extracts the first</span><br><span class="line">   connection request on the <span class="built_in">queue</span> of pending connections <span class="keyword">for</span> the</span><br><span class="line">   listening socket, sockfd, creates a new connected socket, and</span><br><span class="line">   returns a new file descriptor referring to that socket.  The</span><br><span class="line">   newly created socket is not in the listening state.  The original</span><br><span class="line">   socket sockfd is unaffected by this call.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">   On success, these system calls <span class="keyword">return</span> a file descriptor <span class="keyword">for</span> the</span><br><span class="line">   accepted <span class="title function_">socket</span> <span class="params">(a nonnegative integer)</span>.  On error, -1 is</span><br><span class="line">   returned, errno is <span class="built_in">set</span> to indicate the error, and addrlen is left</span><br><span class="line">   unchanged.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>作用：<code>accept()</code> 函数用于在服务器端接受客户端连接请求。</p>
<ul>
<li>该调用默认为阻塞等待：服务器不执行任何操作，直到客户端尝试连接然后继续。</li>
<li>调用成功时，<strong>返回一个新的套接字文件描述符（a read/write socket）</strong>，用于与客户端进行通信：<strong>服务器使用 read/write socket 读取来自客户端的请求并写回响应</strong>。</li>
</ul>
<p>参数 <code>sockfd</code> 仅用于接受客户端连接。</p>
<p>参数 <code>addr</code> 和 <code>addrlen</code> 用于获取客户端的地址信息。</p>
<ul>
<li>在函数调用之前，需要将一个足够大的 <code>sockaddr</code> 结构体传递给 <code>addr</code> 参数，并将其长度传递给 <code>addrlen</code> 参数。<strong>当 <code>accept()</code> 函数返回时，<code>addr</code> 指向的结构体将被填充为客户端的地址信息，而 <code>addrlen</code> 则会被更新为 <code>addr</code> 结构体的实际长度</strong>。</li>
</ul>
<h2 id="client">client</h2>
<p>Example 2. The socket client <em>client.c</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* books[] = &#123;<span class="string">&quot;War and Peace&quot;</span>, <span class="string">&quot;Pride and Prejudice&quot;</span>, <span class="string">&quot;The Sound and the Fury&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">report</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> <span class="built_in">terminate</span>)</span> &#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">terminate</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>); <span class="comment">/* failure */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/* fd for the socket */</span></span><br><span class="line">    <span class="type">int</span> sockfd = socket(AF_INET,     <span class="comment">/* versus AF_LOCAL */</span></span><br><span class="line">                        SOCK_STREAM, <span class="comment">/* reliable, bidirectional */</span></span><br><span class="line">                        <span class="number">0</span>);          <span class="comment">/* system picks protocol (TCP) */</span></span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>)</span><br><span class="line">        report(<span class="string">&quot;socket&quot;</span>, <span class="number">1</span>); <span class="comment">/* terminate */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* connect to the server: configure server&#x27;s address 1st */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;saddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = inet_addr(Host);</span><br><span class="line">    saddr.sin_port = htons(PortNumber); <span class="comment">/* port number in big-endian */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connect(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="keyword">sizeof</span>(saddr)) &lt; <span class="number">0</span>)</span><br><span class="line">        report(<span class="string">&quot;connect&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write some stuff and read the echoes. */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Connect to server, about to write some stuff...&quot;</span>);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ConversationLen; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (write(sockfd, books[i], <span class="built_in">strlen</span>(books[i])) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* get confirmation echoed from server and print */</span></span><br><span class="line">            <span class="type">char</span> buffer[BuffSize + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">memset</span>(buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">            <span class="keyword">if</span> (read(sockfd, buffer, <span class="keyword">sizeof</span>(buffer)) &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">puts</span>(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Client done, about to exit...&quot;</span>);</span><br><span class="line">    close(sockfd); <span class="comment">/* close the connection */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端程序的代码与服务器的类似。两者之间的主要区别在于客户端既不 listens 也不 accepts，而是 connects。</p>
<p><code>connect()</code> 调用可能会因多种原因而失败，例如：</p>
<ul>
<li>客户端的服务器地址错误。</li>
<li>已经有太多客户端连接到服务器。</li>
</ul>
<p>在这个示例中，如果连接操作成功，客户端将写入请求，然后在 for 循环中读取服务器发回来的回显响应。会话结束后，服务器和客户端都 close the read/write socket（那个 <code>accept()</code> 调用返回的新的套接字文件描述符），尽管任何一方的关闭操作都足以关闭连接。此后客户端退出，但如前所述，服务器仍保持开放状态。</p>
<p><strong>connect() 系统调用</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">    The <span class="title function_">connect</span><span class="params">()</span> system call connects the socket referred to by the</span><br><span class="line">    file descriptor sockfd to the address specified by addr.  The</span><br><span class="line">    addrlen argument specifies the size of addr.  The format of the</span><br><span class="line">    address in addr is determined by the address space of the socket</span><br><span class="line">    sockfd; see <span class="title function_">socket</span><span class="params">(<span class="number">2</span>)</span> <span class="keyword">for</span> further details.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">    If the connection or binding succeeds, zero is returned.  On</span><br><span class="line">    error, -1 is returned, and errno is <span class="built_in">set</span> to indicate the error.</span><br></pre></td></tr></table></figure>
<p>作用：<code>connect()</code> 函数是一个阻塞函数，在连接建立完成之前会阻塞程序的执行。其作用是将客户端的套接字连接到指定的服务器地址和端口上。在调用 <code>connect()</code> 函数之前，客户端需要先创建一个套接字，并调用 <code>bind()</code> 函数绑定到本地地址（如果需要的话），然后才能调用 <code>connect()</code> 函数与服务器建立连接。</p>
<p><strong>inet_addr() 辅助函数</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">    The <span class="title function_">inet_addr</span><span class="params">()</span> function shall convert the <span class="built_in">string</span> pointed to by</span><br><span class="line">    cp, in the standard IPv4 dotted decimal notation, to an integer</span><br><span class="line">    value suitable <span class="keyword">for</span> use as an Internet address.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">    Upon successful completion, <span class="title function_">inet_addr</span><span class="params">()</span> shall <span class="keyword">return</span> the Internet</span><br><span class="line">    address. Otherwise, it shall <span class="title function_">return</span> <span class="params">(<span class="type">in_addr_t</span>)</span><span class="params">(<span class="number">-1</span>)</span>.</span><br></pre></td></tr></table></figure>
<p>作用：<code>inet_addr()</code> 将字符串格式的点分十进制 IPv4 地址，转换为网络地址格式。</p>
<h2 id="输出 -v4">输出</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">% ./server</span><br><span class="line">Listening on port 9876 <span class="keyword">for</span> clients...</span><br><span class="line">War and Peace</span><br><span class="line">Pride and Prejudice</span><br><span class="line">The Sound and the Fury <span class="comment"># while(1) -&gt; 一直监听</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">% ./client</span><br><span class="line">Connect to server, about to write some stuff...</span><br><span class="line">War and Peace</span><br><span class="line">Pride and Prejudice</span><br><span class="line">The Sound and the Fury</span><br><span class="line">Client <span class="keyword">done</span>, about to <span class="built_in">exit</span>...</span><br><span class="line">%</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>套接字示例将请求消息回显给客户端，暗示了服务器和客户端之间 <strong> 进行任意丰富对话的可能性</strong>。也许这就是套接字的主要吸引力。在现代系统中，客户端应用程序（例如数据库客户端）通过套接字与服务器进行通信是很常见的。如前所述，本地 IPC sockets 和 Network sockets 仅在一些实现细节上有所不同；一般来说，IPC sockets 的开销较低，性能较好。两者的通信 API 本质上是相同的。</p>
<h1 id="Signals">Signals</h1>
<p><strong>信号（signal）中断正在执行的程序并与其通信 </strong>：信号是一种用于通知进程发生了某种事件的机制。<u> 当其它进程接收到信号时，OS 会中断进程的正常执行，然后根据接收到的信号执行相应的操作</u>。</p>
<p>除了由 OS 发出信号外，一个进程也可以向另一个进程发送信号，从而使信号成为一种 IPC 机制。大多数信号可以被忽略（阻止）或 <strong> 处理（通过指定的代码）</strong>。</p>
<p>在 UNIX 系统可以通过 kill -l 来查看支持的信号列表，以下是部分信号的功能：</p>
<table>
<thead>
<tr>
<th>信号名</th>
<th>POSIX 标准编号</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGKILL</td>
<td>9</td>
<td>强制终止进程，无法被捕获或忽略</td>
</tr>
<tr>
<td>SIGUSR1</td>
<td>10</td>
<td>用户自定义信号 1</td>
</tr>
<tr>
<td>SIGUSR2</td>
<td>12</td>
<td>用户自定义信号 2</td>
</tr>
<tr>
<td>SIGCHLD</td>
<td>17</td>
<td>子进程状态发生改变</td>
</tr>
<tr>
<td>SIGTERM</td>
<td>15</td>
<td>请求终止进程，通常是正常终止</td>
</tr>
</tbody>
</table>
<blockquote>
<p>用户交互中可能会产生（arise）信号。例如，用户从命令行按下 Ctrl+C 来终止从命令行启动的程序；Ctrl+C 生成 SIGTERM (15) 信号。与 SIGKILL (9) 不同，用于终止的 SIGTERM (15) 可以被阻止或处理。</p>
</blockquote>
<p><strong>kill() 系统调用</strong>：</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   The <span class="title function_">kill</span><span class="params">()</span> system call can be used to send any signal to any</span><br><span class="line">   process group or process.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果函数 <code>kill</code> 的第一个参数大于 0，则该参数被视为目标进程的 PID；如果参数为 0，则该参数标识信号发送者所属的进程组。</p>
<h2 id="shutdown">shutdown</h2>
<p>Example 3. the graceful shutdown of a multi-processing system <em>shutdown.c</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">graceful</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\tChild confirming received signal: %i\n&quot;</span>, signum);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\tChild about to terminate gracefully...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\tChild terminating now...&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>); <span class="comment">/* fast-track notification of parent */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_handler</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">current</span>;</span></span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;current.sa_mask); <span class="comment">/* clear the signal set */</span></span><br><span class="line">    current.sa_flags = <span class="number">0</span>;          <span class="comment">/* enables setting sa_handler, not sa_action */</span></span><br><span class="line">    current.sa_handler = graceful; <span class="comment">/* specify a handler */</span></span><br><span class="line"></span><br><span class="line">    sigaction(SIGTERM, &amp;current, <span class="literal">NULL</span>); <span class="comment">/* register the handler */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">child_code</span><span class="params">()</span> &#123;</span><br><span class="line">    set_handler();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="comment">/** loop until interrupted **/</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\tChild just woke up, but going back to sleep.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">parent_code</span><span class="params">(<span class="type">pid_t</span> cpid)</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Parent sleeping for a time...&quot;</span>);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Try to terminate child. */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == kill(cpid, SIGTERM)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;kill&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    wait(<span class="literal">NULL</span>); <span class="comment">/** wait for child to terminate **/</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;My child terminated, about to exit myself...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> cpid = fork();</span><br><span class="line">    <span class="keyword">if</span> (cpid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == cpid) &#123;</span><br><span class="line">        child_code();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent_code(cpid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，来自父进程的 SIGTERM 信号（通过 <code>kill()</code> 系统调用），导致子进程优雅地执行信号处理 callback 函数。父进程等待子进程正常终止后，自身也正常终止。</p>
<p>对于信号处理，该示例使用 <code>sigaction</code> 函数（POSIX 推荐的），而不是 <code>signal</code> 信号函数（它存在可移植性问题）。</p>
<p><strong>struct sigaction 数据结构</strong>：</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">   <span class="type">void</span>     (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">   <span class="type">void</span>     (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line">   <span class="type">sigset_t</span> sa_mask;</span><br><span class="line">   <span class="type">int</span>      sa_flags;</span><br><span class="line">   <span class="type">void</span>     (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><code>sa_flags</code>：整数值，包含了一些标志位，用于控制信号处理的行为。</li>
<li><code>sa_mask</code>：信号集，用于在执行信号处理函数期间阻止其他特定信号的发送。</li>
<li><code>sa_handler</code>：函数指针，指向一个简单的信号处理函数，接收一个信号编号。当 <code>sa_flags</code> 没有设置 <code>SA_SIGINFO</code> 标志时使用。</li>
<li><code>sa_sigaction</code>：函数指针，指向一个更复杂的信号处理函数。当 <code>sa_flags</code> 设置了 <code>SA_SIGINFO</code> 标志时使用。</li>
</ul>
<p><strong>sigaction() 系统调用</strong>：</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">   The <span class="title function_">sigaction</span><span class="params">()</span> system call is used to change the action taken by</span><br><span class="line">   a process on receipt of a specific signal.</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><code>signum</code>：指定了要捕获的信号的编号。比如，<code>SIGTERM</code> 代表终止信号等。</li>
<li><code>act</code>：一个指向 <code>struct sigaction</code> 结构的指针，该结构定义了新的信号处理程序和一些信号处理的选项。如果想要忽略信号，可以将 <code>act</code> 设置为 <code>NULL</code>。</li>
<li><code>oldact</code>：用于存储以前关联的信号处理程序信息，以供后续使用。如果不需要此信息，也可以将其设置为 <code>NULL</code>。</li>
</ul>
<h2 id="输出 -v5">输出</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">% ./shutdown</span><br><span class="line">Parent sleeping <span class="keyword">for</span> a time...</span><br><span class="line">        Child just woke up, but going back to <span class="built_in">sleep</span>.</span><br><span class="line">        Child just woke up, but going back to <span class="built_in">sleep</span>.</span><br><span class="line">        Child just woke up, but going back to <span class="built_in">sleep</span>.</span><br><span class="line">        Child just woke up, but going back to <span class="built_in">sleep</span>.</span><br><span class="line">        Child confirming received signal: 15</span><br><span class="line">        Child about to terminate gracefully...</span><br><span class="line">        Child terminating now...</span><br><span class="line">My child terminated, about to <span class="built_in">exit</span> myself...</span><br><span class="line">% </span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://opensource.com/sites/default/files/gated-content/inter-process_communication_in_linux.pdf">A guide to inter-process communication in Linux</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
        <category>多进程编程</category>
      </categories>
      <tags>
        <tag>多进程编程</tag>
        <tag>进程间通信</tag>
      </tags>
  </entry>
</search>
